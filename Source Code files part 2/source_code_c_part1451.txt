		 return TRUE;
	}
	else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smtpadm.rc
//
#define IDS_SMTPADMIN_DESC              1
#define IDS_SMTPADMIN_SERVICE_DESC      2
#define IDS_SMTPADMIN_VIRTUALSERVER_DESC 3
#define IDS_SMTPADMIN_VIRTUALDIRECTORY_DESC 4
#define IDS_SMTPADMIN_SESSIONS_DESC     5
#define IDS_SMTPADMIN_ALIAS_DESC        6
#define IDS_SMTPADMIN_USER_DESC         7
#define IDS_SMTPADMIN_DL_DESC           8
#define IDS_SMTPADMIN_DOMAIN_DESC       9
#define IDS_TCPACCESS_DESC              10
#define IDS_TCPACCESSEXCEPTIONS_DESC    11
#define IDS_TCPACCESSEXCEPTION_DESC     12
#define IDS_SMTPEXCEPTION_DIDNT_ENUMERATE 200
#define IDS_SMTPEXCEPTION_DIDNT_SET_CURSOR 201
#define IDS_SMTPEXCEPTION_INVALID_INDEX 202
#define IDS_SMTPEXCEPTION_MUST_SUPPLY_USERNAME_OR_IPADDRESS 203
#define IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO 204
#define IDS_SMTPEXCEPTION_DIDNT_CALL_GET 205
#define IDS_SMTPEXCEPTION_STRING_TOO_LONG 206
#define IDS_SMTPEXCEPTION_PROPERTY_OUT_OF_RANGE 207
#define IDS_SMTPEXCEPTION_DIDNT_FIND    208
#define LANGID_US                       0409
#define IDS_UNKNOWN_ERROR               500
#define IDS_SMTPEXCEPTION_INVALID_ADDRESS 501
#define IDS_SMTPEXCEPTION_CANT_DEL_DEFAULT_DOMAIN 502

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\oleutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.cpp

Abstract:

	Provides Useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "iadm.h"
#include "oleutil.h"
#include "cmultisz.h"
#include "resource.h"

//$-------------------------------------------------------------------
//
//	UpdateChangedMask
//
//	Description:
//
//		Marks a field as changed in the given bit vector
//
//	Parameters:
//
//		pbvChangedProps - points to the bit vector
//		dwBitMask - Bit to turn on. (must have only one bit on)
//
//--------------------------------------------------------------------

static void UpdateChangedMask ( DWORD * pbvChangedProps, DWORD dwBitMask )
{
	if ( pbvChangedProps == NULL ) {
		// Legal, means that the caller doesn't want change tracking.

		return;
	}

	_ASSERT ( dwBitMask != 0 );

	*pbvChangedProps |= dwBitMask;
}

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaLongs );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaLongs ) == 1 );

	SafeArrayGetLBound ( psaLongs, 1, &lLBound );
	SafeArrayGetUBound ( psaLongs, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		long		lTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaLongs, &i, &lTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_I4;
		V_I4 (&var) = lTemp;

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaStrings );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaStrings ) == 1 );

	SafeArrayGetLBound ( psaStrings, 1, &lLBound );
	SafeArrayGetUBound ( psaStrings, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaStrings, &i, &strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_BSTR;
		V_BSTR (&var) = ::SysAllocString ( strTemp );

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings )
{
	_ASSERT ( psaVariants );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaStrings;

	_ASSERT ( SafeArrayGetDim ( psaVariants ) == 1 );
	
	*ppsaStrings = NULL;

	SafeArrayGetLBound ( psaVariants, 1, &lLBound );
	SafeArrayGetUBound ( psaVariants, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaStrings = SafeArrayCreate ( VT_BSTR, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		strTemp = V_BSTR (&var);

		hr = SafeArrayPutElement ( psaStrings, &i, strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear (&var);
	}

	*ppsaStrings = psaStrings;
Exit:
	return hr;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGet < BSTR, long, DWORD, DATE >
//
//	Description:
//
//		Performs a default Property Get on a BSTR, long, DWORD or 
//		Ole DATE.
//
//	Parameters:
//
//		Property	- The property to get.
//		pOut		- The resulting copy.
//
//	Returns:
//
//		E_POINTER		- invalid arguments
//		E_OUTOFMEMORY	- Not enough memory to copy
//		NOERROR			- success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGet ( const BSTR strProperty, BSTR * pstrOut )
{
	TraceQuietEnter ( "StdPropertyGet <BSTR>" );

	_ASSERT ( pstrOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	if ( pstrOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		return E_POINTER;
	}

	*pstrOut = NULL;

	if ( strProperty == NULL ) {

		// If the property is NULL, use a blank string:
		*pstrOut = ::SysAllocString ( _T("") );
	}
	else {
		_ASSERT ( IS_VALID_STRING ( strProperty ) );

		// Copy the property into the result:
		*pstrOut = ::SysAllocString ( strProperty );
	}

	if ( *pstrOut == NULL ) {

		// Allocation failed.
		FatalTrace ( 0, "Out of memory" );

		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

HRESULT StdPropertyGet ( long lProperty, long * plOut )
{
	TraceQuietEnter ( "StdPropertyGet <long>" );

	_ASSERT ( plOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plOut ) );

	if ( plOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}

	*plOut = lProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( DATE dateProperty, DATE * pdateOut )
{
	TraceQuietEnter ( "StdPropertyGet <DATE>" );

	_ASSERT ( pdateOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateOut ) );

	if ( pdateOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}
	
	*pdateOut = dateProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings )
{
	TraceFunctEnter ( "StdPropertyGet <MULTI_SZ>" );

	_ASSERT ( pmszProperty );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaStrings ) );

	HRESULT		hr	= NOERROR;

	*ppsaStrings = pmszProperty->ToSafeArray ( );

	if ( *ppsaStrings == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyGetBit ( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pfOut ) );

	if ( !pfOut ) {
		return E_POINTER;
	}

	*pfOut	= GetBitFlag ( bvBitVector, dwBit );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	StdPropertyPut <BSTR, long, DWORD or DATE>
//
//	Description:
//
//		Performs a default Property Put on a BSTR, long, DWORD or
//		Ole date.
//
//	Parameters:
//
//		pProperty	- The property to put.
//		New			- The new value.
//		pbvChangedProps [optional] - Bit Vector which holds which
//				properties have changed.
//		dwBitMask [optional] - This property's bitmask for the 
//				changed bit vector.
//
//	Returns:
//
//		E_POINTER - invalid arguments
//		E_OUTOFMEMORY - Not enough memory to copy
//		NOERROR - success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyPut ( 
	BSTR * pstrProperty, 
	const BSTR strNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0 
	)
{
	TraceQuietEnter ( "StdPropertyPut <BSTR>" );

	// Validate Parameters:
	_ASSERT ( pstrProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrProperty ) );

	_ASSERT ( strNew != NULL );
	_ASSERT ( IS_VALID_STRING ( strNew ) );

	if ( pstrProperty == NULL ) {
		FatalTrace ( 0, "Bad property pointer" );
		return E_POINTER;
	}

	if ( strNew == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	HRESULT	hr	= NOERROR;
	BSTR	strCopy = NULL;

	// Copy the new string:
	strCopy = ::SysAllocString ( strNew );

	if ( strCopy == NULL ) {
		hr = E_OUTOFMEMORY;

		FatalTrace ( 0, "Out of memory" );
		goto Error;
	}

	// Update the changed bit, if necessary:
	if ( *pstrProperty && lstrcmp ( *pstrProperty, strCopy ) != 0 ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	// Replace the old property with the new one.
	SAFE_FREE_BSTR ( *pstrProperty );

	*pstrProperty = strCopy;

Error:
	return hr;
}

HRESULT StdPropertyPut ( 
	long * plProperty, 
	long lNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <long>" );

	_ASSERT ( plProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plProperty ) );

	if ( plProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *plProperty != lNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*plProperty = lNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( 
	DATE * pdateProperty, 
	DATE dateNew, 
	DWORD * pbvChangedProps, // = NULL
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <DATE>" );

	_ASSERT ( pdateProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateProperty ) );

	if ( pdateProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *pdateProperty != dateNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*pdateProperty = dateNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	TraceFunctEnter ( "StdPropertyPut <MULTI_SZ>" );

	_ASSERT ( IS_VALID_IN_PARAM ( psaStrings ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pmszProperty ) );

	if ( psaStrings == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	HRESULT		hr	= NOERROR;

	pmszProperty->FromSafeArray ( psaStrings );

	if ( !*pmszProperty ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Don't want to deal with comparing these properties:
	UpdateChangedMask ( pbvChangedProps, dwBitMask );

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyPutBit ( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbvBitVector ) );
	_ASSERT ( dwBit );

	SetBitFlag ( pbvBitVector, dwBit, fIn );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	PV_MaxChars
//
//	Description:
//
//		Validates a string to make sure it's not too long.
//
//	Parameters:
//
//		strProperty - the string to check
//		nMaxChars - the maximum number of characters in the string,
//			not including the NULL terminator.
//
//	Returns:
//
//		FALSE if the string is too long.
//
//--------------------------------------------------------------------

BOOL PV_MaxChars ( const BSTR strProperty, DWORD nMaxChars )
{
	TraceQuietEnter ( "PV_MaxChars" );

	_ASSERT ( strProperty != NULL );
	_ASSERT ( IS_VALID_STRING ( strProperty ) );

	_ASSERT ( nMaxChars > 0 );

	if ( strProperty == NULL ) {
		// This error should be caught somewhere else.
		return TRUE;
	}

	if ( (DWORD) lstrlen ( strProperty ) > nMaxChars ) {
		ErrorTrace ( 0, "String too long" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	PV_MinMax <int, dword>
//
//	Description:
//
//		Makes sure a property is within a given range.
//
//	Parameters:
//
//		nProperty - the value to test
//		nMin - The minimum value the property could have
//		nMax - The maximum value the property could have
//
//	Returns:
//
//		TRUE if the property is in the range (inclusive).
//
//--------------------------------------------------------------------

BOOL PV_MinMax ( int nProperty, int nMin, int nMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( nMin <= nMax );

	if ( nProperty < nMin || nProperty > nMax ) {
		ErrorTrace ( 0, "Integer out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_MinMax ( DWORD dwProperty, DWORD dwMin, DWORD dwMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( dwMin <= dwMax );

	if ( dwProperty < dwMin || dwProperty > dwMax ) {

		ErrorTrace ( 0, "Dword out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_Boolean		( BOOL fProperty )
{
	TraceQuietEnter ( "PV_Boolean" );

	if ( fProperty != TRUE && fProperty != FALSE ) {

		ErrorTrace ( 0, "Boolean property is not true or false" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGetIDispatch
//
//	Description:
//
//		Gets a IDispatch pointer for the given cLSID
//
//	Parameters:
//
//		clsid		- OLE CLSID of the object
//		ppIDipsatch	- the IDispatch pointer to that object.
//
//	Returns:
//
//		E_POINTER	- invalid argument
//		NOERROR		- Success
//		Others - defined by CoCreateInstance.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGetIDispatch ( 
	REFCLSID clsid, 
	IDispatch ** ppIDispatch 
	)
{
	TraceFunctEnter ( "StdPropertyGetIDispatch" );

	CComPtr<IDispatch>	pNewIDispatch;
	HRESULT				hr = NOERROR;

	_ASSERT ( ppIDispatch );

	if ( ppIDispatch == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return E_POINTER;
	}

	*ppIDispatch = NULL;

	hr = ::CoCreateInstance ( 
		clsid,
		NULL, 
		CLSCTX_ALL, 
		IID_IDispatch,
		(void **) &pNewIDispatch
		);

	if ( FAILED (hr) ) {
		DebugTraceX ( 0, "CoCreate(IDispatch) failed %x", hr );
		FatalTrace ( 0, "Failed to create IDispatch" );
		goto Exit;
	}

	*ppIDispatch = pNewIDispatch;
	pNewIDispatch->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// Destructor releases pNewIDispatch
}

//$-------------------------------------------------------------------
//
//	InetAddressToString
//
//	Description:
//
//		Converts a DWORD with an ip address to a string in the form
//		"xxx.xxx.xxx.xxx"
//
//	Parameters:
//
//		dwAddress	- The address to convert
//		wszAddress	- The resulting string
//		cAddress	- The maximum size of the resulting string
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress )
{
	TraceFunctEnter ( "InetAddressToString" );

	_ASSERT ( wszAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	struct in_addr	addr;
	LPSTR			szAnsiAddress;
	DWORD			cchCopied;

	addr.s_addr = dwAddress;

	szAnsiAddress = inet_ntoa ( addr );

	if ( szAnsiAddress == NULL ) {
		ErrorTraceX ( 0, "inet_ntoa failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	cchCopied = MultiByteToWideChar ( 
		CP_ACP, 
		MB_PRECOMPOSED,
		szAnsiAddress,
		-1,
		wszAddress,
		cAddress
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	TraceFunctLeave ();
	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StringToInetAddress
//
//	Description:
//
//		Converts a string in the form "xxx.xxx.xxx.xxx" to a DWORD
//		IP Address.
//
//	Parameters:
//
//		wszAddress	- The string to convert
//		pdwAddress	- The resulting address
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress )
{
	TraceFunctEnter ( "StringToInetAddress" );

	_ASSERT ( wszAddress );
	_ASSERT ( pdwAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	if ( pdwAddress == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	char	szAnsiAddress[100];
	DWORD	cchCopied;

	*pdwAddress = 0;

	cchCopied = WideCharToMultiByte ( 
		CP_ACP, 
		0, 
		wszAddress, 
		-1, 
		szAnsiAddress, 
		sizeof ( szAnsiAddress ),
		NULL,
		NULL
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	*pdwAddress = inet_addr ( szAnsiAddress );

	if ( !*pdwAddress ) {
		ErrorTraceX ( 0, "inet_addr failed: %x", GetLastError () );
	}

	TraceFunctLeave ();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\rtsrc.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

        rtsrc.h

Abstract:

        Implementation of IRoutingSource interface

Author:

        Fei Su (feisu)       9/22/97    Created.

Revision History:

--*/


#include "stdafx.h"
#include "smtpadm.h"
#include "smtpprop.h"
#include "rtsrc.h"
#include "oleutil.h"
#include "metautil.h"


// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_IRoutingSource


#define RS_RELATIVE_NAME            _T("RoutingSources")


#define ID_DS_TYPE                      0
#define ID_DS_DATA_DIRECTORY            1
#define ID_DS_DEFAULT_MAIL_ROOT         2
#define ID_DS_BIND_TYPE                 3
#define ID_DS_SCHEMA_TYPE               4
#define ID_DS_HOST                      5
#define ID_DS_NAMING_CONTEXT            6
#define ID_DS_ACCOUNT                   7
#define ID_DS_PASSWORD                  8

#define DEFAULT_DS_TYPE                 _T("LDAP")
#define DEFAULT_DS_DATA_DIRECTORY       _T("")
#define DEFAULT_DS_DEFAULT_MAIL_ROOT    _T("/Mailbox")
#define DEFAULT_DS_BIND_TYPE            _T("None")
#define DEFAULT_DS_SCHEMA_TYPE          _T("Exchange5")
#define DEFAULT_DS_HOST                 _T("")
#define DEFAULT_DS_NAMING_CONTEXT       _T("")
#define DEFAULT_DS_ACCOUNT              _T("")
#define DEFAULT_DS_PASSWORD             _T("")


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CRoutingSource::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IRoutingSource,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CRoutingSource::get_Type( BSTR * pstrType )
{
    return StdPropertyGet ( m_strType, pstrType );
}

STDMETHODIMP CRoutingSource::put_Type( BSTR strType )
{
    return StdPropertyPut ( &m_strType, strType, &m_dwFC, BitMask(ID_DS_TYPE));
}


STDMETHODIMP CRoutingSource::get_DataDirectory( BSTR * pstrDataDirectory )
{
    return StdPropertyGet ( m_strDataDirectory, pstrDataDirectory );
}

STDMETHODIMP CRoutingSource::put_DataDirectory( BSTR strDataDirectory )
{
    return StdPropertyPut ( &m_strDataDirectory, strDataDirectory, &m_dwFC, BitMask(ID_DS_DATA_DIRECTORY) );
}


STDMETHODIMP CRoutingSource::get_DefaultMailRoot( BSTR * pstrDefaultMailRoot )
{
    return StdPropertyGet ( m_strDefaultMailroot, pstrDefaultMailRoot );
}

STDMETHODIMP CRoutingSource::put_DefaultMailRoot( BSTR strDefaultMailRoot )
{
    return StdPropertyPut ( &m_strDefaultMailroot, strDefaultMailRoot, &m_dwFC, BitMask(ID_DS_DEFAULT_MAIL_ROOT) );
}


STDMETHODIMP CRoutingSource::get_BindType( BSTR * pstrBindType )
{
    return StdPropertyGet ( m_strBindType, pstrBindType );
}

STDMETHODIMP CRoutingSource::put_BindType( BSTR strBindType )
{
    return StdPropertyPut ( &m_strBindType, strBindType, &m_dwFC, BitMask(ID_DS_BIND_TYPE) );
}


STDMETHODIMP CRoutingSource::get_SchemaType( BSTR * pstrSchemaType )
{
    return StdPropertyGet ( m_strSchemaType, pstrSchemaType );
}

STDMETHODIMP CRoutingSource::put_SchemaType( BSTR strSchemaType )
{
    return StdPropertyPut ( &m_strSchemaType, strSchemaType, &m_dwFC, BitMask(ID_DS_SCHEMA_TYPE) );
}


STDMETHODIMP CRoutingSource::get_Host( BSTR * pstrHost )
{
    return StdPropertyGet ( m_strHost, pstrHost );
}

STDMETHODIMP CRoutingSource::put_Host( BSTR strHost )
{
    return StdPropertyPut ( &m_strHost, strHost, &m_dwFC, BitMask(ID_DS_HOST) );
}



STDMETHODIMP CRoutingSource::get_NamingContext( BSTR * pstrNamingContext )
{
    return StdPropertyGet ( m_strNamingContext, pstrNamingContext );
}

STDMETHODIMP CRoutingSource::put_NamingContext( BSTR strNamingContext )
{
    return StdPropertyPut ( &m_strNamingContext, strNamingContext, &m_dwFC, BitMask(ID_DS_NAMING_CONTEXT) );
}


STDMETHODIMP CRoutingSource::get_Account( BSTR * pstrAccount )
{
    return StdPropertyGet ( m_strAccount, pstrAccount );
}

STDMETHODIMP CRoutingSource::put_Account( BSTR strAccount )
{
    return StdPropertyPut ( &m_strAccount, strAccount, &m_dwFC, BitMask(ID_DS_ACCOUNT) );
}


STDMETHODIMP CRoutingSource::get_Password( BSTR * pstrPassword )
{
    return StdPropertyGet ( m_strPassword, pstrPassword );
}

STDMETHODIMP CRoutingSource::put_Password( BSTR strPassword )
{
    return StdPropertyPut ( &m_strPassword, strPassword, &m_dwFC, BitMask(ID_DS_PASSWORD) );
}


///////////////////////////////////////////////////////////////////
//  Get / Set methods (internal)
///////////////////////////////////////////////////////////////////

HRESULT CRoutingSource::Get(CMetabaseKey * pMBVirtualServer)
{
    TraceFunctEnter ( "CRoutingSource::Get" );
    HRESULT hr = NOERROR;

    if( !pMBVirtualServer )
        BAIL_WITH_FAILURE(hr, E_POINTER);

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_TYPE, DEFAULT_DS_TYPE, &m_strType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DATA_DIRECTORY, DEFAULT_DS_DATA_DIRECTORY, &m_strDataDirectory, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DEFAULT_MAIL_ROOT, DEFAULT_DS_DEFAULT_MAIL_ROOT, &m_strDefaultMailroot, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_BIND_TYPE, DEFAULT_DS_BIND_TYPE, &m_strBindType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_SCHEMA_TYPE, DEFAULT_DS_SCHEMA_TYPE, &m_strSchemaType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_HOST, DEFAULT_DS_HOST, &m_strHost, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_NAMING_CONTEXT, DEFAULT_DS_NAMING_CONTEXT, &m_strNamingContext, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_ACCOUNT, DEFAULT_DS_ACCOUNT, &m_strAccount, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( !StdGetMetabaseProp(pMBVirtualServer, MD_SMTP_DS_PASSWORD, DEFAULT_DS_PASSWORD, &m_strPassword, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());


Exit:
    TraceFunctLeave ();
    return hr;
}


HRESULT CRoutingSource::Set(CMetabaseKey * pMBVirtualServer)
{
    TraceFunctEnter ( "CRoutingSource::Set" );
    HRESULT hr = NOERROR;

    if( !pMBVirtualServer )
        BAIL_WITH_FAILURE(hr, E_POINTER);

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_TYPE)) && 
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_TYPE, m_strType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_DATA_DIRECTORY)) && 
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DATA_DIRECTORY, m_strDataDirectory, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_DEFAULT_MAIL_ROOT)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_DEFAULT_MAIL_ROOT, m_strDefaultMailroot, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_BIND_TYPE)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_BIND_TYPE, m_strBindType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_SCHEMA_TYPE)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_SCHEMA_TYPE, m_strSchemaType, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_HOST)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_HOST, m_strHost, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_NAMING_CONTEXT)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_NAMING_CONTEXT, m_strNamingContext, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_ACCOUNT)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_ACCOUNT, m_strAccount, RS_RELATIVE_NAME) )
        BAIL_WITH_FAILURE(hr, GetLastError());

    if( IS_FLAG_SET(m_dwFC, BitMask(ID_DS_PASSWORD)) &&
        !StdPutMetabaseProp(pMBVirtualServer, MD_SMTP_DS_PASSWORD, m_strPassword, RS_RELATIVE_NAME, IIS_MD_UT_SERVER, METADATA_SECURE | METADATA_INHERIT) )
        BAIL_WITH_FAILURE(hr, GetLastError());


Exit:
    TraceFunctLeave ();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\service.cpp ===
// server.cpp : Implementation of CSmtpAdminService

#include "stdafx.h"
#include "IADM.h"
#include "imd.h"

#include "smtpadm.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "smtpcmn.h"
#include "service.h"
#include "virsvr.h"

#include "smtpprop.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.Service.1")
#define THIS_FILE_IID               IID_ISmtpAdminService




/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CSmtpAdminService::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ISmtpAdminService,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

CSmtpAdminService::CSmtpAdminService () :
    m_lPort         ( 25 ),
    m_lLogMethod    ( 0  )
    // CComBSTR's are initialized to NULL by default.
{
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    m_psaAdmins = NULL;
    InitAsyncTrace ( );
}

CSmtpAdminService::~CSmtpAdminService ()
{
    // All CComBSTR's are freed automatically.
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    TermAsyncTrace ( );
}

// Which Server to configure:

STDMETHODIMP CSmtpAdminService::get_Server ( BSTR * pstrServer )
{
    return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdminService::put_Server ( BSTR strServer )
{
    // If the server name changes, that means the client will have to
    // call Get again:

    // I assume this here:
    _ASSERT ( sizeof (DWORD) == sizeof (int) );

    return StdPropertyPutServerName ( &m_strServer, strServer, (DWORD *) &m_fGotProperties, 1 );
}

// Server Properties:

STDMETHODIMP CSmtpAdminService::get_ServerBindings( SAFEARRAY ** ppsastrServerBindings )
{
    return StdPropertyGet ( &m_mszServerBindings, ppsastrServerBindings );
}

STDMETHODIMP CSmtpAdminService::put_ServerBindings( SAFEARRAY * pstrServerBindings )
{
    return StdPropertyPut ( &m_mszServerBindings, pstrServerBindings, &m_bvChangedFields, BitMask(ID_SERVER_BINDINGS));
}

STDMETHODIMP CSmtpAdminService::get_ServerBindingsVariant( SAFEARRAY ** ppsavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = get_ServerBindings ( &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrServerBindings, ppsavarServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_ServerBindingsVariant( SAFEARRAY * psavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarServerBindings, &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_ServerBindings ( psastrServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminService::get_SecureBindings( SAFEARRAY ** ppsastrSecureBindings )
{
    return StdPropertyGet ( &m_mszSecureBindings, ppsastrSecureBindings );
}

STDMETHODIMP CSmtpAdminService::put_SecureBindings( SAFEARRAY * pstrSecureBindings )
{
    return StdPropertyPut ( &m_mszSecureBindings, pstrSecureBindings, &m_bvChangedFields, BitMask(ID_SECURE_BINDINGS));
}

STDMETHODIMP CSmtpAdminService::get_SecureBindingsVariant( SAFEARRAY ** ppsavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = get_SecureBindings ( &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrSecureServerBindings, ppsavarSecureBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_SecureBindingsVariant( SAFEARRAY * psavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarSecureBindings, &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_SecureBindings ( psastrSecureServerBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::get_Port( long * plPort )
{
    return StdPropertyGet ( m_lPort, plPort );
}

STDMETHODIMP CSmtpAdminService::put_Port( long lPort )
{
    return StdPropertyPut ( &m_lPort, lPort, &m_bvChangedFields, BitMask(ID_PORT));
}

STDMETHODIMP CSmtpAdminService::get_SSLPort( long * plSSLPort )
{
    return StdPropertyGet ( m_lSSLPort, plSSLPort );
}

STDMETHODIMP CSmtpAdminService::put_SSLPort( long lSSLPort )
{
    return StdPropertyPut ( &m_lSSLPort, lSSLPort, &m_bvChangedFields, BitMask(ID_SSLPORT));
}

STDMETHODIMP CSmtpAdminService::get_OutboundPort( long * plOutboundPort )
{
    return StdPropertyGet ( m_lOutboundPort, plOutboundPort );
}

STDMETHODIMP CSmtpAdminService::put_OutboundPort( long lOutboundPort )
{
    return StdPropertyPut ( &m_lOutboundPort, lOutboundPort, &m_bvChangedFields, BitMask(ID_OUTBOUNDPORT));
}


STDMETHODIMP CSmtpAdminService::get_HopCount( long * plHopCount )
{
    return StdPropertyGet ( m_lHopCount, plHopCount );
}

STDMETHODIMP CSmtpAdminService::put_HopCount( long lHopCount )
{
    return StdPropertyPut ( &m_lHopCount, lHopCount, &m_bvChangedFields, BitMask(ID_HOP_COUNT));
}

STDMETHODIMP CSmtpAdminService::get_SmartHost( BSTR * pstrSmartHost )
{
    return StdPropertyGet ( m_strSmartHost, pstrSmartHost );
}

STDMETHODIMP CSmtpAdminService::put_SmartHost( BSTR strSmartHost )
{
    return StdPropertyPut ( &m_strSmartHost, strSmartHost, &m_bvChangedFields, BitMask(ID_SMARTHOST));
}

STDMETHODIMP CSmtpAdminService::get_EnableDNSLookup( BOOL * pfEnableDNSLookup )
{
    return StdPropertyGet ( m_fEnableDNSLookup, pfEnableDNSLookup );
}

STDMETHODIMP CSmtpAdminService::put_EnableDNSLookup( BOOL fEnableDNSLookup )
{
    return StdPropertyPut ( &m_fEnableDNSLookup, fEnableDNSLookup, &m_bvChangedFields, BitMask(ID_ENABLEDNSLOOKUP));
}

STDMETHODIMP CSmtpAdminService::get_PostmasterEmail( BSTR * pstrPostmasterEmail )
{
    return StdPropertyGet ( m_strPostmasterEmail, pstrPostmasterEmail );
}

STDMETHODIMP CSmtpAdminService::put_PostmasterEmail( BSTR strPostmasterEmail )
{
    return StdPropertyPut ( &m_strPostmasterEmail, strPostmasterEmail, &m_bvChangedFields, BitMask(ID_POSTMASTEREMAIL));
}

STDMETHODIMP CSmtpAdminService::get_PostmasterName( BSTR * pstrPostmasterName )
{
    return StdPropertyGet ( m_strPostmasterName, pstrPostmasterName );
}

STDMETHODIMP CSmtpAdminService::put_PostmasterName( BSTR strPostmasterName )
{
    return StdPropertyPut ( &m_strPostmasterName, strPostmasterName, &m_bvChangedFields, BitMask(ID_POSTMASTERNAME));
}


STDMETHODIMP CSmtpAdminService::get_DefaultDomain( BSTR * pstrDefaultDomain )
{
    return StdPropertyGet ( m_strDefaultDomain, pstrDefaultDomain );
}

STDMETHODIMP CSmtpAdminService::put_DefaultDomain( BSTR strDefaultDomain )
{
    return StdPropertyPut ( &m_strDefaultDomain, strDefaultDomain, &m_bvChangedFields, BitMask(ID_DEFAULTDOMAIN));
}

STDMETHODIMP CSmtpAdminService::get_FQDN( BSTR * pstrFQDN )
{
    return StdPropertyGet ( m_strFQDN, pstrFQDN );
}

STDMETHODIMP CSmtpAdminService::put_FQDN( BSTR strFQDN )
{
    return StdPropertyPut ( &m_strFQDN, strFQDN, &m_bvChangedFields, BitMask(ID_FQDN));
}

STDMETHODIMP CSmtpAdminService::get_DropDir( BSTR * pstrDropDir )
{
    return StdPropertyGet ( m_strDropDir, pstrDropDir );
}

STDMETHODIMP CSmtpAdminService::put_DropDir( BSTR strDropDir )
{
    return StdPropertyPut ( &m_strDropDir, strDropDir, &m_bvChangedFields, BitMask(ID_DROPDIR));
}


STDMETHODIMP CSmtpAdminService::get_BadMailDir( BSTR * pstrBadMailDir )
{
    return StdPropertyGet ( m_strBadMailDir, pstrBadMailDir );
}

STDMETHODIMP CSmtpAdminService::put_BadMailDir( BSTR strBadMailDir )
{
    return StdPropertyPut ( &m_strBadMailDir, strBadMailDir, &m_bvChangedFields, BitMask(ID_BADMAILDIR));
}

STDMETHODIMP CSmtpAdminService::get_PickupDir( BSTR * pstrPickupDir )
{
    return StdPropertyGet ( m_strPickupDir, pstrPickupDir );
}

STDMETHODIMP CSmtpAdminService::put_PickupDir( BSTR strPickupDir )
{
    return StdPropertyPut ( &m_strPickupDir, strPickupDir, &m_bvChangedFields, BitMask(ID_PICKUPDIR));
}

STDMETHODIMP CSmtpAdminService::get_QueueDir( BSTR * pstrQueueDir )
{
    return StdPropertyGet ( m_strQueueDir, pstrQueueDir );
}

STDMETHODIMP CSmtpAdminService::put_QueueDir( BSTR strQueueDir )
{
    return StdPropertyPut ( &m_strQueueDir, strQueueDir, &m_bvChangedFields, BitMask(ID_QUEUEDIR));
}

STDMETHODIMP CSmtpAdminService::get_MaxInConnection( long * plMaxInConnection )
{
    return StdPropertyGet ( m_lMaxInConnection, plMaxInConnection );
}

STDMETHODIMP CSmtpAdminService::put_MaxInConnection( long lMaxInConnection )
{
    return StdPropertyPut ( &m_lMaxInConnection, lMaxInConnection, &m_bvChangedFields, BitMask(ID_MAXINCONNECTION));
}

STDMETHODIMP CSmtpAdminService::get_MaxOutConnection( long * plMaxOutConnection )
{
    return StdPropertyGet ( m_lMaxOutConnection, plMaxOutConnection );
}

STDMETHODIMP CSmtpAdminService::put_MaxOutConnection( long lMaxOutConnection )
{
    return StdPropertyPut ( &m_lMaxOutConnection, lMaxOutConnection, &m_bvChangedFields, BitMask(ID_MAXOUTCONNECTION));
}

STDMETHODIMP CSmtpAdminService::get_InConnectionTimeout( long * plInConnectionTimeout )
{
    return StdPropertyGet ( m_lInConnectionTimeout, plInConnectionTimeout );
}

STDMETHODIMP CSmtpAdminService::put_InConnectionTimeout( long lInConnectionTimeout )
{
    return StdPropertyPut ( &m_lInConnectionTimeout, lInConnectionTimeout, &m_bvChangedFields, BitMask(ID_INCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminService::get_OutConnectionTimeout( long * plOutConnectionTimeout )
{
    return StdPropertyGet ( m_lOutConnectionTimeout, plOutConnectionTimeout );
}

STDMETHODIMP CSmtpAdminService::put_OutConnectionTimeout( long lOutConnectionTimeout )
{
    return StdPropertyPut ( &m_lOutConnectionTimeout, lOutConnectionTimeout, &m_bvChangedFields, BitMask(ID_OUTCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminService::get_MaxMessageSize( long * plMaxMessageSize )
{
    return StdPropertyGet ( m_lMaxMessageSize, plMaxMessageSize );
}

STDMETHODIMP CSmtpAdminService::put_MaxMessageSize( long lMaxMessageSize )
{
    return StdPropertyPut ( &m_lMaxMessageSize, lMaxMessageSize, &m_bvChangedFields, BitMask(ID_MAXMESSAGESIZE));
}

STDMETHODIMP CSmtpAdminService::get_MaxSessionSize( long * plMaxSessionSize )
{
    return StdPropertyGet ( m_lMaxSessionSize, plMaxSessionSize );
}

STDMETHODIMP CSmtpAdminService::put_MaxSessionSize( long lMaxSessionSize )
{
    return StdPropertyPut ( &m_lMaxSessionSize, lMaxSessionSize, &m_bvChangedFields, BitMask(ID_MAXSESSIONSIZE));
}
STDMETHODIMP CSmtpAdminService::get_MaxMessageRecipients( long * plMaxMessageRecipients )
{
    return StdPropertyGet ( m_lMaxMessageRecipients, plMaxMessageRecipients );
}

STDMETHODIMP CSmtpAdminService::put_MaxMessageRecipients( long lMaxMessageRecipients )
{
    return StdPropertyPut ( &m_lMaxMessageRecipients, lMaxMessageRecipients, &m_bvChangedFields, BitMask(ID_MAXMESSAGERECIPIENTS));
}

STDMETHODIMP CSmtpAdminService::get_LocalRetries( long * plLocalRetries )
{
    return StdPropertyGet ( m_lLocalRetries, plLocalRetries );
}

STDMETHODIMP CSmtpAdminService::put_LocalRetries( long lLocalRetries )
{
    return StdPropertyPut ( &m_lLocalRetries, lLocalRetries, &m_bvChangedFields, BitMask(ID_LOCALRETRIES));
}

STDMETHODIMP CSmtpAdminService::get_LocalRetryTime( long * plLocalRetryTime )
{
    return StdPropertyGet ( m_lLocalRetryTime, plLocalRetryTime );
}

STDMETHODIMP CSmtpAdminService::put_LocalRetryTime( long lLocalRetryTime )
{
    return StdPropertyPut ( &m_lLocalRetryTime, lLocalRetryTime, &m_bvChangedFields, BitMask(ID_LOCALRETRYTIME));
}

STDMETHODIMP CSmtpAdminService::get_RemoteRetries( long * plRemoteRetries )
{
    return StdPropertyGet ( m_lRemoteRetries, plRemoteRetries );
}

STDMETHODIMP CSmtpAdminService::put_RemoteRetries( long lRemoteRetries )
{
    return StdPropertyPut ( &m_lRemoteRetries, lRemoteRetries, &m_bvChangedFields, BitMask(ID_REMOTERETRIES));
}

STDMETHODIMP CSmtpAdminService::get_RemoteRetryTime( long * plRemoteRetryTime )
{
    return StdPropertyGet ( m_lRemoteRetryTime, plRemoteRetryTime );
}

STDMETHODIMP CSmtpAdminService::put_RemoteRetryTime( long lRemoteRetryTime )
{
    return StdPropertyPut ( &m_lRemoteRetryTime, lRemoteRetryTime, &m_bvChangedFields, BitMask(ID_REMOTERETRYTIME));
}

STDMETHODIMP CSmtpAdminService::get_ETRNDays( long * plETRNDays )
{
    return StdPropertyGet ( m_lETRNDays, plETRNDays );
}

STDMETHODIMP CSmtpAdminService::put_ETRNDays( long lETRNDays )
{
    return StdPropertyPut ( &m_lETRNDays, lETRNDays, &m_bvChangedFields, BitMask(ID_ETRNDAYS));
}

STDMETHODIMP CSmtpAdminService::get_SendDNRToPostmaster( BOOL * pfSendDNRToPostmaster )
{
    return StdPropertyGet ( m_fSendDNRToPostmaster, pfSendDNRToPostmaster );
}

STDMETHODIMP CSmtpAdminService::put_SendDNRToPostmaster( BOOL fSendDNRToPostmaster )
{
    return StdPropertyPut ( &m_fSendDNRToPostmaster, fSendDNRToPostmaster, &m_bvChangedFields, BitMask(ID_SENDDNRTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminService::get_SendBadmailToPostmaster( BOOL * pfSendBadmailToPostmaster)
{
    return StdPropertyGet ( m_fSendBadmailToPostmaster, pfSendBadmailToPostmaster );
}

STDMETHODIMP CSmtpAdminService::put_SendBadmailToPostmaster( BOOL fSendBadmailToPostmaster )
{
    return StdPropertyPut ( &m_fSendBadmailToPostmaster, fSendBadmailToPostmaster, &m_bvChangedFields, BitMask(ID_SENDBADMAILTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminService::get_RoutingDLL( BSTR * pstrRoutingDLL )
{
    return StdPropertyGet ( m_strRoutingDLL, pstrRoutingDLL );
}

STDMETHODIMP CSmtpAdminService::put_RoutingDLL( BSTR strRoutingDLL  )
{
    return StdPropertyPut ( &m_strRoutingDLL, strRoutingDLL, &m_bvChangedFields, BitMask(ID_ROUTINGDLL));
}


STDMETHODIMP CSmtpAdminService::get_RoutingSources  ( SAFEARRAY ** ppsastrRoutingSources )
{
    return StdPropertyGet ( &m_mszRoutingSources, ppsastrRoutingSources );
}
STDMETHODIMP CSmtpAdminService::put_RoutingSources  ( SAFEARRAY * psastrRoutingSources )
{
    return StdPropertyPut ( &m_mszRoutingSources, psastrRoutingSources, &m_bvChangedFields, BitMask(ID_ROUTINGSOURCES) );
}


STDMETHODIMP CSmtpAdminService::get_RoutingSourcesVariant( SAFEARRAY ** ppsavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = get_RoutingSources ( &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrRoutingSources, ppsavarRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_RoutingSourcesVariant( SAFEARRAY * psavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = VariantArrayToStringArray ( psavarRoutingSources, &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_RoutingSources ( psastrRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::get_LocalDomains    ( SAFEARRAY ** ppsastrLocalDomains )
{
    return StdPropertyGet ( &m_mszLocalDomains, ppsastrLocalDomains );
}

STDMETHODIMP CSmtpAdminService::put_LocalDomains    ( SAFEARRAY * psastrLocalDomains )
{
    return StdPropertyPut ( &m_mszLocalDomains, psastrLocalDomains, &m_bvChangedFields, BitMask(ID_LOCALDOMAINS) );
}

STDMETHODIMP CSmtpAdminService::get_DomainRouting   ( SAFEARRAY ** ppsastrDomainRouting )
{
    return StdPropertyGet ( &m_mszDomainRouting, ppsastrDomainRouting );
}
STDMETHODIMP CSmtpAdminService::put_DomainRouting   ( SAFEARRAY * psastrDomainRouting )
{
    return StdPropertyPut ( &m_mszDomainRouting, psastrDomainRouting, &m_bvChangedFields, BitMask(ID_DOMAINROUTING) );
}

STDMETHODIMP CSmtpAdminService::get_DomainRoutingVariant( SAFEARRAY ** ppsastrDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = get_DomainRouting ( &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( pstrDomainRouting, ppsastrDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_DomainRoutingVariant( SAFEARRAY * psastrDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = VariantArrayToStringArray ( psastrDomainRouting, &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_DomainRouting ( pstrDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminService::get_MasqueradeDomain( BSTR * pstrMasqueradeDomain )
{
    return StdPropertyGet ( m_strMasqueradeDomain, pstrMasqueradeDomain );
}

STDMETHODIMP CSmtpAdminService::put_MasqueradeDomain( BSTR strMasqueradeDomain )
{
    return StdPropertyPut ( &m_strMasqueradeDomain, strMasqueradeDomain, &m_bvChangedFields, BitMask(ID_MASQUERADE));
}

STDMETHODIMP CSmtpAdminService::get_SendNdrTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strNdrAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminService::put_SendNdrTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strNdrAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDNDRTO));
}

STDMETHODIMP CSmtpAdminService::get_SendBadTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strBadAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminService::put_SendBadTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strBadAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDBADTO));
}

STDMETHODIMP CSmtpAdminService::get_RemoteSecurePort( long * plRemoteSecurePort )
{
    return StdPropertyGet( m_lRemoteSecurePort, plRemoteSecurePort );
}

STDMETHODIMP CSmtpAdminService::put_RemoteSecurePort( long lRemoteSecurePort )
{
    return StdPropertyPut ( &m_lRemoteSecurePort, lRemoteSecurePort, &m_bvChangedFields, BitMask(ID_REMOTE_SECURE_PORT));
}

STDMETHODIMP CSmtpAdminService::get_ShouldDeliver( BOOL * pfShouldDeliver )
{
    return StdPropertyGet( m_fShouldDeliver, pfShouldDeliver );
}

STDMETHODIMP CSmtpAdminService::put_ShouldDeliver( BOOL fShouldDeliver )
{
    return StdPropertyPut ( &m_fShouldDeliver, fShouldDeliver, &m_bvChangedFields, BitMask(ID_SHOULD_DELIVER));
}


STDMETHODIMP CSmtpAdminService::get_AlwaysUseSsl( BOOL * pfAlwaysUseSsl )
{
    return StdPropertyGet( m_fAlwaysUseSsl, pfAlwaysUseSsl );
}

STDMETHODIMP CSmtpAdminService::put_AlwaysUseSsl( BOOL fAlwaysUseSsl )
{
    return StdPropertyPut ( &m_fAlwaysUseSsl, fAlwaysUseSsl, &m_bvChangedFields, BitMask(ID_ALWAYS_USE_SSL));
}

STDMETHODIMP CSmtpAdminService::get_LimitRemoteConnections( BOOL * pfLimitRemoteConnections )
{
    return StdPropertyGet( m_fLimitRemoteConnections, pfLimitRemoteConnections );
}

STDMETHODIMP CSmtpAdminService::put_LimitRemoteConnections( BOOL fLimitRemoteConnections )
{
    return StdPropertyPut ( &m_fLimitRemoteConnections, fLimitRemoteConnections, &m_bvChangedFields, BitMask(ID_LIMIT_REMOTE_CONNECTIONS));
}

STDMETHODIMP CSmtpAdminService::get_MaxOutConnPerDomain( long * plMaxOutConnPerDomain )
{
    return StdPropertyGet( m_lMaxOutConnPerDomain, plMaxOutConnPerDomain );
}

STDMETHODIMP CSmtpAdminService::put_MaxOutConnPerDomain( long lMaxOutConnPerDomain )
{
    return StdPropertyPut ( &m_lMaxOutConnPerDomain, lMaxOutConnPerDomain, &m_bvChangedFields, BitMask(ID_MAX_OUT_CONN_PER_DOMAIN));
}


STDMETHODIMP CSmtpAdminService::get_AllowVerify( BOOL * pfAllowVerify )
{
    return StdPropertyGet( m_fAllowVerify, pfAllowVerify );
}

STDMETHODIMP CSmtpAdminService::put_AllowVerify( BOOL fAllowVerify )
{
    return StdPropertyPut ( &m_fAllowVerify, fAllowVerify, &m_bvChangedFields, BitMask(ID_ALLOW_VERIFY));
}


STDMETHODIMP CSmtpAdminService::get_AllowExpand( BOOL * pfAllowExpand )
{
    return StdPropertyGet( m_fAllowExpand, pfAllowExpand);
}

STDMETHODIMP CSmtpAdminService::put_AllowExpand( BOOL fAllowExpand )
{
    return StdPropertyPut ( &m_fAllowExpand, fAllowExpand, &m_bvChangedFields, BitMask(ID_ALLOW_EXPAND));
}


STDMETHODIMP CSmtpAdminService::get_SmartHostType( long * plSmartHostType )
{
    return StdPropertyGet( m_lSmartHostType, plSmartHostType );
}

STDMETHODIMP CSmtpAdminService::put_SmartHostType( long lSmartHostType )
{
    return StdPropertyPut ( &m_lSmartHostType, lSmartHostType, &m_bvChangedFields, BitMask(ID_SMART_HOST_TYPE));
}


STDMETHODIMP CSmtpAdminService::get_BatchMessages( BOOL * pfBatchMessages )
{
    return StdPropertyGet( m_fBtachMsgs, pfBatchMessages );
}

STDMETHODIMP CSmtpAdminService::put_BatchMessages( BOOL fBatchMessages )
{
    return StdPropertyPut ( &m_fBtachMsgs, fBatchMessages, &m_bvChangedFields, BitMask(ID_BATCH_MSGS));
}


STDMETHODIMP CSmtpAdminService::get_BatchMessageLimit( long * plBatchMessageLimit )
{
    return StdPropertyGet( m_lBatchMsgLimit, plBatchMessageLimit );
}

STDMETHODIMP CSmtpAdminService::put_BatchMessageLimit( long lBatchMessageLimit )
{
    return StdPropertyPut ( &m_lBatchMsgLimit, lBatchMessageLimit, &m_bvChangedFields, BitMask(ID_BATCH_MSG_LIMIT));
}


STDMETHODIMP CSmtpAdminService::get_DoMasquerade( BOOL * pfDoMasquerade )
{
    return StdPropertyGet( m_fDoMasquerade, pfDoMasquerade );
}

STDMETHODIMP CSmtpAdminService::put_DoMasquerade( BOOL fDoMasquerade )
{
    return StdPropertyPut ( &m_fDoMasquerade, fDoMasquerade, &m_bvChangedFields, BitMask(ID_DO_MASQUERADE));
}


STDMETHODIMP CSmtpAdminService::get_Administrators ( SAFEARRAY ** ppsastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminService::get_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        hr = SafeArrayCopy ( m_psaAdmins, ppsastrAdmins );
    }
    else {
        *ppsastrAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminService::put_Administrators ( SAFEARRAY * psastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminService::put_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    if ( psastrAdmins ) {
        hr = SafeArrayCopy ( psastrAdmins, &m_psaAdmins );
    }
    else {
        m_psaAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminService::get_AdministratorsVariant( SAFEARRAY ** ppsavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = get_Administrators ( &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrAdmins, ppsavarAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::put_AdministratorsVariant( SAFEARRAY * psavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = VariantArrayToStringArray ( psavarAdmins, &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_Administrators ( psastrAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminService::get_LogFileDirectory( BSTR * pstrLogFileDirectory )
{
    return StdPropertyGet ( m_strLogFileDirectory, pstrLogFileDirectory );
}

STDMETHODIMP CSmtpAdminService::put_LogFileDirectory( BSTR strLogFileDirectory )
{
    return StdPropertyPut ( &m_strLogFileDirectory, strLogFileDirectory, &m_bvChangedFields, BitMask(ID_LOGFILEDIRECTORY));
}

STDMETHODIMP CSmtpAdminService::get_LogFilePeriod( long * plLogFilePeriod )
{
    return StdPropertyGet ( m_lLogFilePeriod, plLogFilePeriod );
}

STDMETHODIMP CSmtpAdminService::put_LogFilePeriod( long lLogFilePeriod )
{
    return StdPropertyPut ( &m_lLogFilePeriod, lLogFilePeriod, &m_bvChangedFields, BitMask(ID_LOGFILEPERIOD));
}

STDMETHODIMP CSmtpAdminService::get_LogFileTruncateSize( long * plLogFileTruncateSize )
{
    return StdPropertyGet ( m_lLogFileTruncateSize, plLogFileTruncateSize );
}

STDMETHODIMP CSmtpAdminService::put_LogFileTruncateSize( long lLogFileTruncateSize )
{
    return StdPropertyPut ( &m_lLogFileTruncateSize, lLogFileTruncateSize, &m_bvChangedFields, BitMask(ID_LOGFILETRUNCATESIZE));
}

STDMETHODIMP CSmtpAdminService::get_LogMethod( long * plLogMethod )
{
    return StdPropertyGet ( m_lLogMethod, plLogMethod );
}

STDMETHODIMP CSmtpAdminService::put_LogMethod( long lLogMethod )
{
    return StdPropertyPut ( &m_lLogMethod, lLogMethod, &m_bvChangedFields, BitMask(ID_LOGMETHOD));
}

STDMETHODIMP CSmtpAdminService::get_LogType( long * plLogType )
{
    return StdPropertyGet ( m_lLogType, plLogType );
}

STDMETHODIMP CSmtpAdminService::put_LogType( long lLogType )
{
    return StdPropertyPut ( &m_lLogType, lLogType, &m_bvChangedFields, BitMask(ID_LOGTYPE));
}



//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::Get
//
//  Description:
//
//      Gets server properties from the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminService::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminService::Get" );

    HRESULT             hr          = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    // Validate Server & Service Instance:

    // Talk to the metabase:
    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = GetPropertiesFromMetabase ( pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully got server properties" );
    m_fGotProperties    = TRUE;
    m_bvChangedFields   = 0;

Exit:
    TraceFunctLeave ();

    return hr;

    // CComPtr automatically releases the metabase handle.
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::Set
//
//  Description:
//
//      Sends server properties to the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//      fFailIfChanged - return an error if the metabase has changed?
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminService::Set ( BOOL fFailIfChanged )
{
    TraceFunctEnter ( "CSmtpAdminService::Set" );

    HRESULT hr  = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;
    
    // Make sure the client call Get first:
    if ( !m_fGotProperties ) {
        ErrorTrace ( 0, "Didn't call get first" );

        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
        goto Exit;
    }

    // nothing has been changed
    if( m_bvChangedFields == 0 )
    {
        hr = NOERROR;
        goto Exit;
    }

    // Validate data members:
    if ( !ValidateStrings () ) {
        // !!!magnush - what about the case when any strings are NULL?
        hr = E_FAIL;
        goto Exit;
    }

    if ( !ValidateProperties ( ) ) {
        hr = SmtpCreateExceptionFromWin32Error ( ERROR_INVALID_PARAMETER );;
        goto Exit;
    }

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = SendPropertiesToMetabase ( fFailIfChanged, pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully set server properties" );

    // successfully saved, reset change field bitmap
    m_bvChangedFields = 0;

Exit:
    TraceFunctLeave ();
    return hr;
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::GetPropertiesFromMetabase
//
//  Description:
//
//      Asks the metabase for each property in this class.
//      This class's properties come from /LM/SmtpSvc/
//
//  Parameters:
//
//      pMetabase - The metabase object
//
//  Returns:
//
//      E_OUTOFMEMORY and others.
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminService::GetPropertiesFromMetabase ( IMSAdminBase * pMetabase )
{
    TraceFunctEnter ( "CSmtpAdminService::GetPropertiesFromMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;

    PSECURITY_DESCRIPTOR        pSD = NULL;
    DWORD                       cbSD    = 0;

    hr = metabase.Open ( SMTP_MD_ROOT_PATH );

    if ( FAILED(hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );

        // Return some kind of error code here:
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

    fRet = TRUE;
#if 0
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_PORT,      DEFAULT_SSLPORT,                &m_lSSLPort )           && fRet;
#endif
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT, DEFAULT_OUTBOND_PORT,           &m_lOutboundPort )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   DEFAULT_SMART_HOST,             &m_strSmartHost )       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_HOP_COUNT,        DEFAULT_HOP_COUNT,              &m_lHopCount )      && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,DEFAULT_ENABLE_DNS_LOOKUP,    &m_fEnableDNSLookup )   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, DEFAULT_POSTMASTER_EMAIL,       &m_strPostmasterEmail ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  DEFAULT_POSTMASTER_NAME,        &m_strPostmasterName )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_FQDN_VALUE,           DEFAULT_FQDN,               &m_strFQDN )            && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, DEFAULT_DEFAULT_DOMAIN,     &m_strDefaultDomain )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,        DEFAULT_DROP_DIR,           &m_strDropDir )         && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     DEFAULT_BADMAIL_DIR,            &m_strBadMailDir )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  DEFAULT_PICKUP_DIR,             &m_strPickupDir )       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   DEFAULT_QUEUE_DIR,              &m_strQueueDir )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  DEFAULT_MAX_OUT_CONNECTION,     &m_lMaxOutConnection )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,       DEFAULT_OUT_CONNECTION_TIMEOUT, &m_lOutConnectionTimeout )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,             DEFAULT_MAX_MESSAGE_SIZE,       &m_lMaxMessageSize )        && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    DEFAULT_MAX_SESSION_SIZE,       &m_lMaxSessionSize )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,           DEFAULT_MAX_MESSAGE_RECIPIENTS,     &m_lMaxMessageRecipients )  && fRet;


    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     DEFAULT_LOCAL_RETRIES,      &m_lLocalRetries)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      DEFAULT_LOCAL_RETRY_TIME,   &m_lLocalRetryTime)     && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    DEFAULT_REMOTE_RETRIES,     &m_lRemoteRetries)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     DEFAULT_REMOTE_RETRY_TIME,  &m_lRemoteRetryTime)    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ETRN_DAYS,                DEFAULT_ETRN_DAYS,          &m_lETRNDays)           && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_DLL,          DEFAULT_ROUTING_DLL,            &m_strRoutingDLL)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      DEFAULT_ROUTING_SOURCES,            &m_mszRoutingSources)   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        DEFAULT_LOCAL_DOMAINS,          &m_mszLocalDomains)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       DEFAULT_DOMAIN_ROUTING,         &m_mszDomainRouting)    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MASQUERADE_NAME,          DEFAULT_MASQUERADE_DOMAIN,  &m_strMasqueradeDomain) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_NDR_TO,          DEFAULT_SENDNDRTO,  &m_strNdrAddr)  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_BAD_TO,          DEFAULT_SENDBADTO,  &m_strBadAddr)  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   DEFAULT_REMOTE_SECURE_PORT, &m_lRemoteSecurePort)   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SHOULD_DELIVER,       DEFAULT_SHOULD_DELIVER, &m_fShouldDeliver  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,           DEFAULT_ALWAYS_USE_SSL,             &m_fAlwaysUseSsl  ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, DEFAULT_LIMIT_REMOTE_CONNECTIONS,   &m_fLimitRemoteConnections  )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  DEFAULT_MAX_OUT_CONN_PER_DOMAIN,    &m_lMaxOutConnPerDomain  )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,           DEFAULT_SMART_HOST_TYPE,        &m_lSmartHostType  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,          DEFAULT_BATCH_MSG_LIMIT,        &m_lBatchMsgLimit  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DO_MASQUERADE,            DEFAULT_DO_MASQUERADE,          &m_fDoMasquerade  ) && fRet;

    // the following properties are set on smtpsvc/<instance-id> level for virtual server

    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_BINDINGS,  DEFAULT_SERVER_BINDINGS,        &m_mszServerBindings )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_BINDINGS,  DEFAULT_SECURE_BINDINGS,        &m_mszSecureBindings )  && fRet;
//  fRet = StdGetMetabaseProp ( &metabase, MD_PORT,             DEFAULT_PORT,                   &m_lPort )              && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,      DEFAULT_MAX_IN_CONNECTION,      &m_lMaxInConnection )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,   DEFAULT_IN_CONNECTION_TIMEOUT,  &m_lInConnectionTimeout )   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,    DEFAULT_LOGFILE_DIRECTORY,          &m_strLogFileDirectory)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       DEFAULT_LOGFILE_PERIOD,             &m_lLogFilePeriod)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,DEFAULT_LOGFILE_TRUNCATE_SIZE,      &m_lLogFileTruncateSize)        && fRet;
//  fRet = StdGetMetabaseProp ( &metabase, MD_LOG_METHOD,       DEFAULT_LOG_METHOD,                 &m_lLogMethod)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOG_TYPE,     DEFAULT_LOG_TYPE,                   &m_lLogType)        && fRet;


    //  Get the admin ACL
    DWORD   dwDummy;

    pSD = NULL;
    cbSD    = 0;

    metabase.GetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, &dwDummy, &cbSD, METADATA_INHERIT);
    if ( cbSD != 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
        pSD = (PSECURITY_DESCRIPTOR) new char [ cbSD ];
        
        if( NULL == pSD )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
            
        fRet = metabase.GetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, pSD, &cbSD,METADATA_INHERIT );
    }

    // Check all property strings:
    // If any string is NULL, it is because we failed to allocate memory:
    if ( !ValidateStrings () ) {

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // We can only fail from memory allocations:
    _ASSERT ( fRet );

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

    // Validate the data received from the metabase:
    _ASSERT ( ValidateStrings () );
    _ASSERT ( ValidateProperties( ) );

    // Extract the Administrator list:
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
        m_psaAdmins = NULL;
    }
    if ( pSD ) {
        hr = AclToAdministrators ( m_strServer, pSD, &m_psaAdmins );
        BAIL_ON_FAILURE(hr);
    }

    if ( !ValidateProperties( ) ) {
        CorrectProperties ();
    }

Exit:
    delete (char*) pSD;

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::SendPropertiesToMetabase
//
//  Description:
//
//      Saves each property to the metabase.
//      This class's properties go into /LM/SmtpSvc/
//
//  Parameters:
//
//      fFailIfChanged  - Return a failure code if the metabase
//          has changed since last get.
//      pMetabase - the metabase object.
//
//  Returns:
//
//      E_OUTOFMEMORY and others.
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminService::SendPropertiesToMetabase ( 
    BOOL fFailIfChanged, 
    IMSAdminBase * pMetabase
    )
{
    TraceFunctEnter ( "CSmtpAdminService::SendPropertiesToMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;

    //
    //  Set the admin acl:
    //

    PSECURITY_DESCRIPTOR    pSD     = NULL;
    DWORD                   cbSD    = 0;

//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( m_psaAdmins ) {
            hr = AdministratorsToAcl ( m_strServer, m_psaAdmins, &pSD, &cbSD );
            BAIL_ON_FAILURE(hr);
        }
//  }


    hr = metabase.Open ( SMTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );
    if ( FAILED(hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );

        // !!!magnush - Should we return a simple Service doesn't exist error code?
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

    // Does the client care if the key has changed?
    if ( fFailIfChanged ) {

        //  Did the key change?
        if ( HasKeyChanged ( pMetabase, metabase.QueryHandle(), &m_ftLastChanged ) ) {

            StateTrace ( (LPARAM) this, "Metabase has changed, not setting properties" );
            // !!!magnush - Return the appropriate error code:
            hr = E_FAIL;
            goto Exit;
        }
    }

    //
    //  The general procedure here is to keep setting metabase properties
    //  as long as nothing has gone wrong.  This is done by short-circuiting
    //  the statement by ANDing it with the status code.  This makes the code
    //  much more concise.
    //

    fRet = TRUE;
#if 0
    if ( m_bvChangedFields & BitMask(ID_SSLPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,          m_lSSLPort )        && fRet;
    }
#endif
    if ( m_bvChangedFields & BitMask(ID_OUTBOUNDPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     m_lOutboundPort )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_HOP_COUNT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_HOP_COUNT,    m_lHopCount )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMARTHOST) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   m_strSmartHost )        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ENABLEDNSLOOKUP) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,m_fEnableDNSLookup )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTEREMAIL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, m_strPostmasterEmail )  && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTERNAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  m_strPostmasterName )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_FQDN) ) 
    {
        // need to set the UPDATED flag
        if( m_strFQDN.m_str && m_strFQDN.m_str[0] )
        {
            fRet = StdPutMetabaseProp ( &metabase, MD_UPDATED_FQDN, 1 )         && fRet;
            fRet = StdPutMetabaseProp ( &metabase, MD_FQDN_VALUE,   m_strFQDN )         && fRet;
        }
        else
        {
            // empty string indicating using TCP/IP setting
            fRet = StdPutMetabaseProp ( &metabase, MD_UPDATED_FQDN, 0 )         && fRet;
        }
    }

    if ( m_bvChangedFields & BitMask(ID_DEFAULTDOMAIN) ) 
    {
        // need to set the UPDATE flag
        fRet = StdPutMetabaseProp ( &metabase, MD_UPDATED_DEFAULT_DOMAIN,   1 )         && fRet;
        fRet = StdPutMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, m_strDefaultDomain )            && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DROPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,    m_strDropDir )          && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BADMAILDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     m_strBadMailDir )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_PICKUPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  m_strPickupDir )        && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_QUEUEDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   m_strQueueDir )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXOUTCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  m_lMaxOutConnection )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_OUTCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   m_lOutConnectionTimeout )   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     m_lMaxMessageSize )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXSESSIONSIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    m_lMaxSessionSize )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGERECIPIENTS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       m_lMaxMessageRecipients )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      m_lLocalRetryTime)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_REMOTERETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     m_lRemoteRetryTime)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ETRNDAYS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ETRN_DAYS,                m_lETRNDays)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGDLL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_DLL,          m_strRoutingDLL)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGSOURCES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      &m_mszRoutingSources)   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALDOMAINS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        &m_mszLocalDomains)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DOMAINROUTING) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       &m_mszDomainRouting)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     m_lLocalRetries)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTERETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    m_lRemoteRetries)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MASQUERADE_NAME,  m_strMasqueradeDomain)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDNDRTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_NDR_TO,  m_strNdrAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDBADTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_BAD_TO,  m_strBadAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTE_SECURE_PORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   m_lRemoteSecurePort)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SHOULD_DELIVER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SHOULD_DELIVER,   m_fShouldDeliver)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ALWAYS_USE_SSL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,   m_fAlwaysUseSsl)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LIMIT_REMOTE_CONNECTIONS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, m_fLimitRemoteConnections)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAX_OUT_CONN_PER_DOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  m_lMaxOutConnPerDomain)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMART_HOST_TYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,   m_lSmartHostType)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BATCH_MSG_LIMIT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,  m_lBatchMsgLimit)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DO_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DO_MASQUERADE,    m_fDoMasquerade)        && fRet;
    }

    // the following properties are set on smtpsvc/<instance-id> level for virtual server

    if ( m_bvChangedFields & BitMask(ID_SERVER_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SERVER_BINDINGS,      &m_mszServerBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SECURE_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_BINDINGS,      &m_mszSecureBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_PORT) ) 
    {
//      fRet = StdPutMetabaseProp ( &metabase, MD_PORT,             m_lPort )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXINCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  m_lMaxInConnection )    && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_INCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,m_lInConnectionTimeout )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOGFILEDIRECTORY) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,        m_strLogFileDirectory)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILEPERIOD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       m_lLogFilePeriod)       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILETRUNCATESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,    m_lLogFileTruncateSize)     && fRet;
    }
//  if ( m_bvChangedFields & BitMask(ID_LOGMETHOD) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogMethod)       && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_LOGTYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogType)     && fRet;
    }

//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( pSD ) {
            fRet = fRet && metabase.SetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, pSD, cbSD, METADATA_INHERIT | METADATA_REFERENCE);
        }
        else {
            pMetabase->DeleteData ( metabase.QueryHandle(), _T(""), MD_ADMIN_ACL, BINARY_METADATA );
        }
//  }


    // Save the data to the metabase:
    // hr = metabase.Close();
    // BAIL_ON_FAILURE(hr);
    metabase.Close();

    hr = pMetabase->SaveData ();
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed SaveData call (%x)", hr );
        goto Exit;
    }

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

Exit:
    delete (char*) pSD;

    if( SUCCEEDED(hr) && !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
    }

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::ValidateStrings
//
//  Description:
//
//      Checks to make sure each string property is non-null.
//
//  Returns:
//
//      FALSE if any string property is NULL.
//
//--------------------------------------------------------------------

BOOL CSmtpAdminService::ValidateStrings ( ) const
{
    TraceFunctEnter ( "CSmtpAdminService::ValidateStrings" );

    // Check all property strings:
    // If any string is NULL, return FALSE:
    if ( 
        !m_strSmartHost ||
        !m_strPostmasterEmail ||
        !m_strPostmasterName ||
        !m_strDefaultDomain ||
        !m_strBadMailDir ||
        !m_strPickupDir ||
        !m_strQueueDir ||
        !m_strRoutingDLL ||
        !m_strLogFileDirectory
        ) {

        ErrorTrace ( (LPARAM) this, "String validation failed" );

        TraceFunctLeave ();
        return FALSE;
    }

    _ASSERT ( IS_VALID_STRING ( m_strSmartHost ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterEmail ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterName ) );

    _ASSERT ( IS_VALID_STRING ( m_strDefaultDomain ) );

    _ASSERT ( IS_VALID_STRING ( m_strBadMailDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strPickupDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strQueueDir ) );

    _ASSERT ( IS_VALID_STRING ( m_strRoutingDLL ) );

    _ASSERT ( IS_VALID_STRING ( m_strLogFileDirectory ) );

    TraceFunctLeave ();
    return TRUE;
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminService::ValidateProperties
//
//  Description:
//
//      Checks to make sure all parameters are valid.
//
//  Parameters:
//
//
//  Returns:
//
//      FALSE if any property was not valid.  
//
//--------------------------------------------------------------------

BOOL CSmtpAdminService::ValidateProperties (  ) const
{
    BOOL    fRet    = TRUE;
    
    _ASSERT ( ValidateStrings () );
/*
    fRet = fRet && PV_MinMax    ( m_lPort, MIN_PORT, MAX_PORT );
    fRet = fRet && PV_MinMax    ( m_lSSLPort, MIN_SSLPORT, MAX_SSLPORT );
    fRet = fRet && PV_MinMax    ( m_lOutboundPort, MIN_OUTBOND_PORT, MAX_OUTBOND_PORT );

    fRet = fRet && PV_MinMax    ( m_lMaxInConnection, MIN_MAX_IN_CONNECTION, MAX_MAX_IN_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lMaxOutConnection, MIN_MAX_OUT_CONNECTION, MAX_MAX_OUT_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lInConnectionTimeout, MIN_IN_CONNECTION_TIMEOUT, MAX_IN_CONNECTION_TIMEOUT );
    fRet = fRet && PV_MinMax    ( m_lOutConnectionTimeout, MIN_OUT_CONNECTION_TIMEOUT, MAX_OUT_CONNECTION_TIMEOUT );

    fRet = fRet && PV_MinMax    ( m_lMaxMessageSize, MIN_MAX_MESSAGE_SIZE, MAX_MAX_MESSAGE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxSessionSize, MIN_MAX_SESSION_SIZE, MAX_MAX_SESSION_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxMessageRecipients, MIN_MAX_MESSAGE_RECIPIENTS, MAX_MAX_MESSAGE_RECIPIENTS );

    fRet = fRet && PV_MinMax    ( m_lLocalRetries, MIN_LOCAL_RETRIES, MAX_LOCAL_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lLocalRetryTime, MIN_LOCAL_RETRY_TIME, MAX_LOCAL_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetries, MIN_REMOTE_RETRIES, MAX_REMOTE_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetryTime, MIN_REMOTE_RETRY_TIME, MAX_REMOTE_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lETRNDays, MIN_ETRN_DAYS, MAX_ETRN_DAYS );

    fRet = fRet && PV_MinMax    ( m_lLogFilePeriod, MIN_LOGFILE_PERIOD, MAX_LOGFILE_PERIOD );
    fRet = fRet && PV_MinMax    ( m_lLogFileTruncateSize, MIN_LOGFILE_TRUNCATE_SIZE, MAX_LOGFILE_TRUNCATE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lLogMethod, MIN_LOG_METHOD, MAX_LOG_METHOD );
    fRet = fRet && PV_MinMax    ( m_lLogType, MIN_LOG_TYPE, MAX_LOG_TYPE );

    fRet = fRet && PV_Boolean   ( m_fEnableDNSLookup );
    fRet = fRet && PV_Boolean   ( m_fSendDNRToPostmaster );
    fRet = fRet && PV_Boolean   ( m_fSendBadmailToPostmaster );
*/
    return fRet;
}

void CSmtpAdminService::CorrectProperties ( )
{
/*
    if ( m_strServer && !PV_MaxChars    ( m_strServer, MAXLEN_SERVER ) ) {
        m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
    }
    if ( !PV_MinMax ( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT ) ) {
        m_dwArticleTimeLimit    = DEFAULT_ARTICLETIMELIMIT;
    }
    if ( !PV_MinMax ( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION ) ) {
        m_dwHistoryExpiration   = DEFAULT_HISTORYEXPIRATION;
    }
    if ( !PV_Boolean    ( m_fHonorClientMsgIDs ) ) {
        m_fHonorClientMsgIDs    = !!m_fHonorClientMsgIDs;
    }
    if ( !PV_MaxChars   ( m_strSmtpServer, MAXLEN_SMTPSERVER ) ) {
        m_strSmtpServer[ MAXLEN_SMTPSERVER - 1 ] = NULL;
    }
    if ( !PV_Boolean    ( m_fAllowClientPosts ) ) {
        m_fAllowClientPosts = !!m_fAllowClientPosts;
    }
    if ( !PV_Boolean    ( m_fAllowFeedPosts ) ) {
        m_fAllowFeedPosts   = !!m_fAllowFeedPosts;
    }
    if ( !PV_Boolean    ( m_fAllowControlMsgs ) ) {
        m_fAllowControlMsgs = !!m_fAllowControlMsgs;
    }
    if ( !PV_MaxChars   ( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN ) ) {
        m_strDefaultModeratorDomain[ MAXLEN_DEFAULTMODERATORDOMAIN - 1] = NULL;
    }
    if ( !PV_MinMax ( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK ) ) {
        m_dwCommandLogMask  = DEFAULT_COMMANDLOGMASK;
    }
    if ( !PV_Boolean    ( m_fDisableNewnews ) ) {
        m_fDisableNewnews   = !!m_fDisableNewnews;
    }
    if ( !PV_MinMax ( m_dwExpireRunFrequency, MIN_EXPIRERUNFREQUENCY, MAX_EXPIRERUNFREQUENCY ) ) {
        m_dwExpireRunFrequency  = DEFAULT_EXPIRERUNFREQUENCY;
    }
    if ( !PV_MinMax ( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY ) ) {
        m_dwShutdownLatency     = DEFAULT_SHUTDOWNLATENCY;
    }


  

---------
    if ( m_bvChangedFields & BitMask(ID_PORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_PORT,             m_lPort )       && fRet;
    }
#if 0
    if ( m_bvChangedFields & BitMask(ID_SSLPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,          m_lSSLPort )        && fRet;
    }
#endif
    if ( m_bvChangedFields & BitMask(ID_OUTBOUNDPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     m_lOutboundPort )       && fRet;
    }


    if ( m_strServer && !PV_MaxChars    ( m_strServer, MAXLEN_SERVER ) ) {
        m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
    }
    if ( m_bvChangedFields & BitMask(ID_SMARTHOST) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   m_strSmartHost )        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ENABLEDNSLOOKUP) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,m_fEnableDNSLookup )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTEREMAIL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, m_strPostmasterEmail )  && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTERNAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  m_strPostmasterName )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DEFAULTDOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, m_strDefaultDomain )            && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BADMAILDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     m_strBadMailDir )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_PICKUPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  m_strPickupDir )        && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_QUEUEDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   m_strQueueDir )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXINCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  m_lMaxInConnection )    && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXOUTCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  m_lMaxOutConnection )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_INCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,m_lInConnectionTimeout )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_OUTCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   m_lOutConnectionTimeout )   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     m_lMaxMessageSize )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXSESSIONSIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    m_lMaxSessionSize )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGERECIPIENTS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       m_lMaxMessageRecipients )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXRETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     m_lMaxRetries )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOCALRETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      m_lLocalRetryTime)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_REMOTERETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     m_lRemoteRetryTime)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ETRNDAYS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ETRN_DAYS,                m_lETRNDays)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDDNRTOPOSTMASTER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_NDR_TO_ADMIN,        m_fSendDNRToPostmaster)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_SENDBADMAILTOPOSTMASTER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_BAD_TO_ADMIN,        m_fSendBadmailToPostmaster)     && fRet;
    }

//  if ( m_bvChangedFields & BitMask(ID_RTTYPE) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      m_lRTType)      && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_ROUTINGSOURCES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      m_strRoutingSources)        && fRet;
    }


    if ( m_bvChangedFields & BitMask(ID_LOGFILEDIRECTORY) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,        m_strLogFileDirectory)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILEPERIOD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       m_lLogFilePeriod)       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILETRUNCATESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,    m_lLogFileTruncateSize)     && fRet;
    }
//  if ( m_bvChangedFields & BitMask(ID_LOGMETHOD) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogMethod)       && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_LOGTYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogType)     && fRet;
    }


*/
    _ASSERT ( ValidateProperties ( ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\rtsrc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

        rtsrc.h

Abstract:

        Header file for IRoutingSource interface

Author:

        Fei Su (feisu)       9/22/97    Created.

Revision History:

--*/

class CRoutingSource : 
    public CComDualImpl<IRoutingSource, &IID_IRoutingSource, &LIBID_SMTPADMLib>, 
    public ISupportErrorInfo,
    public CComObjectRoot
{
public:
    CRoutingSource() : m_dwFC(0) {}
    virtual ~CRoutingSource(){}

BEGIN_COM_MAP(CRoutingSource)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IRoutingSource)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

/*
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) ;
*/

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IRoutingSource properties:
    STDMETHODIMP    get_Type            ( BSTR * pstrType );
    STDMETHODIMP    put_Type            ( BSTR strType );

    STDMETHODIMP    get_DataDirectory   ( BSTR * pstrDataDirectory );
    STDMETHODIMP    put_DataDirectory   ( BSTR strDataDirectory );

    STDMETHODIMP    get_DefaultMailRoot ( BSTR * pstrDefaultMailRoot );
    STDMETHODIMP    put_DefaultMailRoot ( BSTR strDefaultMailRoot );

    STDMETHODIMP    get_BindType        ( BSTR * pstrBindType );
    STDMETHODIMP    put_BindType        ( BSTR strBindType );

    STDMETHODIMP    get_SchemaType      ( BSTR * pstrSchemaType );
    STDMETHODIMP    put_SchemaType      ( BSTR strSchemaType );

    STDMETHODIMP    get_Host            ( BSTR * pstrHost );
    STDMETHODIMP    put_Host            ( BSTR strHost );

    STDMETHODIMP    get_NamingContext   ( BSTR * pstrNamingContext );
    STDMETHODIMP    put_NamingContext   ( BSTR strNamingContext );

    STDMETHODIMP    get_Account         ( BSTR * pstrAccount );
    STDMETHODIMP    put_Account         ( BSTR strAccount );

    STDMETHODIMP    get_Password        ( BSTR * pstrPassword );
    STDMETHODIMP    put_Password        ( BSTR strPassword );

    // Internal methods
    HRESULT         Get(CMetabaseKey * pMBVirtualServer);
    HRESULT         Set(CMetabaseKey * pMBVirtualServer);

private:
    CComBSTR        m_strType;
    CComBSTR        m_strDataDirectory;
    CComBSTR        m_strDefaultMailroot;
    CComBSTR        m_strBindType;
    CComBSTR        m_strSchemaType;
    CComBSTR        m_strHost;
    CComBSTR        m_strNamingContext;
    CComBSTR        m_strAccount;
    CComBSTR        m_strPassword;

    DWORD           m_dwFC;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\service.h ===
// expire.h : Declaration of the CSmtpAdminService


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Dependencies
/////////////////////////////////////////////////////////////////////////////

#include "metafact.h"
#include "cmultisz.h"

struct IMSAdminBase;

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminService : 
	public CComDualImpl<ISmtpAdminService, &IID_ISmtpAdminService, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminService,&CLSID_CSmtpAdminService>
{
public:
	CSmtpAdminService();
	virtual ~CSmtpAdminService ();
BEGIN_COM_MAP(CSmtpAdminService)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdminService)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminService) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminService, _T("Smtpadm.Service.1"), _T("Smtpadm.Service"), IDS_SMTPADMIN_SERVICE_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdminService
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which Server to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	// No instance for the server interface

	// Server Properties:

	STDMETHODIMP	get_ServerBindings	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindings	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_ServerBindingsVariant	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindingsVariant	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_SecureBindings	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindings	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_SecureBindingsVariant	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindingsVariant	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_Port			( long * lPort );
	STDMETHODIMP	put_Port			( long lPort );

	STDMETHODIMP	get_SSLPort			( long * lSSLPort );
	STDMETHODIMP	put_SSLPort			( long lSSLPort );

	STDMETHODIMP	get_OutboundPort	( long * lOutboundPort );
	STDMETHODIMP	put_OutboundPort	( long lOutboundPort );

	STDMETHODIMP	get_HopCount		( long * lHopCount );
	STDMETHODIMP	put_HopCount		( long lHopCount );

	STDMETHODIMP	get_SmartHost		( BSTR * pstrSmartHost );
	STDMETHODIMP	put_SmartHost		( BSTR strSmartHost );

	STDMETHODIMP	get_EnableDNSLookup	( BOOL * pfEnableDNSLookup );
	STDMETHODIMP	put_EnableDNSLookup	( BOOL fEnableDNSLookup );

	STDMETHODIMP	get_PostmasterEmail	( BSTR * pstrPostmasterEmail );
	STDMETHODIMP	put_PostmasterEmail	( BSTR strPostmasterEmail );

	STDMETHODIMP	get_PostmasterName	( BSTR * pstrPostmasterName );
	STDMETHODIMP	put_PostmasterName	( BSTR strPostmasterName );

	STDMETHODIMP	get_DefaultDomain	( BSTR * pstrDefaultDomainName );
	STDMETHODIMP	put_DefaultDomain	( BSTR strDefaultDomainName );

	STDMETHODIMP	get_FQDN			( BSTR * pstrFQDN );
	STDMETHODIMP	put_FQDN			( BSTR strFQDN );

	STDMETHODIMP	get_DropDir			( BSTR * pstrDropDir );
	STDMETHODIMP	put_DropDir			( BSTR strDropDir );

	STDMETHODIMP	get_BadMailDir		( BSTR * pstrBadMailDir );
	STDMETHODIMP	put_BadMailDir		( BSTR strBadMailDir );

	STDMETHODIMP	get_PickupDir		( BSTR * pstrPickupDir );
	STDMETHODIMP	put_PickupDir		( BSTR strPickupDir );

	STDMETHODIMP	get_QueueDir		( BSTR * pstrQueueDir );
	STDMETHODIMP	put_QueueDir		( BSTR strQueueDir );

	STDMETHODIMP	get_MaxInConnection		( long * lMaxInConnection );
	STDMETHODIMP	put_MaxInConnection		( long lMaxInConnection );

	STDMETHODIMP	get_MaxOutConnection	( long * lMaxOutConnection );
	STDMETHODIMP	put_MaxOutConnection	( long lMaxOutConnection );

	STDMETHODIMP	get_InConnectionTimeout	( long * lInConnectionTimeout );
	STDMETHODIMP	put_InConnectionTimeout	( long lInConnectionTimeout );

	STDMETHODIMP	get_OutConnectionTimeout( long * lOutConnectionTimeout );
	STDMETHODIMP	put_OutConnectionTimeout( long lOutConnectionTimeout );

	STDMETHODIMP	get_MaxMessageSize		( long * lMaxMessageSize );
	STDMETHODIMP	put_MaxMessageSize		( long lMaxMessageSize );

	STDMETHODIMP	get_MaxSessionSize		( long * lMaxSessionSize );
	STDMETHODIMP	put_MaxSessionSize		( long lMaxSessionSize );

	STDMETHODIMP	get_MaxMessageRecipients	( long * lMaxMessageRecipients );
	STDMETHODIMP	put_MaxMessageRecipients	( long lMaxMessageRecipients );

	STDMETHODIMP	get_LocalRetries		( long * lLocalRetries );
	STDMETHODIMP	put_LocalRetries		( long lLocalRetries );

	STDMETHODIMP	get_LocalRetryTime		( long * lLocalRetryTime );
	STDMETHODIMP	put_LocalRetryTime		( long lLocalRetryTime );

	STDMETHODIMP	get_RemoteRetries		( long * lRemoteRetries );
	STDMETHODIMP	put_RemoteRetries		( long lRemoteRetries );

	STDMETHODIMP	get_RemoteRetryTime		( long * lRemoteRetryTime );
	STDMETHODIMP	put_RemoteRetryTime		( long lRemoteRetryTime );

	STDMETHODIMP	get_ETRNDays			( long * lETRNDays );
	STDMETHODIMP	put_ETRNDays			( long lETRNDays );

	STDMETHODIMP	get_SendDNRToPostmaster	( BOOL * pfSendDNRToPostmaster );
	STDMETHODIMP	put_SendDNRToPostmaster	( BOOL fSendDNRToPostmaster );

	STDMETHODIMP	get_SendBadmailToPostmaster		( BOOL * pfSendBadmailToPostmaster);
	STDMETHODIMP	put_SendBadmailToPostmaster		( BOOL fSendBadmailToPostmaster );

	STDMETHODIMP	get_RoutingDLL			( BSTR * pstrRoutingDLL );
	STDMETHODIMP	put_RoutingDLL			( BSTR strRoutingDLL );


	STDMETHODIMP	get_RoutingSources		( SAFEARRAY ** ppsastrRoutingSources );
	STDMETHODIMP	put_RoutingSources		( SAFEARRAY * pstrRoutingSources );

	STDMETHODIMP	get_RoutingSourcesVariant	( SAFEARRAY ** ppsastrRoutingSources );
	STDMETHODIMP	put_RoutingSourcesVariant	( SAFEARRAY * pstrRoutingSources );

	STDMETHODIMP	get_LocalDomains		( SAFEARRAY ** ppsastrLocalDomains );
	STDMETHODIMP	put_LocalDomains		( SAFEARRAY * pstrLocalDomains );

	STDMETHODIMP	get_DomainRouting		( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRouting		( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_DomainRoutingVariant	( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRoutingVariant	( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_MasqueradeDomain	( BSTR * pstrMasqueradeDomain );
	STDMETHODIMP	put_MasqueradeDomain	( BSTR strMasqueradeDomain );


	STDMETHODIMP	get_SendNdrTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendNdrTo			( BSTR strAddr );

	STDMETHODIMP	get_SendBadTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendBadTo			( BSTR strAddr );
	
	STDMETHODIMP	get_RemoteSecurePort	( long * plRemoteSecurePort );
	STDMETHODIMP	put_RemoteSecurePort	( long lRemoteSecurePort );

	STDMETHODIMP	get_ShouldDeliver		( BOOL * pfShouldDeliver );
	STDMETHODIMP	put_ShouldDeliver		( BOOL fShouldDeliver );

	STDMETHODIMP	get_AlwaysUseSsl			( BOOL * pfAlwaysUseSsl );
	STDMETHODIMP	put_AlwaysUseSsl			( BOOL fAlwaysUseSsl );

	STDMETHODIMP	get_LimitRemoteConnections	( BOOL * pfLimitRemoteConnections );
	STDMETHODIMP	put_LimitRemoteConnections	( BOOL fLimitRemoteConnections );

	STDMETHODIMP	get_MaxOutConnPerDomain		( long * plMaxOutConnPerDomain );
	STDMETHODIMP	put_MaxOutConnPerDomain		( long lMaxOutConnPerDomain );

	STDMETHODIMP	get_AllowVerify				( BOOL * pfAllowVerify );
	STDMETHODIMP	put_AllowVerify				( BOOL fAllowVerify	);

	STDMETHODIMP	get_AllowExpand				( BOOL * pfAllowExpand );
	STDMETHODIMP	put_AllowExpand				( BOOL fAllowExpand );

	STDMETHODIMP	get_SmartHostType			( long * plSmartHostType );
	STDMETHODIMP	put_SmartHostType			( long lSmartHostType );

	STDMETHODIMP	get_BatchMessages			( BOOL * pfBatchMessages );
	STDMETHODIMP	put_BatchMessages			( BOOL fBatchMessages );

	STDMETHODIMP	get_BatchMessageLimit		( long * plBatchMessageLimit );
	STDMETHODIMP	put_BatchMessageLimit		( long lBatchMessageLimit );

	STDMETHODIMP	get_DoMasquerade			( BOOL * pfDoMasquerade );
	STDMETHODIMP	put_DoMasquerade			( BOOL fDoMasquerade );

	STDMETHODIMP	get_Administrators			( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_Administrators			( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_AdministratorsVariant	( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_AdministratorsVariant	( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_LogFileDirectory	( BSTR * pstrLogFileDirectory );
	STDMETHODIMP	put_LogFileDirectory	( BSTR strLogFileDirectory );

	STDMETHODIMP	get_LogFilePeriod		( long * lLogFilePeriod );
	STDMETHODIMP	put_LogFilePeriod		( long lLogFilePeriod );

	STDMETHODIMP	get_LogFileTruncateSize	( long * lLogFileTruncateSize );
	STDMETHODIMP	put_LogFileTruncateSize	( long lLogFileTruncateSize );

	STDMETHODIMP	get_LogMethod			( long * lLogMethod );
	STDMETHODIMP	put_LogMethod			( long lLogMethod );

	STDMETHODIMP	get_LogType				( long * lLogType );
	STDMETHODIMP	put_LogType				( long lLogType );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Get ( );
	STDMETHODIMP	Set ( BOOL fFailIfChanged );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;

	long		m_lPort;					// obselete, use server bindings
	CMultiSz    m_mszServerBindings;		// MultiString
	CMultiSz    m_mszSecureBindings;		// MultiString

	long		m_lSSLPort;
	long		m_lOutboundPort;
	long		m_lRemoteSecurePort;

	CComBSTR	m_strSmartHost;
	BOOL		m_fEnableDNSLookup;
	CComBSTR	m_strPostmasterEmail;
	CComBSTR	m_strPostmasterName;

	CComBSTR	m_strFQDN;
	CComBSTR	m_strDefaultDomain;

	CComBSTR	m_strDropDir;
	CComBSTR	m_strBadMailDir;
	CComBSTR	m_strPickupDir;
	CComBSTR	m_strQueueDir;

	long		m_lHopCount;
	long		m_lMaxInConnection;
	long		m_lMaxOutConnection;
	long		m_lInConnectionTimeout;
	long		m_lOutConnectionTimeout;

	long		m_lMaxMessageSize;
	long		m_lMaxSessionSize;
	long		m_lMaxMessageRecipients;

	long		m_lLocalRetries;
	long		m_lLocalRetryTime;
	long		m_lRemoteRetries;
	long		m_lRemoteRetryTime;

	long		m_lETRNDays;

	BOOL		m_fSendDNRToPostmaster;
	BOOL		m_fSendBadmailToPostmaster;

	CComBSTR	m_strRoutingDLL;
	CMultiSz	m_mszRoutingSources;	// MultiString

	CMultiSz    m_mszLocalDomains;		// MultiString
	CMultiSz    m_mszDomainRouting;		// MultiString

	BOOL		m_fDoMasquerade;
	CComBSTR	m_strMasqueradeDomain;

	CComBSTR	m_strNdrAddr;
	CComBSTR	m_strBadAddr;

	BOOL		m_fShouldDeliver;
	BOOL		m_fAlwaysUseSsl;
	BOOL		m_fLimitRemoteConnections;
	long		m_lMaxOutConnPerDomain;

	BOOL		m_fAllowVerify;
	BOOL		m_fAllowExpand;
	long		m_lSmartHostType;

	BOOL		m_fBtachMsgs;
	long		m_lBatchMsgLimit;

	SAFEARRAY *	m_psaAdmins;

	CComBSTR	m_strLogFileDirectory;
	long		m_lLogFilePeriod;
	long		m_lLogFileTruncateSize;
	long		m_lLogMethod;
	long		m_lLogType;

	// Status:
	BOOL		m_fGotProperties;
	DWORD   	m_bvChangedFields;
	FILETIME	m_ftLastChanged;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT 	GetPropertiesFromMetabase	( IMSAdminBase * pMetabase );
	HRESULT 	SendPropertiesToMetabase	( BOOL fFailIfChanged, IMSAdminBase * pMetabase );

	// Validation:
	BOOL		ValidateStrings ( ) const;
	BOOL		ValidateProperties ( ) const;
	void		CorrectProperties ( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\sessions.cpp ===
// sessions.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "sessions.h"
#include "oleutil.h"
#include "smtpcmn.h"

#include "smtptype.h"
#include "smtpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.Sessions.1")
#define THIS_FILE_IID				IID_ISmtpAdminSessions

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminSessions, CSmtpAdminSessions, IID_ISmtpAdminSessions)

STDMETHODIMP CSmtpAdminSessions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminSessions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminSessions::CSmtpAdminSessions () :
	m_cCount				( 0 ),
	m_dwId					( 0 ),
	m_dwConnectTime			( 0 ),
	m_pSessionInfo			( NULL ),
	m_fSetCursor			( FALSE )
	// CComBSTR's are initialized to NULL by default.
{
    InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Sessions") );
    m_iadsImpl.SetClass ( _T("IIsSmtpSessions") );
}

CSmtpAdminSessions::~CSmtpAdminSessions ()
{
	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
	}

	// All CComBSTR's are freed automatically.
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminSessions,m_iadsImpl)


//
//  enum props
//
STDMETHODIMP CSmtpAdminSessions::get_Count ( long * plCount )
{
	// Count should check to be sure the client enumerated.

	return StdPropertyGet ( m_cCount, plCount );
}

STDMETHODIMP CSmtpAdminSessions::get_UserName ( BSTR * pstrUsername )
{
	return StdPropertyGet ( m_strUsername, pstrUsername );
}

STDMETHODIMP CSmtpAdminSessions::get_Host( BSTR * pstrHost )
{
	return StdPropertyGet ( m_strHost, pstrHost );
}

STDMETHODIMP CSmtpAdminSessions::get_UserId ( long * plId )
{
	return StdPropertyGet ( m_dwId, plId );
}

STDMETHODIMP CSmtpAdminSessions::put_UserId ( long lId )
{
	return StdPropertyPut ( &m_dwId, lId );
}

STDMETHODIMP CSmtpAdminSessions::get_ConnectTime ( long * plConnectTime )
{
	return StdPropertyGet ( m_dwConnectTime, plConnectTime );
}



//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminSessions::Enumerate (  )
{
	// Variables:
	HRESULT					hr			= NOERROR;
	NET_API_STATUS			err;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Enumerating loses the cursor:
	m_fSetCursor = FALSE;

	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
		m_cCount = 0;
	}

	// Call the enumerate sessions RPC:

	err = SmtpGetConnectedUserList (
		m_iadsImpl.QueryComputer(),
		&m_pSessionInfo,
		m_iadsImpl.QueryInstance()
		);

	if( err == NO_ERROR )
	{
		m_cCount = m_pSessionInfo->cEntries;
	}
	else
	{
		hr = SmtpCreateExceptionFromWin32Error ( err );
		goto Exit;
	}

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}

STDMETHODIMP CSmtpAdminSessions::GetNth ( long lIndex )
{
	HRESULT		hr	= NOERROR;

	// Did we enumerate first?
	if ( m_pSessionInfo == NULL ) {

		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_pSessionInfo [ lIndex ] to member variables:
	//

	// ( CComBSTR handles free-ing of old properties )

	m_dwId			= m_pSessionInfo->aConnUserEntry[ lIndex ].dwUserId;
	m_dwConnectTime	= m_pSessionInfo->aConnUserEntry[ lIndex ].dwConnectTime;

	m_strUsername = m_pSessionInfo->aConnUserEntry[ lIndex ].lpszName;
	if ( m_strUsername == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	m_strHost = m_pSessionInfo->aConnUserEntry[ lIndex ].lpszHost;

	if ( m_strHost == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// GetNth sets the cursor:
	m_fSetCursor = TRUE;

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}

STDMETHODIMP CSmtpAdminSessions::Terminate (  )
{
	HRESULT	hr = NOERROR;
	DWORD	err;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Call the TerminateSession RPC:
	err = SmtpDisconnectUser ( 
		m_iadsImpl.QueryComputer(), 
		m_dwId,
		m_iadsImpl.QueryInstance()
		);

	if(  err != NOERROR ) {
		hr = SmtpCreateExceptionFromWin32Error ( err );
		goto Exit;
	}

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}

STDMETHODIMP CSmtpAdminSessions::TerminateAll (  )
{

	// Did we enumerate first?
	HRESULT				hr = NOERROR;
	DWORD				ErrResult = 0;
	DWORD				Err;
	DWORD				i;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Make sure the user has enumerated:
	if ( m_pSessionInfo == NULL ) {

		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );
	}

	// For Each Session:
	for ( i = 0; i < m_cCount; i++ ) {

		// Call the terminate session RPC:
		Err = SmtpDisconnectUser ( 
			m_iadsImpl.QueryComputer(), 
			m_pSessionInfo->aConnUserEntry[ i ].dwUserId,
			m_iadsImpl.QueryInstance()
			);

		if ( Err != 0 && ErrResult == 0 ) {
			ErrResult = Err;
		}
	}

	if(  ErrResult != NOERROR ) {
		hr = SmtpCreateExceptionFromWin32Error ( ErrResult );
		goto Exit;
	}

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\smtpcmn.h ===
// Common header file for the Smtp administration objects.

// Dependencies: please include stdafx.h" first
//
#include "resource.h"

// Constants:

#define HELP_FILE_NAME		_T("smtpadm.hlp")

// Exception creation:

#define SmtpCreateException(nDescriptionId) 	\
	CreateException ( 						\
		_Module.GetResourceInstance(), 		\
		THIS_FILE_IID, 						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(nDescriptionId) 					\
		)

#define SmtpCreateExceptionFromHresult(hr)	\
	CreateExceptionFromHresult (			\
		_Module.GetResourceInstance(),		\
		THIS_FILE_IID,						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(hr)								\
		)

#define SmtpCreateExceptionFromWin32Error(error)	\
	CreateExceptionFromWin32Error (					\
		_Module.GetResourceInstance(),				\
		THIS_FILE_IID,								\
		HELP_FILE_NAME,								\
		THIS_FILE_HELP_CONTEXT,						\
		THIS_FILE_PROG_ID,							\
		(error)										\
		)

// Property validation:

#define VALIDATE_STRING(string, maxlen) \
	if ( !PV_MaxChars ( (string), (maxlen) ) ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_STRING_TOO_LONG );	\
	}

#define VALIDATE_DWORD(dw, dwMin, dwMax)	\
	if ( !PV_MinMax ( (DWORD) (dw), (DWORD) (dwMin), (DWORD) (dwMax) ) ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define VALIDATE_LONG(l, lMin, lMax)	\
	if ( !PV_MinMax ( (l), (lMin), (lMax) ) ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define CHECK_FOR_SET_CURSOR(fEnumerated,fSetCursor)	\
{							\
	if ( !fEnumerated ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );	\
	}						\
							\
	if ( !fSetCursor ) {	\
		return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_SET_CURSOR );	\
	}						\
}

// Metabase paths:

inline void GetMDInstancePath ( TCHAR * szInstancePath, DWORD dwServiceInstance )
{
	wsprintf ( szInstancePath, SMTP_MD_ROOT_PATH _T("%d/"), dwServiceInstance );
}


inline void GetMDParamPath ( TCHAR * szParamPath, DWORD dwServiceInstance )
{
	wsprintf ( szParamPath, SMTP_MD_ROOT_PATH _T("%d/"), dwServiceInstance );
}

inline void GetMDRootPath ( TCHAR * szRootPath, DWORD dwServiceInstance )
{
	wsprintf ( szRootPath, SMTP_MD_ROOT_PATH _T("%d/Root/"), dwServiceInstance );
}

inline void GetMDVDirPath ( TCHAR * szVDirPath, DWORD dwServiceInstance, TCHAR * szName )
{
	wsprintf ( szVDirPath, SMTP_MD_ROOT_PATH _T("%d/Root/%s"), dwServiceInstance, szName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\smtpadm.cpp ===
// smtpadm.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f smtpadmps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "adsiid.h"
#include "smtpadm.h"

#include "admin.h"
#include "service.h"
#include "virsvr.h"
#include "sessions.h"
#include "vdir.h"

#include "alias.h"
#include "user.h"
#include "dl.h"
#include "domain.h"
#include "webhelp.h"

#include "regmacro.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSmtpAdmin, CSmtpAdmin)
	OBJECT_ENTRY(CLSID_CSmtpAdminService, CSmtpAdminService)
	OBJECT_ENTRY(CLSID_CSmtpAdminVirtualServer, CSmtpAdminVirtualServer)
	OBJECT_ENTRY(CLSID_CSmtpAdminSessions, CSmtpAdminSessions)
	OBJECT_ENTRY(CLSID_CSmtpAdminVirtualDirectory, CSmtpAdminVirtualDirectory)
	OBJECT_ENTRY(CLSID_CSmtpAdminAlias, CSmtpAdminAlias)
	OBJECT_ENTRY(CLSID_CSmtpAdminUser, CSmtpAdminUser)
	OBJECT_ENTRY(CLSID_CSmtpAdminDL, CSmtpAdminDL)
	OBJECT_ENTRY(CLSID_CSmtpAdminDomain, CSmtpAdminDomain)
	OBJECT_ENTRY(CLSID_CWebAdminHelper, CWebAdminHelper)
	OBJECT_ENTRY(CLSID_CWebAdminHelper, CWebAdminHelper)
END_OBJECT_MAP()

BEGIN_EXTENSION_REGISTRATION_MAP
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpAlias, SmtpAdminAlias)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpDomain, SmtpAdminDomain)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpDL, SmtpAdminDL)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpSessions, SmtpAdminSessions)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsSmtpUser, SmtpAdminUser)
END_EXTENSION_REGISTRATION_MAP

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
//		InitAsyncTrace ();
		
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
//		TermAsyncTrace ();
		
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// register extensions
	RegisterExtensions();

	// registers object, typelib and all interfaces in typelib
	return(_Module.RegisterServer(TRUE));
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	// register extensions
	UnregisterExtensions();

	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\sessions.h ===
// sessions.h : Declaration of the CSmtpAdminSessions


#include "resource.h"       // main symbols

/*
typedef SMTP_CONN_USER_ENTRY _SMTP_CONN_USER_ENTRY;
typedef _SMTP_CONN_USER_ENTRY   SMTP_CONN_USER_ENTRY;
typedef _SMTP_CONN_USER_ENTRY * LPSMTP_CONN_USER_ENTRY;
*/

#define MAX_USER_NAME_LENGTH	256

#include "smtpapi.h"

/*
typedef struct _SMTP_CONN_USER_ENTRY {

    FILETIME        SessionStartTime;
    DWORD           IPAddress;          // ipaddress
    DWORD           PortConnected;      // port connected to
    CHAR            UserName[MAX_USER_NAME_LENGTH+1]; // logged on user

} SMTP_CONN_USER_ENTRY, *LPSMTP_CONN_USER_ENTRY;
*/


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminSessions : 
	public ISmtpAdminSessions,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminSessions,&CLSID_CSmtpAdminSessions>
{
public:
	CSmtpAdminSessions();
	virtual ~CSmtpAdminSessions ();
BEGIN_COM_MAP(CSmtpAdminSessions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminSessions)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminSessions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminSessions, _T("Smtpadm.Sessions.1"), _T("Smtpadm.Sessions"), IDS_SMTPADMIN_SESSIONS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminSessions
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminSessions
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Count			( long * plCount );

	STDMETHODIMP	get_UserName		( BSTR * pstrUsername );
	STDMETHODIMP	get_Host			( BSTR * pstrHost );

	STDMETHODIMP	get_UserId				( long * plId );
	STDMETHODIMP	put_UserId				( long lId );

	STDMETHODIMP	get_ConnectTime		( long * plConnectTime );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate		(  );
	STDMETHODIMP	GetNth			( long lIndex );
	STDMETHODIMP	Terminate		(  );
	STDMETHODIMP	TerminateAll	(  );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	// Property variables:
	DWORD		m_cCount;

	DWORD		m_dwId;

	CComBSTR	m_strUsername;
	CComBSTR	m_strHost;

	DWORD		m_dwConnectTime;
	//DWORD		m_dwPort;	// not used yet

	// Service variables:
	BOOL		m_fSetCursor;

	LPSMTP_CONN_USER_LIST		m_pSessionInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\smtpprop.h ===
#ifndef _SMTP_PROP_H__
#define _SMTP_PROP_H__

// const
#define TSTR_POSTMASTR_NAME         _T("Postmaster")

// Bitmasks for changed fields:

#define ID_SERVER_BINDINGS			0
#define ID_PORT						0

#define ID_SSLPORT					1
#define ID_SECURE_BINDINGS			1

#define ID_OUTBOUNDPORT				2
#define ID_REMOTE_SECURE_PORT		2

#define ID_SMARTHOST				3
#define ID_SMART_HOST_TYPE			3
#define ID_SHOULD_DELIVER			3

#define ID_ENABLEDNSLOOKUP			4
#define ID_POSTMASTEREMAIL			5
#define ID_POSTMASTERNAME			5

#define ID_HOP_COUNT				6

#define ID_AUTH_PACKAGES            7
#define ID_CLEARTEXT_AUTH_PACKAGE   7
#define ID_AUTH_METHOD              7
#define ID_DEFAULT_LOGON_DOMAIN     7

#define ID_DROPDIR					8
#define ID_BADMAILDIR				8
#define ID_PICKUPDIR				8
#define ID_QUEUEDIR					8

#define ID_ALLOW_VERIFY				9
#define ID_ALLOW_EXPAND				9

#define ID_ROUTE_ACTION             10
#define ID_ROUTE_USER_NAME          10
#define ID_ROUTE_PASSWORD           10

#define ID_ALWAYS_USE_SSL			11
#define ID_MAX_OUT_CONN_PER_DOMAIN	11

#define ID_LIMIT_REMOTE_CONNECTIONS	11

#define ID_MAXINCONNECTION			11
#define ID_MAXOUTCONNECTION			11
#define ID_INCONNECTIONTIMEOUT		11
#define ID_OUTCONNECTIONTIMEOUT		11

#define ID_BATCH_MSGS				12
#define ID_BATCH_MSG_LIMIT			12

// these two must be unique
#define ID_FQDN						13
#define ID_DEFAULTDOMAIN			14

#define ID_MAXMESSAGESIZE			15
#define ID_MAXSESSIONSIZE			15
#define ID_MAXMESSAGERECIPIENTS		15

#define ID_LOCALRETRIES				18
#define ID_REMOTERETRIES			18

#define ID_LOCALRETRYTIME			18
#define ID_REMOTERETRYTIME			18

#define ID_DO_MASQUERADE			19
#define ID_MASQUERADE				19

#define ID_ETRNDAYS					21

#define ID_SENDDNRTOPOSTMASTER		22
#define ID_SENDBADMAILTOPOSTMASTER	22
#define ID_SENDNDRTO				22
#define ID_SENDBADTO				22

#define ID_ROUTINGDLL				24
#define ID_ROUTINGSOURCES			24

#define ID_LOGFILEDIRECTORY			25
#define ID_LOGFILEPERIOD			25
#define ID_LOGFILETRUNCATESIZE		25
#define ID_LOGMETHOD				25
#define ID_LOGTYPE					25

#define ID_LOCALDOMAINS				26
#define ID_DOMAINROUTING			27

#define ID_AUTOSTART				28
#define ID_COMMENT					29


inline DWORD BitMask(DWORD dwId)
{
	_ASSERT(dwId < 32);
	return ( ((DWORD)1) << dwId );
}


// Default Values:
#define UNLIMITED                       ( 0xffffffff )

#define MAX_LONG						UNLIMITED

#define DEFAULT_SERVER_BINDINGS			( ( L":25:\0\0" ) )				// multisz
#define DEFAULT_SECURE_BINDINGS			( ( L":465:\0\0" ) )				// multisz

#define DEFAULT_COMMENT					(_T( "" ))

#define DEFAULT_SMART_HOST				(_T( "" ))
#define DEFAULT_SMART_HOST_TYPE			( 0 )

#define DEFAULT_SHOULD_DELIVER			( TRUE )
#define DEFAULT_ALLOW_EXPAND			( FALSE )
#define DEFAULT_ALLOW_VERIFY			( FALSE )

#define DEFAULT_POSTMASTER_EMAIL		(_T( "Postmaster" ))
#define DEFAULT_POSTMASTER_NAME			(_T( "Postmaster" ))

#define DEFAULT_SENDNDRTO				(_T( "" ))
#define DEFAULT_SENDBADTO				(_T( "" ))

#define DEFAULT_FQDN					(_T( "" ))
#define DEFAULT_DEFAULT_DOMAIN			(_T( "" ))

#define DEFAULT_DO_MASQUERADE			( FALSE )
#define DEFAULT_MASQUERADE_DOMAIN		(_T( "" ))

#define DEFAULT_DROP_DIR				(_T( "" ))
#define DEFAULT_BADMAIL_DIR				(_T( "" ))
#define DEFAULT_PICKUP_DIR				(_T( "" ))
#define DEFAULT_QUEUE_DIR				(_T( "" ))

#define DEFAULT_ROUTING_SOUCES			(_T( "" ))
#define DEFAULT_LOGFILE_DIRECTORY		(_T( "" ))

#define DEFAULT_AUTH_PACKAGES           (_T("NTLM"))
#define DEFAULT_CLEARTEXT_AUTH_PACKAGE  (_T(""))
#define DEFAULT_AUTHENTICATION          (MD_AUTH_ANONYMOUS | MD_AUTH_BASIC | MD_AUTH_NT)
#define DEFAULT_LOGON_DOMAIN            (_T(""))

#define DEFAULT_PORT					( 25  )
#define DEFAULT_SSLPORT					( 465 )
#define DEFAULT_OUTBOND_PORT			( 25  )
#define DEFAULT_REMOTE_SECURE_PORT		( 465  )

#define DEFAULT_HOP_COUNT				( 10  )

#define DEFAULT_ALWAYS_USE_SSL			( FALSE )
#define DEFAULT_LIMIT_REMOTE_CONNECTIONS ( TRUE )
#define DEFAULT_MAX_OUT_CONN_PER_DOMAIN	( 0 )

#define DEFAULT_MAX_IN_CONNECTION		( 1000 )
#define DEFAULT_MAX_OUT_CONNECTION		( 1000 )
#define DEFAULT_IN_CONNECTION_TIMEOUT	( 60 )
#define DEFAULT_OUT_CONNECTION_TIMEOUT	( 60 )

#define DEFAULT_BATCH_MSGS				( TRUE )
#define DEFAULT_BATCH_MSG_LIMIT			( 0 )

#define DEFAULT_MAX_MESSAGE_SIZE		( 2048 * 1024 )
#define DEFAULT_MAX_SESSION_SIZE		( 10240 * 1024 )
#define DEFAULT_MAX_MESSAGE_RECIPIENTS	( 100 )

#define DEFAULT_LOCAL_RETRIES			( 48 )
#define DEFAULT_LOCAL_RETRY_TIME		( 60 )
#define DEFAULT_REMOTE_RETRIES			( 48 )
#define DEFAULT_REMOTE_RETRY_TIME		( 60 )
#define DEFAULT_ETRN_DAYS				( 10 )


#define DEFAULT_ROUTING_DLL				( ( L"routeldp.dll" ) )

#define DEFAULT_ROUTING_SOURCES			( ( L"\0\0" ) )				// multisz

#define DEFAULT_LOCAL_DOMAINS			( ( L"corp.com\0\0" ) )		// multisz
#define DEFAULT_DOMAIN_ROUTING			( ( L"\0\0" ) )				// multisz

#define DEFAULT_ROUTE_ACTION            ( SMTP_SMARTHOST )
#define DEFAULT_ROUTE_USER_NAME         (_T("")) 
#define DEFAULT_ROUTE_PASSWORD          (_T("")) 

#define DEFAULT_LOGFILE_PERIOD			( 1 )
#define DEFAULT_LOGFILE_TRUNCATE_SIZE	( 1388000 )
#define DEFAULT_LOG_METHOD				( 0 )
#define DEFAULT_LOG_TYPE				( 1 )

#define DEFAULT_ENABLE_DNS_LOOKUP		( FALSE )
#define DEFAULT_SEND_DNR_TO_POSTMASTER	( FALSE )
#define DEFAULT_SEND_BAD_TO_POSTMASTER	( FALSE )

#define DEFAULT_AUTOSTART				( TRUE )

// Parameter ranges:
#define MIN_PORT						( 0 )
#define MIN_SSLPORT						( 0 )
#define MIN_OUTBOND_PORT				( 0 )

#define MIN_MAX_IN_CONNECTION			( 0 )
#define MIN_MAX_OUT_CONNECTION			( 0 )
#define MIN_IN_CONNECTION_TIMEOUT		( 0 )
#define MIN_OUT_CONNECTION_TIMEOUT		( 0 )

#define MIN_MAX_MESSAGE_SIZE			( 0 )
#define MIN_MAX_SESSION_SIZE			( 0 )
#define MIN_MAX_MESSAGE_RECIPIENTS		( 0 )

#define MIN_LOCAL_RETRIES				( 0 )
#define MIN_REMOTE_RETRIES				( 0 )

#define MIN_LOCAL_RETRY_TIME			( 0 )
#define MIN_REMOTE_RETRY_TIME			( 0 )
#define MIN_ETRN_DAYS					( 0 )

#define MIN_LOGFILE_PERIOD				( 0 )
#define MIN_LOGFILE_TRUNCATE_SIZE		( 0 )
#define MIN_LOG_METHOD					( 0 )
#define MIN_LOG_TYPE					( 0 )

#define MAX_PORT						( MAX_LONG )
#define MAX_SSLPORT						( MAX_LONG )
#define MAX_OUTBOND_PORT				( MAX_LONG )

#define MAX_MAX_IN_CONNECTION			( MAX_LONG )
#define MAX_MAX_OUT_CONNECTION			( MAX_LONG )
#define MAX_IN_CONNECTION_TIMEOUT		( MAX_LONG )
#define MAX_OUT_CONNECTION_TIMEOUT		( MAX_LONG )

#define MAX_MAX_MESSAGE_SIZE			( MAX_LONG )
#define MAX_MAX_SESSION_SIZE			( MAX_LONG )
#define MAX_MAX_MESSAGE_RECIPIENTS		( MAX_LONG )

#define MAX_LOCAL_RETRIES				( MAX_LONG )
#define MAX_REMOTE_RETRIES				( MAX_LONG )

#define MAX_LOCAL_RETRY_TIME			( MAX_LONG )
#define MAX_REMOTE_RETRY_TIME			( MAX_LONG )
#define MAX_ETRN_DAYS					( MAX_LONG )

#define MAX_LOGFILE_PERIOD				( MAX_LONG )
#define MAX_LOGFILE_TRUNCATE_SIZE		( MAX_LONG )
#define MAX_LOG_METHOD					( MAX_LONG )
#define MAX_LOG_TYPE					( MAX_LONG )


// string length
#define MAXLEN_SERVER					( 256 )

#define MAXLEN_SMART_HOST				( 256 )

#define MAXLEN_POSTMASTER_EMAIL			( 256 )
#define MAXLEN_POSTMASTER_NAME			( 256 )

#define MAXLEN_DEFAULT_DOMAIN			( 256 )

#define MAXLEN_BADMAIL_DIR				( 256 )
#define MAXLEN_PICKUP_DIR				( 256 )
#define MAXLEN_QUEUE_DIR				( 256 )

#define MAXLEN_ROUTING_SOUCES			( 256 )
#define MAXLEN_LOGFILE_DIRECTORY		( 256 )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#pragma warning( disable : 4511 )
#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <winsock2.h>

//  Pull in the common admin object code:
#include <admcmn.h>

#include "smtpinet.h"

#undef SMTP_MD_ROOT_PATH
#define SMTP_MD_ROOT_PATH           _T("/LM/SmtpSvc/")

#undef MD_SERVICE_NAME
#define MD_SERVICE_NAME      _T("SmtpSvc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\user.cpp ===
// user.cpp : Implementation of CSmtpadmApp and UserL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "user.h"
#include "oleutil.h"

#include <lmapibuf.h>

#include "smtpcmn.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.User.1")
#define THIS_FILE_IID               IID_ISmtpAdminUser

#define DEFAULT_NEWSGROUP_NAME          _T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION   _T("")
#define DEFAULT_NEWSGROUP_MODERATOR     _T("")
#define DEFAULT_NEWSGROUP_READONLY      FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminUser, CSmtpAdminUser, IID_ISmtpAdminUser)

STDMETHODIMP CSmtpAdminUser::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_ISmtpAdminUser,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

CSmtpAdminUser::CSmtpAdminUser ()
    // CComBSTR's are initialized to NULL by default.
{
    m_lInboxSizeInMemory    = 0;
    m_lInboxSizeInMsgNumber = 0;
    m_fAutoForward          = FALSE;
    m_fLocal                = TRUE;


    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("User") );
    m_iadsImpl.SetClass ( _T("IIsSmtpUser") );
}

CSmtpAdminUser::~CSmtpAdminUser ()
{
    // All CComBSTR's are freed automatically.
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminUser,m_iadsImpl)

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// user property

STDMETHODIMP CSmtpAdminUser::get_EmailId ( BSTR * pstrEmailId )
{
    return StdPropertyGet ( m_strEmailId, pstrEmailId );
}

STDMETHODIMP CSmtpAdminUser::put_EmailId ( BSTR strEmailId )
{
    return StdPropertyPut ( &m_strEmailId, strEmailId );
}

STDMETHODIMP CSmtpAdminUser::get_Domain ( BSTR * pstrDomain )
{
    return StdPropertyGet ( m_strDomain, pstrDomain );
}

STDMETHODIMP CSmtpAdminUser::put_Domain ( BSTR strDomain )
{
    return StdPropertyPut ( &m_strDomain, strDomain );
}


STDMETHODIMP CSmtpAdminUser::get_MailRoot ( BSTR * pstrMailRoot )
{
    return StdPropertyGet ( m_strMailRoot, pstrMailRoot );
}
STDMETHODIMP CSmtpAdminUser::put_MailRoot ( BSTR strMailRoot )
{
    return StdPropertyPut ( &m_strMailRoot, strMailRoot );
}


STDMETHODIMP CSmtpAdminUser::get_InboxSizeInMemory ( long * plInboxSizeInMemory )
{
    return StdPropertyGet ( m_lInboxSizeInMemory, plInboxSizeInMemory );
}
STDMETHODIMP CSmtpAdminUser::put_InboxSizeInMemory ( long   lInboxSizeInMemory )
{
    return StdPropertyPut ( &m_lInboxSizeInMemory, lInboxSizeInMemory );
}


STDMETHODIMP CSmtpAdminUser::get_InboxSizeInMsgNumber ( long * plInboxSizeInMsgNumber )
{
    return StdPropertyGet ( m_lInboxSizeInMsgNumber, plInboxSizeInMsgNumber );
}
STDMETHODIMP CSmtpAdminUser::put_InboxSizeInMsgNumber ( long   lInboxSizeInMsgNumber )
{
    return StdPropertyPut ( &m_lInboxSizeInMsgNumber, lInboxSizeInMsgNumber );
}


STDMETHODIMP CSmtpAdminUser::get_AutoForward ( BOOL * pfAutoForward )
{
    return StdPropertyGet ( m_fAutoForward, pfAutoForward );
}

STDMETHODIMP CSmtpAdminUser::put_AutoForward ( BOOL fAutoForward )
{
    return StdPropertyPut ( &m_fAutoForward, fAutoForward );
}


STDMETHODIMP CSmtpAdminUser::get_ForwardEmail ( BSTR * pstrForwardEmail )
{
    return StdPropertyGet ( m_strForwardEmail, pstrForwardEmail );
}

STDMETHODIMP CSmtpAdminUser::put_ForwardEmail ( BSTR strForwardEmail )
{
    return StdPropertyPut ( &m_strForwardEmail, strForwardEmail );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////


STDMETHODIMP CSmtpAdminUser::Default ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Default" );

/*
    m_strNewsgroup      = DEFAULT_NEWSGROUP_NAME;
    m_strDescription    = DEFAULT_NEWSGROUP_DESCRIPTION;
    m_strModerator      = DEFAULT_NEWSGROUP_MODERATOR;
    m_fReadOnly         = DEFAULT_NEWSGROUP_READONLY;

    if (
        !m_strNewsgroup ||
        !m_strDescription ||
        !m_strModerator
        ) {

        FatalTrace ( (LPARAM) this, "Out of memory" );
        return E_OUTOFMEMORY;
    }
*/
    TraceFunctLeave ();
    return NOERROR;
}

STDMETHODIMP CSmtpAdminUser::Create ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Create" );

    HRESULT         hr      = NOERROR;
    DWORD           dwErr   = NOERROR;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR           szUserName[512];
    WCHAR*          lpForward;
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );

    if( m_strForwardEmail && m_strForwardEmail[0] )
    {
        lpForward = m_strForwardEmail;
    }
    else
    {
        lpForward = NULL;
    }

    dwErr = SmtpCreateUser(
                m_iadsImpl.QueryComputer(),
                szUserName,
                lpForward,
                m_fLocal,
                m_lInboxSizeInMemory,
                m_lInboxSizeInMsgNumber,
                m_strMailRoot,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to add user: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminUser::Delete ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Delete" );

    HRESULT         hr      = NOERROR;
    DWORD           dwErr   = NOERROR;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR           szUserName[512];
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );

    dwErr = SmtpDeleteUser(
                m_iadsImpl.QueryComputer(),
                szUserName,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to delete user: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminUser::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Get" );

    HRESULT             hr      = NOERROR;
    DWORD               dwErr   = NOERROR;
    LPSMTP_USER_PROPS   pUserProps = NULL;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR           szUserName[512];
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );


    dwErr = SmtpGetUserProps(
                m_iadsImpl.QueryComputer(),
                szUserName,
                &pUserProps,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to get user prop: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

    // free old entry
    m_strMailRoot.Empty();
    m_strForwardEmail.Empty();

    m_strMailRoot = pUserProps->wszVRoot;

    m_strForwardEmail = pUserProps->wszForward;
    m_fAutoForward = (!m_strForwardEmail || !m_strForwardEmail.Length()) ? FALSE : TRUE;

    m_lInboxSizeInMemory = pUserProps->dwMailboxMax;
    m_lInboxSizeInMsgNumber = pUserProps->dwMailboxMessageMax;
    m_fLocal = !!pUserProps->dwLocal;

    // free pUserProps
    if ( pUserProps )
    {
        ::NetApiBufferFree ( pUserProps );
    }

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminUser::Set ( )
{
    TraceFunctEnter ( "CSmtpAdminUser::Set" );

    HRESULT             hr      = NOERROR;
    DWORD               dwErr   = NOERROR;
    SMTP_USER_PROPS     UserProps;

    if( !m_strEmailId || !m_strDomain )
    {
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    WCHAR               szUserName[512];
    wsprintfW( szUserName, L"%s@%s", (LPWSTR) m_strEmailId, (LPWSTR) m_strDomain );

    UserProps.fc            = FC_SMTP_USER_PROPS_ALL;

    if( !m_strForwardEmail || !m_strForwardEmail.Length() )
    {
        UserProps.wszForward    = NULL;
        UserProps.fc            -= FC_SMTP_USER_PROPS_FORWARD;
    }
    else
    {
        UserProps.wszForward    = (LPWSTR)m_strForwardEmail;
    }

    UserProps.wszVRoot      = (LPWSTR)m_strMailRoot;

    UserProps.dwMailboxMax          = m_lInboxSizeInMemory;
    UserProps.dwMailboxMessageMax   = m_lInboxSizeInMsgNumber;
    UserProps.dwLocal               = m_fLocal;


    dwErr = SmtpSetUserProps(
                m_iadsImpl.QueryComputer(),
                szUserName,
                &UserProps,
                m_iadsImpl.QueryInstance() );

    if ( dwErr != NOERROR ) {
        ErrorTrace ( (LPARAM) this, "Failed to set user prop: %x", dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\version.h ===
#include "exver.h"

#define makeString(x) #x

#define BUILD_NUM    atoi(makeString(rmm))

const int HIGH_VERSION = 1;
const int LOW_VERSION = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\vdir.cpp ===
// vdir.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include <listmacr.h>

#include "IADM.h"
#include "imd.h"
#include "inetcom.h"

#include "smtpadm.h"
#include "vdir.h"
#include "oleutil.h"
#include "metafact.h"
#include "metautil.h"

#include "smtpcmn.h"
#include "smtpprop.h"


// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.VirtualDirectory.1")
#define THIS_FILE_IID				IID_ISmtpAdminVirtualDirectory


typedef struct _VDIR_ENTRY {
	TCHAR            szName[METADATA_MAX_NAME_LEN+2];
	TCHAR            szDirectory[MAX_PATH + UNLEN + 3];

	TCHAR            szUser[UNLEN+1];
	TCHAR            szPassword[PWLEN+1];

	DWORD			dwAccess;
	DWORD			dwSslAccess;
	BOOL			fLogAccess;

	LIST_ENTRY		list;
} VDIR_ENTRY, * PVDIR_ENTRY;


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CSmtpAdminVirtualDirectory::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminVirtualDirectory,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminVirtualDirectory::CSmtpAdminVirtualDirectory () :
	m_dwServiceInstance		( 0 ),
	m_lCount				( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	m_dwAccess      = MD_ACCESS_READ | MD_ACCESS_WRITE;
    m_dwSslAccess   = 0;

	InitializeListHead( &m_list );
}

CSmtpAdminVirtualDirectory::~CSmtpAdminVirtualDirectory ()
{
	Clear();

	// All CComBSTR's are freed automatically.
}

void CSmtpAdminVirtualDirectory::Clear()
{
	m_lCount = 0;
	m_fEnumerateCalled = FALSE;
	m_strName.Empty();
	m_strDirectory.Empty();
	m_strUser.Empty();
	m_strPassword.Empty();
	m_dwAccess      = MD_ACCESS_READ | MD_ACCESS_WRITE;
    m_dwSslAccess   = 0;

	// release memory
	PLIST_ENTRY		pHead;
	PLIST_ENTRY		pEntry;
	PLIST_ENTRY		pTemp;
	PVDIR_ENTRY		pCurVDir=NULL;

	for( pHead=&m_list, pEntry=pHead->Flink; pEntry!=pHead; )
	{
		pTemp = pEntry;
		pEntry= pEntry->Flink;

		pCurVDir = CONTAINING_RECORD(pTemp, VDIR_ENTRY, list);
		RemoveEntryList( pTemp );
		delete pCurVDir;
	}

	_ASSERT( IsListEmpty(&m_list) );
}


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Which service to configure:
	
STDMETHODIMP CSmtpAdminVirtualDirectory::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_Server ( BSTR strServer )
{
	return StdPropertyPutServerName ( &m_strServer, strServer );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( (long *) &m_dwServiceInstance, lServiceInstance );
}


// enumeration
STDMETHODIMP CSmtpAdminVirtualDirectory::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_lCount, plCount );
}


// VirtualDirectory property

STDMETHODIMP CSmtpAdminVirtualDirectory::get_VirtualName ( BSTR * pstrName )
{
	return StdPropertyGet ( m_strName, pstrName );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_VirtualName ( BSTR strName )
{
	return StdPropertyPut ( &m_strName, strName );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_Directory ( BSTR * pstrPath )
{
	return StdPropertyGet ( m_strDirectory, pstrPath );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_Directory ( BSTR strPath )
{
	return StdPropertyPut ( &m_strDirectory, strPath );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_User ( BSTR * pstrUserName )
{
	return StdPropertyGet ( m_strUser, pstrUserName );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_User ( BSTR strUserName )
{
	return StdPropertyPut ( &m_strUser, strUserName );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_Password ( BSTR * pstrPassword )
{
	return StdPropertyGet ( m_strPassword, pstrPassword );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_Password ( BSTR strPassword )
{
	return StdPropertyPut ( &m_strPassword, strPassword );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::get_LogAccess( BOOL* pfLogAccess )
{
	return StdPropertyGet ( m_fLogAccess, pfLogAccess );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_LogAccess( BOOL fLogAccess )
{
	return StdPropertyPut ( &m_fLogAccess, fLogAccess );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::get_AccessPermission( long* plAccessPermission )
{
	return StdPropertyGet ( m_dwAccess, plAccessPermission );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_AccessPermission( long lAccessPermission )
{
	return StdPropertyPut ( &m_dwAccess, lAccessPermission );
}


STDMETHODIMP CSmtpAdminVirtualDirectory::get_SslAccessPermission( long* plSslAccessPermission )
{
    return StdPropertyGet ( m_dwSslAccess, plSslAccessPermission );
}

STDMETHODIMP CSmtpAdminVirtualDirectory::put_SslAccessPermission( long lSslAccessPermission )
{
    return StdPropertyPut ( &m_dwSslAccess, lSslAccessPermission );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////


// get /set property for current vdir
STDMETHODIMP CSmtpAdminVirtualDirectory::GetHomeDirectory( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::GetHomeDirectory" );
    m_strName.Empty();
    m_strName = _T("");
    return Get();
}

STDMETHODIMP CSmtpAdminVirtualDirectory::SetHomeDirectory( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::SetHomeDirectory" );
    m_strName.Empty();
    m_strName = _T("");
    return Set();
}


STDMETHODIMP CSmtpAdminVirtualDirectory::Create ( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Create" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	if( !m_strName || !m_strDirectory )
	{
		FatalTrace ( (LPARAM) this, "No virtual directory to create!" );
		hr = E_POINTER;
		return hr;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return SmtpCreateExceptionFromHresult(hr);
	}

	CMetabaseKey		hMB( pmetabase );

    GetMDRootPath( szPath, m_dwServiceInstance );
    hr = hMB.Open( szPath, METADATA_PERMISSION_WRITE );
    BAIL_ON_FAILURE(hr);

    hr = hMB.CreateChild(m_strName);
    BAIL_ON_FAILURE(hr);

	if( !SetVRootPropertyToMetabase( &hMB, m_strName, m_strDirectory, m_strUser, m_strPassword, m_dwAccess, m_dwSslAccess, m_fLogAccess) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		goto Exit;
	}

    hr = hMB.Save();
    BAIL_ON_FAILURE(hr);

Exit:
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromHresult(hr);
    }

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminVirtualDirectory::Delete ( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Delete" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	if ( !m_strName ) {
		FatalTrace ( (LPARAM) this, "Bad dir name to delete" );
		return E_POINTER;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

    GetMDRootPath( szPath, m_dwServiceInstance );

	CMetabaseKey		hMB( pmetabase );
    hr = hMB.Open( szPath, METADATA_PERMISSION_WRITE);
    BAIL_ON_FAILURE(hr);

    hr = hMB.DestroyChild(m_strName);
    BAIL_ON_FAILURE(hr);

    hr = hMB.Save();
    BAIL_ON_FAILURE(hr);

Exit:
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromHresult(hr);
    }

    TraceFunctLeave ();
    return hr;
}

// get /set property for current vdir
STDMETHODIMP CSmtpAdminVirtualDirectory::Get( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Get" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};
	TCHAR	szDirectory[MAX_PATH + UNLEN + 3] = {0};
	TCHAR	szUser[UNLEN+1] = {0};
	TCHAR	szPassword[PWLEN+1] = {0};

	// zero out
	m_strDirectory = (BSTR)NULL;
	m_strUser = (BSTR)NULL;
	m_strPassword = (BSTR)NULL;

	if( !m_strName )
	{
		FatalTrace ( (LPARAM) this, "No virtual directory to create!" );
		hr = E_POINTER;
		return hr;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey		hMB( pmetabase );

    GetMDVDirPath( szPath, m_dwServiceInstance, m_strName );
    hr = hMB.Open( szPath );
	if( FAILED(hr) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		goto Exit;
	}

	if( !GetVRootPropertyFromMetabase( &hMB, _T(""), szDirectory, szUser, szPassword, &m_dwAccess, &m_dwSslAccess, &m_fLogAccess) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		goto Exit;
	}

	m_strDirectory = szDirectory;
	m_strUser = szUser;
	m_strPassword = szPassword;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminVirtualDirectory::Set( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Set" );

	HRESULT	hr = NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	if( !m_strName || !m_strDirectory )
	{
		ErrorTrace ( (LPARAM) this, "No virtual directory to create!" );
		hr = E_POINTER;
		return hr;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey		hMB( pmetabase );

    GetMDVDirPath( szPath, m_dwServiceInstance, m_strName );
	hr = hMB.Open( szPath,METADATA_PERMISSION_WRITE );
    BAIL_ON_FAILURE(hr);

	if( !SetVRootPropertyToMetabase( &hMB, _T(""), m_strDirectory, m_strUser, m_strPassword, m_dwAccess, m_dwSslAccess, m_fLogAccess) )
	{
		hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
		return hr;
	}

    hr = hMB.Save();

Exit:
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromHresult(hr);
    }

	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminVirtualDirectory::Enumerate( )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::Enumerate" );

	HRESULT	hr	= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	TCHAR	szPath[METADATA_MAX_NAME_LEN+2] = {0};

	DWORD	dwAccess;
	DWORD	dwSslAccess;
	BOOL	fLogAccess;

	TCHAR	szName[METADATA_MAX_NAME_LEN+2];
	TCHAR	szDirectory[MAX_PATH + UNLEN + 3];

	TCHAR	szUser[UNLEN+1];
	TCHAR	szPassword[PWLEN+1];

	INT		i;

	PVDIR_ENTRY		pCurVDir=NULL;


	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		return hr;;
	}

    GetMDRootPath( szPath, m_dwServiceInstance );

	CMetabaseKey		hMB( pmetabase );
    hr = hMB.Open( szPath );
	if( FAILED(hr) )
	{
		hr = SmtpCreateExceptionFromHresult( hr );
		goto Exit;
	}


	Clear();	// reset state, m_lCount = 0

	i = 0;

	while( SUCCEEDED( hMB.EnumObjects(_T(""), szName, i ++) ) )
	{
		if ( !GetVRootPropertyFromMetabase( &hMB, szName, szDirectory, szUser, szPassword, &dwAccess, &dwSslAccess, &fLogAccess) )
		{
			continue;
		}

		pCurVDir = new VDIR_ENTRY;
		if( !pCurVDir )
		{
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		lstrcpy( pCurVDir->szName, szName);
		lstrcpy( pCurVDir->szDirectory, szDirectory);
		lstrcpy( pCurVDir->szUser, szUser);
		lstrcpy( pCurVDir->szPassword, szPassword);
		pCurVDir-> dwAccess = dwAccess;
		pCurVDir-> dwSslAccess = dwSslAccess;
		pCurVDir-> fLogAccess = fLogAccess;

		InsertHeadList( &m_list, &(pCurVDir->list) );
		m_lCount ++;
	}

	// _ASSERT( GetLastError() == ERROR_NO_MORE_ITEMS );

	m_fEnumerateCalled = TRUE;

Exit:
	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminVirtualDirectory::GetNth	( long lIndex )
{
	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::GetNth" );

	if( lIndex < 0 || lIndex >= m_lCount )
	{
		TraceFunctLeave ();
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	PLIST_ENTRY     pEntry;
	PVDIR_ENTRY		pVdir;
	INT				i;

	if( !m_fEnumerateCalled )
	{
		TraceFunctLeave ();
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	// zero out
	m_strName = (BSTR)NULL;
	m_strDirectory = (BSTR)NULL;
	m_strUser = (BSTR)NULL;
	m_strPassword = (BSTR)NULL;

	pEntry = &m_list;
	for( i=0; i<=lIndex; i++ )
	{
		pEntry=pEntry->Flink;
		_ASSERT( pEntry != & m_list);

		if( pEntry == & m_list )
		{
			TraceFunctLeave ();
			return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		}
	}

	pVdir = CONTAINING_RECORD(pEntry, VDIR_ENTRY, list);

	// automatically changed to UNICODE
	m_strName = pVdir->szName;
	m_strDirectory = pVdir->szDirectory;
	m_strUser = pVdir->szUser;
	m_strPassword = pVdir->szPassword;

	TraceFunctLeave ();
	return NOERROR;
}


BOOL CSmtpAdminVirtualDirectory::GetVRootPropertyFromMetabase( 
        CMetabaseKey*         hMB, 
        const TCHAR* szName, 
		TCHAR*       szDirectory, 
        TCHAR*       szUser, 
        TCHAR*       szPassword, 
        DWORD*      pdwAccess, 
        DWORD*      pdwSslAccess, 
        BOOL*       pfLogAccess
        )

{
    DWORD		cb;
    DWORD       dwDontLog = DEFAULT_LOG_TYPE;
    HRESULT     hr = NOERROR;

	TraceFunctEnter ( "CSmtpAdminVirtualDirectory::GetVRootPropertyFromMetabase" );

    cb = (MAX_PATH + UNLEN + 3) * sizeof(TCHAR);
    hr = hMB->GetString( szName, MD_VR_PATH, szDirectory,cb,0 );
    if( FAILED(hr) )
    {
        szDirectory[0] = _T('\0');
    }

    StdGetMetabaseProp( hMB, MD_ACCESS_PERM, MD_ACCESS_READ | MD_ACCESS_WRITE, 
        pdwAccess, szName );

    StdGetMetabaseProp( hMB, MD_SSL_ACCESS_PERM, 0, 
        pdwSslAccess, szName );

    StdGetMetabaseProp( hMB, MD_DONT_LOG, DEFAULT_LOG_TYPE, 
        &dwDontLog, szName );
    *pfLogAccess = !dwDontLog;

    cb = sizeof(TCHAR) * (UNLEN+1);
    hr = hMB->GetString(szName,MD_VR_USERNAME,szUser,cb);
    if( FAILED(hr) )
	{
		szUser[0] = _T('\0');
	}

	cb = sizeof(TCHAR) * (PWLEN+1);
	if ( (szUser[0] != _T('\0')) &&
		 (szDirectory[0] == _T('\\')) && 
		 (szDirectory[1] == _T('\\')) )
	{
		hr = hMB->GetString(szName,MD_VR_PASSWORD,szPassword,cb,METADATA_NO_ATTRIBUTES);
        if( FAILED(hr) )
		{
			DebugTrace( (LPARAM)this, "Error %d reading path from %s\n", GetLastError(), szName);
			szPassword[0] = _T('\0');
		}
	}

	return TRUE;
}

BOOL CSmtpAdminVirtualDirectory::SetVRootPropertyToMetabase( 
        CMetabaseKey*             hMB, 
        const TCHAR*     szName, 
		const TCHAR*     szDirectory, 
        const TCHAR*     szUser, 
        const TCHAR*     szPassword, 
        DWORD           dwAccess, 
        DWORD           dwSslAccess, 
        BOOL            fLogAccess
        )
{
    DWORD		dwDontLog = fLogAccess ? 0 : 1;
    HRESULT     hr = NOERROR;

	hr = hMB->SetString( szName,MD_VR_PATH, szDirectory );
    BAIL_ON_FAILURE(hr);

    hr = hMB->SetDword( szName,	MD_DONT_LOG, dwDontLog);
    BAIL_ON_FAILURE(hr);

    hr = hMB->SetDword( szName, MD_ACCESS_PERM, dwAccess );
    BAIL_ON_FAILURE(hr);

    hr = hMB->SetDword( szName, MD_SSL_ACCESS_PERM, dwSslAccess);
    BAIL_ON_FAILURE(hr);

    if( szUser[0] )
    {
        hr = hMB->SetString( szName, MD_VR_USERNAME, szUser);
    }

	if( szPassword[0] )
    {
        hr = hMB->SetString( szName, MD_VR_PASSWORD, szPassword, METADATA_INHERIT | METADATA_SECURE );
    }

Exit:
    if( FAILED(hr) )
    {
        SetLastError(hr);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\virsvr.h ===
// virsvr.h : Declaration of the CSmtpAdminVirtualServer


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "metafact.h"
#include "cmultisz.h"
#include "binding.h"
#include "rtsrc.h"

class CTcpAccess;


// Administrator ACL:
HRESULT		AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins );
HRESULT		AdministratorsToAcl ( LPCTSTR strServer, SAFEARRAY * psaAdmins, PSECURITY_DESCRIPTOR* ppSD, DWORD * pcbSD );


static HRESULT SidToString ( PSID pSID, BSTR * pStr );
static HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID );


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminVirtualServer : 
	public CComDualImpl<ISmtpAdminVirtualServer, &IID_ISmtpAdminVirtualServer, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminVirtualServer,&CLSID_CSmtpAdminVirtualServer>
{
public:
	CSmtpAdminVirtualServer();
	virtual ~CSmtpAdminVirtualServer ();
	
BEGIN_COM_MAP(CSmtpAdminVirtualServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdminVirtualServer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminVirtualServer) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminVirtualServer, _T("Smtpadm.VirtualServer.1"), _T("Smtpadm.VirtualServer"), IDS_SMTPADMIN_VIRTUALSERVER_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdminVirtualServer
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// other interfaces supported by virtual server
	STDMETHODIMP	get_TcpAccess ( ITcpAccess ** ppTcpAccess );

	STDMETHODIMP	get_Comment		( BSTR * pstrComment );
	STDMETHODIMP	put_Comment		( BSTR strComment );

    STDMETHODIMP    get_Bindings         ( IServerBindings ** ppBindings );
    STDMETHODIMP    get_BindingsDispatch ( IDispatch ** ppDispatch );

    STDMETHODIMP    get_RoutingSource   ( IRoutingSource ** ppRoutingSource );
    STDMETHODIMP    get_RoutingSourceDispatch ( IDispatch ** ppRoutingSource );

	// Overridable server properties:

	STDMETHODIMP	get_ServerBindings	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindings	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_ServerBindingsVariant	( SAFEARRAY ** ppsastrServerBindings );
	STDMETHODIMP	put_ServerBindingsVariant	( SAFEARRAY * pstrServerBindings );

	STDMETHODIMP	get_SecureBindings	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindings	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_SecureBindingsVariant	( SAFEARRAY ** ppsastrSecureBindings );
	STDMETHODIMP	put_SecureBindingsVariant	( SAFEARRAY * pstrSecureBindings );

	STDMETHODIMP	get_Port			( long * lPort );
	STDMETHODIMP	put_Port			( long lPort );

	STDMETHODIMP	get_SSLPort			( long * lSSLPort );
	STDMETHODIMP	put_SSLPort			( long lSSLPort );

	STDMETHODIMP	get_OutboundPort	( long * lOutboundPort );
	STDMETHODIMP	put_OutboundPort	( long lOutboundPort );

	STDMETHODIMP	get_HopCount		( long * lHopCount );
	STDMETHODIMP	put_HopCount		( long lHopCount );

	STDMETHODIMP	get_SmartHost		( BSTR * pstrSmartHost );
	STDMETHODIMP	put_SmartHost		( BSTR   pstrSmartHost );

	STDMETHODIMP	get_EnableDNSLookup	( BOOL * pfEnableDNSLookup );
	STDMETHODIMP	put_EnableDNSLookup	( BOOL fEnableDNSLookup );

	STDMETHODIMP	get_PostmasterEmail	( BSTR * pstrPostmasterEmail );
	STDMETHODIMP	put_PostmasterEmail	( BSTR strPostmasterEmail );

	STDMETHODIMP	get_PostmasterName	( BSTR * pstrPostmasterName );
	STDMETHODIMP	put_PostmasterName	( BSTR strPostmasterName );

	STDMETHODIMP	get_DefaultDomain	( BSTR * pstrDefaultDomainName );
	STDMETHODIMP	put_DefaultDomain	( BSTR strDefaultDomainName );

	STDMETHODIMP	get_FQDN			( BSTR * pstrFQDN );
	STDMETHODIMP	put_FQDN			( BSTR strFQDN );

	STDMETHODIMP	get_DropDir			( BSTR * pstrDropDir );
	STDMETHODIMP	put_DropDir			( BSTR strDropDir );

	STDMETHODIMP	get_BadMailDir		( BSTR * pstrBadMailDir );
	STDMETHODIMP	put_BadMailDir		( BSTR strBadMailDir );

	STDMETHODIMP	get_PickupDir		( BSTR * pstrPickupDir );
	STDMETHODIMP	put_PickupDir		( BSTR strPickupDir );

	STDMETHODIMP	get_QueueDir		( BSTR * pstrQueueDir );
	STDMETHODIMP	put_QueueDir		( BSTR strQueueDir );

	STDMETHODIMP	get_MaxInConnection	( long * lMaxInConnection );
	STDMETHODIMP	put_MaxInConnection	( long lMaxInConnection );

	STDMETHODIMP	get_MaxOutConnection( long * lMaxOutConnection );
	STDMETHODIMP	put_MaxOutConnection( long lMaxOutConnection );

	STDMETHODIMP	get_InConnectionTimeout	( long * lInConnectionTimeout );
	STDMETHODIMP	put_InConnectionTimeout	( long lInConnectionTimeout );

	STDMETHODIMP	get_OutConnectionTimeout( long * lOutConnectionTimeout );
	STDMETHODIMP	put_OutConnectionTimeout( long lOutConnectionTimeout );

	STDMETHODIMP	get_MaxMessageSize	( long * lMaxMessageSize );
	STDMETHODIMP	put_MaxMessageSize	( long lMaxMessageSize );

	STDMETHODIMP	get_MaxSessionSize	( long * lMaxSessionSize );
	STDMETHODIMP	put_MaxSessionSize	( long lMaxSessionSize );

	STDMETHODIMP	get_MaxMessageRecipients	( long * lMaxMessageRecipients );
	STDMETHODIMP	put_MaxMessageRecipients	( long lMaxMessageRecipients );

	STDMETHODIMP	get_LocalRetries	( long * lLocalRetries );
	STDMETHODIMP	put_LocalRetries	( long lLocalRetries );

	STDMETHODIMP	get_LocalRetryTime	( long * lLocalRetryTime );
	STDMETHODIMP	put_LocalRetryTime	( long lLocalRetryTime );

	STDMETHODIMP	get_RemoteRetries	( long * lRemoteRetries );
	STDMETHODIMP	put_RemoteRetries	( long lRemoteRetries );

	STDMETHODIMP	get_RemoteRetryTime	( long * lRemoteRetryTime );
	STDMETHODIMP	put_RemoteRetryTime	( long lRemoteRetryTime );

	STDMETHODIMP	get_ETRNDays		( long * lETRNDays );
	STDMETHODIMP	put_ETRNDays		( long lETRNDays );

	STDMETHODIMP	get_SendDNRToPostmaster	( BOOL * pfSendDNRToPostmaster );
	STDMETHODIMP	put_SendDNRToPostmaster	( BOOL fSendDNRToPostmaster );

	STDMETHODIMP	get_SendBadmailToPostmaster		( BOOL * pfSendBadmailToPostmaster);
	STDMETHODIMP	put_SendBadmailToPostmaster		( BOOL fSendBadmailToPostmaster );

	STDMETHODIMP	get_RoutingDLL			( BSTR * pstrRoutingDLL );
	STDMETHODIMP	put_RoutingDLL			( BSTR strRoutingDLL );


	STDMETHODIMP	get_RoutingSources	( SAFEARRAY ** ppsastrRoutingSources );
	STDMETHODIMP	put_RoutingSources	( SAFEARRAY * pstrRoutingSources );

	STDMETHODIMP	get_RoutingSourcesVariant	( SAFEARRAY ** ppsavarRoutingSources );
	STDMETHODIMP	put_RoutingSourcesVariant	( SAFEARRAY * psavarRoutingSources );

	STDMETHODIMP	get_LocalDomains	( SAFEARRAY ** ppsastrLocalDomains );
	STDMETHODIMP	put_LocalDomains	( SAFEARRAY * pstrLocalDomains );
	
	STDMETHODIMP	get_DomainRouting	( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRouting	( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_DomainRoutingVariant	( SAFEARRAY ** ppsastrDomainRouting );
	STDMETHODIMP	put_DomainRoutingVariant	( SAFEARRAY * pstrDomainRouting );

	STDMETHODIMP	get_MasqueradeDomain	( BSTR * pstrMasqueradeDomain );
	STDMETHODIMP	put_MasqueradeDomain	( BSTR strMasqueradeDomain );

	STDMETHODIMP	get_SendNdrTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendNdrTo			( BSTR strAddr );

	STDMETHODIMP	get_SendBadTo			( BSTR * pstrAddr );
	STDMETHODIMP	put_SendBadTo			( BSTR strAddr );
	
	STDMETHODIMP	get_RemoteSecurePort	( long * plRemoteSecurePort );
	STDMETHODIMP	put_RemoteSecurePort	( long lRemoteSecurePort );

	STDMETHODIMP	get_ShouldDeliver		( BOOL * pfShouldDeliver );
	STDMETHODIMP	put_ShouldDeliver		( BOOL fShouldDeliver );

	STDMETHODIMP	get_AlwaysUseSsl			( BOOL * pfAlwaysUseSsl );
	STDMETHODIMP	put_AlwaysUseSsl			( BOOL fAlwaysUseSsl );

	STDMETHODIMP	get_LimitRemoteConnections	( BOOL * pfLimitRemoteConnections );
	STDMETHODIMP	put_LimitRemoteConnections	( BOOL fLimitRemoteConnections );

	STDMETHODIMP	get_MaxOutConnPerDomain		( long * plMaxOutConnPerDomain );
	STDMETHODIMP	put_MaxOutConnPerDomain		( long lMaxOutConnPerDomain );

	STDMETHODIMP	get_AllowVerify				( BOOL * pfAllowVerify );
	STDMETHODIMP	put_AllowVerify				( BOOL fAllowVerify	);

	STDMETHODIMP	get_AllowExpand				( BOOL * pfAllowExpand );
	STDMETHODIMP	put_AllowExpand				( BOOL fAllowExpand );

	STDMETHODIMP	get_SmartHostType			( long * plSmartHostType );
	STDMETHODIMP	put_SmartHostType			( long lSmartHostType );

	STDMETHODIMP	get_BatchMessages			( BOOL * pfBatchMessages );
	STDMETHODIMP	put_BatchMessages			( BOOL fBatchMessages );

	STDMETHODIMP	get_BatchMessageLimit		( long * plBatchMessageLimit );
	STDMETHODIMP	put_BatchMessageLimit		( long lBatchMessageLimit );

	STDMETHODIMP	get_DoMasquerade			( BOOL * pfDoMasquerade );
	STDMETHODIMP	put_DoMasquerade			( BOOL fDoMasquerade );

	STDMETHODIMP	get_Administrators			( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_Administrators			( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_AdministratorsVariant	( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_AdministratorsVariant	( SAFEARRAY * psastrAdmins );

    STDMETHODIMP	get_AuthenticationPackages	( BSTR * pstrAuthenticationPackages );
    STDMETHODIMP	put_AuthenticationPackages	( BSTR strAuthenticationPackages );

    STDMETHODIMP	get_ClearTextAuthPackage	( BSTR * pstrClearTextAuthPackage );
    STDMETHODIMP	put_ClearTextAuthPackage	( BSTR strClearTextAuthPackage );

    STDMETHODIMP    get_AuthenticationMethod    (long *plAuthMethod);
    STDMETHODIMP    put_AuthenticationMethod    (long lAuthMethod);

    STDMETHODIMP    get_DefaultLogonDomain      (BSTR *pstrLogonDomain);
    STDMETHODIMP    put_DefaultLogonDomain      (BSTR strLogonDomain);

    STDMETHODIMP    get_RouteAction             (long *plRouteAction);
    STDMETHODIMP    put_RouteAction             (long lRouteAction);

    STDMETHODIMP    get_RouteUserName           (BSTR *pstrRouteUserName);
    STDMETHODIMP    put_RouteUserName           (BSTR strRouteUserName);

    STDMETHODIMP    get_RoutePassword           (BSTR *pstrRoutePassword);
    STDMETHODIMP    put_RoutePassword           (BSTR strRoutePassword);

	STDMETHODIMP	get_LogFileDirectory		( BSTR * pstrLogFileDirectory );
	STDMETHODIMP	put_LogFileDirectory		( BSTR strLogFileDirectory );

	STDMETHODIMP	get_LogFilePeriod			( long * lLogFilePeriod );
	STDMETHODIMP	put_LogFilePeriod			( long lLogFilePeriod );

	STDMETHODIMP	get_LogFileTruncateSize		( long * lLogFileTruncateSize );
	STDMETHODIMP	put_LogFileTruncateSize		( long lLogFileTruncateSize );

	STDMETHODIMP	get_LogMethod				( long * lLogMethod );
	STDMETHODIMP	put_LogMethod				( long lLogMethod );

	STDMETHODIMP	get_LogType					( long * lLogType );
	STDMETHODIMP	put_LogType					( long lLogType );

/*
	STDMETHODIMP	get_DisplayName	( BSTR * pstrDisplayName );
	STDMETHODIMP	put_DisplayName	( BSTR strDisplayName );
*/
	//
	//	Service State Properties:
	//
	STDMETHODIMP	get_AutoStart	( BOOL * pfAutoStart );
	STDMETHODIMP	put_AutoStart	( BOOL fAutoStart );

    STDMETHODIMP	get_ServerState	( DWORD * pdwServerState );
    STDMETHODIMP    get_Win32ErrorCode      ( long * plWin32ErrorCode );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Get ( );
	STDMETHODIMP	Set ( BOOL fFailIfChanged );
	STDMETHODIMP	BackupRoutingTable( BSTR strPath );

	STDMETHODIMP	Start		( );
	STDMETHODIMP	Pause		( );
	STDMETHODIMP	Continue	( );
	STDMETHODIMP	Stop		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Properties:
	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	long		m_lPort;
	CMultiSz    m_mszServerBindings;		// MultiString
	CMultiSz    m_mszSecureBindings;		// MultiString

	long		m_lSSLPort;
	long		m_lOutboundPort;
	long		m_lRemoteSecurePort;

	CComBSTR	m_strSmartHost;
	BOOL		m_fEnableDNSLookup;
	CComBSTR	m_strPostmasterEmail;
	CComBSTR	m_strPostmasterName;

	CComBSTR	m_strFQDN;
	CComBSTR	m_strDefaultDomain;
	CComBSTR	m_strDropDir;

	CComBSTR	m_strBadMailDir;
	CComBSTR	m_strPickupDir;
	CComBSTR	m_strQueueDir;

	long		m_lHopCount;
	long		m_lMaxInConnection;
	long		m_lMaxOutConnection;
	long		m_lInConnectionTimeout;
	long		m_lOutConnectionTimeout;

	long		m_lMaxMessageSize;
	long		m_lMaxSessionSize;
	long		m_lMaxMessageRecipients;

	long		m_lLocalRetries;
	long		m_lLocalRetryTime;
	long		m_lRemoteRetries;
	long		m_lRemoteRetryTime;

	long		m_lETRNDays;

	BOOL		m_fSendDNRToPostmaster;
	BOOL		m_fSendBadmailToPostmaster;

	CComBSTR	m_strRoutingDLL;
	CMultiSz	m_mszRoutingSources;	// MultiString

	CMultiSz    m_mszLocalDomains;		// MultiString
	CMultiSz    m_mszDomainRouting;		// MultiString

	BOOL		m_fDoMasquerade;
	CComBSTR	m_strMasqueradeDomain;

	CComBSTR	m_strNdrAddr;
	CComBSTR	m_strBadAddr;

	BOOL		m_fShouldDeliver;
	BOOL		m_fAlwaysUseSsl;
	BOOL		m_fLimitRemoteConnections;
	long		m_lMaxOutConnPerDomain;

	BOOL		m_fAllowVerify;
	BOOL		m_fAllowExpand;
	long		m_lSmartHostType;

	BOOL		m_fBtachMsgs;
	long		m_lBatchMsgLimit;

	SAFEARRAY *	m_psaAdmins;

    long        m_lAuthMethod;
    CComBSTR    m_strAuthPackages;
    CComBSTR    m_strClearTextAuthPackage;
    CComBSTR    m_strDefaultLogonDomain;

    // outbound security
    long        m_lRouteAction;
    CComBSTR    m_strRouteUserName;
    CComBSTR    m_strRoutePassword;

	CComBSTR	m_strLogFileDirectory;
	long		m_lLogFilePeriod;
	long		m_lLogFileTruncateSize;
	long		m_lLogMethod;
	long		m_lLogType;

	BOOL		m_fAutoStart;

	//service specific
	CComBSTR	m_strComment;

	// Service State:
    DWORD       m_dwServerState;
    DWORD       m_dwWin32ErrorCode;

	// Unused so far:
	CComBSTR	m_strDisplayName;

	// Tcp restrictions:
	CComPtr<ITcpAccess>		m_pIpAccess;
	CTcpAccess *			m_pPrivateIpAccess;

    // Bindings:
    CComPtr<IServerBindings>    m_pBindings;
    CServerBindings *           m_pPrivateBindings;

    CComObject<CRoutingSource>  m_RoutingSource;

	// Status:
	BOOL		m_fGotProperties;
	DWORD		m_bvChangedFields;
	FILETIME	m_ftLastChanged;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT 	GetPropertiesFromMetabase	( IMSAdminBase * pMetabase );
	HRESULT 	SendPropertiesToMetabase	( BOOL fFailIfChanged, IMSAdminBase * pMetabase );

	// State:
	HRESULT		ControlService 				( 
					IMSAdminBase *	pMetabase, 
					DWORD			ControlCode,
					DWORD			dwDesiredState,
					DWORD			dwPendingState
					);
	HRESULT		WriteStateCommand	( IMSAdminBase * pMetabase, DWORD dwCommand );
	HRESULT		CheckServiceState	( IMSAdminBase * pMetabase, DWORD * pdwState );
	//NNTP_SERVER_STATE	TranslateServerState	( DWORD dwState );

	// Validation:
	BOOL		ValidateStrings ( ) const;
	BOOL		ValidateProperties ( ) const;
	void		CorrectProperties ( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\user.h ===
// user.h : Declaration of the CSmtpAdminUser


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminUser : 
	public ISmtpAdminUser,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminUser,&CLSID_CSmtpAdminUser>
{
public:
	CSmtpAdminUser();
	virtual ~CSmtpAdminUser();
BEGIN_COM_MAP(CSmtpAdminUser)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminUser)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminUser) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminUser, _T("Smtpadm.User.1"), _T("Smtpadm.User"), IDS_SMTPADMIN_USER_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminUser
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminUser
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// User Properties:

	STDMETHODIMP	get_EmailId	( BSTR * pstrEmailId );
	STDMETHODIMP	put_EmailId	( BSTR strEmailId );

	STDMETHODIMP	get_Domain	( BSTR * pstrDomain );
	STDMETHODIMP	put_Domain	( BSTR strDomain );

	STDMETHODIMP	get_MailRoot	( BSTR * pstrMailRoot );
	STDMETHODIMP	put_MailRoot	( BSTR strMailRoot );

	STDMETHODIMP	get_InboxSizeInMemory	( long * plInboxSizeInMemory );
	STDMETHODIMP	put_InboxSizeInMemory	( long   lInboxSizeInMemory );

	STDMETHODIMP	get_InboxSizeInMsgNumber( long * plInboxSizeInMsgNumber );
	STDMETHODIMP	put_InboxSizeInMsgNumber( long   lInboxSizeInMsgNumber );

	STDMETHODIMP	get_AutoForward	( BOOL * pfAutoForward );
	STDMETHODIMP	put_AutoForward ( BOOL fAutoForward );

	STDMETHODIMP	get_ForwardEmail	( BSTR * pstrForwardEmail );
	STDMETHODIMP	put_ForwardEmail	( BSTR strForwardEmail );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////
	STDMETHODIMP	Default	( );

	STDMETHODIMP	Create	( );
	STDMETHODIMP	Delete	( );

	STDMETHODIMP	Get		( );
	STDMETHODIMP	Set		( );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	BOOL		m_fLocal;
	CComBSTR	m_strEmailId;
	CComBSTR	m_strDomain;

	CComBSTR	m_strMailRoot;

	long		m_lInboxSizeInMemory;
	long		m_lInboxSizeInMsgNumber;

	BOOL		m_fAutoForward;
	CComBSTR	m_strForwardEmail;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\vdir.h ===
// vdir.h : Declaration of the CSmtpAdminVirtualDirectory

#ifndef _VDIR_H_
#define _VDIR_H_

#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"
#include "metafact.h"

class CMetabaseKey;

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminVirtualDirectory : 
	public CComDualImpl<ISmtpAdminVirtualDirectory, &IID_ISmtpAdminVirtualDirectory, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminVirtualDirectory,&CLSID_CSmtpAdminVirtualDirectory>
{
public:
	CSmtpAdminVirtualDirectory();
	virtual ~CSmtpAdminVirtualDirectory();
BEGIN_COM_MAP(CSmtpAdminVirtualDirectory)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdminVirtualDirectory)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminVirtualDirectory) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminVirtualDirectory, _T("Smtpadm.VirtualDirectory.1"), _T("Smtpadm.VirtualDirectory"), IDS_SMTPADMIN_VIRTUALDIRECTORY_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdminVirtualDirectory
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:

	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );


	// Enumeration properties:
	STDMETHODIMP	get_Count	( long * plCount );


	// The current virtual directory's properties:

	STDMETHODIMP	get_VirtualName		( BSTR * pstrName );
	STDMETHODIMP	put_VirtualName		( BSTR strName );


	STDMETHODIMP	get_Directory		( BSTR * pstrPath );
	STDMETHODIMP	put_Directory		( BSTR strPath );


	STDMETHODIMP	get_User			( BSTR * pstrUserName );
	STDMETHODIMP	put_User			( BSTR strUserName );


	STDMETHODIMP	get_Password		( BSTR * pstrPassword );
	STDMETHODIMP	put_Password		( BSTR strPassword );

	STDMETHODIMP	get_LogAccess		( BOOL* pfLogAccess );
	STDMETHODIMP	put_LogAccess		( BOOL fLogAccess );

	STDMETHODIMP	get_AccessPermission( long* plAccessPermission );
	STDMETHODIMP	put_AccessPermission( long lAccessPermission );

	STDMETHODIMP	get_SslAccessPermission( long* plSslAccessPermission );
	STDMETHODIMP	put_SslAccessPermission( long lSslAccessPermission );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	// home directory "/"
	STDMETHODIMP GetHomeDirectory ( );
	STDMETHODIMP SetHomeDirectory ( );

	// create / delete entry
	STDMETHODIMP	Create			( );
	STDMETHODIMP	Delete			( );

	// get /set property for current vdir
	STDMETHODIMP	Get				( );
	STDMETHODIMP	Set				( );

	// enumeration
	STDMETHODIMP	Enumerate		( );
	STDMETHODIMP	GetNth			( long lIndex );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	long		m_lCount;

	CComBSTR	m_strName;
	CComBSTR	m_strDirectory;
	CComBSTR	m_strUser;
	CComBSTR	m_strPassword;
	BOOL		m_fLogAccess;

    DWORD		m_dwAccess;
    DWORD		m_dwSslAccess;


	BOOL		m_fEnumerateCalled;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	// Todo: add a list
	//PVDIR_ENTRY		m_pVdir[];

	LIST_ENTRY		m_list;


	// private methods
	void Clear();	// reset the state

	BOOL		GetVRootPropertyFromMetabase( CMetabaseKey* hMB, const TCHAR* szName, 
		TCHAR* szDirectory, TCHAR* szUser, TCHAR* szPassword, DWORD* pdwAccess,
        DWORD* pdwSslAccess, BOOL* pfLogAccess);

	BOOL		SetVRootPropertyToMetabase( CMetabaseKey* hMB, const TCHAR* szName, 
		const TCHAR* szDirectory, const TCHAR* szUser, const TCHAR* szPassword, 
		DWORD dwAccess, DWORD dwSslAccess, BOOL fLogAccess);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\virsvr.cpp ===
// service.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include <lmcons.h>
#include "IADM.h"
#include "imd.h"
#include "mdmsg.h"
#include "iisinfo.h"
#include "iiscnfgp.h"

#include "smtpprop.h"
#include "smtpadm.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "smtpcmn.h"
#include "smtpapi.h"

#include "virsvr.h"


// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.VirtualServer.1")
#define THIS_FILE_IID               IID_ISmtpAdminVirtualServer


/////////////////////////////////////////////////////////////////////////////
//

CSmtpAdminVirtualServer::CSmtpAdminVirtualServer () :
    m_lPort         (25 ),
    m_lLogMethod    ( 0 ),
    m_dwServerState ( MD_SERVER_STATE_STOPPED ),
    m_pPrivateIpAccess          ( NULL ),
    m_dwWin32ErrorCode          ( NOERROR ),
    m_pPrivateBindings          ( NULL ),
    m_lRouteAction              ( 0 )
    // CComBSTR's are initialized to NULL by default.
{
    m_psaAdmins = NULL;
    InitAsyncTrace ( );

    // Create the Ip Access collection:
    CComObject<CTcpAccess> *    pIpAccess;

    CComObject<CTcpAccess>::CreateInstance ( &pIpAccess );
    pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) &m_pIpAccess );
    m_pPrivateIpAccess = pIpAccess;
}

CSmtpAdminVirtualServer::~CSmtpAdminVirtualServer ()
{
    // All CComBSTR's are freed automatically.
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    TermAsyncTrace ( );
}

STDMETHODIMP CSmtpAdminVirtualServer::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ISmtpAdminVirtualServer,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

// Which service to configure:
    
STDMETHODIMP CSmtpAdminVirtualServer::get_Server ( BSTR * pstrServer )
{
    return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Server ( BSTR strServer )
{
    VALIDATE_STRING ( strServer, MAXLEN_SERVER );

    // If the server name changes, that means the client will have to
    // call Get again:

    // I assume this here:
    _ASSERT ( sizeof (DWORD) == sizeof (int) );

    return StdPropertyPutServerName ( &m_strServer, strServer, (DWORD *) &m_fGotProperties, 1);
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ServiceInstance ( long * plServiceInstance )
{
    return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ServiceInstance ( long lServiceInstance )
{
    // If the service instance changes, that means the client will have to
    // call Get again:

    // I assume this here:
    _ASSERT ( sizeof (DWORD) == sizeof (int) );
    
    return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance, (DWORD *) &m_fGotProperties, 1 );
}


STDMETHODIMP CSmtpAdminVirtualServer::get_TcpAccess ( ITcpAccess ** ppTcpAccess )
{
    return m_pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) ppTcpAccess );
}


STDMETHODIMP CSmtpAdminVirtualServer::get_Bindings ( IServerBindings ** ppBindings )
{
    TraceQuietEnter ( "CSmtpAdminVirtualServer::get_Bindings" );

    HRESULT     hr = NOERROR;

    if ( !m_pBindings ) {
        ErrorTrace ( 0, "Didn't call get first" );
        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
        goto Exit;
    }
    else {
        hr = m_pBindings->QueryInterface ( IID_IServerBindings, (void **) ppBindings );
        _ASSERT ( SUCCEEDED(hr) );
    }

Exit:
    if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
        hr = SmtpCreateExceptionFromHresult ( hr );
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_BindingsDispatch ( IDispatch ** ppBindings )
{
    HRESULT                         hr  = NOERROR;
    CComPtr<IServerBindings>    pBindings;

    hr = get_Bindings ( &pBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = pBindings->QueryInterface ( IID_IDispatch, (void **) ppBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

Exit:
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSource ( IRoutingSource ** ppRoutingSource )
{
    TraceQuietEnter ( "CSmtpAdminVirtualServer::get_RoutingSource" );

    HRESULT     hr = NOERROR;

    hr = m_RoutingSource.QueryInterface ( IID_IRoutingSource, (void **) ppRoutingSource );
    BAIL_ON_FAILURE(hr);

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSourceDispatch ( IDispatch ** ppRoutingSource )
{
    TraceQuietEnter ( "CSmtpAdminVirtualServer::get_RoutingSourceDispatch" );

    HRESULT                 hr = NOERROR;

    hr = m_RoutingSource.QueryInterface ( IID_IDispatch, (void **) ppRoutingSource );
    BAIL_ON_FAILURE(hr);

Exit:
    TraceFunctLeave ();
    return hr;
}



// Server overridable Properties:

STDMETHODIMP CSmtpAdminVirtualServer::get_ServerBindings( SAFEARRAY ** ppsastrServerBindings )
{
    return StdPropertyGet ( &m_mszServerBindings, ppsastrServerBindings );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ServerBindings( SAFEARRAY * pstrServerBindings )
{
    return StdPropertyPut ( &m_mszServerBindings, pstrServerBindings, &m_bvChangedFields, BitMask(ID_SERVER_BINDINGS));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_ServerBindingsVariant( SAFEARRAY ** ppsavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = get_ServerBindings ( &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrServerBindings, ppsavarServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ServerBindingsVariant( SAFEARRAY * psavarServerBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarServerBindings, &psastrServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_ServerBindings ( psastrServerBindings );

Exit:
    if ( psastrServerBindings ) {
        SafeArrayDestroy ( psastrServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SecureBindings( SAFEARRAY ** ppsastrSecureBindings )
{
    return StdPropertyGet ( &m_mszSecureBindings, ppsastrSecureBindings );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SecureBindings( SAFEARRAY * pstrSecureBindings )
{
    return StdPropertyPut ( &m_mszSecureBindings, pstrSecureBindings, &m_bvChangedFields, BitMask(ID_SECURE_BINDINGS));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_SecureBindingsVariant( SAFEARRAY ** ppsavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = get_SecureBindings ( &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrSecureServerBindings, ppsavarSecureBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SecureBindingsVariant( SAFEARRAY * psavarSecureBindings )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrSecureServerBindings        = NULL;

    hr = VariantArrayToStringArray ( psavarSecureBindings, &psastrSecureServerBindings );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_SecureBindings ( psastrSecureServerBindings );

Exit:
    if ( psastrSecureServerBindings ) {
        SafeArrayDestroy ( psastrSecureServerBindings );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_Port( long * plPort )
{
    return StdPropertyGet ( m_lPort, plPort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Port( long lPort )
{
    return StdPropertyPut ( &m_lPort, lPort, &m_bvChangedFields, BitMask(ID_PORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SSLPort( long * plSSLPort )
{
    return StdPropertyGet ( m_lSSLPort, plSSLPort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SSLPort( long lSSLPort )
{
    return StdPropertyPut ( &m_lSSLPort, lSSLPort, &m_bvChangedFields, BitMask(ID_SSLPORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_OutboundPort( long * plOutboundPort )
{
    return StdPropertyGet ( m_lOutboundPort, plOutboundPort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_OutboundPort( long lOutboundPort )
{
    return StdPropertyPut ( &m_lOutboundPort, lOutboundPort, &m_bvChangedFields, BitMask(ID_OUTBOUNDPORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_HopCount( long * plHopCount )
{
    return StdPropertyGet ( m_lHopCount, plHopCount );
}


STDMETHODIMP CSmtpAdminVirtualServer::put_HopCount( long lHopCount )
{
    return StdPropertyPut ( &m_lHopCount, lHopCount, &m_bvChangedFields, BitMask(ID_HOP_COUNT));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_SmartHost( BSTR * pstrSmartHost )
{
    return StdPropertyGet ( m_strSmartHost, pstrSmartHost );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SmartHost( BSTR strSmartHost )
{
    return StdPropertyPut ( &m_strSmartHost, strSmartHost, &m_bvChangedFields, BitMask(ID_SMARTHOST));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_EnableDNSLookup( BOOL * pfEnableDNSLookup )
{
    return StdPropertyGet ( m_fEnableDNSLookup, pfEnableDNSLookup );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_EnableDNSLookup( BOOL fEnableDNSLookup )
{
    return StdPropertyPut ( &m_fEnableDNSLookup, fEnableDNSLookup, &m_bvChangedFields, BitMask(ID_ENABLEDNSLOOKUP));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_PostmasterEmail( BSTR * pstrPostmasterEmail )
{
    return StdPropertyGet ( m_strPostmasterEmail, pstrPostmasterEmail );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_PostmasterEmail( BSTR strPostmasterEmail )
{
    return StdPropertyPut ( &m_strPostmasterEmail, strPostmasterEmail, &m_bvChangedFields, BitMask(ID_POSTMASTEREMAIL));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_PostmasterName( BSTR * pstrPostmasterName )
{
    return StdPropertyGet ( m_strPostmasterName, pstrPostmasterName );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_PostmasterName( BSTR strPostmasterName )
{
    return StdPropertyPut ( &m_strPostmasterName, strPostmasterName, &m_bvChangedFields, BitMask(ID_POSTMASTERNAME));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_DefaultDomain( BSTR * pstrDefaultDomain )
{
    return StdPropertyGet ( m_strDefaultDomain, pstrDefaultDomain );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DefaultDomain( BSTR strDefaultDomain )
{
    return StdPropertyPut ( &m_strDefaultDomain, strDefaultDomain, &m_bvChangedFields, BitMask(ID_DEFAULTDOMAIN));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_FQDN( BSTR * pstrFQDN )
{
    return StdPropertyGet ( m_strFQDN, pstrFQDN );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_FQDN( BSTR strFQDN )
{
    return StdPropertyPut ( &m_strFQDN, strFQDN, &m_bvChangedFields, BitMask(ID_FQDN));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_DropDir( BSTR * pstrDropDir )
{
    return StdPropertyGet ( m_strDropDir, pstrDropDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DropDir( BSTR strDropDir )
{
    return StdPropertyPut ( &m_strDropDir, strDropDir, &m_bvChangedFields, BitMask(ID_DROPDIR));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_BadMailDir( BSTR * pstrBadMailDir )
{
    return StdPropertyGet ( m_strBadMailDir, pstrBadMailDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_BadMailDir( BSTR strBadMailDir )
{
    return StdPropertyPut ( &m_strBadMailDir, strBadMailDir, &m_bvChangedFields, BitMask(ID_BADMAILDIR));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_PickupDir( BSTR * pstrPickupDir )
{
    return StdPropertyGet ( m_strPickupDir, pstrPickupDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_PickupDir( BSTR strPickupDir )
{
    return StdPropertyPut ( &m_strPickupDir, strPickupDir, &m_bvChangedFields, BitMask(ID_PICKUPDIR));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_QueueDir( BSTR * pstrQueueDir )
{
    return StdPropertyGet ( m_strQueueDir, pstrQueueDir );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_QueueDir( BSTR strQueueDir )
{
    return StdPropertyPut ( &m_strQueueDir, strQueueDir, &m_bvChangedFields, BitMask(ID_QUEUEDIR));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxInConnection( long * plMaxInConnection )
{
    return StdPropertyGet ( m_lMaxInConnection, plMaxInConnection );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxInConnection( long lMaxInConnection )
{
    return StdPropertyPut ( &m_lMaxInConnection, lMaxInConnection, &m_bvChangedFields, BitMask(ID_MAXINCONNECTION));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxOutConnection( long * plMaxOutConnection )
{
    return StdPropertyGet ( m_lMaxOutConnection, plMaxOutConnection );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxOutConnection( long lMaxOutConnection )
{
    return StdPropertyPut ( &m_lMaxOutConnection, lMaxOutConnection, &m_bvChangedFields, BitMask(ID_MAXOUTCONNECTION));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_InConnectionTimeout( long * plInConnectionTimeout )
{
    return StdPropertyGet ( m_lInConnectionTimeout, plInConnectionTimeout );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_InConnectionTimeout( long lInConnectionTimeout )
{
    return StdPropertyPut ( &m_lInConnectionTimeout, lInConnectionTimeout, &m_bvChangedFields, BitMask(ID_INCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_OutConnectionTimeout( long * plOutConnectionTimeout )
{
    return StdPropertyGet ( m_lOutConnectionTimeout, plOutConnectionTimeout );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_OutConnectionTimeout( long lOutConnectionTimeout )
{
    return StdPropertyPut ( &m_lOutConnectionTimeout, lOutConnectionTimeout, &m_bvChangedFields, BitMask(ID_OUTCONNECTIONTIMEOUT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxMessageSize( long * plMaxMessageSize )
{
    return StdPropertyGet ( m_lMaxMessageSize, plMaxMessageSize );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxMessageSize( long lMaxMessageSize )
{
    return StdPropertyPut ( &m_lMaxMessageSize, lMaxMessageSize, &m_bvChangedFields, BitMask(ID_MAXMESSAGESIZE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxSessionSize( long * plMaxSessionSize )
{
    return StdPropertyGet ( m_lMaxSessionSize, plMaxSessionSize );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxSessionSize( long lMaxSessionSize )
{
    return StdPropertyPut ( &m_lMaxSessionSize, lMaxSessionSize, &m_bvChangedFields, BitMask(ID_MAXSESSIONSIZE));
}
STDMETHODIMP CSmtpAdminVirtualServer::get_MaxMessageRecipients( long * plMaxMessageRecipients )
{
    return StdPropertyGet ( m_lMaxMessageRecipients, plMaxMessageRecipients );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxMessageRecipients( long lMaxMessageRecipients )
{
    return StdPropertyPut ( &m_lMaxMessageRecipients, lMaxMessageRecipients, &m_bvChangedFields, BitMask(ID_MAXMESSAGERECIPIENTS));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LocalRetries( long * plLocalRetries )
{
    return StdPropertyGet ( m_lLocalRetries, plLocalRetries );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LocalRetries( long lLocalRetries )
{
    return StdPropertyPut ( &m_lLocalRetries, lLocalRetries, &m_bvChangedFields, BitMask(ID_LOCALRETRIES));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LocalRetryTime( long * plLocalRetryTime )
{
    return StdPropertyGet ( m_lLocalRetryTime, plLocalRetryTime );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LocalRetryTime( long lLocalRetryTime )
{
    return StdPropertyPut ( &m_lLocalRetryTime, lLocalRetryTime, &m_bvChangedFields, BitMask(ID_LOCALRETRYTIME));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RemoteRetries( long * plRemoteRetries )
{
    return StdPropertyGet ( m_lRemoteRetries, plRemoteRetries );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RemoteRetries( long lRemoteRetries )
{
    return StdPropertyPut ( &m_lRemoteRetries, lRemoteRetries, &m_bvChangedFields, BitMask(ID_REMOTERETRIES));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RemoteRetryTime( long * plRemoteRetryTime )
{
    return StdPropertyGet ( m_lRemoteRetryTime, plRemoteRetryTime );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RemoteRetryTime( long lRemoteRetryTime )
{
    return StdPropertyPut ( &m_lRemoteRetryTime, lRemoteRetryTime, &m_bvChangedFields, BitMask(ID_REMOTERETRYTIME));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ETRNDays( long * plETRNDays )
{
    return StdPropertyGet ( m_lETRNDays, plETRNDays );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ETRNDays( long lETRNDays )
{
    return StdPropertyPut ( &m_lETRNDays, lETRNDays, &m_bvChangedFields, BitMask(ID_ETRNDAYS));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendDNRToPostmaster( BOOL * pfSendDNRToPostmaster )
{
    return StdPropertyGet ( m_fSendDNRToPostmaster, pfSendDNRToPostmaster );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendDNRToPostmaster( BOOL fSendDNRToPostmaster )
{
    return StdPropertyPut ( &m_fSendDNRToPostmaster, fSendDNRToPostmaster, &m_bvChangedFields, BitMask(ID_SENDDNRTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendBadmailToPostmaster( BOOL * pfSendBadmailToPostmaster)
{
    return StdPropertyGet ( m_fSendBadmailToPostmaster, pfSendBadmailToPostmaster );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendBadmailToPostmaster( BOOL fSendBadmailToPostmaster )
{
    return StdPropertyPut ( &m_fSendBadmailToPostmaster, fSendBadmailToPostmaster, &m_bvChangedFields, BitMask(ID_SENDBADMAILTOPOSTMASTER));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingDLL( BSTR * pstrRoutingDLL )
{
    return StdPropertyGet ( m_strRoutingDLL, pstrRoutingDLL );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RoutingDLL( BSTR strRoutingDLL )
{
    return StdPropertyPut ( &m_strRoutingDLL, strRoutingDLL, &m_bvChangedFields, BitMask(ID_ROUTINGDLL));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSources    ( SAFEARRAY ** ppsastrRoutingSources )
{
    return StdPropertyGet ( &m_mszRoutingSources, ppsastrRoutingSources );
}
STDMETHODIMP CSmtpAdminVirtualServer::put_RoutingSources    ( SAFEARRAY * psastrRoutingSources )
{
    return StdPropertyPut ( &m_mszRoutingSources, psastrRoutingSources, &m_bvChangedFields, BitMask(ID_ROUTINGSOURCES) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RoutingSourcesVariant( SAFEARRAY ** ppsavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = get_RoutingSources ( &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrRoutingSources, ppsavarRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RoutingSourcesVariant( SAFEARRAY * psavarRoutingSources )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrRoutingSources        = NULL;

    hr = VariantArrayToStringArray ( psavarRoutingSources, &psastrRoutingSources );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_RoutingSources ( psastrRoutingSources );

Exit:
    if ( psastrRoutingSources ) {
        SafeArrayDestroy ( psastrRoutingSources );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_LocalDomains  ( SAFEARRAY ** ppsastrLocalDomains )
{
    return StdPropertyGet ( &m_mszLocalDomains, ppsastrLocalDomains );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LocalDomains  ( SAFEARRAY * psastrLocalDomains )
{
    return StdPropertyPut ( &m_mszLocalDomains, psastrLocalDomains, &m_bvChangedFields, BitMask(ID_LOCALDOMAINS) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_DomainRouting ( SAFEARRAY ** ppsastrDomainRouting )
{
    return StdPropertyGet ( &m_mszDomainRouting, ppsastrDomainRouting );
}
STDMETHODIMP CSmtpAdminVirtualServer::put_DomainRouting ( SAFEARRAY * psastrDomainRouting )
{
    return StdPropertyPut ( &m_mszDomainRouting, psastrDomainRouting, &m_bvChangedFields, BitMask(ID_DOMAINROUTING) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_DomainRoutingVariant( SAFEARRAY ** ppsavarDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = get_DomainRouting ( &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( pstrDomainRouting, ppsavarDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DomainRoutingVariant( SAFEARRAY * psastrDomainRouting )
{
    HRESULT                 hr;
    SAFEARRAY *             pstrDomainRouting        = NULL;

    hr = VariantArrayToStringArray ( psastrDomainRouting, &pstrDomainRouting );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_DomainRouting ( pstrDomainRouting );

Exit:
    if ( pstrDomainRouting ) {
        SafeArrayDestroy ( pstrDomainRouting );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_MasqueradeDomain( BSTR * pstrMasqueradeDomain )
{
    return StdPropertyGet ( m_strMasqueradeDomain, pstrMasqueradeDomain );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MasqueradeDomain( BSTR strMasqueradeDomain )
{
    return StdPropertyPut ( &m_strMasqueradeDomain, strMasqueradeDomain, &m_bvChangedFields, BitMask(ID_MASQUERADE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendNdrTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strNdrAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendNdrTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strNdrAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDNDRTO));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_SendBadTo( BSTR * pstrAddr )
{
    return StdPropertyGet( m_strBadAddr, pstrAddr );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SendBadTo( BSTR strAddr )
{
    return StdPropertyPut ( &m_strBadAddr, strAddr, &m_bvChangedFields, BitMask(ID_SENDBADTO));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_RemoteSecurePort( long * plRemoteSecurePort )
{
    return StdPropertyGet( m_lRemoteSecurePort, plRemoteSecurePort );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RemoteSecurePort( long lRemoteSecurePort )
{
    return StdPropertyPut ( &m_lRemoteSecurePort, lRemoteSecurePort, &m_bvChangedFields, BitMask(ID_REMOTE_SECURE_PORT));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ShouldDeliver( BOOL * pfShouldDeliver )
{
    return StdPropertyGet( m_fShouldDeliver, pfShouldDeliver );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ShouldDeliver( BOOL fShouldDeliver )
{
    return StdPropertyPut ( &m_fShouldDeliver, fShouldDeliver, &m_bvChangedFields, BitMask(ID_SHOULD_DELIVER));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AlwaysUseSsl( BOOL * pfAlwaysUseSsl )
{
    return StdPropertyGet( m_fAlwaysUseSsl, pfAlwaysUseSsl );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AlwaysUseSsl( BOOL fAlwaysUseSsl )
{
    return StdPropertyPut ( &m_fAlwaysUseSsl, fAlwaysUseSsl, &m_bvChangedFields, BitMask(ID_ALWAYS_USE_SSL));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LimitRemoteConnections( BOOL * pfLimitRemoteConnections )
{
    return StdPropertyGet( m_fLimitRemoteConnections, pfLimitRemoteConnections );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LimitRemoteConnections( BOOL fLimitRemoteConnections )
{
    return StdPropertyPut ( &m_fLimitRemoteConnections, fLimitRemoteConnections, &m_bvChangedFields, BitMask(ID_LIMIT_REMOTE_CONNECTIONS));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_MaxOutConnPerDomain( long * plMaxOutConnPerDomain )
{
    return StdPropertyGet( m_lMaxOutConnPerDomain, plMaxOutConnPerDomain );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_MaxOutConnPerDomain( long lMaxOutConnPerDomain )
{
    return StdPropertyPut ( &m_lMaxOutConnPerDomain, lMaxOutConnPerDomain, &m_bvChangedFields, BitMask(ID_MAX_OUT_CONN_PER_DOMAIN));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AllowVerify( BOOL * pfAllowVerify )
{
    return StdPropertyGet( m_fAllowVerify, pfAllowVerify );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AllowVerify( BOOL fAllowVerify )
{
    return StdPropertyPut ( &m_fAllowVerify, fAllowVerify, &m_bvChangedFields, BitMask(ID_ALLOW_VERIFY));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AllowExpand( BOOL * pfAllowExpand )
{
    return StdPropertyGet( m_fAllowExpand, pfAllowExpand);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AllowExpand( BOOL fAllowExpand )
{
    return StdPropertyPut ( &m_fAllowExpand, fAllowExpand, &m_bvChangedFields, BitMask(ID_ALLOW_EXPAND));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_SmartHostType( long * plSmartHostType )
{
    return StdPropertyGet( m_lSmartHostType, plSmartHostType );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_SmartHostType( long lSmartHostType )
{
    return StdPropertyPut ( &m_lSmartHostType, lSmartHostType, &m_bvChangedFields, BitMask(ID_SMART_HOST_TYPE));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_BatchMessages( BOOL * pfBatchMessages )
{
    return StdPropertyGet( m_fBtachMsgs, pfBatchMessages );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_BatchMessages( BOOL fBatchMessages )
{
    return StdPropertyPut ( &m_fBtachMsgs, fBatchMessages, &m_bvChangedFields, BitMask(ID_BATCH_MSGS));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_BatchMessageLimit( long * plBatchMessageLimit )
{
    return StdPropertyGet( m_lBatchMsgLimit, plBatchMessageLimit );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_BatchMessageLimit( long lBatchMessageLimit )
{
    return StdPropertyPut ( &m_lBatchMsgLimit, lBatchMessageLimit, &m_bvChangedFields, BitMask(ID_BATCH_MSG_LIMIT));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_DoMasquerade( BOOL * pfDoMasquerade )
{
    return StdPropertyGet( m_fDoMasquerade, pfDoMasquerade );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DoMasquerade( BOOL fDoMasquerade )
{
    return StdPropertyPut ( &m_fDoMasquerade, fDoMasquerade, &m_bvChangedFields, BitMask(ID_DO_MASQUERADE));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_Administrators ( SAFEARRAY ** ppsastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::get_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        hr = SafeArrayCopy ( m_psaAdmins, ppsastrAdmins );
    }
    else {
        *ppsastrAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Administrators ( SAFEARRAY * psastrAdmins )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::put_Administrators" );

    HRESULT     hr  = NOERROR;

    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
    }

    if ( psastrAdmins ) {
        hr = SafeArrayCopy ( psastrAdmins, &m_psaAdmins );
    }
    else {
        m_psaAdmins = NULL;
        hr = NOERROR;
    }

    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::get_AdministratorsVariant( SAFEARRAY ** ppsavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = get_Administrators ( &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = StringArrayToVariantArray ( psastrAdmins, ppsavarAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AdministratorsVariant( SAFEARRAY * psavarAdmins )
{
    HRESULT                 hr;
    SAFEARRAY *             psastrAdmins        = NULL;

    hr = VariantArrayToStringArray ( psavarAdmins, &psastrAdmins );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = put_Administrators ( psastrAdmins );

Exit:
    if ( psastrAdmins ) {
        SafeArrayDestroy ( psastrAdmins );
    }

    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::get_AuthenticationPackages(BSTR *pstrAuthPackages)
{
    return StdPropertyGet(m_strAuthPackages, pstrAuthPackages);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AuthenticationPackages(BSTR strAuthPackages)
{
    return StdPropertyPut(&m_strAuthPackages, strAuthPackages, &m_bvChangedFields,
        BitMask(ID_AUTH_PACKAGES));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ClearTextAuthPackage(BSTR *pstrAuthPackages)
{
    return StdPropertyGet(m_strClearTextAuthPackage, pstrAuthPackages);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ClearTextAuthPackage(BSTR strAuthPackages)
{
    return StdPropertyPut(&m_strClearTextAuthPackage, strAuthPackages, &m_bvChangedFields,
        BitMask(ID_CLEARTEXT_AUTH_PACKAGE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_AuthenticationMethod(long *plAuthMethod)
{
    return StdPropertyGet(m_lAuthMethod, plAuthMethod);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AuthenticationMethod(long lAuthMethod)
{
    return StdPropertyPut(&m_lAuthMethod, lAuthMethod, &m_bvChangedFields,
        BitMask(ID_AUTH_METHOD));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_DefaultLogonDomain(BSTR *pstrLogonDomain)
{
    return StdPropertyGet(m_strDefaultLogonDomain, pstrLogonDomain);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_DefaultLogonDomain(BSTR strLogonDomain)
{
    return StdPropertyPut(&m_strDefaultLogonDomain, strLogonDomain, &m_bvChangedFields,
        BitMask(ID_DEFAULT_LOGON_DOMAIN));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RouteAction(long *plRouteAction)
{
    return StdPropertyGet(m_lRouteAction, plRouteAction);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RouteAction(long lRouteAction)
{
    return StdPropertyPut(&m_lRouteAction, lRouteAction, &m_bvChangedFields,
        BitMask(ID_ROUTE_ACTION));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RouteUserName(BSTR *pstrRouteUserName)
{
    return StdPropertyGet(m_strRouteUserName, pstrRouteUserName);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RouteUserName(BSTR strRouteUserName)
{
    return StdPropertyPut(&m_strRouteUserName, strRouteUserName, &m_bvChangedFields,
        BitMask(ID_ROUTE_USER_NAME));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_RoutePassword(BSTR *pstrRoutePassword)
{
    return StdPropertyGet(m_strRoutePassword, pstrRoutePassword);
}

STDMETHODIMP CSmtpAdminVirtualServer::put_RoutePassword(BSTR strRoutePassword)
{
    return StdPropertyPut(&m_strRoutePassword, strRoutePassword, &m_bvChangedFields,
        BitMask(ID_ROUTE_PASSWORD));
}


STDMETHODIMP CSmtpAdminVirtualServer::get_LogFileDirectory( BSTR * pstrLogFileDirectory )
{
    return StdPropertyGet ( m_strLogFileDirectory, pstrLogFileDirectory );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogFileDirectory( BSTR strLogFileDirectory )
{
    return StdPropertyPut ( &m_strLogFileDirectory, strLogFileDirectory, &m_bvChangedFields, BitMask(ID_LOGFILEDIRECTORY));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogFilePeriod( long * plLogFilePeriod )
{
    return StdPropertyGet ( m_lLogFilePeriod, plLogFilePeriod );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogFilePeriod( long lLogFilePeriod )
{
    return StdPropertyPut ( &m_lLogFilePeriod, lLogFilePeriod, &m_bvChangedFields, BitMask(ID_LOGFILEPERIOD));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogFileTruncateSize( long * plLogFileTruncateSize )
{
    return StdPropertyGet ( m_lLogFileTruncateSize, plLogFileTruncateSize );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogFileTruncateSize( long lLogFileTruncateSize )
{
    return StdPropertyPut ( &m_lLogFileTruncateSize, lLogFileTruncateSize, &m_bvChangedFields, BitMask(ID_LOGFILETRUNCATESIZE));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogMethod( long * plLogMethod )
{
    return StdPropertyGet ( m_lLogMethod, plLogMethod );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogMethod( long lLogMethod )
{
    return StdPropertyPut ( &m_lLogMethod, lLogMethod, &m_bvChangedFields, BitMask(ID_LOGMETHOD));
}

STDMETHODIMP CSmtpAdminVirtualServer::get_LogType( long * plLogType )
{
    return StdPropertyGet ( m_lLogType, plLogType );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_LogType( long lLogType )
{
    return StdPropertyPut ( &m_lLogType, lLogType, &m_bvChangedFields, BitMask(ID_LOGTYPE));
}


//
//  Service State Properties:
//
STDMETHODIMP CSmtpAdminVirtualServer::get_AutoStart ( BOOL * pfAutoStart )
{
    return StdPropertyGet ( m_fAutoStart, pfAutoStart );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_AutoStart ( BOOL fAutoStart )
{
    return StdPropertyPut ( &m_fAutoStart, fAutoStart, &m_bvChangedFields, BitMask(ID_AUTOSTART) );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_ServerState ( DWORD * pdwServerState )
{
    return StdPropertyGet ( (long)m_dwServerState, (long *)pdwServerState );
}

STDMETHODIMP CSmtpAdminVirtualServer::get_Win32ErrorCode ( long * plWin32ErrorCode )
{
    return StdPropertyGet ( m_dwWin32ErrorCode, plWin32ErrorCode );
}


// Service-specific properties:

STDMETHODIMP CSmtpAdminVirtualServer::get_Comment( BSTR * pstrComment )
{
    return StdPropertyGet ( m_strComment, pstrComment );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_Comment( BSTR strComment )
{
    return StdPropertyPut ( &m_strComment, strComment, &m_bvChangedFields, BitMask(ID_COMMENT));
}

/*
STDMETHODIMP CSmtpAdminVirtualServer::get_ErrorControl ( BOOL * pfErrorControl )
{
    return StdPropertyGet ( m_fErrorControl, pfErrorControl );
}

STDMETHODIMP CSmtpAdminVirtualServer::put_ErrorControl ( BOOL fErrorControl )
{
    return StdPropertyPut ( &m_fErrorControl, fErrorControl );
}
*/

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminVirtualServer::BackupRoutingTable( BSTR strPath )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::BackupRoutingTable" );

    HRESULT         hr      = NOERROR;
    DWORD           dwErr   = NOERROR;

    dwErr = SmtpBackupRoutingTable ( 
                    (LPWSTR) m_strServer,  
                    (LPWSTR) strPath,
                    (int)m_dwServiceInstance );

    if ( dwErr != 0 ) {
        ErrorTraceX ( (LPARAM) this, "Failed to backup routing table: %x", dwErr );
        SetLastError( dwErr );
        hr = SmtpCreateExceptionFromWin32Error ( dwErr );
        goto Exit;
    }

Exit:
    TraceFunctLeave ();
    return hr;
}


//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::Get
//
//  Description:
//
//      Gets server properties from the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//      (property) m_dwServiceInstance - which SMTP to talk to.
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminVirtualServer::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Get" );

    HRESULT                             hr = NOERROR;
    CComPtr<IMSAdminBase>              pmetabase;
    CComObject<CServerBindings> *       pBindings = NULL;

    // Create the bindings collection:
    m_pBindings.Release ();

    hr = CComObject<CServerBindings>::CreateInstance ( &pBindings );
    if ( FAILED(hr) ) {
        FatalTrace ( (LPARAM) this, "Could not create bindings collection" );
        goto Exit;
    }

    hr = pBindings->QueryInterface ( IID_IServerBindings, (void **) &m_pBindings );
    _ASSERT ( SUCCEEDED(hr) );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    m_pPrivateBindings  = pBindings;


    // Validate Server & Service Instance:

    // Talk to the metabase:
    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = GetPropertiesFromMetabase ( pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully got service properties" );
    m_fGotProperties    = TRUE;
    m_bvChangedFields   = 0;

Exit:
    TraceFunctLeave ();

    return hr;

    // CComPtr automatically releases the metabase handle.
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::Set
//
//  Description:
//
//      Sends server properties to the metabase.
//
//  Parameters:
//
//      (property) m_strServer
//      fFailIfChanged - return an error if the metabase has changed?
//
//  Returns:
//
//      E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdminVirtualServer::Set ( BOOL fFailIfChanged )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Set" );

    HRESULT hr  = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;
    

    // Make sure the client call Get first:
    if ( !m_fGotProperties ) {
        ErrorTrace ( 0, "Didn't call get first" );

        hr = SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
        goto Exit;
    }

    // Validate Server & Service Instance:
    if ( m_dwServiceInstance == 0 ) {
        return SmtpCreateException ( IDS_SMTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
    }

    if ( !m_fGotProperties ) {
        return SmtpCreateException ( IDS_SMTPEXCEPTION_DIDNT_CALL_GET );
    }

    // Validate data members:
    if ( !ValidateStrings () ) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if ( !ValidateProperties ( ) ) {
        hr = SmtpCreateExceptionFromWin32Error ( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = SendPropertiesToMetabase ( fFailIfChanged, pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    StateTrace ( 0, "Successfully set service properties" );

    // successfully saved, reset change field bitmap
    m_bvChangedFields = 0;

Exit:
    TraceFunctLeave ();
    return hr;
}


#define MAX_SLEEP_INST      30000
#define SLEEP_INTERVAL      500

HRESULT CSmtpAdminVirtualServer::ControlService (
    IMSAdminBase *  pMetabase,
    DWORD           ControlCode,
    DWORD           dwDesiredState,
    DWORD           dwPendingState
    )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::ControlService" );

    HRESULT hr              = NOERROR;
    DWORD   dwCurrentState  = dwPendingState;
    DWORD   dwOldState      = dwPendingState;
    DWORD   dwSleepTotal    = 0;

    hr = CheckServiceState ( pMetabase, &dwCurrentState );
    BAIL_ON_FAILURE(hr);

    if ( dwCurrentState == dwDesiredState ) {
        // Nothing to do...
        goto Exit;
    }

    dwOldState  = dwCurrentState;

    //
    //  Special case: trying to start a paused service:
    //

    if ( dwDesiredState == MD_SERVER_STATE_STARTED &&
        dwCurrentState == MD_SERVER_STATE_PAUSED ) {

        ControlCode     = MD_SERVER_COMMAND_CONTINUE;
        dwPendingState  = MD_SERVER_STATE_CONTINUING;
    }
    
    hr = WriteStateCommand ( pMetabase, ControlCode );
    BAIL_ON_FAILURE(hr);

    for(dwSleepTotal = 0, dwCurrentState = dwPendingState;
        (dwCurrentState == dwPendingState || dwCurrentState == dwOldState) && (dwSleepTotal < MAX_SLEEP_INST); 
        dwSleepTotal += SLEEP_INTERVAL
        ) 
    {
        Sleep ( SLEEP_INTERVAL );

        hr = CheckServiceState ( pMetabase, &dwCurrentState );
        BAIL_ON_FAILURE(hr);

        if ( m_dwWin32ErrorCode != NOERROR ) {
            //
            // The service gave an error code.
            //

            break;
        }
    }

    if ( dwSleepTotal >= MAX_SLEEP_INST ) {
        hr = HRESULT_FROM_WIN32 ( ERROR_SERVICE_REQUEST_TIMEOUT );
        goto Exit;
    }

Exit:
    // m_State = TranslateServerState ( dwCurrentState );

    m_dwServerState = dwCurrentState;

    TraceFunctLeave ();
    return hr;
}

HRESULT CSmtpAdminVirtualServer::WriteStateCommand ( IMSAdminBase * pMetabase, DWORD ControlCode )
{
    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;
    TCHAR   szInstancePath [ METADATA_MAX_NAME_LEN ];

    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );

    hr = metabase.Open ( szInstancePath, METADATA_PERMISSION_WRITE );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    fRet = fRet && StdPutMetabaseProp ( &metabase, MD_WIN32_ERROR, NOERROR, _T(""), IIS_MD_UT_SERVER, METADATA_VOLATILE );
    fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_COMMAND, ControlCode );
    if ( !fRet ) {
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CSmtpAdminVirtualServer::CheckServiceState ( IMSAdminBase * pMetabase, DWORD * pdwState )
{
    HRESULT     hr  = NOERROR;
    CMetabaseKey            metabase ( pMetabase );
    TCHAR       szInstancePath [ METADATA_MAX_NAME_LEN ];
    BOOL        fRet = TRUE;

    *pdwState   = MD_SERVER_STATE_INVALID;

    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );
    hr = metabase.Open ( szInstancePath );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    fRet = metabase.GetDword ( MD_WIN32_ERROR, &m_dwWin32ErrorCode );
    fRet = metabase.GetDword ( MD_SERVER_STATE, pdwState );

Exit:
    if ( !fRet ) {
        hr = HRESULT_FROM_WIN32( GetLastError () );
    }
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::Start ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Start" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_START, 
        MD_SERVER_STATE_STARTED, 
        MD_SERVER_STATE_STARTING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::Pause ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Pause" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_PAUSE, 
        MD_SERVER_STATE_PAUSED, 
        MD_SERVER_STATE_PAUSING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminVirtualServer::Continue ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Pause" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_CONTINUE, 
        MD_SERVER_STATE_STARTED, 
        MD_SERVER_STATE_CONTINUING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminVirtualServer::Stop ( )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::Start" );

    HRESULT                 hr      = NOERROR;
    CComPtr<IMSAdminBase>   pmetabase;

    hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
    if ( FAILED(hr) ) {
        goto Exit;
    }

    hr = ControlService ( 
        pmetabase, 
        MD_SERVER_COMMAND_STOP, 
        MD_SERVER_STATE_STOPPED, 
        MD_SERVER_STATE_STOPPING 
        );

Exit:
    TraceFunctLeave ();
    return hr;
}


//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::GetPropertiesFromMetabase
//
//  Description:
//
//      Asks the metabase for each property in this class.
//      This class's properties come from /LM/SmtpSvc/
//
//  Parameters:
//
//      pMetabase - The metabase object
//
//  Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminVirtualServer::GetPropertiesFromMetabase ( IMSAdminBase * pMetabase )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::GetPropertiesFromMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;

    TCHAR   szInstancePath [ METADATA_MAX_NAME_LEN ];
    WCHAR   wszDefaultComment[128]={0};

    PSECURITY_DESCRIPTOR        pSD = NULL;
    DWORD                       cbSD    = 0;

    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );
    wsprintfW( wszDefaultComment, L"[SMTP Virtual Server #%d]", m_dwServiceInstance );

    hr = metabase.Open ( szInstancePath );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    // Overridable server properties:

    hr = m_RoutingSource.Get(&metabase);
    BAIL_ON_FAILURE(hr);
#if 0
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_PORT,          DEFAULT_SSLPORT,            &m_lSSLPort )           && fRet;
#endif
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     DEFAULT_OUTBOND_PORT,       &m_lOutboundPort )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   DEFAULT_SMART_HOST,             &m_strSmartHost )       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_HOP_COUNT,        DEFAULT_HOP_COUNT,              &m_lHopCount )      && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,DEFAULT_ENABLE_DNS_LOOKUP,    &m_fEnableDNSLookup )   && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, DEFAULT_POSTMASTER_EMAIL,       &m_strPostmasterEmail ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  DEFAULT_POSTMASTER_NAME,        &m_strPostmasterName )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_FQDN_VALUE,           DEFAULT_FQDN,               &m_strFQDN )            && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, DEFAULT_DEFAULT_DOMAIN,     &m_strDefaultDomain )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,        DEFAULT_DROP_DIR,           &m_strDropDir )         && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     DEFAULT_BADMAIL_DIR,            &m_strBadMailDir )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  DEFAULT_PICKUP_DIR,             &m_strPickupDir )       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   DEFAULT_QUEUE_DIR,              &m_strQueueDir )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  DEFAULT_MAX_OUT_CONNECTION,     &m_lMaxOutConnection )      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   DEFAULT_OUT_CONNECTION_TIMEOUT, &m_lOutConnectionTimeout )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     DEFAULT_MAX_MESSAGE_SIZE,       &m_lMaxMessageSize )        && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    DEFAULT_MAX_SESSION_SIZE,       &m_lMaxSessionSize )        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       DEFAULT_MAX_MESSAGE_RECIPIENTS,     &m_lMaxMessageRecipients )      && fRet;


    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     DEFAULT_LOCAL_RETRIES,      &m_lLocalRetries)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      DEFAULT_LOCAL_RETRY_TIME,   &m_lLocalRetryTime)     && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    DEFAULT_REMOTE_RETRIES,     &m_lRemoteRetries)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     DEFAULT_REMOTE_RETRY_TIME,  &m_lRemoteRetryTime)        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ETRN_DAYS,                DEFAULT_ETRN_DAYS,          &m_lETRNDays)       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_DLL,          DEFAULT_ROUTING_DLL,            &m_strRoutingDLL)       && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      DEFAULT_ROUTING_SOURCES,            &m_mszRoutingSources)       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        DEFAULT_LOCAL_DOMAINS,          &m_mszLocalDomains)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       DEFAULT_DOMAIN_ROUTING,         &m_mszDomainRouting)        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MASQUERADE_NAME,          DEFAULT_MASQUERADE_DOMAIN,  &m_strMasqueradeDomain) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_NDR_TO,          DEFAULT_SENDNDRTO,  &m_strNdrAddr)  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SEND_BAD_TO,          DEFAULT_SENDBADTO,  &m_strBadAddr)  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   DEFAULT_REMOTE_SECURE_PORT, &m_lRemoteSecurePort)   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SHOULD_DELIVER,       DEFAULT_SHOULD_DELIVER, &m_fShouldDeliver  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,           DEFAULT_ALWAYS_USE_SSL,             &m_fAlwaysUseSsl  ) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, DEFAULT_LIMIT_REMOTE_CONNECTIONS,   &m_fLimitRemoteConnections  )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  DEFAULT_MAX_OUT_CONN_PER_DOMAIN,    &m_lMaxOutConnPerDomain  )  && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,           DEFAULT_SMART_HOST_TYPE,        &m_lSmartHostType  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,          DEFAULT_BATCH_MSG_LIMIT,        &m_lBatchMsgLimit  )    && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_DO_MASQUERADE,            DEFAULT_DO_MASQUERADE,          &m_fDoMasquerade  ) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTE_ACTION,             DEFAULT_ROUTE_ACTION,           &m_lRouteAction  )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTE_USER_NAME,          DEFAULT_ROUTE_USER_NAME,        &m_strRouteUserName  )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_ROUTE_PASSWORD,           DEFAULT_ROUTE_PASSWORD,         &m_strRoutePassword  )  && fRet;

    //
    //  IIS common propperties
    //
    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_BINDINGS,  DEFAULT_SERVER_BINDINGS,        &m_mszServerBindings )  && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_BINDINGS,  DEFAULT_SECURE_BINDINGS,        &m_mszSecureBindings )  && fRet;
//  fRet = StdGetMetabaseProp ( &metabase, MD_PORT,             DEFAULT_PORT,                   &m_lPort )              && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  DEFAULT_MAX_IN_CONNECTION,      &m_lMaxInConnection )   && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,DEFAULT_IN_CONNECTION_TIMEOUT, &m_lInConnectionTimeout )       && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_NTAUTHENTICATION_PROVIDERS, DEFAULT_AUTH_PACKAGES,    &m_strAuthPackages) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, DEFAULT_CLEARTEXT_AUTH_PACKAGE, &m_strClearTextAuthPackage) && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_AUTHORIZATION, DEFAULT_AUTHENTICATION, &m_lAuthMethod) && fRet; 
    fRet = StdGetMetabaseProp ( &metabase, MD_SASL_LOGON_DOMAIN, DEFAULT_LOGON_DOMAIN,  &m_strDefaultLogonDomain) && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,    DEFAULT_LOGFILE_DIRECTORY,          &m_strLogFileDirectory)     && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       DEFAULT_LOGFILE_PERIOD,             &m_lLogFilePeriod)      && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,DEFAULT_LOGFILE_TRUNCATE_SIZE,      &m_lLogFileTruncateSize)        && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_LOG_TYPE,             DEFAULT_LOG_TYPE,                   &m_lLogType)        && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,     DEFAULT_AUTOSTART,              &m_fAutoStart )             && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_COMMENT,       wszDefaultComment,              &m_strComment )         && fRet;

    fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_STATE,         MD_SERVER_STATE_STOPPED,        &m_dwServerState )          && fRet;
    fRet = StdGetMetabaseProp ( &metabase, MD_WIN32_ERROR,          NOERROR,                        &m_dwWin32ErrorCode )       && fRet;

    //  Get the admin ACL
    pSD = NULL;
    cbSD    = 0;

    hr = metabase.GetDataSize ( _T(""), MD_ADMIN_ACL, BINARY_METADATA, &cbSD );
    if( SUCCEEDED(hr) ) 
    {
        _ASSERT ( cbSD != 0 );
        pSD = (PSECURITY_DESCRIPTOR) new char [ cbSD ];
        
        if( NULL == pSD )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        
        hr = NOERROR;
        hr = metabase.GetBinary ( MD_ADMIN_ACL, pSD, cbSD );
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Get the tcp access restrictions:
    //

    hr = m_pPrivateIpAccess->GetFromMetabase ( &metabase );
    BAIL_ON_FAILURE(hr);

    // Check all property strings:
    // If any string is NULL, it is because we failed to allocate memory:
    if ( !ValidateStrings () ) {

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // We can only fail from memory allocations:
    _ASSERT ( fRet );

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

    // Extract the bindings:
    hr = MDBindingsToIBindings ( &m_mszServerBindings, TRUE, m_pBindings );
    BAIL_ON_FAILURE(hr);

    hr = MDBindingsToIBindings ( &m_mszSecureBindings, FALSE, m_pBindings );
    BAIL_ON_FAILURE(hr);

    // Extract the Administrator list:
    if ( m_psaAdmins ) {
        SafeArrayDestroy ( m_psaAdmins );
        m_psaAdmins = NULL;
    }
    if ( pSD ) {
        hr = AclToAdministrators ( m_strServer, pSD, &m_psaAdmins );
        BAIL_ON_FAILURE(hr);
    }

    // Validate the data received from the metabase:
    _ASSERT ( ValidateStrings () );
    _ASSERT ( ValidateProperties( ) );

    if ( !ValidateProperties(  ) ) {
        CorrectProperties ();
    }

Exit:
    delete (char*) pSD;

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::SendPropertiesToMetabase
//
//  Description:
//
//      Saves each property to the metabase.
//      This class's properties go into /LM/SmtpSvc/
//
//  Parameters:
//
//      fFailIfChanged  - Return a failure code if the metabase
//          has changed since last get.
//      pMetabase - the metabase object.
//
//  Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdminVirtualServer::SendPropertiesToMetabase ( 
    BOOL fFailIfChanged, 
    IMSAdminBase * pMetabase
    )
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::SendPropertiesToMetabase" );

    HRESULT hr  = NOERROR;
    CMetabaseKey        metabase    ( pMetabase );
    BOOL    fRet = TRUE;
    TCHAR   szInstancePath [ METADATA_MAX_NAME_LEN ];

    //
    //  Set the admin acl:
    //

    PSECURITY_DESCRIPTOR    pSD     = NULL;
    DWORD                   cbSD    = 0;

//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( m_psaAdmins ) {
            hr = AdministratorsToAcl ( m_strServer, m_psaAdmins, &pSD, &cbSD );
            BAIL_ON_FAILURE(hr);
        }
//  }


    // Open metabase key
    GetMDInstancePath ( szInstancePath, m_dwServiceInstance );
    hr = metabase.Open ( szInstancePath, METADATA_PERMISSION_WRITE );
    if ( FAILED(hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to open instance key, %x", GetLastError() );

        // !!!magnush - Should we return a simple Service doesn't exist error code?
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
        goto Exit;
    }

    // Does the client care if the key has changed?
    if ( fFailIfChanged ) {

        //  Did the key change?
        if ( HasKeyChanged ( pMetabase, metabase.QueryHandle(), &m_ftLastChanged ) ) {

            StateTrace ( (LPARAM) this, "Metabase has changed, not setting properties" );
            // !!!magnush - Return the appropriate error code:
            hr = E_FAIL;
            goto Exit;
        }
    }

    // Extract the bindings:
    if( !(m_bvChangedFields & BitMask(ID_SERVER_BINDINGS)) )
    {
        hr = IBindingsToMDBindings ( m_pBindings, TRUE, &m_mszServerBindings );
        BAIL_ON_FAILURE(hr);
        m_bvChangedFields |= BitMask(ID_SERVER_BINDINGS);
    }

    if( !(m_bvChangedFields & BitMask(ID_SECURE_BINDINGS)) )
    {
        hr = IBindingsToMDBindings ( m_pBindings, FALSE, &m_mszSecureBindings );
        BAIL_ON_FAILURE(hr);
        m_bvChangedFields |= BitMask(ID_SECURE_BINDINGS);
    }

    //
    //  The general procedure here is to keep setting metabase properties
    //  as long as nothing has gone wrong.  This is done by short-circuiting
    //  the statement by ANDing it with the status code.  This makes the code
    //  much more concise.
    //

    fRet = TRUE;

    // Overridable server properties:
    hr = m_RoutingSource.Set(&metabase);
    BAIL_ON_FAILURE(hr);
#if 0
    if ( m_bvChangedFields & BitMask(ID_SSLPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,          m_lSSLPort )        && fRet;
    }
#endif
    if ( m_bvChangedFields & BitMask(ID_OUTBOUNDPORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SMTP_PORT,     m_lOutboundPort )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_HOP_COUNT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_HOP_COUNT,    m_lHopCount )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMARTHOST) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_NAME,   m_strSmartHost )        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ENABLEDNSLOOKUP) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REVERSE_NAME_LOOKUP,m_fEnableDNSLookup )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTEREMAIL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_EMAIL, m_strPostmasterEmail )  && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_POSTMASTERNAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_POSTMASTER_NAME,  m_strPostmasterName )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_FQDN) ) 
    {
        if( m_strFQDN.m_str && m_strFQDN.m_str[0] )
        {
            fRet = StdPutMetabaseProp ( &metabase, MD_FQDN_VALUE,   m_strFQDN )         && fRet;
        }
        else
        {
            if( !metabase.DeleteData( _T(""), MD_FQDN_VALUE, STRING_METADATA ) )
            {
                // not an error if data not exists on the instance level
                fRet = fRet && ( GetLastError() == MD_ERROR_DATA_NOT_FOUND );
            }
        }
    }

    if ( m_bvChangedFields & BitMask(ID_DEFAULTDOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DEFAULT_DOMAIN_VALUE, m_strDefaultDomain )            && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DROPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_DROP_DIR,    m_strDropDir )          && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BADMAILDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BAD_MAIL_DIR,     m_strBadMailDir )       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_PICKUPDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_PICKUP_DIR,  m_strPickupDir )        && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_QUEUEDIR) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAIL_QUEUE_DIR,   m_strQueueDir )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXOUTCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUTBOUND_CONNECTION,  m_lMaxOutConnection )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_OUTCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_TIMEOUT,   m_lOutConnectionTimeout )   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE,     m_lMaxMessageSize )     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_MAXSESSIONSIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_MSG_SIZE_B4_CLOSE,    m_lMaxSessionSize )     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXMESSAGERECIPIENTS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_RECIPIENTS,       m_lMaxMessageRecipients )       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_MINUTES,      m_lLocalRetryTime)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_REMOTERETRYTIME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_MINUTES,     m_lRemoteRetryTime)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ETRNDAYS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ETRN_DAYS,                m_lETRNDays)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGDLL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_DLL,          m_strRoutingDLL)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ROUTINGSOURCES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTING_SOURCES,      &m_mszRoutingSources)   && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALDOMAINS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_DOMAINS,        &m_mszLocalDomains)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DOMAINROUTING) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DOMAIN_ROUTING,       &m_mszDomainRouting)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LOCALRETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOCAL_RETRY_ATTEMPTS,     m_lLocalRetries)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTERETRIES) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_RETRY_ATTEMPTS,    m_lRemoteRetries)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MASQUERADE_NAME,  m_strMasqueradeDomain)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDNDRTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_NDR_TO,  m_strNdrAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SENDBADTO) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SEND_BAD_TO,  m_strBadAddr)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_REMOTE_SECURE_PORT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_REMOTE_SECURE_PORT,   m_lRemoteSecurePort)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SHOULD_DELIVER) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SHOULD_DELIVER,   m_fShouldDeliver)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_ALWAYS_USE_SSL) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ALWAYS_USE_SSL,   m_fAlwaysUseSsl)        && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_LIMIT_REMOTE_CONNECTIONS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LIMIT_REMOTE_CONNECTIONS, m_fLimitRemoteConnections)      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAX_OUT_CONN_PER_DOMAIN) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_OUT_CONN_PER_DOMAIN,  m_lMaxOutConnPerDomain)     && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SMART_HOST_TYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SMARTHOST_TYPE,   m_lSmartHostType)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_BATCH_MSG_LIMIT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_BATCH_MSG_LIMIT,  m_lBatchMsgLimit)       && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_DO_MASQUERADE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_DO_MASQUERADE,    m_fDoMasquerade)        && fRet;
    }

    // outbound security
    if ( m_bvChangedFields & BitMask(ID_ROUTE_ACTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTE_ACTION, m_lRouteAction)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ROUTE_USER_NAME) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTE_USER_NAME,  m_strRouteUserName)     && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_ROUTE_PASSWORD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_ROUTE_PASSWORD,   m_strRoutePassword)     && fRet;
    }

    //
    //  IIS common properties
    //
    if ( m_bvChangedFields & BitMask(ID_SERVER_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SERVER_BINDINGS,      &m_mszServerBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_SECURE_BINDINGS) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_SECURE_BINDINGS,      &m_mszSecureBindings )      && fRet;
    }

    if ( m_bvChangedFields & BitMask(ID_MAXINCONNECTION) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,  m_lMaxInConnection )    && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_INCONNECTIONTIMEOUT) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,m_lInConnectionTimeout )       && fRet;
    }

    if (m_bvChangedFields & BitMask(ID_AUTH_PACKAGES)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_NTAUTHENTICATION_PROVIDERS, m_strAuthPackages);
    }

    if (m_bvChangedFields & BitMask(ID_CLEARTEXT_AUTH_PACKAGE)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, m_strClearTextAuthPackage);
    }

    if (m_bvChangedFields & BitMask(ID_AUTH_METHOD)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_AUTHORIZATION, m_lAuthMethod);
    }

    if (m_bvChangedFields & BitMask(ID_DEFAULT_LOGON_DOMAIN)) 
    {
        fRet = fRet && StdPutMetabaseProp(&metabase, MD_SASL_LOGON_DOMAIN, m_strDefaultLogonDomain);
    }

    if ( m_bvChangedFields & BitMask(ID_LOGFILEDIRECTORY) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_DIRECTORY,        m_strLogFileDirectory)      && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILEPERIOD) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_PERIOD,       m_lLogFilePeriod)       && fRet;
    }
    if ( m_bvChangedFields & BitMask(ID_LOGFILETRUNCATESIZE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOGFILE_TRUNCATE_SIZE,    m_lLogFileTruncateSize)     && fRet;
    }
//  if ( m_bvChangedFields & BitMask(ID_LOGMETHOD) ) 
//  {
//      fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogMethod)       && fRet;
//  }
    if ( m_bvChangedFields & BitMask(ID_LOGTYPE) ) 
    {
        fRet = StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,     m_lLogType)     && fRet;
    }


    if ( m_bvChangedFields & BitMask(ID_AUTOSTART) ) {
        fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,     m_fAutoStart );
    }

    if ( m_bvChangedFields & BitMask(ID_COMMENT) ) {
        fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_COMMENT,       m_strComment );
    }

#if 0
//  if ( m_bvChangedFields & CHNG_ADMINACL ) {
        if ( pSD ) {
            hr = metabase.SetData ( _T(""), MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA, pSD, cbSD, METADATA_INHERIT | METADATA_REFERENCE);
            BAIL_ON_FAILURE(hr);
        }
        else {
            pMetabase->DeleteData ( metabase.QueryHandle(), _T(""), MD_ADMIN_ACL, BINARY_METADATA );
        }
//  }
#endif

//  if ( m_bvChangedFields & CHNG_IPACCESS ) {
        hr = m_pPrivateIpAccess->SendToMetabase ( &metabase );
        BAIL_ON_FAILURE(hr);
//  }

    // Save the data to the metabase:
    // hr = metabase.Close();
    // BAIL_ON_FAILURE(hr);
    metabase.Close();

    hr = pMetabase->SaveData ();
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed SaveData call (%x)", hr );
    }

    // Save the last changed time for this key:
    m_ftLastChanged.dwHighDateTime  = 0;
    m_ftLastChanged.dwLowDateTime   = 0;

    hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
    if ( FAILED (hr) ) {
        ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
        // Ignore this error.
        hr = NOERROR;
    }

Exit:
    delete (char*) pSD;

    if( SUCCEEDED(hr) && !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error ( GetLastError () );
    }

    TraceFunctLeave ();
    return hr;

    // CMetabaseKey automatically closes its handle
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::ValidateStrings
//
//  Description:
//
//      Checks to make sure each string property is non-null.
//
//  Returns:
//
//      FALSE if any string property is NULL.
//
//--------------------------------------------------------------------

BOOL CSmtpAdminVirtualServer::ValidateStrings ( ) const
{
    TraceFunctEnter ( "CSmtpAdminVirtualServer::ValidateStrings" );

    // Check all property strings:
    // If any string is NULL, return FALSE:

    if ( 
        !m_strSmartHost ||
        !m_strPostmasterEmail ||
        !m_strPostmasterName ||
        !m_strDefaultDomain ||
        !m_strBadMailDir ||
        !m_strPickupDir ||
        !m_strQueueDir ||
        !m_strRoutingDLL ||
        !m_strLogFileDirectory
        ) {

        ErrorTrace ( (LPARAM) this, "String validation failed" );

        TraceFunctLeave ();
        return FALSE;
    }

    _ASSERT ( IS_VALID_STRING ( m_strSmartHost ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterEmail ) );
    _ASSERT ( IS_VALID_STRING ( m_strPostmasterName ) );

    _ASSERT ( IS_VALID_STRING ( m_strDefaultDomain ) );

    _ASSERT ( IS_VALID_STRING ( m_strBadMailDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strPickupDir ) );
    _ASSERT ( IS_VALID_STRING ( m_strQueueDir ) );

    _ASSERT ( IS_VALID_STRING ( m_strRoutingDLL ) );

    _ASSERT ( IS_VALID_STRING ( m_strLogFileDirectory ) );

    TraceFunctLeave ();
    return TRUE;
}

//$-------------------------------------------------------------------
//
//  CSmtpAdminVirtualServer::ValidateProperties
//
//  Description:
//
//      Checks to make sure all parameters are valid.
//
//  Parameters:
//
//
//  Returns:
//
//
//--------------------------------------------------------------------

BOOL CSmtpAdminVirtualServer::ValidateProperties ( ) const
{
    BOOL    fRet    = TRUE;
    
    _ASSERT ( ValidateStrings () );

/*
    fRet = fRet && PV_MinMax    ( m_lPort, MIN_PORT, MAX_PORT );
    fRet = fRet && PV_MinMax    ( m_lSSLPort, MIN_SSLPORT, MAX_SSLPORT );
    fRet = fRet && PV_MinMax    ( m_lOutboundPort, MIN_OUTBOND_PORT, MAX_OUTBOND_PORT );

    fRet = fRet && PV_MinMax    ( m_lMaxInConnection, MIN_MAX_IN_CONNECTION, MAX_MAX_IN_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lMaxOutConnection, MIN_MAX_OUT_CONNECTION, MAX_MAX_OUT_CONNECTION );
    fRet = fRet && PV_MinMax    ( m_lInConnectionTimeout, MIN_IN_CONNECTION_TIMEOUT, MAX_IN_CONNECTION_TIMEOUT );
    fRet = fRet && PV_MinMax    ( m_lOutConnectionTimeout, MIN_OUT_CONNECTION_TIMEOUT, MAX_OUT_CONNECTION_TIMEOUT );

    fRet = fRet && PV_MinMax    ( m_lMaxMessageSize, MIN_MAX_MESSAGE_SIZE, MAX_MAX_MESSAGE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxSessionSize, MIN_MAX_SESSION_SIZE, MAX_MAX_SESSION_SIZE );
    fRet = fRet && PV_MinMax    ( m_lMaxMessageRecipients, MIN_MAX_MESSAGE_RECIPIENTS, MAX_MAX_MESSAGE_RECIPIENTS );

    fRet = fRet && PV_MinMax    ( m_lLocalRetries, MIN_LOCAL_RETRIES, MAX_LOCAL_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lLocalRetryTime, MIN_LOCAL_RETRY_TIME, MAX_LOCAL_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetries, MIN_REMOTE_RETRIES, MAX_REMOTE_RETRIES );
    fRet = fRet && PV_MinMax    ( m_lRemoteRetryTime, MIN_REMOTE_RETRY_TIME, MAX_REMOTE_RETRY_TIME );
    fRet = fRet && PV_MinMax    ( m_lETRNDays, MIN_ETRN_DAYS, MAX_ETRN_DAYS );

//  fRet = fRet && PV_MinMax    ( m_lRTType, MIN_RTTYPE, MAX_RTTYPE );

    fRet = fRet && PV_MinMax    ( m_lLogFilePeriod, MIN_LOGFILE_PERIOD, MAX_LOGFILE_PERIOD );
    fRet = fRet && PV_MinMax    ( m_lLogFileTruncateSize, MIN_LOGFILE_TRUNCATE_SIZE, MAX_LOGFILE_TRUNCATE_SIZE );
    fRet = fRet && PV_MinMax    ( m_lLogMethod, MIN_LOG_METHOD, MAX_LOG_METHOD );
    fRet = fRet && PV_MinMax    ( m_lLogType, MIN_LOG_TYPE, MAX_LOG_TYPE );

    fRet = fRet && PV_Boolean   ( m_fEnableDNSLookup );
    fRet = fRet && PV_Boolean   ( m_fSendDNRToPostmaster );
    fRet = fRet && PV_Boolean   ( m_fSendBadmailToPostmaster );
    fRet = fRet && PV_Boolean   ( m_fAutoStart );
*/
    return fRet;
}

void CSmtpAdminVirtualServer::CorrectProperties ( )
{
    /*
    if ( m_strServer && !PV_MaxChars    ( m_strServer, MAXLEN_SERVER ) ) {
        m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
    }
    if ( !PV_MinMax ( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT ) ) {
        m_dwArticleTimeLimit    = DEFAULT_ARTICLETIMELIMIT;
    }
    if ( !PV_MinMax ( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION ) ) {
        m_dwHistoryExpiration   = DEFAULT_HISTORYEXPIRATION;
    }
    if ( !PV_Boolean    ( m_fHonorClientMsgIDs ) ) {
        m_fHonorClientMsgIDs    = !!m_fHonorClientMsgIDs;
    }
    if ( !PV_MaxChars   ( m_strSmtpServer, MAXLEN_SMTPSERVER ) ) {
        m_strSmtpServer[ MAXLEN_SMTPSERVER - 1 ] = NULL;
    }
    if ( !PV_Boolean    ( m_fAllowClientPosts ) ) {
        m_fAllowClientPosts = !!m_fAllowClientPosts;
    }
    if ( !PV_Boolean    ( m_fAllowFeedPosts ) ) {
        m_fAllowFeedPosts   = !!m_fAllowFeedPosts;
    }
    if ( !PV_Boolean    ( m_fAllowControlMsgs ) ) {
        m_fAllowControlMsgs = !!m_fAllowControlMsgs;
    }
    if ( !PV_MaxChars   ( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN ) ) {
        m_strDefaultModeratorDomain[ MAXLEN_DEFAULTMODERATORDOMAIN - 1] = NULL;
    }
    if ( !PV_MinMax ( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK ) ) {
        m_dwCommandLogMask  = DEFAULT_COMMANDLOGMASK;
    }
    if ( !PV_Boolean    ( m_fDisableNewnews ) ) {
        m_fDisableNewnews   = !!m_fDisableNewnews;
    }
    if ( !PV_MinMax ( m_dwExpireRunFrequency, MIN_EXPIRERUNFREQUENCY, MAX_EXPIRERUNFREQUENCY ) ) {
        m_dwExpireRunFrequency  = DEFAULT_EXPIRERUNFREQUENCY;
    }
    if ( !PV_MinMax ( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY ) ) {
        m_dwShutdownLatency     = DEFAULT_SHUTDOWNLATENCY;
    }
*/

    _ASSERT ( ValidateProperties (  ) );
}


HRESULT AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins )
{
    HRESULT         hr          = NOERROR;
    SAFEARRAY *     psaResult   = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cbAcl;
    long            cAdmins;
    long            i;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pAcl;
    BOOL fDaclPresent;
    BOOL fDaclDef;

    pSD = (PSECURITY_DESCRIPTOR)pSDRelative;
    if (pSD == NULL)
    {
        //
        // Empty...
        //
        return ERROR_SUCCESS;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        return GetLastError();
    }

    _VERIFY(GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pAcl, &fDaclDef));
    if (!fDaclPresent || pAcl == NULL)
    {
        return ERROR_SUCCESS;
    }

    if (!IsValidAcl(pAcl))
    {
        return GetLastError();
    }

    cAdmins = pAcl->AceCount;
    cbAcl   = pAcl->AclSize;

    rgsaBound[0].lLbound    = 0;
    rgsaBound[0].cElements  = cAdmins;
    psaResult = SafeArrayCreate ( VT_BSTR, 1, rgsaBound );

    if ( !psaResult ) {
        BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

    for ( i = 0; i < cAdmins; i++ ) {
        PVOID           pAce;
        PACE_HEADER     pAceHeader;
        PSID            pSID;

        if ( GetAce(pAcl, i, &pAce) ) {
            pAceHeader = (PACE_HEADER)pAce;

            if ( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ) {
                CComBSTR    str;

                pSID = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;

                hr = SidToString ( pSID, &str );
                BAIL_ON_FAILURE(hr);

                hr = SafeArrayPutElement ( psaResult, &i, (PVOID) str );
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    if ( *ppsaAdmins ) {
        SafeArrayDestroy ( *ppsaAdmins );
    }
    *ppsaAdmins = psaResult;

Exit:
    return hr;
}


PSID
GetOwnerSID()
/*++

Routine Description:

Arguments:

Return Value:

    Owner sid

--*/
{
    PSID pSID = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pSID))
    {
        _ASSERT( 0 );
        //TRACEEOLID("Unable to get primary SID " << ::GetLastError());
    }

    return pSID;
}


HRESULT AdministratorsToAcl ( 
    LPCTSTR     strServer,
    SAFEARRAY * psaAdmins, 
    PSECURITY_DESCRIPTOR* ppSD, 
    DWORD * pcbSD 
    )
{
    HRESULT     hr  = NOERROR;
    long        lBound;
    long        uBound;
    long        i;
    BOOL        fRet;
    DWORD       cbAcl;
    PACL        pAclResult  = NULL;
    PSID        pSID;

    *ppSD   = NULL;
    *pcbSD  = 0;

    if ( psaAdmins == NULL ) {
        lBound = 0;
        uBound = -1;
    }
    else {
        SafeArrayGetLBound ( psaAdmins, 1, &lBound );
        SafeArrayGetUBound ( psaAdmins, 1, &uBound );
    }

    // Do we have an array of Domain\Usernames?
    if ( lBound > uBound ) {
        // Nothing in the array, so the ACL is NULL.
        goto Exit;
    }

    //
    // Calculate ACL size:
    //
    cbAcl = sizeof (ACL);

    for ( i = lBound; i <= uBound ; i++ ) {
        CComBSTR    str;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );

        if ( SUCCEEDED(hr) && pSID) {
            cbAcl += GetLengthSid ( pSID );
            cbAcl += sizeof ( ACCESS_ALLOWED_ACE );
            cbAcl -= sizeof (DWORD);
            delete pSID;
        }
        hr = NOERROR;

    }

    pAclResult = (PACL) new char [ cbAcl ];
    if ( !pAclResult ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    fRet = InitializeAcl ( pAclResult, cbAcl, ACL_REVISION );
    _ASSERT ( fRet );
    if ( !fRet ) {
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
    }

    //
    //  Create ACL:
    //
    for ( i = lBound; i <= uBound; i++ ) {
        CComBSTR    str;
        PSID        pSID;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );
        if ( SUCCEEDED(hr) ) {
            fRet = AddAccessAllowedAce ( 
                pAclResult, 
                ACL_REVISION, 
                FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                pSID
                );

            delete pSID;
            if ( !fRet ) {
                BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
            }
        }
        hr = NOERROR;

    }

    //
    // Build the security descriptor
    //
    PSECURITY_DESCRIPTOR pSD;
    pSD = new char[SECURITY_DESCRIPTOR_MIN_LENGTH];
    
    if( NULL == pSD )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
        
    _VERIFY(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
    _VERIFY(SetSecurityDescriptorDacl(pSD, TRUE, pAclResult, FALSE));

    //
    // Set owner and primary group
    //
    pSID = GetOwnerSID();
    _ASSERT(pSID);
    _VERIFY(SetSecurityDescriptorOwner(pSD, pSID, TRUE));
    _VERIFY(SetSecurityDescriptorGroup(pSD, pSID, TRUE));

    //
    // Convert to self-relative
    //
    PSECURITY_DESCRIPTOR pSDSelfRelative;
    pSDSelfRelative = NULL;
    DWORD dwSize;
    dwSize = 0L;
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);
    pSDSelfRelative = new char[dwSize];
    
    if( NULL == pSDSelfRelative )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);

    //
    // Clean up
    //
    delete (char*)pSD;
    FreeSid( pSID );


    _ASSERT ( SUCCEEDED(hr) );
    *ppSD   = pSDSelfRelative;
    *pcbSD  = dwSize;

Exit:
    if ( FAILED(hr) ) {
        delete pAclResult;
    }
    return hr;
}

HRESULT SidToString ( PSID pSID, BSTR * pStr )
{
    HRESULT         hr              = NOERROR;
    BOOL            fLookup;
    SID_NAME_USE    SidToNameUse;
    WCHAR           wszUsername [ PATHLEN ];
    DWORD           cbUsername      = sizeof ( wszUsername );
    WCHAR           wszDomain [ PATHLEN ];
    DWORD           cbDomain        = sizeof ( wszDomain );
    WCHAR           wszResult [ 2 * PATHLEN + 2 ];

    fLookup = LookupAccountSid ( 
//      wszSearchDomain,
        NULL,
        pSID,
        wszUsername,
        &cbUsername,
        wszDomain,
        &cbDomain,
        &SidToNameUse
        );
        
    if ( !fLookup ) {
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT (GetLastError ()) );
    }

    wsprintf ( wszResult, _T("%s\\%s"), wszDomain, wszUsername );

    *pStr = ::SysAllocString ( wszResult );

Exit:
    if ( *pStr ) {
        return NOERROR;
    }
    else {
        return E_OUTOFMEMORY;
    }
}

//-------------------------------------------------------------------------
//  Description:
//      Returns the SID for a an account (given as a COMPUTER/USER)
//  Parameters:
//      strSystemName - Name of "computer" on which account is
//      str - Name of user account to look up
//      ppSID - Out parameter; This function allocates a SID for the
//          accountand returns a pointer to it .
//  Returns:
//      S_OK on success. Caller frees *ppSID using delete.
//      Error HRESULT otherwise. *ppSID will be NULL.
//-------------------------------------------------------------------------
HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID )
{
    HRESULT         hr  = NOERROR;
    BOOL            fLookup;
    WCHAR           wszRefDomain[PATHLEN];
    DWORD           cbRefDomain = sizeof ( wszRefDomain );
    DWORD           cbSid = 0;
    SID_NAME_USE    SidNameUse;

    *ppSID = NULL;

    if ( str[0] == '\\' ) {
        //
        //  Skip the initial \, this is for BUILTIN usernames:
        //

        str++;
    }

    _ASSERT ( str[0] != '\\' );

    fLookup = LookupAccountName (
        strSystemName,
        str,
        *ppSID,
        &cbSid,
        wszRefDomain,
        &cbRefDomain,
        &SidNameUse
        );

    // First lookup will fail, but the size will be right:
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        DWORD   dw;

        dw = GetLastError ();
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
    }

    *ppSID = (LPVOID) new char [ cbSid ];
    if ( !*ppSID ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    fLookup = LookupAccountName (
        strSystemName,
        str,
        *ppSID,
        &cbSid,
        wszRefDomain,
        &cbRefDomain,
        &SidNameUse
        );

    if ( !fLookup ) {
        DWORD   dw;

        dw = GetLastError ();
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
    }

Exit:
    if(FAILED(hr) && *ppSID != NULL) {
        delete (*ppSID);
        *ppSID = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqueue.inc ===
# Global settings for SMTP AQueue subprojects

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

!IFNDEF SMTPDIR
SMTPDIR=smtp
!ENDIF

!INCLUDE $(IISBASEDIR)\svcs\$(SMTPDIR)\smtp.inc

STAXAQUEUE=$(STAXSMTP)\aqueue

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\webhelp.cpp ===
// server.cpp : Implementation of CWebAdminHelper

#include "stdafx.h"
#include "smtpadm.h"
#include "webhelp.h"
#include "webhlpr.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.WebAdminHelper.1")
#define THIS_FILE_IID               IID_IWebAdminHelper




/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWebAdminHelper::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IWebAdminHelper,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

CWebAdminHelper::CWebAdminHelper ()
{
    m_hSearchResults    = NULL;

    InitAsyncTrace ( );
}

CWebAdminHelper::~CWebAdminHelper ()
{
    TermAsyncTrace ( );
}

STDMETHODIMP
CWebAdminHelper::EnumerateTrustedDomains (
    BSTR            strServer,
    SAFEARRAY **    ppsaDomains
    )
{
    HRESULT         hr;
    LPWSTR          mszDomains  = NULL;
    SAFEARRAY *     psaResult   = NULL;
    LPWSTR          wszCurrent;
    LPWSTR          wszLocalDomain  = NULL;
    long            cDomains;
    SAFEARRAYBOUND  rgsaBound[1];
    long            i;
    CComVariant     varLocalMachine;

    *ppsaDomains = NULL;

    hr = ::EnumerateTrustedDomains ( strServer, &mszDomains );
    BAIL_ON_FAILURE(hr);

    //
    //  Count the domains:
    //
    cDomains    = 0;    // Always count the local machine
    wszCurrent  = mszDomains;
    while ( wszCurrent && *wszCurrent ) {
        cDomains++;
        wszCurrent += lstrlen ( wszCurrent ) + 1;
    }

    _ASSERT ( cDomains > 0 );

    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = cDomains;

    psaResult = SafeArrayCreate ( VT_VARIANT, 1, rgsaBound );
    if ( !psaResult ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

#if 0
    //
    //  Add the local machine first:
    //

    wszLocalDomain = new WCHAR [ lstrlen ( _T("\\\\") ) + lstrlen ( strServer ) + 1 ];
    if ( wszLocalDomain == NULL ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    wsprintf ( wszLocalDomain, _T("\\\\%s"), strServer );
    StringToUpper ( wszLocalDomain );

    i               = 0;
    varLocalMachine = wszLocalDomain;
    hr = SafeArrayPutElement ( psaResult, &i, &varLocalMachine );
    BAIL_ON_FAILURE(hr);
#endif

    //
    //  Add the rest of the domains:
    //

    for (   wszCurrent = mszDomains, i = 0;
            wszCurrent && *wszCurrent && i < cDomains;
            wszCurrent += lstrlen ( wszCurrent ) + 1, i++ ) {
        CComVariant     var;

        var = wszCurrent;

        SafeArrayPutElement ( psaResult, &i, &var );
        BAIL_ON_FAILURE(hr);
    }

    *ppsaDomains = psaResult;

Exit:
    delete wszLocalDomain;

    if ( FAILED(hr) && psaResult ) {
        SafeArrayDestroy ( psaResult );
    }

    return hr;
}

STDMETHODIMP
CWebAdminHelper::GetPrimaryNTDomain (
    BSTR            strServer,
    BSTR *          pstrPrimaryDomain
    )
{
    HRESULT     hr                  = NOERROR;
    LPWSTR      wszPrimaryDomain    = NULL;

    *pstrPrimaryDomain = NULL;

    hr = GetPrimaryDomain ( strServer, &wszPrimaryDomain );
    BAIL_ON_FAILURE(hr);

    *pstrPrimaryDomain = ::SysAllocString ( wszPrimaryDomain );
    if ( !*pstrPrimaryDomain ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

Exit:
    if ( wszPrimaryDomain ) {
        delete [] wszPrimaryDomain;
    }
    return hr;
}

STDMETHODIMP
CWebAdminHelper::DoesNTAccountExist (
    BSTR strServer,
    BSTR strAccountName,
    VARIANT_BOOL * pbAccountExists
    )
{
    HRESULT     hr;
    BOOL        fExists = FALSE;

    hr = ::CheckNTAccount ( strServer, strAccountName, &fExists );
    BAIL_ON_FAILURE(hr);

Exit:
    *pbAccountExists = fExists ? VARIANT_TRUE : VARIANT_FALSE;
    return hr;
}

STDMETHODIMP
CWebAdminHelper::CreateNTAccount (
    BSTR strServer,
    BSTR strDomain,
    BSTR strUsername,
    BSTR strPassword
    )
{
    HRESULT         hr;

    hr = ::CreateNTAccount ( strServer, strDomain, strUsername, strPassword );

    return hr;
}

STDMETHODIMP
CWebAdminHelper::IsValidEmailAddress (
    BSTR strEmailAddress,
    VARIANT_BOOL * pbValidAddress
    )
{
    BOOL        fIsValid;

    fIsValid = ::IsValidEmailAddress ( strEmailAddress );

    *pbValidAddress = fIsValid ? VARIANT_TRUE : VARIANT_FALSE;
    return NOERROR;
}

STDMETHODIMP
CWebAdminHelper::ToSafeVariableName (
    BSTR strValue,
    BSTR * pstrSafeName
    )
{
    HRESULT     hr          = NOERROR;
    DWORD       cchRequired = 0;
    LPCWSTR     wszValue;
    LPWSTR      wszResult;
    BSTR        strResult   = NULL;

    *pstrSafeName = NULL;
    if ( strValue == NULL ) {
        goto Exit;
    }

    for ( wszValue = strValue, cchRequired = 0; *wszValue; wszValue++ ) {
        if ( iswalnum ( *wszValue ) ) {
            cchRequired++;
        }
        else {
            cchRequired += 7;
        }
    }

    strResult = ::SysAllocStringLen ( NULL, cchRequired );
    if ( !strResult ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    for ( wszValue = strValue, wszResult = strResult; *wszValue; wszValue++ ) {
        if ( iswalnum ( *wszValue ) && *wszValue != _T('_') ) {
            *wszResult++ = *wszValue;
        }
        else {
            int     cchCopied;

            cchCopied = wsprintf ( wszResult, _T("_%d_"), *wszValue );
            wszResult += cchCopied;
        }
    }
    *wszResult = NULL;

    *pstrSafeName = ::SysAllocString ( strResult );
    if ( !*pstrSafeName ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

Exit:
    if ( strResult ) {
        ::SysFreeString ( strResult );
    }
    return hr;
}

STDMETHODIMP
CWebAdminHelper::FromSafeVariableName (
    BSTR strSafeName,
    BSTR * pstrResult
    )
{
    HRESULT     hr          = NOERROR;
    BSTR        strResult   = NULL;
    LPCWSTR     wszValue;
    LPWSTR      wszResult;

    *pstrResult = NULL;
    if ( strSafeName == NULL ) {
        goto Exit;
    }

    strResult = ::SysAllocString ( strSafeName );
    if ( !strResult ) { 
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    for ( wszValue = strSafeName, wszResult = strResult; *wszValue; wszResult++ ) {
        if ( *wszValue != _T('_') ) {
            *wszResult = *wszValue++;
        }
        else {
            wszValue++;
            *wszResult = (WCHAR) _wtoi ( wszValue );
            wszValue = wcschr ( wszValue, _T('_') );
            _ASSERT ( wszValue != NULL );
            wszValue++;
        }
    }

    *wszResult = NULL;
    *pstrResult = ::SysAllocString ( strResult );
    if ( !*pstrResult ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

Exit:
    ::SysFreeString ( strResult );
    return hr;
}

STDMETHODIMP
CWebAdminHelper::AddToDL (
    IDispatch * pDispDL,
    BSTR strAdsPath
    )
{
    HRESULT             hr;
    CComPtr<IADsGroup>  pGroup;

    hr = pDispDL->QueryInterface ( IID_IADsGroup, (void **) &pGroup );
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

    hr = pGroup->Add ( strAdsPath );
    BAIL_ON_FAILURE(hr);

Exit:
    return hr;
}

STDMETHODIMP
CWebAdminHelper::RemoveFromDL (
    IDispatch * pDispDL,
    BSTR strAdsPath
    )
{
    HRESULT             hr;
    CComPtr<IADsGroup>  pGroup;

    hr = pDispDL->QueryInterface ( IID_IADsGroup, (void **) &pGroup );
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

    hr = pGroup->Remove ( strAdsPath );
    BAIL_ON_FAILURE(hr);

Exit:
    return hr;
}

STDMETHODIMP
CWebAdminHelper::ExecuteSearch (
    IDispatch * pDispRecipients,
    BSTR strQuery,
    long cMaxResultsHint
    )
{
    HRESULT     hr;
    LPWSTR      rgwszAttributes [] = {
        { L"ADsPath" },
        { L"objectClass" },
        { L"mail" },
        { L"cn" },
    };
    ADS_SEARCHPREF_INFO         rgSearchPrefs[3];
    DWORD                       cSearchPrefs = ARRAY_SIZE ( rgSearchPrefs );

    rgSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    rgSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    rgSearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    rgSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    rgSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    rgSearchPrefs[1].vValue.Integer = 100;
    rgSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
    rgSearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;
    rgSearchPrefs[2].vValue.Integer = cMaxResultsHint + 10;

    if ( cMaxResultsHint == -1 || cMaxResultsHint == 0 ) {
        cSearchPrefs--;
    }

    hr = TerminateSearch ();
    _ASSERT ( SUCCEEDED(hr) );

    m_pSrch.Release ();

    hr = pDispRecipients->QueryInterface ( IID_IDirectorySearch, (void **) &m_pSrch);
    _ASSERT ( SUCCEEDED(hr) );  // Did you pass in a searchable object?
    BAIL_ON_FAILURE(hr);

    hr = m_pSrch->SetSearchPreference (
        rgSearchPrefs,
        cSearchPrefs
        );
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

    hr = m_pSrch->ExecuteSearch (
        strQuery,
        rgwszAttributes,
        ARRAY_SIZE ( rgwszAttributes ),
        &m_hSearchResults
        );
    BAIL_ON_FAILURE(hr);

    _ASSERT ( m_pSrch && m_hSearchResults );

Exit:
    return hr;
}

#if 0

STDMETHODIMP
CWebAdminHelper::ExecuteSearch (
    IDispatch * pDispRecipients,
    BSTR strQuery,
    long cMaxResultsHint
    )
{
    HRESULT     hr;
    long        LBound          = 0;
    long        UBound          = -1;
    long        cAttributes     = 0;
    LPWSTR *    rgwszAttributes = NULL;
    long        iAttrib;
    long        i;

    hr = TerminateSearch ();
    _ASSERT ( SUCCEEDED(hr) );

    m_pSrch.Release ();

    hr = pDispRecipients->QueryInterface ( IID_IDirectorySearch, (void **) &m_pSrch);
    _ASSERT ( SUCCEEDED(hr) );  // Did you pass in a searchable object?
    BAIL_ON_FAILURE(hr);

    _ASSERT ( SafeArrayGetDim ( psaColumns ) == 1 );

    hr = SafeArrayGetLBound ( psaColumns, 1, &LBound );
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound ( psaColumns, 1, &UBound );
    _ASSERT ( SUCCEEDED(hr) );
    BAIL_ON_FAILURE(hr);

    cAttributes = UBound - LBound + 1;
    if ( cAttributes <= 0 ) {
        BAIL_WITH_FAILURE(hr,E_UNEXPECTED);
    }

    rgwszAttributes = new LPWSTR [ cAttributes ];
    if ( !rgwszAttributes ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    ZeroMemory ( rgwszAttributes, cAttributes * sizeof ( rgwszAttributes[0] ) );

    for ( iAttrib = 0, i = LBound; i <= UBound; i++, iAttrib++ ) {
        CComVariant     varElem;
        LPCWSTR         wszElem;

        hr = SafeArrayGetElement ( psaColumns, &i, &varElem );
        BAIL_ON_FAILURE(hr);

        hr = varElem.ChangeType ( VT_BSTR );
        BAIL_ON_FAILURE(hr);

        wszElem = V_BSTR ( &varElem );

        rgwszAttributes[i] = new WCHAR [ lstrlen ( wszElem ) + 1 ];
        if ( rgwszAttributes[i] == NULL ) {
            BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
        }
        lstrcpy ( rgwszAttributes[i], wszElem );
    }

    hr = m_pSrch->ExecuteSearch (
        strQuery,
        rgwszAttributes,
        cAttributes,
        &m_hSearchResults
        );
    BAIL_ON_FAILURE(hr);

    _ASSERT ( m_pSrch && m_hSearchResults );

Exit:
    for ( i = 0; rgwszAttributes && i < cAttributes; i++ ) {
        delete rgwszAttributes[i];
    }
    delete [] rgwszAttributes;

    return hr;
}

#endif

STDMETHODIMP
CWebAdminHelper::GetNextRow (
    VARIANT_BOOL * pbNextRow
    )
{
    HRESULT     hr;

    _ASSERT ( m_pSrch && m_hSearchResults );

    hr = m_pSrch->GetNextRow ( m_hSearchResults );
    *pbNextRow = (hr == S_OK) ? VARIANT_TRUE : VARIANT_FALSE;

    return hr;
}

STDMETHODIMP
CWebAdminHelper::GetColumn (
    BSTR strColName,
    BSTR * pstrColValue
    )
{
    HRESULT             hr;
    ADS_SEARCH_COLUMN   column;
    CComVariant         varColumn;

    _ASSERT ( m_pSrch && m_hSearchResults );

    *pstrColValue = NULL;

    hr = m_pSrch->GetColumn ( m_hSearchResults, strColName, &column );
    BAIL_ON_FAILURE(hr);

    varColumn = column.pADsValues[0].PrintableString;

    *pstrColValue = SysAllocString ( V_BSTR ( &varColumn ) );
    if ( !*pstrColValue ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

Exit:
    if ( column.pADsValues != NULL ) {
        HRESULT     hrCheck;

        hrCheck = m_pSrch->FreeColumn ( &column );
        _ASSERT ( SUCCEEDED(hrCheck) );
    }

    return hr;
}

STDMETHODIMP
CWebAdminHelper::TerminateSearch ( )
{
    if ( m_hSearchResults ) {
        _ASSERT ( m_pSrch );

        m_pSrch->CloseSearchHandle ( m_hSearchResults );
        m_hSearchResults = NULL;
    }

    m_pSrch.Release ();

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\webhelp.h ===
// expire.h : Declaration of the CWebAdminHelper


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CWebAdminHelper : 
	public CComDualImpl<IWebAdminHelper, &IID_IWebAdminHelper, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CWebAdminHelper,&CLSID_CWebAdminHelper>
{
public:
	CWebAdminHelper ();
	virtual ~CWebAdminHelper ();
BEGIN_COM_MAP(CWebAdminHelper)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IWebAdminHelper)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CWebAdminHelper) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CWebAdminHelper, _T("Smtpadm.WebAdminHelper.1"), _T("Smtpadm.WebAdminHelper"), IDS_SMTPADMIN_SERVICE_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWebAdminHelper
public:

    STDMETHODIMP EnumerateTrustedDomains ( BSTR strServer, SAFEARRAY ** ppsaDomains );

    STDMETHODIMP GetPrimaryNTDomain ( BSTR strServer, BSTR * pstrPrimaryDomain );

    STDMETHODIMP DoesNTAccountExist ( BSTR strServer, BSTR strAccountName, VARIANT_BOOL * pbAccountExists );

    STDMETHODIMP CreateNTAccount ( BSTR strServer, BSTR strDomain, BSTR strUsername, BSTR strPassword );

    STDMETHODIMP IsValidEmailAddress ( BSTR strEmailAddress, VARIANT_BOOL * pbValidAddress );

    STDMETHODIMP ToSafeVariableName ( BSTR strValue, BSTR * pstrSafeName );

    STDMETHODIMP FromSafeVariableName ( BSTR strSafeName, BSTR * pstrValue );

    STDMETHODIMP AddToDL ( IDispatch * pDispDL, BSTR strAdsPath );
    STDMETHODIMP RemoveFromDL ( IDispatch * pDispDL, BSTR strAdsPath );

    STDMETHODIMP ExecuteSearch ( IDispatch * pDispRecipients, BSTR strQuery, long cMaxResultsHint );

    STDMETHODIMP GetNextRow ( VARIANT_BOOL * pbNextRow );

    STDMETHODIMP GetColumn ( BSTR strColName, BSTR * pstrColValue );

    STDMETHODIMP TerminateSearch ( );

private:
    CComPtr<IDirectorySearch>      m_pSrch;
    ADS_SEARCH_HANDLE       m_hSearchResults;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqadmsvr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadmsvr.cpp
//
//  Description:  Implements the IAdvQueueAdmin interface for the CAQSvrInst
//      object.  Also contains implementations of helper functions and classes.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/30/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqadmsvr.h"
#include "mailadmq.h"
#include <intrnlqa_i.c>

#define QA_DMT_CONTEXT_SIG 'CDAQ'

//Used to check *client* supplied structures against versions.  RPC supplied
//structures are not checked.
inline BOOL fCheckCurrentVersion(DWORD dwVersion)
{
    return (((DWORD)CURRENT_QUEUE_ADMIN_VERSION) == dwVersion);
}

//---[ QueueAdminDNTIteratorContext ]------------------------------------------
//
//
//  Description: 
//      Context passed to QueueAdmin DMT iterator functions.
//  Hungarian: 
//      qadntc, pqadntc
//  
//-----------------------------------------------------------------------------
class QueueAdminDMTIteratorContext
{
public:
    QueueAdminDMTIteratorContext() 
    {
        ZeroMemory(this, sizeof(QueueAdminDMTIteratorContext));
        m_dwSignature = QA_DMT_CONTEXT_SIG;
    };
    DWORD                   m_dwSignature;
    DWORD                   m_cItemsToReturn;
    DWORD                   m_cItemsFound;
    HRESULT                 m_hrResult;
    QUEUELINK_ID           *m_rgLinkIDs;
    QUEUELINK_ID           *m_pCurrentLinkID;
    QueueAdminMapFn         m_pfn;
    CAQAdminMessageFilter  *m_paqmf;
    IQueueAdminMessageFilter *m_pIQueueAdminMessageFilter;
};


//---[ SanitizeCountAndVolume ]------------------------------------------------
//
//
//  Description: 
//      Make queue count and volume sutable for user consumption.  There are
//      intended timing windows where the internal versions of these counts
//      may drop to zero.  Rather than redesign this, we just display zero
//      to the admin.
//  Parameters:
//      IN OUT  pcCount     Count to check and update
//      IN OUT  puliVolume  Queue volume to check and update
//  Returns:
//      -
//  History:
//      1/28/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID SanitizeCountAndVolume(IN OUT DWORD *pcCount, 
                            IN OUT ULARGE_INTEGER *puliVolume)
{
    TraceFunctEnterEx(0, "SanitizeCountAndVolume");
    _ASSERT(pcCount);
    _ASSERT(puliVolume);

    //
    // If we are negative sanitize to size zero
    //
    if (*pcCount > 0xFFFFF000)
    {
        StateTrace(0, "Sanitizing msg count of %d", *pcCount);
        *pcCount = 0;
        puliVolume->QuadPart = 0;
    }
    TraceFunctLeave();
}

//---[ IterateDMTAndGetLinkIDs ]------------------------------------------------
//
//
//  Description: 
//      Iterator function used to walk the DMT and generate the perf counters
//      we are interested in.
//  Parameters:
//          IN  pvContext   - pointer to QueueAdminDMTIteratorContext
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      12/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID IterateDMTAndGetLinkIDs(PVOID pvContext, PVOID pvData, 
                             BOOL fWildcard, BOOL *pfContinue, 
                             BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) NULL, "IterateDMTAndGetLinkIDs");
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    QueueAdminDMTIteratorContext *paqdntc = (QueueAdminDMTIteratorContext *)pvContext;
    CLinkMsgQueue *plmq = NULL;
    CDomainEntryLinkIterator delit;
    HRESULT hr = S_OK;

    _ASSERT(pvContext);
    _ASSERT(pvData);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);

    *pfContinue = TRUE;
    *pfDelete = FALSE;

    //Iterate of all links for this domain entry
    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, 
            "Unable to enumerate domain entry for link IDs - 0x%08X", hr);
        goto Exit;
    }

    do
    {
        plmq = delit.plmqGetNextLinkMsgQueue(plmq);
        if (!plmq)
            break;

        //See if we are running out of room to return data
        if (paqdntc->m_cItemsToReturn <= paqdntc->m_cItemsFound)
        {
            paqdntc->m_hrResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        //Have link fill out link info struct
        paqdntc->m_hrResult = plmq->HrGetLinkID(paqdntc->m_pCurrentLinkID);
        if (FAILED(paqdntc->m_hrResult))
            goto Exit;


        //Point to next info in array
        paqdntc->m_pCurrentLinkID++;
        paqdntc->m_cItemsFound++;

    } while (plmq);

  Exit:

    if (plmq)
        plmq->Release();

    //If we have encountered a failure... do not continue
    if (FAILED(paqdntc->m_hrResult))
        *pfContinue = FALSE;

    TraceFunctLeave();
}

//---[ IterateDMTAndApplyQueueAdminFunction ]----------------------------------
//
//
//  Description: 
//      Iterator function used to walk the DMT and generate the perf counters
//      we are interested in.
//  Parameters:
//          IN  pvContext   - pointer to QueueAdminDMTIteratorContext
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      12/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID IterateDMTAndApplyQueueAdminFunction(PVOID pvContext, PVOID pvData, 
                             BOOL fWildcard, BOOL *pfContinue, 
                             BOOL *pfDelete)
{
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    QueueAdminDMTIteratorContext *paqdntc = (QueueAdminDMTIteratorContext *)pvContext;
    CDestMsgQueue *pdmq = NULL;
    HRESULT hr = S_OK;
    CDomainEntryQueueIterator deqit;

    _ASSERT(pvContext);
    _ASSERT(pvData);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(paqdntc->m_paqmf);
    _ASSERT(paqdntc->m_pIQueueAdminMessageFilter);

    *pfContinue = TRUE;
    *pfDelete = FALSE;

   
    //Iterate of all links for this domain entry
    hr = deqit.HrInitialize(pdentry);
    if (FAILED(hr))
        return;

    do
    {
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);
        if (!pdmq)
            break;

        paqdntc->m_hrResult = pdmq->HrApplyQueueAdminFunction(
                                        paqdntc->m_pIQueueAdminMessageFilter);

        paqdntc->m_cItemsFound++;

    } while (pdmq && SUCCEEDED(paqdntc->m_hrResult));

    if (pdmq)
        pdmq->Release();

    //If we have encountered a failure... do not continue
    if (FAILED(paqdntc->m_hrResult))
        *pfContinue = FALSE;

}


//---[ QueueAdminApplyActionToMessages ]---------------------------------------
//
//
//  Description: 
//      FifoQ map function that is used to apply actions to messages.
//  Parameters:
//      IN  pmsgref     ptr to data on queue
//      IN  pvContext   CAQAdminMessageFilter used
//      OUT pfContinue  TRUE if we should continue
//      OUT pfDelete    TRUE if item should be deleted
//  Returns:
//      S_OK on sucess
//  History:
//      12/7/98 - MikeSwa Created 
//      2/21/99 - MikeSwa Updated to support new IQueueAdmin* interfaces
//
//-----------------------------------------------------------------------------
HRESULT QueueAdminApplyActionToMessages(IN CMsgRef *pmsgref, IN PVOID pvContext,
                                 OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    _ASSERT(pmsgref);
    _ASSERT(pvContext);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);

    IQueueAdminMessageFilter *pIQueueAdminMessageFilter = 
                                (IQueueAdminMessageFilter *) pvContext;
    HRESULT hr = S_OK;
    IUnknown *pIUnknownMsg = NULL;

    hr = pmsgref->QueryInterface(IID_IUnknown, (void **) &pIUnknownMsg);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IUnknown failed");
    if (FAILED(hr))
    {
        *pfContinue = FALSE;
        goto Exit;
    }

    hr = pIQueueAdminMessageFilter->HrProcessMessage(pIUnknownMsg, 
                                        pfContinue, pfDelete);

    if (FAILED(hr))
    {
        *pfContinue = FALSE;
        goto Exit;
    }

  Exit:

    if (pIUnknownMsg)
        pIUnknownMsg->Release();

    return hr;
}

//---[ CAQAdminMessageFilter::HrProcessMessage ]-------------------------------
//
//
//  Description: 
//      Processes a single message during an iterator funtion
//  Parameters:
//      IN  pIUnknownMsg        IUnknown ptr for message
//      OUT pfContinue          TRUE if iterator should continue
//      OUT pfDelete            TRUE if iterator should delete from the queue
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrProcessMessage(
            IUnknown *pIUnknownMsg,
            BOOL     *pfContinue,
            BOOL     *pfDelete)
{
    TraceFunctEnterEx((LPARAM) this, "CAQAdminMessageFilter::HrProcessMessage");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(pIUnknownMsg);
    _ASSERT(m_pIQueueAdminAction);

    if (!pfContinue || !pfDelete || !pIUnknownMsg)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (!m_pIQueueAdminAction)
    {
        hr = E_FAIL;
        goto Exit;
    }

    *pfContinue = TRUE;
    *pfDelete = FALSE;

    if (fFoundEnoughMsgs())
    {
        *pfContinue = FALSE;
        goto Exit;
    }

    //Check and see if we should skip this message (paging functionality)
    if ((AQ_MSG_FILTER_ENUMERATION & m_dwFilterFlags) && fSkipMsg())
        goto Exit;

    //Get CMsgRef "interface"
    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    _ASSERT(SUCCEEDED(hr) && "Unable to QI for msgref");
    if (FAILED(hr))
        goto Exit;

    //Check and see if message matches the filter
    if (pmsgref->fMatchesQueueAdminFilter((CAQAdminMessageFilter *) this))
    {
        if (AQ_MSG_FILTER_ACTION & m_dwFilterFlags)
        {
            //Apply action & say that we found another that matches filter
            hr = m_pIQueueAdminAction->HrApplyActionToMessage(pIUnknownMsg, 
                                                            m_dwMessageAction,
                                                            m_pvUserContext,
                                                            pfDelete);
            if (FAILED(hr))
                goto Exit;
        }
        else if (AQ_MSG_FILTER_ENUMERATION & m_dwFilterFlags)
        {
            //$$TODO - Handle slightly more complex filters like
            // - N largest
            // - N oldest
            //that may require matching, sorting, and throwing away previous matches.

            if (pmfGetMsgInfo())
                hr = pmsgref->HrGetQueueAdminMsgInfo(pmfGetMsgInfo());
        
        }
        else
            _ASSERT(0 && "Unknown message enumeration");

        //Mark as found and see if we should continue
        if (SUCCEEDED(hr) && fFoundMsg())
            *pfContinue = FALSE;

    }
  
  Exit:

    if (pmsgref)
        pmsgref->Release();

    //See if backing store for message has been deleted
    if (AQUEUE_E_MESSAGE_HANDLED == hr)
    {
        DebugTrace((LPARAM) this, "Found handled message in queue enumeration");        
        hr = S_OK; //do not fail out of enumeration for a handled message
    }
    TraceFunctLeave();
    return hr;
}


//---[ CAQAdminMessageFilter::HrSetQueueAdminAction ]--------------------------
//
//
//  Description: 
//      Sets the IQueueAdminAction interface for filter
//  Parameters:
//      IN  pIQueueAdminAction        Interface for filter
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrSetQueueAdminAction(
            IQueueAdminAction *pIQueueAdminAction)
{
    _ASSERT(pIQueueAdminAction);

    if (!pIQueueAdminAction)
        return E_POINTER;

    if (m_pIQueueAdminAction)
        m_pIQueueAdminAction->Release();

    m_pIQueueAdminAction = pIQueueAdminAction;
    m_pIQueueAdminAction->AddRef();

    return S_OK;
}

//---[ CAQAdminMessageFilter::HrSetCurrentUserContext ]-------------------------
//
//
//  Description: 
//      Sets a context that is distinct from the pIQueueAdminAction interface
//      and is passed to the IQueueAdminAction interface.  This can be used 
//      by a IQueueAdminAction interface to allow per-session state so 
//      multiple threads can act on a single IQueueAdminAction.
//
//      The actual content of the context is left to the implementation of 
//      IQueueAdminAction.
//  Parameters:
//      IN  pvContext       The context passed in
//  Returns:
//      S_OK always
//  History:
//      4/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrSetCurrentUserContext(
            PVOID	pvContext)
{
    m_pvUserContext = pvContext;
    return S_OK;
};

//---[ CAQAdminMessageFilter::HrGetCurrentUserContext ]-------------------------
//
//
//  Description: 
//      Returns the context previously set by HrSetCurrentUserContext
//  Parameters:
//      OUT  ppvContext       The context previously set
//  Returns:
//      S_OK if ppvContext is non-NULL
//      E_POINTER if ppvContext is NULL
//  History:
//      4/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::HrGetCurrentUserContext(
            PVOID	*ppvContext)
{

    if (!ppvContext)
        return E_POINTER;

    *ppvContext = m_pvUserContext;
    return S_OK;
};

//---[ CAQAdminMessageFilter::QueryInterface ]--------------------------------
//
//
//  Description: 
//      QueryInterface for CDestMsgQueue that supports:
//          - IQueueAdminMessageFilter
//          - IUnknown
//  Parameters:
//
//  Returns:
//
//  History:
//      2/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQAdminMessageFilter::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminMessageFilter *>(this);
    }
    else if (IID_IQueueAdminMessageFilter == riid)
    {
        *ppvObj = static_cast<IQueueAdminMessageFilter *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}


//---[ HrLinkFromLinkID ]------------------------------------------------------
//
//
//  Description: 
//      Utility function used to get the IQueueAdminLink for a giben QUEUELINK_ID
//  Parameters:
//      IN  pdmq        CDomainMappingTable for this virtual server instance
//      IN  pqlLinkID   QUEUELINK_ID for link we are trying to find
//      OUT pIQueueAdminLink link interface returned
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pqlLinkID is invalid
//      Error codes from HrGetDomainEntry and HrGetLinkMsgQueue on failure
//  History:
//      12/4/98 - MikeSwa Created 
//      2/23/99 - MikeSwa Updated for IQueueAdmin* interfaces
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrLinkFromLinkID(QUEUELINK_ID *pqlLinkID,
                         IQueueAdminLink **ppIQueueAdminLink)
{
    _ASSERT(pqlLinkID);
    _ASSERT(ppIQueueAdminLink);
    _ASSERT(QLT_LINK == pqlLinkID->qltType);
    _ASSERT(pqlLinkID->szName);

    HRESULT hr = S_OK;
    LPSTR   szDomain = NULL;
    DWORD   cbDomain = 0;
    CDomainEntry *pdentry = NULL;
    CLinkMsgQueue *plmq = NULL;
    CMailMsgAdminQueue *pmmaq = NULL;

    CAQScheduleID aqsched(pqlLinkID->uuid, pqlLinkID->dwId);
    BOOL flinkmatched = FALSE;

    *ppIQueueAdminLink = NULL;

    if ((QLT_LINK != pqlLinkID->qltType) || !pqlLinkID->szName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    szDomain = szUnicodeToAscii(pqlLinkID->szName);
    if (!szDomain)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Get the domain entry that we are interesting in
    cbDomain = lstrlen(szDomain);
    hr = m_dmt.HrGetDomainEntry(cbDomain, szDomain, 
                                &pdentry);
    if (SUCCEEDED(hr))
    {
        //Search domain entry to link with corresponding router id/schedule id
        hr = pdentry->HrGetLinkMsgQueue(&aqsched, &plmq);

        if (FAILED(hr))
            goto Exit;

        flinkmatched = TRUE;    //found a link for this domain
    }
    else
        flinkmatched = FALSE;
    
    //Try special links
    //check local link
    if (!flinkmatched)
    {
        if(plmq = m_dmt.plmqGetLocalLink())
        {
            if (plmq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
             }
             else
            {
                flinkmatched = FALSE;
                plmq->Release();
                plmq = NULL;
            }
        }
    }

    //unable to find local link, check currently unreachable link
    if (!flinkmatched)
    {
        if(plmq = m_dmt.plmqGetCurrentlyUnreachable())
        {
            if (plmq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
            }
            else
            {
                flinkmatched = FALSE;
                plmq->Release();
                plmq = NULL;
            }
        }
    }

    //unable to find currently unreachable link, check precat link
    if (!flinkmatched)
    {
        if(pmmaq =  m_dmt.pmmaqGetPreCategorized())
        {
            if (pmmaq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
            }
            else
            {
                flinkmatched = FALSE;
                pmmaq->Release();
                pmmaq = NULL;
            }
        }
    }

    //unable to find currently unreachable link, check prerouting link
    if (!flinkmatched)
    {
        if(pmmaq =  m_dmt.pmmaqGetPreRouting())
        {
            if (pmmaq->fMatchesID(pqlLinkID))
            {
                flinkmatched = TRUE;
                hr = S_OK;
            }
            else
            {
                flinkmatched = FALSE;
                pmmaq->Release();
                pmmaq = NULL;
            }
        }
    }

    //unable to find any matching link
    if (!flinkmatched)
        goto Exit;

    if (plmq)
    {
        hr = plmq->QueryInterface(IID_IQueueAdminLink, (void **)ppIQueueAdminLink);
    }
    else if (pmmaq)
    {
        hr = pmmaq->QueryInterface(IID_IQueueAdminLink, (void **)ppIQueueAdminLink);
    }

    _ASSERT(SUCCEEDED(hr) && "QI for LMQ->IQueueAdminLink failed!!!");

    if (FAILED(hr))
        goto Exit;
  
Exit:

    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    if (pmmaq)
        pmmaq->Release();

    if (szDomain)
        FreePv(szDomain);

    return hr;
}

//---[ HrQueueFromQueueID ]-----------------------------------------------------
//
//
//  Description: 
//      Queue Admin utility function that is used to look up a IQueueAdminQueue 
//      given a QUEUELINK_ID.
//  Parameters:
//      IN  pdmq              CDomainMappingTable for this virtual server instance
//      IN  pqlLinkID         QUEUELINK_ID for queue we are trying to find
//      OUT ppIQueueAdminQueue DestMsgQueue we are searching for
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pqlLinkID is invalid
//      Error codes from HrGetDomainEntry and HrGetLinkMsgQueue on failure
//  History:
//      12/7/98 - MikeSwa Created 
//      2/22/99 - MikeSwa Modified to return IQueueAdminQueue interface
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrQueueFromQueueID(QUEUELINK_ID *pqlQueueId,
                           IQueueAdminQueue **ppIQueueAdminQueue)
{
    _ASSERT(pqlQueueId);
    _ASSERT(ppIQueueAdminQueue);
    _ASSERT(QLT_QUEUE == pqlQueueId->qltType);
    _ASSERT(pqlQueueId->szName);

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    LPSTR   szDomain = NULL;
    DWORD   cbDomain = 0;
    CDomainEntry *pdentry = NULL;
    CDestMsgQueue *pdmq = NULL;
    CAQMessageType aqmt(pqlQueueId->uuid, pqlQueueId->dwId);
    IQueueAdminAction  *pIQueueAdminAction = NULL;

    *ppIQueueAdminQueue = NULL;
    if ((QLT_QUEUE != pqlQueueId->qltType) || !pqlQueueId->szName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    szDomain = szUnicodeToAscii(pqlQueueId->szName);
    if (!szDomain)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Get the domain entry that we are interested in
    cbDomain = lstrlen(szDomain);
    hr = m_dmt.HrGetDomainEntry(cbDomain, szDomain, 
                                &pdentry);
    if (FAILED(hr))
    {
        //try local queue
        if (FAILED(HrGetLocalQueueAdminQueue(ppIQueueAdminQueue)))
            goto Exit;

        _ASSERT(*ppIQueueAdminQueue);
        hrTmp = (*ppIQueueAdminQueue)->QueryInterface(IID_IQueueAdminAction,
                                              (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hrTmp) && "QI for IQueueAdminAction failed on local Queue!!");
        if (FAILED(hrTmp))
            goto Exit;

        _ASSERT(pIQueueAdminAction);
        if (pIQueueAdminAction->fMatchesID(pqlQueueId))
        {
            hr = S_OK;
            goto Exit;
        }
        
        //We don't have a match... bail... queue may have been deleted
        goto Exit;
    }

    //Search domain entry to link with corresponding router id/schedule id
    _ASSERT(pdentry);
    hr = pdentry->HrGetDestMsgQueue(&aqmt, &pdmq);

    if (FAILED(hr))
        goto Exit;

    _ASSERT(pdmq);
    hr = pdmq->QueryInterface(IID_IQueueAdminQueue, 
                             (void **) ppIQueueAdminQueue);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (FAILED(hr) && (*ppIQueueAdminQueue))
    {
        (*ppIQueueAdminQueue)->Release();
        *ppIQueueAdminQueue = NULL;
    }

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    if (pdentry)
        pdentry->Release();

    if (pdmq)
        pdmq->Release();

    if (szDomain)
        FreePv(szDomain);

    return hr;
}

//---[ CAQAdminMessageFilter::~CAQAdminMessageFilter ]-------------------------
//
//
//  Description: 
//      Descructor for CAQAdminMessageFilter
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/7/99 - MikeSwa Moved from inline function
//
//-----------------------------------------------------------------------------
CAQAdminMessageFilter::~CAQAdminMessageFilter()
{
	if (m_pIQueueAdminAction)
	    m_pIQueueAdminAction->Release();

    if (m_szMessageId)
        FreePv(m_szMessageId);

    if (m_szMessageSender)
        FreePv(m_szMessageSender);

    if (m_szMessageRecipient)
        FreePv(m_szMessageRecipient);

}

//---[ CAQAdminMessageFilter::InitFromMsgFilter ]------------------------------
//
//
//  Description: 
//      Initializes a CAQAdminMessageFilter from a MESSAGE_FILTER structure.
//  Parameters:
//      IN pmf      Ptr to MESSAGE_FILTER to initialize from
//  Returns:
//      -
//  History:  
//      12/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::InitFromMsgFilter(PMESSAGE_FILTER pmf)
{
    _ASSERT(pmf);

    if (pmf->fFlags & MF_MESSAGEID)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_MESSAGEID;
        m_szMessageId = szUnicodeToAscii(pmf->szMessageId);
        m_dwMsgIdHash = dwQueueAdminHash(m_szMessageId);
    }

    if (pmf->fFlags & MF_SENDER)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_SENDER;
        m_szMessageSender = szUnicodeToAscii(pmf->szMessageSender);
    }

    if (pmf->fFlags & MF_RECIPIENT)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_RECIPIENT;
        m_szMessageRecipient = szUnicodeToAscii(pmf->szMessageRecipient);
    }

    //It doens not make sense to create a filter with a size of 0
    if ((pmf->fFlags & MF_SIZE) && pmf->dwLargerThanSize)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_LARGER_THAN;
        m_dwThresholdSize = pmf->dwLargerThanSize;
    }

    if (pmf->fFlags & MF_TIME)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_OLDER_THAN;
        SystemTimeToFileTime(&pmf->stOlderThan, &m_ftThresholdTime);
    }
    
    if (MF_FROZEN & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_FROZEN;

    if (MF_ALL & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_ALL;

    if (MF_INVERTSENSE & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_INVERTSENSE;

    if (MF_FAILED & pmf->fFlags)
        m_dwFilterFlags |= AQ_MSG_FILTER_FAILED;

    m_dwFilterFlags |= AQ_MSG_FILTER_ACTION;

}

//---[ CAQAdminMessageFilter::InitFromMsgEnumFilter ]--------------------------
//
//
//  Description: 
//      Initializes a CAQAdminMessageFilter from a MESSAGE_ENUM_FILTER struct.
//  Parameters:
//      IN pmef     Ptr to MESSAGE_ENUM_FILTER to initialize from
//  Returns:
//      -
//  History:  
//      12/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::InitFromMsgEnumFilter(PMESSAGE_ENUM_FILTER pemf)
{
    _ASSERT(pemf);

    //only one of MEF_FIRST_N_MESSAGES, MEF_N_LARGEST_MESSAGES, and 
    //MEF_N_OLDEST_MESSAGES make sense
    if (MEF_FIRST_N_MESSAGES & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_FIRST_N_MESSAGES;
    else if (MEF_N_LARGEST_MESSAGES & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_N_LARGEST_MESSAGES;
    else if (MEF_N_OLDEST_MESSAGES & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_N_OLDEST_MESSAGES;

    //Check how many messages we should skip (for "paged" results)
    m_cMessagesToSkip = pemf->cSkipMessages;
    
    if ((AQ_MSG_FILTER_FIRST_N_MESSAGES | 
         AQ_MSG_FILTER_N_LARGEST_MESSAGES |
         AQ_MSG_FILTER_N_OLDEST_MESSAGES) & m_dwFilterFlags)
    {
        m_cMessagesToFind = pemf->cMessages;
    }

    if (MEF_OLDER_THAN & pemf->mefType)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_OLDER_THAN;
        SystemTimeToFileTime(&pemf->stDate, &m_ftThresholdTime);
    }

    if (MEF_LARGER_THAN & pemf->mefType)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_LARGER_THAN;
        m_dwThresholdSize = pemf->cbSize;
    }

    if (pemf->mefType & MEF_SENDER)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_SENDER;
        m_szMessageSender = szUnicodeToAscii(pemf->szMessageSender);
    }

    if (pemf->mefType & MEF_RECIPIENT)
    {
        m_dwFilterFlags |= AQ_MSG_FILTER_RECIPIENT;
        m_szMessageRecipient = szUnicodeToAscii(pemf->szMessageRecipient);
    }

    if (MEF_FROZEN & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_FROZEN;

    if (MEF_ALL & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_ALL;

    if (MEF_INVERTSENSE & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_INVERTSENSE;

    if (MEF_FAILED & pemf->mefType)
        m_dwFilterFlags |= AQ_MSG_FILTER_FAILED;

    m_dwFilterFlags |= AQ_MSG_FILTER_ENUMERATION;

}

//---[ CAQAdminMessageFilter::SetSearchContext ]--------------------------------
//
//
//  Description: 
//      Sets the search context which describes how many results are needed, 
//      and where to store the results
//  Parameters:
//      IN  cMessagesToFind     Number of results there is room to store
//      IN  rgMsgInfo           Array of cMessagesToFind MESSAGE_INFO structs
//                              to store data
//  Returns:
//      -
//  History:
//      12/8/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::SetSearchContext(DWORD cMessagesToFind, 
                                             MESSAGE_INFO *rgMsgInfo) 
{
    if (!m_cMessagesToFind || (m_cMessagesToFind > cMessagesToFind))
        m_cMessagesToFind = cMessagesToFind;

    m_rgMsgInfo = rgMsgInfo;
    m_pCurrentMsgInfo = rgMsgInfo;
};

//---[ CAQAdminMessageFilter::SetMessageAction ]-------------------------------
//
//
//  Description: 
//      Sets the action to apply to messages 
//  Parameters:
//      IN  maMessageAction     
//  Returns:
//      -
//  History:
//      12/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQAdminMessageFilter::SetMessageAction(MESSAGE_ACTION maMessageAction)
{
    m_dwMessageAction = maMessageAction;
}

//---[ CAQAdminMessageFilter::fFoundEnoughMsgs ]-------------------------------
//
//
//  Description: 
//      Determines if we have found enough messages for this filter.
//  Parameters:
//      -
//  Returns:
//      TRUE if we have found enough messages to fill this filter
//      FALSE if we haven't
//  History:
//      12/8/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fFoundEnoughMsgs()
{
    //See if we are unlimited or if we've hit our limit
    if (!m_cMessagesToFind) //no limit
        return FALSE;
    else
        return (m_cMessagesFound >= m_cMessagesToFind);
};

//---[ CAQAdminMessageFilter::fFoundMsg ]--------------------------------------
//
//
//  Description: 
//      Used to by the message enumeration code to record finding a message,
//      so internal pointers and counters can be updated
//  Parameters:
//      -
//  Returns:
//      TRUE if we have found enough messages
//      FALSE if we need to find more messages
//  History:
//      12/8/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fFoundMsg() 
{
    m_cMessagesFound++;
    if (m_pCurrentMsgInfo)
        m_pCurrentMsgInfo++;
    return fFoundEnoughMsgs();
};


//---[ CAQAdminMessageFilter::fMatchesId ]-------------------------------------
//
//
//  Description: 
//      Returns TRUE if ID matches
//  Parameters:
//      szMessageId     String to check
//  Returns:
//      TRUE if match
//  History:
//      12/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesId(LPCSTR szMessageId)
{
    BOOL fStrCmp = FALSE;

    if (szMessageId && m_szMessageId)
        fStrCmp = (0 == lstrcmpi(szMessageId, m_szMessageId));
    else if (!szMessageId && !m_szMessageId)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesSender ]---------------------------------
//
//
//  Description: 
//      Checks if the sender of the message matches the sender of filter
//  Parameters:
//      szMessageSender     The 822 sender of the message
//  Returns:
//      TRUE on match
//  History:
//      12/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesSender(LPCSTR szMessageSender)
{
    BOOL fStrCmp = FALSE;

    if (szMessageSender && m_szMessageSender)
    {
        fStrCmp = CAddr::IsRecipientInRFC822AddressList(
                                                (LPSTR) szMessageSender, 
                                                (LPSTR) m_szMessageSender);
    }
    else if (!szMessageSender && !m_szMessageSender)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesRecipient ]-------------------------------
//
//
//  Description: 
//      Used to check if the messages recipients match the filters
//  Parameters:
//      szMessageRecipient      Recipient list to check
//  Returns:
//      TRUE if matches
//  History:
//      12/9/98 - MikeSwa Created 
//      2/17/99 - MikeSwa Updated to use smtpaddr lib
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesRecipient(LPCSTR szMessageRecipient)
{
    BOOL fStrCmp = FALSE;

    if (szMessageRecipient && m_szMessageRecipient)
    {
        fStrCmp = CAddr::IsRecipientInRFC822AddressList(
                                                (LPSTR) szMessageRecipient, 
                                                (LPSTR) m_szMessageRecipient);
    }
    else if (!szMessageRecipient && !m_szMessageRecipient)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesP1Recipient ]----------------------------
//
//
//  Description: 
//
//  Parameters:
//
//  Returns:
//
//  History:
//      2/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesP1Recipient(
                                      IMailMsgProperties *pIMailMsgProperties)
{
    BOOL fStrCmp = FALSE;

    if (pIMailMsgProperties && m_szMessageRecipient)
    {
        fStrCmp = fQueueAdminIsP1Recip(pIMailMsgProperties, 
                                       m_szMessageRecipient);
    }
    else if (!pIMailMsgProperties && !m_szMessageRecipient)
        fStrCmp = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fStrCmp = !fStrCmp;

    return fStrCmp;
}

//---[ CAQAdminMessageFilter::fMatchesSize ]-----------------------------------
//
//
//  Description: 
//      Used to check if the message size matches the filter
//  Parameters:
//      dwSize      Size of message to check
//  Returns:
//      TRUE if matches filter
//  History:
//      12/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesSize(DWORD dwSize)
{
    BOOL fMatch = FALSE;
    if (!(AQ_MSG_FILTER_LARGER_THAN & m_dwFilterFlags))
        fMatch = TRUE;
    else if (dwSize > m_dwThresholdSize)
        fMatch = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fMatch = !fMatch;

    return fMatch;
}

//---[ CAQAdminMessageFilter::fMatchesTime ]-----------------------------------
//
//
//  Description: 
//      Determines if the recieved time of this message matches the filter.
//  Parameters:
//      pftTime     Pointer to filetime structure.
//  Returns:
//      TRUE on success
//  History:
//      12/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQAdminMessageFilter::fMatchesTime(FILETIME *pftTime)
{
    BOOL fMatch = FALSE;

    if (!(AQ_MSG_FILTER_OLDER_THAN & m_dwFilterFlags))
        fMatch = TRUE;
    else if (0 > CompareFileTime(pftTime, &m_ftThresholdTime))
        fMatch = TRUE;

    if (AQ_MSG_FILTER_INVERTSENSE & m_dwFilterFlags)
        fMatch = !fMatch;

    return fMatch;
}

//---[ CAQSvrInst::ApplyActionToLinks ]----------------------------------------
//
//
//  Description: 
//      Used to start or stop all outgoing connections on the links.
//  Parameters:
//      laAction - describes what action to take on the links.
//                  LA_FREEZE     - Stop all outbound connections
//                  LA_THAW       - Restart after a previous LA_STOP 
//                  LA_INTERNAL   - checks state of links
//  Returns:
//      S_OK on success
//      S_FALSE on LA_INTERNAL and if links are frozen
//  History:
//      11/30/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ApplyActionToLinks(LINK_ACTION laAction) 
{
    TraceFunctEnter("CAQSvrInst::ApplyActionToLinks");
    HRESULT hr = S_OK;
    if (fTryShutdownLock())
    {
        if (m_pConnMgr)
        {
            switch(laAction)
            {
                case LA_FREEZE:
                    m_pConnMgr->QueueAdminStopConnections();
                    break;
                case LA_THAW:
                    m_pConnMgr->QueueAdminStartConnections();
                    break;
                case LA_INTERNAL: //use to query state
                    if (m_pConnMgr->fConnectionsStoppedByAdmin())
                        hr = S_FALSE;
                    break;
                default:
                    _ASSERT(0 && "Undefined LinkAction");
                    hr = E_INVALIDARG;
            }
        }
        ShutdownUnlock();
    }
    
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::ApplyActionToMessages ]-------------------------------------
//
//
//  Description: 
//      Applies a specified action to the set of messages described by the 
//      queueid and message filter
//  Parameters:
//      IN     pqlQueueLinkId   Struct that identifies Queue/Link of interest
//      IN     pmfMessageFilter Struct that describes the messages of interest
//      IN     maMessageAction  Action to take on message
//                  MA_DELETE           Delete and NDR message
//                  MA_DELETE_SILENT    Delete message without NDRing
//                  MA_FREEZE_GLOBAL    "Freeze" message and prevent delivery
//                  MA_THAW_GLOBAL      "Thaw" a previously frozen message
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      11/30/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ApplyActionToMessages(QUEUELINK_ID    *pqlQueueLinkId,
                                          MESSAGE_FILTER  *pmfMessageFilter,
                                          MESSAGE_ACTION  maMessageAction,
                                          DWORD           *pcMsgs)
{
    TraceFunctEnter("CAQSvrInst::ApplyActionToMessages");
    HRESULT hr = S_OK;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    IQueueAdminLink *pIQueueAdminLink = NULL;
    IQueueAdminAction *pIQueueAdminAction = NULL;
    IQueueAdminMessageFilter *pIQueueAdminMessageFilter = NULL;
    CAQAdminMessageFilter *paqmf = new CAQAdminMessageFilter();

    if (!paqmf)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pmfMessageFilter || !pcMsgs || 
        !fCheckCurrentVersion(pmfMessageFilter->dwVersion))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    

    paqmf->InitFromMsgFilter(pmfMessageFilter);
    paqmf->SetMessageAction(maMessageAction);

    hr = paqmf->QueryInterface(IID_IQueueAdminMessageFilter, 
                       (void **) &pIQueueAdminMessageFilter);

    _ASSERT(SUCCEEDED(hr) && "QI for IID_IQueueAdminMessageFilter failed!!!");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminMessageFilter);

    if (QLT_NONE == pqlQueueLinkId->qltType)
    {
        //This is a global action.. iterate over all queues
        QueueAdminDMTIteratorContext aqdntc;
        aqdntc.m_pfn = QueueAdminApplyActionToMessages;
        aqdntc.m_paqmf = paqmf;
        aqdntc.m_pIQueueAdminMessageFilter = pIQueueAdminMessageFilter;

        hr = m_dmt.HrIterateOverSubDomains(NULL, 
                    IterateDMTAndApplyQueueAdminFunction, &aqdntc);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                hr = S_OK;
                *pcMsgs = 0;
            }
            goto Exit;
        }
    }
    else if (QLT_LINK == pqlQueueLinkId->qltType)
    {
        //Apply action to link
        hr = HrLinkFromLinkID(pqlQueueLinkId, &pIQueueAdminLink);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                hr = S_OK;
                *pcMsgs = 0;
            }
            goto Exit;
        }

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminLink->QueryInterface(IID_IQueueAdminAction, 
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for LMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

        hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                        pIQueueAdminMessageFilter);
        if (FAILED(hr))
            goto Exit;

    }
    else if (QLT_QUEUE == pqlQueueLinkId->qltType)
    {
        //Apply action to queue
        hr = HrQueueFromQueueID(pqlQueueLinkId, &pIQueueAdminQueue);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                hr = S_OK;
                *pcMsgs = 0;
            }
            goto Exit;
        }

        _ASSERT(pIQueueAdminQueue);

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminQueue->QueryInterface(IID_IQueueAdminAction, 
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for DMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

        hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                        pIQueueAdminMessageFilter);

        if (FAILED(hr))
            goto Exit;

    }
    else
    {
        //Bogus parameter
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pcMsgs = paqmf->cMessagesFound();
  Exit:

    if (paqmf)
        paqmf->Release();

    if (pIQueueAdminMessageFilter)
        pIQueueAdminMessageFilter->Release();

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetQueueInfo ]----------------------------------------------
//
//
//  Description: 
//      Returns the relevant info for the specified queue 
//  Parameters:
//      IN     pqlQueueId       Struct that identifies Queue of interest
//      IN OUT pqiQueueInfo     Struct to dump info into
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      11/30/98 - MikeSwa Created 
//      2/22/99 - MikeSwa Modified to use IQueueAdminQueue interface
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::GetQueueInfo(QUEUELINK_ID    *pqlQueueId,
                                 QUEUE_INFO      *pqiQueueInfo)
{
    TraceFunctEnter("CAQSvrInst::GetQueueInfo");
    HRESULT hr = S_OK;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    GUID    guidRouter = GUID_NULL;
    DWORD   dwMsgType = 0;

    _ASSERT(pqlQueueId);
    _ASSERT(pqiQueueInfo);
    _ASSERT(pqlQueueId->szName);

    if (!pqiQueueInfo || !pqlQueueId || 
        (QLT_QUEUE != pqlQueueId->qltType) || !pqlQueueId->szName ||
        !fCheckCurrentVersion(pqiQueueInfo->dwVersion))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = HrQueueFromQueueID(pqlQueueId, &pIQueueAdminQueue);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminQueue);
    hr = pIQueueAdminQueue->HrGetQueueInfo(pqiQueueInfo);

    SanitizeCountAndVolume(&(pqiQueueInfo->cMessages),
                           &(pqiQueueInfo->cbQueueVolume));
  Exit:
    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetLinkInfo ]-----------------------------------------------
//
//
//  Description: 
//      Returns the relevant info for the specified link
//  Parameters:
//      IN     pqlLinkId        Struct that identifies link of interest
//      IN OUT pqiLinkInfo      Struct to dump info into
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG if bogus properties are submitted.
//  History:
//      11/30/98 - MikeSwa Created 
//      7/1/99 - MikeSwa Added LinkDiagnostic
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetLinkInfo(QUEUELINK_ID    *pqlLinkId,
                                     LINK_INFO       *pliLinkInfo,
                                     HRESULT         *phrLinkDiagnostic)
{
    TraceFunctEnter("CAQSvrInst::GetLinkInfo");
    HRESULT hr = S_OK;
    IQueueAdminLink *pIQueueAdminLink = NULL;
 
    if (!pliLinkInfo || !pqlLinkId || !phrLinkDiagnostic)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = HrLinkFromLinkID(pqlLinkId, &pIQueueAdminLink);
    if (FAILED(hr))
        goto Exit;

    hr = pIQueueAdminLink->HrGetLinkInfo(pliLinkInfo, phrLinkDiagnostic);

    SanitizeCountAndVolume(&(pliLinkInfo->cMessages),
                           &(pliLinkInfo->cbLinkVolume));
  Exit:
    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::SetLinkState ]-----------------------------------------------
//
//
//  Description: 
//      Used to mark a link as stopped/started by admin
//  Parameters:
//      IN     pqlLinkId       Struct that identifies link of interest
//      IN     la              describes action for link
//  Returns:
//      S_OK on success
//      E_INVALIDARG    if action is not supported
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      11/30/98 - MikeSwa Created 
//      2/22/99 - MikeSwa Modified to use IQueueAdminLink
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetLinkState(QUEUELINK_ID    *pqlLinkId,
                                      LINK_ACTION     la)
{
    TraceFunctEnter("CAQSvrInst::SetLinkInfo");
    HRESULT hr = S_OK;
    IQueueAdminLink *pIQueueAdminLink = NULL;
 
    if (!pqlLinkId)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = HrLinkFromLinkID(pqlLinkId, &pIQueueAdminLink);
    if (FAILED(hr))
        goto Exit;

    hr = pIQueueAdminLink->HrApplyActionToLink(la);
    if (FAILED(hr))
        goto Exit;

    //Try kicking the connection manager
    if (fTryShutdownLock())
    {
        if (m_pConnMgr)
            m_pConnMgr->KickConnections();
        ShutdownUnlock();
    }

  Exit:
    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetLinkIDs ]------------------------------------------------
//
//
//  Description: 
//      Returns a list all the link IDs on this virtual server
//  Parameters:
//      IN OUT pcLinks      Number of links found (sizeof array on IN)
//                          If value is 0, then returns total #
//      IN OUT rgLinks      Array of QUEUELINK_ID structs
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG for bad combinations of arguments
//  History:
//      11/30/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetLinkIDs(DWORD           *pcLinks,
                                    QUEUELINK_ID    *rgLinks)
{
    TraceFunctEnter("CAQSvrInst::GetLinkIDs");
    HRESULT hr = S_OK;
    QueueAdminDMTIteratorContext aqdmtc;
    CLinkMsgQueue *plmqLocal = NULL;
    CLinkMsgQueue *plmqCurrentlyUnreachable = NULL;
    CMailMsgAdminQueue *pmmaqPreCategorized = NULL;
    CMailMsgAdminQueue *pmmaqPreRouting = NULL;

    if (!pcLinks || (*pcLinks && !rgLinks))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!*pcLinks)
    {
        //Return total number of links if they request it
        //number of links +2 for precat and prerouting
        //note that this may be one more than the number 
        //of links actually returned in a subsequent call 
        //since currently  unreachable may or may not have 
        //queues on it and we do not return it if it does 
        //not have queues.

        *pcLinks = m_cCurrentRemoteNextHops+2;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }
    
    aqdmtc.m_cItemsToReturn = *pcLinks;
    aqdmtc.m_rgLinkIDs = rgLinks;
    aqdmtc.m_pCurrentLinkID = rgLinks;
    aqdmtc.m_cItemsFound = 0;

    //Get local Link
    plmqLocal = m_dmt.plmqGetLocalLink();
    if (plmqLocal)
    {
        hr = plmqLocal->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
        if (SUCCEEDED(hr))
        {
            aqdmtc.m_pCurrentLinkID++;
            aqdmtc.m_cItemsFound++;
        }
        plmqLocal->Release();
    }

    //Get currently unreachable link.
    plmqCurrentlyUnreachable = m_dmt.plmqGetCurrentlyUnreachable();
    if (plmqCurrentlyUnreachable)
    {
        //return this link only if there are queues in it
        if (plmqCurrentlyUnreachable->cGetNumQueues() > 0)
        {
            hr = plmqCurrentlyUnreachable->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
            if (SUCCEEDED(hr))
            {
                aqdmtc.m_pCurrentLinkID++;
                aqdmtc.m_cItemsFound++;
            }
        }
        plmqCurrentlyUnreachable->Release();
    }

    //Get precat queue
    pmmaqPreCategorized = m_dmt.pmmaqGetPreCategorized();
    if (pmmaqPreCategorized)
    {
        hr = pmmaqPreCategorized->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
        if (SUCCEEDED(hr))
        {
            aqdmtc.m_pCurrentLinkID++;
            aqdmtc.m_cItemsFound++;
        }
        pmmaqPreCategorized->Release();
    }

    //Get prerouting queue
    pmmaqPreRouting = m_dmt.pmmaqGetPreRouting();
    if (pmmaqPreRouting)
    {
        hr = pmmaqPreRouting->HrGetLinkID(aqdmtc.m_pCurrentLinkID);
        if (SUCCEEDED(hr))
        {
            aqdmtc.m_pCurrentLinkID++;
            aqdmtc.m_cItemsFound++;
        }
        pmmaqPreRouting->Release();
    }

    //Get links for remote domains.
    hr = m_dmt.HrIterateOverSubDomains(NULL, IterateDMTAndGetLinkIDs, 
                                       &aqdmtc);

    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
        {
            //If the call to get remote domains fails with ERROR_NO_SUCH_DOMAIN
            //we must return only the special links --- local, currently unreachable, 
            //precat and prerouting.

            hr = S_OK;
            *pcLinks = aqdmtc.m_cItemsFound;
        }
        goto Exit;
    }

    hr = aqdmtc.m_hrResult;

    if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        *pcLinks = m_cCurrentRemoteNextHops+2;  //+2 for precat, prerouting which are not
    else                                        //counted in m_cCurrentRemoteNextHops.
        *pcLinks = aqdmtc.m_cItemsFound;

  Exit:

    //make sure we don't return ERROR_INSUFFICIENT_BUFFER if there are no links
    if ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr) && !*pcLinks)
        hr = S_OK;

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetQueueIDs ]-----------------------------------------------
//
//
//  Description: 
//      Gets all the queue (DMQ) IDs associated with a given link
//  Parameters:
//      IN     pqlLinkId    ID of link to get queues for
//      IN OUT pcQueues     Sizeof array/ number of queues found
//      IN OUT rgQueues     Array to dump queue info into
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG for bad combinations of arguments
//  History:
//      11/30/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetQueueIDs(QUEUELINK_ID    *pqlLinkId,
                                     DWORD           *pcQueues,
                                     QUEUELINK_ID    *rgQueues)
{
    TraceFunctEnter("CAQSvrInst::GetQueueIDs");
    HRESULT hr = S_OK;
    IQueueAdminLink *pIQueueAdminLink = NULL;
    DWORD   cQueues = 0;

    //Verify args
    if (!pqlLinkId || !pcQueues || (*pcQueues && !rgQueues))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Verify QUEUELINK_ID identifying the link of interest
    if (!pqlLinkId->szName || (pqlLinkId->qltType != QLT_LINK))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    hr = HrLinkFromLinkID(pqlLinkId, &pIQueueAdminLink);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminLink);
    hr = pIQueueAdminLink->HrGetNumQueues(&cQueues);
    if (FAILED(hr))
        goto Exit;

    if ((cQueues > *pcQueues) || (!*pcQueues))
    {
        *pcQueues = cQueues;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    hr = pIQueueAdminLink->HrGetQueueIDs(pcQueues, rgQueues);
    if (FAILED(hr))
        goto Exit;

  Exit:
    //make sure we don't return ERROR_INSUFFICIENT_BUFFER if there are no queues
    if ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr) && !*pcQueues)
        hr = S_OK;

    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetMessageProperties ]--------------------------------------
//
//
//  Description: 
//      Gets the message info for messages described by the filter
//  Parameters:
//      IN     pqlQueueLinkId           Struct that identifies Queue/Link of interest
//      IN     pmfMessageEnumFilter     Filter that describes messages of interest
//      IN OUT pcMsgs                   sizeof array / number of messages found
//      IN OUT rgMsgs                   array of message info structures
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//      E_INVALIDARG if bogus args are passed in.
//  History:
//      11/30/98 - MikeSwa Created 
//      2/22/99 - MikeSwa Modified to use IQueueAdmin* interface
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetMessageProperties(QUEUELINK_ID        *pqlQueueLinkId,
                                         MESSAGE_ENUM_FILTER *pmfMessageEnumFilter,
                                         DWORD               *pcMsgs,
                                         MESSAGE_INFO        *rgMsgs)
{
    TraceFunctEnter("CAQSvrInst::GetMessageProperties");
    HRESULT hr = S_OK;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    IQueueAdminAction  *pIQueueAdminAction = NULL;
    IQueueAdminMessageFilter *pIQueueAdminMessageFilter = NULL;
    MESSAGE_INFO  *pMsgInfo = rgMsgs;
    DWORD          i = 0;
    CAQAdminMessageFilter *paqmf = new CAQAdminMessageFilter();

    if (!paqmf)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Do some parameter checking
    if (!pqlQueueLinkId || !pmfMessageEnumFilter || !pcMsgs || 
        !pqlQueueLinkId->szName || 
        !fCheckCurrentVersion(pmfMessageEnumFilter->dwVersion))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (*pcMsgs && !rgMsgs)
    {
        //If we are specifying messages, we should have space to return data
        hr = E_INVALIDARG;
        goto Exit;
    }

    _ASSERT(QLT_QUEUE == pqlQueueLinkId->qltType);
    if (QLT_QUEUE != pqlQueueLinkId->qltType)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    paqmf->InitFromMsgEnumFilter(pmfMessageEnumFilter);
    paqmf->SetSearchContext(*pcMsgs, rgMsgs);

    hr = HrQueueFromQueueID(pqlQueueLinkId, &pIQueueAdminQueue);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminQueue);
    hr = pIQueueAdminQueue->QueryInterface(IID_IQueueAdminAction, 
                             (void **) &pIQueueAdminAction);
    _ASSERT(SUCCEEDED(hr) && "QI for IID_IQueueAdminAction failed!!!");
    if (FAILED(hr))
        goto Exit;

    hr = paqmf->QueryInterface(IID_IQueueAdminMessageFilter, 
                             (void **) &pIQueueAdminMessageFilter);

    _ASSERT(SUCCEEDED(hr) && "QI for IID_IQueueAdminMessageFilter failed!!!");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIQueueAdminAction);
    hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                    pIQueueAdminMessageFilter);

    if (FAILED(hr))
        goto Exit;

    if (!*pcMsgs && paqmf->cMessagesFound())
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    *pcMsgs = paqmf->cMessagesFound();

  Exit:

    if (paqmf)
        paqmf->Release();

    if (pIQueueAdminMessageFilter)
        pIQueueAdminMessageFilter->Release();

    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::QuerySupportedActions ]-------------------------------------
//
//
//  Description: 
//      Returns the supported actions and filters for a given queue
//  Parameters:
//      IN  pqlQueueLinkId          The queue/link we are interested in
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK on success
//  History:
//      6/15/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::QuerySupportedActions(
                                QUEUELINK_ID        *pqlQueueLinkId,
                                DWORD               *pdwSupportedActions,
                                DWORD               *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::QuerySupportedActions");
    HRESULT hr = S_OK;
    IQueueAdminAction *pIQueueAdminAction = NULL;
    IQueueAdminQueue *pIQueueAdminQueue = NULL;
    IQueueAdminLink *pIQueueAdminLink = NULL;

    _ASSERT(pqlQueueLinkId);
    _ASSERT(pdwSupportedActions);
    _ASSERT(pdwSupportedFilterFlags);

    if (QLT_LINK == pqlQueueLinkId->qltType)
    {
        //Apply action to link
        hr = HrLinkFromLinkID(pqlQueueLinkId, &pIQueueAdminLink);
        if (FAILED(hr))
            goto Exit;

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminLink->QueryInterface(IID_IQueueAdminAction, 
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for LMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

    }
    else if (QLT_QUEUE == pqlQueueLinkId->qltType)
    {
        //Apply action to queue
        hr = HrQueueFromQueueID(pqlQueueLinkId, &pIQueueAdminQueue);
        if (FAILED(hr))
            goto Exit;

        _ASSERT(pIQueueAdminQueue);

        //Query Interface for IQueueAdminAction
        hr = pIQueueAdminQueue->QueryInterface(IID_IQueueAdminAction, 
                                  (void **) &pIQueueAdminAction);
        _ASSERT(SUCCEEDED(hr) && "QI failed for DMQ->IQueueAdminAction");
        if (FAILED(hr))
            goto Exit;

    }
   
    //
    //  If we do not find an action for this ID, then return the default
    //  implementation (most likely is a server level search)... 
    //  otherwise ask our action interface what is supported
    //
    if (!pIQueueAdminAction)
    {
        hr = QueryDefaultSupportedActions(pdwSupportedActions, 
                                          pdwSupportedFilterFlags);
    }
    else
    {
        hr = pIQueueAdminAction->QuerySupportedActions(
                                        pdwSupportedActions,
                                        pdwSupportedFilterFlags);
    }

  Exit:
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            hr = S_OK;  //eat this error

        *pdwSupportedActions = 0;
        *pdwSupportedFilterFlags = 0;
    }

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    if (pIQueueAdminLink)
        pIQueueAdminLink->Release();

    if (pIQueueAdminQueue)
        pIQueueAdminQueue->Release();

    TraceFunctLeave();
    return hr;
}

//---[ QueryDefaultSupportedActions ]------------------------------------------
//
//
//  Description: 
//      Returns the default supported actions.
//  Parameters:
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK always
//  History:
//      1/27/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT QueryDefaultSupportedActions(DWORD  *pdwSupportedActions,
                                     DWORD  *pdwSupportedFilterFlags)
{
    //Currently all of a single type of queue supports the same actions and 
    //filters.  The only special cases are the precat and prerouting queue
    *pdwSupportedActions =  MA_DELETE |\
                            MA_DELETE_SILENT |\
                            MA_FREEZE_GLOBAL |\
            		        MA_THAW_GLOBAL |\
                            MA_COUNT;

    *pdwSupportedFilterFlags =  MF_MESSAGEID |\
                                MF_SENDER |\
                                MF_RECIPIENT |\
                                MF_SIZE |\
                                MF_TIME |\
                                MF_FROZEN |\
                                MF_FAILED |\
                                MF_ALL |\
                                MF_INVERTSENSE;

    return S_OK;
}

//---[ CAQSvrInst::HrGetLocalQueueAdminQueue ]---------------------------------
//
//
//  Description: 
//      Returns an interface for the local queue.
//  Parameters:
//       ppIQueueAdminQueue     Interface returned
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetLocalQueueAdminQueue(
                                      IQueueAdminQueue **ppIQueueAdminQueue)
{
    return m_asyncqPreLocalDeliveryQueue.QueryInterface(IID_IQueueAdminQueue,
                                            (void **) ppIQueueAdminQueue);
}

//---[ HrQueueAdminGetStringProp ]---------------------------------------------
//
//
//  Description: 
//      Wrapper function to handle getting a string property for queue admin
//  Parameters:
//      IN     pIMailMsgProperties  Ptr to IMailMsgProperties interface
//      IN     dwPropID             PropID of interest
//      OUT    pszProp              String allocated for QueueAdmin
//      OUT    pcbProp              Size out param (including 
//                                      terminating NULL(s)).
//  Returns:
//      S_OK on success (even if property is not found)
//      E_OUTOFMEMORY if allocation fails.
//  History:
//      12/8/98 - MikeSwa Created 
//      2/9/99  - MikeSwa Added string size OUT param & changed code to use
//                buffer size returned by GetProperty.
//
//-----------------------------------------------------------------------------
HRESULT HrQueueAdminGetStringProp(IMailMsgProperties *pIMailMsgProperties,
                                DWORD dwPropID, LPSTR *pszProp, DWORD *pcbProp)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrQueueAdminGetStringProp");
    BYTE  pbBuffer[4];
    HRESULT hr = S_OK;
    DWORD   cbIntBuffSize = sizeof(pbBuffer);

    _ASSERT(pszProp);

    *pszProp = NULL;

    //Use GetProperty instead of GetStringA, because it returns the size as well
    hr = pIMailMsgProperties->GetProperty(dwPropID, sizeof(pbBuffer), 
                                          &cbIntBuffSize, pbBuffer);

    if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
        {
            hr = S_OK;
            goto Exit;
        }
        else if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {
            //Our stack buffer is not big enough (which we expected)... 
            //we will have to do a get property directory into out return buffer
            hr = S_OK; 
        }
        else
        {
            goto Exit;
        }
    }

    //Allocate enough space for our string plus an extra terminating \0, so
    //we can munge it into a multivalue prop if needed.
    *pszProp = (LPSTR) pvQueueAdminAlloc(cbIntBuffSize+sizeof(CHAR));
    if (!*pszProp)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Now get the property with our property-sized buffer
    hr = pIMailMsgProperties->GetProperty(dwPropID, cbIntBuffSize, &cbIntBuffSize, 
                                        (BYTE *) (*pszProp));

    //Set extra terminating NULL.
    (*pszProp)[cbIntBuffSize/sizeof(CHAR)] = '\0';

    //Return Property string size
    if (pcbProp)
        *pcbProp = cbIntBuffSize + sizeof(CHAR);

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ HrQueueAdminGetUnicodeStringProp ]--------------------------------------
//
//
//  Description: 
//      Wrapper function to handle getting a string property for queue admin
//  Parameters:
//      IN     pIMailMsgProperties  Ptr to IMailMsgProperties interface
//      IN     dwPropID             PropID of interest
//      OUT    pwszProp             UNICODE String allocated for QueueAdmin
//      OUT    pcbProp              Size out param (including 
//                                      terminating NULL(s)).
//  Returns:
//      S_OK on success (even if property is not found)
//      E_OUTOFMEMORY if allocation fails.
//  History:
//      12/8/98 - MikeSwa Created 
//      2/9/99  - MikeSwa Added string size OUT param & changed code to use
//                buffer size returned by GetProperty.
//
//-----------------------------------------------------------------------------
HRESULT HrQueueAdminGetUnicodeStringProp(
                             IMailMsgProperties *pIMailMsgProperties,
                             DWORD dwPropID, LPWSTR *pwszProp, DWORD *pcbProp)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrQueueAdminGetUnicodeStringProp");
    HRESULT hr = S_OK;
    LPSTR   szProp = NULL;

    _ASSERT(pwszProp);
    *pwszProp = NULL;

    hr = HrQueueAdminGetStringProp(pIMailMsgProperties, dwPropID, &szProp, 
                                   pcbProp);
    if (SUCCEEDED(hr) && szProp)
    {
        BOOL fUTF8 = (dwPropID == IMMPID_MP_RFC822_MSG_SUBJECT);
        *pwszProp = wszQueueAdminConvertToUnicode(szProp, 
                                                  pcbProp ? *pcbProp : 0,
                                                  fUTF8);
        QueueAdminFree(szProp);
        if (pcbProp)
            *pcbProp *= sizeof(WCHAR)/sizeof(CHAR);
    }

    TraceFunctLeave();
    return hr;
}

//---[ cGetNumRecipsFromRFC822 ]-----------------------------------------------
//
//
//  Description: 
//      Utility function that extracts the number of recipients from a RFC822
//      header.  Input values should be as returned by HrQueueAdminGetStringProp
//  Parameters:
//      IN  szHeader            String of header to parse (can be NULL)
//      IN  cbHeader            Size of string header to parse
//  Returns:
//      Number of recipients found in header
//  History:
//      12/8/98 - MikeSwa Created 
//      2/9/99  - MikeSwa Modified to handle all RFC822 address formats
//
//-----------------------------------------------------------------------------
DWORD cQueueAdminGetNumRecipsFromRFC822(LPSTR szHeader, DWORD cbHeader)
{
    //Call through to handy smtpaddr library
    return CAddr::GetRFC822AddressCount(szHeader);
}


//---[ QueueAdminGetRecipListFromP1IfNecessary ]-------------------------------
//
//
//  Description: 
//      Creates a list of recipients from the P1.
//
//      For M3, this will appear in the RFC822 To: list.  For Post M3, we will
//      create an additional field in MESSAGE_INFO for these
//  Parameters:
//      IN     pIMailMsgProperties
//      IN OUT pMsgInfo (modified following)
//                  cEnvRecipients
//                  cbEnvRecipients
//                  mszEnvRecipients
//      
//      The mszEnvRecipients field is a multi-string UNICODE buffer containing
//  a NULL-terminated string for each recipient.  The buffer itself is 
//  terminated by an additional NULL.  Each recipient string will be formatted
//  in the proxy address style format of 'addr-type ":" address'.  The 
//  addr-type should match DS proxy type (i.e. "SMTP" for SMTP).  The address 
//  should be returned in it's native format.
//
//  Returns:
//      -
//  History:
//      2/17/99 - MikeSwa Created 
//      6/10/99 - MikeSwa Modified - P1 recipeints are now always reported
//          as separate fields in the MESSAGE_INFO structure.
//
//-----------------------------------------------------------------------------
void QueueAdminGetRecipListFromP1IfNecessary(IMailMsgProperties *pIMailMsgProperties,
                                       MESSAGE_INFO *pMsgInfo)
{
    TraceFunctEnterEx((LPARAM) NULL, "QueueAdminGetRecipListFromP1IfNecessary");
    LPWSTR      wszRecipBuffer = NULL;
    LPWSTR      wszPrevPlace = NULL;
    LPWSTR      wszCurrentPlace = NULL;
    LPWSTR      wszTmpBuffer = NULL;
    CHAR        szPropBuffer[QUEUE_ADMIN_MAX_BUFFER_REQUIRED] = "";
    HRESULT     hr = S_OK;
    const WCHAR wszPrefix[]     = L"SMTP:";
    const WCHAR wszDelimiter[]  = L"";
    DWORD       cbPropSize = 0;
    DWORD       cbSpaceLeft = 0;
    DWORD       cWCharsWritten = 0;
    DWORD       cRecips = 0;
    DWORD       iCurrentRecip = 0;
    DWORD       cbBufferSize = sizeof(WCHAR)*QUEUE_ADMIN_MAX_BUFFER_REQUIRED;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;

    //Extra space required per-recipient
    const DWORD cbPrefixAndDelimiter = sizeof(wszPrefix) + 
                                       sizeof(wszDelimiter) - 
                                       sizeof(WCHAR);

    _ASSERT(pIMailMsgProperties);

    if (!pMsgInfo || !pIMailMsgProperties)
        return;

    wszRecipBuffer = (LPWSTR) pvQueueAdminAlloc(cbBufferSize);

    //Don't try to write prop if we couldn't allocate
    if (!wszRecipBuffer)
        goto Exit;

    cbSpaceLeft = cbBufferSize;
    wszCurrentPlace = wszRecipBuffer;

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients, 
                                            (void **) &pIMailMsgRecipients);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IMailMsgRecipients failed");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIMailMsgRecipients);
    hr = pIMailMsgRecipients->Count(&cRecips);
    if (FAILED(hr))
        goto Exit;

    if (!cRecips)
        goto Exit; 

    //Start string as double-terminated
    wcscpy(wszCurrentPlace, wszDelimiter);

    //Loop over recipients and dump them to string
    for (iCurrentRecip = 0; iCurrentRecip < cRecips; iCurrentRecip++)
    {
        cbPropSize = sizeof(szPropBuffer);
        hr = pIMailMsgRecipients->GetProperty(iCurrentRecip, 
                    IMMPID_RP_ADDRESS_SMTP, 
                    sizeof(szPropBuffer), &cbPropSize, (BYTE *) szPropBuffer);

        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
            {
                //If this recip is larger than QUEUE_ADMIN_MAX_BUFFER_REQUIRED
                //Go to the next one
                hr = S_OK;
                continue;
            }
            ErrorTrace((LPARAM) NULL, 
                "pIMailMsgRecipients->GetProperty failed with hr - 0x%08X", hr);
            goto Exit;
        }

        _ASSERT(cbPropSize); //This doesn't make sense.. GetProp should have failed
        if (!cbPropSize)
            continue;

        if ((cbSpaceLeft <= cbPrefixAndDelimiter) ||
            (cbPropSize*sizeof(WCHAR) > cbSpaceLeft - cbPrefixAndDelimiter))
        {
            //We do not have enough space left to process this recip
            //and include the prefix and terminating NULLs
            cbSpaceLeft += cbBufferSize;
            cbBufferSize += cbBufferSize;
            wszTmpBuffer = (LPWSTR) pvQueueAdminReAlloc(wszRecipBuffer, cbBufferSize);
            if (!wszTmpBuffer)
                goto Exit; //bail
            wszCurrentPlace = wszTmpBuffer + (wszCurrentPlace-wszRecipBuffer);
            wszRecipBuffer = wszTmpBuffer;
        }

        //Copy address type prefix
        wcscpy(wszCurrentPlace, wszPrefix);
        wszPrevPlace = wszCurrentPlace;
        wszCurrentPlace += (sizeof(wszPrefix)/sizeof(WCHAR) - 1);

        //We need to convert this to UNICODE in place
        cWCharsWritten = MultiByteToWideChar(CP_ACP,
                        0,
                        szPropBuffer,
                        -1,
                        wszCurrentPlace,
                        (cbSpaceLeft - sizeof(wszDelimiter))/sizeof(WCHAR));

        if (!cWCharsWritten)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            //If this failed because of the buffer size, then my calculations
            //were off.
            ASSERT (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr);
            ErrorTrace((LPARAM) NULL, 
                "MultiByteToWideChar failed with hr - 0x%08X", hr);
            wszCurrentPlace = wszPrevPlace;
            wcscpy(wszCurrentPlace, wszDelimiter); //backout prefix
            continue;
        }
        
        //Write double terminating NULL
        wszCurrentPlace += cWCharsWritten;
        
        wcscpy(wszCurrentPlace, wszDelimiter);

        //Set current place to the 2nd terminating NULL
        //If there are no more recips... we are already terminated... if
        //there are, they will overwrite the 2nd terminating NULL.
        _ASSERT(L'\0' == *wszCurrentPlace);
        _ASSERT(L'\0' == *(wszCurrentPlace-1));

        cbSpaceLeft -= (DWORD)((wszCurrentPlace-wszPrevPlace)*sizeof(WCHAR));
    }

  Exit:

    if (FAILED(hr) || !cRecips)
    {
        if (wszRecipBuffer)
            QueueAdminFree(wszRecipBuffer);
    }
    else
    {
        if (pMsgInfo)
        {
            _ASSERT(wszPrevPlace >= wszRecipBuffer);
            pMsgInfo->cEnvRecipients = cRecips;
            pMsgInfo->cbEnvRecipients = (DWORD) ((1+wszCurrentPlace-wszRecipBuffer)*sizeof(WCHAR));
            pMsgInfo->mszEnvRecipients = wszRecipBuffer;
        }
    }

    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    TraceFunctLeave();
}


//---[ fQueueAdminIsP1Recip ]--------------------------------------------------
//
//
//  Description: 
//      Determines if a given recipient is a P1 recipient.
//  Parameters:
//      IN  pIMailMsgProperties     Msg to check recips for
//      IN  szRecip                 Recipient to check for
//  Returns:
//      TRUE if the recipient is a P1 recipient for this message
//      FALSE if the recipient is not a P1 recipient for this message
//  History:
//      2/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL fQueueAdminIsP1Recip(IMailMsgProperties *pIMailMsgProperties,
                          LPCSTR szRecip)
{
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    HRESULT hr = S_OK;
    DWORD   cRecips = 0;
    BOOL    fFound = FALSE;
    LPSTR   szRecipBuffer = NULL;
    DWORD   cbRecipBuffer = 0;
    DWORD   cbProp = 0;
    DWORD   iCurrentRecip = 0;

    //$$REVIEW: This ideal way to do this would be to have mailmsg check
    //it's internal recipient hash tables.

    if (!szRecip || !pIMailMsgProperties)
        goto Exit;

    //cleanup leading whitespace from recipient
    while (*szRecip && isspace(*szRecip))
        szRecip++;

    if (!*szRecip)
        goto Exit;

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients, 
                                            (void **) &pIMailMsgRecipients);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IMailMsgRecipients failed");
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIMailMsgRecipients);
    hr = pIMailMsgRecipients->Count(&cRecips);
    if (FAILED(hr))
        goto Exit;

    if (!cRecips)
        goto Exit; 

    cbRecipBuffer = strlen(szRecip)*sizeof(CHAR) + sizeof(CHAR);
    szRecipBuffer = (LPSTR) pvMalloc(cbRecipBuffer);

    //Loop over recips and look for a match... this will be slooow 
    //(see comment above).
    for (iCurrentRecip = 0; iCurrentRecip < cRecips; iCurrentRecip++)
    {
        hr = pIMailMsgRecipients->GetProperty(iCurrentRecip, 
                    IMMPID_RP_ADDRESS_SMTP, 
                    cbRecipBuffer, &cbProp, (BYTE *) szRecipBuffer);

        if (FAILED(hr))
            continue;

        if (!lstrcmpi(szRecipBuffer, szRecip))
        {
            fFound = TRUE;
            goto Exit;
        }
    }

  Exit:
    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    if (szRecipBuffer)
        FreePv(szRecipBuffer);

    return fFound;
}


//---[ wszQueueAdminConvertToUnicode ]-----------------------------------------
//
//
//  Description: 
//      Allocates and "upgrades" string to UNICODE.  New String is Allocated
//      with pvQueueAdminAlloc, so it can be passed out the queue admin 
//      interface.
//  Parameters:
//      szSrc     Source string
//      cSrc      Strlen of sources string
//  Returns:
//      Pointer to UNICODE version of string (if successful)
//  History:
//      6/7/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
LPWSTR wszQueueAdminConvertToUnicode(LPSTR szSrc, DWORD cSrc, BOOL fUTF8)
{
    LPWSTR  wszDest = NULL;
    if (!szSrc)
        return NULL;

    if (!cSrc)
        cSrc = strlen(szSrc);

    wszDest = (LPWSTR) pvQueueAdminAlloc((cSrc+1)*sizeof(WCHAR));
    if (!wszDest)
        return NULL;

    _ASSERT('\0' == szSrc[cSrc]);
    MultiByteToWideChar(fUTF8 ? CP_UTF8 : CP_ACP,
                        0,
                        szSrc,
                        -1,
                        wszDest,
                        cSrc+1);

    return wszDest;
}

//---[ fBiStrcmpi ]------------------------------------------------------------
//
//
//  Description: 
//      Compares UNICODE to ASCII
//  Parameters:
//      IN  sz      ASCII string to compare
//      IN  wsz     
//  Returns:
//      TRUE if strings match
//      FALSE otherwise
//  History:
//      6/7/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL fBiStrcmpi(LPSTR sz, LPWSTR wsz)
{
    CHAR ch;
    if (!sz && !wsz)
        return TRUE;

    if (!sz || !wsz)
        return FALSE;

    //Loop through strings.. conver UNICODE chars to ASCII and compare
    while (*sz && *wsz)
    {
        wctomb(&ch, *wsz);
        if (ch != *sz)
            return FALSE;
        sz++;
        wsz++;
    }

    return TRUE; //they matched
}


//---[ szUnicodeToAscii ]------------------------------------------------------
//
//
//  Description: 
//      Convert QueueAdmin parameter to UNICODE. Strings are alloced with 
//      Exchmem and are the responsability of the caller to free.
//  Parameters:
//      IN  wszSrc      Source string to contert
//  Returns:
//      Pointer to ASCII string on success
//      NULL on failure
//  History:
//      6/7/99 - MikeSwa Created 
//      4/3/2000 - MikeSwa Modified to make loc safe
//
//-----------------------------------------------------------------------------
LPSTR  szUnicodeToAscii(LPCWSTR wszSrc)
{
    TraceFunctEnterEx((LPARAM) NULL, "szUnicodeToAscii");
    LPSTR  szDest = NULL;
    DWORD  dwErr  = ERROR_SUCCESS;
    DWORD  cSrc   = NULL;
    if (!wszSrc)
        return NULL;

    //
    //  Call into WideCharToMultiByte to get length
    //
    cSrc = WideCharToMultiByte(CP_ACP,
                        0,
                        wszSrc,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);

    cSrc++;

    szDest = (LPSTR) pvMalloc((cSrc+1)*sizeof(CHAR));
    if (!szDest)
    {
        ErrorTrace(0, "Unable to allocate conversion buffer of size %d", cSrc);
        goto Exit;
    }

    //
    //  WideCharToMultiByte a second time to do the actual conversion
    //
    if (!WideCharToMultiByte(CP_ACP,
                        0,
                        wszSrc,
                        -1,
                        szDest,
                        cSrc+1,
                        NULL,
                        NULL))
    {
        FreePv(szDest);
        szDest = NULL;
        dwErr = GetLastError();
        ErrorTrace((LPARAM) NULL, "Error convert from UNICODE to ASCII - %lu", dwErr);
        _ASSERT(0 && "Conversion from UNICODE failed");
    }
    else 
    {
        DebugTrace(0, "Converted %S to %s", wszSrc, szDest);
    }

  Exit:
    return szDest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqdbgcnt.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgcnt.cpp
//
//  Description:  Implementation of CDeubgCountdown object
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/28/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqdbgcnt.h"

//---[ CDebugCountdown::ThreadStartRoutine ]-----------------------------------
//
//
//  Description: 
//      This is the main worker routine for the class it keeps on calling 
//      WaitForSingleObject... and will assert if it times out.
//  Parameters:
//      pvThis      The "this" ptr for this object
//  Returns:
//      Always 0
//  History:
//      10/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CDebugCountdown::ThreadStartRoutine(PVOID pvThis)
{
    _ASSERT(pvThis);
    DWORD dwWaitResult = 0;
    DWORD dwTick1 = 0;
    DWORD dwTick2 = 0;
    CDebugCountdown *pdbgcntThis = (CDebugCountdown *) pvThis;

    _ASSERT(DEBUG_COUNTDOWN_SIG == pdbgcntThis->m_dwSignature);

    while (DEBUG_COUNTDOWN_ENDED != pdbgcntThis->m_dwFlags)
    {
        _ASSERT(pdbgcntThis->m_hEvent);
        dwTick1 = GetTickCount();
        dwWaitResult = WaitForSingleObject(pdbgcntThis->m_hEvent, 
                                pdbgcntThis->m_dwMilliseconds);

        dwTick2 = GetTickCount();
        if (DEBUG_COUNTDOWN_SUSPENDED != pdbgcntThis->m_dwFlags)
        {
            //This assert is the whole reason for the existance of this object
            _ASSERT((WAIT_TIMEOUT != dwWaitResult) && "Failure to call stop hints... check threads");
        }
      
    }
    return 0;
}

CDebugCountdown::CDebugCountdown()
{
    m_dwSignature = DEBUG_COUNTDOWN_SIG;
    m_hEvent = NULL;
    m_dwMilliseconds = DEBUG_COUNTDOWN_DEFAULT_WAIT;
    m_hThread = NULL;
    m_dwFlags = 0;
}

CDebugCountdown::~CDebugCountdown()
{
    if (m_hEvent)
        _VERIFY(CloseHandle(m_hEvent));

    if (m_hThread)
        _VERIFY(CloseHandle(m_hThread));
}

//The following group of functions are defined as inline NULL-ops in retail 
//builds.  Below are there debug implementations
#ifdef DEBUG

//---[ CDebugCountdown::StartCountdown ]---------------------------------------
//
//
//  Description: 
//      Starts the countdown timer... will create an event and a thread to 
//      wait on that event.
//  Parameters:
//      dwMilliseconds      Milliseconds to wait before ASSERTING
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::StartCountdown(DWORD dwMilliseconds)
{
    DWORD dwThreadId = 0;

    m_dwMilliseconds = dwMilliseconds;

    if (!m_hEvent)
        m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hEvent && !m_hThread)
    {
        m_hThread = CreateThread (NULL, 0, CDebugCountdown::ThreadStartRoutine, 
                                  this, 0, &dwThreadId);
    }
}

//---[ CDebugCountdown::SuspendCountdown ]-------------------------------------
//
//
//  Description: 
//      Suspends the countdown until the Next ResetCountdown().  Designed to 
//      be used when another component's shutdown routine is called (like cat),
//      and it is expected that they will provide there own stop hints.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::SuspendCountdown()
{
    m_dwFlags = DEBUG_COUNTDOWN_SUSPENDED;
}

//---[ CDebugCountdown::ResetCountdown ]---------------------------------------
//
//
//  Description: 
//      Causes thread to wake up and start waiting again.  Will also reset a 
//      suspended countdown.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::ResetCountdown()
{
    m_dwFlags = 0;
    if (m_hEvent)
        _VERIFY(SetEvent(m_hEvent));
}

//---[ CDebugCountdown::EndCountdown ]-----------------------------------------
//
//
//  Description: 
//      Terminates the countdown and waits for the waiting thread to exit.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDebugCountdown::EndCountdown()
{
    m_dwFlags = DEBUG_COUNTDOWN_ENDED;

    if (m_hEvent)
    {
        _VERIFY(SetEvent(m_hEvent));

        //Wait for thread to exit
        if (m_hThread)
        {
            WaitForSingleObject(m_hThread, INFINITE);
            _VERIFY(CloseHandle(m_hThread));
            m_hThread = NULL;
        }
    }
}


#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqdbgcnt.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgcnt.h
//
//  Description:  Provides a per-virtual server mechanism for ensuring that
//      the service stops and gives the proper stop hints while stopping. This
//      object creates a thread that will ASSERT if stop hints are not called
//      often enough.  This will allow you to access the debugger while the 
//      guilty function is taking so much time.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/27/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQDBGCOUNT_H__
#define __AQDBGCOUNT_H__


#define DEBUG_COUNTDOWN_SIG 'tnCD'
#define DEBUG_COUNTDOWN_DEFAULT_WAIT 20000

//define empty retail functions... to retail ops compile out
#ifdef DEBUG
#define EMPTY_RETAIL_VOID_FUNC
#else //retail
#define EMPTY_RETAIL_VOID_FUNC {}
#endif //DEBUG

//---[ CDebugCountdown ]-------------------------------------------------------
//
//
//  Description: 
//      Class that encapsulates functionality to ensure that stop hints are
//      called often enough
//  Hungarian: 
//      dbgcnt, pdbgcnt
//  
//-----------------------------------------------------------------------------
class CDebugCountdown
{
  protected:
    DWORD       m_dwSignature;
    HANDLE      m_hEvent;
    HANDLE      m_hThread;
    DWORD       m_dwMilliseconds;
    DWORD       m_dwFlags;

    enum //flags
    {
        DEBUG_COUNTDOWN_SUSPENDED = 0x00000001,
        DEBUG_COUNTDOWN_ENDED     = 0x00000002,
    };

    static DWORD ThreadStartRoutine(PVOID pThis);
  public:
    CDebugCountdown();
    ~CDebugCountdown();

    void StartCountdown(DWORD dwMilliseconds = DEBUG_COUNTDOWN_DEFAULT_WAIT) EMPTY_RETAIL_VOID_FUNC;
    void SuspendCountdown() EMPTY_RETAIL_VOID_FUNC;
    void ResetCountdown() EMPTY_RETAIL_VOID_FUNC;
    void EndCountdown() EMPTY_RETAIL_VOID_FUNC;
};

#endif //__AQDBGCOUNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqinst.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqinst.cpp
//
//  Description: Implementation of the Advanced Queueing Server Instance
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <aqprecmp.h>
#include "dcontext.h"
#include "connmgr.h"
#include <smtpseo.h>
#include <cat.h>
#include "dsnevent.h"
#include "asyncq.inl"
#include "testmapfn.h"
#include "aqutil.h"
#include "smtpconn.h"
#include "aqrpcsvr.h"
#include "aqsize.h"
#include "propstrm.h"
#include "tran_evntlog.h"

#define PRELOCAL_QUEUE_ID   0x00000001
#define PRECAT_QUEUE_ID     0x00000002
#define PREROUTING_QUEUE_ID 0x00000004
#define PRESUBMIT_QUEUE_ID  0x00000008

HRESULT MailTransport_Completion_SubmitMessage(HRESULT hrStatus, PVOID pvContext);
HRESULT MailTransport_Completion_PreCategorization(HRESULT hrStatus, PVOID pvContext);
HRESULT MailTransport_Completion_PostCategorization(HRESULT hrStatus, PVOID pvContext);

const CLSID CLSID_ExchangeStoreDriver       = {0x7BD80399,0xE37E,0x11d1,{0x9B,0xE2,0x00,0xA0,0xC9,0x5E,0x61,0x43}};

//---[ CAQSvrInst::fShouldRetryMessage ]---------------------------------------
//
//
//  Description:
//      Attempts to determine if the message has hit a hard failure (like the
//      backing store has been deleted).  This uses GetBinding to determine
//      The error returned by the store driver.  if it is FILE_NOT_FOUND,
//      then the backing store for the message has been deleted... or is no
//      longer valid (i.e. - the store restarting).
//  Parameters:
//      pIMailMsgProperties
//      fShouldBounceUsageIfRetry   TRUE - Should bounce usage on retry
//                                  FALSE - Never bounce usage
//          If the message is alreade associated with a msgref, this
//          should always be FALSE since bouncing the usage count
//          is done through the CMsgRef.
//  Returns:
//      TRUE    If we think we should retry the message
//      FALSE   If new *know* that the message should be dropped.  If unsure,
//              we will return TRUE.
//  History:
//      1/4/2000 - MikeSwa Created
//      4/10/2000 - MikeSwa Modified to better detect store shutdown/failure
//
//-----------------------------------------------------------------------------
BOOL  CAQSvrInst::fShouldRetryMessage(IMailMsgProperties *pIMailMsgProperties,
                                      BOOL fShouldBounceUsageIfRetry)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "fShouldRetryMessage");

    BOOL                fShouldRetry        = TRUE;
    BOOL                fHasShutdownLock    = FALSE;
    HRESULT             hr                  = S_OK;
    IMailMsgQueueMgmt   *pIMailMsgQueueMgmt = NULL;
    IMailMsgValidateContext *pIMailMsgValidateContext = NULL;

    _ASSERT(pIMailMsgProperties);

    if (!fTryShutdownLock())
        goto Exit;

    fHasShutdownLock = TRUE;

    //
    //  First check and see if the message context is still OK - if that
    //  doesn't work, we use the  HrValidateMessageConteNt call below
    //  and force a RFC822 rendering of the message (which can be a
    //  huge perf hit).
    //

    // QI for validation interface
    hr = pIMailMsgProperties->QueryInterface(
            IID_IMailMsgValidateContext,
            (LPVOID *)&pIMailMsgValidateContext);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to QI for IMailMsgValidateContext 0x%08X",hr);
        goto Exit;
    }

    // Validate the message context
    hr = pIMailMsgValidateContext->ValidateContext();

    DebugTrace((LPARAM) this,
        "ValidateContext returned 0x%08X", hr);

    if (hr == S_OK) //this message is fine
        goto Exit;
    else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        fShouldRetry = FALSE;
        goto Exit;
    }

    //
    //  If the above didn't work... try harder by verifying content.  This
    //  will open the handles... so we need to close them
    //
    hr = HrValidateMessageContent(pIMailMsgProperties);
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        //The mailmsg has been deleted... we can just drop it.
        DebugTrace((LPARAM) pIMailMsgProperties,
            "WARNING: Backing store for mailmsg has been deleted.");
        fShouldRetry = FALSE;
        goto Exit;
    }
    else if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "GetBinding failed with hr - 0x%08X", hr);
        goto Exit;
    }

  Exit:

    //
    //  Bounce usage count if we have are sticking it back in the queue
    //  and the caller does not object
    //
    if (fShouldRetry && fShouldBounceUsageIfRetry)
    {
        hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt,
                                                (void **) &pIMailMsgQueueMgmt);
        if (SUCCEEDED(hr) && pIMailMsgQueueMgmt)
        {
            pIMailMsgQueueMgmt->ReleaseUsage();
            pIMailMsgQueueMgmt->AddUsage();
            pIMailMsgQueueMgmt->Release();
        }
    }

    if (pIMailMsgValidateContext)
        pIMailMsgValidateContext->Release();

    if (fHasShutdownLock)
        ShutdownUnlock();

    TraceFunctLeave();
    return fShouldRetry;
}

//thin wrapper for CAQSvrInst::fPreCatQueueCompletion member
BOOL  fPreCatQueueCompletionWrapper(IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext)
{
    if (!((CAQSvrInst *)pvContext)->fPreCatQueueCompletion(pIMailMsgProperties))
        return !((CAQSvrInst *)pvContext)->fShouldRetryMessage(pIMailMsgProperties);
    else
        return TRUE;
}

//thin wrapper for CAQSvrInst::fPreLocalDeliveryCompletion
BOOL  fPreLocalDeliveryQueueCompletionWrapper(CMsgRef *pmsgref,
                                              PVOID pvContext)
{
    return ((CAQSvrInst *)pvContext)->fPreLocalDeliveryQueueCompletion(pmsgref);
}

//thin wrapper for CAQSvrInst::fPostDSNQueueCompletion member
BOOL  fPostDSNQueueCompletionWrapper(IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext)
{
    return (SUCCEEDED(((CAQSvrInst *)pvContext)->HrInternalSubmitMessage(pIMailMsgProperties)));
}

//thin wrapper for CAQSvrInst::fPreRoutingQueueCompletion
BOOL  fPreRoutingQueueCompletionWrapper(IMailMsgProperties *pIMailMsgProperties,
                                        PVOID pvContext)
{
    if (!((CAQSvrInst *)pvContext)->fRouteAndQueueMsg(pIMailMsgProperties))
        return !((CAQSvrInst *)pvContext)->fShouldRetryMessage(pIMailMsgProperties);
    else
        return TRUE;
}

//thin wrappers for handling internal asyncq queue failures
BOOL  fAsyncQHandleFailedMailMsg(IMailMsgProperties *pIMailMsgProperties,
                                        PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->HandleAQFailure(AQ_FAILURE_INTERNAL_ASYNCQ,
                        E_OUTOFMEMORY, pIMailMsgProperties);
    return TRUE;
}

BOOL  fAsyncQHandleFailedMsgRef(CMsgRef *pmsgref, PVOID pvContext)
{
    _ASSERT(pmsgref);
    if (pmsgref)
        pmsgref->RetryOnDelete();
    return TRUE;
}

//Thin wrapper(s) for AsyncQueueRetry - kick starting queues
void LocalDeliveryRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PRELOCAL_QUEUE_ID);
}

void CatRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PRECAT_QUEUE_ID);
}

void RoutingRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PREROUTING_QUEUE_ID);
}

void SubmitRetry(PVOID pvContext)
{
    ((CAQSvrInst *)pvContext)->AsyncQueueRetry(PRESUBMIT_QUEUE_ID);
}

//---[ CAQSvrInst::fPreSubmissionQueueCompletionWrapper ]----------------------
//
//
//  Description:
//      Completion function for PreSubmit Queue
//  Parameters:
//      pIMailMsgPropeties      IMailMsg to submit
//      pvContext               Ptr to CAQSvrInst
//  Returns:
//      TRUE    completed successfully
//      FALSE   message needs to be retried
//  History:
//      10/8/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL  CAQSvrInst::fPreSubmissionQueueCompletionWrapper(
                                    IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext)
{
    BOOL    fRetry = FALSE;
    HRESULT hr = S_OK;
    CAQSvrInst *paqinst = (CAQSvrInst *)pvContext;

    _ASSERT(paqinst);

    InterlockedDecrement((PLONG) &(paqinst->m_cCurrentMsgsPendingSubmit));
    hr = (paqinst->HrInternalSubmitMessage(pIMailMsgProperties));
    if (FAILED(hr))
    {
        if (paqinst->fShouldRetryMessage(pIMailMsgProperties))
        {
            fRetry = TRUE;
            InterlockedIncrement((PLONG) &(paqinst->m_cCurrentMsgsPendingSubmit));

            //
            //  We need to kick off a retry as well for the presubmit queue
            //
            if (!paqinst->m_cSubmitRetriesPending)
            {
                InterlockedIncrement((PLONG) &(paqinst->m_cSubmitRetriesPending));
                paqinst->SetCallbackTime(SubmitRetry, paqinst, g_cSubmissionRetryMinutes);
            }

        }
    }

    return (!fRetry);
}


//currently these numbers are completely arbitrary... we will need to tune them
const DWORD     MAX_SYNC_CATQ_THREADS           = 5;
const DWORD     ITEMS_PER_CATQ_THREAD           = 50;
const DWORD     ITEMS_PER_CATQ_SYNC_THREAD      = 50;

const DWORD     MAX_SYNC_LOCALQ_THREADS         = 0;
const DWORD     ITEMS_PER_LOCALQ_THREAD         = 20;
const DWORD     ITEMS_PER_LOCALQ_SYNC_THREAD    = 5;

//must be zero to avoid reentrant lock problems
const DWORD     MAX_SYNC_POSTDSNQ_THREADS       = 0;
const DWORD     ITEMS_PER_POSTDSNQ_THREAD       = 100;
const DWORD     ITEMS_PER_POSTDSNQ_SYNC_THREAD  = 1;

const DWORD     MAX_SYNC_ROUTINGQ_THREADS       = 0;
const DWORD     ITEMS_PER_ROUTINGQ_THREAD       = 50;
const DWORD     ITEMS_PER_ROUTINGQ_SYNC_THREAD  = 50;

const DWORD     MAX_SYNC_SUBMITQ_THREADS        = 0;
const DWORD     ITEMS_PER_SUBMITQ_THREAD        = 50;
const DWORD     ITEMS_PER_SUBMITQ_SYNC_THREAD   = 50;

const DWORD     ITEMS_PER_WORKQ_THREAD          = 25;

DEBUG_DO_IT(CAQSvrInst *g_paqinstLastDeleted = NULL;); //used to find the last deleted in CDB

#define TRACE_COUNTERS \
{\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending submission event for server 0x%08X", m_cCurrentMsgsPendingSubmitEvent, this); \
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending pre-cat event for server 0x%08X", m_cCurrentMsgsPendingPreCatEvent, this); \
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending post-cat event for server 0x%08X", m_cCurrentMsgsPendingPostCatEvent, this); \
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs submited (total post cat) for delivery on server 0x%08X", m_cTotalMsgsQueued, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs pending categorization for server 0x%08X", m_cCurrentMsgsPendingCat, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs ack'd on server 0x%08X", m_cMsgsAcked, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs ack'd for retry on server 0x%08X", m_cMsgsAckedRetry, this);\
    DebugTrace(0xC0DEC0DE, "INFO: %d msgs delivered local on server 0x%08X", m_cMsgsDeliveredLocal, this);\
}

// {407525AC-62B5-11d2-A694-00C04FA3490A}
static const GUID g_guidDefaultRouter =
{ 0x407525ac, 0x62b5, 0x11d2, { 0xa6, 0x94, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

//GUID for local queue
// {34E2DCCC-C91A-11d2-A6B1-00C04FA3490A}
static const GUID g_guidLocalQueue =
{ 0x34e2dccc, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

//---[ CAQSvrInst::CAQSvrInst ]------------------------------------------------
//
//
//  Description:
//      Class constuctor
//  Parameters:
//      SMTP_SERVER_INSTANCE *pssi - ptr to SMTP server instance object
//      pISMTPServer - interface used to handle local deliverys
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CAQSvrInst::CAQSvrInst(DWORD dwServerInstance,
                       ISMTPServer *pISMTPServer)
                       : m_mglSupersedeIDs(&m_cSupersededMsgs),
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

                         m_asyncqPreLocalDeliveryQueue("LocalAsyncQueue", LOCAL_LINK_NAME,
                                                       &g_guidLocalQueue, 0, this),

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif
                         m_slPrivateData("CAQSvrInst",
                                         SHARE_LOCK_INST_TRACK_DEFAULTS |
                                         SHARE_LOCK_INST_TRACK_SHARED_THREADS |
                                         SHARE_LOCK_INST_TRACK_CONTENTION, 500)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::CAQSvrInst");
    _ASSERT(pISMTPServer);

    m_dwSignature = CATMSGQ_SIG;
    m_dwFlavorSignature = g_dwFlavorSignature;
    m_cbClasses = g_cbClasses;

    //Init counters
    m_cTotalMsgsQueued = 0;        //# of messages on dest queues (after fanout)
    m_cMsgsAcked = 0;         //# of messages that have been acknowledged
    m_cMsgsAckedRetry = 0;    //# of messages acked with retry all
    m_cMsgsDeliveredLocal= 0; //# of messages delivered to local store
    m_cCurrentMsgsPendingSubmitEvent = 0; //current # of messages in
                                          //submission event
    m_cCurrentMsgsPendingPreCatEvent = 0; // current # of messages in
                                          // precat event
    m_cCurrentMsgsPendingPostCatEvent = 0; //current # of messages in
                                           //post-categorization event
    m_cCurrentMsgsSubmitted = 0; //# total msgs in system
    m_cCurrentMsgsPendingCat = 0; //# Msgs that have not be categorized
    m_cCurrentMsgsPendingRouting = 0; //# Msgs that have been cat.
                                //but have not been completely queued
    m_cCurrentMsgsPendingDelivery = 0; //# Msgs pending remote delivery
    m_cCurrentMsgsPendingLocal = 0; //# Msgs pending local delivery
    m_cCurrentMsgsPendingRetry = 0; //# Msgs with unsuccessful attempts
    m_cCurrentQueueMsgInstances = 0;  //# of msgs instances pending
                                //remote deliver (>= #msgs)
    m_cCurrentRemoteDestQueues = 0; //# of DestMsgQueues created
    m_cCurrentRemoteNextHops = 0; //# of Next Hop links created
    m_cCurrentRemoteNextHopsEnabled = 0; //# of links that can have connections
    m_cCurrentRemoteNextHopsPendingRetry = 0; //# of links pending retry
    m_cCurrentRemoteNextHopsPendingSchedule = 0; //# of links pending schedule
    m_cCurrentRemoteNextHopsFrozenByAdmin = 0; //# of links frozen by admin
    m_cTotalMsgsSubmitted = 0; //total # of messages submitted to AQ
    m_cTotalExternalMsgsSubmitted = 0; //Sumitted via an external interface
    m_cMsgsAckedRetryLocal = 0;
    m_cCurrentMsgsPendingLocalRetry = 0;
    m_cDMTRetries  = 0;
    m_cTotalMsgsTURNETRNDelivered = 0;
    m_cCurrentMsgsPendingDeferredDelivery = 0;
    m_cCurrentResourceFailedMsgsPendingRetry = 0;
    m_cTotalMsgsBadmailed = 0;
    m_cBadmailNoRecipients = 0;
    m_cBadmailHopCountExceeded = 0;
    m_cBadmailFailureGeneral = 0;
    m_cBadmailBadPickupFile = 0;
    m_cBadmailEvent = 0;
    m_cBadmailNdrOfDsn = 0;
    m_cTotalDSNFailures = 0;
    m_cCurrentMsgsInLocalDelivery = 0;
    m_cTotalResetRoutes = 0;
    m_cCurrentPendingResetRoutes = 0;
    m_cCurrentMsgsPendingSubmit = 0;


    //Counters to keep track of the number of messages in Cat
    m_cCatMsgCalled = 0;
    m_cCatCompletionCalled = 0;

    //DSN Related counters
    m_cDelayedDSNs = 0;
    m_cNDRs = 0;
    m_cDeliveredDSNs = 0;
    m_cRelayedDSNs = 0;
    m_cExpandedDSNs = 0;

    m_cSupersededMsgs = 0; //number of messages superseded

    m_dwDelayExpireMinutes = g_dwDelayExpireMinutes;
    m_dwNDRExpireMinutes = g_dwNDRExpireMinutes;
    m_dwLocalDelayExpireMinutes = g_dwDelayExpireMinutes;
    m_dwLocalNDRExpireMinutes = g_dwNDRExpireMinutes;


    m_dwInitMask = 0;
    m_prstrDefaultDomain = NULL;
    m_prstrBadMailDir = NULL;
    m_prstrCopyNDRTo = NULL;
    m_prstrServerFQDN = NULL;

    m_dwDSNLanguageID = 0;
    m_dwDSNOptions = DSN_OPTIONS_DEFAULT;

    if (pISMTPServer)
        pISMTPServer->AddRef();

    m_pISMTPServer = pISMTPServer;

    // Get the ISMTPServerEx interface
    {
        HRESULT     hr;

        hr = m_pISMTPServer->QueryInterface(
                IID_ISMTPServerEx,
                (LPVOID *)&m_pISMTPServerEx);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) m_pISMTPServer,
                "Unable to QI for ISMTPServerEx 0x%08X",hr);

            m_pISMTPServerEx = NULL;
        }

        // Make sure we got the interface
        _ASSERT(m_pISMTPServerEx);
    }

    m_hCat = INVALID_HANDLE_VALUE;
    m_dwServerInstance = dwServerInstance;
    m_pConnMgr = NULL;
    m_pIMessageRouterDefault = NULL;

    //Retry stuff
    m_dwFirstTierRetrySeconds = g_dwFirstTierRetrySeconds;

    m_cLocalRetriesPending = 0;  //used for moderating local retries
    m_cCatRetriesPending = 0; //used for moderating cat retires
    m_cRoutingRetriesPending = 0; //used for moderating routing retries
    m_cSubmitRetriesPending = 0; //used for moderating submit retries

    m_pIRouterReset = NULL;

    //Add to global list of virtual servers
    m_liVirtualServers.Blink = &g_liVirtualServers;
    g_pslGlobals->ExclusiveLock();
    m_liVirtualServers.Flink = g_liVirtualServers.Flink;
    g_liVirtualServers.Flink->Blink = &m_liVirtualServers;
    g_liVirtualServers.Flink = &m_liVirtualServers;
    g_pslGlobals->ExclusiveUnlock();

    //
    //  Assume (until proven otherwise) mailmsg returns the handle count
    //
    m_fMailMsgReportsNumHandles = TRUE;

    m_defq.Initialize(this);

    TraceFunctLeave();

}

//---[ CAQSvrInst::~CAQSvrInst ]--------------------------------------------
//
//
//  Description:
//      Class destuctor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CAQSvrInst::~CAQSvrInst()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::~CAQSvrInst");

    //make sure that all cleanup was done
    HrDeinitialize();  //can be called multiple times

    if (m_pISMTPServer)
        m_pISMTPServer->Release();

    if (m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    if (m_pConnMgr)
    {
        m_pConnMgr->Release();
        m_pConnMgr = NULL;
    }

    if (m_prstrDefaultDomain)
        m_prstrDefaultDomain->Release();

    if (m_prstrBadMailDir)
        m_prstrBadMailDir->Release();

    if (m_prstrCopyNDRTo)
        m_prstrCopyNDRTo->Release();

    if (m_prstrServerFQDN)
        m_prstrServerFQDN->Release();

    //Take out of list of global list
    g_pslGlobals->ExclusiveLock();
    m_liVirtualServers.Flink->Blink = m_liVirtualServers.Blink;
    m_liVirtualServers.Blink->Flink = m_liVirtualServers.Flink;
    g_pslGlobals->ExclusiveUnlock();
    m_liVirtualServers.Flink = NULL;
    m_liVirtualServers.Flink = NULL;

    MARK_SIG_AS_DELETED(m_dwSignature);
    DEBUG_DO_IT(g_paqinstLastDeleted = this;);
    TraceFunctLeave();

}


//---[ CAQSvrInst::HrInitialize ]--------------------------------------------
//
//
//  Description:
//      Initialization of CAQSvrInst virtual server instance object.
//  Parameters:
//      IN  szUserName           User name to log on DS with
//      IN  szDomainName         Domain name to log on to DS with
//      IN  szPassword           Password to authenticate to DS with
//      IN  pServiceStatusFn     Server status callback function
//      IN  pvServiceContext     Context to pass back for callback function
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrInitialize(
                    IN  LPSTR   szUserName,
                    IN  LPSTR   szDomainName,
                    IN  LPSTR   szPassword,
                    IN  PSRVFN  pServiceStatusFn,
                    IN  PVOID   pvServiceContext)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrInitialize");
    HRESULT hr = S_OK;
    IMailTransportSetRouterReset *pISetRouterReset = NULL;

    //
    //  Update global config information.
    //
    ReadGlobalRegistryConfiguration();

    m_pIMessageRouterDefault = new CAQDefaultMessageRouter(
                                (GUID *) &g_guidDefaultRouter, this);
    if (!m_pIMessageRouterDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    m_fmq.Initialize(this);

    hr = CAQRpcSvrInst::HrInitializeAQServerInstanceRPC(this,
                                                        m_dwServerInstance,
                                                        m_pISMTPServer);
    if (FAILED(hr))
        goto Exit;

    //Initialize Message Categorization
    hr = CatInit(
        NULL,
        pServiceStatusFn,
        pvServiceContext,
        m_pISMTPServer,
        (IAdvQueueDomainType *) this,
        m_dwServerInstance,
        &m_hCat);

    if (FAILED(hr))
    {
        m_hCat = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    //Pass RouterReset Interface to ISMTPServer
    if (m_pISMTPServer)
    {
        hr = m_pISMTPServer->QueryInterface(IID_IMailTransportSetRouterReset,
                                            (void **) &pISetRouterReset);
        if (SUCCEEDED(hr))
        {
            m_dwInitMask |= CMQ_INIT_ROUTER_RESET;
            _ASSERT(pISetRouterReset);
            hr = pISetRouterReset->RegisterResetInterface(m_dwServerInstance,
                                (IMailTransportRouterReset *) this);
            _ASSERT(SUCCEEDED(hr)); //something is wrong if this failed
            pISetRouterReset->Release();
            pISetRouterReset = NULL;
        }

        hr = m_pISMTPServer->QueryInterface(IID_IMailTransportRouterReset,
                                            (void **) &m_pIRouterReset);
        if (FAILED(hr))
            m_pIRouterReset = NULL;
    }

    hr = m_dmt.HrInitialize(this, &m_asyncqPreLocalDeliveryQueue,
                        &m_asyncqPreCatQueue, &m_asyncqPreRoutingQueue);
    if (FAILED(hr))
        goto Exit;

    m_dwInitMask |= CMQ_INIT_DMT;

    hr = m_dct.HrInit();
    if (FAILED(hr))
        goto Exit;

    m_dwInitMask |= CMQ_INIT_DCT;

    m_pConnMgr = new CConnMgr;
    if (NULL == m_pConnMgr)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = m_pConnMgr->HrInitialize(this);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_CONMGR;

    hr = m_dsnsink.HrInitialize();
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_DSN;

    hr = m_asyncqPreCatQueue.HrInitialize(MAX_SYNC_CATQ_THREADS,
                                          ITEMS_PER_CATQ_THREAD,
                                          ITEMS_PER_CATQ_SYNC_THREAD,
                                          this,
                                          fPreCatQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL,
                                          g_cMaxIMsgHandlesThreshold);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_PRECATQ;

    hr = m_asyncqPreLocalDeliveryQueue.HrInitialize(MAX_SYNC_LOCALQ_THREADS,
                                                    ITEMS_PER_LOCALQ_THREAD,
                                                    ITEMS_PER_LOCALQ_SYNC_THREAD,
                                                    this,
                                                    fPreLocalDeliveryQueueCompletionWrapper,
                                                    fAsyncQHandleFailedMsgRef,
                                                    HrWalkPreLocalQueueForDSN);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_PRELOCQ;

    hr = m_asyncqPostDSNQueue.HrInitialize(MAX_SYNC_POSTDSNQ_THREADS,
                                          ITEMS_PER_POSTDSNQ_THREAD,
                                          ITEMS_PER_POSTDSNQ_SYNC_THREAD,
                                          this,
                                          fPostDSNQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_POSTDSNQ;

    hr = m_asyncqPreRoutingQueue.HrInitialize(MAX_SYNC_ROUTINGQ_THREADS,
                                          ITEMS_PER_ROUTINGQ_THREAD,
                                          ITEMS_PER_ROUTINGQ_SYNC_THREAD,
                                          this,
                                          fPreRoutingQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_ROUTINGQ;

    hr = m_asyncqPreSubmissionQueue.HrInitialize(MAX_SYNC_SUBMITQ_THREADS,
                                          ITEMS_PER_SUBMITQ_THREAD,
                                          ITEMS_PER_SUBMITQ_SYNC_THREAD,
                                          this,
                                          fPreSubmissionQueueCompletionWrapper,
                                          fAsyncQHandleFailedMailMsg,
                                          NULL);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_SUBMISSIONQ;

    hr = m_aqwWorkQueue.HrInitialize(ITEMS_PER_WORKQ_THREAD);
    if (FAILED(hr))
        goto Exit;
    m_dwInitMask |= CMQ_INIT_WORKQ;

    m_dwInitMask |= CMQ_INIT_OK;  //everything was initialized

    // create the router object
    hr = HrTriggerInitRouter();


  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HrDeinitialize() ]----------------------------------------
//
//
//  Description:
//      Signals server shutdown
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Whatever error codes are generated during the shutdown process
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    DWORD   i  = 0;
    IMailTransportSetRouterReset *pISetRouterReset = NULL;

    //
    // Tell categorizer to stop categorizing before we block on the
    // shutdown lock.
    //
    if (INVALID_HANDLE_VALUE != m_hCat)
    {
        CatPrepareForShutdown(m_hCat);
    }


    //
    //  We have hit this assert a few times due to NT stress failures.
    //  This is only really useful if at least one messsage has been
    //  sent.  The asser is basically useless if we hit it in KD during
    //  NT stress runs.
    //
    if (m_cTotalMsgsSubmitted)
        m_dbgcnt.StartCountdown();

    ServerStopHintFunction();
    //Get Exclusive shutdown lock
    SignalShutdown();

    ServerStopHintFunction();
    //Turn off RPC for this instance
    hrTmp = CAQRpcSvrInst::HrDeinitializeAQServerInstanceRPC(this, m_dwServerInstance);
    if (FAILED(hrTmp))
    {
        ErrorTrace((LPARAM) this,
            "Error shutting down Aqueue RPC hr - 0x%08X", hrTmp);
        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

    ServerStopHintFunction();
    m_fmq.Deinitialize();
    ServerStopHintFunction();
    m_defq.Deinitialize();

    m_dwInitMask &= ~CMQ_INIT_DCT; //no de-initialize function to call

    //stop any pending categorization
    ServerStopHintFunction();
    if (INVALID_HANDLE_VALUE != m_hCat)
    {
        m_dbgcnt.SuspendCountdown();
        hrTmp  = CatCancel(m_hCat);
        if FAILED(hrTmp)
        {
            ErrorTrace((LPARAM) this,
                "ERROR:  Categorization shutdown error hr - 0x%08X", hrTmp);
            if (SUCCEEDED(hr))
                hr = hrTmp;
        }

        //shutdow message categorization
        CatTerm(m_hCat);

        m_dbgcnt.ResetCountdown();

        m_hCat = INVALID_HANDLE_VALUE;
    }

    //Tell ISMTPServer to set RouterReset Interface to NULL
    ServerStopHintFunction();
    if (m_pISMTPServer)
    {
        hr = m_pISMTPServer->QueryInterface(IID_IMailTransportSetRouterReset,
                                            (void **) &pISetRouterReset);
        if (SUCCEEDED(hr))
        {
            m_dwInitMask &= ~CMQ_INIT_ROUTER_RESET;
            _ASSERT(pISetRouterReset);
            hr = pISetRouterReset->RegisterResetInterface(m_dwServerInstance,
                                NULL);
            _ASSERT(SUCCEEDED(hr)); //something is wrong if this failed
            pISetRouterReset->Release();
            pISetRouterReset = NULL;
        }
    }

    ServerStopHintFunction();
    if (m_pIRouterReset)
    {
        m_pIRouterReset->Release();
        m_pIRouterReset = NULL;
    }

    ServerStopHintFunction();
    if (CMQ_INIT_DMT & m_dwInitMask)
    {
        m_dwInitMask ^= CMQ_INIT_DMT;
        hrTmp = m_dmt.HrDeinitialize();
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
    }

    //Deinitializing the connection manager will also release the retry
    //sink to make all it's callbacks.
    ServerStopHintFunction();
    if (NULL != m_pConnMgr)
    {
        if (CMQ_INIT_CONMGR & m_dwInitMask)
        {
            _ASSERT(m_pISMTPServer);
            m_dwInitMask ^= CMQ_INIT_CONMGR;
            hrTmp = m_pConnMgr->HrDeinitialize();
            if (FAILED(hrTmp) && SUCCEEDED(hr))
                hr = hrTmp;
        }

        m_pConnMgr->Release();
        m_pConnMgr = NULL;
    }

    //deinitialize pre-local delivery queue
    ServerStopHintFunction();
    if (CMQ_INIT_PRELOCQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreLocalDeliveryQueue.HrDeinitialize(
            HrWalkMsgRefQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_PRELOCQ;
    }

    //deinitialize pre-cat delivery queue
    ServerStopHintFunction();
    if (CMQ_INIT_PRECATQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreCatQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_PRECATQ;
    }

    //deinitialize post DNS queue
    ServerStopHintFunction();
    if (CMQ_INIT_POSTDSNQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPostDSNQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_POSTDSNQ;
    }

    //deinitialize pre-routing  queue
    ServerStopHintFunction();
    if (CMQ_INIT_ROUTINGQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreRoutingQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_ROUTINGQ;
    }

    //deinitialize pre-submit queue
    ServerStopHintFunction();
    if (CMQ_INIT_SUBMISSIONQ & m_dwInitMask)
    {
        hrTmp = m_asyncqPreSubmissionQueue.HrDeinitialize(
            HrWalkMailMsgQueueForShutdown, this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_SUBMISSIONQ;
    }

    ServerStopHintFunction();
    m_mglSupersedeIDs.Deinitialize(this);

    ServerStopHintFunction();
    if (CMQ_INIT_WORKQ & m_dwInitMask)
    {
        hrTmp = m_aqwWorkQueue.HrDeinitialize(this);
        if (FAILED(hrTmp) && SUCCEEDED(hr))
            hr = hrTmp;
        m_dwInitMask ^= CMQ_INIT_WORKQ;
    }

    //the following bits don't have specific delinitialize functions
    m_dwInitMask &= ~(CMQ_INIT_DSN | CMQ_INIT_OK);

    ServerStopHintFunction();
    if (m_pIMessageRouterDefault)
    {
        m_pIMessageRouterDefault->Release();
        m_pIMessageRouterDefault = NULL;
    }

    m_dbgcnt.EndCountdown();
    _ASSERT((!m_dwInitMask) || FAILED(hr));

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HrGetIConnectionManager ]---------------------------------
//
//
//  Description:
//      Returns the IConnectionManager interface for this AdvancedQueuing instance
//  Parameters:
//      OUT ppIConnectionManger     Returned interface
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetIConnectionManager(
               OUT IConnectionManager **ppIConnectionManager)
{
    HRESULT hr = S_OK;
    _ASSERT(ppIConnectionManager);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    m_pConnMgr->AddRef();
    *ppIConnectionManager = m_pConnMgr;

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::cCountMsgsForHandleThrottling ]-----------------------------
//
//
//  Description:
//      returns the number of messages in the system that
//      is used elsewhere to decide to start/stop handle throttling
//
//
//  Parameters:
//      pIMailMsgProperties     pointer to MailMsg interface to query
//
//  Returns:
//      DWORD returned is:
//
//      - With Windows2000 RTM mailmsg.dll:
//        count of all messages in the system
//
//      - With Windows2000 SP1 mailmsg.dll:
//        count of open property stream handles
//        OR
//        count of all messages in the system
//        if the former can't be obtained
//
//  History:
//      1/28/00 aszafer Created
//-----------------------------------------------------------------------------

#ifndef IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES
#define IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES   0x3004
#endif

DWORD CAQSvrInst::cCountMsgsForHandleThrottling(IN IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT hr = MAILMSG_E_PROPNOTFOUND;  //Count as failure if we do not call
    DWORD dwStreamOpenHandlesCount = 0;


    TraceFunctEnterEx((LPARAM) this, "Entering CAQSvrInst::cCountMsgsForHandleThrottling");

    //
    //  We should never call into mailmsg if we know we do not have the correct version.
    //  This will load the property stream and cause us to potentially access the
    //  properties in an unsafe way.
    //
    if (m_fMailMsgReportsNumHandles && pIMailMsgProperties)
    {
        hr = pIMailMsgProperties->GetDWORD(
            IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,
            &dwStreamOpenHandlesCount);

        if(FAILED(hr))
        {
            m_fMailMsgReportsNumHandles = FALSE;
            //must be RTM version of mailmsg.dll
            DebugTrace((LPARAM) this, "GetDWORD(IMMPID*OPEN_PROPERTY_STREAM_HANDLES) failed hr %08lx", hr);
            DebugTrace((LPARAM) this, "returning g_cIMsgInSystem + m_cCurrentMsgsPendingSubmit");
        }
    }



    TraceFunctLeaveEx((LPARAM) this);

    return SUCCEEDED(hr) ? dwStreamOpenHandlesCount : g_cIMsgInSystem + m_cCurrentMsgsPendingSubmit ;
}


//---[ CAQSvrInst::QueueMsgForLocalDelivery ]----------------------------------
//
//
//  Description:
//      Queues a single message for local delivery
//  Parameters:
//      IN  pmsgref     Message Ref to deliver locally
//  Returns:
//      -
//  History:
//      1/26/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::QueueMsgForLocalDelivery(CMsgRef *pmsgref, BOOL fLocalLink)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::QueueMsgForLocalDelivery");
    HRESULT hr = S_OK;
    CAQStats aqstat;
    CLinkMsgQueue *plmq = NULL;

    //
    // Get the stats from the msgref
    //
    pmsgref->GetStatsForMsg(&aqstat);

    //
    //  Get the local link and update the stats
    //
    plmq = m_dmt.plmqGetLocalLink();
    if (plmq)
    {
        hr = plmq->HrNotify(&aqstat, TRUE);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "HrNotify failed... local stats innaccurate 0x%08X", hr);
            hr = S_OK;
        }
    }

    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingLocal);
    hr = m_asyncqPreLocalDeliveryQueue.HrQueueRequest(pmsgref);
    if (FAILED(hr))
    {
        hr = plmq->HrNotify(&aqstat, FALSE);
        pmsgref->RetryOnDelete();
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingLocal);
    }

    //
    //  Make sure we release the local link if we got it
    //
    if (plmq)
        plmq->Release();

    TraceFunctLeave();
}

//---[ CAQSvrInst::fRouteAndQueueMsg ]-----------------------------------------
//
//
//  Description:
//      Add a Categorized Message to the CMT to be queue for delivery
//  Parameters:
//      IN pIMailMsgProperties      Msg to routing and queue for delivery
//  Returns:
//      TRUE if message has been successfully routed and queued for delivery
//              (or if errors have been handled internally)
//      FALSE if message needs to be requeued for a later retry
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fRouteAndQueueMsg(IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::fRouteAndQueueMsg");
    HRESULT       hr        = S_OK;
    HRESULT       hrTmp     = S_OK;
    DWORD         cDomains  = 0; //number of domains message will be deliver to
    DWORD         cQueues   = 0; //number of queues for the message
    DWORD         i         = 0; //loop counter
    DWORD         cLocalRecips = 0;
    DWORD         cRemoteRecips = 0;
    DWORD         dwDMTVersion = 0;
    CMsgRef       *pmsgref  = NULL;
    CDestMsgQueue **rgpdmq  = NULL;
    BOOL          fLocked   = FALSE;
    BOOL          fRoutingLock = FALSE;
    BOOL          fLocal    = FALSE;
    BOOL          fRemote   = FALSE;
    BOOL          fOnDMQ    = FALSE;
    BOOL          fDMTLocked = FALSE;
    BOOL          fKeepTrying = TRUE;
    BOOL          fGotMsgType = FALSE;
    BOOL          fReturn = TRUE;
    DWORD         dwMessageType = 0;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    IMailMsgRecipients *pIRecipList = NULL;
    IMessageRouter *pIMessageRouter = NULL;

    _ASSERT(CATMSGQ_SIG == m_dwSignature);


    _ASSERT(pIMailMsgProperties);
    if (NULL == pIMailMsgProperties)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients, (PVOID *) &pIRecipList);
    if (FAILED(hr))
        goto Exit;


    //get a shared lock to guard against shutdown.
    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    hr = pIRecipList->DomainCount(&cDomains);
    if (FAILED(hr))
        goto Exit;

    if (!cDomains) //and hence no recipients
    {
        //This could be a completely valid case (like an empty DL)
        //In this case we just turf the message and act as if everything is fine
        DecMsgsInSystem(); //update our counters
        HandleBadMail(pIMailMsgProperties, TRUE, NULL, AQUEUE_E_NO_RECIPIENTS, FALSE);
        InterlockedIncrement((PLONG) &m_cBadmailNoRecipients);

        //Delete the message
        HrDeleteIMailMsg(pIMailMsgProperties);
        hr = S_OK;
        goto Exit;
    }

    //Check Message to see if there are unresolved recipients to NDR
    hr = HrNDRUnresolvedRecipients(pIMailMsgProperties, pIRecipList);
    if (FAILED(hr))
    {
        HandleAQFailure(AQ_FAILURE_CANNOT_NDR_UNRESOLVED_RECIPS, hr, pIMailMsgProperties);
        ErrorTrace((LPARAM) this, "ERROR: Unable to NDR message - hr 0x%08X", hr);
        //just drop message for now... we cannot let it continue until this succeeds
        hr = S_OK;
        goto Exit;
    }

    if (S_FALSE == hr)
    {
        //There is no work to be done for this message - delete it
        HrDeleteIMailMsg(pIMailMsgProperties);
        DebugTrace((LPARAM) this,
                  "INFO: Deleting message after NDRing all unresolved recips");
        hr = S_OK;
        DecMsgsInSystem(); //update our counters
        goto Exit;
    }

    rgpdmq = (CDestMsgQueue **) pvMalloc(cDomains * sizeof(CDestMsgQueue *));
    if (NULL == rgpdmq)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    RoutingShareLock();
    fRoutingLock = TRUE;

    hr = HrTriggerGetMessageRouter(pIMailMsgProperties, &pIMessageRouter);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "ERROR: Unable to get message router - HR 0z%08X", hr);
        goto Exit;
    }

    hr = pIMessageRouter->GetMessageType(pIMailMsgProperties, &dwMessageType);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "ERROR: Unable to get message type - HR 0x%08X", hr);
        goto Exit;
    }

    //We own a reference to the message type now
    fGotMsgType = TRUE;

    pmsgref = new((DWORD) cDomains) CMsgRef(cDomains, pIMailMsgQueueMgmt, pIMailMsgProperties,
                this, dwMessageType, pIMessageRouter->GetTransportSinkID());

    if (NULL == pmsgref)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Loop until we get consistant info on where to queue message (based on
    //DMT version number).
    while (fKeepTrying)
    {
        dwDMTVersion = m_dmt.dwGetDMTVersion();
        hr = pmsgref->HrInitialize(pIRecipList, pIMessageRouter, dwMessageType,
                            &cLocalRecips, &cRemoteRecips, &cQueues, rgpdmq);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr)
            {
                //Some sort of config/routing change... we need to retry the
                //message
                fGotMsgType = FALSE;
                hr = HrReGetMessageType(pIMailMsgProperties,
                                    pIMessageRouter, &dwMessageType);
                if (FAILED(hr))
                    goto Exit;
                fGotMsgType = TRUE;

            }
            else  //It was a genuine error... bail
                goto Exit;
        }

        //Before Enqueuing Messages or firing off local delivery... throttle usage count
        if (g_cMaxIMsgHandlesThreshold < cCountMsgsForHandleThrottling(pIMailMsgProperties))
        {
            DebugTrace((LPARAM) 0xC0DEC0DE, "INFO: Closing IMsg Content - %d messsages in queue", cCountMsgsForHandleThrottling(pIMailMsgProperties));
            //bounce usage count off of zero
            pIMailMsgQueueMgmt->ReleaseUsage();
            pIMailMsgQueueMgmt->AddUsage();
        }

        m_dmt.AquireDMTShareLock();
        if (m_dmt.dwGetDMTVersion() != dwDMTVersion)
        {
            //DMT Version changed... that means that our queues may have been
            //removed from the DMT.  Time to retry
            m_dmt.ReleaseDMTShareLock();
            _ASSERT(fKeepTrying);

            InterlockedIncrement((PLONG) &m_cDMTRetries);

            fGotMsgType = FALSE;
            hr = HrReGetMessageType(pIMailMsgProperties, pIMessageRouter,
                            &dwMessageType);
            if (FAILED(hr))
                goto Exit;
            fGotMsgType = TRUE;

            continue;  //Try again
        }

        fKeepTrying = FALSE;
        fDMTLocked = TRUE;

        //enqueue the message reference for each destination it is going to
        for (i = 0; i < cQueues; i++)
        {
            if (NULL != rgpdmq[i])
            {
                InterlockedIncrement(&m_cTotalMsgsQueued);

                //enqueue message and assign message type to first enqueue
                hr = rgpdmq[i]->HrEnqueueMsg(pmsgref, !fOnDMQ);
                if (FAILED(hr))
                {
                    InterlockedDecrement(&m_cTotalMsgsQueued);
                    goto Exit;
                }
                fOnDMQ = TRUE;

                //
                //  Check and see if this queue is explicitly routed remote.
                //  It may be a gateway delivery queue.
                //
                if (!fRemote)
                    fRemote = rgpdmq[i]->fIsRemote();
            }
            else
            {
                fLocal = TRUE;
            }
        }


        _ASSERT(fDMTLocked);
        m_dmt.ReleaseDMTShareLock();
        fDMTLocked = FALSE;

        if (fLocal) //kick off local delivery
        {
            QueueMsgForLocalDelivery(pmsgref, FALSE);
        }
    }

  Exit:

    if (fDMTLocked)
    {
        m_dmt.ReleaseDMTShareLock();
        fDMTLocked = FALSE;
    }

    // Check and process any special queues in the DMT
    if (fRoutingLock && fLocked)
        m_dmt.ProcessSpecialLinks(m_dwDelayExpireMinutes, TRUE);

    //
    // Must Release IMessageRouter before starting shutdown since the
    // IMessageRouter sink may have a reference to us (via
    // IRouterReset)
    //
    if (NULL != pIMessageRouter)
    {
        if (!fOnDMQ && fGotMsgType) //we have a reference to this message type
        {
            hrTmp = pIMessageRouter->ReleaseMessageType(dwMessageType, 1);
            _ASSERT(SUCCEEDED(hrTmp));
        }
        pIMessageRouter->Release();
    }

    if (fRoutingLock)
        RoutingShareUnlock();

    if (fLocked)
        ShutdownUnlock();

    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    if (pIRecipList)
        pIRecipList->Release();

    if (NULL != rgpdmq)
        FreePv(rgpdmq);

    if (fRemote && pmsgref)
    {
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingDelivery);
        //msgref needs to decrement the remote count when it is released
        pmsgref->CountMessageInRemoteTotals();
    }

    if (NULL != pmsgref)
    {
        if (FAILED(hr) && (fOnDMQ || fLocal))
        {
            //If we have a msgref and it has been queued, we must
            //wait until all other references are released to retry it
            pmsgref->RetryOnDelete();
            hr = S_OK; //don't let caller retry
        }
        pmsgref->Release();
    }

    //if we did not succeed, msgs is still in pre-routing queue
    if (FAILED(hr))
    {
        fReturn = FALSE;
        //kick off retry if necessary
        if (!m_cRoutingRetriesPending)
        {
            InterlockedIncrement((PLONG) &m_cRoutingRetriesPending);
            SetCallbackTime(RoutingRetry, this, g_cRoutingRetryMinutes);
        }
    }
    else
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingRouting);


    TRACE_COUNTERS;
    TraceFunctLeave();
    return fReturn;
}

//---[ CAQSvrInst::HrAckMsg ]------------------------------------------------
//
//
//  Description:
//      Acknowledge the (un)delivery of a message.  Will call the msgref AckMsg,
//      which will requeue it to the appropriate queues
//  Parameters:
//      pMsgAck     Pointer to Message Ack structure
//      fLocal      TRUE if this is an ack for a local delivery
//  Returns:
//      S_OK on success
//      ERROR_INVALID_HANDLE if the context handle was invalid
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrAckMsg(IN MessageAck *pMsgAck, BOOL fLocal)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrAckMsg");
    HRESULT         hr      = S_OK;
    DWORD           i       = 0; //loop counter
    CDeliveryContext    *pdcntxt = NULL;

    _ASSERT(pMsgAck);
    _ASSERT(pMsgAck->pvMsgContext);

    pdcntxt = (CDeliveryContext *) pMsgAck->pvMsgContext;
    if ((NULL == pdcntxt) || !(pdcntxt->FVerifyHandle(pMsgAck->pIMailMsgProperties)))
    {
        hr = ERROR_INVALID_HANDLE;
        goto Exit;
    }


    if (!fLocal)
    {
        InterlockedIncrement(&m_cMsgsAcked);
        if (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus)
            InterlockedIncrement((PLONG) &m_cMsgsAckedRetry);
    }
    else //local
    {
        if (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus)
            InterlockedIncrement((PLONG) &m_cMsgsAckedRetryLocal);
    }

    hr = pdcntxt->HrAckMessage(pMsgAck);
    if (FAILED(hr))
        goto Exit;

  Exit:
    //clean up all the things we have used here
    if (pdcntxt)
        pdcntxt->Recycle();

    TRACE_COUNTERS;
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HrNotify ]------------------------------------------------------------
//
//
//  Description:
//      Passes notification off to Connection Mangaer
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrNotify(IN CAQStats *paqstats, BOOL fAdd)
{
    HRESULT hr = S_OK;
    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    hr = m_pConnMgr->HrNotify(paqstats, fAdd);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::HrGetInternalDomainInfo ]----------------------------------
//
//
//  Description:
//    Expose ability to get internal Domain Info to internal components
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if match is found
//      AQUEUE_E_INVALID_DOMAIN if no match is found
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetInternalDomainInfo(
                                    IN  DWORD cbDomainNameLength,
                                    IN  LPSTR szDomainName,
                                    OUT CInternalDomainInfo **ppDomainInfo)
{
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    _ASSERT(CMQ_INIT_DCT & m_dwInitMask);

    hr = m_dct.HrGetInternalDomainInfo(cbDomainNameLength, szDomainName, ppDomainInfo);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::HrGetDefaultDomainInfo ]----------------------------
//
//
//  Description:
//    Expose ability to get internal default Domain Info to internal components
//  Parameters:
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if found
//      AQUEUE_E_INVALID_DOMAIN if not found
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetDefaultDomainInfo(
                                    OUT CInternalDomainInfo **ppDomainInfo)
{
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    _ASSERT(CMQ_INIT_DCT & m_dwInitMask);

    hr = m_dct.HrGetDefaultDomainInfo(ppDomainInfo);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::HrGetDomainEntry ]----------------------------------------
//
//
//  Description:
//      Get Domain Entry
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      OUT     ppdentry                Domain Entry for domain (from DMT)
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrGetDomainEntry(IN  DWORD cbDomainNameLength,
                             IN  LPSTR szDomainName,
                             OUT CDomainEntry **ppdentry)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(ppdentry);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    hr = m_dmt.HrGetDomainEntry(cbDomainNameLength, szDomainName, ppdentry);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fLocked)
        ShutdownUnlock();

    return hr;
}

//---[ CAQSvrInst::HrIterateDMTSubDomains ]----------------------------------------
//
//
//  Description:
//      Get Domain Entry
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      IN      pfn                     Iterator function
//      IN      pvcontext               Context passed to each call
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//--------------------------------------------------------------------------------

HRESULT CAQSvrInst::HrIterateDMTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DOMAIN_STRING strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(pfn);
    _ASSERT(pvContext);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    strDomain.Length = (USHORT) cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) cbDomainNameLength;
    strDomain.Buffer = szDomainName;

    hr = m_dmt.HrIterateOverSubDomains(&strDomain, pfn,pvContext);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fLocked)
        ShutdownUnlock();

    return hr;
}

//---[ CAQSvrInst::HrIterateDMTSubDomains ]----------------------------------------
//
//
//  Description:
//      Get Domain Entry
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      IN      pfn                     Iterator function
//      IN      pvcontext               Context passed to each call
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//--------------------------------------------------------------------------------
HRESULT CAQSvrInst::HrIterateDCTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DOMAIN_STRING strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(pfn);
    _ASSERT(pvContext);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    strDomain.Length = (USHORT) cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) cbDomainNameLength;
    strDomain.Buffer = szDomainName;

    hr = m_dct.HrIterateOverSubDomains(&strDomain, pfn,pvContext);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fLocked)
        ShutdownUnlock();

    return hr;
}


//---[ CAQSvrInst::HrTriggerGetMessageRouter ]--------------------------------------
//
//
//  Description:
//      Wrapper function that signals the MAIL_TRANSPORT_ON_GET_ROUTER_EVENT
//  Parameters:
//      IN  pIMailMsgProperties       - IMailMsgProperties to get
//      OUT pIMessageRouter
//
//  Returns:
//
//  History:
//      5/20/98 - MikeSwa Created
//      jstamerj 1998/07/10 18:30:41: Implemented Server event
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerGetMessageRouter(
            IN  IMailMsgProperties *pIMailMsgProperties,
            OUT IMessageRouter     **ppIMessageRouter)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::HrTriggerGetMessageRouter");
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    _ASSERT(ppIMessageRouter);
    _ASSERT(pIMailMsgProperties);
    _ASSERT(m_pIMessageRouterDefault);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    if(m_pISMTPServer) {

        EVENTPARAMS_ROUTER EventParams;
        //
        // Initialiez EventParams
        //
        EventParams.dwVirtualServerID = m_dwServerInstance;
        EventParams.pIMailMsgProperties = pIMailMsgProperties;
        EventParams.pIMessageRouter = NULL;
        EventParams.pIRouterReset = m_pIRouterReset;
        EventParams.pIRoutingEngineDefault = this;

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT,
            &EventParams);
        if(SUCCEEDED(hr)) {
            if(EventParams.pIMessageRouter) {
                //
                // The implementor of GetMessageRouter returned
                // IMessageRouter with a refcount of one for us
                //
                *ppIMessageRouter = EventParams.pIMessageRouter;
            } else {
                //
                // The server event succeeded, but no sink supplied an
                // IMessageRouter (including default functionality)
                //
                hr = E_FAIL;
            }
        }
    } else {

        ErrorTrace((LPARAM)this, "Unable to trigger event to GetMessageRouter; using default");
        //
        // Try calling our default (builtin) GetMessageRouter
        //
        hr = GetMessageRouter(
            pIMailMsgProperties,          //IN  IMsg
            NULL,               //IN  pIMessageRouter (Current)
            ppIMessageRouter);  //OUT ppIMessageRouter (New)
    }

  Exit:

    if (fLocked)
        ShutdownUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//---[ CAQSvrInst::HrTriggerLogEvent ]-----------------------------------------
//
//
//  Description:
//      Wrapper function that signals the SMTP_LOG_EVENT event
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerLogEvent(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::HrTriggerLogEvent");
    HRESULT hr = S_OK;
    if (m_pISMTPServerEx) {
        hr = m_pISMTPServerEx->TriggerLogEvent(
                                    idMessage,
                                    idCategory,
                                    cSubstrings,
                                    rgszSubstrings,
                                    wType,
                                    errCode,
                                    iDebugLevel,
                                    szKey,
                                    dwOptions,
                                    iMessageString,
                                    hModule);
    } else {
      //
      //  If we do not have at least W2K SP2... we will not have this
      //  interface.
      //
      ErrorTrace((LPARAM) this, 
        "Need W2KSP2: Unable to log event %d with erCode %d");
    }
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//---[ CAQSvrInst::HrTriggerInitRouter ]---------------------------------------
//
//
//  Description:
//      Wrapper function that signals the MAIL_TRANSPORT_ON_GET_ROUTER_EVENT
//      but only has it create a new router object
//  Parameters:
//      none
//
//  Returns:
//
//  History:
//      5/20/98 - MikeSwa Created
//      jstamerj 1998/07/10 18:30:41: Implemented Server event
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerInitRouter() {
    TraceFunctEnter("CAQSvrInst::HrTriggerInitRouter");
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    if (m_pISMTPServer) {

        EVENTPARAMS_ROUTER EventParams;
        //
        // Initialiez EventParams
        //
        EventParams.dwVirtualServerID = m_dwServerInstance;
        EventParams.pIMailMsgProperties = NULL;
        EventParams.pIMessageRouter = NULL;
        EventParams.pIRouterReset = m_pIRouterReset;
        EventParams.pIRoutingEngineDefault = NULL;

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT,
            &EventParams);
    } else {
        hr = S_OK;
    }

  Exit:

    if (fLocked)
        ShutdownUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//---[ CAQSvrInst::QueryInterface ]------------------------------------------
//
//
//  Description:
//      QueryInterface for IAdvQueue
//  Parameters:
//
//  Returns:
//      S_OK on success
//
//  Notes:
//      This implementation makes it possible for any server component to get
//      the IAdvQueueConfig interface.
//
//  History:
//      7/29/98 - MikeSwa Modified (added IAdvQueueDomainType)
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IAdvQueue *>(this);
    }
    else if (IID_IAdvQueue == riid)
    {
        *ppvObj = static_cast<IAdvQueue *>(this);
    }
    else if (IID_IAdvQueueConfig == riid)
    {
        *ppvObj = static_cast<IAdvQueueConfig *>(this);
    }
    else if (IID_IAdvQueueDomainType == riid)
    {
        *ppvObj = static_cast<IAdvQueueDomainType *>(this);
    }
    else if (IID_IAdvQueueAdmin == riid)
    {
        *ppvObj = static_cast<IAdvQueueAdmin *>(this);
    }
    else if (IID_IMailTransportRouterSetLinkState == riid)
    {
        *ppvObj = static_cast<IMailTransportRouterSetLinkState *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CAQSvrInst::SubmitMessage ]---------------------------------------------
//
//
//  Description:
//      External function to submit messages for delivery
//  Parameters:
//      pIMailMsgProperties         Msg to submit for delivery
//  Returns:
//      S_OK always
//  History:
//      10/7/1999 - MikeSwa Moved from inline function
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SubmitMessage(IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SubmitMessage");
    HRESULT hr = S_OK;

    if (NULL == pIMailMsgProperties)
    {
        ErrorTrace((LPARAM)NULL,
                    "SubmitMessage called with NULL pIMailMsgProperties");
        return E_INVALIDARG;
    }

    InterlockedIncrement((PLONG) &m_cTotalExternalMsgsSubmitted);
    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingSubmit);

    hr = m_asyncqPreSubmissionQueue.HrQueueRequest(
                                pIMailMsgProperties, FALSE,
                                cCountMsgsForHandleThrottling(pIMailMsgProperties));

    if (FAILED(hr))
    {
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingSubmit);
        HandleAQFailure(AQ_FAILURE_INTERNAL_ASYNCQ, hr, pIMailMsgProperties);
    }

    TraceFunctLeave();
    return S_OK;
}

//---[ CAQSvrInst::HrInternalSubmitMessage ]-----------------------------------
//
//
//  Description:
//      Implements IAdvQueue::SubmitMessage
//  Parameters:
//      pIMailMsgProperties... Messaage to queue
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrInternalSubmitMessage(
                      IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties,
                      "CAQSvrInst::SubmitMessage");
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    HRESULT hr = S_OK;
    DWORD dwMsgStatus = MP_STATUS_SUCCESS;
    EVENTPARAMS_SUBMISSION Params;
    FILETIME ftDeferred;
    DWORD   cbProp = 0;
    DWORD   dwContext = 0;

    _ASSERT(pIMailMsgProperties);

    if (NULL == pIMailMsgProperties)
    {
        ErrorTrace((LPARAM)NULL,
                   "SubmitMessage called with NULL pIMailMsgProperties");
        return E_INVALIDARG;
    }

    //Check and see if we need to request a retry for failed msgs
    m_fmq.StartProcessingIfNecessary();

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_DEFERRED_DELIVERY_FILETIME,
                                          sizeof(FILETIME), &cbProp,
                                          (BYTE *) &ftDeferred);

    if (SUCCEEDED(hr) && !fInPast(&ftDeferred, &dwContext))
    {
        //Defer delivery until a later time if deferred delivery time is
        //present, and in the past
        hr = S_OK;
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingDeferredDelivery);
        m_defq.Enqueue(pIMailMsgProperties, &ftDeferred);
        goto Exit;
    }

    // Set Expiry times for message
    hr = HrSetMessageExpiry(pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
                   "ERROR: Unable to stamp expire times on message - hr 0x%08x",
                   hr);
        return hr;
    }

    InterlockedIncrement((PLONG) &m_cTotalMsgsSubmitted);

    //
    // Set the message status (if currently unset)
    //
    hr = pIMailMsgProperties->GetDWORD(
        IMMPID_MP_MESSAGE_STATUS,
        &dwMsgStatus);

    if( (hr == MAILMSG_E_PROPNOTFOUND) ||
        (g_fResetMessageStatus) )
    {
        //
        // Initialize the message status
        //
        hr = pIMailMsgProperties->PutDWORD(
            IMMPID_MP_MESSAGE_STATUS,
            MP_STATUS_SUCCESS);

        dwMsgStatus = MP_STATUS_SUCCESS;
    }

    //
    //$$TODO: Jump from here to whatever state dwMsgStatus indicates
    //
        MSG_TRACK_INFO msgTrackInfo;
        ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
        msgTrackInfo.dwEventId = MTE_BEGIN_SUBMIT_MESSAGE;
        m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    //
    // AddRef this object here; release in completion
    //
    AddRef();

    Params.pIMailMsgProperties = pIMailMsgProperties;
    Params.pfnCompletion = MailTransport_Completion_SubmitMessage;
    Params.pCCatMsgQueue = this;

    pIMailMsgProperties->AddRef();

    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingSubmitEvent);
    TRACE_COUNTERS;

    //
    // Call server event if we can and if dwMsgStatus does not
    // indicate the mssage has already been submitted
    //
    if(SUCCEEDED(hr) &&
       (m_pISMTPServer) &&
       (dwMsgStatus < MP_STATUS_SUBMITTED))
    {
        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_SUBMISSION_EVENT,
            &Params);

        DebugTrace((LPARAM)pIMailMsgProperties,
                   "TriggerServerEvent returned hr %08lx", hr);
    }

    //
    // If TriggerServerEvent returned an error OR m_pISMTPServer is
    // null, or the message was already submitted, call the event
    // completion routine directly
    //
    if((m_pISMTPServer == NULL) ||
       FAILED(hr) ||
       (dwMsgStatus >= MP_STATUS_SUBMITTED))
    {
        DebugTrace((LPARAM)this, "Skipping the submission event");

        // Call the SEO Dispatcher completion routine directly so we
        // don't loose this mail...
        hr = SubmissionEventCompletion(S_OK, &Params);
    }

    //
    // SEO dispatcher will call the completion routine
    // (MailTransport_Completion_SubmitMessage) regardless wether or
    // not all the sinks work synchronously or async.  Because of
    // this, this function is now done.
    //

  Exit:
    TraceFunctLeaveEx((LPARAM) pIMailMsgProperties);
    return hr;
}

//---[ CAQSvrInst::HandleFailedMessage ]--------------------------------------
//
//
//  Description:
//      Handles a failed message from SMTP... usually by NDRing the message or
//      by treating the message as badmail.
//
//      NOTE: Message or input file will be deleted by this operation.
//  Parameters:
//      pIMailMsgProperties     MailMsg that needs to be handles
//      fUseIMailMsgProperties  Use the IMailMsg if set, else use the szFilename,
//      szFileName              use the filename if no msg
//      dwFailureReasons        One of the failure reasons described in aqueue.idl
//      hrFailureCode           Additional information that describes a failure
//                              code encountered by SMTP.
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pIMailMsgProperties is NULL
//  History:
//      7/28/98 - MikeSwa Created
//      10/14/98 - MikeSwa Added filename string for badmail
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::HandleFailedMessage(
                                   IN IMailMsgProperties *pIMailMsgProperties,
                                   IN BOOL fUseIMailMsgProperties,
                                   IN LPSTR szFileName,
                                   IN DWORD dwFailureReason,
                                   IN HRESULT hrFailureCode)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleFailedMessage");
    HRESULT hr = S_OK;
    HRESULT hrBadMail = hrFailureCode;
    DWORD iCurrentDomain = 0;
    DWORD cDomains = 0;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    CDSNParams  dsnparams;
    BOOL  fNDR = TRUE; //FALSE -> Badmail handling

    SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
    dsnparams.dwStartDomain = 0;
    dsnparams.dwDSNActions = DSN_ACTION_FAILURE_ALL;
    dsnparams.pIMailMsgProperties = pIMailMsgProperties;
    dsnparams.hrStatus = hrFailureCode;

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_AQ_FAILED_MESSAGE;
    msgTrackInfo.dwRcptReportStatus = dwFailureReason;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    //
    //  Switch over the various general failure reasons and handle them as
    //  appropriate.
    //
    switch(dwFailureReason)
    {
      case MESSAGE_FAILURE_HOP_COUNT_EXCEEDED:
        //
        //  Attempt to NDR
        //
        _ASSERT(pIMailMsgProperties);
        dsnparams.hrStatus = AQUEUE_E_MAX_HOP_COUNT_EXCEEDED;
        fNDR = TRUE;
        break;

      case MESSAGE_FAILURE_GENERAL:
        //
        //  Attempt to NDR
        //
        fNDR = TRUE;
        break;

      case MESSAGE_FAILURE_CAT:
        //
        //  Attempt to NDR... set DSN context to CAT
        //
        dsnparams.dwDSNActions |= DSN_ACTION_CONTEXT_CAT;
        fNDR = TRUE;
        break;

      case MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE:
        //
        //  Badmail, since we do not have the P1 information needed to badmail
        //
        _ASSERT(szFileName);
        hrBadMail = AQUEUE_E_PICKUP_DIR;
        fNDR = FALSE; //This should be handled as badmail
        break;
      default:
        _ASSERT(0 && "Unhandled failed msg case!");
    }

    if (fNDR && pIMailMsgProperties && fUseIMailMsgProperties)
    {
        hr = HrLinkAllDomains(pIMailMsgProperties);
        if (FAILED(hr))
            goto Exit;

        //Fire DSN Generation event
        hr = HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
        {
            HandleBadMail(pIMailMsgProperties, fUseIMailMsgProperties,
                          szFileName, hrBadMail, FALSE);
            if (dwFailureReason == MESSAGE_FAILURE_GENERAL) {
                InterlockedIncrement((PLONG) &m_cBadmailFailureGeneral);
            } else {
                _ASSERT(dwFailureReason == MESSAGE_FAILURE_HOP_COUNT_EXCEEDED);
                InterlockedIncrement((PLONG) &m_cBadmailHopCountExceeded);
            }
            hr = S_OK; //handled error internally
            ErrorTrace((LPARAM) this, "ERROR: Unable to NDR failed mail - hr 0x%08X", hr);
            goto Exit;
        }
    }
    else
    {
        //Handle as badmail
        HandleBadMail(pIMailMsgProperties, fUseIMailMsgProperties,
                      szFileName, hrBadMail, FALSE);
        InterlockedIncrement((PLONG) &m_cBadmailBadPickupFile);
        _ASSERT(dwFailureReason == MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE);
    }

    if ( fUseIMailMsgProperties && pIMailMsgProperties)
    {
        //Now that we are done... delete mailmsg from system
        hr = HrDeleteIMailMsg(pIMailMsgProperties);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to delete message hr0x%08X", hr);
            //message was actually NDR'd/bad mailed correctly
            hr = S_OK;
        }
    }

  Exit:
    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Completion_SubmitMessage
//
// Synopsis: SEO will call this routine after all sinks for
// SubmitMessage have been handeled
//
// Arguments:
//   pvContext: Context passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980609 16:13:40: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_SubmitMessage(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnter("MailTransport_Completion_SubmitMessage");

    PEVENTPARAMS_SUBMISSION pParams = (PEVENTPARAMS_SUBMISSION) pvContext;
    CAQSvrInst *paqinst = (CAQSvrInst *) pParams->pCCatMsgQueue;

    TraceFunctLeave();
    return paqinst->SubmissionEventCompletion(
        hrStatus,
        pParams);
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::SubmissionEventCompletion
//
// Synopsis: Completion routine called when the submission event is
// done.
//
// Arguments:
//   hrStatus: Status of server event
//   pParams: Context passed into TriggerServereEvent
//
// Returns:
//   Nothing
//
// History:
// jstamerj 980610 12:26:18: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::SubmissionEventCompletion(
    HRESULT hrStatus,
    PEVENTPARAMS_SUBMISSION pParams)
{
    TraceFunctEnterEx((LPARAM)pParams->pIMailMsgProperties,
                      "CAQSvrInst::SubmissionEventCompletion");
    _ASSERT(pParams);
    HRESULT hr;

    DebugTrace((LPARAM)pParams->pIMailMsgProperties,
               "Status of event completion: %08lx", hrStatus);

    InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingSubmitEvent);

    //
    // Update the message status
    //
    hr = SetNextMsgStatus(MP_STATUS_SUBMITTED, pParams->pIMailMsgProperties);
    if (hr == S_OK) //anything else implies that the message has been handled
    {
        // Only trigger the precat event if message was not turfed.
        TriggerPreCategorizeEvent(pParams->pIMailMsgProperties);
    }

    //
    // Release refernce added in SubmitMessage
    //
    Release();

    pParams->pIMailMsgProperties->Release();

    //
    // pParams is part of a larger allocation that will be released by
    // SEO Dispatcher code
    //

    TraceFunctLeave();
    return S_OK;
}


//---[ CAQSvrInst::SubmitMessageToCategorizer ]-------------------------------------------
//
//
//  Description:
//      Implements IAdvQueue::SubmitMessageToCategorizer
//  Parameters:
//      pIMailMsgProperties... Messaage to queue
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SubmitMessageToCategorizer(
          IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "CAQSvrInst::SubmitMessageToCategorizer");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    BOOL fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_SUBMIT_MESSAGE_TO_CAT;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    fLocked = TRUE;

    cIncMsgsInSystem();

    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingCat);
    TRACE_COUNTERS;

    hr = m_asyncqPreCatQueue.HrQueueRequest(pIMailMsgProperties, FALSE,
                                            cCountMsgsForHandleThrottling(pIMailMsgProperties));
    if (FAILED(hr))
    {
        HandleAQFailure(AQ_FAILURE_PRECAT_RETRY, E_FAIL, pIMailMsgProperties);
        goto Exit;
    }

  Exit:
    if(fLocked)
    {
        ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::SetNextMsgStatus ]------------------------------------------
//
//
//  Description:
//      Used by the event glue code to set the next message status.  Will turf
//      or badmail a message if the status indicates that is the requested
//      action.
//  Parameters:
//      IN  dwCurrentStatus         The current status (according to *current*
//                                  place in event pipeline).  Valid values are
//                                      MP_STATUS_SUBMITTED
//                                      MP_STATUS_CATEGORIZED
//      IN  pIMailMsgProperties     The message
//      OUT pdwNewStatus            The new status
//  Returns:
//      S_OK    Success
//      S_FALSE Success, but message has been handled.
//  History:
//      11/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SetNextMsgStatus(
                             IN  DWORD dwCurrentStatus,
                             IN  IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SetNextMsgStatus");
    HRESULT hr = S_OK;
    DWORD   dwActualStatus = 0;
    DWORD   dwNewStatus = 0;
    BOOL    fHandled = FALSE;

    _ASSERT(pIMailMsgProperties);
    _ASSERT((MP_STATUS_SUBMITTED == dwCurrentStatus) || (MP_STATUS_CATEGORIZED == dwCurrentStatus));

    hr = pIMailMsgProperties->GetDWORD(IMMPID_MP_MESSAGE_STATUS, &dwActualStatus);

    if (FAILED(hr))
        dwActualStatus = dwCurrentStatus;

    if (MP_STATUS_SUCCESS == dwActualStatus)
        dwActualStatus = dwCurrentStatus;

    switch(dwActualStatus)
    {
        case MP_STATUS_BAD_MAIL:
            HandleBadMail(pIMailMsgProperties, TRUE, NULL, E_FAIL, FALSE);
            InterlockedIncrement((PLONG) &m_cBadmailEvent);
            //OK... now continue as if message was aborted
        case MP_STATUS_ABORT_DELIVERY:
            fHandled = TRUE;
            HrDeleteIMailMsg(pIMailMsgProperties);
            break;

        case MP_STATUS_ABANDON_DELIVERY:
            //In this case, we will leave the message in the queue directory
            //until restart & reset the state so it goes through the entire
            //pipeline.   The idea is that someone can write a sink to detect
            //a non-supported state (like CAT disabled in an Exchange install)
            //that will abandon delivery of the messages and log an event.
            //The admin can fix the problem and restart smtpsvc.  Once
            //the service is restarted... the messages are magically submitted
            //and re-categorized.

            fHandled = TRUE;
            pIMailMsgProperties->PutDWORD(IMMPID_MP_MESSAGE_STATUS,
                                          MP_STATUS_SUCCESS);
            break;

        case MP_STATUS_CATEGORIZED:
            //Don't change status from categorized to something else
            dwNewStatus = dwActualStatus;
            DebugTrace((LPARAM) this, "Message 0x%x  has already been categorized",
                        pIMailMsgProperties);
            break;

        default:  //simply move on to the next expected status
            dwNewStatus = dwCurrentStatus;
    }

    if (!fHandled)
    {
        pIMailMsgProperties->PutDWORD(IMMPID_MP_MESSAGE_STATUS, dwNewStatus);

        //callers will not be able to do anything about a failure to write status
        hr = S_OK;
    }
    else
    {
        DecMsgsInSystem();
        hr = S_FALSE;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::fPreCatQueueCompletion ]-----------------------------------
//
//
//  Description:
//      Completion routine for Pre-Categorization queue
//  Parameters:
//      pIMailMsgProperties - MailMsg to give to categorization
//  Returns:
//      TRUE    if successful
//      FALSE   if message needs to be re-requeue
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fPreCatQueueCompletion(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::fPreCatQueueCompletion");
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    HRESULT hr = S_OK;
    HRESULT hrCatCompletion;
    IUnknown *pIUnknown = NULL;
    BOOL fRet = TRUE;
    BOOL fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = S_OK; //we cannot retry on shutdown
        goto Exit;
    }

    fLocked = TRUE;

    hr = pIMailMsgProperties->QueryInterface(IID_IUnknown, (PVOID *) &pIUnknown);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IUknown Failed!");
    _ASSERT(pIUnknown);

    InterlockedIncrement((PLONG) &m_cCatMsgCalled);
    m_asyncqPreCatQueue.IncPendingAsyncCompletions();
    hr = CatMsg(m_hCat, pIUnknown,(PFNCAT_COMPLETION)CAQSvrInst::CatCompletion,
                       (LPVOID) this);

    if (FAILED(hr))
    {
        if(hr == CAT_E_RETRY)
        {
            //
            // Return false so that this message will be re-queued
            //
            fRet =  FALSE;
            InterlockedDecrement((PLONG) &m_cCatMsgCalled);
            m_asyncqPreCatQueue.DecPendingAsyncCompletions();

            //
            // Schedule a time to retry the messages
            //
            ScheduleCatRetry();
        }
        else
        {
            //
            // Return true since this is not a retryable error
            // Call CatCompletion to handle the non-retryable error (log an event, etc)
            //
            hrCatCompletion = CatCompletion(
                hr,                 // hrCatResult
                (LPVOID) this,      // pContext
                pIUnknown,          // pIMsg
                NULL);              // rgpIMsg

            _ASSERT(SUCCEEDED(hrCatCompletion));
        }
    }

  Exit:
    if (pIUnknown)
        pIUnknown->Release();

    if(fLocked)
    {
        ShutdownUnlock();
    }

    TraceFunctLeave();
    return fRet;
}

//---[ CAQSvrInst::SetConfigInfo ]--------------------------------------------
//
//
//  Description:
//      Implements IAdvQueueConfig::SetConfigInfo
//  Parameters:
//      IN  pAQConfigInfo   Ptr to config info structure
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetConfigInfo(IN AQConfigInfo *pAQConfigInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SetConfigInfo");
    HRESULT hr = S_OK;

    if (!pAQConfigInfo)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //check version of structure
    if (!pAQConfigInfo->cbVersion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }


    //we must be setting something
    if (!(pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_ALL))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }


    m_slPrivateData.ExclusiveLock();


    //Retry related config data
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwFirstRetrySeconds))
    {
        m_dwFirstTierRetrySeconds = pAQConfigInfo->dwFirstRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_EXPIRE_DELAY &&
        MEMBER_OK(pAQConfigInfo, dwDelayExpireMinutes))
    {
        m_dwDelayExpireMinutes = pAQConfigInfo->dwDelayExpireMinutes;
        if (m_dwDelayExpireMinutes == 0) {
            //Default to g_dwRetriesBeforeDelay* retry interval
            m_dwDelayExpireMinutes =
                g_dwRetriesBeforeDelay*m_dwFirstTierRetrySeconds/60;
        }
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_EXPIRE_NDR &&
        MEMBER_OK(pAQConfigInfo, dwNDRExpireMinutes))
    {
        m_dwNDRExpireMinutes = pAQConfigInfo->dwNDRExpireMinutes;
        if (m_dwNDRExpireMinutes == 0) {
            //Default to g_dwDelayIntervalsBeforeNDR* delay expiration
            m_dwNDRExpireMinutes =
                g_dwDelayIntervalsBeforeNDR*m_dwDelayExpireMinutes;
        }
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_LOCAL_EXPIRE_DELAY &&
        MEMBER_OK(pAQConfigInfo, dwLocalDelayExpireMinutes))
    {
        DWORD dwOldLocalDelayExpire = m_dwLocalDelayExpireMinutes;
        m_dwLocalDelayExpireMinutes = pAQConfigInfo->dwLocalDelayExpireMinutes;
        if (m_dwLocalDelayExpireMinutes == 0) {
            //Default to g_dwRetriesBeforeDelay* retry interval
            m_dwLocalDelayExpireMinutes =
                g_dwRetriesBeforeDelay*m_dwFirstTierRetrySeconds/60;
        }

    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_LOCAL_EXPIRE_NDR &&
        MEMBER_OK(pAQConfigInfo, dwLocalNDRExpireMinutes))
    {
        m_dwLocalNDRExpireMinutes = pAQConfigInfo->dwLocalNDRExpireMinutes;
        if (m_dwLocalNDRExpireMinutes == 0) {
            //Default to g_dwDelayIntervalsBeforeNDR* delay expiration
            m_dwLocalNDRExpireMinutes =
                g_dwDelayIntervalsBeforeNDR*m_dwLocalDelayExpireMinutes;
        }
    }

    //Handle default local domain
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_DEFAULT_DOMAIN &&
        MEMBER_OK(pAQConfigInfo, szDefaultLocalDomain))
    {
        hr = HrUpdateRefCountedString(&m_prstrDefaultDomain,
                                      pAQConfigInfo->szDefaultLocalDomain);
    }

    //Handle Server FQDN
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_SERVER_FQDN &&
        MEMBER_OK(pAQConfigInfo, szServerFQDN))
    {
        hr = HrUpdateRefCountedString(&m_prstrServerFQDN,
                                      pAQConfigInfo->szServerFQDN);
    }

    //Handle Copy NDR To Address
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_SEND_DSN_TO &&
        MEMBER_OK(pAQConfigInfo, szSendCopyOfNDRToAddress))
    {
        hr = HrUpdateRefCountedString(&m_prstrCopyNDRTo,
                                      pAQConfigInfo->szSendCopyOfNDRToAddress);
    }

    //Handle BadMail config
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_BADMAIL_DIR &&
        MEMBER_OK(pAQConfigInfo, szBadMailDir))
    {
        hr = HrUpdateRefCountedString(&m_prstrBadMailDir,
                                      pAQConfigInfo->szBadMailDir);
    }


    //Get DSN options
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_USE_DSN_OPTIONS &&
        MEMBER_OK(pAQConfigInfo, dwDSNOptions))
    {
        m_dwDSNOptions = pAQConfigInfo->dwDSNOptions;
    }

    //Get Default DSN Language
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_USE_DSN_LANGUAGE &&
        MEMBER_OK(pAQConfigInfo, dwDSNLanguageID))
    {
        m_dwDSNLanguageID = pAQConfigInfo->dwDSNLanguageID;
    }

    m_slPrivateData.ExclusiveUnlock();

    m_pConnMgr->UpdateConfigData(pAQConfigInfo);

    if (INVALID_HANDLE_VALUE != m_hCat)
    {
        HRESULT hrTmp = CatChangeConfig(m_hCat, pAQConfigInfo, m_pISMTPServer, (IAdvQueueDomainType *) this);
        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::SetDomainInfo ]-------------------------------------------
//
//
//  Description:
//      Implements IAdvQueueConfig::SetDomainInfo
//  Parameters:
//      IN pDomainInfo  Per domain config info to store
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetDomainInfo(IN DomainInfo *pDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::SetDomainInfo");
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;
    BOOL    fLocked = FALSE;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    pIntDomainInfo = new CInternalDomainInfo(m_dct.dwGetCurrentVersion());
    if (!pIntDomainInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Create internal Domain Info struct
    hr = pIntDomainInfo->HrInit(pDomainInfo);
    if (FAILED(hr))
        goto Exit;

    hr = m_dct.HrSetInternalDomainInfo(pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    DebugTrace((LPARAM) this, "INFO: Setting domain info flags 0x%08X for domain %s",
        pDomainInfo->dwDomainInfoFlags, pDomainInfo->szDomainName);

  Exit:

    if (fLocked)
        ShutdownUnlock();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::GetDomainInfo ]-------------------------------------------
//
//
//  Description:
//      Implements IAdvQueue::GetDomainInfo... returns information about a
//      requested domain.  To keep from leaking memory, all calls must be paired
//      with a call to ReleaseDomainInfo.  Will handle wildcard matches
//  Parameters:
//      IN     cbDomainNameLength   Length of domain name string
//      IN     szDomainName         Domain Name to look for
//      IN OUT pDomainInfo          Ptr to Domain info structure to fill
//      OUT    ppvDomainContext     Ptr to Domain context used to release mem
//  Returns:
//      S_OK on success
//  History:
//      7/29/98 - MikeSwa Modified (fixed leak of domain info struct)
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetDomainInfo(
                             IN     DWORD cbDomainNameLength,
                             IN     CHAR szDomainName[],
                             IN OUT DomainInfo *pDomainInfo,
                             OUT    DWORD **ppvDomainContext)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;
    BOOL    fLocked = FALSE;

    if (!cbDomainNameLength || !szDomainName || !pDomainInfo || !ppvDomainContext)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    _ASSERT(pDomainInfo->cbVersion >= sizeof(DomainInfo));

    *ppvDomainContext = NULL;


    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    hr = m_dct.HrGetInternalDomainInfo(cbDomainNameLength, szDomainName, &pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIntDomainInfo);

    //copy domain info struct
    memcpy(pDomainInfo, &(pIntDomainInfo->m_DomainInfo), sizeof(DomainInfo));
    *ppvDomainContext = (DWORD *) pIntDomainInfo;

    goto Exit;

  Exit:
    if (fLocked)
        ShutdownUnlock();

    return hr;
}

//---[ CAQSvrInst::ReleaseDomainInfo ]---------------------------------------
//
//
//  Description:
//      Implements IAdvQueueConfig ReleaseDomainInfo... releases data
//      associated with the DomainInfo struct returned by GetDomainInfo.
//  Parameters:
//      IN  pvDomainContext     Context passed
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pvDomainContext is NULL
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ReleaseDomainInfo(IN DWORD *pvDomainContext)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = (CInternalDomainInfo *) pvDomainContext;


    if (!pIntDomainInfo)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pIntDomainInfo->Release();

  Exit:
    return hr;
}

//---[ CAQSvrInst::GetPerfCounters ]---------------------------------------
//
//
//  Description:
//      Method to retrieve AQ perf counters.
//  Parameters:
//      OUT  pAQPerfCounters     Struct to return counters in.
//      OUT  pCatPerfCouneters   Struct to return counters in. (optinal)
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pAQPerfCounters is NULL
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetPerfCounters(
    OUT AQPerfCounters *pAQPerfCounters,
    OUT PCATPERFBLOCK   pCatPerfCounters)
{
    HRESULT hr = S_OK;
    if (!pAQPerfCounters)
        return( E_INVALIDARG );

    _ASSERT((sizeof(AQPerfCounters) == pAQPerfCounters->cbVersion) && "aqueue/smtpsvc dll version mismatch");

    if (sizeof(AQPerfCounters) != pAQPerfCounters->cbVersion)
        return( E_INVALIDARG );

    pAQPerfCounters->cMsgsDeliveredLocal = m_cMsgsDeliveredLocal;
    pAQPerfCounters->cCurrentMsgsPendingCat = m_cCurrentMsgsPendingCat;
    pAQPerfCounters->cCurrentMsgsPendingRemoteDelivery = m_cCurrentMsgsPendingDelivery;
    pAQPerfCounters->cCurrentMsgsPendingLocalDelivery = m_cCurrentMsgsPendingLocal;
    pAQPerfCounters->cCurrentQueueMsgInstances = m_cCurrentQueueMsgInstances;
    pAQPerfCounters->cTotalMsgRemoteSendRetries = m_cMsgsAckedRetry;
    pAQPerfCounters->cTotalMsgLocalRetries = m_cMsgsAckedRetryLocal;
    pAQPerfCounters->cCurrentMsgsPendingLocalRetry = m_cCurrentMsgsPendingLocalRetry;

    //DSN counters
    pAQPerfCounters->cNDRsGenerated = m_cNDRs;
    pAQPerfCounters->cDelayedDSNsGenerated = m_cDelayedDSNs;
    pAQPerfCounters->cDeliveredDSNsGenerated = m_cDeliveredDSNs;
    pAQPerfCounters->cRelayedDSNsGenerated = m_cRelayedDSNs;
    pAQPerfCounters->cExpandedDSNsGenerated = m_cExpandedDSNs;
    pAQPerfCounters->cTotalMsgsTURNETRN = m_cTotalMsgsTURNETRNDelivered;

    //Queue/Link related counters
    pAQPerfCounters->cCurrentRemoteDestQueues = m_cCurrentRemoteDestQueues;
    pAQPerfCounters->cCurrentRemoteNextHopLinks = m_cCurrentRemoteNextHops;

    pAQPerfCounters->cTotalMsgsBadmailNoRecipients = m_cBadmailNoRecipients;
    pAQPerfCounters->cTotalMsgsBadmailHopCountExceeded = m_cBadmailHopCountExceeded;
    pAQPerfCounters->cTotalMsgsBadmailFailureGeneral = m_cBadmailFailureGeneral;
    pAQPerfCounters->cTotalMsgsBadmailBadPickupFile = m_cBadmailBadPickupFile;
    pAQPerfCounters->cTotalMsgsBadmailEvent = m_cBadmailEvent;
    pAQPerfCounters->cTotalMsgsBadmailNdrOfDsn = m_cBadmailNdrOfDsn;
    pAQPerfCounters->cCurrentMsgsPendingRouting = m_cCurrentMsgsPendingRouting;
    pAQPerfCounters->cTotalDSNFailures = m_cTotalDSNFailures;
    pAQPerfCounters->cCurrentMsgsInLocalDelivery = m_cCurrentMsgsInLocalDelivery;

    //
    // The m_cTotalMsgsSubmitted counter counts the number of times
    // HrInternalSubmit msg has been called.  This does not include the
    // presubmission queue, so me need to manually add this count in.
    //
    pAQPerfCounters->cTotalMsgsSubmitted = m_cTotalMsgsSubmitted +
                                           m_cCurrentMsgsPendingSubmit;

    if (fTryShutdownLock()) {
        pAQPerfCounters->cCurrentMsgsPendingUnreachableLink =
            m_dmt.GetCurrentlyUnreachableTotalMsgCount();
        ShutdownUnlock();
    }

    //For now, these counters will be calculated by walking the DMT (same
    //function that determines msgs pending retry).
    pAQPerfCounters->cCurrentRemoteNextHopLinksEnabled = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksPendingRetry = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksPendingScheduling = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksPendingTURNETRN = 0;
    pAQPerfCounters->cCurrentRemoteNextHopLinksFrozenByAdmin = 0;


    //Get Retry remote retry and DSN counters
    pAQPerfCounters->cCurrentMsgsPendingRemoteRetry = 0;
    if (fTryShutdownLock())
    {
        hr = m_dmt.HrIterateOverSubDomains(NULL, CalcDMTPerfCountersIteratorFn,
                                           pAQPerfCounters);

        //will not generate transient errors (we expect success or an empty table
        _ASSERT(SUCCEEDED(hr) || (DOMHASH_E_NO_SUCH_DOMAIN == hr));

        if((m_hCat != INVALID_HANDLE_VALUE) && (pCatPerfCounters))
            hr = CatGetPerfCounters(m_hCat, pCatPerfCounters);

        _ASSERT(SUCCEEDED(hr));

        ShutdownUnlock();
    }

    //save values in CAQSvrInst, so we can dump them in the debugger
    m_cCurrentRemoteNextHopsEnabled = pAQPerfCounters->cCurrentRemoteNextHopLinksEnabled;
    m_cCurrentRemoteNextHopsPendingRetry = pAQPerfCounters->cCurrentRemoteNextHopLinksPendingRetry;
    m_cCurrentRemoteNextHopsPendingSchedule = pAQPerfCounters->cCurrentRemoteNextHopLinksPendingScheduling;
    m_cCurrentRemoteNextHopsFrozenByAdmin = pAQPerfCounters->cCurrentRemoteNextHopLinksFrozenByAdmin;

    return( S_OK );
}

//---[ CAQSvrInst::ResetPerfCounters ]---------------------------------------
//
//
//  Description:
//      Method to reset AQ perf counters to 0.
//  Parameters:
//      None
//  Returns:
//      S_OK on success
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ResetPerfCounters()
{
    m_cTotalMsgsQueued = 0;
    m_cTotalMsgsSubmitted = 0;
    m_cMsgsAcked = 0;
    m_cMsgsAckedRetry = 0;
    m_cMsgsDeliveredLocal = 0;
    m_cMsgsAckedRetryLocal = 0;
    m_cTotalMsgsTURNETRNDelivered = 0;

    //clear DSN counters
    m_cDelayedDSNs = 0;
    m_cNDRs = 0;
    m_cDeliveredDSNs = 0;
    m_cRelayedDSNs = 0;
    m_cExpandedDSNs = 0;

    return( S_OK );
}


//---[ CAQSvrInst::StartConfigUpdate() ]---------------------------------------
//
//
//  Description:
//      Implements IAQConfig::StartConfigUpdate() which is used to signal that
//      all of the domain information is about to be updated.
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN on shutdown
//  History:
//      9/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::StartConfigUpdate()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::StartConfigUpdate");
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
    }
    else
    {
        m_dct.StartConfigUpdate();
        ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::FinishConfigUpdate ]----------------------------------------
//
//
//  Description:
//      Implements IAQConfig::FinishConfigUpdate() which is used to signal that
//      signal that all of the domain information has been updated.  This will
//      cause us to walk through the DomainConfigTable and remove any domain
//      config info that has not been updated (ie - a domain that has been
//      deleted).
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if called while shutdown is in progress.
//  History:
//      9/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::FinishConfigUpdate()
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::FinishConfigUpdate");
    HRESULT hr = S_OK;

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
    }
    else
    {
        m_dct.FinishConfigUpdate();

        //Reroute everything
        //$$REVIEW - should we re-route on metabase changes?
        ResetRoutes(RESET_NEXT_HOPS);

        //Important configuration data may have changed... kick connmgr
        m_pConnMgr->KickConnections();

        ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::TriggerPostCategorizeEvent
//
// Synopsis: Triggers post categorization event
//
// Arguments:
//   pIMsg: MailMsg for event or NULL
//   rgpIMsg: NULL or a null terminated array of mailmsg pointers
//
//   NOTE: pIMsg or rgpIMsg must be NULL, but neither can be null
//   (exclusive OR)
//
// Returns:
//    -
//
// History:
// jstamerj 980616 20:43:08: Created.
//      8/25/98 - MikeSwa Modified - removed return code
//
//-------------------------------------------------------------
void CAQSvrInst::TriggerPostCategorizeEvent(
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    TraceFunctEnterEx((LPARAM)this,
                      "CAQSvrInst::TriggerPostCategorizeEvent");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    IMailMsgProperties *pIMailMsgProperties = NULL;

    if(pIMsg)
    {
        hr = TriggerPostCategorizeEventOneMsg(pIMsg);
        if (FAILED(hr))
        {
            hrTmp = pIMsg->QueryInterface(IID_IMailMsgProperties,
                                      (void **) &pIMailMsgProperties);
            _ASSERT(SUCCEEDED(hrTmp) && "Could not QI for IMailMsgProperties");
            if (FAILED(hrTmp))
                LogAQEvent(AQ_FAILURE_POSTCAT_EVENT, NULL, NULL, NULL);
            else
            {
                HandleAQFailure(AQ_FAILURE_POSTCAT_EVENT, hr,
                                pIMailMsgProperties);
                pIMailMsgProperties->Release();
                pIMailMsgProperties = NULL;
            }
            DecMsgsInSystem(FALSE, FALSE);
            hr = S_OK;
        }
    }
    else
    {
        _ASSERT(rgpIMsg);
        IUnknown **ppIMsgCurrent = rgpIMsg;
        DecMsgsInSystem(FALSE, FALSE);

        while(SUCCEEDED(hr) && (*ppIMsgCurrent))
        {
            hr = TriggerPostCategorizeEventOneMsg(
                *ppIMsgCurrent);
            ppIMsgCurrent++;
            if (FAILED(hr))
            {
                hrTmp = (*ppIMsgCurrent)->QueryInterface(IID_IMailMsgProperties,
                                          (void **) &pIMailMsgProperties);
                _ASSERT(SUCCEEDED(hrTmp) && "Could not QI for IMailMsgProperties");
                if (FAILED(hrTmp))
                    LogAQEvent(AQ_FAILURE_POSTCAT_EVENT, NULL, NULL, NULL);
                else
                {
                    HandleAQFailure(AQ_FAILURE_POSTCAT_EVENT, hr,
                                    pIMailMsgProperties);
                    pIMailMsgProperties->Release();
                    pIMailMsgProperties = NULL;
                }
                hr = S_OK;
            }
            else
            {
                cIncMsgsInSystem();
            }
        }
    }
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::TriggerPostCategorizeEventOneMsg
//
// Synopsis: Triggers ONE server event for one mailmsg
//
// Arguments:
//   pIMsg - mailmsg
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980616 21:26:30: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::TriggerPostCategorizeEventOneMsg(
    IUnknown *pIMsg)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::TriggerPostCategorizeEventOneMsg");
    HRESULT hr;

    //
    // trigger one event
    // this is an async event
    //
    EVENTPARAMS_POSTCATEGORIZE Params;

    // Setup pParams
    hr = pIMsg->QueryInterface(IID_IMailMsgProperties,
                               (PVOID *)&(Params.pIMailMsgProperties));
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "QI failed with error %08lx",
                   hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }
    Params.pfnCompletion = MailTransport_Completion_PostCategorization;
    Params.pCCatMsgQueue = (PVOID) this;

    //
    // Addref here, release in completion
    //
    AddRef();

    //
    // keep a count of messages in the post-cat event
    //
    InterlockedIncrement((LPLONG) &m_cCurrentMsgsPendingPostCatEvent);

    if(m_pISMTPServer) {
        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT,
            &Params);
        DebugTrace((LPARAM)this, "TriggerServerEvent returned hr %08lx", hr);

    }

    if((m_pISMTPServer == NULL) || (FAILED(hr))) {

        ErrorTrace((LPARAM)this,
                   "Unable to dispatch server event; calling completion routine directly");
        //
        // Call completion routine directly
        //
        TraceFunctLeaveEx((LPARAM)this);
        return PostCategorizationEventCompletion(S_OK, &Params);
    }
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Completion_PostCategorization
//
// Synopsis: SEO will call this routine after all sinks for
// OnPostCategoriztion have been handeled
//
// Arguments:
//   pvContext: Context passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980609 16:13:40: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_PostCategorization(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnter("MailTransport_Completion_PostCategorization");

    PEVENTPARAMS_POSTCATEGORIZE pParams = (PEVENTPARAMS_POSTCATEGORIZE) pvContext;
    CAQSvrInst *paqinst = (CAQSvrInst *) pParams->pCCatMsgQueue;

    TraceFunctLeave();
    return paqinst->PostCategorizationEventCompletion(
        hrStatus,
        pParams);
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::PostCategorizationEventCompletion
//
// Synopsis: Called on the completion side of OnPostCategorization
//
// Arguments:
//   hrStatus: status of server event
//   pParams: context structure passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980616 21:33:05: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::PostCategorizationEventCompletion(
    HRESULT hrStatus,
    PEVENTPARAMS_POSTCATEGORIZE pParams)
{
    TraceFunctEnterEx((LPARAM)this,
                      "CAQSvrInst::PostCategorizationEventCompletion");
    DebugTrace((LPARAM)this, "hrStatus is %08lx", hrStatus);

    HRESULT hr;

    //
    // Decrease count of msgs in post-cat event
    //
    InterlockedDecrement((LPLONG) &m_cCurrentMsgsPendingPostCatEvent);


    hr = SetNextMsgStatus(MP_STATUS_CATEGORIZED, pParams->pIMailMsgProperties);
    //See if this message has been "handled"
    if (S_FALSE == hr)
    {
        //Message has been "handled"... do not try to route it
        hr = S_OK;
    }
    else
    {

        //Increment counters and put msg into the pre-routing queue
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingRouting);
        hr = m_asyncqPreRoutingQueue.HrQueueRequest(pParams->pIMailMsgProperties,
                              FALSE, cCountMsgsForHandleThrottling(pParams->pIMailMsgProperties));
        if (FAILED(hr))
        {
            HandleAQFailure(AQ_FAILURE_PREROUTING_FAILED, hr, pParams->pIMailMsgProperties);
            ErrorTrace((LPARAM)this, "fRouteAndQueueMsg failed with hr %08lx", hr);
            DecMsgsInSystem(FALSE, FALSE);

            //don't passback shutdown errors in completions routines
            if (AQUEUE_E_SHUTDOWN == hr)
                hr = S_OK;
        }
    }

    //
    // Release mailmsg reference added in TriggerPostCategorizerEventOneMsg
    //
    pParams->pIMailMsgProperties->Release();

    //
    // Release reference to this object added in
    // TriggerPostCategorizerEventOneMsg
    //
    Release();
    TraceFunctLeaveEx((LPARAM)this);
    return S_OK; //we should always handle failures internally here
}

//---[ CatCompletion ]---------------------------------------------------------
//
//
//  Description:
//      Message Categoriztion Completion function
//  Parameters:
//      hrCatResult     HRESULT of categorization attempt
//      pContext        Context as passed into MsgCat
//      pIMsg           Single categorized IMsg (if not bifurcated)
//      rgpIMsg         NULL terminated array of IMsg's (bifurcated)
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::CatCompletion(HRESULT hrCatResult, PVOID pContext,
                      IUnknown *pIMsg,
                      IUnknown **rgpIMsg)
{
    TraceFunctEnterEx((LPARAM) pIMsg, "CatCompletion");
    HRESULT hr = S_OK;
    CAQSvrInst *paqinst = (CAQSvrInst *) pContext;
    IMailMsgProperties *pIMailMsg = NULL;
    IMailMsgQueueMgmt  *pIMailMsgQM = NULL;
    _ASSERT(paqinst);
    _ASSERT(CATMSGQ_SIG == paqinst->m_dwSignature);

    //Increment count of times CatCompletion called
    InterlockedIncrement((PLONG) &(paqinst->m_cCatCompletionCalled));
    paqinst->m_asyncqPreCatQueue.DecPendingAsyncCompletions();


    //make sure Cat is returning an HRESULT
    _ASSERT(!hrCatResult || (hrCatResult & 0xFFFF0000));

    if (SUCCEEDED(hrCatResult))
    {
        //
        // Kick off post categorize event
        //
        InterlockedDecrement((PLONG) &(paqinst->m_cCurrentMsgsPendingCat));
        paqinst->TriggerPostCategorizeEvent(pIMsg, rgpIMsg);
    }
    else if (FAILED(hrCatResult) &&
             (CAT_E_RETRY == hrCatResult))
    {
        //MsgCat has some re-tryable error...
        //stick it back in the queue and retry later
        DebugTrace((LPARAM) paqinst, "INFO: MsgCat had tmp failure - hr 0x%08X", hr);

        //
        //  Adjust counters... they we be adjusted correctly per msg in
        //  HandleCatRetryOneMessage
        //
        InterlockedDecrement((PLONG) &(paqinst->m_cCurrentMsgsPendingCat));
        paqinst->DecMsgsInSystem(FALSE, FALSE);

        if(pIMsg)
        {
            paqinst->HandleCatRetryOneMessage(pIMsg);
        }
        else
        {
            _ASSERT(rgpIMsg);
            IUnknown **ppIMsgCurrent = rgpIMsg;

            while(*ppIMsgCurrent)
            {
                paqinst->HandleCatRetryOneMessage(*ppIMsgCurrent);
                ppIMsgCurrent++;
            }
        }
    }
    else
    {
        _ASSERT(pIMsg && rgpIMsg == NULL && "Message bifurcated inspite of non-retryable cat error");
        paqinst->HandleCatFailure(pIMsg, hrCatResult);
    }   // Non retryable error

    TraceFunctLeaveEx((LPARAM)paqinst);
    return S_OK; //all errors should be handled internally
}



//---[ CAQSvrInst::HandleCatRetryOneMessage ]----------------------------------
//
//
//  Description:
//      Handles cat retry for a single message
//  Parameters:
//      pIUnknown        IUnknown for the message to retry
//  Returns:
//      -
//  History:
//      4/13/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleCatRetryOneMessage(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleCatRetryOneMessage");
    IMailMsgProperties *pIMailMsgProperties = NULL;
    HRESULT hr = S_OK;

    hr = pIUnknown->QueryInterface(IID_IMailMsgProperties,
                                   (void **) &pIMailMsgProperties);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgProperties FAILED");
    if (FAILED(hr))
        goto Exit;

    //
    //  Check and see if the message is still valid
    //
    if (!fShouldRetryMessage(pIMailMsgProperties))
        goto Exit;

    //
    //  Queue it to the pre-cat queue
    //
    hr = m_asyncqPreCatQueue.HrQueueRequest(pIMailMsgProperties,
                TRUE, cCountMsgsForHandleThrottling(pIMailMsgProperties));
    if (FAILED(hr))
    {
        HandleAQFailure(AQ_FAILURE_PRECAT_RETRY, hr, pIMailMsgProperties);
        goto Exit;
    }

    //
    //  Adjust counters as appropriate
    //
    InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingCat);
    cIncMsgsInSystem();

    //
    // Kick off cat retry if needed
    //
    ScheduleCatRetry();

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
}

//---[ CAQSvrInst::HandleCatFailure ]------------------------------------------
//
//
//  Description:
//      Handles the details of post cat DSN generation.  Will put the
//      message in the failed queue if DSN generation fails
//  Parameters:
//      pIUnknown           IUnkown for mailmsg
//      hrCatResult         Error code returned by cat
//  Returns:
//      -
//  History:
//      11/11/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleCatFailure(IUnknown *pIUnknown, HRESULT hrCatResult)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleCatFailure");
    HRESULT hr = S_OK;
    IMailMsgProperties *pIMailMsgProperties = NULL;
    BOOL    fHasShutdownLock = FALSE;

    ErrorTrace((LPARAM) this,
        "ERROR: MsgCat failed, will try to NDR message - hr 0x%08X",
        hrCatResult);

    InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingCat);
    DecMsgsInSystem(FALSE, FALSE);

    const char *rgszStrings[1] = { NULL };

    if(!pIUnknown)
        goto Exit;

    //If we are shutting down, this error could be caused by a shutdown being
    //signaled.  If this is the case, we do not want to log an error or
    //generate an NDR.
    if (!fTryShutdownLock())
        goto Exit;

    fHasShutdownLock = TRUE;

    HrTriggerLogEvent(
        AQUEUE_CAT_FAILED,              // Message ID
        TRAN_CAT_QUEUE_ENGINE,          // Category
        1,                              // Word count of substring
        rgszStrings,                    // Substring
        EVENTLOG_WARNING_TYPE,          // Type of the message
        hrCatResult,                    // error code
        LOGEVENT_LEVEL_MEDIUM,          // Logging level
        "phatq",                        // key to this event
        LOGEVENT_FLAG_PERIODIC,         // Logging option
        0,                              // index of format message string in rgszStrings
        GetModuleHandle(AQ_MODULE_NAME)        // module handle to format a message
    );

    hr = pIUnknown->QueryInterface(IID_IMailMsgProperties,
                                   (void **) &pIMailMsgProperties);

    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgProperties FAILED");
    if (FAILED(hr))
        goto Exit;

    // we ignore errors on this since it is only to help debug
    // cat failures
    pIMailMsgProperties->PutDWORD(IMMPID_MP_HR_CAT_STATUS,
                                  hrCatResult);


    hr = HandleFailedMessage(pIMailMsgProperties,
                             TRUE,
                             NULL,
                             MESSAGE_FAILURE_CAT,
                             hrCatResult);

  Exit:
    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    if (fHasShutdownLock)
        ShutdownUnlock();

    TraceFunctLeave();
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::ResetRoutes
//
// Synopsis: This is a sink callback function; sinks will call this
// function when they wish to reset next hop routes or message types.
//
// Arguments:
//  dwResetType: Must be either RESET_NEXT_HOPS or RESET_MESSAGE_TYPES
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: bogus dwResetType
//
// History:
// jstamerj 1998/07/10 19:27:45: Created.
//      3/9/99 - MikeSwa Added async reset
//
//-------------------------------------------------------------
STDMETHODIMP CAQSvrInst::ResetRoutes(
    IN  DWORD dwResetType)
{
    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::ResetRoutes");
    HRESULT hr = S_OK;
    InterlockedIncrement((PLONG) &m_cTotalResetRoutes);

    if(dwResetType == RESET_NEXT_HOPS) {

        DebugTrace((LPARAM)this, "ResetNextHops called");

        if (1 == InterlockedIncrement((PLONG) &m_cCurrentPendingResetRoutes))
        {
            DebugTrace((LPARAM) this, "Adding ResetRoutes operation to work queue");
            AddRef(); //released in completion function
            hr = HrQueueWorkItem(this, CAQSvrInst::fResetRoutesNextHopCompletion);
            //Failure will still call completion function, so we should not release
        }
        else
        {
            DebugTrace((LPARAM) this, "Other ResetRoutes pending... only one pending allowed");
            InterlockedDecrement((PLONG) &m_cCurrentPendingResetRoutes);
        }

    } else if(dwResetType == RESET_MESSAGE_TYPES) {

        DebugTrace((LPARAM)this, "ResetMessageTypes called");
        //$$TODO: Reset message types

    } else {

        ErrorTrace((LPARAM)this, "ResetRoutes called with bogus dwResetType %08lx",
                   dwResetType);
        hr =  E_INVALIDARG;

    }
    return hr;
}

//---[ CAQSvrInst::LogResetRouteEvent ]----------------------------------------
//
//
//  Description: 
//      Log statistics on resetroute
//  Parameters:
//      dwObtainLock    time spend on obtaining exclusive lock
//      dwWaitLock      time spend on waiting for the lock
//      dwQueue         queue length at the moment
//  History:
//      11/10/2000 haozhang created
//
//-----------------------------------------------------------------------------

void CAQSvrInst::LogResetRouteEvent( DWORD dwObtainLock,
                    DWORD dwWaitLock,
                    DWORD dwQueue)
{
         
    LPSTR lpstr[3];

    char subStrings[3][13];
 
    sprintf (subStrings[0],"%d",dwObtainLock);
    sprintf (subStrings[1],"%d",dwWaitLock);
    sprintf (subStrings[2],"%d",dwQueue);

    lpstr[0] = subStrings[0];
    lpstr[1] = subStrings[1];
    lpstr[2] = subStrings[2];

    HrTriggerLogEvent(
        AQUEUE_RESETROUTE_DIAGNOSTIC,          // Message ID
        TRAN_CAT_QUEUE_ENGINE,                 // Category ID
        3,                                     // Word count of substring
        (LPCSTR *) lpstr,                      // Substring
        EVENTLOG_INFORMATION_TYPE,             // Type of the message
        0,                                     // No error code
        LOGEVENT_LEVEL_MAXIMUM,                // Debug level
        NULL,                                  // Key to identify this event
        LOGEVENT_FLAG_ALWAYS
      );
}


//---[ CAQSvrInst::fResetRoutesNextHopCompletion ]-----------------------------
//
//
//  Description:
//      Completion function that handles async reset routes
//  Parameters:
//      pvThis      Ptr to CAQSvrInst
//      dwStatus    Status returned by
//  Returns:
//      TRUE always
//  History:
//      3/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fResetRoutesNextHopCompletion(PVOID pvThis, DWORD dwStatus)
{
    TraceFunctEnterEx((LPARAM) pvThis, "CAQSvrInst::fResetRoutesNextHopCompletion");
    CAQSvrInst *paqinst = (CAQSvrInst *) pvThis;
    DWORD       cCurrentPendingResetRoutes = 0;
    DWORD       dwPreLock;
    DWORD       dwObtainLock;
    DWORD       dwReleaseLock;
    DWORD       dwQueue;

    _ASSERT(paqinst);

    if (ASYNC_WORK_QUEUE_NORMAL == dwStatus)
    {
        if (paqinst && paqinst->fTryShutdownLock())
        {
            DebugTrace((LPARAM) paqinst, "Rerouting domains");

            dwPreLock = GetTickCount();

            paqinst->m_slPrivateData.ExclusiveLock();

            dwObtainLock = GetTickCount();

            dwQueue = paqinst->m_cCurrentRemoteDestQueues;

            //Drop pending reset routes count here.  We should do it after
            //we grab the lock to prevent too many threads from
            //trying to grab it exclusively.  We also need to do it
            //before we actual update any routing info in case a ResetRoutes
            //is requested midway through this update.
            cCurrentPendingResetRoutes = InterlockedDecrement((PLONG)
                                &(paqinst->m_cCurrentPendingResetRoutes));

            //Make sure the count hasn't gone negative
            _ASSERT(cCurrentPendingResetRoutes < 0xFFFFFF00);

            paqinst->m_dmt.HrRerouteDomains(NULL);
            paqinst->m_slPrivateData.ExclusiveUnlock();

            dwReleaseLock = GetTickCount();

            //If things have been re-routing to a special link... we should 
            //process them as well.
            paqinst->m_dmt.ProcessSpecialLinks(paqinst->m_dwDelayExpireMinutes,
                                               FALSE);

            paqinst->ShutdownUnlock();

            //
            // Log Event of ResetRoute
            //
            paqinst->LogResetRouteEvent(
                                dwObtainLock - dwPreLock,     // time to obtain the exclusive lock
                                dwReleaseLock - dwObtainLock, // time waiting on the lock 
                                dwQueue                       // number of queues
                                );
        }
    }
    else
    {
        if (paqinst)
        {
            cCurrentPendingResetRoutes = InterlockedDecrement((PLONG)
                                    &(paqinst->m_cCurrentPendingResetRoutes));

            //Make sure the count hasn't gone negative
            _ASSERT(cCurrentPendingResetRoutes < 0xFFFFFF00);
        }

        if (ASYNC_WORK_QUEUE_FAILURE & dwStatus)
            ErrorTrace((LPARAM) paqinst, "ResetRoutes completion failure");
    }

    if (paqinst)
        paqinst->Release();

    TraceFunctLeave();
    return TRUE;
}

//---[ CAQSvrInst::GetDomainInfoFlags ]--------------------------------------
//
//
//  Description:
//      Determines if a domain is local (has DOMAIN_INFO_LOCAL_MAILBOX set)
//  Parameters:
//      IN  szDomainName        Name of domain to check for
//      OUT pdwDomainInfoFlags  DomainInfo flags for this domain
//  Returns:
//      S_OK on success
//      E_INVALIDARG if szDomainName or pdwDomainInfoFlags is NULL
//  History:
//      7/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetDomainInfoFlags(
                IN  LPSTR szDomainName,
                OUT DWORD *pdwDomainInfoFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::GetDomainInfoFlags");
    BOOL    fLocked         = FALSE;
    HRESULT hr              = S_OK;
    DWORD   cbDomainName    = 0;
    CInternalDomainInfo              *pIntDomainInfo = NULL;
    ISMTPServerGetAuxDomainInfoFlags *pISMTPServerGetAuxDomainInfoFlags = NULL;
    DWORD                             dwSinkDomainFlags = 0;

    _ASSERT(pdwDomainInfoFlags && "Invalid Param");
    _ASSERT(szDomainName && "Invalid Param");

    if (!pdwDomainInfoFlags || !szDomainName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    cbDomainName = lstrlen(szDomainName);
    hr = m_dct.HrGetInternalDomainInfo(cbDomainName, szDomainName,
                                        &pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(pIntDomainInfo);

    // Aux Domain info not found, use the config we got from our own tables
    *pdwDomainInfoFlags = pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags;

    // We should have gotten back domain config even if it is only
    // the default config - now we need to see if we can get more
    // specific data from an event sink
    if (!cbDomainName || pIntDomainInfo->m_DomainInfo.szDomainName[0] == '*')
    {
        // QI for ISMTPServerGetAuxDomainInfoFlags interface
        hr = m_pISMTPServer->QueryInterface(
            IID_ISMTPServerGetAuxDomainInfoFlags,
            (LPVOID *)&pISMTPServerGetAuxDomainInfoFlags);

        if (FAILED(hr)) {
            ErrorTrace((LPARAM) this,
                "Unable to QI for ISMTPServerGetAuxDomainInfoFlags 0x%08X",hr);

            // Drop this error, this isn't fatal
            hr = S_OK;
            goto Exit;
        }

        // Check for domain info
        hr = pISMTPServerGetAuxDomainInfoFlags->HrTriggerGetAuxDomainInfoFlagsEvent(
                    szDomainName,
                    &dwSinkDomainFlags);

        if (FAILED(hr)) {
            ErrorTrace((LPARAM) this,
                "Failed calling HrTriggerGetAuxDomainInfoFlags 0x%08X",hr);

            // Drop this error, this isn't fatal
            hr = S_OK;
            goto Exit;
        }

        if (dwSinkDomainFlags & DOMAIN_INFO_INVALID) {
            // Domain info not found from event sink
            hr = S_OK;
            goto Exit;
        }

        // Ok, we got Aux Domain info, use it
        *pdwDomainInfoFlags = dwSinkDomainFlags;
    }

  Exit:

    if (pISMTPServerGetAuxDomainInfoFlags)
        pISMTPServerGetAuxDomainInfoFlags->Release();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    if (fLocked)
        ShutdownUnlock();

    TraceFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CAQSvrInst::GetMessageRouter
//
// Synopsis: Default functionality of GetMessageRouter
//           If there is no current IMessageRouter, provide the
//           default IMessageRouter
//
// Arguments:
//  pIMailMsgProperties: MailMsg that needs a router
//  pICurrentRouter: current sink provided router
//  ppIMessageRouter: out param for new IMessageRouter
//
// Returns:
//  S_OK: Success, provided IMessageRouter
//  E_NOTIMPL: Didn't provide an IMessageRouter
//
// History:
// jstamerj 1998/07/10 19:33:41: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CAQSvrInst::GetMessageRouter(
    IN  IMailMsgProperties      *pIMailMsgProperties,
    IN  IMessageRouter          *pICurrentMessageRouter,
    OUT IMessageRouter          **ppIMessageRouter)
{
    _ASSERT(ppIMessageRouter);

    TraceFunctEnterEx((LPARAM)this, "CAQSvrInst::GetMessageRouter");
    if((pICurrentMessageRouter == NULL) &&
       (m_pIMessageRouterDefault)) {

        //
        // Return our default IMessageRouter and AddRef for the caller
        //
        *ppIMessageRouter = m_pIMessageRouterDefault;
        m_pIMessageRouterDefault->AddRef();

        DebugTrace((LPARAM)this, "Supplying default IMessageRouter");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;

    } else {

        TraceFunctLeaveEx((LPARAM)this);
        return E_NOTIMPL;
    }
}


//---[ CAQSvrInst::HrTriggerDSNGenerationEvent ]-----------------------------
//
//
//  Description:
//      Triggers DSN Generation event
//  Parameters:
//      pdsnparams      A CDSNParams that will be used to trigger event
//      fHasRoutingLock TRUE if routing lock is current held by this thread
//  Returns:
//      S_OK on success (and DSN was generated)
//      S_FALSE on success, but no DSN generated
//      AQUEUE_E_NOT_INITIALIZED if not initialized correctly
//  History:
//      7/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrTriggerDSNGenerationEvent(CDSNParams *pdsnparams,
                                                BOOL fHasRoutingLock)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrTriggerDSNGenerationEvent");
    HRESULT hr = S_OK;
    DWORD cCurrent = 0;
    CRefCountedString *prstrDefaultDomain = NULL;
    LPSTR szDefaultDomain = NULL;
    DWORD cbDefaultDomain = 0;
    CRefCountedString *prstrCopyNDRTo = NULL;
    LPSTR szCopyNDRTo = NULL;
    DWORD cbCopyNDRTo = 0;
    CRefCountedString *prstrFQDN = NULL;
    LPSTR szFQDN = NULL;
    DWORD cbFQDN = 0;
    DWORD cCallsToDSNEventLeft = 0;
    DWORD cCurrentDSNsGenerated = 0;

    if (!(m_dwInitMask & CMQ_INIT_DSN) || !m_pISMTPServer)
    {
        hr = AQUEUE_E_NOT_INITIALIZED;
        goto Exit;
    }

    //Get config string from ref-counted objects
    if (!fHasRoutingLock)
        m_slPrivateData.ShareLock();
    else
        m_slPrivateData.AssertIsLocked();

    if (m_prstrDefaultDomain)
    {
        prstrDefaultDomain = m_prstrDefaultDomain;
        prstrDefaultDomain->AddRef();
        szDefaultDomain = prstrDefaultDomain->szStr();
        cbDefaultDomain = prstrDefaultDomain->cbStrlen();
    }
    else
    {
        //we need to have something as our default domain
        szDefaultDomain = "localhost";
        cbDefaultDomain = sizeof("localhost") - 1;
    }

    if (m_prstrCopyNDRTo)
    {
        prstrCopyNDRTo = m_prstrCopyNDRTo;
        prstrCopyNDRTo->AddRef();
        szCopyNDRTo = prstrCopyNDRTo->szStr();
        cbCopyNDRTo = prstrCopyNDRTo->cbStrlen();
    }

    if (m_prstrServerFQDN)
    {
        prstrFQDN = m_prstrServerFQDN;
        prstrFQDN->AddRef();
        szFQDN = prstrFQDN->szStr();
        cbFQDN = prstrFQDN->cbStrlen();
    }

    if (!fHasRoutingLock)
        m_slPrivateData.ShareUnlock();

    do
    {
        hr = m_dsnsink.GenerateDSN(m_pISMTPServer,
                                 pdsnparams->pIMailMsgProperties,
                                 pdsnparams->dwStartDomain,
                                 pdsnparams->dwDSNActions,
                                 pdsnparams->dwRFC821Status,
                                 pdsnparams->hrStatus,
                                 szDefaultDomain,
                                 cbDefaultDomain,
                                 szFQDN,
                                 cbFQDN,
                                 (CHAR *) DEFAULT_MTA_TYPE,
                                 sizeof(DEFAULT_MTA_TYPE)-1,
                                 pdsnparams->szDebugContext,
                                 lstrlen(pdsnparams->szDebugContext),
                                 m_dwDSNLanguageID,
                                 m_dwDSNOptions,
                                 szCopyNDRTo,
                                 cbCopyNDRTo,
                                 &(pdsnparams->pIMailMsgPropertiesDSN),
                                 &(pdsnparams->dwDSNTypesGenerated),
                                 &cCurrentDSNsGenerated,
                                 &cCallsToDSNEventLeft);

        if (SUCCEEDED(hr))
        {
            //A DSN was generated
            if(pdsnparams->pIMailMsgPropertiesDSN)
            {
                _ASSERT(pdsnparams->dwDSNTypesGenerated && "No DSN type reported for generated DSN");

                if ((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL) & pdsnparams->dwDSNTypesGenerated)
                {
                    MSG_TRACK_INFO msgTrackInfo;

                    cCurrent = InterlockedIncrement((PLONG) &m_cNDRs);
                    DebugTrace((LPARAM) this, "INFO: NDR Generated - total %d", cCurrent);

                    ZeroMemory(&msgTrackInfo, sizeof(MSG_TRACK_INFO));
                    msgTrackInfo.dwEventId = MTE_NDR_ALL;
                    msgTrackInfo.pszPartnerName = "aqueue";
                    msgTrackInfo.dwRcptReportStatus = MP_STATUS_ABORT_DELIVERY;
                    m_pISMTPServer->WriteLog(&msgTrackInfo,
                                              pdsnparams->pIMailMsgProperties,
                                              NULL,
                                              NULL);
                }
                if (DSN_ACTION_DELAYED & pdsnparams->dwDSNTypesGenerated)
                {
                    cCurrent = InterlockedIncrement((PLONG) &m_cDelayedDSNs);
                    DebugTrace((LPARAM) this, "INFO: Delayed DSN Generated - total %d", cCurrent);
                }
                if (DSN_ACTION_RELAYED & pdsnparams->dwDSNTypesGenerated)
                {
                    cCurrent = InterlockedIncrement((PLONG) &m_cRelayedDSNs);
                    DebugTrace((LPARAM) this, "INFO: Relayed DSN Generated - total %d", cCurrent);
                }
                if (DSN_ACTION_DELIVERED & pdsnparams->dwDSNTypesGenerated)
                {
                    cCurrent = InterlockedIncrement((PLONG) &m_cDeliveredDSNs);
                    DebugTrace((LPARAM) this, "INFO: Delivery DSN Generated - total %d", cCurrent);
                }
                if (DSN_ACTION_EXPANDED & pdsnparams->dwDSNTypesGenerated)
                {
                    cCurrent = InterlockedIncrement((PLONG) &m_cExpandedDSNs);
                    DebugTrace((LPARAM) this, "INFO: Expanded DSN Generated - total %d", cCurrent);
                }

                //Queue request to post DSN generation queue
                hr = m_asyncqPostDSNQueue.HrQueueRequest(pdsnparams->pIMailMsgPropertiesDSN,
                                    FALSE, cCountMsgsForHandleThrottling(pdsnparams->pIMailMsgProperties));
                if (SUCCEEDED(hr))
                    hr = S_OK;
                pdsnparams->pIMailMsgPropertiesDSN->Release();
                pdsnparams->pIMailMsgPropertiesDSN = NULL;

                pdsnparams->cRecips += cCurrentDSNsGenerated;
                cCurrentDSNsGenerated = 0;
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else if (AQUEUE_E_NDR_OF_DSN == hr)
        {
            hr = S_FALSE;  //report as no DSN generated

            //original message is badmail
            HandleBadMail(pdsnparams->pIMailMsgProperties, TRUE, NULL,
                          AQUEUE_E_NDR_OF_DSN, fHasRoutingLock);
            InterlockedIncrement((PLONG) &m_cBadmailNdrOfDsn);
        }
        else
        {
            //bail out on failure
            InterlockedIncrement((PLONG) &m_cTotalDSNFailures);

            //
            //  Check to see if the message has been deleted... store driver
            //  has been gone away.
            //
            if (!fShouldRetryMessage(pdsnparams->pIMailMsgProperties, FALSE))
            {
                DebugTrace((LPARAM) this, "Msg no longer valid... abandoning");
                hr = S_FALSE;
            }
            goto Exit;
        }
    } while (cCallsToDSNEventLeft);

  Exit:
    if (prstrDefaultDomain)
        prstrDefaultDomain->Release();

    if (prstrCopyNDRTo)
        prstrCopyNDRTo->Release();

    if (prstrFQDN)
        prstrFQDN->Release();

    TraceFunctLeave();
    return hr;

}

//---[ CAQSvrInst::HrNDRUnresolvedRecipients ]-------------------------------
//
//
//  Description:
//      NDR any unresolved recipients for a given IMailMsgProperties.  Also
//      generates a expanded DSNs
//  Parameters:
//      IN  pIMailMsgProperties     IMailMsgProperties to generate NDR for
//      IN  pIMailMsgRecipients     Recipients interface for message
//  Returns:
//      S_OK on success and message should continue through transport
//      S_FALSE on success, but message should not be queued for delivery
//  History:
//      7/21/98 - MikeSwa Created
//      10/14/98 - MikeSwa Modified to use common utility functions
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrNDRUnresolvedRecipients(
                                      IMailMsgProperties *pIMailMsgProperties,
                                      IMailMsgRecipients *pIMailMsgRecipients)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrNDRUnresolvedRecipients");
    HRESULT hr = S_OK;
    HRESULT hrCat = S_OK;  //cat HRESULT
    DWORD   cbProp = 0;
    DWORD   iCurrentDomain = 0;
    DWORD   cRecips = 0;

    _ASSERT(pIMailMsgProperties);

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_HR_CAT_STATUS, sizeof(HRESULT),
                    &cbProp, (BYTE *) &hrCat);
    if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND == hr) //no result... don't generate DSN
            hr = S_OK; //not really an error
        goto Exit;
    }

    if (CAT_W_SOME_UNDELIVERABLE_MSGS == hrCat)
    {
        //There was an error resolving recipients
        //We need to NDR all recipients with hard errors (like RP_UNRESOLVED)
        //and expand any recipient marked expanded.
        CDSNParams  dsnparams;
        dsnparams.dwStartDomain = 0;
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE | DSN_ACTION_EXPANDED;
        dsnparams.pIMailMsgProperties = pIMailMsgProperties;
        dsnparams.hrStatus = CAT_W_SOME_UNDELIVERABLE_MSGS;

        hr = HrLinkAllDomains(pIMailMsgProperties);
        if (FAILED(hr))
            goto Exit;

        //Fire DSN Generation event
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        hr = HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;

        //Check to see how many recipients have been NDRd
        hr = pIMailMsgRecipients->Count(&cRecips);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                       "ERROR: IMailMsgRecipients::Count() FAILED - hr 0x%08X", hr);
            goto Exit;
        }

        //If all recipients have been handled... return S_FALSE
        if (dsnparams.cRecips == cRecips)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }

    }
    else
    {
        hr = S_OK;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::fPreLocalDeliveryQueueCompletion ]------------------------
//
//
//  Description:
//      Completion function for PerLocal delivery queue
//  Parameters:
//      pmsgref - Msgref to attempt delivery for
//  Returns:
//      TRUE    If Delivery attempt was handled (delivered or NDR'd)
//      FALSE   If MsgRef needs to be requeued
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fPreLocalDeliveryQueueCompletion(CMsgRef *pmsgref)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::fPreLocalDeliveryQueueCompletion");
    HRESULT hr = S_OK;
    BOOL    fMsgHandled = TRUE;
    BOOL    fLocked = FALSE;  //TRUE if locked for shutdown
    CDeliveryContext dcntxtLocal;
    DWORD         cRecips   = 0;
    DWORD        *rgdwRecips= 0;
    CAQStats aqstat;
    CLinkMsgQueue *plmq = NULL;
    MessageAck    MsgAck;
    IMailMsgProperties *pIMailMsgProperties = NULL;

    ZeroMemory(&MsgAck, sizeof(MessageAck));
    MsgAck.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;

    if (NULL == m_pISMTPServer)
    {
        ErrorTrace((LPARAM) this, "ERROR: Local Delivery not configured properly");
        goto Exit;
    }

    if (!fTryShutdownLock())
        goto Exit;

    fLocked = TRUE;

    if (pmsgref->fIsMsgFrozen())
    {
        //Message is frozen... requeue message
        fMsgHandled = FALSE;
    }

    hr = m_dmt.HrPrepareForLocalDelivery(pmsgref, FALSE, &dcntxtLocal,
                                          &cRecips, &rgdwRecips);
    if (FAILED(hr))
    {
        if ((AQUEUE_E_MESSAGE_HANDLED != hr) && (AQUEUE_E_MESSAGE_PENDING != hr))
        {
            //message will be retried when last reference is released.
            pmsgref->RetryOnDelete();
            ErrorTrace((LPARAM) this, "ERROR: HrPrepareLocalDelivery FAILED - hr 0x%08X", hr);
        }
        fMsgHandled = TRUE;
        hr = S_OK;
        goto Exit;
    }

    //Increase Ref count for message ref (as if it was actually queued)
    pmsgref->AddRef();

    //Send off for local delivery
    pIMailMsgProperties = pmsgref->pimsgGetIMsg();
    InterlockedIncrement((PLONG) &m_cCurrentMsgsInLocalDelivery);

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_LOCAL_DELIVERY;
    msgTrackInfo.cRcpts = cRecips;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    hr = m_pISMTPServer->TriggerLocalDelivery(pIMailMsgProperties, cRecips, rgdwRecips);
    InterlockedDecrement((PLONG) &m_cCurrentMsgsInLocalDelivery);
    if (FAILED(hr))
    {
        //EVNT - local delivery failed


        //We will need to handle in one of 2 ways:
        //  - set fMsgHandled to FALSE (on STOREDRV_E_RETRY)
        //  - NDR the message (on other errors)
        if (STOREDRV_E_RETRY == hr)
        {
            //try... try again
            DebugTrace((LPARAM) pIMailMsgProperties, "INFO: Msg queued for local retry");
            fMsgHandled = FALSE;
            MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY;

            if (!m_cLocalRetriesPending)
            {
                InterlockedIncrement((PLONG) &m_cLocalRetriesPending);
                //Use default retry sink to handle local retry
                _ASSERT(m_dwLocalDelayExpireMinutes && "Retry set to zero!");
                m_pConnMgr->SetCallbackTime(LocalDeliveryRetry, this, g_cLocalRetryMinutes);
            }
        }
        else
        {
            ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: Local delivery failed. - hr 0x%08X", hr);
            MsgAck.dwMsgStatus = MESSAGE_STATUS_NDR_ALL;
        }
    }
    else
    {
        InterlockedIncrement(&m_cMsgsDeliveredLocal);
    }

    MsgAck.pIMailMsgProperties = pIMailMsgProperties;
    MsgAck.pvMsgContext = (DWORD *) &dcntxtLocal;
    MsgAck.dwMsgStatus |= MESSAGE_STATUS_LOCAL_DELIVERY;

    //
    //  Make sure we should retry the message.  We want to do this before we
    //  ACK the message so that we do not reopen the P1 stream if we *are*
    //  retrying it.
    //
    if (!fMsgHandled)
        fMsgHandled = !pmsgref->fShouldRetry();

    hr = HrAckMsg(&MsgAck, TRUE);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "ERROR: Local MsgAck failed - hr 0x%08X", hr);
        goto Exit;
    }

  Exit:
    if (fMsgHandled) //we aren't retrying message
    {
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingLocal);

        //
        // Update stats for the local link
        //
        pmsgref->GetStatsForMsg(&aqstat);
        plmq = m_dmt.plmqGetLocalLink();
        if (plmq)
        {
            hr = plmq->HrNotify(&aqstat, FALSE);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this,
                    "HrNotify failed... local stats innaccurate 0x%08X", hr);
                hr = S_OK;
            }
            plmq->Release();
            plmq = NULL;
        }
    }

    if (fLocked)
        ShutdownUnlock();

    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    TraceFunctLeave();
    return fMsgHandled;
}

//---[ CAQSvrInst::HrSetMessageExpiry ]--------------------------------------
//
//
//  Description:
//      Sets the Expiry times on the message.  Will not overwrite any
//      existing expire times.
//
//      ***NOTE***
//          This includes messges that have only some properties set... so it
//          is possible to set some of the expire properties, and have
//          some of them set as defaults.  By setting these properties on the
//          OnMessageSubmission event, you can implement having different
//          expire times for different priorities.
//  Parameters:
//      IN  pIMailMsgProperties     message to stamp properties on
//  Returns:
//      S_OK on success
//  History:
//      8/13/98 - MikeSwa Created
//      10/9/98 - MikeSwa  - Changed behavior to that any pre-existing
//                  properties will be maintained.
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrSetMessageExpiry(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HrSetMessageExpiry");
    HRESULT hr = S_OK;
    DWORD   dwTimeContext = 0;
    DWORD   cbProp = 0;
    FILETIME ftExpireTime;
    DWORD   dwDelayExpireMinutes;
    DWORD   dwNDRExpireMinutes;
    DWORD   dwLocalDelayExpireMinutes;
    DWORD   dwLocalNDRExpireMinutes;

    _ASSERT(pIMailMsgProperties);

    m_slPrivateData.ShareLock();
    dwDelayExpireMinutes = m_dwDelayExpireMinutes;
    dwNDRExpireMinutes = m_dwNDRExpireMinutes;
    dwLocalDelayExpireMinutes = m_dwLocalDelayExpireMinutes;
    dwLocalNDRExpireMinutes = m_dwLocalNDRExpireMinutes;
    m_slPrivateData.ShareUnlock();

    //Set arrival time
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTime);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Prop not set... we can set it
        m_qtTime.GetExpireTime(0, &ftExpireTime, &dwTimeContext);
        hr = pIMailMsgProperties->PutProperty(IMMPID_MP_ARRIVAL_FILETIME,
            sizeof(FILETIME), (BYTE *) &ftExpireTime);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to write arrival time to msg");
            goto Exit;
        }
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    //Get & set time expire times of messages
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_EXPIRE_DELAY,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTime);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Prop not set... we can set it
        m_qtTime.GetExpireTime(dwDelayExpireMinutes, &ftExpireTime, &dwTimeContext);
        hr = pIMailMsgProperties->PutProperty(IMMPID_MP_EXPIRE_DELAY, sizeof(FILETIME),
                                                (BYTE *) &ftExpireTime);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to write delay expire time to msg");
            goto Exit;
        }
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_EXPIRE_NDR,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTime);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Prop not set... we can set it
        m_qtTime.GetExpireTime(dwNDRExpireMinutes, &ftExpireTime, &dwTimeContext);
        hr = pIMailMsgProperties->PutProperty(IMMPID_MP_EXPIRE_NDR, sizeof(FILETIME),
                                                (BYTE *) &ftExpireTime);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to write NDR expire time to msg");
            goto Exit;
        }
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_DELAY,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTime);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Prop not set... we can set it
        m_qtTime.GetExpireTime(dwLocalDelayExpireMinutes, &ftExpireTime, &dwTimeContext);
        hr = pIMailMsgProperties->PutProperty(IMMPID_MP_LOCAL_EXPIRE_DELAY, sizeof(FILETIME),
                                                (BYTE *) &ftExpireTime);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to write Local delay expire time to msg");
            goto Exit;
        }
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_NDR,
            sizeof(FILETIME), &cbProp, (BYTE *) &ftExpireTime);
    if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Prop not set... we can set it
        m_qtTime.GetExpireTime(dwLocalNDRExpireMinutes, &ftExpireTime, &dwTimeContext);
        hr = pIMailMsgProperties->PutProperty(IMMPID_MP_LOCAL_EXPIRE_NDR, sizeof(FILETIME),
                                                (BYTE *) &ftExpireTime);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Unable to write Local NDR expire time to msg");
            goto Exit;
        }
    }
    else if (FAILED(hr))
    {
        goto Exit;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}


//---[ CAQSvrInst::AsyncQueueRetry ]-----------------------------------------
//
//
//  Description:
//      Restarts an async queue after a failure.
//  Parameters:
//      dwQueueID       Tells which queue to kick
//          PRELOCAL_QUEUE_ID   Retries pre-local queue
//          PRECAT_QUEUE_ID     Retries pre-cat queue
//          PREROUTING_QUEUE_ID Retries pre-routing queue
//          PRESUBMIT_QUEUE_ID  Retries pre-submit queue
//  Returns:
//      -
//  History:
//      8/17/98 - MikeSwa Created
//      3/3/2000 - MikeSwa Modified to add presubmit queue
//
//-----------------------------------------------------------------------------
void CAQSvrInst::AsyncQueueRetry(DWORD dwQueueID)
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);

    if (fTryShutdownLock())
    {
        if (PRELOCAL_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cLocalRetriesPending);
            m_asyncqPreLocalDeliveryQueue.StartRetry();
        }
        else if (PRECAT_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cCatRetriesPending);
            m_asyncqPreCatQueue.StartRetry();
        }
        else if (PREROUTING_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cRoutingRetriesPending);
            m_asyncqPreRoutingQueue.StartRetry();
        }
        else if (PRESUBMIT_QUEUE_ID == dwQueueID)
        {
            InterlockedDecrement((PLONG) &m_cSubmitRetriesPending);
            m_asyncqPreSubmissionQueue.StartRetry();
        }
        else
        {
            _ASSERT(0 && "Invalid Queue ID");
        }
        ShutdownUnlock();
    }
}

//---[ HrCreateBadMailPropertyFile ]------------------------------------------
//
//
//  Description:
//      Creates a property stream for the given message.  The property
//      stream file is given name the .BDP extension.
//  Parameters:
//      szDestFileBase      The filename of the actual badmail file
//      pIMailMsgProperties The original message that is being badmailed
//                          (may be NULL if it is a pickup dir file)
//  Returns:
//      S_OK on success
//      E_POINTER if szDestFileBase is NULL
//  History:
//      8/17/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrCreateBadMailPropertyFile(LPSTR szDestFileBase,
                                    IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrCreateBadMailPropertyFile");
    HRESULT hr = S_OK;
    CHAR    szOldExt[] = "123";
    CHAR    szNewExt[] = "BDP";
    LPSTR   szBadMailFileNameExt = NULL;
    DWORD   cbBadMailFileName = 0;
    BOOL    fShouldRestoreExtension = FALSE;
    CFilePropertyStream fstrm;
    IMailMsgBind *pIMailMsgBind = NULL;
    IMailMsgPropertyStream *pIMailMsgPropertyStream = NULL;

    _ASSERT(szDestFileBase);

    if (!szDestFileBase)
    {
        hr = E_POINTER;
        ErrorTrace((LPARAM) NULL, "Error NULL badmail filename passed in");
        goto Exit;
    }

    if (!pIMailMsgProperties) //no-op
        goto Exit;

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgBind,
                                             (void **) &pIMailMsgBind);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to QI for IMailMsgBind - 0x%08X", hr);
        goto Exit;
    }

    _ASSERT(pIMailMsgBind);

    //Create the filename & file
    cbBadMailFileName = strlen(szDestFileBase);
    _ASSERT(cbBadMailFileName > 4); //must at least have . extenstion
    szBadMailFileNameExt = szDestFileBase + cbBadMailFileName-3;

    //szBadMailFileNameExt now points to the first character of the 3 char ext
    _ASSERT('.' == *(szBadMailFileNameExt-1));
    _ASSERT(sizeof(szNewExt) == sizeof(szOldExt));
    memcpy(szOldExt, szBadMailFileNameExt, sizeof(szOldExt));
    memcpy(szBadMailFileNameExt, szNewExt, sizeof(szNewExt));
    fShouldRestoreExtension = TRUE;

    hr = fstrm.HrInitialize(szDestFileBase);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to create badmail property stream - 0x%08X", hr);
        goto Exit;
    }

    hr = fstrm.QueryInterface(IID_IMailMsgPropertyStream,
                              (void **) &pIMailMsgPropertyStream);
    _ASSERT(SUCCEEDED(hr)); //we control this totally
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to QI for IID_IMailMsgPropertyStream - 0x%08X", hr);
        goto Exit;
    }

    hr = pIMailMsgBind->GetProperties(pIMailMsgPropertyStream,
                                      MAILMSG_GETPROPS_COMPLETE, NULL);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "GetProperties failed with 0x%08X", hr);
        goto Exit;
    }

  Exit:
    if (fShouldRestoreExtension)
    {
        _ASSERT(szBadMailFileNameExt);
        memcpy(szBadMailFileNameExt, szOldExt, sizeof(szOldExt));
    }

    if (pIMailMsgBind)
        pIMailMsgBind->Release();

    if (pIMailMsgPropertyStream)
        pIMailMsgPropertyStream->Release();

    TraceFunctLeave();
    return hr;
}
//---[ HrCreateBadMailReasonFile ]---------------------------------------------
//
//
//  Description:
//      Creates a file in the badmail directory that expains why the given
//      message was badmailed, and dump the sender and recipient as well.  Uses
//      the extension BMR (BadMailReason) to differentiate from the content.
//  Parameters:
//      szDestFileBase      The filename of the actual badmail file
//      hrReason            The reason the badmail is being created
//      pIMailMsgProperties The original message that is being badmailed
//                          (may be NULL if it is a pickup dir file)
//  Returns:
//      S_OK on success
//      E_POINTER if szDestFileBase is NULL
//  History:
//      8/16/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrCreateBadMailReasonFile(IN LPSTR szDestFileBase,
                        IN HRESULT  hrReason,
                        IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrCreateBadMailReasonFile");
    HRESULT hr = S_OK;
    HRESULT hrErrorLogged = hrReason;
    WCHAR   wszBadmailReason[1000] = L"";  //Localized hrReason string
    WCHAR   wszReasonBuffer[2000] = L"";
    WCHAR   wszErrorCode[] = L"0x12345678 ";
    WCHAR   wszErrorCodeMessage[200] = L"";
    CHAR    szPropBuffer[1000] = "";
    DWORD   dwErr = 0;
    BOOL    fWriteBadmailReason = FALSE;
    BOOL    fShouldRestoreExtension = FALSE;
    DWORD   cReasonBuffer = 0;
    LPSTR   szBadMailFileNameExt = NULL;
    CHAR    szOldExt[] = "123";
    CHAR    szNewExt[] = "BDR";
    DWORD   cbBadMailFileName = 0;
    HANDLE  hBadMailFile = NULL;
    DWORD   cbBytesWritten = 0;
    DWORD   dwFacility = 0;
    LPWSTR  rgwszArgList[32];
    const   WCHAR wcszBlankLine[] = L"\r\n";
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    DWORD   cRecips = 0;
    DWORD   iCurrentRecip = 0;

    _ASSERT(szDestFileBase);
    if (!szDestFileBase)
    {
        ErrorTrace((LPARAM) NULL, "Invalid destination file for badmail");
        hr = E_POINTER;
        goto Exit;
    }

    if (!g_hAQInstance)
    {
        _ASSERT(g_hAQInstance && "This should always be set in DLL main");
        ErrorTrace((LPARAM) NULL, "Error, g_hAQInstance is NULL");
        hr = E_FAIL;
        goto Exit;
    }

    //Create the filename & file
    cbBadMailFileName = strlen(szDestFileBase);
    _ASSERT(cbBadMailFileName > 4); //must at least have . extenstion
    szBadMailFileNameExt = szDestFileBase + cbBadMailFileName-3;

    //szBadMailFileNameExt now points to the first character of the 3 char ext
    _ASSERT('.' == *(szBadMailFileNameExt-1));
    _ASSERT(sizeof(szNewExt) == sizeof(szOldExt));
    memcpy(szOldExt, szBadMailFileNameExt, sizeof(szOldExt));
    memcpy(szBadMailFileNameExt, szNewExt, sizeof(szNewExt));
    fShouldRestoreExtension = TRUE;

    hBadMailFile = CreateFile(szDestFileBase,
                              GENERIC_WRITE,
                              0,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);

    if (INVALID_HANDLE_VALUE ==hBadMailFile )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Unable to create badmail reason file - err 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }

    //Figure out the reason for the failure
    if (SUCCEEDED(hrErrorLogged))
    {
        //someone is being lazy about setting the error reason
        _ASSERT(0 && "No badmail reason given");
        ErrorTrace((LPARAM) NULL, "Non-failing badmail HRESULT given 0x%08X",
                   hrErrorLogged);

        //Substitute a generic error so we don't have something obnoxious like
        //"The operation completed succesfully" appear in the badmail file
        hrErrorLogged = E_FAIL;
    }

    //Write the error code in "0x00000000" format
    wsprintfW(wszErrorCode, L"0x%08X", hrErrorLogged);

    dwFacility = ((0x0FFF0000 & hrErrorLogged) >> 16);

    //If it is not ours... then "un-HRESULT" it
    if (dwFacility != FACILITY_ITF)
        hrErrorLogged &= 0x0000FFFF;

    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       g_hAQInstance,
                       hrErrorLogged,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszBadmailReason,
                       sizeof(wszBadmailReason)/sizeof(WCHAR), NULL);

    if (!dwErr)
    {
        //We should fall back on a numeric error that we were given
        ErrorTrace((LPARAM) NULL,
            "Error: unable to format badmail message 0x%08X,  error is %d",
            hrErrorLogged, GetLastError());

        wcscpy(wszBadmailReason, wszErrorCode);
    }
    else
    {
        //Get rid of trailing newline
        cReasonBuffer = wcslen(wszBadmailReason);
        cReasonBuffer--;
        while(iswspace(wszBadmailReason[cReasonBuffer]))
        {
            wszBadmailReason[cReasonBuffer] = '\0';
            cReasonBuffer--;
        }
        cReasonBuffer = 0;
    }

    ErrorTrace((LPARAM) NULL,
        "Generating badmail because: %S", wszBadmailReason);

    rgwszArgList[0] = wszBadmailReason;
    rgwszArgList[1] = NULL;
    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       g_hAQInstance,
                       PHATQ_BADMAIL_REASON,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszReasonBuffer,
                       sizeof(wszReasonBuffer)/sizeof(WCHAR),
                       (va_list *) rgwszArgList);
    if (!dwErr)
    {
        ErrorTrace((LPARAM) NULL,
            "Error: unable to format PHATQ_BADMAIL_REASON,  error is %d",
            GetLastError());
        hr = HRESULT_FROM_WIN32(GetLastError());
        wcscpy(wszReasonBuffer, wszBadmailReason);
    }

    cReasonBuffer = wcslen(wszReasonBuffer);
    if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                   cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Error writing to badmail reason file - erro 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }

    //Write the actual error code in 0x00000000 form so tools can parse it out
    rgwszArgList[0] = wszErrorCode;
    rgwszArgList[1] = NULL;
    wcscpy(wszReasonBuffer, wcszBlankLine);
    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       g_hAQInstance,
                       PHATQ_BADMAIL_ERROR_CODE,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszReasonBuffer+(sizeof(wcszBlankLine)-1)/sizeof(WCHAR),
                       (sizeof(wszReasonBuffer)-sizeof(wcszBlankLine))/sizeof(WCHAR),
                       (va_list *) rgwszArgList);

    wcscat(wszReasonBuffer, wcszBlankLine);
    cReasonBuffer = wcslen(wszReasonBuffer);
    if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                   cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Error writing to badmail reason file - erro 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }

    //All the rest requries access to an actual message... if we don't
    //have one, bail
    if (!pIMailMsgProperties)
        goto Exit;

    //Write Sender of message
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_SENDER_ADDRESS_SMTP,
        sizeof(szPropBuffer), szPropBuffer);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "ERROR: Unable to get sender of IMailMsg 0x%08X",
            pIMailMsgProperties);
        hr = S_OK; //just don't display sender
    }
    else
    {
        rgwszArgList[0] = (LPWSTR) szPropBuffer;
        rgwszArgList[1] = NULL;
        wcscpy(wszReasonBuffer, wcszBlankLine);
        dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           g_hAQInstance,
                           PHATQ_BADMAIL_SENDER,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           wszReasonBuffer+(sizeof(wcszBlankLine)-1)/sizeof(WCHAR),
                           (sizeof(wszReasonBuffer)-sizeof(wcszBlankLine))/sizeof(WCHAR),
                           (va_list *) rgwszArgList);

        wcscat(wszReasonBuffer, wcszBlankLine);
        cReasonBuffer = wcslen(wszReasonBuffer);
        if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                       cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL,
                "Error writing to badmail reason file - erro 0x%08X - file %s",
                hr, szDestFileBase);
            goto Exit;
        }
    }


    //Write Message recipients
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients,
                                    (PVOID *) &pIMailMsgRecipients);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to query interface for recip interface - 0x%08X", hr);
        goto Exit;
    }

    hr = pIMailMsgRecipients->Count(&cRecips);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL,
            "Unable to get recipient count - 0x%08X", hr);
        goto Exit;
    }

    //If we don't have any recipients, bail
    if (!cRecips)
        goto Exit;

    //Write the localized text
    wcscpy(wszReasonBuffer, wcszBlankLine);
    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       g_hAQInstance,
                       PHATQ_BADMAIL_RECIPIENTS,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       wszReasonBuffer+(sizeof(wcszBlankLine)-1)/sizeof(WCHAR),
                       (sizeof(wszReasonBuffer)-sizeof(wcszBlankLine))/sizeof(WCHAR),
                       NULL);
    cReasonBuffer = wcslen(wszReasonBuffer);
    if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                   cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL,
            "Error writing to badmail reason file - erro 0x%08X - file %s",
            hr, szDestFileBase);
        goto Exit;
    }


    //Loop over SMTP recips and dump them in the file
    for (iCurrentRecip = 0; iCurrentRecip < cRecips; iCurrentRecip++)
    {
        hr = pIMailMsgRecipients->GetStringA(iCurrentRecip,
                IMMPID_RP_ADDRESS_SMTP, sizeof(szPropBuffer), szPropBuffer);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL,
                "Unable to get SMTP address for recip %d - 0x%08X",
                iCurrentRecip, hr);
            hr = S_OK;
            continue;
        }

        cReasonBuffer = wsprintfW(wszReasonBuffer, L"\t%S%s",
                  szPropBuffer, wcszBlankLine);
        if (!WriteFile(hBadMailFile, (PVOID) wszReasonBuffer,
                       cReasonBuffer*sizeof(WCHAR), &cbBytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL,
                "Error writing to badmail reason file - error 0x%08X - file %s",
                hr, szDestFileBase);
            goto Exit;
        }
    }

  Exit:
    if (fShouldRestoreExtension)
    {
        _ASSERT(szBadMailFileNameExt);
        memcpy(szBadMailFileNameExt, szOldExt, sizeof(szOldExt));
    }

    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    if (hBadMailFile != INVALID_HANDLE_VALUE)
        _VERIFY(CloseHandle(hBadMailFile));

    TraceFunctLeave();
    return hr;
}

//---[ CAQSvrInst::HandleBadMail ]---------------------------------------------
//
//
//  Description:
//      Handles mail that needs to be placed in the badmail directory (or
//      equivalent).
//  Parameters:
//      IN      pIMailMsgProperties that needs to be badmail'd
//      IN      fUseIMailMsgPropeties -- use IMAilMsgProps if set else use szFilename
//      IN      szFileName  Name of badmail file (if no msg can be supplied)
//      IN      hrReason - HRESULT (defined in aqerr) that describes reason
//                  Eventually, we may log this information to the badmail
//                  file (or recipient)
//      IN      fHasRoutingLock - TRUE if this thread holds routing lock
//  Returns:
//      -
//  History:
//      10/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleBadMail(IN IMailMsgProperties *pIMailMsgProperties,
                               IN BOOL fUseIMailMsgProperties,
                               IN LPSTR szOriginalFileName,
                               IN HRESULT hrReason,
                               IN BOOL fHasRoutingLock)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::HandleBadMail");
    HRESULT hr = S_OK;
    LPSTR szFullPathName = NULL;
    LPSTR szFileName = NULL;
    BOOL  fDataLocked = FALSE;
    BOOL  fDone = TRUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PFIO_CONTEXT pFIOContext = NULL;
    FILETIME ftCurrent;
    CRefCountedString *prstrBadMailDir = NULL;

    MSG_TRACK_INFO msgTrackInfo;
    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_BADMAIL;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    InterlockedIncrement((PLONG) &m_cTotalMsgsBadmailed);

    if (!fHasRoutingLock)
    {
        m_slPrivateData.ShareLock();
        fDataLocked = TRUE;
    }
    else
    {
        m_slPrivateData.AssertIsLocked();
    }


    if (m_prstrBadMailDir)
    {
        prstrBadMailDir = m_prstrBadMailDir;
        prstrBadMailDir->AddRef();
    }
    else
    {
        LogAQEvent(AQUEUE_E_NO_BADMAIL_DIR, NULL, pIMailMsgProperties, NULL);
        goto Exit;
    }

    if (fDataLocked)
    {
        m_slPrivateData.ShareUnlock();
        fDataLocked = FALSE;
    }

    szFullPathName = (LPSTR) pvMalloc(sizeof(CHAR) *
                         (UNIQUEUE_FILENAME_BUFFER_SIZE +
                         prstrBadMailDir->cbStrlen()));

    if (!szFullPathName)
    {
        LogAQEvent(AQUEUE_E_BADMAIL, NULL, pIMailMsgProperties, NULL);
        goto Exit;
    }

    memcpy(szFullPathName, prstrBadMailDir->szStr(),
            prstrBadMailDir->cbStrlen());

    if (szFullPathName[prstrBadMailDir->cbStrlen()-1] != '\\')
    {
        _ASSERT(0 && "Malformed badmail config");
        LogAQEvent(AQUEUE_E_NO_BADMAIL_DIR, NULL, pIMailMsgProperties, NULL);
        goto Exit;
    }

    szFileName = szFullPathName + prstrBadMailDir->cbStrlen();

    //If we have a msg use it
    if (pIMailMsgProperties && fUseIMailMsgProperties)
    {
        //Loop while trying to generate a unique file name
        do
        {
            fDone = TRUE;

            GetExpireTime(0, &ftCurrent, NULL);
            GetUniqueFileName(&ftCurrent, szFileName, "BAD");

            //Create file and write MsgContent to it
            hFile = CreateFile( szFullPathName,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_NEW,
                        FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED,
                        NULL);

            if (INVALID_HANDLE_VALUE == hFile)
            {
                if (ERROR_ALREADY_EXISTS == GetLastError())
                {
                    //Try a new file name
                    fDone = FALSE;
                    continue;
                }

                //Other we are hosed... log an event
                LogAQEvent(AQUEUE_E_BADMAIL, NULL, pIMailMsgProperties, NULL);
                goto Exit;
            }

            _ASSERT(hFile);  //should return INVALID_HANDLE_VALUE on failure
        } while (!fDone);

        if (hFile != INVALID_HANDLE_VALUE)
            pFIOContext = AssociateFile(hFile);

        if (!pFIOContext ||
            FAILED(pIMailMsgProperties->CopyContentToFile(pFIOContext, NULL)))
        {
            //Copy failed log event
            LogAQEvent(AQUEUE_E_BADMAIL, NULL, pIMailMsgProperties, NULL);
        }
    }
    else if (szOriginalFileName)
    {
        //Otherwise (no msg)... just do a movefile
        _ASSERT(szFullPathName[prstrBadMailDir->cbStrlen()-1] == '\\');
        szFullPathName[prstrBadMailDir->cbStrlen()-1] = '\0';
        if (!MoveFileEx(szOriginalFileName, szFullPathName,
                MOVEFILE_COPY_ALLOWED))
        {
            //MoveFile failed... try renaming with a unique file name
            szFullPathName[prstrBadMailDir->cbStrlen()-1] = '\\';
            GetExpireTime(0, &ftCurrent, NULL);
            GetUniqueFileName(&ftCurrent, szFileName, "BAD");
            if (rename(szOriginalFileName, szFullPathName))
                LogAQEvent(AQUEUE_E_BADMAIL, NULL, NULL, szOriginalFileName);
        }
    }

    hr = HrCreateBadMailReasonFile(szFullPathName, hrReason, pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to make badmail reason file - hr 0x%08X", hr);
    }

    hr = HrCreateBadMailPropertyFile(szFullPathName, pIMailMsgProperties);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to make badmail property file - hr 0x%08X", hr);
    }

  Exit:
    if (fDataLocked)
        m_slPrivateData.ShareUnlock();

    if (prstrBadMailDir)
        prstrBadMailDir->Release();

    if (szFullPathName)
        FreePv(szFullPathName);

    if (NULL != pFIOContext)
        ReleaseContext(pFIOContext);

    TraceFunctLeave();
}

//---[ HandleAQFailure ]--------------------------------------------------------
//
//
//  Description:
//      Function to handle AQ failures that would result in loss of data
//      or messages if unhandled.  Meant to be a substitute for
//      _ASSERT(SUCCEEDED(hr)).
//
//      Note: Msgs are still Turfed for M2
//  Parameters:
//      eaqfFailureSituation        Enum that describes the failure situation
//                                  as well as what the context is.
//      hr                          HRSULT that triggered failure condition
//      pIMailMsgProperties         MailMsgProperties
//  Returns:
//      -
//  History:
//      8/25/98 - MikeSwa Created
//      10/8/98 - MikeSwa Moved to CAQSvrInst
//
//-----------------------------------------------------------------------------
void CAQSvrInst::HandleAQFailure(eAQFailure eaqfFailureSituation,
                                 HRESULT hr,
                                 IMailMsgProperties *pIMailMsgProperties)
{
    _ASSERT(eaqfFailureSituation < AQ_FAILURE_NUM_SITUATIONS);
    InterlockedIncrement((PLONG) &g_cTotalAQFailures);
    InterlockedIncrement((PLONG) &(g_rgcAQFailures[eaqfFailureSituation]));
    BOOL    fCanRetry = fShouldRetryMessage(pIMailMsgProperties);
    MSG_TRACK_INFO msgTrackInfo;

    ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
    msgTrackInfo.dwEventId = MTE_AQ_FAILURE;
    m_pISMTPServer->WriteLog( &msgTrackInfo, pIMailMsgProperties, NULL, NULL );

    switch(eaqfFailureSituation)
    {
      case(AQ_FAILURE_CANNOT_NDR_UNRESOLVED_RECIPS):
        LogAQEvent(AQUEUE_E_DSN_FAILURE, NULL, pIMailMsgProperties, NULL);
        //drop through to default case
      default:
        //
        //  Throw the message in the last-ditch retry queue if the following are true:
        //      - We had a failure
        //      - We are not shutting down
        //      - We can retry the message (e.g., it has not been deleted)
        //
        if (FAILED(hr) && (AQUEUE_E_SHUTDOWN != hr) && fCanRetry)
        {
            InterlockedIncrement((PLONG) &m_cCurrentResourceFailedMsgsPendingRetry);
            m_fmq.HandleFailedMailMsg(pIMailMsgProperties);
        }
    }
}

//---[ CAQSvrInst::LogAQEvent ]------------------------------------------------
//
//
//  Description:
//      General event logging mechanism for AQ
//  Parameters:
//      hrEventReason       AQUEUE HRESULT describing event
//      pmsgref             CMsgRef of msg for event (can be NULL)
//      pIMailMsgProperties pIMailMsgProperties for event (can be NULL)
//      szFileName          Filename if no msgs provided (can be NULL)
//  Returns:
//      -
//  History:
//      10/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQSvrInst::LogAQEvent(HRESULT hrEventReason, CMsgRef *pmsgref,
                            IMailMsgProperties *pIMailMsgProperties,
                            LPSTR szFileName)
{
    TraceFunctEnterEx((LPARAM) this, "CAQSvrInst::LogAQEvent");

    switch (hrEventReason)
    {
      //$$TODO - Add actual event callouts here
      case (S_OK): //Added to remove switch compile warnings
      default:
        ErrorTrace((LPARAM) this, "EVENT: Generic AQueue event - 0x%08X", hrEventReason);
    }
    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::TriggerPreCategorizeEvent
//
// Synopsis: Fire the pre-cat server event
//
// Arguments:
//  pIMailMsgProperties: the IMailMsgProperties interface of the mailmsg
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/11/24 20:07:58: Created.
//
//-------------------------------------------------------------
VOID CAQSvrInst::TriggerPreCategorizeEvent(
    IN  IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT hr;
    EVENTPARAMS_PRECATEGORIZE Params;

    TraceFunctEnterEx((LPARAM)pIMailMsgProperties,
                      "CAQSvrInst::TriggerPreCategorizeEvent");

    _ASSERT(pIMailMsgProperties);

    Params.pfnCompletion = MailTransport_Completion_PreCategorization;
    Params.pCCatMsgQueue = (PVOID) this;
    Params.pIMailMsgProperties = pIMailMsgProperties;

    //
    // Addref here, release in completion
    //
    pIMailMsgProperties->AddRef();
    AddRef();

    //
    // keep a count of messages in the pre-cat event
    //
    InterlockedIncrement((LPLONG) &m_cCurrentMsgsPendingPreCatEvent);

    if(m_pISMTPServer) {
        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT,
            &Params);
        DebugTrace((LPARAM)this, "TriggerServerEvent returned hr %08lx", hr);

    }

    if((m_pISMTPServer == NULL) || (FAILED(hr))) {

        ErrorTrace((LPARAM)this,
                   "Unable to dispatch server event; calling completion routine directly");

        DebugTrace((LPARAM)this, "hr is %08lx", hr);
        //
        // Call completion routine directly
        //
        _VERIFY(SUCCEEDED(PreCatEventCompletion(S_OK, &Params)));
    }
    TraceFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CAQSvrInst::PreCatEventCompletion
//
// Synopsis: Called by SEO upon completipon of the precat event
//
// Arguments:
//  pIMailMsgProperties: the IMailMsgProperties interface of the mailmsg
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/11/24 20:17:44: Created.
//
//-------------------------------------------------------------
HRESULT CAQSvrInst::PreCatEventCompletion(
    IN  HRESULT hrStatus,
    IN  PEVENTPARAMS_PRECATEGORIZE pParams)
{
    HRESULT hr;

    _ASSERT(pParams);
    _ASSERT(pParams->pIMailMsgProperties);

    TraceFunctEnterEx((LPARAM)pParams->pIMailMsgProperties,
                      "CAQSvrInst::PreCatEventCompletion");

    DebugTrace((LPARAM)pParams->pIMailMsgProperties, "hrStatus is %08lx", hrStatus);

    //
    // Decrease count of msgs in pre-cat event
    //
    InterlockedDecrement((LPLONG) &m_cCurrentMsgsPendingPreCatEvent);

    //
    // Update the message status and check for abort/badmail
    //
    hr = SetNextMsgStatus(MP_STATUS_SUBMITTED, pParams->pIMailMsgProperties);
    if (hr == S_OK) //anything else implies that the message has been handled
    {
        //Only submit to categorizer if things message was not turfed.

        hr = SubmitMessageToCategorizer(pParams->pIMailMsgProperties);

        if(FAILED(hr))
        {
            _ASSERT((hr == AQUEUE_E_SHUTDOWN) && "SubmitMessageToCategorizer failed.");
            ErrorTrace((LPARAM)pParams->pIMailMsgProperties,
                       "SubmitMessageToCategorizer returned hr %08lx",
                       hr);
        }
    }
    //
    // Release references added in TriggerPreCategorizeEvent
    //
    pParams->pIMailMsgProperties->Release();
    Release();

    TraceFunctLeaveEx((LPARAM)pParams->pIMailMsgProperties);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Completion_PreCategorization
//
// Synopsis: SEO will call this routine after all sinks for
// OnPreCategoriztion have been handeled
//
// Arguments:
//   pvContext: Context passed into TriggerServerEvent
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/11/24 20:26:51: Created
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_PreCategorization(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnter("MailTransport_Completion_PreCategorization");

    PEVENTPARAMS_PRECATEGORIZE pParams = (PEVENTPARAMS_PRECATEGORIZE) pvContext;
    CAQSvrInst *paqinst = (CAQSvrInst *) pParams->pCCatMsgQueue;

    TraceFunctLeave();
    return paqinst->PreCatEventCompletion(
        hrStatus,
        pParams);
}


//---[ CAQSvrInst::SetCallbackTime ]-------------------------------------------
//
//
//  Description:
//      Set a callback time based on a number of minutes.
//  Parameters:
//      IN  pCallbackFn         Ptr to a callback function
//      IN  pvContext           Context pass to callback function
//      IN  dwCallbackMinutes   Minutes to wait before calling callback
//                              function.
//  Returns:
//
//  History:
//      12/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN DWORD    dwCallbackMinutes)
{
    HRESULT hr = S_OK;
    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    _ASSERT(m_pConnMgr);
    if (m_pConnMgr)
        hr = m_pConnMgr->SetCallbackTime(pCallbackFn, pvContext,
                                         dwCallbackMinutes);

    ShutdownUnlock();
  Exit:
    return hr;
}

//---[ CAQSvrInst::SetCallbackTime ]-------------------------------------------
//
//
//  Description:
//      Set a callback time based on a filetime.
//  Parameters:
//
//  Returns:
//
//  History:
//      12/29/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN FILETIME *pft)
{
    HRESULT hr = S_OK;
    DWORD   dwCallbackMinutes = 0;
    DWORD   dwTimeContext = 0;
    FILETIME ftCurrentTime;
    LARGE_INTEGER *pLargeIntCurrentTime = (LARGE_INTEGER *) &ftCurrentTime;
    LARGE_INTEGER *pLargeIntCallbackTime = (LARGE_INTEGER *) pft;

    _ASSERT(pCallbackFn);
    _ASSERT(pvContext);
    _ASSERT(pft);

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    if (!fInPast(pft, &dwTimeContext))
    {
        //Get current time using previous context (so current time is the same)
        GetExpireTime(0, &ftCurrentTime, &dwTimeContext);

        //the current time must be less than the callback time
        _ASSERT(pLargeIntCurrentTime->QuadPart < pLargeIntCallbackTime->QuadPart);

        pLargeIntCurrentTime->QuadPart = pLargeIntCallbackTime->QuadPart -
                                         pLargeIntCurrentTime->QuadPart;

        pLargeIntCurrentTime->QuadPart /= (LONGLONG) 600000000;

        //If the callback time is > 2 billion minutes... I'd
        //like to know about it in debug builds
        _ASSERT(!pLargeIntCurrentTime->HighPart);

        dwCallbackMinutes = pLargeIntCurrentTime->LowPart;

        //The only current application is for deferred delivery... I would like
        //to see the internal test situations that result in a deferred delivery
        _ASSERT(dwCallbackMinutes < (60*24*7));

        //
        //  If we have rounded down to 0 minutes, we should call back in 1
        //  otherwise we can end up in a tight loop.  If the call merely wants
        //  another thread, they should use the AsyncWorkQueue
        //
        if (!dwCallbackMinutes)
            dwCallbackMinutes = 1;
    }
    else
    {
        //If in past... callback as soon as possible, but don't use this thread, in
        //case there are locking complications (CShareLockNH is non-reentrant).
        dwCallbackMinutes = 1;
    }

    _ASSERT(m_pConnMgr);
    if (m_pConnMgr)
        hr = m_pConnMgr->SetCallbackTime(pCallbackFn, pvContext,
                                         dwCallbackMinutes);

    ShutdownUnlock();
  Exit:
    return hr;
}


//---[ CAQSvrInst::SetLinkState ]----------------------------------------------
//
//
//  Description:
//      Implements IMailTransportRouterSetLinkState::SetLinkState
//  Parameters:
//      IN  szLinkDomainName        The Domain Name of the link (next hop)
//      IN  guidRouterGUID          The GUID ID of the router
//      IN  dwScheduleID            The schedule ID link
//      IN  szConnectorName         The connector name given by the router
//      IN  dwFlagsToSet            Link State Flags to set
//      IN  dwFlagsToUnset          Link State Flags to unset
//      IN  pftNextScheduledConnection   Next scheduled connection time.
//  Returns:
//      S_OK on success
//      E_INVALIDARG if szLinkDomainName is NULL
//      AQUEUE_E_SHUTDOWN if shutting down.
//  History:
//      1/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQSvrInst::SetLinkState(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnsetLinkState,
        IN FILETIME               *pftNextScheduledConnection,
        IN IMessageRouter         *pMessageRouter)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DWORD   cbLinkDomainName = 0;
    CDomainEntry *pdentry = NULL;
    CLinkMsgQueue *plmq = NULL;
    CAQScheduleID aqsched(guidRouterGUID, dwScheduleID);
    BOOL fRemoveOwnedSchedule = TRUE;

    if (!szLinkDomainName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    cbLinkDomainName = lstrlen(szLinkDomainName);

    // see if they want to create a new link
    if (dwSetLinkState & LINK_STATE_CREATE_IF_NECESSARY) {
        // creating a link requires a pmessagerouter
        if (pMessageRouter == NULL) {
            hr = E_POINTER;
        } else {
            LinkFlags lf;

            if (dwSetLinkState & LINK_STATE_TYPE_INTERNAL_SMTP) {
                lf = eLinkFlagsInternalSMTPLinkInfo;
            } else {
                _ASSERT(dwSetLinkState & LINK_STATE_TYPE_EXTERNAL_SMTP);
                lf = eLinkFlagsExternalSMTPLinkInfo;
            }

            dwSetLinkState &=
                ~(LINK_STATE_TYPE_INTERNAL_SMTP |
                  LINK_STATE_TYPE_EXTERNAL_SMTP);

            // get the link, and create it if it doesn't exist and they want to
            // have a new link created
            hr = m_dmt.HrGetOrCreateLink(szLinkDomainName,
                                         cbLinkDomainName,
                                         dwScheduleID,
                                         szConnectorName,
                                         pMessageRouter,
                                         TRUE,
                                         lf,
                                         &plmq,
                                         &fRemoveOwnedSchedule);
        }
    } else {
        cbLinkDomainName = lstrlen(szLinkDomainName);

        hr = HrGetDomainEntry(cbLinkDomainName, szLinkDomainName, &pdentry);

        if (SUCCEEDED(hr))
            hr = pdentry->HrGetLinkMsgQueue(&aqsched, &plmq);
    }
    if (FAILED(hr))
        goto Exit;

    // this bit is only used above, so remove it
    dwSetLinkState &= ~LINK_STATE_CREATE_IF_NECESSARY;
    dwUnsetLinkState &= ~LINK_STATE_CREATE_IF_NECESSARY;

    _ASSERT(plmq);

    //
    //  If this operation is dis-allowing scheduled connections... we should
    //  record when the next scheduled attempt will be.  We should also do
    //  this before we modify the link state, so that the queue admin does
    //  not display a scheduled queue without a next connection time.
    //
    if (pftNextScheduledConnection &&
        (pftNextScheduledConnection->dwLowDateTime ||
         pftNextScheduledConnection->dwHighDateTime))
    {
        plmq->SetNextScheduledConnection(pftNextScheduledConnection);
    }

    //filter out the reserved bits for this "public" API
    plmq->dwModifyLinkState(~LINK_STATE_RESERVED & dwSetLinkState,
                            ~LINK_STATE_RESERVED & dwUnsetLinkState);

    // schedule a callback if one was requested
    if (pftNextScheduledConnection->dwLowDateTime != 0 ||
        pftNextScheduledConnection->dwHighDateTime != 0)
    {
        //callback with next attempt
        plmq->AddRef(); //Addref self as context
        hr = SetCallbackTime(
                CLinkMsgQueue::ScheduledCallback,
                plmq,
                pftNextScheduledConnection);
        if (FAILED(hr))
            plmq->Release(); //callback will not happen... release context
    }

  Exit:
    if (fLocked)
        ShutdownUnlock();

    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    //
    //  If we have not passed ownership of the shedule ID to a link,
    //  then we are responsible for releasing it.
    //
    if (fRemoveOwnedSchedule) {

        IMessageRouterLinkStateNotification *pILinkStateNotify = NULL;

        HRESULT hrLinkStateNotify =
            pMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                (VOID **) &pILinkStateNotify);

        _ASSERT( SUCCEEDED( hrLinkStateNotify));

        FILETIME ftNotUsed = {0,0};
        DWORD    dwSetNotUsed = LINK_STATE_NO_ACTION;
        DWORD    dwUnsetNotUsed = LINK_STATE_NO_ACTION;

        hrLinkStateNotify =
            pILinkStateNotify->LinkStateNotify(
                szLinkDomainName,
                guidRouterGUID,
                dwScheduleID,
                szConnectorName,
                LINK_STATE_LINK_NO_LONGER_USED,
                0, //consecutive failures
                &ftNotUsed,
                &dwSetNotUsed,
                &dwUnsetNotUsed);

        _ASSERT( SUCCEEDED( hrLinkStateNotify));

        if ( NULL != pILinkStateNotify) {
            pILinkStateNotify->Release();
        }
    }

    return hr;
}


//---[ CAQSvrInst::prstrGetDefaultDomain ]-------------------------------------
//
//
//  Description:
//      Returns the ref-counted string for the default domain
//  Parameters:
//      -
//  Returns:
//      See above
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CRefCountedString *CAQSvrInst::prstrGetDefaultDomain()
{
    CRefCountedString *prstrDefaultDomain = NULL;
    m_slPrivateData.ShareLock();
    if (m_prstrDefaultDomain)
        m_prstrDefaultDomain->AddRef();

    prstrDefaultDomain = m_prstrDefaultDomain;
    m_slPrivateData.ShareUnlock();
    return prstrDefaultDomain;
}

//+------------------------------------------------------------
//
// Function: ScheduleCatRetry
//
// Synopsis: Schedule categorizer retry if necessary
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 2000/06/08 17:31:30: Created.
//
//-------------------------------------------------------------
VOID CAQSvrInst::ScheduleCatRetry()
{
    if (!m_cCatRetriesPending)
    {
        InterlockedIncrement((PLONG) &m_cCatRetriesPending);
        //Use default retry sink to handle local retry
        _ASSERT(m_dwLocalDelayExpireMinutes && "Retry set to zero!");
        m_pConnMgr->SetCallbackTime(CatRetry, this, g_cCatRetryMinutes);
    }
} // CAQSvrInst::ScheduleCatRetry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqadmsvr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadmsvr.h
//
//  Description: Contains definitions for internal structures, classes and 
//      enums that are needed by to handle the Queue Admin functionality
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/3/98 - MikeSwa Created 
//      2/21/98 - MikeSwa added support for IQueueAdmin* interfaces
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQADMSVR_H__
#define __AQADMSVR_H__

#include <aqueue.h>
#include <intrnlqa.h>

#define AQ_MSG_FILTER_SIG   'FMQA'

//enum describing internal flags
typedef enum tagAQ_MSG_FILTER
{
    AQ_MSG_FILTER_MESSAGEID                = 0x00000001,
    AQ_MSG_FILTER_SENDER                   = 0x00000002,
    AQ_MSG_FILTER_RECIPIENT                = 0x00000004,
    AQ_MSG_FILTER_OLDER_THAN               = 0x00000008,
    AQ_MSG_FILTER_LARGER_THAN              = 0x00000010,
    AQ_MSG_FILTER_FROZEN                   = 0x00000020,
    AQ_MSG_FILTER_FIRST_N_MESSAGES         = 0x00000040,
    AQ_MSG_FILTER_N_LARGEST_MESSAGES       = 0x00000080,
    AQ_MSG_FILTER_N_OLDEST_MESSAGES        = 0x00000100,
    AQ_MSG_FILTER_FAILED                   = 0x00000200,
    AQ_MSG_FILTER_ENUMERATION              = 0x10000000,
    AQ_MSG_FILTER_ACTION                   = 0x20000000,
    AQ_MSG_FILTER_ALL                      = 0x40000000,
    AQ_MSG_FILTER_INVERTSENSE              = 0x80000000,
} AQ_MSG_FILTER;

#define AQUEUE_DEFAULT_SUPPORTED_ENUM_FILTERS  (\
            MEF_FIRST_N_MESSAGES | \
            MEF_SENDER | \
            MEF_RECIPIENT | \
            MEF_LARGER_THAN | \
            MEF_OLDER_THAN | \
            MEF_FROZEN | \
            MEF_FAILED | \
            MEF_ALL | \
            MEF_INVERTSENSE)

HRESULT QueryDefaultSupportedActions(DWORD  *pdwSupportedActions,
                                     DWORD  *pdwSupportedFilterFlags);

//QueueAdmin Map function (can be used on CFifoQueue).
typedef HRESULT (* QueueAdminMapFn)(CMsgRef *, PVOID, BOOL *, BOOL *);

//---[ CAQAdminMessageFilter ]-------------------------------------------------
//
//
//  Description: 
//      Internal representation for the MESSAGE_FILTER and MESSAGE_ENUM_FILETER
//      structures.  Provides helper functions to help maintain search lists
//      and allow a CMsgRef to complare itself to the filter description in an
//      efficient manner.
//
//      The idea is that a CMsgRef will query for the properties requested
//      in this filter by calling dwGetMsgFilterFlags() and calling the 
//      specialize compare functions (which will handle the mechanics of
//      AQ_MSG_FILTER_INVERTSENSE).
//  Hungarian: 
//      aqmf, paqmf
//  
//-----------------------------------------------------------------------------
class CAQAdminMessageFilter :
    public IQueueAdminMessageFilter,
    public CBaseObject
{
  private:
    DWORD           m_dwSignature;
    DWORD           m_cMessagesToFind; //0 => find as many as possible
    DWORD           m_cMessagesToSkip;
    DWORD           m_cMessagesFound;
    DWORD           m_dwFilterFlags;
    MESSAGE_ACTION  m_dwMessageAction;
    LPSTR           m_szMessageId;
    LPSTR           m_szMessageSender;
    LPSTR           m_szMessageRecipient;
    DWORD           m_dwThresholdSize;
    FILETIME        m_ftThresholdTime;
    MESSAGE_INFO   *m_rgMsgInfo;
    MESSAGE_INFO   *m_pCurrentMsgInfo;
    DWORD           m_dwMsgIdHash;
    IQueueAdminAction *m_pIQueueAdminAction;
    PVOID           m_pvUserContext;

  public:
    CAQAdminMessageFilter()
    {
        //Don't zero vtable :)
        ZeroMemory(((BYTE *)this)+
                    FIELD_OFFSET(CAQAdminMessageFilter, m_dwSignature), 
                    sizeof(CAQAdminMessageFilter) - 
                    FIELD_OFFSET(CAQAdminMessageFilter, m_dwSignature));
        m_dwSignature = AQ_MSG_FILTER_SIG;
    };

    ~CAQAdminMessageFilter();

    void    InitFromMsgFilter(PMESSAGE_FILTER pmf);
    void    InitFromMsgEnumFilter(PMESSAGE_ENUM_FILTER pemf);
    void    SetSearchContext(DWORD cMessagesToFind, MESSAGE_INFO *rgMsgInfo);
    void    SetMessageAction(MESSAGE_ACTION MessageAction);

    DWORD   dwGetMsgFilterFlags() {return m_dwFilterFlags;};
    BOOL    fFoundEnoughMsgs();
    BOOL    fFoundMsg();
    BOOL    fSkipMsg()
    {
        if (m_cMessagesToSkip)
        {
            m_cMessagesToSkip--;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    
    //Returns true if hash matches or is value NULL string & fMatchesId
    //should be called
    BOOL    fMatchesIdHash(DWORD dwMsgIdHash) 
        {return dwMsgIdHash ? (dwMsgIdHash == m_dwMsgIdHash) : TRUE;};

    DWORD   cMessagesFound() {return m_cMessagesFound;};
    MESSAGE_INFO *pmfGetMsgInfo() {return m_pCurrentMsgInfo;};
    MESSAGE_INFO *pmfGetMsgInfoAtIndex(DWORD iMsgInfo)
    {
        _ASSERT(iMsgInfo < m_cMessagesFound);
        _ASSERT(iMsgInfo < m_cMessagesToFind);
        return &(m_rgMsgInfo[iMsgInfo]);
    };
    
    BOOL    fMatchesId(LPCSTR szMessageId);
    BOOL    fMatchesSender(LPCSTR szMessageSender);
    BOOL    fMatchesRecipient(LPCSTR szMessageRecipient);
    BOOL    fMatchesP1Recipient(IMailMsgProperties *pIMailMsgProperties);
    BOOL    fMatchesSize(DWORD dwSize);
    BOOL    fMatchesTime(FILETIME *pftTime);

  public: //IUnknown
    //CBaseObject handles addref and release
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

  public: //IQueueAdminMessageFilter
    STDMETHOD(HrProcessMessage)(
            IUnknown *pIUnknownMsg,
            BOOL     *pfContinue,
            BOOL     *pfDelete);

    STDMETHOD(HrSetQueueAdminAction)(
            IQueueAdminAction *pIQueueAdminAction);

    STDMETHOD(HrSetCurrentUserContext)(
            PVOID	pvContext);

    STDMETHOD(HrGetCurrentUserContext)(
            PVOID	*ppvContext);
};

//Allocator funcations that are safe for the required RPC calls made by QueueAdmin
inline PVOID pvQueueAdminAlloc(size_t cbSize)
{
    return LocalAlloc(0, cbSize);
}

inline PVOID pvQueueAdminReAlloc(PVOID pvSrc, size_t cbSize)
{
    return LocalReAlloc(pvSrc, cbSize, 0);
}

inline void QueueAdminFree(PVOID pvFree)
{
    LocalFree(pvFree);
}

//Convert internal AQ config into to exportable UNICODE
LPWSTR wszQueueAdminConvertToUnicode(LPSTR szSrc, DWORD cSrc, BOOL fUTF8 = FALSE);

//Convert QueueAdmin parameter to UNICODE
LPSTR  szUnicodeToAscii(LPCWSTR szSrc);

BOOL fBiStrcmpi(LPSTR sz, LPWSTR wsz); //compares UNICODE to ASCII string

HRESULT HrQueueAdminGetStringProp(IMailMsgProperties *pIMailMsgProperties,
                                  DWORD dwPropID, LPSTR *pszProp, 
                                  DWORD *pcbProp = NULL);

HRESULT HrQueueAdminGetUnicodeStringProp(
                                  IMailMsgProperties *pIMailMsgProperties,
                                  DWORD dwPropID, LPWSTR *pwszProp, 
                                  DWORD *pcbProp = NULL);

DWORD   cQueueAdminGetNumRecipsFromRFC822(LPSTR szHeader, DWORD cbHeader);

void QueueAdminGetRecipListFromP1IfNecessary(
                                       IMailMsgProperties *pIMailMsgProperties,
                                       MESSAGE_INFO *pMsgInfo);

BOOL fQueueAdminIsP1Recip(IMailMsgProperties *pIMailMsgProperties,
                          LPCSTR szRecip);

//---[ dwQueueAdminHash ]------------------------------------------------------
//
//
//  Description: 
//      Function To Hash Queue Admin Strings.  Specifically designed for MSGIDs
//      so we do not have to open the property stream to check the MSGID during
//      QueueAdmin operations.
//  Parameters:
//      IN  szString        String to Hash
//  Returns:
//      DWORD hash
//  History:
//      1/18/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline DWORD dwQueueAdminHash(LPCSTR szString)
{
    DWORD dwHash = 0;
    
    if (szString)
    {
        while (szString && *szString)
        {
            //Use Hash from Domhash.lib
            dwHash *= 131;  //First prime after ASCII character codes
            dwHash += *szString;
            szString++;
        }
    }
    return dwHash;
}

//FifoQ Map function used to implement a majority of queue admin functionality
//pvContext should be a pointer to a IQueueAdminMessageFilter interface
HRESULT QueueAdminApplyActionToMessages(IN CMsgRef *pmsgref, IN PVOID pvContext,
                                    OUT BOOL *pfContinue, OUT BOOL *pfDelete);

#endif //__AQADMSVR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqnotify.h ===
//-----------------------------------------------------------------------------
//
//
//  File: AQNotify.h
//
//  Description:  Contains definitions for the notification interface used 
//      within Advanced Queuing..
//
//  Author: mikeswa
//
//  History:
//      11/2/98 - MikeSwa. Added IAQNotification 
//
//  Copyright (C) 1997, 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _AQNOTIFY_H_
#define _AQNOTIFY_H_

#include "aqincs.h"
class CAQStats;

//---[ IAQNotify ]-------------------------------------------------------
//
//
//  Description: 
//      Internal AQ Interface that is used to pass dynamic updates about 
//      queue size, volume, priority, etc...
//  Hungarian: 
//      pIAQNotify
//  
//-----------------------------------------------------------------------------
class IAQNotify
{
  public:
    virtual HRESULT HrNotify(CAQStats *paqstats, BOOL fAdd) = 0;
};


#endif //_AQNOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqprecmp.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqprecmp.h
//
//  Description:  Precompiled CPP phatq\advqueue
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/19/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <aqprecmp.h>

#include <mailmsg_i.c>
#include <smtpevent_i.c>

#ifdef PLATINUM
#include <ptntintf_i.c>
#include <exdrv_i.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqinst.h ===
//-----------------------------------------------------------------------------
//
//
//    File: aqinst.h
//
//    Description:
//      CAQSvrInst is a central dispatcher class for Advanced Queuing.  It 
//      coordinates shutdown and exposes the following COM interfaces:
//          - IAdvQueue
//          - IAdvQueueConfig
//
//    Owner: mikeswa
//
//    History:
//      9/3/98 - MikeSwa - changed from legacy name catmsgq.h & CCatMsgQueue
//
//    Copyright (C) 1997, 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQINST_H__
#define __AQINST_H__

#include "cmt.h"
#include <rwnew.h>
#include "baseobj.h"
#include "aqueue.h"
#include "domcfg.h"
#include "domain.h"
#include "smtpseo.h"
#include "smproute.h"
#include "qwiktime.h"
#include "dsnsink.h"
#include "asyncq.h"
#include "shutdown.h"
#include "refstr.h"
#include "msgguid.h"
#include "aqdbgcnt.h"
#include "aqnotify.h"
#include "defdlvrq.h"
#include "failmsgq.h"
#include "asncwrkq.h"
#include "tran_evntlog.h"
#include "aqreg.h"

//-- *** LOCKS IN AQUEUE *** --------------------------------------------------
//
// NOTE: General comment on locks in aqueue.
//
//   In general, we use CShareLockNH as our locking mechanism.  These locks are
//  Reader/Writer locks with TryEnter semantics and the performance feature 
//  that they use less than 1 handle per lock (~1 handle per thread).
//
//   Shutdown is handled by using these locks.  Each class that serves as an
//  entrypoint for external threads (CAsyncQueue & CConnMgr) inherits from
//  CSyncShutdown.  At shutdown, this classes lock is aquired EXCLUSIVE, and 
//  to protect operations from shutdown, a this classes lock is aquired SHARED
//  for the duration of the opertaion.  Getting the shutdown sharelock either
//  success or fails without blocking (aquiring the EXCLUSIVE shutdown lock is
//  the only blocking call).
//
//   The only other global lock is the virtual server instance routing lock.
//  This is acquired shared for all operations at the same level the exclusive
//  lock is aquired.  This is acquired exlusively *only* for router changes 
//  caused by IRouterReset::ResetRoutes.
//
//   If other classes have data which needs to be protected, they will have a 
//  m_slPrivateData sharelock.  Any operation that needs to read data in a 
//  thread-safe manner, should aquire the m_slPrivateData SHARED.  Any 
//  operation that needs to write data that is accessable by multiple threads
//  should aquire that object's m_slPrivateData lock EXCLUSIVE.
//
//   Some objects (CFifoQueue for example) require more than one lock to avoid
//  contention.  These objects will have locks that are descriptive of that
//  particular locks functions.  CFifoQueue, for example, uses m_slHead and
//  m_slTail to respectively protect the head and tail of the queue.
//
//-----------------------------------------------------------------------------

// forward declarations to avoid #include nightmares
class    CLinkMsgQueue;
class    CConnMgr;
class    CAQStats;
class    CDSNParams;
class    CMsgRef;

#define MEMBER_OK(pStruct, Member) \
    (((LONG) (pStruct)->cbVersion) >= ( ((BYTE *) &((pStruct)->Member)) - ((BYTE *) pStruct)))

//For Service callback function
typedef void (*PSRVFN)(PVOID);

//CatMsgQueue Signature
#define CATMSGQ_SIG ' QMC'

//Total number of IMsgs in the system (all virtual servers)
_declspec(selectany) DWORD g_cIMsgInSystem = 0;

//List of virtual servers used by debugger extensions
_declspec(selectany) LIST_ENTRY g_liVirtualServers = {&g_liVirtualServers, &g_liVirtualServers};

//Sharelock used to access global virtual servers
_declspec(selectany) CShareLockNH *g_pslGlobals = NULL;

//Setup defaults
const DWORD g_cMaxConnections = 10000;  //Maximum # of total connections allocated
const DWORD g_cMaxLinkConnections = 10; //Maximum # of connections per link
const DWORD g_cMinMessagesPerConnection = 20; //There must be this many messages
                                             //per addional connection that is
                                             //allocated for a link
const DWORD g_cMaxMessagesPerConnection = 20; //We server atmost these many messages per connection
const DWORD g_dwConnectionWaitMilliseconds = 3600000;

const DWORD g_dwRetryThreshold  = 3;    // Till 3 consecutive failures we treat it as glitch;
const DWORD g_dwGlitchRetrySeconds = (1 * 60);  // retry a glitch failure in one minute

const DWORD g_dwFirstTierRetrySeconds = (15 * 60);   // retry a failure in 15 minutes
const DWORD g_dwSecondTierRetrySeconds = (60 * 60);   // retry a failure in 60 minutes
const DWORD g_dwThirdTierRetrySeconds = (12 * 60 * 60); // retry a failure in 12 hrs
const DWORD g_dwFourthTierRetrySeconds = (24 * 60 * 60); // retry a failure in 24 hrs

const DWORD g_dwRetriesBeforeDelay = 5;
const DWORD g_dwDelayIntervalsBeforeNDR = 2;
const DWORD g_dwDelayExpireMinutes = g_dwRetriesBeforeDelay*g_dwFirstTierRetrySeconds/(60);
const DWORD g_dwNDRExpireMinutes = g_dwDelayIntervalsBeforeNDR*g_dwDelayExpireMinutes;


//
//  Additional message failure codes that should move to aqueue.idl.
//
#define MESSAGE_FAILURE_CAT (MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE+1)

//---[ eAQFailure ]-------------------------------------------------------------
//
//
//  Description: 
//      Enum used to desribe failure scenarios that will require special handling
//  Hungarian: 
//      eaqf
//  
//-----------------------------------------------------------------------------
typedef enum eAQFailure_
{
    AQ_FAILURE_CANNOT_NDR_UNRESOLVED_RECIPS = 0,
    AQ_FAILURE_PREROUTING_FAILED,
    AQ_FAILURE_PRECAT_RETRY,
    AQ_FAILURE_POSTCAT_EVENT,
    AQ_FAILURE_NO_RESOURCES,
    AQ_FAILURE_NDR_OF_DSN,
    AQ_FAILURE_NO_RECIPS,
    AQ_FAILURE_PENDING_DEFERRED_DELIVERY,
    AQ_FAILURE_PROCESSING_DEFERRED_DELIVERY,
    AQ_FAILURE_MSGREF_RETRY,
    AQ_FAILURE_PRELOCAL_QUEUE,
    AQ_FAILURE_INTERNAL_ASYNCQ,
    AQ_FAILURE_NUM_SITUATIONS //always keep this as last
} eAQFailure; 

_declspec(selectany) DWORD g_cTotalAQFailures = 0;
_declspec(selectany) DWORD g_cAQFailureSituations = AQ_FAILURE_NUM_SITUATIONS;
_declspec(selectany) DWORD g_rgcAQFailures[AQ_FAILURE_NUM_SITUATIONS] = {0};

//---[ CAQSvrInst ]------------------------------------------------------------
//
//
//  Hungarian: aqinst, paqinst
//
//  Legacy Hungarian: cmq, pcmq (from old CCatMsgQueue object)
//
//  Provides an interface definition for the enqueuing/acking categorized
//  messages Also provides an interface for creating link queues.
//
//  Only one of these objects exist per virtual server... it is used a
//  co-ordinating object used to handle an orderly shutdown.
//
//-----------------------------------------------------------------------------
class CAQSvrInst :
    public CBaseObject,
    public CSyncShutdown,
    public IAdvQueue,
    public IAdvQueueConfig,
    public IAdvQueueAdmin,
    public IMailTransportRoutingEngine,
    public IMailTransportRouterReset,
    public IAdvQueueDomainType,
    public IAQNotify,
    public IMailTransportRouterSetLinkState
{
protected:
    DWORD                   m_dwSignature;
    LIST_ENTRY              m_liVirtualServers;
    DWORD                   m_dwServerInstance; //Virtual server instance

    //Useful signatures that include flavor and verision information
    DWORD                   m_cbClasses;
    DWORD                   m_dwFlavorSignature;

    //Total counts used for counting totals of messages that have passed 
    //through the system.  Very useful for determing which component has
    //dropped a message after a stress run.
    LONG                    m_cTotalMsgsQueued; //Total # of messages on dest queues (after fanout)
    LONG                    m_cMsgsAcked;       //Total # of messages that have been acknowledged
    LONG                    m_cMsgsAckedRetry;  //Total # of messages acked with retry all
    LONG                    m_cMsgsDeliveredLocal; //Total # of messages delivered to local store
    DWORD                   m_cMsgsAckedRetryLocal; //Total # of messages msgs that have been ack'd retry

    //Current system state counters
    DWORD                   m_cCurrentMsgsSubmitted; //# total msgs in system
    DWORD                   m_cCurrentMsgsPendingCat; //# Msgs that have not be categorized
    DWORD                   m_cCurrentMsgsPendingRouting; //# Msgs that have not been routed.
    DWORD                   m_cCurrentMsgsPendingDelivery; //# Msgs pending remote delivery
    DWORD                   m_cCurrentMsgsPendingLocal; //# Msgs pending local delivery
    DWORD                   m_cCurrentMsgsPendingLocalRetry; //# Msgs pending local retries
    DWORD                   m_cCurrentMsgsPendingRetry; //# Msgs with unsuccessful attempts
    DWORD                   m_cCurrentQueueMsgInstances;  //# of msgs instances pending 
                                                    //remote deliver (>= #msgs)
    DWORD                   m_cCurrentRemoteDestQueues; //# of DestMsgQueues created
    DWORD                   m_cCurrentRemoteNextHops; //# of Next Hop links created
    DWORD                   m_cCurrentRemoteNextHopsEnabled; //# of links that can have connections
    DWORD                   m_cCurrentRemoteNextHopsPendingRetry; //# of links pending retry
    DWORD                   m_cCurrentRemoteNextHopsPendingSchedule; //# of links pending schedule
    DWORD                   m_cCurrentRemoteNextHopsFrozenByAdmin; //# of links frozen by admin
    DWORD                   m_cTotalMsgsSubmitted; //# of messages submitted to AQ
    DWORD                   m_cTotalExternalMsgsSubmitted; //# of messages submitted to AQ externally
    DWORD                   m_cCurrentMsgsPendingSubmitEvent; //# of messages in submission event
    DWORD                   m_cCurrentMsgsPendingPreCatEvent; //# of messages in PreCat event
    DWORD                   m_cCurrentMsgsPendingPostCatEvent; //# of messages in PostCat event
    DWORD                   m_cDelayedDSNs; //# of DSN's that contain action:delayed
    DWORD                   m_cNDRs;        //# of DSN's that contain action:failed 
    DWORD                   m_cDeliveredDSNs; //# of DSN's that contain action:delivered
    DWORD                   m_cRelayedDSNs; //# of DSN's that contain action:relayed
    DWORD                   m_cExpandedDSNs; //# of DSN's that contain action:expanded
    DWORD                   m_cDMTRetries;
    DWORD                   m_cSupersededMsgs;
    DWORD                   m_cTotalMsgsTURNETRNDelivered;
    DWORD                   m_cTotalMsgsBadmailed;
    DWORD                   m_cCatMsgCalled;
    DWORD                   m_cCatCompletionCalled;
    DWORD                   m_cBadmailNoRecipients;
    DWORD                   m_cBadmailHopCountExceeded;
    DWORD                   m_cBadmailFailureGeneral;
    DWORD                   m_cBadmailBadPickupFile;
    DWORD                   m_cBadmailEvent;
    DWORD                   m_cBadmailNdrOfDsn;
    DWORD                   m_cTotalDSNFailures;
    DWORD                   m_cCurrentMsgsInLocalDelivery;
    DWORD                   m_cTotalResetRoutes;
    DWORD                   m_cCurrentPendingResetRoutes;
    DWORD                   m_cCurrentMsgsPendingSubmit;
    CAQMsgGuidList          m_mglSupersedeIDs;

    CShareLockInst          m_slPrivateData; //read/write lock for global config into

    CDomainMappingTable     m_dmt;  //ptr to domain mapping table
    CConnMgr               *m_pConnMgr;
    CDomainConfigTable      m_dct;
    ISMTPServer            *m_pISMTPServer;
    ISMTPServerEx          *m_pISMTPServerEx;
    HANDLE                  m_hCat;
    CAQQuickTime            m_qtTime; //exposes interfaces for getting expire times
    CDefaultDSNSink         m_dsnsink;

    //Global config data
    DWORD                   m_cMinMessagesPerConnection; 
    DWORD                   m_cMaxMessagesPerConnection; 
    DWORD                   m_dwConnectionWaitMilliseconds; 
    //retry related
    DWORD                   m_dwFirstTierRetrySeconds; //Threshold failure retry interval
    DWORD                   m_dwDelayExpireMinutes;
    DWORD                   m_dwNDRExpireMinutes;
    DWORD                   m_dwLocalDelayExpireMinutes;
    DWORD                   m_dwLocalNDRExpireMinutes;

    //Counters used to for local and cat retry
    DWORD                   m_cLocalRetriesPending;
    DWORD                   m_cCatRetriesPending;
    DWORD                   m_cRoutingRetriesPending;
    DWORD                   m_cSubmitRetriesPending;


    DWORD                   m_dwInitMask; //used to keep track of who has been init'd
    IMessageRouter          *m_pIMessageRouterDefault;
    CRefCountedString       *m_prstrDefaultDomain;
    CRefCountedString       *m_prstrBadMailDir;
    CRefCountedString       *m_prstrCopyNDRTo;
    CRefCountedString       *m_prstrServerFQDN;

    //DSN Options
    DWORD                   m_dwDSNOptions;
    DWORD                   m_dwDSNLanguageID;

    CAsyncMailMsgQueue      m_asyncqPreCatQueue;

    CAsyncRetryAdminMsgRefQueue m_asyncqPreLocalDeliveryQueue;
    CAsyncMailMsgQueue      m_asyncqPostDSNQueue;
    CAsyncMailMsgQueue      m_asyncqPreRoutingQueue;
    CAsyncMailMsgQueue      m_asyncqPreSubmissionQueue;
    CDebugCountdown         m_dbgcnt;
    //Flags used to describe what has been initialized

    IMailTransportRouterReset *m_pIRouterReset;  //pointer to router reset implementation

    //Queue and counter for deferred delivery
    CAQDeferredDeliveryQueue m_defq;
    DWORD                    m_cCurrentMsgsPendingDeferredDelivery;

    //Failed Msg Queue
    CFailedMsgQueue          m_fmq;
    DWORD                    m_cCurrentResourceFailedMsgsPendingRetry;

    //Work queue used to do async work items
    CAsyncWorkQueue          m_aqwWorkQueue;

    BOOL                     m_fMailMsgReportsNumHandles;

    typedef enum _eCMQInitFlags
    {
        CMQ_INIT_OK             = 0x80000000,
        CMQ_INIT_DMT            = 0x00000001,
        CMQ_INIT_DCT            = 0x00000002,
        CMQ_INIT_CONMGR         = 0x00000004,
        CMQ_INIT_LINKQ          = 0x00000008,
        CMQ_INIT_DSN            = 0x00000010,
        CMQ_INIT_PRECATQ        = 0x00000020,
        CMQ_INIT_PRELOCQ        = 0x00000040,
        CMQ_INIT_POSTDSNQ       = 0x00000080,
        CMQ_INIT_ROUTER_RESET   = 0x00000100,
        CMQ_INIT_ROUTINGQ       = 0x00000200,
        CMQ_INIT_WORKQ          = 0x00000400,
        CMQ_INIT_SUBMISSIONQ    = 0x00000800,
        CMQ_INIT_MSGQ           = 0x80000000,
    } eCMQInitFlags;

public:

    CAQSvrInst(DWORD dwServerInstance,
                 ISMTPServer *pISMTPServer);
    ~CAQSvrInst();

    HRESULT HrInitialize(
                    IN  LPSTR   szUserName = NULL,
                    IN  LPSTR   szDomainName = NULL,
                    IN  LPSTR   szPassword = NULL,
                    IN  PSRVFN  pServiceStatusFn = NULL,
                    IN  PVOID   pvServiceContext = NULL);

    HRESULT HrDeinitialize();

    //publicly accessable member values 
    //MUST wrap in fTryShutdownLock - ShutdownUnlock
    CDomainMappingTable    *pdmtGetDMT() {AssertShutdownLockAquired();return &m_dmt;};
    CAQMsgGuidList         *pmglGetMsgGuidList() {AssertShutdownLockAquired(); return &m_mglSupersedeIDs;};

    HRESULT HrGetIConnectionManager(OUT IConnectionManager **ppIConnectionManager);

    //Public Methods exposed through events (or some other mechanism)
    // This function queues a categorized message for remote/local delivery
    BOOL fRouteAndQueueMsg(IN IMailMsgProperties *pIMailMsg);

    //Acknowledge the message ref.
    //There should be one Ack for every dequeue from a link.
    HRESULT HrAckMsg(MessageAck *pMsgAck, BOOL fLocal = FALSE);

    //methods to (un)map domain names to ids.
    HRESULT HrGetDomainMapping(
                IN LPSTR szDomainName, //Domain name
                OUT CDomainMapping *pdmap); //resulting domain mapping
    HRESULT HrGetDomainName(
                IN CDomainMapping *pdmap, //Domain mapping
                OUT LPSTR *pszDomainName);  //resolved domain name

    //Pass notifications off to Connection Manager
    HRESULT HrNotify(IN CAQStats *paqstats, BOOL fAdd);

    //Expose ability to get internal Domain Info to internal components
    HRESULT HrGetInternalDomainInfo(IN  DWORD cbDomainNameLength,
                                    IN  LPSTR szDomainName,
                                    OUT CInternalDomainInfo **ppDomainInfo);

    HRESULT HrGetDefaultDomainInfo(OUT CInternalDomainInfo **ppDomainInfo);

    //Get Domain Entry from DMT
    HRESULT HrGetDomainEntry(IN  DWORD cbDomainNameLength,
                             IN  LPSTR szDomainName,
                             OUT CDomainEntry **ppdentry);

    // jstamerj 980607 21:41:25: The completion routine of the
    // submission event trigger 
    HRESULT SubmissionEventCompletion(
        HRESULT hrStatus,
        PEVENTPARAMS_SUBMISSION pParams);

    // jstamerj 1998/11/24 19:53:24: Fire off the PreCat event
    VOID    TriggerPreCategorizeEvent(IN IMailMsgProperties *pIMailMsgProperties);

    // jstamerj 1998/11/24 19:54:23: Completion routine of the pre-cat event
    HRESULT PreCatEventCompletion(IN HRESULT hrStatus, IN PEVENTPARAMS_PRECATEGORIZE pParams);

    // jstamerj 980610 12:24:29: Called from HrPreCatEventCompletion
    HRESULT SubmitMessageToCategorizer(IN IMailMsgProperties *pIMailMsgProperties);

    // jstamerj 980616 22:06:45: Called from CatCompletion
    void    TriggerPostCategorizeEvent(IUnknown *pIMsg, IUnknown **rgpIMsg);

    // jstamerj 980616 22:07:18: triggers a post-cat event for one message
    HRESULT TriggerPostCategorizeEventOneMsg(IUnknown *pIMsg);

    // jstamerj 980616 22:07:54: Handles post-cat event completions
    HRESULT PostCategorizationEventCompletion(HRESULT hrStatus, PEVENTPARAMS_POSTCATEGORIZE pParams);

    // 11/17/98 - MikeSwa added for CDO badmail/abort delivery
    //  returns S_FALSE if message has been completely handled.
    HRESULT SetNextMsgStatus(IN  DWORD dwCurrentStatus, 
                             IN  IMailMsgProperties *pIMailMsgProperties);

    //Called by async completion to PreCat Queue
    BOOL    fPreCatQueueCompletion(IMailMsgProperties *pIMailMsgProperties);

    //Called by async completion to PreCat Queue
    BOOL    fPreLocalDeliveryQueueCompletion(CMsgRef *pmsgref);

    //Used to restart async queues after failures
    void    AsyncQueueRetry(DWORD dwQueueID);

    //Called to Set message expiry times during SubmitMessage
    HRESULT HrSetMessageExpiry(IMailMsgProperties *pIMailMsgProperties);

    //API to keep counters in sync
    inline DWORD cIncMsgsInSystem(); //returns total of all virtual servers
    inline void DecMsgsInSystem(BOOL fWasRetriedRemote = FALSE, BOOL fWasRemote = FALSE,
                                BOOL fWasRetriedLocal = FALSE);

    //Called by Msgref on first message retry
    inline void IncRetryCount(BOOL fLocal);

    //Called by DestMsgQueue to describe message fanout
    inline void IncQueueMsgInstances();
    inline void DecQueueMsgInstances();

    //Used to keep track of the number of queues/next hops
    inline void  IncDestQueueCount();
    inline void  DecDestQueueCount();
    inline DWORD cGetDestQueueCount();
    inline void  IncNextHopCount();
    inline void  DecNextHopCount();

    //Called by functions walk pre-local queue for NDRs
    inline void DecPendingLocal();

    inline void IncTURNETRNDelivered();

    //aszafer 1/28/00
    //used to decide start/stop throttling handles
    DWORD cCountMsgsForHandleThrottling(IN IMailMsgProperties *pIMailMsgProperties);

    //Functions to call into the specifc hash tables to iterate over subdomains
    //
    HRESULT HrIterateDMTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext) ;
    HRESULT HrIterateDCTSubDomains(IN LPSTR szDomainName,
                                   IN DWORD cbDomainNameLength,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext);

    //Calls that allow access to time objects
    inline void GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext); //if non-zero, will use last time

    inline BOOL fInPast(IN FILETIME *pftExpireTime, IN OUT DWORD *pdwExpireContext);

    HRESULT HrTriggerDSNGenerationEvent(CDSNParams *pdsnparams, BOOL fHasRoutingLock);

    HRESULT HrNDRUnresolvedRecipients(IMailMsgProperties *pIMailMsgProperties,
                                      IMailMsgRecipients *pIMailMsgRecipients);

    //friend functions that can be used as completion functions
    friend HRESULT CatCompletion(HRESULT hrCatResult, PVOID pContext, IUnknown *pIMsg,
                      IUnknown **rgpIMsg);

    //Expose server start/stop hint functions
    inline VOID ServerStartHintFunction();
    inline VOID ServerStopHintFunction();

    //function used to handle badmail
    void HandleBadMail(IN IMailMsgProperties *pIMailMsgProperties,
                       IN BOOL fUseIMailMsgProperties,
                       IN LPSTR szFileName,
                       IN HRESULT hrReason,
                       BOOL fHasRoutingLock);

    //Function to handle some sort of system failure that would cause
    //messages/data to be lost if unhandled
    void HandleAQFailure(eAQFailure eaqfFailureSituation, 
                         HRESULT hr, IMailMsgProperties *pIMailMsgProperties);


    //Stub call for logging an event
    void LogAQEvent(HRESULT hrEventReason, CMsgRef *pmsgref, 
                    IMailMsgProperties *pIMailMsgProperties,
                    LPSTR szFileName);

    //Routing lock should be grabbed before accessing queues (after shutdown)
    void RoutingShareLock() {m_slPrivateData.ShareLock();};
    BOOL fTryRoutingShareLock() {return m_slPrivateData.TryShareLock();};
    void RoutingShareUnlock() {m_slPrivateData.ShareUnlock();};

    HRESULT SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN DWORD    dwCallbackMinutes);

    HRESULT SetCallbackTime(IN PSRVFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN FILETIME *pft);

    void DecPendingDeferred() 
        {InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingDeferredDelivery);};
    
    void DecPendingFailed() 
        {InterlockedDecrement((PLONG) &m_cCurrentResourceFailedMsgsPendingRetry);};

    void QueueMsgForLocalDelivery(CMsgRef *pmsgref, BOOL fLocalLink);

    HRESULT HrInternalSubmitMessage(IMailMsgProperties *pIMailMsgProperties);


    //Get string for default domain
    CRefCountedString *prstrGetDefaultDomain();

    //Completion Function called by MsgCat
    static HRESULT CatCompletion(HRESULT hrCatResult, PVOID pContext, 
                                 IUnknown *pImsg, IUnknown **rgpImsg);
    
    //Handles details of post-cat DSN generation
    void    HandleCatFailure(IUnknown *pIUnknown, HRESULT hrCatResult);

    //Handle the details of retrying after cat failure
    void    HandleCatRetryOneMessage(IUnknown *pIUnknown);

    HRESULT HrGetLocalQueueAdminQueue(IQueueAdminQueue **ppIQueueAdminQueue);

    HRESULT HrQueueFromQueueID(QUEUELINK_ID *pqlQueueId,
                            IQueueAdminQueue **ppIQueueAdminQueue);

    HRESULT HrLinkFromLinkID(QUEUELINK_ID *pqlLinkID,
                            IQueueAdminLink **ppIQueueAdminLink);

    inline HRESULT HrQueueWorkItem(PVOID pvData, 
                            PASYNC_WORK_QUEUE_FN pfnCompletion);

    static BOOL fResetRoutesNextHopCompletion(PVOID pvThis, DWORD dwStatus);

    static BOOL fPreSubmissionQueueCompletionWrapper(
                                    IMailMsgProperties *pIMailMsgProperties,
                                    PVOID pvContext);

    BOOL  fShouldRetryMessage(IMailMsgProperties *pIMailMsgProperties,
                              BOOL fShouldBounceUsageIfRetry = TRUE);

    VOID ScheduleCatRetry();

    void LogResetRouteEvent( DWORD dwObainLock, 
        DWORD dwWaitLock,
        DWORD dwQueue);

    //Routing interface used internal to AQ components
public:
    //Fires MAIL_TRANSPORT_ON_GET_ROUTER_FOR_MESSAGE_EVENT
    HRESULT HrTriggerGetMessageRouter(
            IN  IMailMsgProperties *pIMailMsg,
            OUT IMessageRouter     **pIMessageRouter);
    HRESULT HrTriggerLogEvent(
                IN DWORD                    idMessage,
                IN WORD                     idCategory,
                IN WORD                     cSubstrings,
                IN LPCSTR                   *rgszSubstrings,
                IN WORD                     wType,
                IN DWORD                    errCode,
                IN WORD                     iDebugLevel,
                IN LPCSTR                   szKey,
                IN DWORD                    dwOptions,
                IN DWORD                    iMessageString = 0xffffffff,
                IN HMODULE                  hModule = NULL);

private:
    HRESULT HrTriggerInitRouter();

    //IUnknown
public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

    //IAdvQueue
public:
    STDMETHOD(SubmitMessage)(IN IMailMsgProperties *pIMailMsgProperties);

    STDMETHOD(HandleFailedMessage)(IN IMailMsgProperties *pIMailMsgProperties,
                                   IN BOOL fUseIMailMsgProperties,
                                   IN LPSTR szFileName,
                                   IN DWORD dwFailureReason,
                                   IN HRESULT hrFailureCode);

    //IAdvQueueConfig
public:
    STDMETHOD(SetConfigInfo)(IN AQConfigInfo *pAQConfigInfo);
    STDMETHOD(SetDomainInfo)(IN DomainInfo *pDomainInfo);
    STDMETHOD(GetDomainInfo)(IN     DWORD cbDomainNameLength,
                             IN     CHAR szDomainName[],
                             IN OUT DomainInfo *pDomainInfo,
                             OUT    DWORD **ppvDomainContext);
    STDMETHOD(ReleaseDomainInfo)(IN DWORD *pvDomainContext);
    STDMETHOD(GetPerfCounters)(OUT AQPerfCounters *pAQPerfCounters,
                               OUT CATPERFBLOCK   *pCatPerfCounters);
    STDMETHOD(ResetPerfCounters)();
    STDMETHOD(StartConfigUpdate)();
    STDMETHOD(FinishConfigUpdate)();

    //IMailTransportRoutingEngine
public:
    STDMETHOD(GetMessageRouter)(
        IN  IMailMsgProperties      *pIMailMsg,
        IN  IMessageRouter          *pICurrentMessageRouter,
        OUT IMessageRouter          **ppIMessageRouter);

    //IMailTransportRouterReset
public:
    STDMETHOD(ResetRoutes)(
        IN  DWORD                   dwResetType);

    //IAdvQueueDomainType
public:
    STDMETHOD(GetDomainInfoFlags)(   
        IN  LPSTR szDomainName,
        DWORD *pdwDomainInfoFlags);

    // IAdvQueueAdmin
public:
    STDMETHOD(ApplyActionToLinks)(
        LINK_ACTION     laAction);

    STDMETHOD(ApplyActionToMessages)(
        QUEUELINK_ID    *pqlQueueLinkId,
        MESSAGE_FILTER  *pmfMessageFilter,
        MESSAGE_ACTION  maMessageAction,
        DWORD           *pcMsgs);

    STDMETHOD(GetQueueInfo)(
        QUEUELINK_ID    *pqlQueueId,
        QUEUE_INFO      *pqiQueueInfo);

    STDMETHOD(GetLinkInfo)(
        QUEUELINK_ID    *pqlLinkId,
        LINK_INFO       *pliLinkInfo,
        HRESULT         *phrLinkDiagnostic);

    STDMETHOD(SetLinkState)(
        QUEUELINK_ID    *pqlLinkId,
        LINK_ACTION     la);

    STDMETHOD(GetLinkIDs)(
        DWORD           *pcLinks,
        QUEUELINK_ID    *rgLinks);

    STDMETHOD(GetQueueIDs)(
        QUEUELINK_ID    *pqlLinkId,
        DWORD           *pcQueues,
        QUEUELINK_ID    *rgQueues);

    STDMETHOD(GetMessageProperties)(
        QUEUELINK_ID        *pqlQueueLinkId,
        MESSAGE_ENUM_FILTER *pmfMessageEnumFilter,
        DWORD               *pcMsgs,
        MESSAGE_INFO        *rgMsgs);

    STDMETHOD(QuerySupportedActions)(
        QUEUELINK_ID        *pqlQueueLinkId,
        DWORD               *pdwSupportedActions,
        DWORD               *pdwSupportedFilterFlags);


  public: //IMailTransportRouterSetLinkState
    STDMETHOD(SetLinkState)(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnSetLinkState,
        IN FILETIME               *pftNextScheduledConnection,
        IN IMessageRouter         *pMessageRouter);

};


//*** inline counter functions

//---[ CAQSvrInst::cIncMsgsInSystem ]----------------------------------------
//
//
//  Description: 
//      Used to increment the global and virtual server msg counts.  Returns 
//      the global count for resource management purposes.
//  Parameters:
//      -
//  Returns:
//      DWORD - Global # of Msgs in system
//
//-----------------------------------------------------------------------------
DWORD CAQSvrInst::cIncMsgsInSystem()
{
    InterlockedIncrement((PLONG) &m_cCurrentMsgsSubmitted);
    return (InterlockedIncrement((PLONG) &g_cIMsgInSystem));
};

//---[ CAQSvrInst::DecMsgsInSystem ]-----------------------------------------
//
//
//  Description: 
//      Decrements the global and virtual server message counts.  Also 
//      decrements the pending retry count if needed.
//  Parameters:
//      fWasRetriedRemote - TRUE if msg was retried remotely and retry count needs 
//          to be decremented.
//      fWasRemote - TRUE if message was being delivered remotely
//      fWasRetriedLocal - TRUE if counted towards m_cCurrentMsgsPendingLocalRetry
//  Returns:
//      - 
//
//-----------------------------------------------------------------------------
void CAQSvrInst::DecMsgsInSystem(BOOL fWasRetriedRemote, BOOL fWasRemote, 
                                   BOOL fWasRetriedLocal)
{
    InterlockedDecrement((PLONG) &g_cIMsgInSystem);
    InterlockedDecrement((PLONG) &m_cCurrentMsgsSubmitted);

    if (fWasRetriedRemote)
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingRetry);

    if (fWasRemote)
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingDelivery);

    if (fWasRetriedLocal)
        InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingLocalRetry);

};

//---[ CAQSvrInst::IncRetryCount ]-------------------------------------------
//
//
//  Description: 
//      Used by MsgRef the first time a Message is ack'd with a non-success
//      code.  
//  Parameters:
//      BOOL    fLocal  TRUE if message is local
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncRetryCount(BOOL fLocal)
{
    if (fLocal)
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingLocalRetry);
    else
        InterlockedIncrement((PLONG) &m_cCurrentMsgsPendingRetry);
};

//---[ CAQSvrInst::[Inc|Dec]QueueMsgInstances ]------------------------------
//
//
//  Description: 
//      Increments/decrements a count of the total number of message instances
//      queued for remote delivery.  Because a message may be put in more than
//      one queue, the steady state of this count will be at least as large as 
//      the number of messages.  However, this count reflects messages that 
//      are currently on the queues and does *not* count messages that are 
//      currently being attempted by SMTP (which m_cCurrentMsgsPendingDelivery)
//      *does* count.
//
//      Used by DestMsgQueues.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncQueueMsgInstances()
{
    InterlockedIncrement((PLONG) &m_cCurrentQueueMsgInstances);
};

void CAQSvrInst::DecQueueMsgInstances()
{
    InterlockedDecrement((PLONG) &m_cCurrentQueueMsgInstances);
};

//---[ Queue/NextHop Counter API ]---------------------------------------------
//
//
//  Description: 
//      Used to increment/decrement Queue and NextHop counters
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncDestQueueCount()
{
    InterlockedIncrement((PLONG) &m_cCurrentRemoteDestQueues);
};

void CAQSvrInst::DecDestQueueCount()
{
    InterlockedDecrement((PLONG) &m_cCurrentRemoteDestQueues);
};

DWORD CAQSvrInst::cGetDestQueueCount()
{
    return m_cCurrentRemoteDestQueues;
}

void CAQSvrInst::IncNextHopCount()
{
    InterlockedIncrement((PLONG) &m_cCurrentRemoteNextHops);
};

void CAQSvrInst::DecNextHopCount()
{
    InterlockedDecrement((PLONG) &m_cCurrentRemoteNextHops);
};


//---[ CAQSvrInst::DecPendingLocal ]-----------------------------------------
//
//
//  Description: 
//      Called by function walking pre-local delivery queue when a message
//      is being expired.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/14/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQSvrInst::DecPendingLocal()
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    InterlockedDecrement((PLONG) &m_cCurrentMsgsPendingLocal);
};


//---[ CAQSvrInst::IncTURNETRNDelivered ]--------------------------------------
//
//
//  Description: 
//      Used to keep track of the # of TURN/ETRN messages delivered.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQSvrInst::IncTURNETRNDelivered()
{
    InterlockedIncrement((PLONG) &m_cTotalMsgsTURNETRNDelivered);
}

//---[ CAQSvrInst::GetExpireTime ]-------------------------------------------
//
//
//  Description: 
//      Get the expriation time for cMinutesExpireTime from now.
//  Parameters:
//      IN     cMinutesExpireTime   # of minutes in future to set time
//      IN OUT pftExpireTime        Filetime to store new expire time
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//      -
//  History:
//      7/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQSvrInst::GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext)
{
    m_qtTime.GetExpireTime(cMinutesExpireTime, pftExpireTime,  pdwExpireContext);
}

//---[ CAQSvrInst::fInPast ]-------------------------------------------------
//
//
//  Description: 
//      Determines if a given file time has already happened
//  Parameters:
//      IN     pftExpireTime        FILETIME with expiration
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//      TRUE if expire time is in the past
//      FALSE if expire time is in the future
//  History:
//      7/11/98 - MikeSwa Created 
//  Note:
//      You should NOT use the same context used to get the FILETIME, because
//      it will always return FALSE
//
//-----------------------------------------------------------------------------
BOOL CAQSvrInst::fInPast(IN FILETIME *pftExpireTime, 
                           IN OUT DWORD *pdwExpireContext)
{
    return m_qtTime.fInPast(pftExpireTime, pdwExpireContext);
}

//---[ ServerStartHintFunction & ServerStartHintFunction ]---------------------
//
//
//  Description: 
//      Functions for telling the Service control manager that we are
//      starting/stopping the service.
//
//      These functions are often called by functions that have been passed
//      the CAQSvrInst ptr as a PVOID context, so it makes sense to check
//      and assert on our signature here.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/22/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID CAQSvrInst::ServerStartHintFunction()
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    if (m_pISMTPServer)
        m_pISMTPServer->ServerStartHintFunction();
}

VOID CAQSvrInst::ServerStopHintFunction()
{
    _ASSERT(CATMSGQ_SIG == m_dwSignature);
    if (fShutdownSignaled())
    {
        m_dbgcnt.ResetCountdown();
        //Only call stop hint if shutdown has been signalled
        if (m_pISMTPServer)
            m_pISMTPServer->ServerStopHintFunction();
    }
}

//---[ CAQSvrInst::HrQueueWorkItem ]-------------------------------------------
//
//
//  Description: 
//      Thin wrapper to queue item to async work queue
//  Parameters:
//      pvData          Data to pass to completion function
//      pfnCompletion   Completion function
//  Returns:
//      S_OK on success
//      failure code from CAsyncWorkQueue
//  History:
//      3/9/99 - MikeSwa Created 
//      7/7/99 - MikeSwa - will work during shutdown to allow multithreaded
//               shutdown work.
//
//-----------------------------------------------------------------------------
HRESULT CAQSvrInst::HrQueueWorkItem(PVOID pvData, 
                                    PASYNC_WORK_QUEUE_FN pfnCompletion)
{
    return m_aqwWorkQueue.HrQueueWorkItem(pvData, pfnCompletion);
}

#endif // __AQINST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqreg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: 
//
//  Description:
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/21/2000 - MikeSwa Created 
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "aqprecmp.h"
#include <registry.h>

//---[ CAQRegDwordDescriptor ]-------------------------------------------------
//
//
//  Description: 
//      Simple stucture used to match the name of a value of a DWORD in memory
//  Hungarian: 
//      regdw, pregwd
//  
//-----------------------------------------------------------------------------
class CAQRegDwordDescriptor
{
  public:
    LPCSTR      m_szName;
    DWORD      *m_pdwValue;
    VOID UpdateGlobalDwordFromRegistry(const CMyRegKey &regKey);
};

//
//  Array of descriptors that match the name of the value with the internal
//  variable
//
const CAQRegDwordDescriptor g_rgregwd[] = {
    {"MsgHandleThreshold",              &g_cMaxIMsgHandlesThreshold},
    {"MsgHandleAsyncThreshold",         &g_cMaxIMsgHandlesAsyncThreshold},
    {"LocalRetryMinutes",               &g_cLocalRetryMinutes},
    {"CatRetryMinutes",                 &g_cCatRetryMinutes},
    {"RoutingRetryMinutes",             &g_cRoutingRetryMinutes},
    {"SubmissionRetryMinutes",          &g_cSubmissionRetryMinutes},
    {"ResetRoutesRetryMinutes",         &g_cResetRoutesRetryMinutes},
    {"SecondsPerDSNPass",               &g_cMaxSecondsPerDSNsGenerationPass},
    {"AdditionalPoolThreadsPerProc",    &g_cPerProcMaxThreadPoolModifier},
    {"MaxPercentPoolThreads",            &g_cMaxATQPercent},
    {"ResetMessageStatus",              &g_fResetMessageStatus},
};


//---[ UpdateGlobalDwordFromRegistry ]-----------------------------------------
//
//
//  Description: 
//      Updates a global DWORD value from the registry.  Will not modify data
//      if the value is not in the registry
//  Parameters:
//      IN  regKey      CMyRegKey class for containing key
//      IN  szValue     Name of value to read under key
//      IN  pdwData     Data of value
//  Returns:
//      -
//  History:
//      1/21/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID CAQRegDwordDescriptor::UpdateGlobalDwordFromRegistry(const CMyRegKey &regKey)
{
    TraceFunctEnterEx(0, "UpdateGlobalDwordFromRegistry");
    DWORD       dwValue = 0;
    DWORD       dwErr   = NO_ERROR;
    CRegDWORD   regDWHandles(regKey, m_szName);

    
    //
    //  We should have a valid string associated with this object
    //
    _ASSERT(m_szName);

    dwErr = regDWHandles.QueryErrorStatus();
    if (NO_ERROR != dwErr)
        goto Exit;
    
    dwErr = regDWHandles.GetDword(&dwValue);
    if (NO_ERROR != dwErr)
        goto Exit;

    if (m_pdwValue)
        *m_pdwValue = dwValue;

  Exit:
    DebugTrace(0, "Reading registry value %s\\%s %d - (err 0x%08X)", 
        regKey.GetName(), m_szName, dwValue, dwErr);
    
    TraceFunctLeave();
    return;
}

//---[ ReadGlobalRegistryConfiguration ]---------------------------------------
//
//
//  Description: 
//      Reads all the global registry configuration.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/21/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID ReadGlobalRegistryConfiguration()
{
    TraceFunctEnterEx(0, "HrReadGlobalRegistryConfiguration");
    DWORD   dwErr = NO_ERROR;
    DWORD   cValues = sizeof(g_rgregwd)/sizeof(CAQRegDwordDescriptor);
    CAQRegDwordDescriptor *pregdw = (CAQRegDwordDescriptor *) g_rgregwd;

    //Key registry value
    CMyRegKey regKey(HKEY_LOCAL_MACHINE, &dwErr, AQREG_KEY_CONFIGURATION, KEY_READ);
    
    if (NO_ERROR != dwErr)
    {
        DebugTrace(0, "Opening aqreg key %s failed with - Err 0x%08X", 
            regKey.GetName(), dwErr);
        goto Exit;
    }

    //
    // Loop through all our DWORD config and store the global variable
    //
    while (cValues)
    {
        pregdw->UpdateGlobalDwordFromRegistry(regKey);
        cValues--;
        pregdw++;
    }

  Exit:
    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqprecmp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqprecmp.h
//
//  Description:  Precompiled header for aqueue\advqueue
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/15/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQPRECMP_H__
#define __AQPRECMP_H__

//Includes from external directories
#include <aqincs.h>
#include <rwnew.h>
#include <aqueue.h>
#include <mailmsgprops.h>
#include <address.hxx>
#include <mailmsg.h>
#include <mailmsgi.h>
#include <baseobj.h>
#include <tran_evntlog.h>
#include <listmacr.h>
#include <smtpevent.h>
#include <aqmem.h>

#ifdef PLATINUM
#include <phatqmsg.h>
#include <ptntdefs.h>
#include <ptntintf.h>
#include <linkstate.h>
#include <exdrv.h>
#include <ptrwinst.h>
#define  AQ_MODULE_NAME "phatq"
#else  //NOT PLATINUM
#include <aqmsg.h>
#include <rwinst.h>
#define  AQ_MODULE_NAME "aqueue"
#endif //PLATINUM


//Internal AdvQueue headers
#include "cmt.h"
#include "aqintrnl.h"
#include "aqinst.h"
#include "connmgr.h"
#include "aqadmsvr.h"
#include "linkmsgq.h"
#include "destmsgq.h"
#include "domain.h"
#include "msgref.h"
#include "dcontext.h"
#include "connmgr.h"
#include "aqnotify.h"
#include "smproute.h"
#include "qwiktime.h"
#include "shutdown.h"
#include "refstr.h"
#include "msgguid.h"
#include "aqdbgcnt.h"
#include "aqnotify.h"
#include "defdlvrq.h"
#include "failmsgq.h"
#include "asncwrkq.h"

#endif //__AQPRECMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqreg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqreg.h
//
//  Description:    Header file containing aq's registry constants
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/4/2000 - MikeSwa Created 
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQREG_H__
#define __AQREG_H__

//---[ Registry Paths ]--------------------------------------------------------
//
//
//  Description: 
//      These are the registry keys used by AQ for configuration
//  
//-----------------------------------------------------------------------------
#define AQREG_KEY_CONFIGURATION "System\\CurrentControlSet\\Services\\SMTPSVC\\Queuing"

//---[ Global Registry Variables ]---------------------------------------------
//
//
//  Description: 
//      The following are the global configuration variables that can be 
//      affected by registry settings.
//  
//-----------------------------------------------------------------------------

//
// Handle management values.  When the number of mailmsgs in the system hits 
// this threshold, we will start closing handles.
//
_declspec(selectany)    DWORD   g_cMaxIMsgHandlesThreshold      = 1000;
_declspec(selectany)    DWORD   g_cMaxIMsgHandlesAsyncThreshold = 1000;

//
//  The following is a for optimizing DSN generation.  After generating
//  a certain number of DSNs, we will quit and go and restart at a later time
//
_declspec(selectany)    DWORD   g_cMaxSecondsPerDSNsGenerationPass = 10;

//
//  The following is the amount of time to wait before retry a reset
//  routes after a routing failure
//
_declspec(selectany)    DWORD   g_cResetRoutesRetryMinutes = 10;

//
//  Async Queue retry intervals that can be modified by registry settings
//
_declspec(selectany)    DWORD   g_cLocalRetryMinutes        = 5;
_declspec(selectany)    DWORD   g_cCatRetryMinutes          = 60;
_declspec(selectany)    DWORD   g_cRoutingRetryMinutes      = 60;
_declspec(selectany)    DWORD   g_cSubmissionRetryMinutes   = 60;

//
//  Async Queue Adjustment values.  We will increase the max number 
//  of threads per proc by this value
//
_declspec(selectany)    DWORD   g_cPerProcMaxThreadPoolModifier = 6;

//
//  Async Queue Adjustment value.  We will request up to this % of 
//  max ATQ threads *per async queue*.  This % is post our modifcation
//  as per g_cPerProcMaxThreadPoolModifier.
//
_declspec(selectany)    DWORD   g_cMaxATQPercent            = 90;

//
//  Reset Message status.  If this is non-zero, we will reset the
//  message status of every message submitted to MP_STATUS_SUBMITTED.
//
_declspec(selectany)    DWORD   g_fResetMessageStatus       = 0;

//
//Reads config information from the registry and modifies the appropriate globals.
//
VOID ReadGlobalRegistryConfiguration();

#endif //__AQREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqroute.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqroute.h
//
//  Description:  AQ Routing helper classes.  Defines AQ concepts of message
//      type (CAQMessageType) and ScheduleID (CAQScheduleID).
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/21/98 - MikeSwa Created 
//      6/9/98 - MikeSwa Modified constructors
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQROUTE_H__
#define __AQROUTE_H__
#include <smproute.h>

//---[ CAQMessageType ]--------------------------------------------------------
//
//
//  Description: 
//      Encapsulates message type returned by IMessageRouter as well as the 
//      GUID id of the message router itself
//  Hungarian: 
//      aqmt, paqmt
//  
//-----------------------------------------------------------------------------
class CAQMessageType
{
public:
    inline CAQMessageType(GUID guidRouter, DWORD dwMessageType);
    inline CAQMessageType(CAQMessageType *paqmt);
    inline BOOL    fIsEqual(CAQMessageType *paqmt);
    inline BOOL    fSameMessageRouter(CAQMessageType *paqmt);
    DWORD  dwGetMessageType() {return m_dwMessageType;};
    inline void    GetGUID(IN OUT GUID *pguid);

    //Used to update message type when changed befored msg is queued
    void   SetMessageType(DWORD dwMessageType) {m_dwMessageType = dwMessageType;};
protected:
    GUID    m_guidRouter;
    DWORD   m_dwMessageType;
};

//---[ CAQScheduleID ]---------------------------------------------------------
//
//
//  Description: 
//      Encapsulates schedule id returned by IMessageRouter as well as the
//      GUID id of the message router itseld
//  Hungarian: 
//      aqsched, paqsched
//  
//-----------------------------------------------------------------------------
class CAQScheduleID
{
public:
    inline CAQScheduleID();
    inline CAQScheduleID(IMessageRouter *pIMessageRouter, DWORD dwScheduleID);
    inline CAQScheduleID(GUID guidRouter, DWORD dwScheduleID);
    inline void Init(IMessageRouter *pIMessageRouter, DWORD dwScheduleID);
    inline BOOL    fIsEqual(CAQScheduleID *paqsched);
    inline BOOL    fSameMessageRouter(CAQScheduleID *paqsched);
    inline DWORD   dwGetScheduleID() {return m_dwScheduleID;};
    inline void    GetGUID(IN OUT GUID *pguid);
protected:
    GUID    m_guidRouter;
    DWORD   m_dwScheduleID;
};

//---[ CAQMessageType::CAQMessageType ]----------------------------------------
//
//
//  Description: 
//      Constructor for CAQMessageType
//  Parameters:
//      guidRouter  - GUID returned by IMessageRouter::GetTransportSinkID
//      dwMessageType - Message type returned by IMessageRouter::GetMessageType
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMessageType::CAQMessageType(GUID guidRouter, DWORD dwMessageType)
{
    m_guidRouter = guidRouter;
    m_dwMessageType = dwMessageType;
}

//---[ CAQMessageType::CAQMessageType ]----------------------------------------
//
//
//  Description: 
//      Contructor for CAQMessageType that clones another CAQMessageType
//  Parameters:
//      paqmt   CAQMessageType to clone
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMessageType::CAQMessageType(CAQMessageType *paqmt)
{
    m_guidRouter = paqmt->m_guidRouter;
    m_dwMessageType = paqmt->m_dwMessageType;
}

//---[ CAQMessageType::fIsEqual ]----------------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQMessageType's refer to the same router and
//      message type pair
//  Parameters:
//      paqmt   - Other CAQMessageType to compare against
//  Returns:
//      TRUE if the refer to the same message type and router
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQMessageType::fIsEqual(CAQMessageType *paqmt)
{
    return ((paqmt->m_dwMessageType == m_dwMessageType) &&
            (paqmt->m_guidRouter == m_guidRouter));
};

//---[ CAQMessageType::fSameMessageRouter ]------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQMessageType's refer to the same router ID
//  Parameters:
//      paqmt   - Other CAQMessageType to compare against
//  Returns:
//      TRUE if the refer to the same router ID
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQMessageType::fSameMessageRouter(CAQMessageType *paqmt)
{
    return(paqmt->m_guidRouter == m_guidRouter);
};

//---[ CAQMessageType::GetGUID ]------------------------------------------------
//
//
//  Description: 
//      Gets the GUID associated with this message type
//  Parameters:
//      pguid   GUID to copy value into
//  Returns:
//      -
//  History:
//      12/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMessageType::GetGUID(IN OUT GUID *pguid)
{
    _ASSERT(pguid);
    memcpy(pguid, &m_guidRouter, sizeof(GUID));
}

//---[ CAQScheduleID::CAQScheduleID ]------------------------------------------
//
//
//  Description: 
//      CAQScheduleID constructor & initialization function
//  Parameters:
//      pIMessageRouter  - Message Router for this link
//      dwScheduleID - ScheduleID returned by IMessageRouter::GetNextHop
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created 
//      6/9/98 - MikeSwa Modified to take pIMessageRouter
//
//-----------------------------------------------------------------------------
CAQScheduleID::CAQScheduleID(IMessageRouter *pIMessageRouter, DWORD dwScheduleID)
{
    Init(pIMessageRouter, dwScheduleID);
}

//---[ CAQScheduleID::CAQScheduleID ]-------------------------------------------
//
//
//  Description: 
//      Default constructor for CAQScheduleID... should be used with 
//  Parameters:
//
//  Returns:
//
//  History:
//      6/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQScheduleID::CAQScheduleID()
{
    ZeroMemory(&m_guidRouter, sizeof(GUID));
    m_dwScheduleID = 0xDEAFBEEF;
}

//---[ CAQScheduleID::CAQScheduleID ]------------------------------------------
//
//
//  Description: 
//      Yet another flavor of CAQScheduleID constructor
//  Parameters:
//      guidRouter      GUID of router for schedule ID
//      dwScheduleID    Schedule ID returned by router
//  Returns:
//      -
//  History:
//      9/22/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQScheduleID::CAQScheduleID(GUID guidRouter, DWORD dwScheduleID)
{
    m_guidRouter = guidRouter;
    m_dwScheduleID = dwScheduleID;
}

//---[ CAQScheduleID::Init ]---------------------------------------------------
//
//
//  Description: 
//      Initalization of CAQScheduleID object... used to allow allocation of 
//      object on stack before dwScheduleID is known
//  Parameters:
//      pIMessageRouter  - Message Router for this link
//      dwScheduleID - ScheduleID returned by IMessageRouter::GetNextHop
//  Returns:
//      -
//  History:
//      6/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQScheduleID::Init(IMessageRouter *pIMessageRouter, DWORD dwScheduleID)
{
    m_guidRouter = pIMessageRouter->GetTransportSinkID();
    m_dwScheduleID = dwScheduleID;
}

//---[ CAQScheduleID::fIsEqual ]----------------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQScheduleID's refer to the same router and
//      Schedule ID pair
//  Parameters:
//      paqsched   - Other CAQScheduleID to compare against
//  Returns:
//      TRUE if the refer to the same schedule ID and router
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQScheduleID::fIsEqual(CAQScheduleID *paqsched)
{
    return ((paqsched->m_dwScheduleID == m_dwScheduleID) &&
            (paqsched->m_guidRouter == m_guidRouter));
};

//---[ CAQScheduleID::fSameMessageRouter ]-------------------------------------
//
//
//  Description: 
//      Determines if 2 given CAQScheduleID's refer to the same router ID
//  Parameters:
//      paqsched   - Other CAQScheduleID to compare against
//  Returns:
//      TRUE if the refer to the same router ID
//  History:
//      5/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQScheduleID::fSameMessageRouter(CAQScheduleID *paqsched)
{
    return (paqsched->m_guidRouter == m_guidRouter);
};

//---[ CAQScheduleID::GetGUID ]------------------------------------------------
//
//
//  Description: 
//      Gets the GUID associated with this schedule ID
//  Parameters:
//      pguid   GUID to copy value into
//  Returns:
//      -
//  History:
//      9/25/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQScheduleID::GetGUID(IN OUT GUID *pguid)
{
    _ASSERT(pguid);
    memcpy(pguid, &m_guidRouter, sizeof(GUID));
}
#endif //__AQROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqrpcsvr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcsvr.cpp
//
//  Description:  Implementation of AQ RPC server
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqrpcsvr.h"
#include "aqadmrpc.h"
#include <inetcom.h>
#include <iiscnfg.h>

LIST_ENTRY          CAQRpcSvrInst::s_liInstancesHead;
CShareLockNH        CAQRpcSvrInst::s_slPrivateData;
RPC_BINDING_VECTOR *CAQRpcSvrInst::s_pRpcBindingVector = NULL;
BOOL                CAQRpcSvrInst::s_fEndpointsRegistered = FALSE;

//
// Quick and dirty string validation
//
static inline BOOL pValidateStringPtr(LPWSTR lpwszString, DWORD dwMaxLength)
{
    if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
        return(FALSE);
    while (dwMaxLength--)
        if (*lpwszString++ == 0)
            return(TRUE);
    return(FALSE);
}

//---[ HrInitializeAQRpc ]-----------------------------------------------------
//
//
//  Description: 
//      Initializes AQ RPC.  This should only be called once per service
//      startup (not VS).  Caller in responable for ensuring that this and
//      HrInitializeAQRpc are called in a thread safe manner.
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Error code from RPC
//  History:
//      6/5/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrInitializeAQRpc()
{
    TraceFunctEnterEx((LPARAM) NULL, "CAQRpcSvrInst::HrInitializeAQRpc");
    HRESULT     hr = S_OK;
    RPC_STATUS  status = RPC_S_OK;

    InitializeListHead(&s_liInstancesHead);
    s_pRpcBindingVector = NULL;
    s_fEndpointsRegistered = FALSE;

    //Listen on the appropriate protocols sequences
    status = RpcServerUseAllProtseqs(RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                      NULL);

    if (status != RPC_S_OK)
        goto Exit;

    //Advertise the appropriate interface
    status = RpcServerRegisterIfEx(IAQAdminRPC_v1_0_s_ifspec, NULL, NULL, 
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL);

    if (status != RPC_S_OK)
        goto Exit;

    //Get the dynamic endpoints
    status = RpcServerInqBindings(&s_pRpcBindingVector);
    if (status != RPC_S_OK)
        goto Exit;
    
    //Register the endpoints
    status = RpcEpRegister(IAQAdminRPC_v1_0_s_ifspec, s_pRpcBindingVector,
                           NULL, NULL);
    if (status != RPC_S_OK)
        goto Exit;

    s_fEndpointsRegistered = TRUE;

  Exit:
    if (status != RPC_S_OK)
        hr = HRESULT_FROM_WIN32(status);

    TraceFunctLeave();
    return hr;
}

//---[ HrDeinitializeAQRpc ]----------------------------------------------------
//
//
//  Description: 
//      Do global RPC cleanup
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Error code from RPC otherwise
//  History:
//      6/5/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrDeinitializeAQRpc()
{
    TraceFunctEnterEx((LPARAM) NULL, "CAQRpcSvrInst::HrDeinitializeAQRpc");
    HRESULT     hr = S_OK;
    RPC_STATUS  status = RPC_S_OK;

    if (s_fEndpointsRegistered) {
        status = RpcEpUnregister(IAQAdminRPC_v1_0_s_ifspec, s_pRpcBindingVector, NULL);
        if (status != RPC_S_OK) hr = HRESULT_FROM_WIN32(status);
    }
    
    if (s_pRpcBindingVector) {
        status = RpcBindingVectorFree(&s_pRpcBindingVector);
        if (status != RPC_S_OK) hr = HRESULT_FROM_WIN32(status);
    }

    status = RpcServerUnregisterIf(IAQAdminRPC_v1_0_s_ifspec, NULL, 0);

    if (status != RPC_S_OK) hr = HRESULT_FROM_WIN32(status);

    s_fEndpointsRegistered = FALSE;
    s_pRpcBindingVector = NULL;
    TraceFunctLeave();
    return hr;
}

//---[ HrInitializeAQServerInstanceRPC ]---------------------------------------
//
//
//  Description: 
//      Add instance to RPC interface
//  Parameters:
//      IN  paqinst             Instnace to add to interface
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      S_OK on success
//  History:
//      6/5/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrInitializeAQServerInstanceRPC(CAQSvrInst *paqinst, 
                                        DWORD dwVirtualServerID,
                                        ISMTPServer *pISMTPServer)
{
    TraceFunctEnterEx((LPARAM) paqinst, 
        "CAQRpcSvrInst::HrInitializeAQServerInstanceRPC");
    HRESULT hr = S_OK;
    CAQRpcSvrInst *paqrpc = NULL;

    paqrpc = CAQRpcSvrInst::paqrpcGetRpcSvrInstance(dwVirtualServerID);
    if (paqrpc)
    {
        _ASSERT(0 && "Instance already added to RPC interface");
        paqrpc->Release();
        paqrpc = NULL;
        goto Exit;
    }

    paqrpc = new CAQRpcSvrInst(paqinst, dwVirtualServerID, pISMTPServer);
    if (!paqrpc)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ HrDeinitializeAQServerInstanceRPC ]-------------------------------------
//
//
//  Description: 
//      Remove instance from RPC interface
//  Parameters:
//      IN  paqinst             Instnace to remove from interface
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      S_OK on success
//  History:
//      6/5/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAQRpcSvrInst::HrDeinitializeAQServerInstanceRPC(CAQSvrInst *paqinst, 
                                          DWORD dwVirtualServerID)
{
    TraceFunctEnterEx((LPARAM) paqinst, 
        "CAQRpcSvrInst::HrDeinitializeAQServerInstanceRPC");
    HRESULT hr = S_OK;
    CAQRpcSvrInst *paqrpc = NULL;

    paqrpc = CAQRpcSvrInst::paqrpcGetRpcSvrInstance(dwVirtualServerID);
    if (!paqrpc)
        goto Exit; //allow calls if HrInitializeAQServerInstanceRPC failed

    //Found it
    //$$TODO - verify the paqinst is correct
    
    paqrpc->SignalShutdown();

    //Remove from list of entries
    s_slPrivateData.ExclusiveLock();
    RemoveEntryList(&(paqrpc->m_liInstances));
    s_slPrivateData.ExclusiveUnlock();
    paqrpc->Release(); //release reference associated with list

  Exit:
    if (paqrpc)
        paqrpc->Release();



    TraceFunctLeave();
    return hr;
}


//---[ CAQRpcSvrInst::CAQRpcSvrInst ]------------------------------------------
//
//
//  Description: 
//      Constructor for CAQRpcSvrInst class
//  Parameters:
//      IN  paqinst             Instnace to remove from interface
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      -
//  History:
//      6/6/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQRpcSvrInst::CAQRpcSvrInst(CAQSvrInst *paqinst, DWORD dwVirtualServerID,
                             ISMTPServer *pISMTPServer)
{
    _ASSERT(paqinst);
    _ASSERT(pISMTPServer);

    m_paqinst = paqinst;
    m_dwVirtualServerID = dwVirtualServerID;
    m_pISMTPServer = pISMTPServer;
    m_dwSignature = CAQRpcSvrInst_Sig;

    if (m_paqinst)
        m_paqinst->AddRef();

    if (m_pISMTPServer)
        m_pISMTPServer->AddRef();

    //Add to list of virtual server instaces
    s_slPrivateData.ExclusiveLock();
    InsertHeadList(&s_liInstancesHead, &m_liInstances);
    s_slPrivateData.ExclusiveUnlock();
}

//---[ CAQRpcSvrInst::~CAQRpcSvrInst ]-----------------------------------------
//
//
//  Description: 
//      Desctructor for CAQRpcSvrInst
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/6/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQRpcSvrInst::~CAQRpcSvrInst()
{

    if (m_paqinst)
        m_paqinst->Release();

    if (m_pISMTPServer)
        m_pISMTPServer->Release();

    m_dwSignature = CAQRpcSvrInst_SigFree;

}


//---[ CAQRpcSvrInst::paqrpcGetRpcSvrInstance ]--------------------------------
//
//
//  Description: 
//      Gets the CAQRpcSvrInst for a given virtual server ID
//  Parameters:
//      IN  dwVirtualServerID   Virtual server ID of instance
//  Returns:
//      Pointer to appropriate CAQRpcSvrInst on success
//      NULL if not found
//  History:
//      6/6/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQRpcSvrInst *CAQRpcSvrInst::paqrpcGetRpcSvrInstance(DWORD dwVirtualServerID)
{
    LIST_ENTRY  *pli = NULL;
    CAQRpcSvrInst *paqrpc = NULL;

    s_slPrivateData.ShareLock();
    pli = s_liInstancesHead.Flink;

    while (pli && (pli != &s_liInstancesHead))
    {
        paqrpc = CONTAINING_RECORD(pli, CAQRpcSvrInst, m_liInstances);
        //$$TODO check signature
        if (paqrpc->m_dwVirtualServerID == dwVirtualServerID)
        {
            paqrpc->AddRef();
            break; //found it
        }

        paqrpc = NULL;
        pli = pli->Flink;
    }
    s_slPrivateData.ShareUnlock();

    return paqrpc;
}


//---[ CAQRpcSvrInst::fAccessCheck ]-------------------------------------------
//
//
//  Description: 
//      Performs acess check for RPC interfaces
//  Parameters:
//      IN      fWriteAccessRequired    TRUE if write access is required
//  Returns:
//      TRUE if access check is succeeds
//      FALSE if user does not have access
//  History:
//      6/7/99 - MikeSwa Created (from SMTP AQAdmin access code)
//
//-----------------------------------------------------------------------------
BOOL CAQRpcSvrInst::fAccessCheck(BOOL fWriteAccessRequired)
{
    TraceFunctEnterEx((LPARAM) this, "CAQRpcSvrInst::fAccessCheck");
    SECURITY_DESCRIPTOR    *pSecurityDescriptor = NULL;
    DWORD                   cbSecurityDescriptor = 0;
    HRESULT                 hr = S_OK;
    DWORD                   err = ERROR_SUCCESS;
    BOOL                    fAccessAllowed = FALSE;
    HANDLE                  hAccessToken = NULL;
    BYTE                    PrivSet[200];
    DWORD                   cbPrivSet = sizeof(PrivSet);
    ACCESS_MASK             maskAccessGranted;
    GENERIC_MAPPING         gmGenericMapping = {
                                MD_ACR_READ,
                                MD_ACR_WRITE,
                                MD_ACR_READ,
                                MD_ACR_READ | MD_ACR_WRITE
                            };

    if (!m_pISMTPServer)
        goto Exit;  //if we cannot check it... assume if fails

    hr = m_pISMTPServer->ReadMetabaseData(MD_ADMIN_ACL, NULL, 
                                         &cbSecurityDescriptor);
    if (SUCCEEDED(hr))
    {
        //We passed in NULL.. should have failed
        _ASSERT(0 && "Invalid response for ReadMetabaseData");
        goto Exit;
    }
    if ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr) ||
        !cbSecurityDescriptor)
    {
        //Can't get ACL... bail
        goto Exit;
    }

    pSecurityDescriptor = (SECURITY_DESCRIPTOR *) pvMalloc(cbSecurityDescriptor);
    if (!pSecurityDescriptor)
        goto Exit;

    hr = m_pISMTPServer->ReadMetabaseData(MD_ADMIN_ACL, (BYTE *) pSecurityDescriptor, 
                                         &cbSecurityDescriptor);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, 
            "Error calling ReadMetabaseData for AccessCheck - hr 0x%08X", hr);
        goto Exit;
    }

    // Verify that we got a proper SD.  if not then fail
    if (!IsValidSecurityDescriptor(pSecurityDescriptor)) 
    {
        ErrorTrace(0, "IsValidSecurityDescriptor failed with %lu", GetLastError());
        goto Exit;
    }

    err = RpcImpersonateClient(NULL);
    if (err != ERROR_SUCCESS) 
    {
        ErrorTrace((LPARAM) this, "RpcImpersonateClient failed with %lu", err);
        goto Exit;
    }

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hAccessToken))
    {
        ErrorTrace((LPARAM) this, 
            "OpenThreadToken Failed with %lu", GetLastError());
        goto Exit;
    }

    //Check access
    if (!AccessCheck(pSecurityDescriptor,
                     hAccessToken,
                     fWriteAccessRequired ? MD_ACR_WRITE : MD_ACR_READ,
                     &gmGenericMapping,
                     (PRIVILEGE_SET *)PrivSet,
                     &cbPrivSet,
                     &maskAccessGranted,
                     &fAccessAllowed))
    {
        fAccessAllowed = FALSE;
        ErrorTrace((LPARAM) this, 
            "AccessCheck Failed with %lu", GetLastError());
        goto Exit;
    }

    if (!fAccessAllowed)
        DebugTrace((LPARAM) this, "Access denied for Queue Admin RPC");

    //Do any additional read-only processing
    if (fWriteAccessRequired && fAccessAllowed && 
        !(MD_ACR_WRITE & maskAccessGranted))
    {
        DebugTrace((LPARAM) this, "Write Access denied for Queue Admin RPC");
        fAccessAllowed = FALSE;
    }

  Exit:
    if (pSecurityDescriptor)
        FreePv(pSecurityDescriptor);

    if (hAccessToken)
        CloseHandle(hAccessToken);

    TraceFunctLeave();
    return fAccessAllowed;
}

//---[ HrGetAQInstance ]-------------------------------------------------------
//
//
//  Description: 
//      This is used by all of the AQ RPC's to get a pointer to AQ based on an
//      instance name.
//
//      THE SHUTDOWN LOCK ON ppaqrpc IS HELD AFTER THIS CALL COMPLETES.
//      THE CALLER MUST CALL paqrpc->ShutdownUnlock() WHEN THEY HAVE
//      FINISHED THEIR QUEUE ADMIN OPERATION.
//  Parameters:
//      IN  wszInstance             A number containing the instance to lookup.  
//      IN  fWriteAccessRequired    TRUE if write access is required
//      OUT ppIAdvQueueAdmin        Pointer to AQ admin interface
//      OUT ppaqrpc                 Pointer to CAQRpcSvrInst
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) if user does not have access
//      HRESULT_FROM_WIN32(ERROR_NOT_FOUND) if virtual server is not found
//      HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) if server is shutting 
//          down.
//      E_POINTER if pointer arguments are NULL
//      E_INVALIDARG if wszInstance is a bad pointer
//  History:
//      6/11/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT HrGetAQInstance(IN  LPWSTR wszInstance, 
                                IN  BOOL fWriteAccessRequired,
                                OUT IAdvQueueAdmin **ppIAdvQueueAdmin,
                                OUT CAQRpcSvrInst **ppaqrpc) {
    TraceFunctEnter("GetAQInstance");
    
    CAQSvrInst     *paqinst = NULL;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    CAQRpcSvrInst  *paqrpc = NULL;
    BOOL            fHasAccess = FALSE;
    DWORD           dwInstance = 1;
    BOOL            fShutdownLock = FALSE;
    HRESULT         hr = S_OK;

    _ASSERT(ppIAdvQueueAdmin);
    _ASSERT(ppaqrpc);
    
    if (!wszInstance || !ppIAdvQueueAdmin || !ppaqrpc)
    {
        hr = E_POINTER;
        goto Exit;
    }

    *ppIAdvQueueAdmin = NULL;
    *ppaqrpc = NULL;

    if (!pValidateStringPtr(wszInstance, MAX_PATH)) 
    {
        ErrorTrace(NULL, "Invalid parameter: wszInstance\n");
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwInstance = _wtoi(wszInstance);
    DebugTrace((LPARAM) NULL, "instance is %S (%i)", wszInstance, dwInstance);

    paqrpc = CAQRpcSvrInst::paqrpcGetRpcSvrInstance(dwInstance);
    if (!paqrpc)
    {
        ErrorTrace((LPARAM) NULL, 
            "Error unable to find requested virtual server for QAPI %d", dwInstance);
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    //
    //  Check for proper access.
    //
    //  This should be done BEFORE the shutdown lock is grabbed because it
    //  may require hitting the metabase (which could cause a shutdown deadlock)
    if (!paqrpc->fAccessCheck(fWriteAccessRequired))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }

    // Ensure that shutdown does not happen in the middle of our operation
    if (!paqrpc->fTryShutdownLock())
    {
        hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
        goto Exit;
    }

    fShutdownLock = TRUE;
    paqinst = paqrpc->paqinstGetAQ();

    hr = paqinst->QueryInterface(IID_IAdvQueueAdmin, 
                                        (void **) &pIAdvQueueAdmin);
    if (FAILED(hr)) 
    {
        pIAdvQueueAdmin = NULL;
        goto Exit;
    }

  Exit:

    if (FAILED(hr))
    {
        //cleanup
        if (paqrpc)
        {
            if (fShutdownLock)
                paqrpc->ShutdownUnlock();
            paqrpc->Release();
        }

        if (pIAdvQueueAdmin)
            pIAdvQueueAdmin->Release();
        pIAdvQueueAdmin = NULL;
    }
    else //return OUT params
    {
        *ppIAdvQueueAdmin = pIAdvQueueAdmin;
        *ppaqrpc = paqrpc;
        _ASSERT(ppaqrpc);
        _ASSERT(pIAdvQueueAdmin);
    }
        
    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQApplyActionToLinks(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction)
{
    TraceFunctEnter("AQApplyActionToLinks");
    HRESULT hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    CAQRpcSvrInst  *paqrpc = NULL;
    BOOL    fNeedWriteAccess = TRUE;

    if (LA_INTERNAL == laAction) //just checking the state
        fNeedWriteAccess = FALSE;

    hr = HrGetAQInstance(wszInstance, fNeedWriteAccess, &pIAdvQueueAdmin, &paqrpc);
    if (FAILED(hr))
        return hr;

    hr = pIAdvQueueAdmin->ApplyActionToLinks(laAction);

    paqrpc->ShutdownUnlock();
    paqrpc->Release();
    pIAdvQueueAdmin->Release();
    
    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQApplyActionToMessages(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs)
{
    TraceFunctEnter("AQApplyActionToMessages");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlQueueLinkId, sizeof(QUEUELINK_ID))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pmfMessageFilter, sizeof(MESSAGE_FILTER))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pmfMessageFilter\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, TRUE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr))
    {
        hr = pIAdvQueueAdmin->ApplyActionToMessages(pqlQueueLinkId,
                                           pmfMessageFilter,
                                           maMessageAction,
                                           pcMsgs);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }
        
    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetQueueInfo(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo)
{
    TraceFunctEnter("AQGetQueueInfo");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlQueueId, sizeof(QUEUELINK_ID))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pqiQueueInfo, sizeof(QUEUE_INFO))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqiQueueInfo\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr)) 
    {
        hr = pIAdvQueueAdmin->GetQueueInfo(pqlQueueId,
                                  pqiQueueInfo);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    } 
            
    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetLinkInfo(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo,
    HRESULT         *phrLinkDiagnostic)
{
    TraceFunctEnter("AQGetLinkInfo");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    
    if (IsBadReadPtr((LPVOID)pqlLinkId, sizeof(QUEUELINK_ID))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqlLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pliLinkInfo, sizeof(LINK_INFO))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pliLinkInfo\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)phrLinkDiagnostic, sizeof(HRESULT))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pliLinkInfo\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr)) 
    {
        hr = pIAdvQueueAdmin->GetLinkInfo(pqlLinkId,
                                 pliLinkInfo, phrLinkDiagnostic);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    } 

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQSetLinkState(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la)
{
    TraceFunctEnter("AQSetLinkInfo");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    
    if (IsBadReadPtr((LPVOID)pqlLinkId, sizeof(QUEUELINK_ID))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqlLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, TRUE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr)) 
    {
        hr = pIAdvQueueAdmin->SetLinkState(pqlLinkId,
                                 la);
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    } 

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetLinkIDs(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**prgLinks)
{
    TraceFunctEnter("AQGetLinkIDs");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadWritePtr((LPVOID)pcLinks, sizeof(DWORD))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pcLinks\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)prgLinks, sizeof(QUEUELINK_ID *))) 
    {
        ErrorTrace(NULL, "Invalid parameter: prgLinks\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr)) 
    {
        QUEUELINK_ID *rgLinks = NULL;
        DWORD cLinks = 0;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        // loop on calls to GetLinkIDs until we have enough memory to
        // get all of the links.  for the first call we will always
        // have a NULL rgLinks and just be asking for the size.  we need
        // to loop in case more links show up between calls
        while (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) 
        {
            hr = pIAdvQueueAdmin->GetLinkIDs(&cLinks, rgLinks);
            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) 
            {
                if (rgLinks != NULL) MIDL_user_free(rgLinks);
                rgLinks = (QUEUELINK_ID *) 
                    MIDL_user_allocate(sizeof(QUEUELINK_ID) * cLinks);
                if (rgLinks == NULL) hr = E_OUTOFMEMORY;
            }
        }
        
        if (SUCCEEDED(hr)) 
        {
            *prgLinks = rgLinks;
            *pcLinks = cLinks;
        } 
        else 
        {
            *prgLinks = NULL;
            *pcLinks = 0;
            if (rgLinks) MIDL_user_free(rgLinks);
        }
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    } 
    
    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetQueueIDs(
    AQUEUE_HANDLE   wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**prgQueues)
{
    TraceFunctEnter("AQGetQueueIDs");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlLinkId, sizeof(QUEUELINK_ID))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqlLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pcQueues, sizeof(DWORD))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pcQueues\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)prgQueues, sizeof(QUEUELINK_ID *))) 
    {
        ErrorTrace(NULL, "Invalid parameter: prgQueues\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr)) 
    {
        QUEUELINK_ID *rgQueues = NULL;
        DWORD cQueues = 0;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        // loop on calls to GetLinkIDs until we have enough memory to
        // get all of the links.  for the first call we will always
        // have a NULL rgQueues and just be asking for the size.  we need
        // to loop in case more links show up between calls
        while (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) 
        {
            hr = pIAdvQueueAdmin->GetQueueIDs(pqlLinkId, &cQueues, rgQueues);
            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) 
            {
                if (rgQueues != NULL) MIDL_user_free(rgQueues);
                rgQueues = (QUEUELINK_ID *) 
                    MIDL_user_allocate(sizeof(QUEUELINK_ID) * cQueues);
                if (rgQueues == NULL) hr = E_OUTOFMEMORY;
            }
        }
        
        if (SUCCEEDED(hr)) 
        {
            *prgQueues = rgQueues;
            *pcQueues = cQueues;
        } 
        else 
        {
            *prgQueues = NULL;
            *pcQueues = 0;
            if (rgQueues) MIDL_user_free(rgQueues);
        }
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    }

    TraceFunctLeave();
    return hr;
}

NET_API_STATUS
NET_API_FUNCTION
AQGetMessageProperties(
    AQUEUE_HANDLE     	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**prgMsgs)
{
    TraceFunctEnter("AQGetMessageProperties");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;

    if (IsBadReadPtr((LPVOID)pqlQueueLinkId, sizeof(QUEUELINK_ID))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadReadPtr((LPVOID)pmfMessageEnumFilter, sizeof(MESSAGE_FILTER))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pmfMessageEnumFilter\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pcMsgs, sizeof(DWORD))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pcMsgs\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)prgMsgs, sizeof(MESSAGE_INFO *))) 
    {
        ErrorTrace(NULL, "Invalid parameter: prgMsgs\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    if (SUCCEEDED(hr)) 
    {
        MESSAGE_INFO *rgMsgs = NULL;
        DWORD cMsgs = 0;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        // loop on calls to GetLinkIDs until we have enough memory to
        // get all of the links.  for the first call we will always
        // have a NULL rgMsgs and just be asking for the size.  we need
        // to loop in case more links show up between calls
        while (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) 
        {
            hr = pIAdvQueueAdmin->GetMessageProperties(pqlQueueLinkId, 
                                              pmfMessageEnumFilter,
                                              &cMsgs, 
                                              rgMsgs);
            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) 
            {
                if (rgMsgs != NULL) MIDL_user_free(rgMsgs);
                rgMsgs = (MESSAGE_INFO *) 
                    MIDL_user_allocate(sizeof(MESSAGE_INFO) * cMsgs);
                if (rgMsgs == NULL) hr = E_OUTOFMEMORY;
            }
        }
        
        if (SUCCEEDED(hr)) 
        {
            *prgMsgs = rgMsgs;
            *pcMsgs = cMsgs;
        } 
        else 
        {
            *prgMsgs = NULL;
            *pcMsgs = 0;
            if (rgMsgs) MIDL_user_free(rgMsgs);
        }
        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();
    } 

    TraceFunctLeave();
    return hr;
}


//---[ AQQuerySupportedActions ]----------------------------------------------
//
//
//  Description: 
//      Client stub for querying supported actions
//  Parameters:
//      IN  wszServer               The server to connect to
//      IN  wszInstance             The virtual server instance to connect to
//      IN  pqlQueueLinkId          The queue/link we are interested in
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK on success
//      E_INVALIDARG on bad pointer args
//      Internal error code from HrGetAQInstance or 
//          IAdvQueue::QuerySupportedActions
//  History:
//      6/15/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
NET_API_STATUS
NET_API_FUNCTION
AQQuerySupportedActions(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
    DWORD           *pdwSupportedActions,
    DWORD           *pdwSupportedFilterFlags)
{
    TraceFunctEnter("AQQuerySupportedActions");
    CAQRpcSvrInst  *paqrpc = NULL;
    HRESULT         hr = S_OK;
    IAdvQueueAdmin *pIAdvQueueAdmin = NULL;
    BOOL            fHasWriteAccess = TRUE;

    if (IsBadReadPtr((LPVOID)pqlQueueLinkId, sizeof(QUEUELINK_ID))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pqlQueueLinkId\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pdwSupportedActions, sizeof(DWORD))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pdwSupportedActions\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    if (IsBadWritePtr((LPVOID)pdwSupportedFilterFlags, sizeof(DWORD))) 
    {
        ErrorTrace(NULL, "Invalid parameter: pdwSupportedFilterFlags\n");
        TraceFunctLeave();
        return(E_INVALIDARG);
    }

    hr = HrGetAQInstance(wszInstance, TRUE, &pIAdvQueueAdmin, &paqrpc);
    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr))
        return hr;

    //
    //  If we cannot get the instance, then try again only requesting
    //  read-only access
    //
    if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
    {
        fHasWriteAccess = FALSE;
        hr = HrGetAQInstance(wszInstance, FALSE, &pIAdvQueueAdmin, &paqrpc);
    }

    if (SUCCEEDED(hr)) 
    {
        hr = pIAdvQueueAdmin->QuerySupportedActions(pqlQueueLinkId,
                                           pdwSupportedActions,
                                           pdwSupportedFilterFlags);

        paqrpc->ShutdownUnlock();
        pIAdvQueueAdmin->Release();
        paqrpc->Release();

        //
        //  If the caller does not have write access, we need to 
        //  censor the supported actions
        //
        if (!fHasWriteAccess)
            *pdwSupportedActions = 0;
    } 

    TraceFunctLeave();
    return hr;
}

//---[ MIDL_user_allocate ]----------------------------------------------------
//
//
//  Description: 
//      MIDL memory allocation
//  Parameters:
//      size : Memory size requested.
//  Returns:
//      Pointer to the allocated memory block.
//  History:
//      6/5/99 - MikeSwa Created (taken from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
PVOID MIDL_user_allocate(IN size_t size)
{
    PVOID pvBlob = NULL;

    pvBlob = LocalAlloc( LPTR, size);

    return(pvBlob);

}

//---[ MIDL_user_free ]--------------------------------------------------------
//
//
//  Description: 
//    MIDL memory free .
//  Parameters:
//    IN    pvBlob    Pointer to a memory block that is freed.
//  Returns:
//      -
//  History:
//      6/5/99 - MikeSwa Created (from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
VOID MIDL_user_free(IN PVOID pvBlob)
{
    LocalFree(pvBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqsize.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqsize.h
//
//  Description:  Header file that defines globals that can be used as a 
//      internal version stamp by debugger exstensions
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQSIZE_H__
#define __AQSIZE_H__

_declspec(selectany) DWORD g_cbClasses = 
                                sizeof(CAQSvrInst) +
                                sizeof(CLinkMsgQueue) +
                                sizeof(CDestMsgQueue) +
                                sizeof(CDomainEntry) + 
                                sizeof(CMsgRef) +
                                sizeof(CSMTPConn);

_declspec(selectany) DWORD g_dwFlavorSignature = 
#ifdef DEBUG
' GBD';
#else
' LTR';
#endif

#endif //__AQSIZE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqrpcsvr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcsvr.h
//
//  Description:  Header file for AQueue server-side RPC implementations.
//      Contains per-instance initialization functions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQRPCSVR_H__
#define __AQRPCSVR_H__

#include <aqincs.h>
#include <rwnew.h>
#include <baseobj.h>
#include <shutdown.h>
#include <mailmsg.h>

class CAQSvrInst;


#define CAQRpcSvrInst_Sig       'cpRQ'
#define CAQRpcSvrInst_SigFree   'cpR!'

//---[ CAQRpcSvrInst ]---------------------------------------------------------
//
//
//  Description: 
//      Per-instance RPC class.  Handles RPC details and shutdown timing
//  Hungarian: 
//      aqrpc, paqrpc
//  
//-----------------------------------------------------------------------------
class CAQRpcSvrInst : 
    public CBaseObject,
    public CSyncShutdown
{
  private:
    static  CShareLockNH        s_slPrivateData;
    static  LIST_ENTRY          s_liInstancesHead;
    static  RPC_BINDING_VECTOR *s_pRpcBindingVector;
    static  BOOL                s_fEndpointsRegistered;
  protected:
    DWORD                   m_dwSignature;
    LIST_ENTRY              m_liInstances;
    CAQSvrInst             *m_paqinst;
    DWORD                   m_dwVirtualServerID;
    ISMTPServer            *m_pISMTPServer;
  public:
    CAQRpcSvrInst(CAQSvrInst *paqinst, DWORD dwVirtualServerID,
                  ISMTPServer *pISMTPServer);
    ~CAQRpcSvrInst();

    CAQSvrInst *paqinstGetAQ() {return m_paqinst;}; 
    static CAQRpcSvrInst *paqrpcGetRpcSvrInstance(DWORD dwVirtualServerID);

    BOOL   fAccessCheck(BOOL fReadOnly);


  public: //static functions
    static HRESULT HrInitializeAQRpc();
    static HRESULT HrDeinitializeAQRpc();

    static HRESULT HrInitializeAQServerInstanceRPC(CAQSvrInst *paqinst, 
                                            DWORD dwVirtualServerID,
                                            ISMTPServer *pISMTPServer);
    static HRESULT HrDeinitializeAQServerInstanceRPC(CAQSvrInst *paqinst, 
                                              DWORD dwVirtualServerID);

};

#endif //__AQRPCSVR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqstats.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqstats.cpp
//
//  Description:  Implementation of CAQStats/
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqstats.h"
#include "aqutil.h"

CAQStats::CAQStats()
{
    m_dwSignature = AQSTATS_SIG;
    Reset();
}

void CAQStats::Reset()
{
    m_dwHighestPri = 0;
    m_dwNotifyType = NotifyTypeUndefined;
    m_uliVolume.QuadPart = 0;
    m_pvContext = NULL;
    m_cMsgs = 0;
    m_cOtherDomainsMsgSpread = 0;
    ZeroMemory(m_rgcMsgPriorities, NUM_PRIORITIES*sizeof(DWORD));
};

//---[ CAQStats::UpdateStats ]------------------------------------------
//
//
//  Description: 
//      Used to provide "thread-safe" update.
//
//      NOTE: It is possible that m_dwHighestPri will not be entirely correct
//      if multple threads are changing the max priority at the same time, but
//      was deemed non-crucial.
//  Parameters:
//      paqstats        CAQStats to update data from
//      fAdd            TRUE if update reflects addition of msgs 
//                      FALSE if update reflects removal of msgs
//  Returns:
//      -
//  History:
//      11/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQStats::UpdateStats(CAQStats *paqstat, BOOL fAdd)
{
    DWORD dwPri = 0;
    DWORD cTmpMsgCount = 0;
    DWORD dwNewHighestPri = 0;

    dwInterlockedAddSubtractDWORD(&m_cMsgs, paqstat->m_cMsgs, fAdd);
    dwInterlockedAddSubtractDWORD(&m_cOtherDomainsMsgSpread, paqstat->m_cOtherDomainsMsgSpread, fAdd);
    
    //When adding new messages, finding the highest priority is easy
    dwPri = m_dwHighestPri;
    if (fAdd && (paqstat->m_dwHighestPri > dwPri))
    {
        InterlockedCompareExchange((PLONG) &m_dwHighestPri, 
                                   (LONG) paqstat->m_dwHighestPri, 
                                   (LONG) dwPri);
    }

    //Count down from highest prioriry
    for (DWORD iPri = 0; iPri < NUM_PRIORITIES; iPri++)
    {
        if (paqstat->m_rgcMsgPriorities[iPri])
        {
            cTmpMsgCount = dwInterlockedAddSubtractDWORD(&(m_rgcMsgPriorities[iPri]), 
                                paqstat->m_rgcMsgPriorities[iPri], fAdd);

            if (!fAdd && (cTmpMsgCount != paqstat->m_rgcMsgPriorities[iPri]))
            {
                if (dwNewHighestPri < iPri)
                    dwNewHighestPri = dwNewHighestPri;
            }
        }
        else if (!fAdd && m_rgcMsgPriorities[iPri] && (dwNewHighestPri < iPri))
        {
            dwNewHighestPri = dwNewHighestPri;
        }

    }

    //See if removing message has changed the highest priority
    if (!fAdd && (dwNewHighestPri < dwPri))
    {
        InterlockedCompareExchange((PLONG) &m_dwHighestPri, 
                                   (LONG) dwNewHighestPri, 
                                   (LONG) dwPri);
    }

    //Update total volume
    InterlockedAddSubtractULARGE(&m_uliVolume, &(paqstat->m_uliVolume), fAdd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqstats.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqstats.h
//
//  Description:  Header file for CAQStats class
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQSTATS_H__
#define __AQSTATS_H__

#include "cmt.h"
#include "aqutil.h"

enum NotifyType
{
    NotifyTypeUndefined     = 0x00000000,
    NotifyTypeDestMsgQueue  = 0x00000001, //notification sender is a dest queue
    NotifyTypeLinkMsgQueue  = 0x00000002, //notification sender is a link
    NotifyTypeReroute       = 0x00000004, //notification sender is a reroute
    NotifyTypeNewLink       = 0x10000000, //sender is a newly created link
};

class CDestMsgQueue;
class CLinkMsgQueue;

#define AQSTATS_SIG 'tatS'

//---[ CAQStats ]-------------------------------------------------------
//
//
//  Hungarian: aqstat, paqstat
//
//  
//-----------------------------------------------------------------------------
class CAQStats 
{
protected:
    DWORD               m_dwSignature;
public:
    DWORD               m_dwNotifyType; //Type of notification being sent
    DWORD               m_cMsgs;        //Total count of msgs
    DWORD               m_cOtherDomainsMsgSpread;  //Count of other domains message
                                                   //is queued for
    DWORD               m_rgcMsgPriorities[NUM_PRIORITIES]; //count per-priority
    ULARGE_INTEGER      m_uliVolume;
    DWORD               m_dwHighestPri;
    union //notification sender
    {
        PVOID          m_pvContext;
        CDestMsgQueue  *m_pdmq;
        CLinkMsgQueue  *m_plmq;
    };
    
    CAQStats();
    void Reset();

    //Used to provide thread-safe update
    void UpdateStats(CAQStats *paqstat, BOOL fAdd);
    
};


#endif //__AQSTATS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqutil.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqutil.h
//
//  Description:
//      General AQueue utility functions... like IMailMsg Usage Count
//      manipulation, queue mapping functions, and domain name table iterator
//      functions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/20/98 - MikeSwa Created
//      7/29/98 - MikeSwa Modified (added CalcMsgsPendingRetryIteratorFn)
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQUTIL_H__
#define __AQUTIL_H__
#include "aqincs.h"
#include "msgref.h"
#include "refstr.h"

//Functions to manipulate IMailMsg usage count
HRESULT HrIncrementIMailMsgUsageCount(IUnknown *pIUnknown);
HRESULT HrReleaseIMailMsgUsageCount(IUnknown *pIUnknown);
HRESULT HrDeleteIMailMsg(IUnknown *pIUnknown); //deletes and releases usage count

HRESULT HrWalkMailMsgQueueForShutdown(IN IMailMsgProperties *pIMailMsgProperties,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete);

BOOL    fMailMsgShutdownCompletion(PVOID pvContext, DWORD dwStatus);

HRESULT HrWalkMsgRefQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete);

BOOL    fMsgRefShutdownCompletion(PVOID pvContext, DWORD dwStatus);

//Domain Name Table iterator function used to count perf counters
VOID CalcDMTPerfCountersIteratorFn(PVOID pvContext, PVOID pvData,
                                         BOOL fWildcard, BOOL *pfContinue,
                                         BOOL *pfDelete);


//Functions to manipulate DWORD's bits in a thread safe manner
DWORD dwInterlockedSetBits(DWORD *pdwTarget, DWORD dwFlagMask);
DWORD dwInterlockedUnsetBits(DWORD *pdwTarget, DWORD dwFlagMask);

HRESULT HrWalkPreLocalQueueForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete);

//Used to reget the message type in various retry situations
HRESULT HrReGetMessageType(IN     IMailMsgProperties *pIMailMsgProperties,
                           IN     IMessageRouter *pIMessageRouter,
                           IN OUT DWORD *pdwMessageType);

#define UNIQUEUE_FILENAME_BUFFER_SIZE 35

//Creates a unique filename
void GetUniqueFileName(IN FILETIME *pft, IN LPSTR szFileBuffer, IN LPSTR szExtension);


//Ultility function to link all domains together (primarly to NDR an entire message)
HRESULT HrLinkAllDomains(IN IMailMsgProperties *pIMailMsgProperties);

//Parses a GUID from a string... returns TRUE on success
BOOL fAQParseGuidString(LPSTR szGuid, DWORD cbGuid, GUID *pguid);


inline DWORD dwInterlockedAddSubtractDWORD(DWORD *pdwValue,
                                        DWORD dwNew, BOOL fAdd)
{
    return InterlockedExchangeAdd((PLONG) pdwValue,
                            fAdd ? ((LONG) dwNew) : (-1 * ((LONG) dwNew)));
};

void InterlockedAddSubtractULARGE(ULARGE_INTEGER *puliValue,
                                  ULARGE_INTEGER *puliNew, BOOL fAdd);


//Functions to do simple spin lock manipulations
inline BOOL fTrySpinLock(DWORD *pdwLock, DWORD dwLockBit)
{
    return (!(dwLockBit & dwInterlockedSetBits(pdwLock, dwLockBit)));
}

inline void ReleaseSpinLock(DWORD *pdwLock, DWORD dwLockBit)
{
    _ASSERT(*pdwLock & dwLockBit);
    dwInterlockedUnsetBits(pdwLock, dwLockBit);
}

//
//  Same as above but checks content handle.  We force a rendering of the
//  message
//
HRESULT HrValidateMessageContent(IMailMsgProperties *pIMailMsgProperties);


#endif //__AQUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asncwrkq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: asncwrkq.cpp
//
//  Description:  Implementation of CAsyncWorkQueue.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      3/8/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "asncwrkq.h"
#include "asyncq.inl"


CPool CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool;
DWORD CAsyncWorkQueueItem::s_cCurrentHeapAllocations = 0;
DWORD CAsyncWorkQueueItem::s_cTotalHeapAllocations = 0;

//---[ CAsyncWorkQueueItem::new ]----------------------------------------------
//
//
//  Description: 
//      Wrapper for new that will use CPool or Exchmem to allocate... 
//      whichever is appropriate.
//  Parameters:
//      size        size of item to allocate (should always be 
//                  sizeof (CAsyncWorkQueueItem)
//  Returns:
//      Pointer to newly allocated CAsyncWorkQueueItem
//  History:
//      7/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void * CAsyncWorkQueueItem::operator new(size_t size)
{
    CAsyncWorkQueueItemAllocatorBlock *pcpaqwi = NULL;

    _ASSERT(sizeof(CAsyncWorkQueueItem) == size);

    pcpaqwi = (CAsyncWorkQueueItemAllocatorBlock *) s_CAsyncWorkQueueItemPool.Alloc(); 
    if (pcpaqwi)
    {
        pcpaqwi->m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_ALLOC_CPOOL_SIG;
    }
    else
    {
        //Fallback on Exchmem
        pcpaqwi = (CAsyncWorkQueueItemAllocatorBlock *) 
                            pvMalloc(sizeof(CAsyncWorkQueueItemAllocatorBlock));
        if (pcpaqwi)
        {
            pcpaqwi->m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_ALLOC_HEAP_SIG;
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &s_cCurrentHeapAllocations));
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &s_cTotalHeapAllocations));
        }
    }

    if (pcpaqwi)
        return ((void *) &(pcpaqwi->m_pawqi));
    else
        return NULL;
}

//---[ CAsyncWorkQueueItem::delete ]-------------------------------------------
//
//
//  Description: 
//      Delete operator that will handle deleting via CPool or exchmem
//  Parameters:
//      pv      Object to delete
//      size    Size of object
//  Returns:
//      -
//  History:
//      7/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAsyncWorkQueueItem::operator delete(void *pv, size_t size)
{
    _ASSERT(sizeof(CAsyncWorkQueueItem) == size);
    _ASSERT(pv);
    CAsyncWorkQueueItemAllocatorBlock *pcpaqwi = CONTAINING_RECORD(pv, 
                                    CAsyncWorkQueueItemAllocatorBlock, m_pawqi);
    DWORD   dwOldSignature = pcpaqwi->m_dwSignature;

    _ASSERT(ASYNC_WORK_QUEUE_ENTRY_ALLOC_INVALID_SIG != dwOldSignature);

    //Reset signature before we free it, in case memory allocators
    //do not overwrite it (we want our asserts to fire at the time 
    //of the double-free).
    pcpaqwi->m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_ALLOC_INVALID_SIG;
    switch(dwOldSignature)
    {
      case ASYNC_WORK_QUEUE_ENTRY_ALLOC_CPOOL_SIG:
        s_CAsyncWorkQueueItemPool.Free(pcpaqwi);
        break;
      case ASYNC_WORK_QUEUE_ENTRY_ALLOC_HEAP_SIG:
        DEBUG_DO_IT(InterlockedDecrement((PLONG) &s_cCurrentHeapAllocations));
        FreePv(pcpaqwi);
        break;
      default:
        _ASSERT(0 && "Invalid signature when freeing CAsyncWorkQueueItem");
    }
}

//---[ CAsyncWorkQueueItem::CAsyncWorkQueueItem ]------------------------------
//
//
//  Description: 
//      Default constructor for CAsyncWorkQueueItem
//  Parameters:
//      pvData          Data to pass to completion function
//      pfnCompletion   Completion function
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueueItem::CAsyncWorkQueueItem(PVOID pvData,
                                         PASYNC_WORK_QUEUE_FN pfnCompletion)
{
    _ASSERT(pfnCompletion);

    m_dwSignature   = ASYNC_WORK_QUEUE_ENTRY;
    m_pvData        = pvData;
    m_pfnCompletion = pfnCompletion;
}

//---[ CAsyncWorkQueueItem::~CAsyncWorkQueueItem ]-----------------------------
//
//
//  Description: 
//      Default destructor for CAsyncWorkQueueItem
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueueItem::~CAsyncWorkQueueItem()
{
    m_dwSignature = ASYNC_WORK_QUEUE_ENTRY_FREE;
}

//---[ CAsyncWorkQueue::CAsyncWorkQueue ]--------------------------------------
//
//
//  Description: 
//      Default constructor for CAsyncWorkQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueue::CAsyncWorkQueue()
{
    m_dwSignature = ASYNC_WORK_QUEUE_SIG;
    m_cWorkQueueItems = 0;
    m_dwStateFlags = ASYNC_WORK_QUEUE_NORMAL;
}

//---[ CAsyncWorkQueue::~CAsyncWorkQueue ]-------------------------------------
//
//
//  Description: 
//      Destructor for CAsyncWorkQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncWorkQueue::~CAsyncWorkQueue()
{
    m_dwSignature = ASYNC_WORK_QUEUE_SIG_FREE;
}

//---[ CAsyncWorkQueue::HrInitialize ]-----------------------------------------
//
//
//  Description: 
//      Initialization routing for CAsyncWorkQueue base.  Initializes the 
//      CAsyncQueue
//  Parameters:
//      cItemsPerThread     The number of items to process per async thread
//  Returns:
//      S_OK on success
//      Failure code from CAsyncQueue::HrInitialize()
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrInitialize(DWORD cItemsPerThread)
{
    HRESULT hr = S_OK;
    hr = m_asyncq.HrInitialize(0, //there can be *no* sync threads
                               cItemsPerThread, 
                               1,//init requires this value to be at least 1
                               this,
                               CAsyncWorkQueue::fQueueCompletion, 
                               CAsyncWorkQueue::fQueueFailure,
                               NULL);

    return hr;
}

//---[ CAsyncWorkQueue::HrDeinitialize ]---------------------------------------
//
//
//  Description:   
//      Signals shutdown for queue code
//  Parameters:
//      paqinst         Pointer to AQ server instance object
//  Returns:
//      S_OK on success
//  History:
//      3/8/99 - MikeSwa Created 
//      7/7/99 - MikeSwa Allow async threads to help process shutdown
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrDeinitialize(CAQSvrInst *paqinst)
{
    const   DWORD   MAX_ITERATIONS_NO_PROGRESS = 1000; //iterations before assert
    HRESULT hr = S_OK;
    DWORD   cLastCount = cGetWorkQueueItems();
    DWORD   cIterationsNoProgress = 0;
    _ASSERT(paqinst);

    //Start processing all items in "shutdown" mode
    m_dwStateFlags = ASYNC_WORK_QUEUE_SHUTDOWN;

    //
    //  Make sure we have threads actively processing this queue before
    //  we settle down and wait for them to stop.
    //
    _ASSERT(!cGetWorkQueueItems() || m_asyncq.dwGetTotalThreads());
    m_asyncq.StartRetry();

    //Let the worker threads have some fun before we stop and do the single
    //theaded initialization
    while (cLastCount && (cIterationsNoProgress < MAX_ITERATIONS_NO_PROGRESS))
    {
        if (cLastCount <= cGetWorkQueueItems())
            cIterationsNoProgress++;
        
        //I'd like to see this case
        _ASSERT(cIterationsNoProgress < MAX_ITERATIONS_NO_PROGRESS); 

        cLastCount = cGetWorkQueueItems();
        paqinst->ServerStopHintFunction();

        //Since it may take longer than our stop hint to process a 
        //single item in the queue, we need to sleep instead of 
        //attempting to process an item (Bug #X5:118258).
        Sleep(10000);
    }
    hr = m_asyncq.HrDeinitialize(CAsyncWorkQueue::HrShutdownWalkFn, 
                                           paqinst);
    return hr;
}

//---[ CAsyncWorkQueue::HrQueueWorkItem ]--------------------------------------
//
//
//  Description: 
//      Queues items to async work queue
//  Parameters:
//      pvData          Data item to pass to completion function
//      pfCompletion    Completion function
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if queue item could not be allocated
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrQueueWorkItem(PVOID pvData, 
                                         PASYNC_WORK_QUEUE_FN pfnCompletion)
{
    HRESULT hr = S_OK;
    CAsyncWorkQueueItem *pawqi = NULL;

    _ASSERT(pvData);
    _ASSERT(pfnCompletion);

    if (!pfnCompletion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Create queue item, initialize it, and queue it
    pawqi = new CAsyncWorkQueueItem(pvData, pfnCompletion);
    if (!pawqi)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = m_asyncq.HrQueueRequest(pawqi, FALSE);
    if (FAILED(hr))
        goto Exit;

    InterlockedIncrement((PLONG) &m_cWorkQueueItems);

  Exit:
    if (FAILED(hr) && pfnCompletion)
    {
        //call completion function
        pfnCompletion(pvData,
                      ASYNC_WORK_QUEUE_FAILURE | 
                      ASYNC_WORK_QUEUE_ENQUEUE_THREAD);
    }

    if (pawqi)
        pawqi->Release();

    return hr;
}

//---[ CAsyncWorkQueue::fQueueCompletion ]-------------------------------------
//
//
//  Description: 
//      Completion function called by CAsyncQueue
//  Parameters:
//      pawqi       CAsyncWorkQueueItem to process
//      pvContext   "this" pointer
//  Returns:
//      TRUE if item was process
//      FALSE otherwise
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAsyncWorkQueue::fQueueCompletion(CAsyncWorkQueueItem *pawqi,
                                       PVOID pvContext)
{
    BOOL    fRet = TRUE;
    CAsyncWorkQueue *pawq = (CAsyncWorkQueue *) pvContext;

    _ASSERT(pawqi);
    _ASSERT(pawq);
    _ASSERT(ASYNC_WORK_QUEUE_ENTRY == pawqi->m_dwSignature);
    _ASSERT(ASYNC_WORK_QUEUE_SIG == pawq->m_dwSignature);

    fRet = pawqi->m_pfnCompletion(pawqi->m_pvData, 
                                  pawq->m_dwStateFlags);

    if (fRet)
        InterlockedDecrement((PLONG) 
                    &(((CAsyncWorkQueue *)pawq)->m_cWorkQueueItems));

    return fRet;
}

//---[ CAsyncWorkQueue::fQueueFailure ]----------------------------------------
//
//
//  Description:    
//      Function to handle internal failures in CAsyncQueue
//  Parameters:
//      pawq        "this" pointer
//      pawqi       CAsyncWorkQueueItem to process
//  Returns:
//      TRUE always
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAsyncWorkQueue::fQueueFailure(CAsyncWorkQueueItem *pawqi,
                                    PVOID pawq)
                                    
{
    _ASSERT(pawqi);
    _ASSERT(pawq);
    _ASSERT(ASYNC_WORK_QUEUE_ENTRY == pawqi->m_dwSignature);
    _ASSERT(ASYNC_WORK_QUEUE_SIG == ((CAsyncWorkQueue *)pawq)->m_dwSignature);

    pawqi->m_pfnCompletion(pawqi->m_pvData, ASYNC_WORK_QUEUE_FAILURE);

    InterlockedDecrement((PLONG) &(((CAsyncWorkQueue *)pawq)->m_cWorkQueueItems));

    return TRUE;
}

//---[ CAsyncWorkQueue::HrShutdownWalkFn ]-------------------------------------
//
//
//  Description: 
//      Function to walk an CAsyncWorkQueue queue at shutdown and clear out 
//      all of the pending work items
//  Parameters:
//      IN  CAsyncWorkQueueItem ptr to data on queue
//      IN  PVOID pvContext     AQ server intstance
//      OUT BOOL *pfContinue,   TRUE if we should continue
//      OUT BOOL *pfDelete);    TRUE if item should be deleted
//  Returns:
//      S_OK always
//  History:
//      3/8/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncWorkQueue::HrShutdownWalkFn(
                                     CAsyncWorkQueueItem *pawqi, 
                                     PVOID pvContext,
                                     BOOL *pfContinue, 
                                     BOOL *pfDelete)
{
    CAQSvrInst *paqinst = (CAQSvrInst *) pvContext;

    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(pawqi);
    _ASSERT(ASYNC_WORK_QUEUE_ENTRY == pawqi->m_dwSignature);


    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    paqinst->ServerStopHintFunction();
    pawqi->m_pfnCompletion(pawqi->m_pvData, ASYNC_WORK_QUEUE_SHUTDOWN);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqutil.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqutil.cpp
//
//  Description:
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/20/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqutil.h"

//---[ HrIncrementIMailMsgUsageCount ]-------------------------------------------
//
//
//  Description:
//      Calls IMailMsgQueueMgmt::AddUsage.  Handles calling QueryInterface
//      for the right interface
//  Parameters:
//      pIUnknown   - ptr to IUknown for MailMsg
//  Returns:
//      S_OK on success
//  History:
//      7/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrIncrementIMailMsgUsageCount(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) pIUnknown, "HrIncrementIMailMsgUsageCount");
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIUnknown);

    hr = pIUnknown->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->AddUsage();
    if (FAILED(hr))
        goto Exit;

  Exit:
    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    TraceFunctLeave();
    return hr;
}

//---[ HrReleaseIMailMsgUsageCount ]-------------------------------------------
//
//
//  Description:
//      Calls IMailMsgQueueMgmt::ReleaseUsage.  Handles calling QueryInterface
//      for the right interface
//  Parameters:
//      pIUnknown   - ptr to IUknown for MailMsg
//  Returns:
//      S_OK on success
//  History:
//      7/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrReleaseIMailMsgUsageCount(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) pIUnknown, "HrReleaseIMailMsgUsageCount");
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIUnknown);

    hr = pIUnknown->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->ReleaseUsage();
    if (FAILED(hr))
        goto Exit;

  Exit:
    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    TraceFunctLeave();
    return hr;
}

//---[ HrDeleteIMailMsg ]------------------------------------------------------
//
//
//  Description:
//      Deletes a Msg and releases its usage count
//  Parameters:
//      pIUnknown   Ptr to mailmsg
//  Returns:
//      S_OK on success
//  History:
//      7/21/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrDeleteIMailMsg(IUnknown *pIUnknown)
{
    TraceFunctEnterEx((LPARAM) pIUnknown, "HrDeleteIMailMsg");
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIUnknown);

    hr = pIUnknown->QueryInterface(IID_IMailMsgQueueMgmt, (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->Delete(NULL);
    if (FAILED(hr))
        goto Exit;

  Exit:
    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    TraceFunctLeave();
    return hr;
}

//---[ HrWalkMailMsgQueueForShutdown ]------------------------------------------
//
//
//  Description:
//      Function to walk an IMailMsg queue at shutdown and clear out all of the
//      IMailMsgs
//  Parameters:
//      IN  pIMailMsgProperties //ptr to data on queue
//      IN  PVOID pvContext   //list of queues to prepare for DSN
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK
//  History:
//      7/20/98 - MikeSwa Created
//      7/7/99 - Added async shutdown
//-----------------------------------------------------------------------------
HRESULT HrWalkMailMsgQueueForShutdown(IN IMailMsgProperties *pIMailMsgProperties,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrWalkMailMsgQueueForShutdown");
    Assert(pfContinue);
    Assert(pfDelete);
    HRESULT hrTmp = S_OK;
    CAQSvrInst *paqinst = (CAQSvrInst *) pvContext;

    _ASSERT(pIMailMsgProperties);
    _ASSERT(paqinst);


    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    paqinst->ServerStopHintFunction();

    //Add to queue so async thread will have final release and the associated I/O
    pIMailMsgProperties->AddRef();
    paqinst->HrQueueWorkItem(pIMailMsgProperties, fMailMsgShutdownCompletion);

    TraceFunctLeave();
    return S_OK;
}


//---[ fMailMsgShutdownCompletion ]---------------------------------------------
//
//
//  Description:
//      CAsyncWorkQueue completion function to allow multi-threaded shutdown
//      of a MailMsgQueue
//  Parameters:
//      IN  pvContext   - A mailmsg to release
//      IN  dwStatus    - The status passed in by the async work queue
//  Returns:
//      TRUE always
//  History:
//      7/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL    fMailMsgShutdownCompletion(PVOID pvContext, DWORD dwStatus)
{
    IMailMsgProperties *pIMailMsgProperties = (IMailMsgProperties *) pvContext;
    HRESULT hr = S_OK;
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    _ASSERT(pIMailMsgProperties);

    if (!pIMailMsgProperties)
        goto Exit;

    //Bounce the usage count to force this thread to do any necessary commits
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt,
                                            (PVOID *) &pIMailMsgQueueMgmt);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgQueueMgmt FAILED");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->ReleaseUsage();
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgQueueMgmt->AddUsage();
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (pIMailMsgProperties)
        pIMailMsgProperties->Release();

    if (pIMailMsgQueueMgmt)
        pIMailMsgQueueMgmt->Release();

    return TRUE;
}

//---[ HrWalkMsgRefQueueForShutdown ]--------------------------------
//
//
//  Description:
//      Function to walk a queue containing msgrefs at shutdown and
//      clear out all of the IMailMsgs
//  Parameters:
//      IN  CMsgRef pmsgref,  //ptr to data on queue
//      IN  PVOID pvContext   //list of queues to prepare for DSN
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK - *always*
//  History:
//      7/20/98 - MikeSwa Created
//      7/7/99 - MikeSwa Added async shutdown
//-----------------------------------------------------------------------------
HRESULT HrWalkMsgRefQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue,
                                     OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "HrWalkMsgRefQueueForShutdown");
    Assert(pfContinue);
    Assert(pfDelete);
    CAQSvrInst *paqinst = (CAQSvrInst *) pvContext;
    _ASSERT(pmsgref);
    _ASSERT(paqinst);

    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    if (paqinst)
        paqinst->ServerStopHintFunction();

    //Add to queue so async thread will have final release and the associated I/O
    pmsgref->AddRef();
    paqinst->HrQueueWorkItem(pmsgref, fMsgRefShutdownCompletion);

    TraceFunctLeave();
    return S_OK;
}

//---[ fMsgRefShutdownCompletion ]---------------------------------------------
//
//
//  Description:
//      CAsyncWorkQueue completion function to allow multi-threaded shutdown
//      of a MailMsgQueue
//  Parameters:
//      IN  pvContext   - A mailmsg to release
//      IN  dwStatus    - The status passed in by the async work queue
//  Returns:
//      TRUE always
//  History:
//      7/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL    fMsgRefShutdownCompletion(PVOID pvContext, DWORD dwStatus)
{
    CMsgRef *pmsgref = (CMsgRef *) pvContext;
    _ASSERT(pmsgref);

    if (!pmsgref)
        return TRUE;

    //Call prepare to shutdown to force async threads to be the ones
    //doing that actual IO
    pmsgref->PrepareForShutdown();
    pmsgref->Release();
    return TRUE;
}

//---[ CalcDMTPerfCountersIteratorFn ]-----------------------------------------
//
//
//  Description:
//      Iterator function used to walk the DMT and generate the perf counters
//      we are interested in.
//  Parameters:
//          IN  pvContext   - pointer to context (current total of pending msgs)
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      7/29/98 - MikeSwa Created
//      7/31/98 - MikeSwa Modified (Added link state counters)
//      9/22/98 - MikeSwa Changed from domain flags to link flags
//
//  Note:
//      Currently the status is stored on the domain entry (and not the link).
//      At some point we will have to differentiate this, and add flags to
//      the link.  In this funciton the cLinkCount variable is a temporary
//      workaround.
//-----------------------------------------------------------------------------
VOID CalcDMTPerfCountersIteratorFn(PVOID pvContext, PVOID pvData,
                                    BOOL fWildcard, BOOL *pfContinue,
                                    BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pvData, "CalcMsgsPendingRetryIteratorFn");
    CDomainEntry   *pdentry = (CDomainEntry *) pvData;
    AQPerfCounters *pAQPerfCounters = (AQPerfCounters *) pvContext;
    CLinkMsgQueue  *plmq = NULL;
    CDomainEntryLinkIterator delit;
    DWORD           cMsgsOnCurrentLink = 0;
    DWORD           dwLinkStateFlags = 0;
    HRESULT         hr = S_OK;
    BOOL            fLinkEnabled = TRUE;

    _ASSERT(pvContext);
    _ASSERT(pvData);
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(sizeof(AQPerfCounters) == pAQPerfCounters->cbVersion);


    //Always continue, and never delete
    *pfContinue = TRUE;
    *pfDelete = FALSE;

    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
        goto Exit;

    while (plmq = delit.plmqGetNextLinkMsgQueue(plmq))
    {
        dwLinkStateFlags = plmq->dwGetLinkState();
        fLinkEnabled = TRUE;

        if (!(LINK_STATE_RETRY_ENABLED & dwLinkStateFlags))
        {
            //Link is pending retry
            fLinkEnabled = FALSE;
            cMsgsOnCurrentLink = plmq->cGetTotalMsgCount();
            if (FAILED(hr))
                ErrorTrace((LPARAM) plmq, "ERROR: Unable to get msg count - hr 0x%08X", hr);
            else //Add count of current link to current total
                pAQPerfCounters->cCurrentMsgsPendingRemoteRetry += cMsgsOnCurrentLink;
        }


        if (!(LINK_STATE_SCHED_ENABLED & dwLinkStateFlags))
        {
            //Link is pending a scheduled connection
            fLinkEnabled = FALSE;
            pAQPerfCounters->cCurrentRemoteNextHopLinksPendingScheduling++;
        }

        if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & dwLinkStateFlags)
        {
            //Link is a TURN/ETRN link
            if (!((LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_PRIV_TURN_ENABLED)
                  & dwLinkStateFlags))
                fLinkEnabled = FALSE; //link is not currently being serviced

            pAQPerfCounters->cCurrentRemoteNextHopLinksPendingTURNETRN++;
        }

        if (LINK_STATE_ADMIN_HALT & dwLinkStateFlags)
        {
            //Link is currently frozen by admin
            fLinkEnabled = FALSE;
            pAQPerfCounters->cCurrentRemoteNextHopLinksFrozenByAdmin++;
        }

        if (fLinkEnabled)
        {
            //There are no flags set that indicate this link is not enabled
            pAQPerfCounters->cCurrentRemoteNextHopLinksEnabled++;
        }

    }

  Exit:
    if (plmq)
        plmq->Release();

    TraceFunctLeave();
}


//---[ dwInterlockedSetBits ]--------------------------------------------------
//
//
//  Description:
//      Set bits in a DWORD in a thread sate manner
//  Parameters:
//      IN  pdwTarget   Ptr to DWORD to modify
//      IN  dwFlagMask  bits to set
//  Returns:
//      Original value
//  History:
//      8/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD dwInterlockedSetBits(DWORD *pdwTarget, DWORD dwFlagMask)
{
    DWORD dwChk;
    DWORD dwTmp;

    _ASSERT(pdwTarget);
    do
    {
        dwChk = *pdwTarget;
        dwTmp = dwChk | dwFlagMask;
        if (dwChk == dwTmp) //no work to be done
            break;
    } while (InterlockedCompareExchange((PLONG) pdwTarget,
                                        (LONG) dwTmp,
                                        (LONG) dwChk) != (LONG) dwChk);

    return dwChk;
}

//---[ dwInterlockedUnsetBits ]------------------------------------------------
//
//
//  Description:
//      Unset bits in a DWORD in a thread sate manner
//  Parameters:
//      IN  pdwTarget   Ptr to DWORD to modify
//      IN  dwFlagMask  bits to unset
//  Returns:
//      Original value
//  History:
//      8/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD dwInterlockedUnsetBits(DWORD *pdwTarget, DWORD dwFlagMask)
{
    DWORD dwChk;
    DWORD dwTmp;

    _ASSERT(pdwTarget);
    do
    {
        dwChk = *pdwTarget;
        dwTmp = dwChk & ~dwFlagMask;
        if (dwChk == dwTmp) //no work to be done
            break;
    } while (InterlockedCompareExchange((PLONG) pdwTarget,
                                        (LONG) dwTmp,
                                        (LONG) dwChk) != (LONG) dwChk);

    return dwChk;
}

//---[ HrWalkPreLocalQueueForDSN ]---------------------------------------------
//
//
//  Description:
//      Function to walk the pre-local delivery queue for DSN generation
//  Parameters:
//      IN  CMsgRef pmsgref     ptr to data on queue
//      IN  PVOID pvContext     ptr to CAQSvrInst
//      OUT BOOL *pfContinue    TRUE if we should continue
//      OUT BOOL *pfDelete      TRUE if item should be deleted
//  Returns:
//      S_OK on success
//  History:
//      8/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrWalkPreLocalQueueForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "HrWalkPreLocalQueueForDSN");
    HRESULT hr = S_OK;
    DWORD   dwDSNFlags = 0;
    CAQSvrInst *paqinst = (CAQSvrInst *)pvContext;

    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(paqinst);

    *pfContinue = TRUE; //always keep walking queue
    *pfDelete = FALSE;  //keep message in queue unless we NDR it

    if (paqinst && paqinst->fShutdownSignaled())
    {
        //If we got a shutdown hint...we should bail
        *pfContinue = FALSE;
        goto Exit;
    }

    hr = pmsgref->HrSendDelayOrNDR(CMsgRef::MSGREF_DSN_LOCAL_QUEUE |
                                   CMsgRef::MSGREF_DSN_SEND_DELAY,
                                   NULL, AQUEUE_E_MSG_EXPIRED, &dwDSNFlags);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pmsgref, "ERROR: HrSendDelayOrNDR failed - hr 0x%08X", hr);
        goto Exit;
    }

    //We need to remove this message from the queue
    if ((CMsgRef::MSGREF_DSN_SENT_NDR | CMsgRef::MSGREF_HANDLED) & dwDSNFlags)
    {
        *pfDelete = TRUE;

        //Update relevant counters
        paqinst->DecPendingLocal();

    }

  Exit:
    TraceFunctLeave();
    return hr;
}


//---[ HrReGetMessageType ]-----------------------------------------------------
//
//
//  Description:
//      Regets the message type after a retry failure
//  Parameters:
//      IN     pIMailMsgProperties      Message we are interested in
//      IN     pIMessageRouter          Router for that message
//      IN OUT pdwMessageType           Old/New message type for the message
//  Returns:
//      S_OK on success
//      Passes through errors from ReleaseMessageType & GetMessageType
//  History:
//      9/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrReGetMessageType(IN     IMailMsgProperties *pIMailMsgProperties,
                           IN     IMessageRouter *pIMessageRouter,
                           IN OUT DWORD *pdwMessageType)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrReGetMessageType");
    HRESULT hr = S_OK;

    //$$REVIEW - we might not have to get a new message type here... we
    //might only need it on a specific error code returned by HrInitialize.
    //Get New Messagetype... in case that changed
    hr = pIMessageRouter->ReleaseMessageType(*pdwMessageType, 1);
    if (FAILED(hr))
    {
        _ASSERT(SUCCEEDED(hr) && "ReleaseMessageType failed... may leak message types");
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "ERROR: ReleaseMessageType failed! - hr 0x%08X", hr);
        hr = S_OK; //we are about to retry anyway
    }

    hr = pIMessageRouter->GetMessageType(pIMailMsgProperties, pdwMessageType);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "ERROR: Unable to re-get message type - HR 0x%08X", hr);
        goto Exit; //we cannot recover from this
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//Used to guarantee uniqueue files names
DWORD g_cUniqueueFileNames = 0;

//---[ GetUniqueFileName ]-----------------------------------------------------
//
//
//  Description:
//      Creates a uniqueue file name
//  Parameters:
//      pft             Ptr to current filetime
//      szFileBuffer    Buffer to put string into... should be
//                      at least UNIQUEUE_FILENAME_BUFFER_SIZE
//      szExtension     Extension for file name... if longer than three chars,
//                      you will need to increase the size of szFileBuffer
//                      accordingly.
//  Returns:
//      -
//  History:
//      10/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void GetUniqueFileName(IN FILETIME *pft, IN LPSTR szFileBuffer,
                       IN LPSTR szExtension)
{
     DWORD cbFileNameSize = 0;
     DWORD cUnique = InterlockedIncrement((PLONG) &g_cUniqueueFileNames);
     SYSTEMTIME systime;

     _ASSERT(szFileBuffer);
     _ASSERT(szExtension);

     FileTimeToSystemTime(pft, &systime);

     cbFileNameSize = wsprintf(
            szFileBuffer,
            "%05.5x%02.2d%02.2d%02.2d%02.2d%02.2d%04.4d%08X.%s",
            systime.wMilliseconds,
            systime.wSecond, systime.wMinute, systime.wHour,
            systime.wDay, systime.wMonth, systime.wYear,
            cUnique, szExtension);

     //Assert that are constant is big enough
     //By default... allow room for ".eml" extension
     _ASSERT((cbFileNameSize + 4 - lstrlen(szExtension)) < UNIQUEUE_FILENAME_BUFFER_SIZE);
}



//---[ HrLinkAllDomains ]-------------------------------------------------------
//
//
//  Description:
//      Ultility function to link all domains together  for recipient enumeration
//      (primarly used to NDR an entire message).
//
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to link domains together for
//  Returns:
//      S_OK on success
//  History:
//      10/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrLinkAllDomains(IN IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrLinkAllDomains");
    HRESULT hr = S_OK;
    DWORD cDomains = 0;
    DWORD iCurrentDomain = 1;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;

    _ASSERT(pIMailMsgProperties);

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients,
                                            (void **) &pIMailMsgRecipients);
    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgRecipients failed");
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgRecipients->DomainCount(&cDomains);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: Unable to get DomainCount - hr 0x%08X", hr);
        goto Exit;
    }

    //Set up domain list for all domains
    for (iCurrentDomain = 1; iCurrentDomain < cDomains; iCurrentDomain++)
    {
        hr = pIMailMsgRecipients->SetNextDomain(iCurrentDomain-1, iCurrentDomain,
                                FLAG_OVERWRITE_EXISTING_LINKS);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: SetNextDomain Failed - hr 0x%08X", hr);
            goto Exit;
        }
    }

    //handle single domain case
    if (1 == cDomains)
    {
        hr = pIMailMsgRecipients->SetNextDomain(0, 0, FLAG_SET_FIRST_DOMAIN);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: SetNextDomain Failed for single domain- hr 0x%08X", hr);
            goto Exit;
        }
    }

  Exit:

    if (pIMailMsgRecipients)
        pIMailMsgRecipients->Release();

    TraceFunctLeave();
    return hr;
}


//Parses a GUID from a string... returns TRUE on success
//---[ fAQParseGuidString ]----------------------------------------------------
//
//
//  Description:
//      Attempts to parse a GUID from a string of hex digits..
//      Can handle punctuation, spaces and even leading "0x"'s.
//  Parameters:
//      IN  szGuid  String to parse GUID from
//      IN  cbGuid  Max size of GUID string buffer
//      OUT guidID  GUID parsed from string
//  Returns:
//      TRUE if a guid value could be parsed from the string
//      FALSE if a guid value could not be parsed from the string
//  History:
//      10/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fAQParseGuidString(LPSTR szGuid, DWORD cbGuid, GUID *pguid)
{
    const   DWORD NO_SUCH_VALUE = 0xFF;
    BOOL    fParsed = FALSE;
    BOOL    fLastCharZero = FALSE; //Used to handle "0x"
    DWORD   *pdwGuid = (DWORD *) pguid;
    DWORD   cDigits = 0;
    DWORD   dwValue = NO_SUCH_VALUE;
    LPSTR   szCurrent = szGuid;
    LPSTR   szStop = szGuid + cbGuid/sizeof(CHAR);

    //Use DWORD array to populate GUID
    *pdwGuid = 0;
    while ((szStop > szCurrent) && (*szCurrent))
    {
        dwValue = NO_SUCH_VALUE;
        if (('0' <= *szCurrent) && ('9' >= *szCurrent))
            dwValue = *szCurrent-'0';
        else if (('a' <= *szCurrent) && ('f' >= *szCurrent))
            dwValue = 10 + *szCurrent-'a';
        else if (('A' <= *szCurrent) && ('F' >= *szCurrent))
            dwValue = 10 + *szCurrent-'A';
        else if (fLastCharZero &&
                 (('x' == *szCurrent) || ('X' == *szCurrent)))
        {
            //back out last shift (we don't have to subtract anything, since
            //the value was zero).
            _ASSERT(cDigits);
            if (0 == (cDigits % 8)) //happened when we changed DWORDs
                pdwGuid--;
            else
                *pdwGuid /= 16;  //undo last shift
            cDigits--;
        }

        //Set flag for handling 0x sequence
        if (0 != dwValue)
            fLastCharZero = FALSE;
        else
            fLastCharZero = TRUE;

        //In all string guid representations... a valid hex number is at least
        //2 characters long... so 0x0 should be mapped to 0x00 and 0xa should
        //be mapped to 0x0a.  Check and see if such a situation is happening
        if ((NO_SUCH_VALUE == dwValue) && (0 != (cDigits % 2)) &&
            (',' == *szCurrent))
        {
            //undo last add and shift.  The next if clause will re-write
            //the last value in at the proper point
            *pdwGuid /= 16;
            dwValue = *pdwGuid & 0x0000000F;
            *pdwGuid &= 0xFFFFFFF0;
            *pdwGuid *= 16;
        }

        //Add value to GUID if hex character
        if (NO_SUCH_VALUE != dwValue)
        {
            *pdwGuid += dwValue;
            if (0 == (++cDigits % 8))
            {
                //We have reached a DWORD boundary... move on
                if (32 == cDigits)
                {
                    //quit when we have enough
                    fParsed = TRUE;
                    break;
                }
                pdwGuid++;
                *pdwGuid = 0;
            }
            else
                *pdwGuid *= 16;
        }
        szCurrent++;
    }

    //Handle ending 0xa (should be 0x0a) digits
    if (!fParsed && (31 == cDigits))
    {
        dwValue = *pdwGuid & 0x000000FF;
        _ASSERT(!(dwValue & 0x0000000F));
        *pdwGuid &= 0xFFFFFF00;
        dwValue /= 16;
        *pdwGuid += dwValue;
        fParsed = TRUE;
    }

    return fParsed;
}


//---[ InterlockedAddSubtractULARGE ]------------------------------------------
//
//
//  Description:
//      Performs "interlocked" Add/Subtract on ULARGE_INTEGER structures.
//
//      Uses s_slUtilityData to synchronize if neccessary.
//  Parameters:
//      IN      puliValue       ULARGE to modify
//      IN      puliNew         ULARGE to modify value with
//      IN      fAdd            TRUE if we are adding new value
//                              FALSE if we are subtracting
//  Returns:
//      -
//  History:
//      11/2/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------

void InterlockedAddSubtractULARGE(ULARGE_INTEGER *puliValue,
                                  ULARGE_INTEGER *puliNew, BOOL fAdd)
{
    _ASSERT(puliValue);
    _ASSERT(puliNew);
    ULARGE_INTEGER uliTmp = {0};
    BOOL    fDone = FALSE;
    DWORD   dwTmp = 0;
    DWORD   dwHighPart = 0;
    DWORD   dwLowPart = 0;
    static  CShareLockNH s_slUtilityData; //Used to synchronize global updates of ULONG

    s_slUtilityData.ShareLock();
    BOOL    fShareLock = TRUE; //FALSE implies Exclusive lock

    while (!fDone)
    {
        uliTmp.QuadPart = puliValue->QuadPart;
        dwHighPart = uliTmp.HighPart;
        dwLowPart = uliTmp.LowPart;

        if (fAdd)
            uliTmp.QuadPart += puliNew->QuadPart; //add volume
        else
            uliTmp.QuadPart -= puliNew->QuadPart;

        //First see of the high part needs updating
        if (dwHighPart != uliTmp.HighPart)
        {
            if (fShareLock)
            {
                //This only happens every 4GB of data per queue..
                //which means we shouldn't be hitting this lock that
                //often
                s_slUtilityData.ShareUnlock();
                s_slUtilityData.ExclusiveLock();
                fShareLock = FALSE;

                //Go back to top of loop and re-get data
                continue;
            }

            //At this point it is just safe for us to update the values
            puliValue->QuadPart = uliTmp.QuadPart;
        }
        else if (dwLowPart != uliTmp.LowPart)
        {
            //Only need to update the low DWORD
            dwTmp = (DWORD) InterlockedCompareExchange(
                                            (PLONG) &(puliValue->LowPart),
                                            (LONG) uliTmp.LowPart,
                                            (LONG) dwLowPart);
            if (dwLowPart != dwTmp)
                continue;  //update failed
        }

        fDone = TRUE;
    }

    if (fShareLock)
        s_slUtilityData.ShareUnlock();
    else
        s_slUtilityData.ExclusiveUnlock();

}

//---[ HrValidateMessageContent ]----------------------------------------------
//
//
//  Description:
//      Validates a message based on its content handle.  If the backing store
//      has been deleted, and the handle is not cached, we should detect this.
//  Parameters:
//      pIMailMsgProperties             - MailMsg to validate
//  Returns:
//      HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) Message belongs to this store
//          driver but is no longer valid
//      other error code from store driver interface or mailmsg
//  History:
//      4/13/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrValidateMessageContent(IMailMsgProperties *pIMailMsgProperties)
{
    TraceFunctEnterEx((LPARAM) pIMailMsgProperties, "HrValidateMessageContent");
    IMailMsgBind   *pBindInterface = NULL;
    PFIO_CONTEXT    pIMsgFileHandle = NULL;
    HRESULT hr = S_OK;

    //
    //  Attempt to query interface for the binding interface
    //
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgBind,
                                            (void **)&pBindInterface);
    if (FAILED(hr) || !pBindInterface)
    {
        ErrorTrace((LPARAM) pIMailMsgProperties,
            "Unable to QI for IID_IMailMsgBind - hr 0x%08X", hr);
        goto Exit;
    }

    //
    //  Request the PFIO_CONTEXT for this message
    //
    hr = pBindInterface->GetBinding(&pIMsgFileHandle, NULL);
    DebugTrace((LPARAM) pIMailMsgProperties,
            "GetBinding return hr - 0x%08X", hr);

  Exit:

    if (pBindInterface)
    {
        pBindInterface->ReleaseContext();
        pBindInterface->Release();
    }

    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\aqueue.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File:
//      aqueue.cpp
//  Description:
//      Implementation of DLL Exports.
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"

#ifndef PLATINUM
#include "initguid.h"
#include <iadmw.h>
#endif //PLATINUM

#include "aqueue_i.c"
#include "aqintrnl_i.c"
#include "SMTPConn.h"
#include "qwiklist.h"
#include "fifoqimp.h"
#include <irtlmisc.h>
#include <iiscnfg.h>
#include <wrapmb.h>
#include <smtpinet.h>

#include <cat.h>
#include <aqinit.h>
#include "aqrpcsvr.h"

//Global vars used for shutdown
DWORD g_cInstances = 0;
CShareLockNH g_slInit;  //lock used for thread-safe initialization

//Global vars used for Dll init/shutdown (including Cat COM stuff)
LONG  g_cDllInit = 0;
BOOL  g_fInit = FALSE;
CShareLockNH g_slDllInit;
BOOL  g_fForceDllCanUnloadNowFailure = FALSE;

#define CALL_SERVICE_STATUS_CALLBACK \
    pServiceStatusFn ? pServiceStatusFn(pvServiceContext) : 0

//---[ HrAdvQueueInitializeEx ]-------------------------------------------------
//
//
//  Description:
//      Aqueue.dll initialization function that provides in params for user name,
//      domain, password, and service control callback functions.
//  Parameters:
//      IN  pISMTPServer         ptr to local delivery function / object
//      IN  dwServerInstance     virtual server instance
//      IN  szUserName           User name to log on DS with
//      IN  szDomainName         Domain name to log on to DS with
//      IN  szPassword           Password to authenticate to DS with
//      IN  pServiceStatusFn     Server status callback function
//      IN  pvServiceContext     Context to pass back for callback function
//      OUT ppIAdvQueue          returned IAdvQueue ptr
//      OUT ppIConnectionManager returned IConnectionManager ptr
//      OUT ppIAdvQueueConfig    returned IAdvQueueConfig ptr
//      OUT ppvContext           Virtual server context
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueInitializeEx(
                    IN  ISMTPServer *pISMTPServer,
                    IN  DWORD   dwServerInstance,
                    IN  LPSTR   szUserName,
                    IN  LPSTR   szDomainName,
                    IN  LPSTR   szPassword,
                    IN  PSRVFN  pServiceStatusFn,
                    IN  PVOID   pvServiceContext,
                    OUT IAdvQueue **ppIAdvQueue,
                    OUT IConnectionManager **ppIConnectionManager,
                    OUT IAdvQueueConfig **ppIAdvQueueConfig,
                    OUT PVOID *ppvContext)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrAdvQueueInitialize");
    HRESULT hr = S_OK;
    CAQSvrInst *paqinst = NULL;
    CDomainMappingTable *pdmt = NULL;
    BOOL    fLocked = FALSE;
    BOOL    fInstanceCounted = FALSE;

#ifdef PLATINUM
    BOOL    fIisRtlInit = FALSE;
    BOOL    fATQInit = FALSE;
#endif

    BOOL    fAQDllInit = FALSE;
    BOOL    fExchmemInit = FALSE;
    BOOL    fCPoolInit = FALSE;
    BOOL    fRpcInit = FALSE;

    CALL_SERVICE_STATUS_CALLBACK;
    g_slInit.ExclusiveLock();
    fLocked = TRUE;

    if ((NULL == ppIAdvQueue) ||
        (NULL == ppIConnectionManager) ||
        (NULL == ppvContext) ||
        (NULL == ppIAdvQueueConfig))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppvContext = NULL;

    if (1 == InterlockedIncrement((PLONG) &g_cInstances))
    {
        fInstanceCounted = TRUE;
        CALL_SERVICE_STATUS_CALLBACK;

#ifdef PLATINUM
        //Initialize IISRTL
        if (!InitializeIISRTL())
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL, "ERROR: LISRTL Init failed with 0x%08X", hr);
            if (SUCCEEDED(hr))
                hr = E_FAIL;
            goto Exit;
        }
        fIisRtlInit = TRUE;

        //Initialize ATQ
        if (!AtqInitialize(0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM) NULL, "ERROR: ATQ Init failed with 0x%08X", hr);
            if (SUCCEEDED(hr))
                hr = E_FAIL;
            goto Exit;
        }
        fATQInit = TRUE;
#endif

        hr = HrDllInitialize();
        if (FAILED(hr))
        {
            goto Exit;
        }
        fAQDllInit = TRUE;

        //create CPool objects
        if (!CQuickList::s_QuickListPool.ReserveMemory(10000, sizeof(CQuickList)))
            hr = E_OUTOFMEMORY;

        if (!CSMTPConn::s_SMTPConnPool.ReserveMemory(g_cMaxConnections, sizeof(CSMTPConn)))
            hr = E_OUTOFMEMORY;

        if (!CMsgRef::s_MsgRefPool.ReserveMemory(100000, (DWORD)MSGREF_STANDARD_CPOOL_SIZE))
            hr = E_OUTOFMEMORY;

        if (!CAQMsgGuidListEntry::s_MsgGuidListEntryPool.ReserveMemory(500, sizeof(CAQMsgGuidListEntry)))
            hr = E_OUTOFMEMORY;

        if (!CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool.ReserveMemory(20000, sizeof(CAsyncWorkQueueItemAllocatorBlock)))
            hr = E_OUTOFMEMORY;

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL, "Error unable to initialize CPOOL");
            goto Exit;
        }

        fCPoolInit = TRUE;

        //Initialize Queue Admin RPC interface
        hr = CAQRpcSvrInst::HrInitializeAQRpc();
        if (FAILED(hr))
            goto Exit;

        fRpcInit = TRUE;

    }

    if (!g_pslGlobals)
    {
        g_pslGlobals = new CShareLockNH();
        if (NULL == g_pslGlobals) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    CALL_SERVICE_STATUS_CALLBACK;
    g_slInit.ExclusiveUnlock();
    fLocked = FALSE;

    CFifoQueue<CLinkMsgQueue *>::StaticInit();
    CFifoQueue<CMsgRef *>::StaticInit();
    CFifoQueue<IMailMsgProperties *>::StaticInit();
    CFifoQueue<CAsyncWorkQueueItem *>::StaticInit();

    //Create requested objects
    CALL_SERVICE_STATUS_CALLBACK;
    paqinst = new CAQSvrInst(dwServerInstance, pISMTPServer);
    if (NULL == paqinst)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    CALL_SERVICE_STATUS_CALLBACK;
    hr = paqinst->HrInitialize(szUserName, szDomainName, szPassword,
                            pServiceStatusFn,
                            pvServiceContext);
    if (FAILED(hr))
        goto Exit;

    //Create Connection Manager
    CALL_SERVICE_STATUS_CALLBACK;
    hr = paqinst->HrGetIConnectionManager(ppIConnectionManager);

    //Set Return values
    *ppIAdvQueue = (IAdvQueue *) paqinst;  //Already addref'd at creation
    *ppIAdvQueueConfig = (IAdvQueueConfig *) paqinst;
    (*ppIAdvQueueConfig)->AddRef();

  Exit:
    if (FAILED(hr))
    {
        //Make sure that we clean up everything here
        if (NULL != paqinst)
            paqinst->Release();

        //If initialization failed... we should not count an
        //instance as started
        if (fInstanceCounted)
            InterlockedDecrement((PLONG) &g_cInstances);

#ifdef PLATINUM
        if (fATQInit)
            AtqTerminate();

        if (fIisRtlInit)
            TerminateIISRTL();
#endif

        if (fAQDllInit)
            DllDeinitialize();

        if (fCPoolInit)
        {
            //Release CPool objects
            CQuickList::s_QuickListPool.ReleaseMemory();
            CSMTPConn::s_SMTPConnPool.ReleaseMemory();
            CMsgRef::s_MsgRefPool.ReleaseMemory();
            CAQMsgGuidListEntry::s_MsgGuidListEntryPool.ReleaseMemory();
            CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool.ReleaseMemory();
        }

        if (fRpcInit)
            CAQRpcSvrInst::HrDeinitializeAQRpc();
    }
    else
    {
        *ppvContext = (PVOID) paqinst;
        paqinst->AddRef();
    }

    if (fLocked)
        g_slInit.ExclusiveUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ HrAdvQueueInitialize ]---------------------------------------------------
//
//
//  Description:
//      Performs DLL-wide initialization
//
//  Parameters:
//      IN  pISMTPServer         ptr to local delivery function / object
//      IN  dwServerInstance     virtual server instance
//      OUT ppIAdvQueue          returned IAdvQueue ptr
//      OUT ppIConnectionManager returned IConnectionManager ptr
//      OUT ppIAdvQueueConfig    returned IAdvQueueConfig ptr
//      OUT ppvContext           Virtual server context
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueInitialize(
                    IN  ISMTPServer *pISMTPServer,
                    IN  DWORD   dwServerInstance,
                    OUT IAdvQueue **ppIAdvQueue,
                    OUT IConnectionManager **ppIConnectionManager,
                    OUT IAdvQueueConfig **ppIAdvQueueConfig,
                    OUT PVOID *ppvContext)
{
    HRESULT hr = S_OK;

    hr =  HrAdvQueueInitializeEx(pISMTPServer, dwServerInstance,
                NULL, NULL, NULL, NULL, NULL, ppIAdvQueue,
                ppIConnectionManager, ppIAdvQueueConfig, ppvContext);
    return hr;
}

//---[ HrAdvQueueDeinitializeEx ]------------------------------------------------
//
//
//  Description:
//      Performs DLL-wide Cleanup.
//
//      Adds callback to service control manager.
//
//      This MUST not be called until all DLL objects have been released.
//
//      NOTE: There are several objects that are exported outside this DLL.
//      The following are directly exported & should be released before the
//      the Heap and CPool allocations are freed
//          IAdvQueue
//          IConnectionManager
//          ISMTPConnection
//      The Message Context also contains several references to internal objects,
//      but does not need to be explicitly released (since these objects can only
//      be accessed though the AckMessage() call).
//  Parameters:
//      PVOID   pvContext       Context that was returned by initialization
//                              function
//      IN  pServiceStatusFn     Server status callback function
//      IN  pvServiceContext     Context to pass back for callback function
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueDeinitializeEx(IN PVOID pvContext,
                               IN  PSRVFN  pServiceStatusFn,
                               IN  PVOID   pvServiceContext)
{
    TraceFunctEnterEx((LPARAM) NULL, "HrAdvQueueDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrCurrent = S_OK;
    DWORD   cRefs;
    DWORD   dwWaitResult = WAIT_OBJECT_0;
    bool    fDestroyHeap = true;
    DWORD   dwShutdownTimeout = 0;  //time to wait for shutdown
    CAQSvrInst *paqinst;
    g_fForceDllCanUnloadNowFailure = TRUE;
    g_slInit.ExclusiveLock();

    if (NULL != pvContext)
    {
        paqinst = (CAQSvrInst *) pvContext;
        hr = paqinst->HrDeinitialize();

        cRefs = paqinst->Release();
        DebugTrace((LPARAM) NULL, "There are %d refs remaining on the CMQ", cRefs);
        if (0 != cRefs)
        {
            _ASSERT(0 && "Someone has outstanding references to IAdvQueue or IAdvQueuConfig");
            fDestroyHeap = false;
        }
    }

    CFifoQueue<CLinkMsgQueue *>::StaticDeinit();
    CFifoQueue<CMsgRef *>::StaticDeinit();
    CFifoQueue<IMailMsgProperties *>::StaticDeinit();
    CFifoQueue<CAsyncWorkQueueItem *>::StaticDeinit();

    if (0 == InterlockedDecrement((PLONG) &g_cInstances))
    {
#ifdef PLATINUM
        AtqTerminate();
#endif

        if (fDestroyHeap)
        {
            delete g_pslGlobals;
            g_pslGlobals = NULL;

            DllDeinitialize();

            //Release CPool objects
            CQuickList::s_QuickListPool.ReleaseMemory();
            CSMTPConn::s_SMTPConnPool.ReleaseMemory();
            CMsgRef::s_MsgRefPool.ReleaseMemory();
            CAQMsgGuidListEntry::s_MsgGuidListEntryPool.ReleaseMemory();
            CAsyncWorkQueueItem::s_CAsyncWorkQueueItemPool.ReleaseMemory();

        }

        //Deinitialize Queue Admin RPC interface
        hr = CAQRpcSvrInst::HrDeinitializeAQRpc();

#ifdef PLATINUM
        TerminateIISRTL();
#endif

        //Force mailmsg and other COM DLLs to go buh-bye
        CoFreeUnusedLibraries();
    }

    g_slInit.ExclusiveUnlock();
    TraceFunctLeave();
    g_fForceDllCanUnloadNowFailure = FALSE;
    return hr;
}

//---[ HrAdvQueueDeinitialize ]------------------------------------------------
//
//
//  Description:
//      Performs DLL-wide Cleanup.
//
//      This MUST not be called until all DLL objects have been released.
//
//      NOTE: There are several objects that are exported outside this DLL.
//      The following are directly exported & should be released before the
//      the Heap and CPool allocations are freed
//          IAdvQueue
//          IConnectionManager
//          ISMTPConnection
//      The Message Context also contains several references to internal objects,
//      but does not need to be explicitly released (since these objects can only
//      be accessed though the AckMessage() call).
//  Parameters:
//      PVOID   pvContext       Context that was returned by initialization
//                              function
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT HrAdvQueueDeinitialize(PVOID pvContext)
{
    return HrAdvQueueDeinitializeEx(pvContext, NULL, NULL);
}

//---[ HrRegisterAdvQueueDll ]-------------------------------------------------
//
//
//  Description:
//      Sets metabase path of for advanced queuing DLL to this DLL.
//  Parameters:
//      hAQInstance - Handle passed into DLL main
//  Returns:
//      S_OK on success
//      E_INVALIDARG if hAQInstance is NULL.
//      Error codes from accessed metabase
//  History:
//      7/30/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrRegisterAdvQueueDll(HMODULE hAQInstance)
{
    HRESULT hr = S_OK;
    WCHAR   wszModule[512] = L"";
    METADATA_HANDLE     hMDRootVS = NULL;
    METADATA_RECORD     mdrData;
    DWORD   dwErr = NO_ERROR;
    DWORD   cbModule = 0;
    IMSAdminBase *pMSAdmin = NULL;

    ZeroMemory(&mdrData, sizeof(METADATA_RECORD));

    CoInitialize(NULL);
    InitAsyncTrace();
    TraceFunctEnterEx((LPARAM) NULL, "HrRegisterAdvQueueDll");

    if (!hAQInstance)
    {
        hr = E_INVALIDARG;
        ErrorTrace((LPARAM) NULL, "DLL Main did not save instance");
        goto Exit;
    }

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) &pMSAdmin);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "CoCreateInstance failed! hr = 0x%08X", hr);
        goto Exit;
    }

    dwErr = GetModuleFileNameW(hAQInstance,
                              wszModule,
                              sizeof(wszModule)/sizeof(WCHAR));
    //GetModuleFileName returns non-zero on success
    if (0 == dwErr)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) NULL, "GetModule name failed - 0x%08X", hr);
        if (SUCCEEDED(hr)) hr = E_FAIL;
        goto Exit;
    }

    cbModule = (wcslen(wszModule)+1)*sizeof(WCHAR);

    hr = pMSAdmin->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                            L"LM/SMTPSVC/",
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                            10000,
                            &hMDRootVS);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could not open the key! - 0x%08x", hr);
        goto Exit;
    }

    mdrData.dwMDIdentifier  = MD_AQUEUE_DLL;
    mdrData.dwMDAttributes  = METADATA_INHERIT;
    mdrData.dwMDUserType    = IIS_MD_UT_SERVER;
    mdrData.dwMDDataType    = STRING_METADATA;
    mdrData.dwMDDataLen     = cbModule;
    mdrData.pbMDData        = (PBYTE) wszModule;
    mdrData.dwMDDataTag     = 0;
    hr = pMSAdmin->SetData( hMDRootVS, L"", &mdrData);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could set the AQ DLL - 0x%08X", hr);
        goto Exit;
    }


  Exit:

    if (NULL != hMDRootVS)
        pMSAdmin->CloseKey(hMDRootVS);

    if (pMSAdmin)
    {
        hr = pMSAdmin->SaveData();
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL, "Error saving metabase data  -  0x%08X", hr);
        }
    }

    TraceFunctLeave();
    TermAsyncTrace();
    CoUninitialize();
    return hr;
}

//---[ HrUnregisterAdvQueueDll ]-----------------------------------------------
//
//
//  Description:
//      Removes the AdvQueue DLL setting from the metabase
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      Error from MSAdminBase
//  History:
//      8/2/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT HrUnregisterAdvQueueDll()
{
    HRESULT hr = S_OK;
    DWORD   dwErr = NO_ERROR;
    METADATA_HANDLE     hMDRootVS = NULL;
    IMSAdminBase *pMSAdmin = NULL;


    CoInitialize(NULL);
    InitAsyncTrace();
    TraceFunctEnterEx((LPARAM) NULL, "HrUnregisterAdvQueueDll");

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) &pMSAdmin);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "CoCreateInstance failed! hr = 0x%08X", hr);
        goto Exit;
    }

    hr = pMSAdmin->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                            L"LM/SMTPSVC/",
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                            10000,
                            &hMDRootVS);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could not open the key! - 0x%08x", hr);
        goto Exit;
    }

    hr = pMSAdmin->DeleteData( hMDRootVS, L"", MD_AQUEUE_DLL, STRING_METADATA);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) NULL, "Could delete the AQ DLL - 0x%08X", hr);
        goto Exit;
    }


  Exit:

    if (NULL != hMDRootVS)
        pMSAdmin->CloseKey(hMDRootVS);

    if (pMSAdmin)
    {
        hr = pMSAdmin->SaveData();
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) NULL, "Error saving metabase data  -  0x%08X", hr);
        }
    }

    TraceFunctLeave();
    TermAsyncTrace();
    CoUninitialize();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hAQInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
    }

    return CatDllMain(hInstance, dwReason, NULL);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

//
// Register COM objects
//
STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;
    HRESULT hrCat = S_OK;

    hr = HrRegisterAdvQueueDll(g_hAQInstance);

    hrCat =  RegisterCatServer();

    if (SUCCEEDED(hr))
        hr = hrCat;

    return hr;
}

//
// Unregister COM objects
//
STDAPI DllUnregisterServer()
{
    HRESULT hr = S_OK;
    HRESULT hrCat = S_OK;

    hr = HrUnregisterAdvQueueDll();

    hrCat = UnregisterCatServer();

    if (SUCCEEDED(hr))
        hr = hrCat;

    return hr;
}

STDAPI DllCanUnloadNow()
{
    HRESULT hr;

    hr = DllCanUnloadCatNow();
    if(hr == S_OK) {
        //
        // Check aqueue COM objects (if any)
        //
        if (g_fForceDllCanUnloadNowFailure || g_cInstances)
            hr = S_FALSE;
    }
    return hr;
}

STDAPI DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
{
    HRESULT hr;
    //
    // Check to see if clsid is an aqueue object (if any aqueue
    // objects are cocreateable)
    // Currently none are
    //
    // Pass to the cat
    //
    hr = DllGetCatClassObject(
        clsid,
        iid,
        ppv);

    return hr;
}


//+------------------------------------------------------------
//
// Function: HrDllInitialize
//
// Synopsis: Refcounted initialize of exchmem and tracing
//  The logic for HrDllInitialize and DllDeInitialize depend on the
//  facts that the callers always call HrDllInitialize first and only
//  call DllDeInitialize once after each call to HrDllInitialize succeeds
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  error from exstrace
//
// History:
// jstamerj 1998/12/16 15:37:07: Created.
//
//-------------------------------------------------------------
HRESULT HrDllInitialize()
{
    HRESULT hr = S_OK;
    LONG lNewCount;

    //
    // Increment inside a sharelock because of the following case:
    // If multiple threads are calling initialize and one thread is
    // actually doing the initialization, we don't want any threads to
    // return from this function until the initialization is done
    //
    g_slDllInit.ShareLock();

    lNewCount = InterlockedIncrement(&g_cDllInit);

    //
    // No matter what, we must Init before leaving this call
    // Possible scenerios:
    //
    // lNewCount = 1, g_fInit = FALSE
    //   Normal initialization case
    // lNewCount = 1, g_fInit = TRUE
    //   Another thread is in DllDeinitialize and we have a race to
    //   see who gets the exclusive lock first.  If we get it first,
    //   DllInitialize will do nothing (since g_fInit is TRUE) and
    //   DllDeInitialize will do nothing (since g_cDllInit will be >
    //   0)
    //   If DllDeInitialize gets the exclusive lock first, it will
    //   deinit and we will reinit
    // lNewCount > 1, g_fInit = FALSE
    //   We need to get the exclusive lock to init (or to wait until
    //   another thread inits)
    // lNewCount > 1, g_fInit = TRUE
    //   We're alrady initialized, continue.
    //
    if((lNewCount == 1) || (g_fInit == FALSE)) {

        g_slDllInit.ShareUnlock();
        g_slDllInit.ExclusiveLock();

        if(g_fInit == FALSE) {
            //
            // Initialize exchmem and tracing
            //
            InitAsyncTrace();

            //
            // Initialize exchmem
            //
            if(!TrHeapCreate()) {

                hr = E_OUTOFMEMORY;
                TermAsyncTrace();
            }
            if(SUCCEEDED(hr))  {
                g_fInit = TRUE;
            } else {
                InterlockedDecrement(&g_cDllInit);
            }
        }
        g_slDllInit.ExclusiveUnlock();

    } else {

        g_slDllInit.ShareUnlock();
    }
    _ASSERT(g_fInit);
    return hr;
}


//+------------------------------------------------------------
//
// Function: DllDeinitialize
//
// Synopsis: Refcounted deinitialize of exchmem and tracing
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/16 15:46:32: Created.
//
//-------------------------------------------------------------
VOID DllDeinitialize()
{
    //
    // We don't need to do the decrement inside a sharelock because we
    // don't care about blocking threads until the DLL is really
    // DeInitialzied (whereas HrDllInitialize does care)
    //
    if(InterlockedDecrement(&g_cDllInit) == 0) {

        g_slDllInit.ExclusiveLock();
        //
        // If the refcount is still zero, deinitialize
        // If the refcount is non-zero, someone initialized before we
        // got the exclusive lock, so do not deinitialize
        //
        if(g_cDllInit == 0) {
            //
            // If this assert fires, then DllDeinitialize has been
            // called before DllInitialize returned (or there is a
            // DllInit/Deinit mismatch)
            //
            _ASSERT(g_fInit == TRUE);

            //
            // Termiante exchmem and tracing
            //
            if(!TrHeapDestroy()) {

                TraceFunctEnter("DllDeinitialize");
                ErrorTrace((LPARAM) 0,
                           "Unable to Destroy Exchmem heap for Advanced Queuing");
                TraceFunctLeave();
            }
            TermAsyncTrace();
            g_fInit = FALSE;

        } else {
            //
            // Someone called initialize between the time we
            // decremented the count and got the exclusive lock.  In
            // this case we don't want to deinitialize
            //
        }
        g_slDllInit.ExclusiveUnlock();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asncwrkq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: asncwrkq.h
//
//  Description:  Header file for CAsyncWorkQueue class.  This class uses
//      ATQ threads to do async work.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      3/8/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __ASNCWRKQ_H__
#define __ASNCWRKQ_H__

#include "aqincs.h"
#include "asyncq.h"

//Async work queue call back function
typedef BOOL (*PASYNC_WORK_QUEUE_FN)(PVOID pvContext, 
                                    DWORD dwStatus);

#define ASYNC_WORK_QUEUE_SIG                        'QkrW'
#define ASYNC_WORK_QUEUE_SIG_FREE                   'Qkr!'
#define ASYNC_WORK_QUEUE_ENTRY                      'EkrW'
#define ASYNC_WORK_QUEUE_ENTRY_FREE                 'Ekr!'

//Signatures to describe how this entry was allocated
#define ASYNC_WORK_QUEUE_ENTRY_ALLOC_CPOOL_SIG      'QWAP'
#define ASYNC_WORK_QUEUE_ENTRY_ALLOC_HEAP_SIG       'QWAH'
#define ASYNC_WORK_QUEUE_ENTRY_ALLOC_INVALID_SIG    'QWA!'

typedef enum TagAsyncWorkQueueItemState
{
    ASYNC_WORK_QUEUE_NORMAL         = 0x00000001,
    ASYNC_WORK_QUEUE_SHUTDOWN       = 0x00000002,
    ASYNC_WORK_QUEUE_FAILURE        = 0x00000003,

    //Warning flag set when failure happens on enqueue thread
    ASYNC_WORK_QUEUE_ENQUEUE_THREAD = 0x80000001,
} AsyncWorkQueueItemState;

class CAsyncWorkQueue;

//---[ CAsyncWorkQueueItem ]---------------------------------------------------
//
//
//  Description: 
//      Item in async work queue
//
//  Hungarian: 
//      awqi, pawqi
//  
//-----------------------------------------------------------------------------
class CAsyncWorkQueueItem : 
    public CBaseObject
{
  public:
    //define special memory allocators
    static  CPool           s_CAsyncWorkQueueItemPool;
    static  DWORD           s_cCurrentHeapAllocations;
    static  DWORD           s_cTotalHeapAllocations;

    void * operator new (size_t size); 
    void operator delete(void *pv, size_t size);

    CAsyncWorkQueueItem(PVOID pvData,
                        PASYNC_WORK_QUEUE_FN pfnCompletion);
    ~CAsyncWorkQueueItem();
  protected:
    DWORD                   m_dwSignature;
    PVOID                   m_pvData;
    PASYNC_WORK_QUEUE_FN    m_pfnCompletion;
    friend class            CAsyncWorkQueue;
};


//---[ CAsyncWorkQueueItemAllocatorBlock ]-------------------------------------
//
//
//  Description: 
//      Struct used as a hidden wrapper for CAsyncWorkQueueItem allocation... 
//      used exclusively by the CAsyncWorkQueueItem new and delete operators
//  Hungarian: 
//      cpawqi, pcpawqi
//  
//-----------------------------------------------------------------------------
typedef struct TagCAsyncWorkQueueItemAllocatorBlock

{
    DWORD                   m_dwSignature;
    CAsyncWorkQueueItem     m_pawqi;
} CAsyncWorkQueueItemAllocatorBlock;


//---[ CAsyncWorkQueue ]-------------------------------------------------------
//
//
//  Description: 
//      Async work queue that 
//  Hungarian: 
//      awq, paqw
//  
//-----------------------------------------------------------------------------
class CAsyncWorkQueue 
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_cWorkQueueItems;
    DWORD       m_dwStateFlags;
    CAsyncQueue<CAsyncWorkQueueItem *, ASYNC_QUEUE_WORK_SIG> m_asyncq;
  public:
    CAsyncWorkQueue();
    ~CAsyncWorkQueue();
    HRESULT HrInitialize(DWORD cItemsPerThread);
    HRESULT HrDeinitialize(CAQSvrInst *paqinst);
    HRESULT HrQueueWorkItem(PVOID pvData, 
                            PASYNC_WORK_QUEUE_FN pfnCompletion);

    DWORD   cGetWorkQueueItems() {return m_cWorkQueueItems;};

    static  BOOL fQueueCompletion(CAsyncWorkQueueItem *pawqi,
                                  PVOID pawq);
    static  BOOL fQueueFailure(CAsyncWorkQueueItem *pawqi,
                               PVOID pawq);

    static  HRESULT HrShutdownWalkFn(CAsyncWorkQueueItem *paqwi, 
                                     PVOID pvContext,
                                     BOOL *pfContinue, 
                                     BOOL *pfDelete);
};

#endif //__ASNCWRKQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncq.cpp
//
//  Description: Non-template asyncq implementations
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/23/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "asyncq.h"
#include "asyncq.inl"

DWORD CAsyncQueueBase::s_cAsyncQueueStaticInitRefCount = 0;
DWORD CAsyncQueueBase::s_cMaxPerProcATQThreadAdjustment = 0;
DWORD CAsyncQueueBase::s_cDefaultMaxAsyncThreads = 0;


//---[ CAsyncQueueBase::ThreadPoolInitialize ]---------------------------------
//
//
//  Description: 
//      Performs static ATQ initialization.  This call is ref-counted.  If
//      it succeeds, the caller should call HrThreadPoolDeinitialze();
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/30/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAsyncQueueBase::ThreadPoolInitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueueBase::HrThreadPoolInitialize");
    DWORD   cATQMaxAsyncThreads = 0;
    DWORD   cATQMaxTotalAsyncThreads = 0;
    DWORD   cOurMaxAsyncThreads = 0;
    SYSTEM_INFO sinf;

    //
    //  On 0 -> 1 transition, adjust ATQ according to our config
    //
    if (!s_cAsyncQueueStaticInitRefCount)
    {
        //
        //  Get max threads per proc
        //
        cATQMaxAsyncThreads = (DWORD)AtqGetInfo(AtqMaxPoolThreads);
        _ASSERT(cATQMaxAsyncThreads && "AtqGetInfo says there are no threads!");
        if (!cATQMaxAsyncThreads)
            cATQMaxAsyncThreads = 1;

        cOurMaxAsyncThreads = cATQMaxAsyncThreads;
        
        //
        //  Adjust value by our config value
        //
        cOurMaxAsyncThreads += g_cPerProcMaxThreadPoolModifier;

        //
        //  Get # of procs (using GetSystemInfo)
        //
        GetSystemInfo(&sinf);
        cOurMaxAsyncThreads *= sinf.dwNumberOfProcessors;

        //
        //  We will throttle our requests at g_cMaxATQPercent
        //  the max number of ATQ threads
        //
        cOurMaxAsyncThreads = (g_cMaxATQPercent*cOurMaxAsyncThreads)/100;

        if (!cOurMaxAsyncThreads)
            cOurMaxAsyncThreads = 1;

        //
        //  Set static so people later on can use this calculation
        //
        s_cDefaultMaxAsyncThreads = cOurMaxAsyncThreads;

        //
        //  Now we need to adjust our threads
        //
        s_cMaxPerProcATQThreadAdjustment = g_cPerProcMaxThreadPoolModifier;

        //
        //  Per proc thread limit
        //
        if (s_cMaxPerProcATQThreadAdjustment) 
        {
            AtqSetInfo(AtqMaxPoolThreads, 
                cATQMaxAsyncThreads + s_cMaxPerProcATQThreadAdjustment);
            DebugTrace((LPARAM) this, 
                "Adjusting per proc ATQ thread limit by %d (orig %d)",
                s_cMaxPerProcATQThreadAdjustment, cATQMaxAsyncThreads);
        }

        _ASSERT(!(0xFF000000 & cOurMaxAsyncThreads)); //sanity check number
    }
    
    s_cAsyncQueueStaticInitRefCount++;
    m_cMaxAsyncThreads = s_cDefaultMaxAsyncThreads;
    DebugTrace((LPARAM) this, "Setting m_cMaxAsyncThreads to %d");
    
    TraceFunctLeave();
}


//---[ CAsyncQueueBase::ThreadPoolDeinitialize ]-------------------------------
//
//
//  Description: 
//      Will re-adjust ATQ data if we changed them during initialization
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      3/30/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAsyncQueueBase::ThreadPoolDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueueBase::HrThreadPoolDeinitialize");
    DWORD   cATQMaxAsyncThreads = 0;
    DWORD   cATQMaxTotalAsyncThreads = 0;

    _ASSERT(s_cAsyncQueueStaticInitRefCount != 0);
    s_cAsyncQueueStaticInitRefCount--;

    //
    //   If this is the last queue, adjust our configuration so back to
    //   the way we found it.
    //
    if (!s_cAsyncQueueStaticInitRefCount)
    {
        cATQMaxAsyncThreads = (DWORD)AtqGetInfo(AtqMaxPoolThreads);
        cATQMaxTotalAsyncThreads = (DWORD) AtqGetInfo(AtqMaxThreadLimit);

        //
        //  Reset per-proc threads if it makes sense
        //
        if (s_cMaxPerProcATQThreadAdjustment &&
            (cATQMaxAsyncThreads > s_cMaxPerProcATQThreadAdjustment))
        {
            AtqSetInfo(AtqMaxPoolThreads, 
                cATQMaxAsyncThreads - s_cMaxPerProcATQThreadAdjustment);
  
            DebugTrace((LPARAM) this,
                "Resetting ATQ Max per proc threads to %d",
                cATQMaxAsyncThreads - s_cMaxPerProcATQThreadAdjustment);
 
            s_cMaxPerProcATQThreadAdjustment = 0;
        }

    }

    TraceFunctLeave();
}

//---[ CAsyncRetryAdminMsgRefQueue::CAsyncRetryAdminMsgRefQueue ]--------------
//
//
//  Description: 
//      Constructor for CAsyncRetryAdminMsgRefQueue
//  Parameters:
//      szDomain        Domain name for this queue
//      pguid           GUID for this queue
//      dwID            Shedule ID for this queue
//  Returns:
//      -
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncRetryAdminMsgRefQueue::CAsyncRetryAdminMsgRefQueue(
                        LPCSTR szDomain, LPCSTR szLinkName, 
                        const GUID *pguid, DWORD dwID, CAQSvrInst *paqinst)
{
    _ASSERT(szDomain);
    _ASSERT(pguid);

    m_cbDomain = 0;
    m_szDomain = NULL;
    m_cbLinkName = 0;
    m_szLinkName = NULL;
    m_paqinst = paqinst;

    if (szDomain)
    {
        m_cbDomain = lstrlen(szDomain);
        m_szDomain = (LPSTR) pvMalloc(m_cbDomain+1);
        if (m_szDomain)
            lstrcpy(m_szDomain, szDomain);
    }

    if (szLinkName)
    {
        m_cbLinkName = lstrlen(szLinkName);
        m_szLinkName = (LPSTR) pvMalloc(m_cbLinkName+1);
    }

    if (m_szLinkName)
        lstrcpy(m_szLinkName, szLinkName);

    if (pguid)
        memcpy(&m_guid, pguid, sizeof(GUID));
    else
        ZeroMemory(&m_guid, sizeof(GUID));

    m_dwID = dwID;
}

//---[ CAsyncRetryAdminMsgRefQueue::~CAsyncRetryAdminMsgRefQueue ]-------------
//
//
//  Description: 
//      Destructor for CAsyncRetryAdminMsgRefQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAsyncRetryAdminMsgRefQueue::~CAsyncRetryAdminMsgRefQueue()
{
    if (m_szDomain)
        FreePv(m_szDomain);

    if (m_szLinkName)
        FreePv(m_szLinkName);
}

//---[ CAsyncRetryAdminMsgRefQueue::QueryInterface ]---------------------------
//
//
//  Description: 
//      QueryInterface for CAsyncRetryAdminMsgRefQueue that supports:
//          - IQueueAdminAction
//          - IUnknown
//          - IQueueAdminQueue 
//  Parameters:
//
//  Returns:
//
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncRetryAdminMsgRefQueue::QueryInterface(
                                                  REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminQueue == riid)
    {
        *ppvObj = static_cast<IQueueAdminQueue *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CAsyncRetryAdminMsgRefQueue::HrApplyQueueAdminFunction ]----------------
//
//
//  Description: 
//      Will call the IQueueAdminMessageFilter::Process message for every 
//      message in this queue.  If the message passes the filter, then
//      HrApplyActionToMessage on this object will be called.
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncRetryAdminMsgRefQueue::HrApplyQueueAdminFunction(
                     IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_OK;
    _ASSERT(pIQueueAdminMessageFilter);
    hr = pIQueueAdminMessageFilter->HrSetQueueAdminAction(
                                    (IQueueAdminAction *) this);

    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetQueueAdminAction");

    if (FAILED(hr))
        goto Exit;

    hr = HrMapFn(QueueAdminApplyActionToMessages, pIQueueAdminMessageFilter);

  Exit:
    return hr;
}

//---[ CAsyncRetryAdminMsgRefQueue::HrApplyActionToMessage ]-------------------
//
//
//  Description: 
//      Applies an action to this message for this queue.  This will be called
//      by the IQueueAdminMessageFilter during a queue enumeration function.
//  Parameters:
//      IN  *pIUnknownMsg       ptr to message abstraction
//      IN  ma                  Message action to perform
//      IN  pvContext           Context set on IQueueAdminFilter
//      OUT pfShouldDelete      TRUE if the message should be deleted
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created 
//      4/2/99 - MikeSwa Added context
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncRetryAdminMsgRefQueue::HrApplyActionToMessage(
                     IUnknown *pIUnknownMsg,
                     MESSAGE_ACTION ma,
                     PVOID pvContext,
                     BOOL *pfShouldDelete)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncRetryAdminMsgRefQueue::HrApplyActionToMessage");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;
    CLinkMsgQueue *plmq = (CLinkMsgQueue *)pvContext;
    CAQStats aqstats;

    _ASSERT(pIUnknownMsg);
    _ASSERT(pfShouldDelete);

    *pfShouldDelete = FALSE;

    hr = pIUnknownMsg->QueryInterface(IID_CMsgRef, (void **) &pmsgref);
    _ASSERT(SUCCEEDED(hr) && "IUnknownMsg Must be a CMsgRef!!");
    if (FAILED(hr))
        goto Exit;

    switch (ma)
    {
      case MA_DELETE:
        hr = pmsgref->HrQueueAdminNDRMessage(NULL);
        *pfShouldDelete = TRUE;
        break;
      case MA_DELETE_SILENT:
        hr = pmsgref->HrRemoveMessageFromQueue(NULL);
        *pfShouldDelete = TRUE;
        break;
      case MA_FREEZE_GLOBAL:
        pmsgref->GlobalFreezeMessage();
        break;
      case MA_THAW_GLOBAL:
        pmsgref->GlobalThawMessage();
        break;
      case MA_COUNT:
      default:
        //do nothing for counting and default
        break;
    }

    //
    //  If we are deleting the message, we need to tell the
    //  link so we can have accurate stats for the link.
    //
    if (*pfShouldDelete && SUCCEEDED(hr))
    {
        //
        // NTRAID#X5-138120-2000/10/04-mikeswa
        // We will not have a plmq, if this delete is coming 
        // from the queue-level.  This can cause stats to be 
        // incorrect, but this action is not exposed via the UI.
        //
        if (plmq)
        {
            pmsgref->GetStatsForMsg(&aqstats);
            plmq->HrNotify(&aqstats, FALSE);
        }
        else 
        {
            ErrorTrace((LPARAM) this, 
                "Unable to update stats for queue-level ops");
        }
        
        if (m_paqinst)
            m_paqinst->DecPendingLocal();
    }

  Exit:
    if (pmsgref)
        pmsgref->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CAsyncRetryAdminMsgRefQueue::HrGetQueueInfo ]---------------------------
//
//
//  Description: 
//      Gets the Queue Admin infor for this Queue
//  Parameters:
//      IN OUT pqiQueueInfo     Ptr to Queue Info Stucture to fill
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncRetryAdminMsgRefQueue::HrGetQueueInfo(
                                                     QUEUE_INFO *pqiQueueInfo)
{
    HRESULT hr = S_OK;

    //Get # of messages
    pqiQueueInfo->cMessages = m_cItemsPending+m_cRetryItems;

    //Get Link name: Note that this class is used for special links like
    //local delivery queue... so there is no destination SMTP domain to
    //route to... therefore we need to return a special link name to admin.
    
    pqiQueueInfo->szLinkName = wszQueueAdminConvertToUnicode(m_szLinkName,
                                                             m_cbLinkName);

    if (m_szDomain)
    {
        //Get Queue name
        pqiQueueInfo->szQueueName = wszQueueAdminConvertToUnicode(m_szDomain, 
                                                                  m_cbDomain);
        if (!pqiQueueInfo->szQueueName)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

    }

    //Currently setting this to zero since we do not calculate it
    pqiQueueInfo->cbQueueVolume.QuadPart = 0;

    pqiQueueInfo->dwMsgEnumFlagsSupported = AQUEUE_DEFAULT_SUPPORTED_ENUM_FILTERS;

  Exit:
    return hr;
}

//---[ CAsyncRetryAdminMsgRefQueue::HrGetQueueID ]-----------------------------
//
//
//  Description: 
//      Gets the QueueID for this Queue.  
//  Parameters:
//      IN OUT pQueueID     QUEUELINK_ID struct to fill in
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncRetryAdminMsgRefQueue::HrGetQueueID(
                                                    QUEUELINK_ID *pQueueID)
{
    pQueueID->qltType = QLT_QUEUE;
    pQueueID->dwId = m_dwID;
    memcpy(&pQueueID->uuid, &m_guid, sizeof(GUID));

    if (m_szDomain)
    {
        pQueueID->szName = wszQueueAdminConvertToUnicode(m_szDomain, m_cbDomain);
        if (!pQueueID->szName)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

//---[ CAsyncRetryAdminMsgRefQueue::fMatchesID ]-------------------------------
//
//
//  Description: 
//      Used to determine if this link matches a given scheduleID/guid pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CAsyncRetryAdminMsgRefQueue::fMatchesID(
                                                 QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);

    if (!pQueueLinkID)
        return FALSE;

    if (0 != memcmp(&m_guid, &(pQueueLinkID->uuid), sizeof(GUID)))
        return FALSE;

    if (m_dwID != pQueueLinkID->dwId)
        return FALSE;

    //Don't need to check domain name since there is a special GUID to 
    //identify the local async queue.  

    return TRUE;
}


//---[ CAsyncMailMsgQueue::HrQueueRequest ]------------------------------------
//
//
//  Description: 
//      Function that will queue a request to the async queue and close 
//      the handles associated with a message if we are above our simple
//      "throttle" limit.
//  Parameters:
//      pIMailMsgProperties The IMailMsgProperties interface to queue
//      fRetry              TRUE - if this message is being retried
//                          FALSE - otherwise
//      cMsgsInSystem       The total number of messages in the system
//  Returns:
//      S_OK on success
//      Error code from async queue on failure.
//  History:
//      10/7/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncMailMsgQueue::HrQueueRequest(IMailMsgProperties *pIMailMsgProperties, 
                                           BOOL  fRetry, 
                                           DWORD cMsgsInSystem)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncMailMsgQueue::HrQueueRequest");
    IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
    HRESULT hr = S_OK;

    if (g_cMaxIMsgHandlesThreshold < cMsgsInSystem)
    {
        DebugTrace((LPARAM) this, 
            "INFO: Closing IMsg Content - %d messsages in queue", cMsgsInSystem);
        hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt, 
                                                (void **) &pIMailMsgQueueMgmt);
        if (SUCCEEDED(hr))
        {
            //bounce usage count off of zero
            pIMailMsgQueueMgmt->ReleaseUsage();
            pIMailMsgQueueMgmt->AddUsage();
            pIMailMsgQueueMgmt->Release();
        }
        else
        {
            ErrorTrace((LPARAM) this, 
                "Unable to QI for IMailMsgQueueMgmt - hr 0x%08X", hr);
        }
    }

    TraceFunctLeave();
    return CAsyncMailMsgQueueBase::HrQueueRequest(pIMailMsgProperties, fRetry);
}

//---[ CAsyncMailMsgQueue::HrQueueRequest ]------------------------------------
//
//
//  Description: 
//      Since we inherit from AsyncQueue who implmenents this, we should assert 
//      so that a dev adding a new call to this class later on, will use the 
//      version that closes handles.
//
//      In RTL this will force the handles closed and queue the request 
//  Parameters:
//      pIMailMsgProperties The IMailMsgProperties interface to queue
//      fRetry              TRUE - if this message is being retried
//                          FALSE - otherwise
//  Returns:
//      returns return value from proper version of HrQueueRequest
//  History:
//      10/7/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAsyncMailMsgQueue::HrQueueRequest(IMailMsgProperties *pIMailMsgProperties, 
                                           BOOL  fRetry)
{
    _ASSERT(0 && "Should use HrQueueRequest with 3 parameters");
    return HrQueueRequest(pIMailMsgProperties, fRetry, 
                          g_cMaxIMsgHandlesThreshold+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncq.h
//
//  Description: Header file for CAsyncQueue class, which provides the 
//      underlying implementation of pre-local delivery and pre-categorization
//      queue.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/16/98 - MikeSwa Created 
//      2/2/99 - MikeSwa Added CAsyncRetryQueue
//      2/22/99 - MikeSwa Added  CAsyncRetryAdminMsgRefQueue
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __ASYNCQ_H__
#define __ASYNCQ_H__
#include <fifoq.h>
#include <intrnlqa.h>
#include <baseobj.h>
#include <aqstats.h>

_declspec(selectany) BOOL   g_fRetryAtFrontOfAsyncQueue = FALSE;

class CAQSvrInst;
class CAsyncWorkQueueItem;

#define ASYNC_QUEUE_SIG         'QnsA'
#define ASYNC_RETRY_QUEUE_SIG   ' QRA'

//Add new template signatures here
#define ASYNC_QUEUE_MAILMSG_SIG 'MMIt'
#define ASYNC_QUEUE_MSGREF_SIG  'frMt'
#define ASYNC_QUEUE_WORK_SIG    'krWt'

//---[ CAsyncQueueBase ]-------------------------------------------------------
//
//
//  Description: 
//      Base class for CAsyncQueue.  This is a separate class for 2 reasons.  
//      The most important reason to to allow access to standard member data 
//      with out knowing the template type of the class (for ATQ completion
//      functions).  The 2nd reason is to make it easier to write a debugger
//      extension to dump this information.
//
//      This class should only be used as a baseclass for CAsyncQueue... it
//      is not designed to be used by itself.
//  Hungarian: 
//      asyncqb, pasyncqb
//  
//-----------------------------------------------------------------------------
class CAsyncQueueBase
{
  protected:
    DWORD   m_dwSignature;
    DWORD   m_dwTemplateSignature;      //signature that defines type of PQDATA (for ATQ)
    DWORD   m_cMaxSyncThreads;          //max threads that can complete sync
    DWORD   m_cMaxAsyncThreads;         //Max # ATQ thread to use
    DWORD   m_cCurrentSyncThreads;      //current sync threads
    DWORD   m_cCurrentAsyncThreads;     //current number of async threads
    DWORD   m_cItemsPending;            //# of items pending in the queue
    LONG    m_cItemsPerATQThread;       //max # of items an atq thread will process
    LONG    m_cItemsPerSyncThread;      //max # of items a pilfered thread will process
    LONG    m_lUnscheduledWorkItems;    //# of items that aren't "spoken for" by a thread
                                        //Can be a negative value if there are 
    DWORD   m_cCurrentCompletionThreads;//# of threads processing end of queue
    DWORD   m_cTotalAsyncCompletionThreads;//Total # of async completion threads
    DWORD   m_cTotalSyncCompletionThreads; //Total # of async completion threads
    DWORD   m_cTotalShortCircuitThreads; //Total # of threads that proccess data without queue
    DWORD   m_cCompletionThreadsRequested; //# of threads requested to process queue
    DWORD   m_cPendingAsyncCompletions; //# of async completions that we know about
    DWORD   m_cMaxPendingAsyncCompletions;
    DWORD   m_dwQueueFlags;             //Describes status of queue
    PVOID   m_pvContext;                //Context that is passed to completion function
    PATQ_CONTEXT m_pAtqContext;         //ATQ Context for this object
    SOCKET  m_hAtqHandle;               //Handle used for atq stuff
    friend  VOID AsyncQueueAtqCompletion(PVOID pvContext, DWORD vbBytesWritten, 
                             DWORD dwStatus, OVERLAPPED *pOverLapped);
    inline  CAsyncQueueBase(DWORD dwTemplateSignature);

    VOID    IncrementPendingAndWorkCount(LONG lCount=1)
    {
        if (!lCount)
            return;

        _ASSERT(lCount > 0); //should call decrement
        InterlockedExchangeAdd((PLONG) &m_cItemsPending, lCount);
        InterlockedExchangeAdd(&m_lUnscheduledWorkItems, lCount);
    };

    VOID    DecrementPendingAndWorkCount(LONG lCount=-1)
    {
        if (!lCount)
            return;
        _ASSERT(lCount < 0); //should call increment instead
        InterlockedExchangeAdd(&m_lUnscheduledWorkItems, lCount);
        InterlockedExchangeAdd((PLONG) &m_cItemsPending, lCount);
    };
    
    enum //possible bits for m_dwQueueFlags
    {
        ASYNC_QUEUE_STATUS_PAUSED   = 0x00000001,
        ASYNC_QUEUE_STATUS_SHUTDOWN = 0x80000000, //shutdown has been signaled
    };

    //
    //  Statics used for ATQ stuff.
    //
    static DWORD s_cAsyncQueueStaticInitRefCount;
    static DWORD s_cMaxPerProcATQThreadAdjustment;
    static DWORD s_cDefaultMaxAsyncThreads;

    void ThreadPoolInitialize();
    void ThreadPoolDeinitialize();
  public:
      DWORD dwGetTotalThreads() 
      { 
          return (  m_cCurrentSyncThreads + 
                    m_cCurrentAsyncThreads + 
                    m_cCompletionThreadsRequested); 
      }
};

//---[ CAsyncQueue ]-----------------------------------------------------------
//
//
//  Description: 
//      FIFO queue that allows thread-throttling and async completion.  
//      Inherits from CAsyncQueueBase.
//  Hungarian: 
//      asyncq, pasyncq
//  
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
class CAsyncQueue : public CAsyncQueueBase
{
  public:
    typedef BOOL (*QCOMPFN)(PQDATA pqdItem, PVOID pvContext); //function type for Queue completion
    CAsyncQueue();
    ~CAsyncQueue();
    HRESULT HrInitialize(
                DWORD cMaxSyncThreads, 
                DWORD cItemsPerATQThread, 
                DWORD cItemsPerSyncThread, 
                PVOID pvContext,
                QCOMPFN pfnQueueCompletion,
                QCOMPFN pfnFailedItem,
                CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFailure,
                DWORD cMaxPendingAsyncCompletions = 0);

    HRESULT HrDeinitialize(CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown, 
                           CAQSvrInst *paqinst);

    HRESULT HrQueueRequest(PQDATA pqdata, BOOL fRetry = FALSE); //Queue request for processing
    void    StartThreadCompletionRoutine(BOOL fSync);  //Start point for worker threads
    void    RequestCompletionThreadIfNeeded();
    BOOL    fThreadNeededAndMarkWorkPending(BOOL fSync);
    virtual BOOL   fHandleCompletionFailure(PQDATA pqdata);
    void    StartRetry() {UnpauseQueue();RequestCompletionThreadIfNeeded();};
    virtual HRESULT HrMapFn(CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, PVOID pvContext);
    DWORD   cGetItemsPending() {return m_cItemsPending;};
 
    //
    //  "Pause" API
    //
    void    PauseQueue();
    void    UnpauseQueue();
    BOOL    fIsPaused() {return (ASYNC_QUEUE_STATUS_PAUSED & m_dwQueueFlags);};
    
    //
    //  Tells the queue about pending async completions, so it can be 
    //  intelligent about throttling.  As we hit the limit, we will 
    //  pause/unpause the queue
    //
    void    IncPendingAsyncCompletions();
    void    DecPendingAsyncCompletions();

    //
    //  Basic QAPI functionality
    //
    DWORD   cQueueAdminGetNumItems() {return m_cItemsPending;};
    DWORD   dwQueueAdminLinkGetLinkState();

  protected:
    CFifoQueue<PQDATA>  m_fqQueue;       //queue for items

    //Function called to handle item pulled off of queue
    QCOMPFN m_pfnQueueCompletion;

    //Function called to handle items that could not be called due to resource
    //failures (for example during MergeRetryQueue).
    QCOMPFN m_pfnFailedItem;
  
    //Function called to walk the queues when the completion function fails
    CFifoQueue<PQDATA>::MAPFNAPI m_pfnQueueFailure; 

    //Process the item at the head of the queue
    HRESULT HrProcessSingleQueueItem();

    //Handles callback for dropped data
    void HandleDroppedItem(PQDATA pqdItem);
};

//---[ CAsyncRetryQueue ]------------------------------------------------------
//
//
//  Description: 
//      Derived class of CAsyncQueue adds an additional queue to gracefully 
//      handle retry scenarios.
//
//      Messages are first placed in the normal retry queue,  If they fail, 
//      they are placed in a secondary retry queue, which will not be retried
//      until this queue is kicked by an external retry timer. 
//  Hungarian: 
//      asyncrq, pasyncrq
//  
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
class CAsyncRetryQueue : public CAsyncQueue<PQDATA, TEMPLATE_SIG>
{
  public:
    CAsyncRetryQueue();
    ~CAsyncRetryQueue();

    HRESULT HrDeinitialize(CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown, 
                           CAQSvrInst *paqinst);
    void    StartRetry()
    {
        MergeRetryQueue();
        CAsyncQueue<PQDATA, TEMPLATE_SIG>::StartRetry();
    };
    HRESULT HrQueueRequest(PQDATA pqdata, BOOL fRetry = FALSE); //Queue request for processing
    virtual BOOL       fHandleCompletionFailure(PQDATA pqdata);
    virtual HRESULT HrMapFn(CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, PVOID pvContext);
    DWORD   cGetItemsPendingRetry() {return m_cRetryItems;};

    //
    //  Basic QAPI functionality
    //
    DWORD   cQueueAdminGetNumItems() {return (m_cItemsPending+m_cRetryItems);};
    DWORD   dwQueueAdminLinkGetLinkState();
  protected:
    DWORD               m_dwRetrySignature;
    DWORD               m_cRetryItems;

    CFifoQueue<PQDATA>  m_fqRetryQueue;  //queue for items

    void MergeRetryQueue();
};

//-----------------------------------------------------------------------------
//
//  Queues for precat and prerouting are of this type.
//
//  Hungarian: pammq, pammq
//
//  Each object of this class is embedded into a CMailMsgAdminQueue object
//  which exposes admin interfaces, and applies admin commands to this class.
//------------------------------------------------------------------------------

typedef CAsyncRetryQueue<IMailMsgProperties *, ASYNC_QUEUE_MAILMSG_SIG>  CAsyncMailMsgQueueBase;
class CAsyncMailMsgQueue : 
    public CAsyncMailMsgQueueBase
{
  public:
    //Queues request & closes handles if total number of messages
    //in system is over the limit.
    HRESULT HrQueueRequest(IMailMsgProperties *pIMailMsgProperties, 
                           BOOL  fRetry, 
                           DWORD cMsgsInSystem);

    //Since we inherit from someone who implmenents this, assert so that 
    //a dev adding a new call later on, will use the version that 
    //closes handles
    HRESULT HrQueueRequest(IMailMsgProperties *pIMailMsgProperties, 
                           BOOL  fRetry = FALSE);
};

//---[ CAsyncRetryAdminMsgRefQueue ]-------------------------------------------
//
//
//  Description: 
//      Class that provides queue admin functionality on top of 
//      CAsyncRetryAdminMsgRefQueue.
//  Hungarian: 
//      aradmq, paradmq
//  
//-----------------------------------------------------------------------------
class CAsyncRetryAdminMsgRefQueue : 
    public IQueueAdminAction,
    public IQueueAdminQueue,
    public CAsyncRetryQueue<CMsgRef *, ASYNC_QUEUE_MSGREF_SIG>,
    public CBaseObject
{
  protected:
    DWORD       m_cbDomain;
    LPSTR       m_szDomain;
    DWORD       m_cbLinkName;
    LPSTR       m_szLinkName;
    GUID        m_guid;
    DWORD       m_dwID;
    CAQSvrInst *m_paqinst;
  public:
    CAsyncRetryAdminMsgRefQueue(LPCSTR szDomain, LPCSTR szLinkName, 
            const GUID *pguid, DWORD dwID, CAQSvrInst *paqinst);
    ~CAsyncRetryAdminMsgRefQueue();

  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj); 
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    //All of these objects are allocated as part CAQSvrInst... we can
    //add the assert below to make sure that someone does not relese it 
    //early
    STDMETHOD_(ULONG, Release)(void) 
        {_ASSERT(m_lReferences > 1); return CBaseObject::Release();};

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD(HrApplyActionToMessage)(
		IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
		BOOL *pfShouldDelete);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return QueryDefaultSupportedActions(pdwSupportedActions, 
                                            pdwSupportedFilterFlags);
    };
  public: //IQueueAdminQueue
    STDMETHOD(HrGetQueueInfo)(
        QUEUE_INFO *pliQueueInfo);

    STDMETHOD(HrGetQueueID)(
        QUEUELINK_ID *pQueueID);

};

//Define typical asyncq type for casting
typedef  CAsyncQueue<CMsgRef *, ASYNC_QUEUE_MSGREF_SIG>  ASYNCQ_TYPE;
typedef  ASYNCQ_TYPE *PASYNCQ_TYPE;

//---[ AsyncQueueAtqCompletion ]-----------------------------------------------
//
//
//  Description:
//      Atq completion routine.  This is slightly tricky since we cannot pass
//      a templated function to the ATQ context.  This is the one place that
//      templating breaks down, and we actually need to list all of the
//      supported PQDATA types.
//  Parameters:
//      pvContext   - ptr fo CAsyncQueue class
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//      3/8/99 - MikeSwa Added ASYNC_QUEUE_WORK_SIG
//
//----------------------------------------------------------------------------
inline VOID AsyncQueueAtqCompletion(PVOID pvContext, DWORD vbBytesWritten,
                             DWORD dwStatus, OVERLAPPED *pOverLapped)
{
    CAsyncQueueBase *pasyncqb = (PASYNCQ_TYPE) pvContext;
    DWORD dwTemplateSig = pasyncqb->m_dwTemplateSignature;
    DWORD dwQueueFlags = pasyncqb->m_dwQueueFlags;
    
    _ASSERT(ASYNC_QUEUE_SIG == pasyncqb->m_dwSignature);

    //Up total async thread count (only async threads visit this function)
    InterlockedIncrement((PLONG) &(pasyncqb->m_cTotalAsyncCompletionThreads));
    InterlockedDecrement((PLONG) &(pasyncqb->m_cCompletionThreadsRequested));
    InterlockedIncrement((PLONG) &(pasyncqb->m_cCurrentAsyncThreads));

    if (CAsyncQueueBase::ASYNC_QUEUE_STATUS_SHUTDOWN & dwQueueFlags)
    {
        //Do not access pasyncaq since we are shutting down
    }
    else if (ASYNC_QUEUE_MAILMSG_SIG == dwTemplateSig)
    {
        ((CAsyncQueue<IMailMsgProperties *, ASYNC_QUEUE_MAILMSG_SIG> *)pvContext)->StartThreadCompletionRoutine(FALSE);
    }
    else if (ASYNC_QUEUE_MSGREF_SIG == dwTemplateSig)
    {
        ((CAsyncQueue<CMsgRef *, ASYNC_QUEUE_MSGREF_SIG> *)pvContext)->StartThreadCompletionRoutine(FALSE);
    }
    else if (ASYNC_QUEUE_WORK_SIG == dwTemplateSig)
    {
        ((CAsyncQueue<CAsyncWorkQueueItem *, ASYNC_QUEUE_WORK_SIG> *)pvContext)->StartThreadCompletionRoutine(FALSE);
    }
    else
    {
        _ASSERT(0 && "Unregonized template sig... must be added to this function");
    }

    InterlockedDecrement((PLONG) &(pasyncqb->m_cCurrentAsyncThreads));
}

#endif //__ASYNCQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\atl.cpp ===
#include "stdafx.h"
#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\bitmap.h ===
//-----------------------------------------------------------------------------
//
//
//    File: bitmap.h
//
//    Description: Contains bitmap manipulation utilities
//
//    Author: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __bitmap_h__
#define __bitmap_h__

#include "cmt.h"

//---[ CMsgBitMap ]------------------------------------------------------------
//
//
//    Hungarian: mbmap, pmbmap
//
//    Provides a wrapper around the bitmaps used to indicate per recipient responsibility
//    and statistics.
//
//    Number of recipients is not stored with bitmaps, since there will be many bitmaps
//    per message. This can reduce memory usage nearly by half (in the case of < 32 recips).
//-----------------------------------------------------------------------------

class CMsgBitMap
{
private:
    DWORD        m_rgdwBitMap[1]; //if there are MORE than 32 recipients

    //private helper functions
    DWORD dwIndexToBitMap(DWORD dwIndex);
    
    static inline DWORD cGetNumDWORDS(DWORD cBits)
        {return((cBits + 31)/32);};
    
public:
    //overide new operator to allow for variable sized bitmaps
    void * operator new(size_t stIgnored, unsigned int cBits);
    
    CMsgBitMap(DWORD cBits);  //only zeros memory... can be done externally when there
                              //is a large array of bitmaps.
  
    //return the actual size of the bitmap with a given # of recips
    static inline size_t size(DWORD cBits) 
        {return (cGetNumDWORDS(cBits)*sizeof(DWORD));};

    //Simple logic checking for bitmaps
    BOOL    FAllClear(IN DWORD cBits);
    BOOL    FAllSet(IN DWORD cBits);

    //Test against a single other bit
    BOOL    FTest(IN DWORD cBits, IN CMsgBitMap *pmbmap);

    //Interlocked Test and set functionality
    BOOL    FTestAndSet(IN DWORD cBits, IN CMsgBitMap *pmbmap);
    
    //Set/Clear the bit corresponding to a given index on the bitmap
    HRESULT HrMarkBits(IN DWORD cBits,
                    IN DWORD cIndexes,  //# of indexes in array
                    IN DWORD *rgiBits,  //array of indexes to mark
                    IN BOOL  fSet);    //TRUE => set to 1, 0 otherwise

    //Generate a list of indexes represented by the bitmap
    HRESULT HrGetIndexes(IN  DWORD   cBits, 
                         OUT DWORD  *pcIndexes,     //# of indexes returned
                         OUT DWORD **prgdwIndexes); //array of indexes


    //Set self to logical OR of group
    HRESULT HrGroupOr(IN DWORD cBits,
                      IN DWORD cBitMaps,     //# of bitmaps passed in
                      IN CMsgBitMap **rgpBitMaps); //array of bitmap ptrs

    //If the description of the following is not immediately clear, I have
    //included a truth table with the implementation

    //Filter self against other bitmap-only keep bits set if NOT set in other
    HRESULT HrFilter(IN DWORD cBits, 
                     IN CMsgBitMap *pmbmap); //bitmap to filter against

    //Filters and sets filtered bits to 1 in other bitmap
    HRESULT HrFilterSet(IN DWORD cBits,
                        IN CMsgBitMap *pmbmap); //bitmap to filter and set

    //Sets bits that are 1 in self to 0 in other.  Checks to make sure that
    //self is a subset of setbits to other
    HRESULT HrFilterUnset(IN DWORD cBits,
                        IN CMsgBitMap *pmbmap); //bitmap to unset

};


#endif //__bitmap_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\cmt.h ===
//-----------------------------------------------------------------------------
//
//
//    File: cmt.h
//
//    Description:    
//      General Header file for the CMT objects
//
//    Owner: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _CMT_H_
#define _CMT_H_

//Comment out the following if you do not information printed out (ie running as
// a service).
#define CMT_CONSOLE_DEBUG

#include "aqincs.h"

//---[ EffectivePriority ]-----------------------------------------------------
//
//
//  Hungarian: pri
//
//  Effective Routing priority.  Allows standardf priorities to be adjusted
//  based on configuration (ie, message size, originator... etc)
//-----------------------------------------------------------------------------
typedef enum _EffectivePriority
{
//Priorities in order of importance          
//                      | hex | binary |
//                      ================
    eEffPriLow          = 0x0, //000    Standard low pri needs to map here
    eEffPriNormalMinus  = 0x1, //001
    eEffPriNormal       = 0x2, //010    Standard normal pri needs to map here
    eEffPriNormalPlus   = 0x3, //011
    eEffPriHighMinus    = 0x4, //100
    eEffPriHigh         = 0x5, //101    Standard high pri needs to map here
    eEffPriHighPlus     = 0x6, //110
    eEffPriMask         = 0x7  //111
} EffectivePriority, *PEffectivePriority;

typedef EffectivePriority   TEffectivePriority;  //to make Mahesh's life easier



//Besure to update Macros when constants are changed
#define fNormalPri(Pri)  (((EffectivePriority) (Pri)) && (((EffectivePriority) (Pri)) <= eEffPriNormalPlus))
#define fHighPri(Pri)    (((EffectivePriority) (Pri)) & 0x4)
#define fHighestPri(Pri) (((EffectivePriority) (Pri)) == eEffPriHighPlus)
#define NUM_PRIORITIES  7

//---[ enum LinkOptions ]------------------------------------------------------
//
//
//  Hungarian: lo, plo
//
//  Used to describe options available on per link operations
//-----------------------------------------------------------------------------
typedef enum  _LinkOptions
{
    eLinkDefault    = 0x00000000, //perform default action
    eLinkOnlySmall  = 0x00000001, //Do not return large messages
} LinkOptions, *PLinkOptions;

//---[ LinkQOSMask ]-----------------------------------------------------------
//
//  Quality of service bitmasks... used to describe what Routing QOS a message is 
//  eligible for.
//-----------------------------------------------------------------------------
typedef enum _LinkQOSMask
{
    LINK_QOS_MASK_NORMAL    = 0x00000001,  //normal QOS 
    LINK_QOS_MASK_PRI       = 0x00000002,  //high priority QOS 
    LINK_QOS_MASK_COST      = 0x00000004,  //monetary cost QOS
    LINK_QOS_MASK_SIZE      = 0x00000008,  //small message QOS
    LINK_QOS_MASK_INVALID   = 0xFFFFFFF0,  //invalid bits'n'pieces
} LinkQOSMask;

//enum specific macro (we will be passing as bitmasks, so we will have to cast
//and avoid normal type-checking)
#define _ASSERT_LINK_QOS_MASK(x) _ASSERT((x) && !(LINK_QOS_MASK_INVALID & (x)))

#endif // _CMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\bitmap.cpp ===
//-----------------------------------------------------------------------------
//
//
//    File: bitmap.cpp
//
//    Description: Contains code for implementation of bitmap functions
//
//    Owner: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "bitmap.h"
#include <dbgilock.h>

#define BITS_PER_DWORD  32

//Set up static masks for quick parsing
const DWORD   s_rgdwMasks[8] =
{
    0xF0000000,
    0x0F000000,
    0x00F00000,
    0x000F0000,
    0x0000F000,
    0x00000F00,
    0x000000F0,
    0x0000000F
};

//Used for fast conversion from index to bitmap
const DWORD   s_rgdwIndexMasks[32] =
{
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001
};

//Used to check for zero'd bitmaps with cBits does not fill up a DWORD
const DWORD   s_rgdwZeroMasks[32] =
{
    0x80000000, 0xC0000000, 0xE0000000, 0xF0000000,
    0xF8000000, 0xFC000000, 0xFE000000, 0xFF000000,
    0xFF800000, 0xFFC00000, 0xFFE00000, 0xFFF00000,
    0xFFF80000, 0xFFFC0000, 0xFFFE0000, 0xFFFF0000,
    0xFFFF8000, 0xFFFFC000, 0xFFFFE000, 0xFFFFF000,
    0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00, 0xFFFFFF00,
    0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0, 0xFFFFFFF0,
    0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE, 0xFFFFFFFF,
};

//---[ fInterlockedDWORDCompareExchange ]--------------------------------------
//
//
//  Description:
//      Provide an inline function to handle the type-checking, casts,
//      and comparison in DWORD chunks.
//  Parameters:
//      pdwDest     Destination to update
//      dwNewValue  Value to update with
//      dwCompare   Old value to check against
//  Returns:
//      TRUE if update succeeded
//
//-----------------------------------------------------------------------------
inline BOOL fInterlockedDWORDCompareExchange(LPDWORD pdwDest, DWORD dwNewValue,
                                             DWORD dwCompare)
{
    return(
        ((DWORD) InterlockedCompareExchange((PLONG)pdwDest,
            (LONG) dwNewValue, (LONG) dwCompare))
        == dwCompare);
}

//---[ CMsgBitMap::new ]----------------------------------------------------------
//
//
//  Description:
//      Overide the new operator to allow for the variable size of this class.
//      A good optimization would be to use the C-pool type stuff for the
//      90% case of 1 domain, and allocate the rest on the fly
//  Parameters:
//      cBits    the number of bits this message is being delivered to.
//  Returns:
//      -
//-----------------------------------------------------------------------------
void * CMsgBitMap::operator new(size_t stIgnored, unsigned int cBits)
{
    void    *pvThis = NULL;
    int      i = 0;

    _ASSERT(size(cBits) >= sizeof(DWORD));
    pvThis = pvMalloc(size(cBits));

    return (pvThis);
}

//---[ CMsgBitMap::CMsgBitMap ]------------------------------------------------
//
//
//  Description:
//      Class constructor.  Will zero memory for a bitmap that is not part of
//      a message reference
//  Parameters:
//      cBits - The number of bits in the bitmap
//  Returns:
//
//
//-----------------------------------------------------------------------------
CMsgBitMap::CMsgBitMap(DWORD cBits)
{
    DWORD   cDWORDs = cGetNumDWORDS(cBits);
    ZeroMemory(m_rgdwBitMap, cDWORDs*sizeof(DWORD));
}

//---[ CMsgBitMap::FAllClear ]-------------------------------------------------
//
//
//  Description:
//      Checks to see of all relevant bits (1st cBits) are 0
//  Parameters:
//      cBits the number of bits in the bitmap
//  Returns:
//      TRUE if all bits are 0, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FAllClear(DWORD cBits)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::FAllClear");
    BOOL    fResult = TRUE;
    DWORD   cDWORDs = cGetNumDWORDS(cBits) ;

    //verify all DWORD's by checking if 0
    for (DWORD i = 0; i < cDWORDs; i++)
    {
        if (m_rgdwBitMap[i] != 0x00000000)
        {
            fResult = FALSE;
            break;
        }
    }

    TraceFunctLeave();
    return fResult;
}

//---[ CMsgBitMap::FAllSet ]---------------------------------------------------
//
//
//  Description:
//      Checks to see of all relevant bits (1st cBits) are 1
//  Parameters:
//      cBits the number of bits in the bitmap
//  Returns:
//      TRUE if all bits are 1, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FAllSet(DWORD cBits)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::FAllClear");
    BOOL    fResult = TRUE;
    DWORD   cDWORDs = cGetNumDWORDS(cBits+1) -1;  //check all but last DWORD
    DWORD   iZeroIndex = cBits & 0x0000001F;

    //verify all DWORD's by checking if 0
    for (DWORD i = 0; i < cDWORDs; i++)
    {
        if (m_rgdwBitMap[i] != 0xFFFFFFFF)
        {
            fResult = FALSE;
            goto Exit;  //if we hit the iZeroIndex clause, we might assert
        }
    }

    _ASSERT(i || iZeroIndex || !fResult); //We must check at least 1 DWORD

    if (iZeroIndex)
    {
        iZeroIndex--; //we cBits is a count... our index starts at 0.
        //last DWORD should be a subset of the ZeroMask
        _ASSERT(s_rgdwZeroMasks[iZeroIndex] ==
                (s_rgdwZeroMasks[iZeroIndex] | m_rgdwBitMap[cDWORDs]));

        if (s_rgdwZeroMasks[iZeroIndex] != m_rgdwBitMap[cDWORDs])
            fResult = FALSE;
    }

  Exit:
    TraceFunctLeave();
    return fResult;
}

//---[ CMsgBitMap::HrMarkBits ]------------------------------------------------
//
//
//    Description:
//      Marks the bits (as 0 or 1) that corresponds to the given indexes
//
//    Parameters:
//      IN DWORD cBits
//      IN DWORD cIndexes   # of indexes in array
//      IN DWORD rgiBits    SORTED array of indexes of bits to mark
//      IN BOOL  fSet       TRUE => set to 1, 0 otherwise
//    Returns:
//      S_OK on success
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrMarkBits(IN DWORD cBits, IN DWORD cIndexes,
                               IN DWORD *rgiBits, IN BOOL fSet)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrMarkBits");
    HRESULT hr = S_OK;
    DWORD   cDWORDs = cGetNumDWORDS(cBits);
    DWORD   dwTmp;
    DWORD   dwIndex = 0x00000000;
    DWORD   i;
    DWORD   iCurrentIndex = 0;     //current index in rgiBits
    DWORD   iCurrentLimit = BITS_PER_DWORD -1; //current limit of 32 bit range for values of rgiBits

    _ASSERT(cIndexes);
    _ASSERT(cIndexes <= cBits);

    for (i = 0; i < cDWORDs; i++)
    {
        dwIndex = 0x00000000;
        while ((iCurrentIndex < cIndexes) &&
                (rgiBits[iCurrentIndex] <= iCurrentLimit))
        {
            _ASSERT(rgiBits[iCurrentIndex] < cBits);
            dwIndex |= s_rgdwIndexMasks[(rgiBits[iCurrentIndex] % BITS_PER_DWORD)];
            iCurrentIndex++;
        }

        if (dwIndex != 0x00000000) //don't perform costly interlocked op if we don't need to
        {
            if (fSet) //set bit
            {
              SpinTry1:
                dwTmp = m_rgdwBitMap[i];
                if (!fInterlockedDWORDCompareExchange(&(m_rgdwBitMap[i]), (dwIndex | dwTmp), dwTmp))
                    goto SpinTry1;
            }
            else  //clear bit
            {
              SpinTry2:
                dwTmp = m_rgdwBitMap[i];
                if (!fInterlockedDWORDCompareExchange(&(m_rgdwBitMap[i]), ((~dwIndex) & dwTmp), dwTmp))
                    goto SpinTry2;
            }
        }

        if (iCurrentIndex >= cIndexes)
            break; //don't do more work than we have to

        iCurrentLimit += BITS_PER_DWORD;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrGetIndexes ]----------------------------------------------
//
//
//  Description:
//      Generates an array of indexes represented by the bitmap
//  Parameters:
//      IN  DWORD   cBits
//      OUT DWORD  *pcIndexes     //# of indexes returned
//      OUT DWORD **prgdwIndexes  //array of indexes
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if memory allocation fails
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrGetIndexes(IN DWORD cBits, OUT DWORD *pcIndexes,
                         OUT DWORD **prgdwIndexes)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrGetIndexes");
    HRESULT  hr         = S_OK;
    DWORD   *pdwIndexes = NULL;
    DWORD    dwIndex    = 0;
    DWORD    dwIndexOffset = 0;
    DWORD    cDWORDs = cGetNumDWORDS(cBits);
    DWORD    cdwAllocated = 0;
    DWORD    cCurrentIndexes = 0;
    DWORD    i = 0;
    DWORD   *pdwTmp = NULL;

    //$$REVIEW: How do we balance CPU usage vs memory usage here?  We know the
    //  max size of the output array is cBits DWORDS, but in actuality it can
    //  little as 1 DWORD.  Prognosticating the actual size accurately would
    //  require scanning the bitmap multiple times.
    //
    // Easy(studpid) way: Count bits, allocate array, recount and add indexes to array
    //
    // Idea #1: Allocate in chunks of 32 DWORDS, Realloc if we run out  Should
    //  not have to worry about reallocing for 90% of the cases.
    //
    // Idea #2: Add some stats to this class, and run some stress tests in debug
    //  mode, and develop a heuristic that limits reallocs and such (ie alloc
    //  lg(cBits) to start with).
    //
    // Idea #3: Continue with Idea #2, but add self-tuning stats
    Assert(pcIndexes);
    Assert(prgdwIndexes);

    pdwIndexes = (DWORD *) pvMalloc(BITS_PER_DWORD*sizeof(DWORD));
    if (pdwIndexes == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    cdwAllocated = BITS_PER_DWORD;

    cCurrentIndexes = 0;

    for (i = 0; i < cDWORDs; i++)
    {
        dwIndex = 0;
        while (dwIndex < BITS_PER_DWORD)
        {
            //can use mask to check if possible
            if ((!(dwIndex & 0x00000003)) && //if %4 == 0
                !(s_rgdwMasks[dwIndex/4] & m_rgdwBitMap[i]))
            {
                dwIndex += 4; //Can skip ahead 4
            }
            else
            {
                if (s_rgdwIndexMasks[dwIndex] & m_rgdwBitMap[i])  //Found it!
                {
                    //Write index and check if re-allocation is needed
                    if (cCurrentIndexes >= cdwAllocated)
                    {
                        cdwAllocated += BITS_PER_DWORD;
                        pdwTmp = (DWORD *) pvRealloc(pdwIndexes, cdwAllocated*sizeof(DWORD));
                        if (NULL == pdwTmp)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                        }
                        pdwIndexes = pdwTmp;
                    }
                    *(pdwIndexes + cCurrentIndexes) = (dwIndex + dwIndexOffset);
                    cCurrentIndexes++;
                }
                dwIndex++;
            }
        }

        //Use dwIndexOffset to break down index generation into 32-bit chunks
        dwIndexOffset += BITS_PER_DWORD;
    }

    *prgdwIndexes = pdwIndexes; //set OUT value
    *pcIndexes = cCurrentIndexes;

  Exit:

    if (FAILED(hr))
    {
        *prgdwIndexes = NULL;
        *pcIndexes = 0;
        FreePv(pdwIndexes);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrGroupOr ]-------------------------------------------------
//
//
//  Description:
//      Sets thir bitmap to the logical OR of the given list of bitmaps. This
//      is used to prepare a bitmap that represents the domains being delivered
//      over a list (or destmsg queue).  Current bitmap is NOT cleared prior to
//      this operation.
//  Parameters:
//      IN DWORD cBits  number of bits in bitmap
//      IN DWORD cBitMaps number of bitmaps in array
//      IN CMsgBitMap **rgpBitMaps array of bitmaps to OR
//  Returns:
//      S_OK on success
//
// Note: This is NOT thread safe.. it's intended use is only for tmp bitmaps
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrGroupOr(IN DWORD cBits, IN DWORD cBitMaps,
                      IN CMsgBitMap **rgpBitMaps)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrGroupOr");
    HRESULT hr = S_OK;
    DWORD   cDWORDs = cGetNumDWORDS(cBits);
    DWORD   i, j;

    for (i = 0; i < cDWORDs; i++)
    {
        for (j = 0; j < cBitMaps; j++)
        {
            Assert(rgpBitMaps[j]);
            m_rgdwBitMap[i] |= rgpBitMaps[j]->m_rgdwBitMap[i];
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrFilter ]--------------------------------------------------
//
//
//  Description:
//      Filters the current bitmap by setting only the bits that are SET in
//      in and UNSET in the given bitmap..
//      Performs a logical AND with the complement of the given bitmap
//  Parameters:
//      IN DWORD cBits          # of bits in bitmap
//      IN CMsgBitMap *pmbmap   bitmap to filter against
//  Returns:
//      S_OK on success
//
//  Truth Table:
//      A => this bitmap
//      B => pmbmap
//
//      A B | A'B'
//     ===========
//      0 0 | 0 0
//      0 1 | 0 1
//      1 0 | 1 0
//      1 1 | 0 1
//
// Note: This is NOT thread safe.. it's intended use is only for tmp bitmaps
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrFilter(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrFilter");
    HRESULT hr = S_OK;
    DWORD   cDWORDs = cGetNumDWORDS(cBits);

    Assert(pmbmap);

    for (DWORD i = 0; i < cDWORDs; i++)
    {
        m_rgdwBitMap[i] &= ~(pmbmap->m_rgdwBitMap[i]);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrFilterSet ]-----------------------------------------------
//
//
//  Description:
//      Filters the current bitmap and sets those bits to 1 in the given
//      bitmap.  Unlike HrFilter, this modifies the given bitmap and does so
//      in a thread-safe manner.
//  Parameters:
//      IN DWORD cBits          # of bits in bitmap
//      IN CMsgBitMap *pmbmap   bitmap to filter against
//  Returns:
//      S_OK on success
//
//  Truth Table:
//      A => this bitmap
//      B => pmbmap
//
//      A B | A'B'
//     ===========
//      0 0 | 0 0
//      0 1 | 0 1
//      1 0 | 1 1
//      1 1 | 0 1
//
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrFilterSet(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrFilterSet");
    Assert(pmbmap);

    HRESULT hr         = S_OK;
    DWORD   cDWORDs    = cGetNumDWORDS(cBits);
    DWORD   dwSelfNew;
    DWORD   dwOtherNew;
    DWORD   dwOtherOld;
    DWORD   i;
    BOOL    fDone      = FALSE;

    for (i = 0; i < cDWORDs; i++)
    {
        fDone = FALSE;
        dwSelfNew  = m_rgdwBitMap[i];
        while (!fDone)
        {
            dwOtherNew = pmbmap->m_rgdwBitMap[i];
            dwOtherOld = dwOtherNew;

            dwSelfNew &= ~dwOtherNew;  //filter
            dwOtherNew ^= dwSelfNew;   //set

            if (fInterlockedDWORDCompareExchange(&(pmbmap->m_rgdwBitMap[i]),
                        dwOtherNew, dwOtherOld))
            {
                fDone = TRUE;
                m_rgdwBitMap[i] = dwSelfNew;
            }
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgBitMap::HrFilterUnset ]-----------------------------------------------
//
//
//  Description:
//      Uses the current bitmap and sets those bits that are 1 on it to 0 in the
//      given bitmap.  Unlike HrFilterSet, only the pmbmap is modified.
//
//      This also checks that all bits that are 1 in self are also 1 in the
//      other... ie that the 1 bits in this are a subset of pmbmap
//  Parameters:
//      IN DWORD cBits          # of bits in bitmap
//      IN CMsgBitMap *pmbmap   bitmap to filter against
//  Returns:
//      S_OK on success
//
//  Truth Table:
//      A => this bitmap
//      B => pmbmap
//
//      A B | A'B'
//     ===========
//      0 0 | 0 0
//      0 1 | 0 1
//      1 0 | x x  - undefined (will assert)
//      1 1 | 1 0
//
//-----------------------------------------------------------------------------
HRESULT CMsgBitMap::HrFilterUnset(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgBitMap::HrFilterUnset");
    Assert(pmbmap);

    HRESULT hr         = S_OK;
    DWORD   cDWORDs    = cGetNumDWORDS(cBits);
    BOOL    fDone      = FALSE;
    DWORD   i;
    DWORD   dwOtherNew;
    DWORD   dwOtherOld;

    for (i = 0; i < cDWORDs; i++)
    {
        fDone = FALSE;

        while (!fDone)
        {
            dwOtherNew = pmbmap->m_rgdwBitMap[i];
            dwOtherOld = dwOtherNew;

            if (m_rgdwBitMap[i] & ~dwOtherNew)
            {
                //this bitmap is NOT a subset of the given bitmap
                _ASSERT(0); //caller's mistake
                hr = E_FAIL;
                goto Exit;
            }

            dwOtherNew ^= m_rgdwBitMap[i];   //unset

            if (fInterlockedDWORDCompareExchange(&(pmbmap->m_rgdwBitMap[i]),
                        dwOtherNew, dwOtherOld))
            {
                fDone = TRUE;
            }
        }
    }


  Exit:
    TraceFunctLeave();
    return hr;
}


//---[ CMsgBitMap::FTestAndSet ]-----------------------------------------------
//
//
//  Description: 
//      An Interlocked function to test and set a bit on the this bit map.  
//      Looks for the bit that is set in the given bitmap, if that bit is also
//      1 in this bitmap, returns FALSE.  If that bit is 0, it sets it to 1,
//      and returns TRUE.
//      
//      NOTE: Results are UNDEFINED if there is more than 1 bit set in pmbmap.
//  Parameters:
//      cBits       # of bits in bitmap
//      pmbmap      Bitmap to check against
//  Returns:
//      TRUE if the corresponding bit was 0 (and is now set to 1)
//      FALSE if the corresponding bit was already1
//  History:
//      11/8/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FTestAndSet(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    BOOL    fRet      = FALSE;
    DWORD   cDWORDs   = cGetNumDWORDS(cBits);
    BOOL    fDone     = FALSE;
    DWORD   dwThisNew = 0;
    DWORD   dwThisOld = 0;
    DWORD   i         = 0;
    
    for (i = 0; i < cDWORDs; i++)
    {

        if (pmbmap->m_rgdwBitMap[i])
        {
            //We've hit the bit in the given bitmap

            //See if bit is already set
            if (pmbmap->m_rgdwBitMap[i] & m_rgdwBitMap[i])
                break;

            while (!fDone)
            {
                dwThisOld = m_rgdwBitMap[i];
                dwThisNew = dwThisOld | pmbmap->m_rgdwBitMap[i];

                //See if another thread has set it
                if (dwThisOld & pmbmap->m_rgdwBitMap[i])
                    break;

                //Only 1 bit should be set on given bitmap
                _ASSERT((dwThisOld | pmbmap->m_rgdwBitMap[i]) == 
                        (dwThisOld ^ pmbmap->m_rgdwBitMap[i]));

                //Try to set bit
                if (fInterlockedDWORDCompareExchange(&(m_rgdwBitMap[i]),
                            dwThisNew, dwThisOld))
                {
                    fDone = TRUE;
                    fRet = TRUE;
                }
            }

            break;
        }
    }

    return fRet;
}

//---[ CMsgBitMap::FTest ]-----------------------------------------------------
//
//
//  Description: 
//      Tests this bitmap against a single bit in the given bitmap
//      NOTE: Results are UNDEFINED if there is more than 1 bit set in pmbmap.
//  Parameters:
//      cBits       # of bits in bitmap
//      pmbmap      Bitmap to check against
//  Returns:
//      TRUE if the corresponding bit is 1
//      FALSE if the corresponding bit is 0
//  History:
//      11/8/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CMsgBitMap::FTest(IN DWORD cBits, IN CMsgBitMap *pmbmap)
{
    BOOL    fRet      = FALSE;
    DWORD   cDWORDs   = cGetNumDWORDS(cBits);
    DWORD   i         = 0;
    
    for (i = 0; i < cDWORDs; i++)
    {
        //See if we've hit the bit in the given bitmap
        if (pmbmap->m_rgdwBitMap[i])
        {
            //See if bit is already set
            if (pmbmap->m_rgdwBitMap[i] & m_rgdwBitMap[i])
                fRet = TRUE;

            break;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\asyncq.inl ===
//-----------------------------------------------------------------------------
//
//
//  File: asyncq.inl
//
//  Description:  Implementation of templated CAsyncQueue class.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/17/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __ASYNCQ_INL__
#define __ASYNCQ_INL__

#include "asyncq.h"
#include "testmapfn.h"
#include "fifoqimp.h"
#include "aqinst.h"


//---[ CAsyncQueueBase::CAsyncQueueBase ]--------------------------------------
//
//
//  Description:
//      Default constructor for CAsyncQueueBase class
//  Parameters:
//      dwTemplateSignature     - Signature used to identify the type of
//                                templated super class this is associated with
//                                when an ATQ completion routine is called
//  Returns:
//      -
//  History:
//      7/18/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAsyncQueueBase::CAsyncQueueBase(DWORD dwTemplateSignature)
{
    m_dwSignature = ASYNC_QUEUE_SIG;
    m_dwTemplateSignature = dwTemplateSignature;
    m_cMaxSyncThreads = 0;
    m_cMaxAsyncThreads = 0;
    m_cCurrentSyncThreads = 0;
    m_cCurrentAsyncThreads = 0;
    m_cItemsPending = 0;
    m_cItemsPerATQThread = 0;
    m_cItemsPerSyncThread = 0;
    m_lUnscheduledWorkItems = 0;
    m_cCurrentCompletionThreads = 0;
    m_cCompletionThreadsRequested = 0;
    m_dwQueueFlags = 0;
    m_pvContext = NULL;
    m_pAtqContext = NULL;
    m_hAtqHandle = INVALID_SOCKET;
    m_cTotalAsyncCompletionThreads = 0;
    m_cTotalSyncCompletionThreads = 0;
    m_cTotalShortCircuitThreads = 0;
    m_cPendingAsyncCompletions = 0;
    m_cMaxPendingAsyncCompletions = 0;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::CAsyncQueue<PQDATA, TEMPLATE_SIG> ]--
//
//
//  Description:
//      Default constructor for CAsyncQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncQueue<PQDATA, TEMPLATE_SIG>::CAsyncQueue<PQDATA, TEMPLATE_SIG>() :
    CAsyncQueueBase(TEMPLATE_SIG)
{
    m_pfnQueueCompletion = NULL;
    m_pfnQueueFailure = NULL;
    m_pfnFailedItem = NULL;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::~CAsyncQueue<PQDATA, TEMPLATE_SIG> ]--
//
//
//  Description:
//      Default desctructor for CAsyncQueue.  Call Queue-mapping function to
//      to clear out the queue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncQueue<PQDATA, TEMPLATE_SIG>::~CAsyncQueue<PQDATA, TEMPLATE_SIG>()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::~CAsyncQueue<PQDATA, TEMPLATE_SIG>");
    HRESULT hr = S_OK;
    DWORD   cItems = 0;

    //
    //  If this is off, then we may not actually be processing anything
    //  (if we have hit the limit).  
    //
    _ASSERT(!m_cPendingAsyncCompletions);

    hr = m_fqQueue.HrMapFn(HrClearQueueMapFn, m_pvContext, &cItems);
    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ERROR: Unable to Cleanup CAsyncQueue - hr 0x%08X", hr);
    else
        DecrementPendingAndWorkCount(-((LONG) cItems));

    if (m_pAtqContext)
    {
        //Freeing context will close handle
        AtqFreeContext(m_pAtqContext, FALSE);
    }

    TraceFunctLeave();
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrInitialize ]-----------------------
//
//
//  Description:
//      Initializes CAsyncQueue with the neccessary information
//  Parameters:
//      cMaxSyncThreads     The maximum # of threads that will be "stolen" from
//                          the enqueuing threads and used to process items
//                          from the front of the queue
//      cItemsPerATQThread  Max # of items an ATQ thread will process from the
//                          front of the queue before being released
//      cItemsPerSyncThread Max # of items a stolen sync thread will process
//                          from the fron of the queeu before being released
//      pvContext           Context pass to completion routines and queue-map
//                          functions (can be NULL)
//      pfnQueueCompletion  Function called to process a single item from
//                          the front of the queue.
//      pfnFailedItem       Function called if an internal resource failure
//                          prevents an item from being queued or requeued
//      pfnQueueFailure     Function called to walk the queues when the
//                          completion function fails
//
//  Note:
//      Queue completion functino has the following prototype
//              BOOL (*QCOMPFN)(PQDATA pqData, PVOID pvContext)
//      Returns TRUE if the item has been handles
//              FALSE if the item needs to be requeued
//
//  Returns:
//      S_OK on success
//      E_INVALIDARG if the params are invalid:
//          cItemsPerThread is 0
//          pfnQueueCompletion is NULL
//  History:
//      7/17/98 - MikeSwa Created
//      2/3/99 - MikeSwa Added pfnFailedItem
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrInitialize(
                DWORD cMaxSyncThreads,
                DWORD cItemsPerATQThread,
                DWORD cItemsPerSyncThread,
                PVOID pvContext,
                QCOMPFN pfnQueueCompletion,
                QCOMPFN pfnFailedItem,
                CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFailure,
                DWORD cMaxPendingAsyncCompletions)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrInitialize");
    HRESULT hr = S_OK;

    ThreadPoolInitialize();

    if (!cItemsPerATQThread || !cItemsPerSyncThread || !pfnQueueCompletion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    m_cMaxSyncThreads = cMaxSyncThreads;
    m_cItemsPerATQThread = (DWORD) cItemsPerATQThread;
    m_cItemsPerSyncThread = (DWORD) cItemsPerSyncThread;
    _ASSERT(m_cItemsPerATQThread > 0);
    m_pvContext = pvContext;
    m_pfnFailedItem = pfnFailedItem;
    m_pfnQueueCompletion = pfnQueueCompletion;
    m_pfnQueueFailure = pfnQueueFailure;
    m_cMaxPendingAsyncCompletions = cMaxPendingAsyncCompletions;
    //Create a dummy socket to handle async completion
    m_hAtqHandle = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == m_hAtqHandle)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        ErrorTrace((LPARAM) this, "ERROR socket() failed - hr 0x%08X", hr);
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        goto Exit;
    }

    //associate socket handle with ATQ
    if (!AtqAddAsyncHandle(&m_pAtqContext, NULL, this,
            AsyncQueueAtqCompletion, INFINITE, (HANDLE) m_hAtqHandle))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "ERROR AtqAddAsyncHandle failed - hr 0x%08X", hr);
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        goto Exit;
    }

  Exit:
    if (FAILED(hr))
        ThreadPoolDeinitialize();

    TraceFunctLeave();
    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize ]---------------------
//
//
//  Description:
//      Walks queues with given function for shutdown
//  Parameters:
//      pfnQueueShutdown    Queue-mapping function called on shutdown to
//                          clean queues.  If NULL, it will substitute
//                          HrClearQueueMapFn which walks the queues and
//                          releases all PQDATA in it
//      paqinst             Shutdown context with server stop hint function
//  Returns:
//      S_OK on success
//  History:
//      7/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize(
                              CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown,
                              CAQSvrInst *paqinst)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize");
    HRESULT hr = S_OK;
    _ASSERT(paqinst);
    DWORD   cItems = 0;

    //set shutdown bit
    dwInterlockedSetBits(&m_dwQueueFlags, ASYNC_QUEUE_STATUS_SHUTDOWN);

    //wait until all requested threads have returned
    while (m_cCurrentCompletionThreads || m_cCompletionThreadsRequested)
    {
        if (paqinst)
            paqinst->ServerStopHintFunction();
        Sleep(1000);
    }

    //map shutdown function
    hr = m_fqQueue.HrMapFn(pfnQueueShutdown, paqinst, &cItems);
    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ERROR: Unable to Cleanup CAsyncQueue - hr 0x%08X", hr);
    else
        DecrementPendingAndWorkCount(-((LONG)cItems));

    ThreadPoolDeinitialize();
    TraceFunctLeave();
    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest ]---------------------
//
//
//  Description:
//      Queues request for async completion.
//  Parameters:
//      pqdata          Data to pass to completion function
//      fRetry          TRUE => Put item at front of queue (and don't use this
//                              thread to process it).
//                      FALSE => Queue normaly
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if queue-related resources could not be allocated
//  History:
//      7/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(PQDATA pqdata,
                                                          BOOL fRetry)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest");
    HRESULT hr = S_OK;
    DWORD   cCurrentSyncThreads;

    _ASSERT(m_pfnQueueCompletion);

    cCurrentSyncThreads = InterlockedIncrement((PLONG) &m_cCurrentSyncThreads);

    //If we are shutting down... do not bother to queue the message
    if (ASYNC_QUEUE_STATUS_SHUTDOWN & m_dwQueueFlags)
        goto Exit;

    IncrementPendingAndWorkCount();
    //Only enqueue if there are others waiting
    if (fRetry ||  (m_cItemsPending > 1) || 
        (m_cMaxSyncThreads < cCurrentSyncThreads) || fIsPaused())
    {
        //Enqueue data
        if (fRetry && g_fRetryAtFrontOfAsyncQueue)
            hr = m_fqQueue.HrRequeue(pqdata);
        else
            hr = m_fqQueue.HrEnqueue(pqdata);

        if (FAILED(hr))
        {
            DecrementPendingAndWorkCount();
            ErrorTrace((LPARAM) this, "ERROR: Unable to queue item for async handling - hr 0x%08X", hr);
            goto Exit;
        }

        //see if we can steal this thread thread to process queue entries
        //Only steal a thread if the following conditions are met:
        //  - We have not exceeded our sync thread limit
        //  - There are no async threads that could be doing the work
        //  - We are not retrying something
        if (!fRetry && !fIsPaused() &&
            (m_cMaxSyncThreads >= cCurrentSyncThreads) &&
            !m_cCurrentAsyncThreads && !m_cCompletionThreadsRequested)
        {
            //Make sure there is work to be done
            if (fThreadNeededAndMarkWorkPending(TRUE))
            {
                //Steal thread
                StartThreadCompletionRoutine(TRUE);
            }
        }
    }
    else
    {
        //Steal this thread thread to proccess this item w/o hitting queue
        DecrementPendingAndWorkCount();
        InterlockedIncrement((PLONG) &m_cTotalShortCircuitThreads);

        //Process Item & handle failure case
        if (!m_pfnQueueCompletion(pqdata, m_pvContext))
        {
            fHandleCompletionFailure(pqdata);
        }
    }

    //Always make sure there are enough threads to do the work (unless we are retrying)
    if (!fRetry)
        RequestCompletionThreadIfNeeded();

  Exit:
    InterlockedDecrement((PLONG) &m_cCurrentSyncThreads);
    return hr;
    TraceFunctLeave();
}


//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::ProcessSingleQueueItem ]-------------
//
//
//  Description:
//      Processes a single item at the head of the queue.  All failures need
//      to be handled internally
//  Parameters:
//      -
//  Returns:
//      SUCCEEDED(hr)) on success and we should continue
//      AQUEUE_E_QUEUE_EMPTY when there are no more items to process
//      E_FAIL if the completion call failed
//      Error code from HrDequeue on other failure.
//  History:
//      7/17/98 - MikeSwa Created
//      2/3/2000 - MikeSwa Modified to return an HRESULT
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrProcessSingleQueueItem()
{
    HRESULT hr = S_OK;
    PQDATA  pqdata = NULL;
    DWORD   cItemsLeft = 0;
    BOOL    fSucceeded = TRUE;

    hr = m_fqQueue.HrDequeue(&pqdata);
    if (SUCCEEDED(hr))
    {
        DecrementPendingAndWorkCount();

        //We have data item - now process it
        fSucceeded = m_pfnQueueCompletion(pqdata, m_pvContext);

        if (fSucceeded || fHandleCompletionFailure(pqdata))
        {
            //Request another thread if
            // - we had at least 1 success.
            // - handle failure told use to continue
            RequestCompletionThreadIfNeeded();
            
            //If fHandleCompletionFailure said we succeeded, then continue
            fSucceeded = TRUE;

        }
        pqdata->Release();
    }

    //
    //  If the dequeue succeeded but the completion failed, then return E_FAIL
    //
    if (!fSucceeded && (SUCCEEDED(hr)))
        hr = E_FAIL;

    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::StartThreadCompletionRoutine ]-------
//
//
//  Description:
//      Starting point to completion threads.  Each thread will attempt to
//      process m_cItemsPerATQThread items from the front of the queue
//  Parameters:
//      fSync   TRUE if a sync thread, FALSE... this is an ATQ thread
//  Returns:
//      -
//  History:
//      7/17/98 - MikeSwa Created
//      2/3/2000 - MikeSwa Modified to fix window that would leave items
//                  "stranded" in queue.
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::StartThreadCompletionRoutine(BOOL fSync)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncQueue::StartThreadCompletionRoutine");
    DWORD   cItemsToProcess = (DWORD) (fSync ? m_cItemsPerSyncThread: m_cItemsPerATQThread);
    HRESULT hr = S_OK;

    InterlockedIncrement((PLONG) &m_cCurrentCompletionThreads);

    if (fSync)
        InterlockedIncrement((PLONG) &m_cTotalSyncCompletionThreads);

    //process items until we fail or are done
    while (cItemsToProcess && SUCCEEDED(hr))
    {
        hr = HrProcessSingleQueueItem();

        //
        // If we have been paused, we should stop processing immediately
        //
        if (fIsPaused())
            break;
    }

    //Increment work by amount not done
    if (cItemsToProcess)
        InterlockedExchangeAdd(&m_lUnscheduledWorkItems, (LONG) cItemsToProcess);

    InterlockedDecrement((PLONG) &m_cCurrentCompletionThreads);

    //
    //  If we are quiting because the queue is empty... make sure that we check
    //  if any threads need to be allocated *after* resetting 
    //  m_lUnscheduledWorkItems
    //
    if (AQUEUE_E_QUEUE_EMPTY == hr)
        RequestCompletionThreadIfNeeded();
    
    TraceFunctLeave();
}


//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::fThreadNeededAndMarkWorkPending ]----
//
//
//  Description:
//      Determines if another worker thread is needed, and adjusts
//      m_lUnscheduledWorkItems & m_cCompletionThreadsRequested
//      to relect the fact that another thread will
//      be requested to do the work. Callee is repsonsible for determining
//      if a thread can be allocated
//  Parameters:
//      fSync   TRUE if checking for a sync thread, FALSE... checking for an ATQ thread
//  Returns:
//      TRUE if another thread is needed (and member values adjusted accordingly)
//      FALSE if another thread is not needed to do work
//  History:
//      7/18/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL CAsyncQueue<PQDATA, TEMPLATE_SIG>::fThreadNeededAndMarkWorkPending(BOOL fSync)
{
    if (ASYNC_QUEUE_STATUS_SHUTDOWN & m_dwQueueFlags)
    {
        _ASSERT(!fSync && "CAQSvrInst should not call now!!!");
        return FALSE;
    }
    else if (m_lUnscheduledWorkItems > 0)
    {
        //
        //  Make sure that our pending work makes sense.  This value should
        //  be at *most* the number of items in the queue
        //
        _ASSERT(m_lUnscheduledWorkItems <= (LONG) m_cItemsPending);

        //adjust work expected and return TRUE
        InterlockedExchangeAdd(&m_lUnscheduledWorkItems,
                -(fSync ? m_cItemsPerSyncThread : m_cItemsPerATQThread));

        return TRUE;
    }
    else 
    {
        return FALSE;
    }
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::RequestCompletionThreadIfNeeded ]----
//
//
//  Description:
//      Requests a queue completion thread if needed.  Uses ATQ and handle
//      allocated to POQS for another thread.  Makes sure that we do not
//      exceed the max # of async threads.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/18/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::RequestCompletionThreadIfNeeded()
{
    DWORD cThreadsRequested = m_cCompletionThreadsRequested;
    
    //
    //  If we are paused, do not ask for new threads.
    //
    if (fIsPaused())
        return;

    if (m_cMaxAsyncThreads > (cThreadsRequested + m_cCurrentAsyncThreads))
    {
        if (fThreadNeededAndMarkWorkPending(FALSE))
        {
            cThreadsRequested = InterlockedIncrement((PLONG) &m_cCompletionThreadsRequested);
            if (m_cMaxAsyncThreads >= (cThreadsRequested + m_cCurrentAsyncThreads))
            {
                AtqPostCompletionStatus(m_pAtqContext, 0);
            }
            else
            {
                //cleanup
                InterlockedExchangeAdd(&m_lUnscheduledWorkItems, m_cItemsPerATQThread);
                InterlockedDecrement((PLONG) &m_cCompletionThreadsRequested);
            }
        }
    }
}


//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure ]------------
//
//
//  Description:
//      Called when async completion function returns false... handles requeuing
//      data and record-keeping.  Needs to handle the following:
//  Parameters:
//      pqdata      - Data that triggered failure
//  Returns:
//      -
//  History:
//      7/18/98 - MikeSwa Created
//      8/14/98 - MikeSwa Modified to add failure handling
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL CAsyncQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure(PQDATA pqdata)
{
    HRESULT hr;
    DWORD   cItemsRemoved = 0;

    if (ASYNC_QUEUE_STATUS_SHUTDOWN & m_dwQueueFlags)
        return FALSE;

    if (g_fRetryAtFrontOfAsyncQueue)
        hr = m_fqQueue.HrRequeue(pqdata);
    else
        hr = m_fqQueue.HrEnqueue(pqdata);

    if (SUCCEEDED(hr)) 
    {
        IncrementPendingAndWorkCount();
    }
    else
        HandleDroppedItem(pqdata);


    //call failure routine (if present)
    if (m_pfnQueueFailure)
    {
        hr = m_fqQueue.HrMapFn(m_pfnQueueFailure, m_pvContext, &cItemsRemoved);
        if (SUCCEEDED(hr))
        {
            //Adjust appropriate counters
            DecrementPendingAndWorkCount(-((LONG)cItemsRemoved));
        }
    }

    return FALSE;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HandleDroppedItem ]------------------
//
//
//  Description: 
//      Handles a dropped PQDATA by calling the callback provided at start
//      up
//  Parameters:
//      pqData
//  Returns:
//
//  History:
//      2/3/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::HandleDroppedItem(PQDATA pqData)
{
    if (m_pfnFailedItem)
        m_pfnFailedItem(pqData, m_pvContext);
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrMapFn ]----------------------------
//
//
//  Description: 
//      Calls a function on every message in the queue
//  Parameters:
//      IN  pfnQueueFn      Function to call for every message
//      IN  pvContext       Context passed to completion function
//  Returns:
//      S_OK on success
//      Error code from CFifoQueue<PQDATA>::HrMapFn
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrMapFn(
                                      CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, 
                                      PVOID pvContext)
{
    DWORD cItems = 0;
    HRESULT hr = S_OK;

    hr = m_fqQueue.HrMapFn(pfnQueueFn, pvContext, &cItems);
    if (SUCCEEDED(hr)) 
    {
        DecrementPendingAndWorkCount(-((LONG)cItems));
    }

    return hr;
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::PauseQueue ]-------------------------
//
//
//  Description: 
//      Pauses a queue by setting the ASYNC_QUEUE_STATUS_PAUSED bit
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/24/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::PauseQueue()
{
    dwInterlockedSetBits(&m_dwQueueFlags, ASYNC_QUEUE_STATUS_PAUSED);
}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::UnpauseQueue ]-----------------------
//
//
//  Description: 
//      Unpauses a queue by unsetting the ASYNC_QUEUE_STATUS_PAUSED bit and
//      requesting threads if neccessary.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/24/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::UnpauseQueue()
{
    DWORD dwOrig = dwInterlockedUnsetBits(&m_dwQueueFlags, ASYNC_QUEUE_STATUS_PAUSED);

    //
    //  The queue *was* paused.  We should make sure that we reqest threads 
    //  if there are items to process.
    //
    if (ASYNC_QUEUE_STATUS_PAUSED & dwOrig)
        RequestCompletionThreadIfNeeded();

}

//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::IncPendingAsyncCompletions ]---------
//
//
//  Description: 
//      Increments the pending async completion count.  If the async queue 
//      feeds into something that may complete async (like CatMsg).  In this
//      case, we may want to throttle the number of outstanding completions
//      we have (i.e.- too avoid having too many active messages)
//
//      If we have hit our limit, then this call with pause the queue.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/24/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::IncPendingAsyncCompletions()
{
    InterlockedIncrement((PLONG) &m_cPendingAsyncCompletions);

    //
    //  Check against limit if we have one
    //
    if (m_cMaxPendingAsyncCompletions && 
        (m_cPendingAsyncCompletions > m_cMaxPendingAsyncCompletions))
    {
        PauseQueue();
    }
}
    
//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::DecPendingAsyncCompletions ]---------
//
//
//  Description: 
//      Decrements the pending async completion count.  If we drop below our
//      threshold, then we will unpause the queue.
//  Parameters:
//
//  Returns:
//
//  History:
//      1/24/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncQueue<PQDATA, TEMPLATE_SIG>::DecPendingAsyncCompletions()
{
    InterlockedDecrement((PLONG) &m_cPendingAsyncCompletions);

    if (m_cMaxPendingAsyncCompletions && 
        (m_cPendingAsyncCompletions < m_cMaxPendingAsyncCompletions))
    {
        UnpauseQueue();
    }
}


//---[ CAsyncQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState ]-------
//
//
//  Description: 
//      Gets the Queue admin state of this queue.  This is different depending
//      on the type of async queue this is (normal vs. retry).
//  Parameters:
//      -
//  Returns:
//      returns the QAPI link flags describing what state this link is in
//  History:
//      3/3/2000 - MikeSwa Created (moved from mailadmq.cpp)
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
DWORD  CAsyncQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState()
{
    //
    //Queue is in retry if there are items pending and no threads are 
    //processing them or it is active if there are items pending and 
    //threads processing them. If there are no items then it is ready.
    //
    if (fIsPaused())
        return LI_READY;
    else if (0 != cGetItemsPending() && 0 == dwGetTotalThreads())
        return LI_RETRY;
    else if (0 != m_pammq->cGetItemsPending())
        return LI_ACTIVE;
    else 
        return LI_READY;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::CAsyncRetryQueue ]--------------
//
//
//  Description: 
//      Default constructor for CAsyncRetryQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::CAsyncRetryQueue()
{
    m_dwRetrySignature = ASYNC_RETRY_QUEUE_SIG;
    m_cRetryItems = 0;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::~CAsyncRetryQueue ]-------------
//
//
//  Description: 
//      Default destructor for CAsyncRetryQueue.  Walks retry queue to release
//      items on it.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::~CAsyncRetryQueue()
{
    m_fqRetryQueue.HrMapFn(HrClearQueueMapFn, m_pvContext, NULL);
}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize ]----------------
//
//
//  Description:
//      Walks queues with given function for shutdown
//  Parameters:
//      pfnQueueShutdown    Queue-mapping function called on shutdown to
//                          clean queues.  If NULL, it will substitute
//                          HrClearQueueMapFn which walks the queues and
//                          releases all PQDATA in it
//      paqinst             Shutdown context with server stop hint function
//  Returns:
//      S_OK on success
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize(
                            CFifoQueue<PQDATA>::MAPFNAPI pfnQueueShutdown, 
                            CAQSvrInst *paqinst)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize");
    HRESULT hr = S_OK;
    DWORD   cItems = 0;
    _ASSERT(paqinst);

    CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrDeinitialize(pfnQueueShutdown,
                                                          paqinst);

    //map shutdown function
    hr = m_fqRetryQueue.HrMapFn(pfnQueueShutdown, paqinst, &cItems);
    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ERROR: Unable to Cleanup CAsyncQueue - hr 0x%08X", hr);
    else
        dwInterlockedAddSubtractDWORD(&m_cRetryItems, cItems, FALSE);


    TraceFunctLeave();
    return hr;

}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure ]------
//
//
//  Description:
//      Called when async completion function returns false... handles requeuing
//      data to the retry queue
//  Parameters:
//      pqdata      - Data that triggered failure
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
BOOL CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::fHandleCompletionFailure(PQDATA pqdata)
{
    HRESULT hr;
    DWORD   cItemsRemoved = 0;

    if (ASYNC_QUEUE_STATUS_SHUTDOWN & m_dwQueueFlags)
        return FALSE;

    //Requeue failed item to retry queue... a possible interesting thing to do
    //here would be to run the failed item through the failure function 
    //(without the queue) to generate DSNs and see if the item actually need to 
    //be queues.
    hr = m_fqRetryQueue.HrRequeue(pqdata);
    if (SUCCEEDED(hr))
        InterlockedIncrement((PLONG) &m_cRetryItems);
    else
        HandleDroppedItem(pqdata);

    return TRUE;

}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest ]----------------
//
//
//  Description: 
//      Queue a request for a retry queue.
//  Parameters:
//      pqdata          Data to pass to completion function
//      fRetry          TRUE => Put item in retry queue until queue is kicked
//                      FALSE => Queue normaly
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if queue-related resources could not be allocated
//  History:
//      3/3/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(PQDATA pqdata, 
                                                               BOOL fRetry)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncRetryQueue<>::HrQueueRequest");
    HRESULT hr = S_OK;

    //
    //  Handle as failure if retry (will put the item in the retry queue).
    //  Otherwise pass to base implementation (queue to normal asyncq).
    //
    if (fRetry)
        fHandleCompletionFailure(pqdata);
    else
        hr = CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(pqdata, fRetry);

    TraceFunctLeave();
    return hr;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFn ]-----------------------
//
//
//  Description: 
//      Calls a function on every message in the queue
//  Parameters:
//      IN  pfnQueueFn      Function to call for every message
//      IN  pvContext       Context passed to completion function
//  Returns:
//      S_OK on success
//      Error code from CFifoQueue<PQDATA>::HrMapFn
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
HRESULT CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::HrMapFn(
                                       CFifoQueue<PQDATA>::MAPFNAPI pfnQueueFn, 
                                       PVOID pvContext)
{
    DWORD cItems = 0;
    HRESULT hr = S_OK;

    hr = CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrMapFn(pfnQueueFn, pvContext);
    if (FAILED(hr))
        goto Exit;

    hr = m_fqRetryQueue.HrMapFn(pfnQueueFn, pvContext, &cItems);
    if (SUCCEEDED(hr))
        dwInterlockedAddSubtractDWORD(&m_cRetryItems, cItems, FALSE);

  Exit:
    return hr;
}

//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::MergeRetryQueue ]---------------
//
//
//  Description: 
//      Merges retry queue into normal queue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/5/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
void CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::MergeRetryQueue()
{
    DWORD   cItemsRemoved = 0;
    PQDATA  pqData = NULL;
    HRESULT hr = S_OK;

    if (ASYNC_QUEUE_STATUS_SHUTDOWN & m_dwQueueFlags)
        return;

    //call failure routine (if present)
    if (m_pfnQueueFailure)
    {
        hr = m_fqRetryQueue.HrMapFn(m_pfnQueueFailure, m_pvContext, &cItemsRemoved);
        if (SUCCEEDED(hr))
        {
            //Adjust appropriate counters
            InterlockedExchangeAdd((PLONG) &m_cRetryItems, -((LONG) cItemsRemoved));
        }
    }

    //Now remerge queue
    hr = S_OK;
    while (SUCCEEDED(hr))
    {
        pqData = NULL;
        hr = m_fqRetryQueue.HrDequeue(&pqData);

        if (FAILED(hr))
            break;

        _ASSERT(pqData);

        InterlockedDecrement((PLONG) &m_cRetryItems);

        //Queue request as retry so we know thread will not be stolen
        hr = CAsyncQueue<PQDATA, TEMPLATE_SIG>::HrQueueRequest(pqData, TRUE);
        if (FAILED(hr))
            HandleDroppedItem(pqData);

        pqData->Release();
    }
}


//---[ CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState ]--
//
//
//  Description: 
//      Gets the Queue admin state of this queue.  This is different depending
//      on the type of async queue this is (normal vs. retry).
//  Parameters:
//      -
//  Returns:
//      returns the QAPI link flags describing what state this link is in
//  History:
//      3/3/2000 - MikeSwa Created (moved from localq.cpp)
//
//-----------------------------------------------------------------------------
template<class PQDATA, DWORD TEMPLATE_SIG>
DWORD  CAsyncRetryQueue<PQDATA, TEMPLATE_SIG>::dwQueueAdminLinkGetLinkState()
{
    //If we items in retry and others... mark it in retry
    //If we have items pending.. it is active
    //Otherwise it is ready
    if (fIsPaused())
        return LI_READY;
    if ((0 != cGetItemsPendingRetry()) && (0 == cGetItemsPending()))
        return LI_RETRY;
    else if (0 != cGetItemsPending())
        return LI_ACTIVE;
    else 
        return LI_READY;
}

#endif //__ASYNCQ_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\connmgr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ConnMgr.cpp
//
//  Description:  Implementation of CConnMgr which provides the
//      IConnectionManager interface.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "retrsink.h"
#include "ConnMgr.h"
#include "fifoqimp.h"
#include "smtpconn.h"
#include "tran_evntlog.h"

VOID LookupQueueforETRN(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete);
VOID CreateETRNDomainList(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete);

//If we are not limiting the number of messages that each connection can handle,
//then lets use this as a guide to determine how many connections to create.
#define UNLIMITED_MSGS_PER_CONNECTION 20

//---[ CConnMgr::CConnMgr ]----------------------------------------------------
//
//
//  Description:
//      Default constructor for CConnMgr class.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CConnMgr::CConnMgr() : CSyncShutdown()
{
    HRESULT hr = S_OK;
    m_paqinst = NULL;
    m_pqol = NULL;
    m_hNextConnectionEvent = NULL;
    m_hShutdownEvent = NULL;
    m_hReleaseAllEvent = NULL;
    m_cConnections = 0;

    m_cMaxLinkConnections = g_cMaxLinkConnections;
    m_cMinMessagesPerConnection = g_cMinMessagesPerConnection;
    m_cMaxMessagesPerConnection = g_cMaxMessagesPerConnection;
    m_cMaxConnections = g_cMaxConnections;
    m_cGetNextConnectionWaitTime = g_dwConnectionWaitMilliseconds;
    m_dwConfigVersion = 0;
    m_fStoppedByAdmin = FALSE;

}

//---[ CConnMgr::~CConnMgr ]-----------------------------------------------------
//
//
//  Description:
//      Default destructor for CConnMgr
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CConnMgr::~CConnMgr()
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::~CConnMgr");

    if (NULL != m_hNextConnectionEvent)
    {
        if (!CloseHandle(m_hNextConnectionEvent))
        {
            DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()),
                "Unable to close handle for Get Next Connection Event");
        }
    }

    if (NULL != m_hShutdownEvent)
    {
        if (!CloseHandle(m_hShutdownEvent))
        {
            DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()),
                "Unable to close handle for Connection Manger Shutdown Event");
        }
    }

    if (NULL != m_hReleaseAllEvent)
    {
        if (!CloseHandle(m_hReleaseAllEvent))
        {
            DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()),
                "Unable to close handle for Connection Manger Release All Event");
        }
    }

    TraceFunctLeave();
}

//---[ CConnMgr::HrInitialize ]------------------------------------------------
//
//
//  Description:
//      CConnMgr Initialization function.
//  Parameters:
//      paqinst            ptr fo CAQSvrInst virtual instance object
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::HrInitialize(CAQSvrInst *paqinst)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::HrInitialize");
    HRESULT hr = S_OK;
    IConnectionRetryManager *pIRetryMgr = NULL;

    _ASSERT(paqinst);

    paqinst->AddRef();
    m_paqinst = paqinst;

    //Create Manual reset event to release all waiting threads on shutdown
    m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hShutdownEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //Create Queue of Links
    m_pqol = new QueueOfLinks;
    if (NULL == m_pqol)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    m_hNextConnectionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hNextConnectionEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //Create Manual reset event to release all waiting threads on caller's request
    m_hReleaseAllEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hReleaseAllEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    hr = QueryInterface(IID_IConnectionRetryManager, (PVOID *) &pIRetryMgr);
    if (FAILED(hr))
        goto Exit;

   //Create the default retry handler object and initialize it
   m_pDefaultRetryHandler = new CSMTP_RETRY_HANDLER();

    if (!m_pDefaultRetryHandler)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

   //Addref IConnectionRetryManager here
   //and release it during deinit
   pIRetryMgr->AddRef();
   hr = m_pDefaultRetryHandler->HrInitialize(pIRetryMgr);
   if (FAILED(hr))
   {
      ErrorTrace((LPARAM) hr, "ERROR: Unable to initialize the retry handler!");
        goto Exit;
   }

  Exit:

    if (pIRetryMgr)
        pIRetryMgr->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::HrDeinitialize ]----------------------------------------------
//
//
//  Description:
//      CConnMgr Deinitialization function.
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::HrDeinitialize");

    //Wait max of 3 minutes no-progress.
    const DWORD CONNMGR_WAIT_SECONDS = 5;
    const DWORD MAX_CONNMGR_SHUTDOWN_WAITS = 1200/CONNMGR_WAIT_SECONDS;
    const DWORD MAX_CONNMGR_SHUTDOWN_WAITS_WITHOUT_PROGRESS = 180/CONNMGR_WAIT_SECONDS;
    HRESULT hr = S_OK;
    HRESULT hrQueue = S_OK;
    CLinkMsgQueue *plmq = NULL;
    DWORD   cWaits = 0;
    DWORD   cWaitsSinceLastProgress = 0;
    DWORD   cConnectionsPrevious = 0;

    if (m_paqinst)
        m_paqinst->ServerStopHintFunction();

    SignalShutdown();

    if (NULL != m_hShutdownEvent)
    {
        if (!SetEvent(m_hShutdownEvent))
        {
            if (SUCCEEDED(hr))
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (NULL != m_pqol)
    {
        //Dequeue Links until empty
        hrQueue = m_pqol->HrDequeue(&plmq);
        while (SUCCEEDED(hrQueue))
        {
            _ASSERT(plmq);
            plmq->Release();
            hrQueue = m_pqol->HrDequeue(&plmq);
        }
        delete m_pqol;
        m_pqol = NULL;
    }


    cConnectionsPrevious = m_cConnections;
    while (m_cConnections)
    {
        cWaits++;
        cWaitsSinceLastProgress++;
        if (m_paqinst)
            m_paqinst->ServerStopHintFunction();
        Sleep(CONNMGR_WAIT_SECONDS * 1000);
        if (m_cConnections != cConnectionsPrevious)
        {
            cConnectionsPrevious = m_cConnections;
            cWaitsSinceLastProgress = 0;
        }

        if ((cWaits > MAX_CONNMGR_SHUTDOWN_WAITS) ||
            (cWaitsSinceLastProgress > MAX_CONNMGR_SHUTDOWN_WAITS_WITHOUT_PROGRESS))
        {
            _ASSERT(0 && "SMTP not returning all connections");
            ErrorTrace((LPARAM) this, "ERROR: %d Connections outstanding on shutdown", m_cConnections);
            break;
        }
    }

    //Must happen after we are done caller server stop hint functions
    if (NULL != m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    //NK** To be safe do it as interlocked exchange
   if (m_pDefaultRetryHandler)
   {
      m_pDefaultRetryHandler->HrDeInitialize();
      m_pDefaultRetryHandler = NULL;
   }

    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::HrNotify ]----------------------------------------------------
//
//
//  Description:
//      Method exposed to recieve a notification about a change in queue status
//  Parameters:
//      IN  paqstats    Notification object
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::HrNotify(IN CAQStats *paqstats, BOOL fAdd)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::HrNotify");
    HRESULT hr = S_OK;
    CLinkMsgQueue *plmq = NULL;
    DWORD   cbDomainName = 0;
    LPSTR   szDomainName = NULL;

    _ASSERT(paqstats);

    plmq = paqstats->m_plmq;

    _ASSERT(plmq); //ConnMgr notifications must have a link associated with then

    if (paqstats->m_dwNotifyType & NotifyTypeNewLink)
    {
        hr = plmq->HrGetSMTPDomain(&cbDomainName, &szDomainName);
        if (FAILED(hr))
            goto Exit;

        //must add new link to QueueOfLinks
        plmq->IncrementConnMgrCount();
        hr = m_pqol->HrEnqueue(plmq);
        if (FAILED(hr))
        {
            plmq->DecrementConnMgrCount();
            DebugTrace((LPARAM) hr, "ERROR: Unable to add new link to connection manager!");
            goto Exit;
        }
    }

    //See if we can (and *should*) create a connection
    if ((m_cConnections < m_cMaxConnections) &&
        plmq->fShouldConnect(m_cMaxLinkConnections, m_cMinMessagesPerConnection))
    {
        DebugTrace((LPARAM) m_hNextConnectionEvent, "INFO: Setting Next Connection Event");
        if (!SetEvent(m_hNextConnectionEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::ReleaseConnection ]-------------------------------------------
//
//
//  Description:
//      Releases the connection count when a connection is being destroyed
//  Parameters:
//      IN  pSMTPConn               SMTP Connection Object to release
//      OUT pfHardErrorForceNDR     TRUE if there was a hard error and we must
//                                  pass this link through DSN generation
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CConnMgr::ReleaseConnection(CSMTPConn *pSMTPConn,
                                 BOOL *pfHardErrorForceNDR)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ReleaseConnection");
    DWORD   dwDomainInfoFlags = 0;
    DWORD   dwLinkStateFlags = 0;
    DWORD   dwConnectionStatus = pSMTPConn->dwGetConnectionStatus();
    DWORD   dwConnectionFailureCount = 0;
    HRESULT hr = S_OK;
    CLinkMsgQueue   *plmq = NULL;
    DWORD   cbDomain = 0;
    LPSTR   szDomain = NULL;
    BOOL    fCanRetry = FALSE;
    BOOL    fLocked = FALSE;
    DWORD   cConnections = 0;
    CInternalDomainInfo    *pIntDomainInfo= NULL;
    CAQScheduleID *paqsched = NULL;
    FILETIME ftNextRetry;
    BOOL    fShouldNotify = FALSE;


    GUID guidRouting = GUID_NULL;
    DWORD cMessages = 0;

    ZeroMemory(&ftNextRetry, sizeof(FILETIME));

    _ASSERT(pfHardErrorForceNDR);
    if (pfHardErrorForceNDR)
        *pfHardErrorForceNDR = FALSE;

    plmq = pSMTPConn->plmqGetLink();
    _ASSERT(plmq); //connection must be associated with a link

    paqsched = plmq->paqschedGetScheduleID();
    _ASSERT(paqsched);

    //Get the routing GUID
    paqsched->GetGUID(&guidRouting);

    hr = plmq->HrGetSMTPDomain(&cbDomain, &szDomain);
    if (FAILED(hr))
    {
        _ASSERT(0);  //I need to unstand when this can happen
        DebugTrace((LPARAM) hr, "ERROR: HrGetSMTPDomain failed");
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }
    else
    {
        fLocked = TRUE;

        _ASSERT(m_paqinst);
        hr = plmq->HrGetDomainInfo(&cbDomain, &szDomain, &pIntDomainInfo);
        if (FAILED(hr))
        {
            //It must match the "*" domain at least
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            DebugTrace((LPARAM) hr, "ERROR: HrGetInternalDomainInfo");
            goto Exit;
        }
        _ASSERT(pIntDomainInfo);
        dwDomainInfoFlags = pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags ;
        cConnections = plmq->cGetConnections();

        //NK** Update the link with the number of messages tried, failed, sent etc
        //If the remaining count goes to 0 and trigger is set, we will disable the trigger
        cMessages = plmq->cGetTotalMsgCount();

        //If we no more messages on the link, we need to disable
        //flags that caused one time triggering
        if(!cMessages)
        {
            //No more messages on the link - we may need to unset some flags on the link

            //If someone set this bit... then we should continue to notify them
            if (plmq->dwGetLinkState() & LINK_STATE_CONNECT_IF_NO_MSGS)
                fShouldNotify = TRUE;

            if(dwDomainInfoFlags & DOMAIN_INFO_TURN_ONLY || dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY )
                dwLinkStateFlags |= LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_PRIV_TURN_ENABLED;

        }
        //Disable the admin forced connection
        // 2/1/99 - MikeSwa - We need to do this check every time, or we will
        //  continue to create connections for this link
        if (plmq->dwGetLinkState() & LINK_STATE_ADMIN_FORCE_CONN)
            dwLinkStateFlags |= LINK_STATE_ADMIN_FORCE_CONN;

        //Call link function to *unset* flags
        if (dwLinkStateFlags)
            plmq->dwModifyLinkState(LINK_STATE_NO_ACTION, dwLinkStateFlags);

        //The connection failed and this is the last outstanding connection to this domain
        //Increment the failure count
        dwConnectionFailureCount = plmq->cGetMessageFailureCount();
        if(cConnections == 1 && (CONNECTION_STATUS_OK != dwConnectionStatus))
        {
            dwConnectionFailureCount =  plmq->IncrementFailureCounts();
        }

        if((CONNECTION_STATUS_FAILED_NDR_UNDELIVERED |
            CONNECTION_STATUS_FAILED_LOOPBACK) & dwConnectionStatus)
        {
            //
            // Flag the link so that we generate DSNs on it and fall fown to
            // the retry handler sink. This link will be marked retry so that
            // no new connections are created.
            //
            if(pfHardErrorForceNDR)
                *pfHardErrorForceNDR = TRUE;

            //
            //  Trick the retry sink so it always uses the glitch retry
            //
            dwConnectionFailureCount = 1;
        }


        _ASSERT(m_pDefaultRetryHandler);
        DebugTrace((LPARAM) this,
                "INFO: ConnectionRelease for domain %s: %d failed, %d tried, status 0x%08X",
                szDomain, pSMTPConn->cGetFailedMsgCount(),
                pSMTPConn->cGetTriedMsgCount(),
                pSMTPConn->dwGetConnectionStatus());
        hr = m_pDefaultRetryHandler->ConnectionReleased(cbDomain, szDomain,
                    dwDomainInfoFlags, paqsched->dwGetScheduleID(),
                    guidRouting, dwConnectionStatus,
                    pSMTPConn->cGetFailedMsgCount(),
                    pSMTPConn->cGetTriedMsgCount(),
                    dwConnectionFailureCount, &fCanRetry, &ftNextRetry);
        if (FAILED(hr))
        {
            DebugTrace((LPARAM) hr,
                "ERROR: Failed to deal with released connection");
        }

        //Make sure that the proper flags are set WRT retry
        if (fCanRetry)
        {
            if (dwConnectionStatus == CONNECTION_STATUS_OK)
                plmq->ResetConnectionFailureCount();

            //If this is a TURN/ETRN domain, we do not want to enable it unless
            //another TURN/ETRN request comes... or a retry request is scheduled for
            //later.  The reason for this, is that we don't want to retry TURN/ETRN
            //domains in the conventional sense, so the defaul retry sink ignores
            //them except for "glitch" retries
            if(dwDomainInfoFlags & (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))
                dwLinkStateFlags = LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_PRIV_TURN_ENABLED;
            else
                dwLinkStateFlags = LINK_STATE_NO_ACTION;

            dwLinkStateFlags = plmq->dwModifyLinkState(LINK_STATE_RETRY_ENABLED,
                                                       dwLinkStateFlags);

            //Check for state change
            if (!(LINK_STATE_RETRY_ENABLED & dwLinkStateFlags))
                fShouldNotify = TRUE;
        }
        else
        {
            char szDiagnosticVerb[1024] = "";
            char szDiagnosticError[1024] = "";
            HRESULT hrDiagnostic;
            plmq->GetDiagnosticInfo(szDiagnosticVerb,
                                    sizeof(szDiagnosticVerb),
                                    szDiagnosticError,
                                    sizeof(szDiagnosticError),
                                    &hrDiagnostic);
            const char *rgszSubstrings[] = {
                szDomain,
                NULL /* error message */,
                szDiagnosticVerb,
                szDiagnosticError,
            };

            if (SUCCEEDED(hrDiagnostic))
            {
                //This means that the connection has failed,
                //but there is no diagnostic information... this could
                //be caused by several things, but we want to avoid
                //logging a potentially bogus event.

                //Set this error to something that looks useful, but
                //is actually the transport equivalent on E_FAIL.  We
                //can use this to find when this was hit by looking at
                //the error logs on retail builds.
                hrDiagnostic = PHATQ_E_CONNECTION_FAILED;

                ErrorTrace((LPARAM) this,
                    "Link Diagnostic was not set - defaulting");
            }


            DWORD iMessage = AQUEUE_REMOTE_DELIVERY_FAILED;
            if (*szDiagnosticVerb != 0 || *szDiagnosticError != 0)
            {
                iMessage = AQUEUE_REMOTE_DELIVERY_FAILED_DIAGNOSTIC;

                if (m_paqinst)
                {
                    m_paqinst->HrTriggerLogEvent(
                        iMessage,                               // Message ID
                        TRAN_CAT_CONNECTION_MANAGER,            // Category
                        4,                                      // Word count of substring
                        rgszSubstrings,                         // Substring
                        EVENTLOG_WARNING_TYPE,                  // Type of the message
                        hrDiagnostic,                           // error code
                        LOGEVENT_LEVEL_MEDIUM,                  // Logging level
                        szDomain,                               // Key to identify this event
                        LOGEVENT_FLAG_PERIODIC,                 // Event logging option
                        1,                                      // format string's index in substring
                        GetModuleHandle(AQ_MODULE_NAME)         // module handle to format a message
                        );
                }
            }
            else {
                if (m_paqinst)
                {
                    m_paqinst->HrTriggerLogEvent(
                        iMessage,                               // Message ID
                        TRAN_CAT_CONNECTION_MANAGER,            // Category
                        2,                                      // Word count of substring
                        rgszSubstrings,                         // Substring
                        EVENTLOG_WARNING_TYPE,                  // Type of the message
                        hrDiagnostic,                           // error code
                        LOGEVENT_LEVEL_MEDIUM,                  // Logging level
                        szDomain,                               // Key to identify this event
                        LOGEVENT_FLAG_PERIODIC,                 // Event logging option
                        1,                                      // format string's index in substring
                        GetModuleHandle(AQ_MODULE_NAME)         // module handle to format message
                        );
                }
            }

            if (dwConnectionStatus == CONNECTION_STATUS_OK)
                plmq->IncrementFailureCounts(); //we had a false positive

            dwLinkStateFlags = plmq->dwModifyLinkState(LINK_STATE_NO_ACTION,
                                                       LINK_STATE_RETRY_ENABLED);

            //Check for state change
            if (LINK_STATE_RETRY_ENABLED & dwLinkStateFlags)
                fShouldNotify = TRUE;

            if (ftNextRetry.dwHighDateTime || ftNextRetry.dwLowDateTime)
            {
                //Retry is telling us a retry time... report that.
                //Set the next retry time that the retry sink tells us about
                plmq->SetNextRetry(&ftNextRetry);
            }
        }

        //Notify router/scheduler of any changes
        if (fShouldNotify)
            plmq->SendLinkStateNotification();

        if (cConnections < m_cMaxConnections)
        {
           if (!SetEvent(m_hNextConnectionEvent))
              DebugTrace((LPARAM) HRESULT_FROM_WIN32(GetLastError()), "Unable to set GetNextConnection Event");
        }
    }

  Exit:
    if (plmq)
        plmq->Release();

    //Decrement connection count
    cConnections = InterlockedDecrement((long *) &m_cConnections);
    DebugTrace((LPARAM) this, "INFO: Releasing Connection for link 0x%08X", plmq);

    if (fLocked)
        ShutdownUnlock();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    TraceFunctLeave();
}

//---[ CConnMgr::QueryInterface ]------------------------------------------
//
//
//  Description:
//      QueryInterface for IAdvQueue
//  Parameters:
//
//  Returns:
//      S_OK on success
//
//  Notes:
//      This implementation makes it possible for any server component to get
//      the IConnectionManager interface.
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IConnectionRetryManager *>(this);
    }
    else if (IID_IConnectionRetryManager == riid)
    {
        *ppvObj = static_cast<IConnectionRetryManager *>(this);
    }
    else if (IID_IConnectionManager == riid)
    {
        *ppvObj = static_cast<IConnectionManager *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CConnMgr::GetNextConnection ]-------------------------------------------
//
//
//  Description:
//      Implementation of IConnectionManager::GetNextConnection()
//
//      Returns the next available connection.  Will create a connection object
//      and associate it with a link.  If we are already at max connections, or
//      no link needs a connection, then this call will block until a an
//      appropriate connection can be made.
//  Parameters:
//      OUT pismtpconn  SMTP Connection interface
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::GetNextConnection(ISMTPConnection ** ppISMTPConnection)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::GetNextConnection");
    const DWORD NUM_CONNECTION_OBJECTS = 3;
    //Release event is the last event in array
    const DWORD WAIT_OBJECT_RELEASE_EVENT = WAIT_OBJECT_0 + NUM_CONNECTION_OBJECTS -1;
    HRESULT hr = S_OK;
    DWORD   cLinksToTry = 0;
    DWORD   cConnections = 0;
    CLinkMsgQueue *plmq = NULL;
    CSMTPConn *pSMTPConn = NULL;
    bool    fForceWait = false;  //temporarily force thread to wait
    bool    fLocked = false;
    DWORD   cbDomain = 0;
    LPSTR   szDomain = NULL;
    HANDLE  rghWaitEvents[NUM_CONNECTION_OBJECTS] = {m_hShutdownEvent, m_hNextConnectionEvent, m_hReleaseAllEvent};
    DWORD   dwWaitResult;
    DWORD   cMaxConnections = 0;
    DWORD   cGetNextConnectionWaitTime = 30000;  //make sure we never start in a busy wait loop
    DWORD   cMaxLinkConnections = 0;
    DWORD   cMinMessagesPerConnection = 0;
    DWORD   cMaxMessagesPerConnection = 0;
    DWORD   dwConfigVersion;
    LONG    cTimesQueued = 0; //# of times a link has been queue'd
    BOOL    fOwnConnectionCount = FALSE;
    BOOL    fMembersUnsafe = FALSE; //set to TRUE during shutdown situations

    if (NULL == ppISMTPConnection)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Get config data
    m_slPrivateData.ShareLock();
    cMaxLinkConnections = m_cMaxLinkConnections;
    cMaxMessagesPerConnection = m_cMaxMessagesPerConnection;

    //Handle unlimited case
    if (m_cMinMessagesPerConnection)
        cMinMessagesPerConnection = m_cMinMessagesPerConnection;
    else
        cMinMessagesPerConnection = UNLIMITED_MSGS_PER_CONNECTION;

    cMaxConnections = m_cMaxConnections;
    cGetNextConnectionWaitTime = m_cGetNextConnectionWaitTime;
    dwConfigVersion = m_dwConfigVersion;
    m_slPrivateData.ShareUnlock();


    cConnections = InterlockedIncrement((PLONG) &m_cConnections);
    fOwnConnectionCount = TRUE;
    cLinksToTry = m_pqol->cGetCount();
    while (true)
    {

        //Use CSyncShutdown locking to prevent shutdown from happening under us
        if (!fLocked)
        {
            if (!fTryShutdownLock())
            {
                hr = AQUEUE_E_SHUTDOWN;
                goto Exit;
            }
            m_paqinst->RoutingShareLock();
            fLocked = TRUE;
        }

        if (m_dwConfigVersion != dwConfigVersion)
        {
            //Config data has/is being updated aquire lock & get new data
            m_slPrivateData.ShareLock();
            cMaxLinkConnections = m_cMaxLinkConnections;
            cMaxMessagesPerConnection = m_cMaxMessagesPerConnection;

            //Handle unlimited case
            if (m_cMinMessagesPerConnection)
                cMinMessagesPerConnection = m_cMinMessagesPerConnection;
            else
                cMinMessagesPerConnection = UNLIMITED_MSGS_PER_CONNECTION;

            cMaxConnections = m_cMaxConnections;
            cGetNextConnectionWaitTime = m_cGetNextConnectionWaitTime;
            dwConfigVersion = m_dwConfigVersion;
            m_slPrivateData.ShareUnlock();
        }

        //$$REVIEW: If there is more than 1 thread waiting on GetNextConnection,
        //then all threads will cycle through all availalbe links (if none are
        //available for connections).  However, it is very unlikely that this
        //run through the queue will be neccessary after Milestone #1.
        while ((0 == cLinksToTry) ||
                (cConnections > cMaxConnections) || fForceWait ||
                fConnectionsStoppedByAdmin())
        {
            InterlockedDecrement((PLONG) &m_cConnections);
            fOwnConnectionCount = FALSE;

            //Release lock for wait function
            fLocked = false;
            m_paqinst->RoutingShareUnlock();
            ShutdownUnlock();

            DebugTrace((LPARAM) m_cConnections, "INFO: Waiting in GetNextConnection");

            _ASSERT(m_cGetNextConnectionWaitTime && "Configured for busy wait loop");
            dwWaitResult = WaitForMultipleObjects(NUM_CONNECTION_OBJECTS,
                        rghWaitEvents, FALSE, cGetNextConnectionWaitTime);

            //NOTE: We *cannot* touch member variables until we determine that
            //we are not shutting down, because SMTP may have a thread in here
            //after this object is destroyed.
            DebugTrace((LPARAM) this, "INFO: Waking up in GetNextConnection");

            if (WAIT_FAILED == dwWaitResult)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
            else if (WAIT_OBJECT_0 == dwWaitResult)  //shutdown event fired
            {
                DebugTrace((LPARAM) this, "INFO: Leaving GetNextConnection because of Shutdown event");
                fMembersUnsafe = TRUE;
                hr = AQUEUE_E_SHUTDOWN;
                goto Exit;
            }
            else if (WAIT_OBJECT_RELEASE_EVENT == dwWaitResult)
            {
                DebugTrace((LPARAM) this, "INFO: Leaving GetNextConnection because ReleaseAllWaitingThreads called");
                //Caller asked that all threads be released
                *ppISMTPConnection = NULL;
                hr = AQUEUE_E_SHUTDOWN;
                fMembersUnsafe = TRUE;
                goto Exit;
            }

            _ASSERT((WAIT_OBJECT_0 == dwWaitResult - 1) || (WAIT_TIMEOUT == dwWaitResult));

            //Re-aquire lock
            if (!fTryShutdownLock())
            {
                hr = AQUEUE_E_SHUTDOWN;
                goto Exit;
            }
            else
            {
                m_paqinst->RoutingShareLock();
                fLocked = true;
            }

            cLinksToTry = m_pqol->cGetCount();
            fForceWait = false; //only force wait once in a row
            cConnections = InterlockedIncrement((PLONG) &m_cConnections);
            fOwnConnectionCount = TRUE;
        }

        _ASSERT(cConnections <= cMaxConnections);

        cLinksToTry--;

      //NK**Insted of Dequeue we should lock and peek to see if the link
      //needs to be dequed
      //If the peek is quick it will be better than dequeing and then
      //enquing it in order
      //Move this complete check into peek

        hr = m_pqol->HrDequeue(&plmq);
        if (FAILED(hr))
        {
            if (AQUEUE_E_QUEUE_EMPTY == hr) //not really an error
            {
                hr = S_OK;
                fForceWait = true;
                continue;
            }
            else
                goto Exit;  //need to handle case of empty queues a little better
        }

        hr = plmq->HrCreateConnectionIfNeeded(cMaxLinkConnections,
                        cMinMessagesPerConnection, cMaxMessagesPerConnection,
                        this, &pSMTPConn);

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "ERROR: HrCreateConnectionIfNeeded failed - hr 0x%08X", hr);
            goto Exit;
        }

        if (S_OK == hr)
        {
            _ASSERT(pSMTPConn);

            //take this opportunity to see if it need queueing
            cTimesQueued = plmq->DecrementConnMgrCount();
            if (!cTimesQueued)
            {
                plmq->IncrementConnMgrCount();
                hr = m_pqol->HrEnqueue(plmq);

                //If we fail here, we are in serious trouble...
                //A link has been lost - we should probably log an event $$TODO
                if (FAILED(hr))
                {
                    plmq->DecrementConnMgrCount();
                    DebugTrace((LPARAM) hr, "ERROR: Unable to requeue link 0x%8X", plmq);
                    goto Exit;
                }
            }

            hr = plmq->HrGetSMTPDomain(&cbDomain, &szDomain);
            if (FAILED(hr))
                goto Exit;

            DebugTrace((LPARAM) plmq, "INFO: Allocating new connection for domain %s", szDomain);

            break;
        }
        else
        {
            _ASSERT(!pSMTPConn);
            //The link does not need a connection - queue the link and look at
            //the next in line.

            //Check if this link can be delete (will increment ConnMgrCount if
            //it can
            plmq->RemoveLinkIfEmpty();
            cTimesQueued = plmq->DecrementConnMgrCount();
            if (!cTimesQueued)
            {
                plmq->IncrementConnMgrCount();
                hr = m_pqol->HrEnqueue(plmq);
                if (FAILED(hr))
                {
                    plmq->DecrementConnMgrCount();
                    DebugTrace((LPARAM) hr,
                        "ERROR: Unable to requeue link 0x%8X", plmq);
                    goto Exit;
                }
            }

            plmq->Release();
            plmq = NULL;
        }

        _ASSERT(fLocked);
        m_paqinst->RoutingShareUnlock();
        ShutdownUnlock();
        fLocked = false;
    }

    *ppISMTPConnection = (ISMTPConnection *) pSMTPConn;
    fOwnConnectionCount = FALSE;

  Exit:
    //NOTE: We *cannot* touch member variables until we determine that
    //we are not shutting down, because SMTP may have a thread in here
    //after this object is destroyed.

    //make sure connection count is correct if we couldn't create a connection
    if (fOwnConnectionCount)
    {
        _ASSERT(!fMembersUnsafe);
        InterlockedDecrement((PLONG) &m_cConnections);
    }

    if (NULL != plmq)
        plmq->Release();

    if (fLocked)
    {
        _ASSERT(!fMembersUnsafe);
        m_paqinst->RoutingShareUnlock();
        ShutdownUnlock();
    }

    if (FAILED(hr) && pSMTPConn)
    {
        if (hr != AQUEUE_E_SHUTDOWN)
            ErrorTrace((LPARAM) this, "ERROR: GetNextConnection failed - hr 0x%08X", hr);

        if (pSMTPConn)
        {
            pSMTPConn->Release();
            *ppISMTPConnection = NULL;
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ ConnMgr::GetNamedConnection ]-------------------------------------------
//
//
//  Description:
//      Implements IConnectionManager::GetNamedConnection
//
//      Returns a connection for the specifically requested connection (if it
//      exists).  Unlike GetNextConnection, this call will not block, it will
//      immediately succeed or fail.
//  Parameters:
//      IN  cbSMTPDomain    Length of domain name (strlen)
//      IN  szSMTPDomain    SMTP Domain of requested connection
//      OUT ppismtpconn     Returned SMTP Connection interface
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if no link exists for the domain
//      AQUEUE_E_QUEUE_EMPTY if link exists but there are no messages on it
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::GetNamedConnection(
                                  IN  DWORD cbSMTPDomain,
                                  IN  char szSMTPDomain[],
                                  OUT ISMTPConnection **ppISMTPConnection)
{
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::GetNamedConnection");
    HRESULT hr = S_OK;
    CDomainEntry   *pdentry = NULL;
    CAQScheduleID aqsched;
    CSMTPConn *pSMTPConn = NULL;
    CLinkMsgQueue  *plmq = NULL;
    CDomainEntryLinkIterator delit;
    DWORD cMessages = 0;
    DWORD cConnectionsOnLink = 0;

    _ASSERT(ppISMTPConnection);
    *ppISMTPConnection = NULL;

    if (fConnectionsStoppedByAdmin()) //Can't create connections
    {
        hr = S_OK;
        goto Exit;
    }

    //Check if it has a queue in DMT for it
    hr = m_paqinst->HrGetDomainEntry(cbSMTPDomain, szSMTPDomain, &pdentry);
    if (FAILED(hr))
    {
        //If we do not have a DMQ corresponding to it
        //we should respond with zero message
        if( hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
        {
            hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
        }
        else
        {
            hr = S_OK;
        }
        goto Exit;

    }

    //NK** : Can we live with this single call
    //The assumption being that domain configured for TURN will
    //always have only one link associated with it
    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
    {
        //Treat as no-link case
        ErrorTrace((LPARAM) this, "Initializing link iterator failed - hr 0x%08X", hr);
        hr = S_OK;
        goto Exit;
    }

    plmq = delit.plmqGetNextLinkMsgQueue(plmq);
    if (!plmq)
    {
        //If we do not have a link corresponding to it
        //we should report the error back to SMTP
        hr = S_OK;
        goto Exit;
    }

    //Check if there are connections for this link that exist
    //
    cConnectionsOnLink = plmq->cGetConnections();
    if(cConnectionsOnLink)
    {
        //Do not allow multiple connections on TURN domains
        //It does not make much sense
        hr = S_OK;
        goto Exit;
    }

    //get the msg count from the dmq
    cMessages = plmq->cGetTotalMsgCount();

    if(cMessages)
    {
        //Create the connection with no message limit
        pSMTPConn = new CSMTPConn(this, plmq, 0);

        if (NULL == pSMTPConn)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        plmq->AddConnection(pSMTPConn);

        *ppISMTPConnection = (ISMTPConnection *) pSMTPConn;

        InterlockedIncrement((PLONG) &m_cConnections);

        //Now enable the link for turned connections
        plmq->dwModifyLinkState(LINK_STATE_PRIV_TURN_ENABLED, LINK_STATE_NO_ACTION);

        goto Exit;
    }
    else
    {
        hr = S_OK;
        goto Exit;
    }


  Exit:
    if (pdentry)
        pdentry->Release();
    if(plmq)
        plmq->Release();
    TraceFunctLeave();
    return hr;
}

//---[ CConnMgr::ReleaseWaitingThreads ]---------------------------------------
//
//
//  Description:
//      Releases all threads waiting on get next connection.
//  Parameters:
//      -
//  Returns:
//      AQUEUE_E_NOT_INITIALIZED if event handle does not exist
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::ReleaseWaitingThreads()
{
    HRESULT hr = S_OK;

    if (m_paqinst)
        m_paqinst->SetShutdownHint();

    if (NULL == m_hReleaseAllEvent)
    {
        hr = AQUEUE_E_NOT_INITIALIZED;
        goto Exit;
    }

    //Since this is an manual-reset event, we will need to Set the Event
    //NOTE: Using PulseEvent here would sometimes cause the system to hang
    //on shutdown.
    if (!SetEvent(m_hReleaseAllEvent))
        hr = HRESULT_FROM_WIN32(GetLastError());

  Exit:
    return hr;
}

//---[ CreateETRNDomainList ]-----------------------------------------------------------
//
//
//  Description:
//      Implements CreateETRNDomainList. A function passed to the
//      DCT iterator to create a list of subdomains corresponding to the ETRN requests
//      of type @domain
//
//  Parameters:
//
//  Returns:
//
//
//---------------------------------------------------------------------------------

VOID CreateETRNDomainList(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CInternalDomainInfo    *pIntDomainInfo = (CInternalDomainInfo*)pvData;
    ETRNCTX         *pETRNCtx = (ETRNCTX*) pvContext;

    *pfContinue = TRUE;
    *pfDelete   = FALSE;
    HRESULT hr  = S_OK;

    TraceFunctEnterEx((LPARAM) NULL, "ETRNSubDomains");

    //We simply create a list of domains in DMT that match our pattern
    //IDI stands for InternalDomainInfo
    if( pETRNCtx && pIntDomainInfo)
    {
        //We add it to the array and add a reference to it
        pETRNCtx->rIDIList[pETRNCtx->cIDICount] = pIntDomainInfo;
        pIntDomainInfo->AddRef();
        if(++pETRNCtx->cIDICount >= MAX_ETRNDOMAIN_PER_COMMAND)
        {
            _ASSERT(0);
            pETRNCtx->hr = AQUEUE_E_ETRN_TOO_MANY_DOMAINS;
            *pfContinue = FALSE;
        }
    }
    else
    {
        if (pETRNCtx)
            pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
        *pfContinue = FALSE;
    }

    TraceFunctLeave();
    return;
}



//---[ LookupQueueforETRN ]--------------------------------------------------
//
//
//  Description:
//      Implements LookupQueueforETRN. A function passed to the
//      DMT iterator to lookup all queues for a wild card domain
//
//  Parameters:
//  Returns:
//
//
//---------------------------------------------------------------------------------

VOID LookupQueueforETRN(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CDomainEntry   *pdentry = (CDomainEntry*)pvData;
    CLinkMsgQueue   *plmq = NULL;
    CDomainEntryLinkIterator delit;
    CInternalDomainInfo    *pIntDomainInfo =NULL;
    ETRNCTX         *pETRNCtx = (ETRNCTX*) pvContext;
    char            *szSMTPDomain = NULL;
    DWORD           cbSMTPDomain = 0;
    DWORD           cMessages = 0;
    HRESULT hr  = S_OK;
    *pfContinue = TRUE;
    *pfDelete   = FALSE;


    TraceFunctEnterEx((LPARAM) NULL, "ETRNSubDomains");

    //If the Domain has messages it is candidate for ETRN
    //Get the link msg queue from the DMT entry
    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
        goto Exit;

    while (plmq = delit.plmqGetNextLinkMsgQueue(plmq))
    {

        //get the msg count from the dmq
        cMessages = plmq->cGetTotalMsgCount();

        if(cMessages)
        {
            //get the name of the domain we are currently considering
            hr = pdentry->HrGetDomainName(&szSMTPDomain);
            if (FAILED(hr))
            {
                //we had some internal error we need to stop iterating
                //Set the Hr in context
                DebugTrace((LPARAM) NULL, "Failed to get message count for %s", szSMTPDomain);
                *pfContinue = FALSE;
                pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                goto Exit;
            }
            cbSMTPDomain = lstrlen(szSMTPDomain);

            //Lookup it up in the DCT to see if there is an entry that conflicts with this
            //If there is no exact match the lookup will comeup with the closest configured
            //ancestor

            hr = pETRNCtx->paqinst->HrGetInternalDomainInfo(cbSMTPDomain, szSMTPDomain, &pIntDomainInfo);
            if (FAILED(hr))
            {
                //It must match the "*" domain at least
                //Otherwise we had some internal error we need to stop iterating
                //Set the Hr in context
                *pfContinue = FALSE;
                pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                goto Exit;
            }
            else
            {
                _ASSERT(pIntDomainInfo);
                //If that ancestor configured for ETRN and it is not the root, we enable it
                //else we skip domain
                //
                if ((pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY) &&
                              pIntDomainInfo->m_DomainInfo.cbDomainNameLength != 1)
                {

                    pETRNCtx->cMessages += cMessages;
                    cMessages = 0;

                    //If it does - trigger the links.
                    DebugTrace((LPARAM) NULL, "Enabling ETRN for domain %s", szSMTPDomain);

                    plmq->dwModifyLinkState(
                            LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_RETRY_ENABLED,
                            LINK_STATE_NO_ACTION);

                }

            } //If we have a valid IntDomainInfo
        } //Message count is zero
    } //looping over lmq's for entry

Exit:
    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    if (szSMTPDomain)
        FreePv(szSMTPDomain);

    if (plmq)
        plmq->Release();

    return;
}


//---[ CConnMgr::ETRNDomainList ]--------------------------------------------------
//
//
//  Description:
//      Implements IConnectionManager:ETRNDomainList.  Used to ETRN appropriate
//      domains based on the list of CInternalDomainInfo passed in
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::ETRNDomainList(ETRNCTX *pETRNCtx)
{
    CInternalDomainInfo *pIntDomainInfo = NULL;

    BOOL fWildcard = FALSE;
    HRESULT hr = S_OK;
    DWORD i = 0;
    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ETRNDomain");

    //NK** Do I need to sort the pointers for duplicates ?
    if(!pETRNCtx->cIDICount)
    {
        //We have nothing in our list
        //
        hr = AQUEUE_E_INVALID_DOMAIN;
        goto Exit;

    }
    for(; i < pETRNCtx->cIDICount; i++)
    {
        if(!(pIntDomainInfo = pETRNCtx->rIDIList[i]))
        {
            //Error happend
            pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
            break;
        }
        //We go ahead only if the domain is marked for ETRN
        if ((pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY))
        {
            //check if this is wild card domain
            fWildcard = FALSE;
            if( pIntDomainInfo->m_DomainInfo.szDomainName[0] == '*' &&
                            pIntDomainInfo->m_DomainInfo.cbDomainNameLength != 1)
            {
                fWildcard = TRUE;
            }
            //If the domain in the list is a wild card entry then
            if(fWildcard)
            {
                //So we have atleast one matching ETRN domain configured
                if(pETRNCtx->hr == S_OK)
                    pETRNCtx->hr = AQ_S_SMTP_WILD_CARD_NODE;
                //Lookup this domain and all its subdomains in the DMT
                //skip over the leading "*."
                hr = pETRNCtx->paqinst->HrIterateDMTSubDomains(pIntDomainInfo->m_DomainInfo.szDomainName + 2,
                                                            pIntDomainInfo->m_DomainInfo.cbDomainNameLength - 2,
                                                       (DOMAIN_ITR_FN)LookupQueueforETRN,  pETRNCtx);
                if (FAILED(hr) && hr != DOMHASH_E_NO_SUCH_DOMAIN && hr != AQUEUE_E_INVALID_DOMAIN)
                {
                     DebugTrace((LPARAM) NULL, "ERROR calling HrIterateDMTSubDomains");
                     goto Exit;
                }

            } // wild card DCT entry
            else
            {
                //Start the queue for the entry
                hr = StartETRNQueue(pIntDomainInfo->m_DomainInfo.cbDomainNameLength,
                                    pIntDomainInfo->m_DomainInfo.szDomainName,
                                    pETRNCtx);
                if (FAILED(hr))
                {
                    //NK** This actually may not be an error
                    //If we do not have a DMQ corresponding to it
                    //we should respond with zero message
                    if( hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
                    {
                        pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                        goto Exit;
                    }
                    else
                        continue;

                }
            } //not a wild card DCT entry
        }
    }

Exit:

    TraceFunctLeave();
    return hr;

}

//---[ CConnMgr::StartETRNQueue ]--------------------------------------------------
//
//
//  Description:
//      Implements CConnMgr::StartETRNQueuet.  Used to start the queue for any
//      domain configured for ETRN
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::StartETRNQueue(IN  DWORD   cbSMTPDomain,
                         IN  char szSMTPDomain[],
                         ETRNCTX *pETRNCtx)
{
    CDomainEntry    *pdentry = NULL;
    CDomainEntryLinkIterator delit;
    CLinkMsgQueue   *plmq = NULL;
    CAQSvrInst      *paqinst = pETRNCtx->paqinst;
    DWORD           cMessages = 0;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ETRNDomain");

    //So we have a domain configured for ETRN by this name
    if( pETRNCtx->hr == S_OK)
        pETRNCtx->hr = AQ_S_SMTP_VALID_ETRN_DOMAIN;

    //Check if it has a queue in DMT for it
    hr = pETRNCtx->paqinst->HrGetDomainEntry(cbSMTPDomain, szSMTPDomain, &pdentry);
    if (FAILED(hr))
    {
        //If we do not have a DMQ corresponding to it
        //we should respond with zero message
        if( hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
        {
            pETRNCtx->hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
        }
        goto Exit;

    }

    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
        goto Exit;

    while (plmq = delit.plmqGetNextLinkMsgQueue(plmq))
    {
        //get the msg count from the dmq
        cMessages = plmq->cGetTotalMsgCount();

        if(cMessages)
        {
            pETRNCtx->cMessages += cMessages;
            cMessages = 0;

            //If it does - trigger the link.
            DebugTrace((LPARAM) NULL, "Enabling ETRN for domain %s", szSMTPDomain);
            plmq->dwModifyLinkState(
                        LINK_STATE_PRIV_ETRN_ENABLED | LINK_STATE_RETRY_ENABLED,
                        LINK_STATE_NO_ACTION);

        }

    }

Exit:
    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;

}

//---[ CConnMgr::ETRNDomain ]----------------------------------------------------
//
//
//  Description:
//      Implements IConnectionManager:ETRNDomain.  Used to reqeust that a
//      domain be ETRN'd (enabled for outbound connections).
//  Parameters:
//      IN  cbSMTPDomain    String length of domain name
//      IN  szSMTPDomain    SMTP Domain name.  Wildcarded names start with
//                          a "@" (eg "@foo.com");
//      OUT pcMessages      # of Messages queued for ETRN domain
//  Returns:
//  Remarks:
//  If the received domain is wildcarded '@' then we follow this logic :
//      Lookup this node and every subnode of this node in DCT. The lookup is done
//  using table iterator and iterator function CreateETRNDomainList. For every entry
//  that is found with ETRN flag set, lookup if any queues exist in DMT. If the
//  queue exist and have messages in them then we enable the corresponding links.
//      If the lookup in DCT yields a domain that is configured as wild card '*.",
//  then we lookup all queus corresponding to all sub domains of that domain. We do
//  this using the iterator and iterator function LookupQueueforETRN. For every queue
//  found by iterator the function checks back in DMT if the domain is configured for
//  ETRN. This is to take care of situations where one specific subdomain of a wild
//  card configured domain may be not configured for etrn.
//      Eg : *.foo.com => ETRN, but 1.foo.com => NO_ETRN
//
//  Both calls to iterate are covered with reader locks. The lock stays valid for
//  the duration of all iterations.
//  The iterator function used during DCT iterations also adds reference to every
//  InternalDomainInfo as we need the data to stay valid after the table lock is released.
//----------------------------------------------------------------------------------
STDMETHODIMP CConnMgr::ETRNDomain(
                          IN  DWORD   cbSMTPDomain,
                         IN  char szSMTPDomain[],
                         OUT DWORD *pcMessages)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    CDomainEntry   *pdentry = NULL;
    CDestMsgQueue *pdmq = NULL;
    CInternalDomainInfo    *pIntDomainInfo =NULL;

    BOOL    fETRNSubDomains = FALSE;

    char    * szTmpDomain = szSMTPDomain;
    ETRNCTX EtrnCtx;
    EtrnCtx.hr = S_OK;
    EtrnCtx.cMessages = 0;
    EtrnCtx.paqinst = NULL;
    EtrnCtx.cIDICount = 0;
    EtrnCtx.rIDIList[0] = NULL;

    TraceFunctEnterEx((LPARAM) this, "CConnMgr::ETRNDomain");

    DWORD      cMessages = 0;

    *pcMessages = 0;  //$$TODO - Get real values


    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    m_paqinst->RoutingShareLock();
    fLocked = TRUE;

    EtrnCtx.paqinst = m_paqinst;

    //do we have a '@' request
    if(*szTmpDomain == '@')
        fETRNSubDomains = TRUE;

    //If we do have '@' request, we need to skip the first chararcter
    //and then look for every sub domain of the domain in the DCT
    //For every subdomain that we find with ETRN flag, we will lookup the
    //DMT to see if there is a queue
    //If the entry we find in DCT is of wildcard type, we will lookup all
    //subdomains of that domain in DMT looking for all queues destined for
    //subdomains of the DCT entry.
    if(fETRNSubDomains)
    {
        ++szTmpDomain;
        //Create a list of all subdomains of this domain in the DCT
        hr = m_paqinst->HrIterateDCTSubDomains(szTmpDomain, lstrlen(szTmpDomain),
                                        (DOMAIN_ITR_FN)CreateETRNDomainList, &EtrnCtx);

        //If we fail to look up single domain
        if (FAILED(hr))
        {
            if(hr == AQUEUE_E_INVALID_DOMAIN || hr == DOMHASH_E_NO_SUCH_DOMAIN)
            {
                DebugTrace((LPARAM)this, "ERROR calling HrIterateDCTSubdomains");
                hr = hr = AQ_E_SMTP_ETRN_NODE_INVALID;
            }
            else
            {
                DebugTrace((LPARAM)this, "ERROR calling HrIterateDCTSubdomains");
                hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
            }
            goto Exit;
        }

        //Check if the lookup got us anything
        if(!FAILED(EtrnCtx.hr))
        {
            //Check if any queus can be started for domains in the list
            //Start if possible
            hr = ETRNDomainList(&EtrnCtx);
            if (FAILED(hr))
            {
                if(hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
                {
                    DebugTrace((LPARAM)this, "ERROR calling ETRNSubDomain");
                    hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                    goto Exit;
                }
            }

            //If we saw atleast one matching domain
            if(EtrnCtx.hr == AQ_S_SMTP_VALID_ETRN_DOMAIN || EtrnCtx.hr == AQ_S_SMTP_WILD_CARD_NODE)
            {
                *pcMessages = EtrnCtx.cMessages;
                hr = EtrnCtx.hr;
            }
            else
                hr = AQ_E_SMTP_ETRN_NODE_INVALID;
        }
        else
            hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;

        goto Exit;
    }
    else
    {
        //Lookup the domain in the domain cfg table and see if it has ETRN bit set
        _ASSERT(m_paqinst);
        hr = m_paqinst->HrGetInternalDomainInfo(cbSMTPDomain, szSMTPDomain, &pIntDomainInfo);
        if (FAILED(hr))
        {
            //It must match the "*" domain at least
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
            goto Exit;
        }
        else
        {
            _ASSERT(pIntDomainInfo);
             EtrnCtx.rIDIList[0] = pIntDomainInfo;
             EtrnCtx.cIDICount = 1;

            //We will not ETRN if the closest ancestor is Root or two level
            //NK** implement search for two level
            if( pIntDomainInfo->m_DomainInfo.cbDomainNameLength == 1)
            {
                //Cannot ETRN based on the root domain
                hr = AQ_E_SMTP_ETRN_NODE_INVALID;
                goto Exit;
            }

            if ((pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_ETRN_ONLY))
            {
                //Start the queue if exists for this domain
                hr = StartETRNQueue(cbSMTPDomain, szSMTPDomain,&EtrnCtx);
                if (FAILED(hr))
                {
                    if(hr != AQUEUE_E_INVALID_DOMAIN && hr != DOMHASH_E_NO_SUCH_DOMAIN)
                    {
                        DebugTrace((LPARAM)this, "ERROR calling ETRNSubDomain");
                        hr = AQ_E_SMTP_ETRN_INTERNAL_ERROR;
                        goto Exit;
                    }
                }

                //If we saw atleast one matching domain
                if(EtrnCtx.hr == AQ_S_SMTP_VALID_ETRN_DOMAIN || EtrnCtx.hr == AQ_S_SMTP_WILD_CARD_NODE)
                {
                    *pcMessages = EtrnCtx.cMessages;
                    hr = AQ_S_SMTP_VALID_ETRN_DOMAIN;
                }
                else
                    hr = AQ_E_SMTP_ETRN_NODE_INVALID;

                goto Exit;
            }
            else
            {
                //Cannot ETRN based on the root domain
                hr = AQ_E_SMTP_ETRN_NODE_INVALID;
                goto Exit;
            }
        }
    }



Exit:

    //wake up thread in GetNextConnection
    if (SUCCEEDED(hr) &&SUCCEEDED(EtrnCtx.hr) && EtrnCtx.cMessages)
        _VERIFY(SetEvent(m_hNextConnectionEvent));


    if (fLocked)
    {
        m_paqinst->RoutingShareUnlock();
        ShutdownUnlock();
    }

    //free up all InternalDomainInfo
    for(DWORD i=0; i < EtrnCtx.cIDICount; i++)
        if (EtrnCtx.rIDIList[i])
            EtrnCtx.rIDIList[i]->Release();

    if (pdentry)
        pdentry->Release();

    TraceFunctLeave();
    return hr;
}


//---[ CConnMgr::ModifyLinkState ]---------------------------------------------
//
//
//  Description:
//      Link state can change so that connections can(not) be created for a link.
//  Parameters:
//      IN cbDomainName     String length of domain name
//      IN szDomainName     Domain Name to enable
//      IN dwScheduleID     ScheduleID of <domain, schedule> pair
//      IN rguidTransportSink GUID of router associated with link
//      IN dwFlagsToSet     Link State Flags to set
//      IN dwFlagsToUnset   Link State Flags to unset
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain does not exist
//
//-----------------------------------------------------------------------------
HRESULT CConnMgr::ModifyLinkState(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink,
               IN  DWORD dwFlagsToSet,
               IN  DWORD dwFlagsToUnset)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    CDomainEntry *pdentry = NULL;
    CLinkMsgQueue *plmq = NULL;
    CAQScheduleID aqsched(rguidTransportSink, dwScheduleID);

    if (!cbDomainName || !szDomainName)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    _ASSERT(m_paqinst);
    hr = m_paqinst->HrGetDomainEntry(cbDomainName, szDomainName, &pdentry);
    if (FAILED(hr))
        goto Exit;

    hr = pdentry->HrGetLinkMsgQueue(&aqsched, &plmq);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(plmq);
    //filter out the reserved bits for this "public" API
    plmq->dwModifyLinkState(~LINK_STATE_RESERVED & dwFlagsToSet,
                            ~LINK_STATE_RESERVED & dwFlagsToUnset);

  Exit:
    if (fLocked)
        ShutdownUnlock();

    if (pdentry)
        pdentry->Release();

    if (plmq)
        plmq->Release();

    return hr;
}

//---[ CConnMgr::UpdateConfigData ]-------------------------------------------
//
//
//  Description:
//      Will be used by catmsgq to update the metabase changes
//
//  Parameters:
//
//  Returns:
//
//-----------------------------------------------------------------------------
//

void CConnMgr::UpdateConfigData(IN AQConfigInfo *pAQConfigInfo)
{
    BOOL    fUpdated = FALSE;
    RETRYCONFIG RetryConfig;

    RetryConfig.dwRetryThreshold = g_dwRetryThreshold;
    RetryConfig.dwGlitchRetrySeconds = g_dwGlitchRetrySeconds;

    //
    //  This is registry configurable... make sure we have a sane
    //  value
    //
    if (!RetryConfig.dwGlitchRetrySeconds)
        RetryConfig.dwGlitchRetrySeconds = 60;

    RetryConfig.dwFirstRetrySeconds = g_dwFirstTierRetrySeconds;
    RetryConfig.dwSecondRetrySeconds = g_dwSecondTierRetrySeconds;
    RetryConfig.dwThirdRetrySeconds = g_dwThirdTierRetrySeconds;
    RetryConfig.dwFourthRetrySeconds = g_dwFourthTierRetrySeconds;

    m_slPrivateData.ExclusiveLock();
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MAX_CON &&
        MEMBER_OK(pAQConfigInfo, cMaxConnections))
    {
        if ((m_cMaxConnections != pAQConfigInfo->cMaxConnections))
        {
            fUpdated = TRUE;

            //g_cMaxConnections is the number connection objects we
            //reserve with CPool... we can't go above that.
            if (g_cMaxConnections < pAQConfigInfo->cMaxConnections)
                m_cMaxConnections = g_cMaxConnections;
            else
                m_cMaxConnections = pAQConfigInfo->cMaxConnections;
        }
    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MAX_LINK &&
        MEMBER_OK(pAQConfigInfo, cMaxLinkConnections))
    {
        if (m_cMaxLinkConnections != pAQConfigInfo->cMaxLinkConnections)
        {
            fUpdated = TRUE;
            //g_cMaxConnections is the number connection objects we
            //reserve with CPool... we can't go above that.
            if (!pAQConfigInfo->cMaxLinkConnections ||
                (g_cMaxConnections < pAQConfigInfo->cMaxLinkConnections))
                m_cMaxLinkConnections = g_cMaxConnections;
            else
                m_cMaxLinkConnections = pAQConfigInfo->cMaxLinkConnections;
        }
    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MIN_MSG &&
        MEMBER_OK(pAQConfigInfo, cMinMessagesPerConnection))
    {

        if (m_cMinMessagesPerConnection != pAQConfigInfo->cMinMessagesPerConnection)
        {
            fUpdated = TRUE;
            m_cMinMessagesPerConnection = pAQConfigInfo->cMinMessagesPerConnection;
            //Currently we set both these values based on the batching value from SMTP
            m_cMaxMessagesPerConnection = pAQConfigInfo->cMinMessagesPerConnection;
        }

    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_WAIT &&
        MEMBER_OK(pAQConfigInfo, dwConnectionWaitMilliseconds))
    {
        if (m_cGetNextConnectionWaitTime != pAQConfigInfo->dwConnectionWaitMilliseconds)
        {
            fUpdated = TRUE;
            m_cGetNextConnectionWaitTime = pAQConfigInfo->dwConnectionWaitMilliseconds;
        }
    }

    if (fUpdated) //only force updated when really required
        InterlockedIncrement((PLONG) &m_dwConfigVersion);

    m_slPrivateData.ExclusiveUnlock();

    fUpdated = FALSE;

    //Retry related config data
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwRetryThreshold))
    {
        fUpdated = TRUE;
        RetryConfig.dwRetryThreshold = pAQConfigInfo->dwRetryThreshold;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwFirstRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwFirstRetrySeconds = pAQConfigInfo->dwFirstRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwSecondRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwSecondRetrySeconds = pAQConfigInfo->dwSecondRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwThirdRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwThirdRetrySeconds = pAQConfigInfo->dwThirdRetrySeconds;
    }
    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        MEMBER_OK(pAQConfigInfo, dwFourthRetrySeconds))
    {
        fUpdated = TRUE;
        RetryConfig.dwFourthRetrySeconds = pAQConfigInfo->dwFourthRetrySeconds;
    }

    if (pAQConfigInfo->dwAQConfigInfoFlags & AQ_CONFIG_INFO_CON_RETRY &&
        fUpdated )
        m_pDefaultRetryHandler->UpdateRetryData(&RetryConfig);

}




//---[ CConnMgr::RetryLink ]---------------------------------------------------
//
//
//  Description:
//      Implements IConnectionRetryManager::RetryLink, which enables the retry
//      sink to enable a link for retry.
//  Parameters:
//      IN cbDomainName     String length of domain name
//      IN szDomainName     Domain Name to enable
//      IN dwScheduleID     ScheduleID of <domain, schedule> pair
//      IN rguidTransportSink GUID of router associated with link
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain does not exist
//  History:
//      1/9/99 - MikeSwa Created (simplified routing sink)
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnMgr::RetryLink(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink)
{
    HRESULT hr = S_OK;
    hr = ModifyLinkState(cbDomainName, szDomainName, dwScheduleID,
                rguidTransportSink, LINK_STATE_RETRY_ENABLED,
                LINK_STATE_NO_ACTION);

    //
    //  Kick the connections so we know to make one
    //
    KickConnections();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dcontext.h ===
//-----------------------------------------------------------------------------
//
//
//	File: dcontext.h
//
//	Description: Defines stucture referenced by delilvery context HANDLE
//		(as returned by HrGetNextMessage).  This should only be used inside
//		the CMT.
//
//	Author: mikeswa
//
//	Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _DCONTEXT_H_
#define _DCONTEXT_H_

#include "bitmap.h"
#include "aqueue.h"

class CMsgRef;
class CDestMsgRetryQueue;

#define DELIVERY_CONTEXT_SIG    'txtC'
#define DELIVERY_CONTEXT_FREE   'txt!'

//---[ CDeliveryContext ]------------------------------------------------------
//
//
//  Description: 
//      Context that is used to Ack message after local/remote delivery.  The
//      memory for this class is either allocated with the connection object
//      or on the stack for local delivery.
//  Hungarian: 
//
//  
//-----------------------------------------------------------------------------
class CDeliveryContext
{
public:
    CDeliveryContext();
    CDeliveryContext(CMsgRef *pmsgref, CMsgBitMap *pmbmap, DWORD cRecips, 
            DWORD *rgdwRecips, DWORD dwStartDomain, CDestMsgRetryQueue *pdmrq); 
    ~CDeliveryContext();
    
    HRESULT HrAckMessage(IN MessageAck *pMsgAck);
    
    void Init(CMsgRef *pmsgref, CMsgBitMap *pmbmap, DWORD cRecips, 
            DWORD *rgdwRecips, DWORD dwStartDomain, CDestMsgRetryQueue *pdmrq);
    void Recycle();
    BOOL FVerifyHandle(IMailMsgProperties *pIMailMsgPropeties);

    CDestMsgRetryQueue *pdmrqGetDMRQ() {return m_pdmrq;};
private:
    friend class CMsgRef;
    DWORD       m_dwSignature;
    CMsgRef     *m_pmsgref;  //MsgRef for this context
    CMsgBitMap  *m_pmbmap;   //Bitmap of domains that delivery was attempted for
    DWORD        m_cRecips;  //Number of recips to deliver to
    DWORD       *m_rgdwRecips; //Array of recip indexes
    DWORD        m_dwStartDomain; //First domain delivered to

    //Retry interface for this delivey attempt
    CDestMsgRetryQueue *m_pdmrq; 
};

#endif //_DCONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dbgilock.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dbgilock.h
//
//  Description:
//      Provide debug version of InterlockedCompareExchange that can be used
//      to ferret out multithreading issues.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef _DBGILOCK_H_
#define _DBGILOCK_H_

#include <aqincs.h>

#ifdef DEBUG
extern  LONG       g_cSleeps;   //number attempts that lead to a sleep
extern  LONG       g_cAttempts; //total number of attempts

#ifndef DEFAULT_SLEEP_CHANCE
#define DEFAULT_SLEEP_CHANCE 0
#endif  //DEFAULT_SLEEP_CHANCE

//---[ PvDebugInterlockedFn ]--------------------------------------------------
//
//
//  Description:
//      This is a DEBUG wrapper around Interlocked Compare Exchange that
//      provides some help in detecting multithreading problem.  The last
//      parament can be used to describe the "percentage" of times the this
//      function will sleep as the last thing before trying the update
//  Parameters:
//      PVOID *ppvDest   destination address
//      PVOID pvSource   new value
//      PVOID pvOld      old value to check againes
//      int iChance      percentage chance to sleep
//  Returns:
//      Same as InterlockedCompareExchange, the value before the update
//      attempt.
//
//-----------------------------------------------------------------------------
//
// This function is entirely wrong and will not work on 64-bit systems. The
// same function cannot be used for PVOIDs and LONGs.
//
/*
inline PVOID PvDebugInterlockedFn(
                PVOID *ppvDest, //destination address
                PVOID pvSource, //new value
                PVOID pvOld,    //old value to check againes
                int iChance)    //percentage chance to sleep
{

    int cAttempts = InterlockedIncrement(&g_cAttempts);
    int cSleeps = g_cSleeps;

    Assert(cAttempts); //if 0, the WIN32 api docs are wrong
    if (iChance && (iChance >= ((cSleeps*100)/cAttempts))) //does it meet the percentage chance?
    {
        InterlockedIncrement(&g_cSleeps);
        Sleep(0);
    }

// Milans - If we are using NT5 headers, the InterlockedCompareExchangePointer
// will be defined
#ifdef InterlockedCompareExchangePointer
    return ((PVOID)InterlockedCompareExchange((PLONG) ppvDest,(LONG)pvSource,(LONG)pvOld));
#else
    return (InterlockedCompareExchange(ppvDest,pvSource,pvOld));
#endif
}
*/
#endif

// Milans - If we are using NT5 headers, the InterlockedCompareExchangePointer
// will be defined
#ifndef InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointer InterlockedCompareExchange
#endif // if NT5

#endif //_DBGILOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\consched.h ===
//-----------------------------------------------------------------------------
//
//
//  File: consched.h
//
//  Description:    Header file for CConnScheduler, a class that implements a 
//      stub IConnectionScheduler for A/Q that only handles retry logic.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __CONSCHED_H__
#define __CONSCHED_H__

#include <aqueue.h>
#include <baseobj.h>
#include "shutdown.h"
#include "catmsgq.h"

class CScheduledAction;

//---[ CConnScheduler ]--------------------------------------------------------
//
//
//  Description: Implements a stub IConnectionScheduler and handles connection
//      retry logic for AQ.
//
//  Hungarian: cshed, pcshed
//
//  
//-----------------------------------------------------------------------------
class CConnScheduler : 
    public IConnectionScheduler,
    protected CSyncShutdown,
    public CBaseObject
{
  private:
    CCatMsgQueue        *m_pcmq;
    IScheduleManager    *m_pISchedMgr;
    HANDLE               m_hShutdown;
  public:
    CConnScheduler(CCatMsgQueue *pcmq, IScheduleManager *pISchedMgr);
    ~CConnScheduler();

    HRESULT HrInit();
    HRESULT HrDeinit();
    HRESULT HrProcessAction(CScheduledAction *pSchedAct, DWORD cDelayMilliseconds=0);
  
  public:  //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

  public:  //IConnectionScheduler
    STDMETHOD(ConnectionReleased) (
					IN  DWORD cbDomainName,
					IN  char szDomainName[],
					IN  DWORD dwScheduleID,
					IN  DWORD dwConnectionStatus,		//eConnectionStatus
					IN  DWORD cFailedMessages,		//# of failed message for *this* connection
					IN  DWORD cUntriedMessages,		//# of untried messages in queue
					IN  DWORD cOutstandingConnections,//# of other active connections for this domain
					OUT BOOL *pfAllowImmediateRetry);
    
    STDMETHOD(NewRemoteDomain) (
					IN  DWORD cbDomainName,
					IN  char szDomainName[],
					IN  DWORD dwScheduleID,
					OUT BOOL *pfAllowImmediateConnection);

    STDMETHOD(DeleteRemoteDomain) (
					IN  DWORD cbDomainName,
					IN  char szDomainName[],
                    IN  DWORD dwScheduleID) {return S_OK;};
};


#endif //__CONSCHED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\connmgr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: ConnMgr.h
//
//  Description: Definition CConnMgr, class that implements IConnectionManager
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------


#ifndef __CONNMGR_H_
#define __CONNMGR_H_

#include "aqinst.h"
#include <aqueue.h>
#include "aqnotify.h"
#include <fifoq.h>
#include "shutdown.h"
#include <baseobj.h>
#include <mailmsg.h>
#include "retrsink.h"

class   CLinkMsgQueue;
class   CDomainMappingTable;
class   CSMTPConn;

typedef CFifoQueue<CLinkMsgQueue *> QueueOfLinks;

//We will only allow one @command to ETRN maximum 'X' domains
//Anything more will be denied
#define MAX_ETRNDOMAIN_PER_COMMAND  50

typedef struct etrncontext
{
    HRESULT hr;
    DWORD   cMessages;
    CAQSvrInst *paqinst;
    CInternalDomainInfo* rIDIList[MAX_ETRNDOMAIN_PER_COMMAND];
    DWORD   cIDICount;
} ETRNCTX, *PETRNCTX;

//---[ CConnMgr ]--------------------------------------------------------------
//
//
//  Hungarian: connmgr, pconnmgr
//
//
//-----------------------------------------------------------------------------
class CConnMgr :
    public IConnectionManager,
    public IConnectionRetryManager,
    public CBaseObject,
    public IAQNotify,
    protected CSyncShutdown
{
private:
    CAQSvrInst          *m_paqinst;
    QueueOfLinks        *m_pqol;
    CSMTP_RETRY_HANDLER  *m_pDefaultRetryHandler;
    HANDLE               m_hNextConnectionEvent;
    HANDLE               m_hShutdownEvent;
    HANDLE               m_hReleaseAllEvent;
    DWORD                m_cConnections;

    //config stuff
    CShareLockNH         m_slPrivateData;
    DWORD                m_dwConfigVersion; //updated every time config is updated
    DWORD                m_cMinMessagesPerConnection;  //will be per-domain
    DWORD                m_cMaxLinkConnections; //will be per-domain
    DWORD                m_cMaxMessagesPerConnection;
    DWORD                m_cMaxConnections;
    DWORD                m_cGetNextConnectionWaitTime;
    BOOL                 m_fStoppedByAdmin;

private :
    HRESULT CConnMgr::ETRNDomainList(ETRNCTX *pETRNCtx);
    HRESULT CConnMgr::StartETRNQueue(IN  DWORD   cbSMTPDomain,
                                     IN  char szSMTPDomain[],
						             ETRNCTX *pETRNCtx);

public:
    CConnMgr();
    ~CConnMgr();
    HRESULT HrInitialize(CAQSvrInst *paqinst);
    HRESULT HrDeinitialize();
    HRESULT HrNotify(IN CAQStats *paqstats, BOOL fAdd);

    //Keep track of the number of connections
    void ReleaseConnection(CSMTPConn *pSMTPConn, BOOL *pfHardErrorForceNDR);

    //Will be used by catmsgq to update the metabase changes
    void UpdateConfigData(IN AQConfigInfo *pAQConfigInfo);

    //Used by CAQSvrInst to signal local delivery retry
    HRESULT SetCallbackTime(IN RETRFN   pCallbackFn,
                            IN PVOID    pvContext,
                            IN DWORD    dwCallbackMinutes)
    {
        HRESULT hr = S_OK;
        if (m_pDefaultRetryHandler)
        {
            hr = m_pDefaultRetryHandler->SetCallbackTime(pCallbackFn,
                                pvContext, dwCallbackMinutes);
        }
        else
        {
            hr = E_FAIL;
        }
        return hr;
    }

    //Can be used to make an otherwise idle system re-evaluate the
    //need for connections
    void KickConnections()
    {
        if (!m_fStoppedByAdmin)
            _VERIFY(SetEvent(m_hNextConnectionEvent));
    };

    void QueueAdminStopConnections() {m_fStoppedByAdmin = TRUE;};
    void QueueAdminStartConnections() {m_fStoppedByAdmin = FALSE;KickConnections();};
    BOOL fConnectionsStoppedByAdmin() {return m_fStoppedByAdmin;};

    HRESULT ModifyLinkState(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink,
               IN  DWORD dwFlagsToSet,
               IN  DWORD dwFlagsToUnset);

public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

public: // IConnectionManager - private interface with SMTP
    STDMETHOD(GetNextConnection)(OUT ISMTPConnection **ppISMTPConnection);
    STDMETHOD(GetNamedConnection)(IN  DWORD cbSMTPDomain,
                                  IN  char szSMTPDomain[],
                                  OUT ISMTPConnection **ppISMTPConnection);
    STDMETHOD(ReleaseWaitingThreads)();
    STDMETHOD(ETRNDomain)(IN  DWORD   cbSMTPDomain,
                     IN  char szSMTPDomain[],
                     OUT DWORD *pcMessages);


public: //IConnectionRetryManager - interface with routing
    STDMETHOD(RetryLink)(
               IN  DWORD cbDomainName,
               IN  char szDomainName[],
               IN  DWORD dwScheduleID,
               IN  GUID rguidTransportSink);

};

#endif //__CONNMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\consched.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ConnSched.cpp
//
//  Description:  Implementation of CConnScheduler class, which provides a stub
//      implementation of IConnectionScheduler for aqueue.dll.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <transmem.h>
#include "consched.h"
#include "catmsgq.h"

#define DEFAULT_DOMAIN_LENGTH   256 //initial 
#define ACTION_SIG 'ntcA'

//---[ eScheduleAction ]-------------------------------------------------------
//
//
//  Description: Enum describing the possible actions that can happen
//
//  
//-----------------------------------------------------------------------------
typedef enum eScheduleAction
{
    SCHEDULE_ACTION_RETRY   = 0x000000001,
    SCHEDULE_ACTION_ENABLE  = 0x000000002,
    SCHEDULE_ACTION_DISABLE = 0x000000003,
};

eScheduleAction g_eScheduleAction = SCHEDULE_ACTION_RETRY; //encourage symbols

//---[ CScheduledAction ]------------------------------------------------------
//
//
//  Hungarian: pSchedAct
//
//  Description: Class that represent a single queued action for the scheduler
//
//  
//-----------------------------------------------------------------------------
class CScheduledAction
{
public:
    CScheduledAction(DWORD dwAction);
    ~CScheduledAction();
    HRESULT HrInit(DWORD cbDomain, LPSTR szDomain);
    DWORD   m_dwSig;    //signature used when to make verify dequeued object
    DWORD   m_dwAction; //Action to start
    DWORD   m_cbDomain; //# bytes in domain name
    LPSTR   m_szDomain; //domain name string
    CHAR    m_szBuffer[DEFAULT_DOMAIN_LENGTH]; //default buffer to use
};

//---[ CScheduledAction::CScheduledAction ]------------------------------------
//
//
//  Description: 
//      Class constructor for CScheduledAction
//  Parameters:
//      Action to create object for
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
inline CScheduledAction::CScheduledAction(DWORD dwAction)
{
    m_dwSig    = ACTION_SIG;
    m_dwAction = dwAction;
    m_cbDomain = 0;
    m_szDomain = NULL;
    m_szBuffer[0] = '\0';
}

//---[ CScheduledAction::~CScheduledAction ]-----------------------------------
//
//
//  Description: 
//      Class destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
inline CScheduledAction::~CScheduledAction()
{
    if (m_szDomain && (m_szDomain != m_szBuffer))
    {
        _ASSERT( m_cbDomain >= DEFAULT_DOMAIN_LENGTH);
        FreePv(m_szDomain);
    }
}

//---[ CScheduledAction::HrInit ]----------------------------------------------
//
//
//  Description: 
//      Initializes a CScheduleAction object... will allocate a buffer for the
//      string name if neccessary
//  Parameters:
//      cbDomain    # bytes in domain name
//      szDomain    Domain Name string
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
HRESULT inline CScheduledAction::HrInit(DWORD cbDomain, LPSTR szDomain)
{
    HRESULT hr = S_OK;
    if (cbDomain >= DEFAULT_DOMAIN_LENGTH)
    {
        m_szDomain = (LPSTR) pvMalloc(cbDomain+sizeof(CHAR));
        if (!m_szDomain)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else
    {
        m_szDomain = m_szBuffer;
    }

    m_cbDomain = cbDomain;
    memcpy(m_szDomain, szDomain, cbDomain+sizeof(CHAR));

  Exit:
    return hr;
}

//---[ SCHED_THREAD_PARAM ]----------------------------------------------------
//
//
//  Description: Struct used to pass thread parameters to threads created to
//      handle scheduled actions/
//
//  
//-----------------------------------------------------------------------------
typedef struct _SCHED_THREAD_PARAM
{
    CScheduledAction *pSchedAct;    //scheduled action
    CConnScheduler *pConnSched;     //object that can process action
    DWORD           dwDelay;  //time to sleep before action
} SCHED_THREAD_PARAM, *PSCHED_THREAD_PARAM;


//---[ StartConnectionSchedulerThread ]----------------------------------------
//
//
//  Description: 
//      Function used to start a Connection Scheduler thread
//  Parameters:
//      lpThreadParam - actually a this pointer for a CMsgConversion Obj.
//  Returns:
//      HRESULT indicating success or failure.
//
//-----------------------------------------------------------------------------
DWORD  WINAPI StartConnectionSchedulerThread(LPVOID lpThreadParam)
{
    HRESULT hr = S_OK;
    bool    fCOMInit = false;
    PSCHED_THREAD_PARAM pSchedThreadParam = (PSCHED_THREAD_PARAM) lpThreadParam;
    CScheduledAction *pSchedAct = pSchedThreadParam->pSchedAct;
    CConnScheduler   *pConnSched = pSchedThreadParam->pConnSched;

    _ASSERT(pSchedAct && pConnSched);

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        goto Exit;

    fCOMInit = true;

    if (ACTION_SIG != pSchedAct->m_dwSig) 
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = pConnSched->HrProcessAction(pSchedAct, pSchedThreadParam->dwDelay);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (pConnSched)
        pConnSched->Release();

    if (pSchedThreadParam)
        delete pSchedThreadParam;

    if (fCOMInit)
        CoUninitialize();

    return ((DWORD) hr);
}

//---[ CConnScheduler::CConnScheduler ]----------------------------------------
//
//
//  Description: 
//      Class constructor for CConnScheduler
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CConnScheduler::CConnScheduler(CCatMsgQueue *pcmq, IScheduleManager *pISchedMgr)
{
    _ASSERT(pcmq);
    _ASSERT(pISchedMgr);

    m_pcmq = pcmq;
    m_pISchedMgr = pISchedMgr;

    m_pcmq->AddRef();
    m_pISchedMgr->AddRef();

    m_hShutdown = NULL;
}

//---[ CConnScheduler::~CConnScheduler ]---------------------------------------
//
//
//  Description: 
//      Class destructor for CConnScheduler
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
CConnScheduler::~CConnScheduler()
{
    if (m_pcmq)
        m_pcmq->Release();

    if (m_pISchedMgr)
        m_pISchedMgr->Release();

    if (m_hShutdown)
    {
        CloseHandle(m_hShutdown);
    }

}

//---[ CConnScheduler::HrInit ]------------------------------------------------
//
//
//  Description: 
//      
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
HRESULT CConnScheduler::HrInit()
{
    HRESULT hr = S_OK;

    hr = HrInitSyncShutdown();

    m_hShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hShutdown)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

  Exit:
    return hr;
}

//---[ CConnScheduler::HrDeinit ]----------------------------------------------
//
//
//  Description: 
//      Signals an orderly shutdown
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
HRESULT CConnScheduler::HrDeinit()
{
    HRESULT hr = S_OK;

    if (!SetEvent(m_hShutdown))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    SignalShutdown();

    if (m_pcmq)
    {
        m_pcmq->Release();
        m_pcmq = NULL;
    }

    if (m_pISchedMgr)
    {
        m_pISchedMgr->Release();
        m_pISchedMgr = NULL;
    }

    Sleep(1000); //given retry threads a chance to shutdown.
  Exit:
    return hr;
}

//---[ CConnScheduler::HrProcessAction ]--------------------------------------
//
//
//  Description: 
//      Processes a single schedule action
//  Parameters:
//      pSchedAct           object that encapsulates scheduled action
//      cDelayMilliseconds  Time in millseconds to delay processing of action
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CConnScheduler::HrProcessAction(CScheduledAction *pSchedAct, 
                                        DWORD dwDelayMilliseconds)
{
    HRESULT hr = S_OK;
    DWORD   dwWaitResult = 0;
    BOOL    fLocked = FALSE;
    _ASSERT(m_pISchedMgr);
    _ASSERT(m_hShutdown);
    _ASSERT(pSchedAct);
    _ASSERT(pSchedAct->m_szDomain);
    _ASSERT(pSchedAct->m_cbDomain);

    hr = HrLock();
    if (FAILED(hr))
        goto Exit;

    fLocked = TRUE;

    dwWaitResult = WaitForSingleObject(m_hShutdown, dwDelayMilliseconds);
    if (WAIT_OBJECT_0 == dwWaitResult) //shutdown
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    _ASSERT(WAIT_TIMEOUT == dwWaitResult);

    if (pSchedAct->m_dwAction & SCHEDULE_ACTION_RETRY)
    {
        hr = m_pISchedMgr->EnableOutboundConnections(pSchedAct->m_cbDomain, 
                        pSchedAct->m_szDomain, 0);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        _ASSERT(0 || "Invalid Arg");
    }

  Exit:
    if (fLocked)
        HrUnlock();

    return hr;
}



//---[ CConnScheduler::QueryInterface ]----------------------------------------
//
//
//  Description: 
//      QueryInterface for IConnectionScheduler
//  Parameters:
//
//  Returns:
//      S_OK on success
//
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnScheduler::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IConnectionScheduler *>(this);
    }
    else if (IID_IConnectionScheduler == riid)
    {
        *ppvObj = static_cast<IConnectionScheduler *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CConnScheduler::ConnectionReleased ]------------------------------------
//
//
//  Description: 
//      Implements IConnectionScheduler::ConnectionRelease().  Called when 
//      SMTP releases a connection and is used to handle retry logic
//  Parameters:
//      IN  cbDomainName    String length of domain name
//      IN  szDomainName    Domain name of connection that was released
//      IN  dwScheduleID    Schedule ID of this connection
//      IN  cFailedMessages Number of messages that were attempted and failed
//                          by the particular connection instance being released
//      IN  cUntiredMessages The number of messages that have not been attempted
//                          For this <domain, schedule>
//      IN  cOutstandingConnections  The number of other outstanding connections
//                          for this <domain, schedule>
//      OUT pfAllowImmediateRetry  Should we allow any further connections to 
//                          be created for this <domain, schedule>
//  Returns:
//      S_OK on success
//
//  REVIEW:
//      Will we really want to expose this functionality externally?  It might
//      make sense to have another internal object that makes calls to ISMTP
//-----------------------------------------------------------------------------
STDMETHODIMP CConnScheduler::ConnectionReleased(
   					IN  DWORD cbDomainName,
					IN  char szDomainName[],
					IN  DWORD dwScheduleID,
					IN  DWORD dwConnectionStatus,		//eConnectionStatus
					IN  DWORD cFailedMessages,		//# of failed message for *this* connection
					IN  DWORD cUntriedMessages,		//# of untried messages in queue
					IN  DWORD cOutstandingConnections,//# of other active connections for this domain
					OUT BOOL *pfAllowImmediateRetry)
{
    TraceFunctEnterEx((LPARAM) this, "CConnScheduler::ConnectionReleased");
    HRESULT hr = S_OK;
    CScheduledAction *pSchedAct = NULL;
    PSCHED_THREAD_PARAM pThreadParam = NULL;
    HANDLE  hThread = NULL;
    DWORD   dwThreadID = 0;
    BOOL    fLocked = FALSE;


    _ASSERT(pfAllowImmediateRetry);

    hr = HrLock();
    if (FAILED(hr))
        goto Exit;

    fLocked = TRUE;
        
    if (!cFailedMessages && (CONNECTION_STATUS_OK == dwConnectionStatus))
    {
        *pfAllowImmediateRetry = TRUE;
    }
    else
    {
        DebugTrace((LPARAM) dwConnectionStatus, "INFO: Remote Domain %s scheduled for retry", szDomainName);
        pSchedAct = new CScheduledAction(SCHEDULE_ACTION_RETRY);
        hr = pSchedAct->HrInit(cbDomainName, szDomainName);
        if (FAILED(hr))
            goto Exit;

        pThreadParam = (PSCHED_THREAD_PARAM) pvMalloc(sizeof(SCHED_THREAD_PARAM));
        if (!pThreadParam)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pThreadParam->pSchedAct = pSchedAct;
        pThreadParam->pConnSched = this;
        if (FAILED(m_pcmq->HrGetConnectionRetry(&(pThreadParam->dwDelay))))
        {
            pThreadParam->dwDelay = 60000;
        }

        AddRef();

        hThread = CreateThread(
                    NULL,
                    0,
                    StartConnectionSchedulerThread,
                    (LPVOID) pThreadParam,
                    0,
                    &dwThreadID);

        if (NULL == hThread)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        if (!CloseHandle(hThread))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        hThread = NULL;

        pThreadParam = NULL;
        pSchedAct = NULL;
        *pfAllowImmediateRetry = FALSE;
    }

  Exit:
    if (pSchedAct)
        delete pSchedAct;

    if (pThreadParam)
    {
        Release();
        FreePv(pThreadParam);
    }

    if (fLocked)
        HrUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ CConnScheduler::NewRemoteDomain ]---------------------------------------
//
//
//  Description: 
//      Implements IConnectionScheduler::NewRemoteDomain().  For MM1, this is 
//      just a stub implementation with no actual scheduling happening (all
//      domains are approved for immediate connections.
//  Parameters:
//      IN  cbDomainName    String length of domain name
//      IN  szDomainName    Domain name of next hop link that was created
//      IN  dwScheduleID    Schedule ID of this connection
//      OUT pfAllowImmediateConnection Should we allow any further connections to 
//                          be created for this <domain, schedule> befote
//                          IScheduleManager::EnableOutboundConnections is called.
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CConnScheduler::NewRemoteDomain(
					IN  DWORD cbDomainName,
					IN  char szDomainName[],
					IN  DWORD dwScheduleID,
					OUT BOOL *pfAllowImmediateConnection)
{
    HRESULT hr = S_OK;
    _ASSERT(pfAllowImmediateConnection);

    *pfAllowImmediateConnection = TRUE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dcontext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dcontext.cpp
//
//  Description:    Implementation of delivery context class.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "dcontext.h"

CDeliveryContext::CDeliveryContext()
{
    m_dwSignature = DELIVERY_CONTEXT_FREE;
    m_pmsgref = NULL;
    m_pmbmap = NULL;
    m_cRecips = 0;
    m_rgdwRecips = NULL;
    m_pdmrq = NULL;
}

void CDeliveryContext::Recycle()
{
    if (m_pmsgref)    
        m_pmsgref->Release();
    if (m_pmbmap)     
        delete m_pmbmap;
    if (m_rgdwRecips)
        FreePv(m_rgdwRecips);
    if (m_pdmrq)
        m_pdmrq->Release();

    m_dwSignature = DELIVERY_CONTEXT_FREE;
    m_pmsgref = NULL;
    m_pmbmap = NULL;
    m_cRecips = 0;
    m_rgdwRecips = NULL;
    m_pdmrq = NULL;
}

//---[ CDeliveryContext::CDeliveryContext ]------------------------------------
//
//
//  Description: 
//      Constructor for CDeliveryContext.  Should be created by a CMsgRef on
//      Prepare delivery.
//
//      $$REVIEW:  We may wish to include the ability to define rgdwRecips
//      as a CPool buffer.  If so, we will need to add a flag telling how to
//      get rid of it.
//  Parameters:
//      pmsgref     MsgRef that generated this context
//      pmbmap      Bitmap of domains that delivery is being attempted on
//      cRecips     Number of Recipients we are attempting delivery to
//      rgdwRecips  Array of recip indexes.  This allows the delivery context
//                  to handle deleting the buffer.
//      dwStartDomain The first domain in context
//      pdmrq       Retry interface for this delivery attempt
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDeliveryContext::CDeliveryContext(CMsgRef *pmsgref, CMsgBitMap *pmbmap,
                                   DWORD cRecips, DWORD *rgdwRecips, 
                                   DWORD dwStartDomain, 
                                   CDestMsgRetryQueue *pdmrq) 
{
    m_dwSignature = DELIVERY_CONTEXT_FREE;  //so init succeeds
    Init(pmsgref, pmbmap, cRecips, rgdwRecips, dwStartDomain, pdmrq);
}

void CDeliveryContext::Init(CMsgRef *pmsgref, CMsgBitMap *pmbmap,
                       DWORD cRecips, DWORD *rgdwRecips, DWORD dwStartDomain,
                       CDestMsgRetryQueue *pdmrq) 
{
    _ASSERT(pmsgref);
    _ASSERT(pmbmap);
    _ASSERT(cRecips);
    _ASSERT(rgdwRecips);
    _ASSERT(DELIVERY_CONTEXT_FREE == m_dwSignature);
    m_dwSignature = DELIVERY_CONTEXT_SIG;
    m_pmsgref = pmsgref;
    m_pmbmap = pmbmap;
    m_cRecips = cRecips;
    m_rgdwRecips = rgdwRecips;
    m_dwStartDomain = dwStartDomain;
    m_pdmrq = pdmrq;
    if (m_pdmrq)
        m_pdmrq->AddRef();
}; 

//---[ CDeliveryContext::~CDeliveryContext ]-----------------------------------
//
//
//  Description: 
//      Destructor for CDeliveryContext.  The buffer used to pass recipients to
//      the SMTP stack will be freed here.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDeliveryContext::~CDeliveryContext()
{
    if (m_pmsgref)    
        m_pmsgref->Release();
    if (m_pmbmap)     
        delete m_pmbmap;
    if (m_rgdwRecips)
        FreePv(m_rgdwRecips);
    if (m_pdmrq)
        m_pdmrq->Release();

    m_dwSignature = DELIVERY_CONTEXT_FREE;
};

//---[  CDeliveryContext::HrAckMessage ]----------------------------------------
//
//
//  Description: 
//      Ack (non)delivery of message
//  Parameters:
//      pMsgAck     Ptr to MessageAck structure
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDeliveryContext::HrAckMessage(IN MessageAck *pMsgAck)
{
    HRESULT hr = S_OK;
    _ASSERT(m_pmsgref);
    _ASSERT(DELIVERY_CONTEXT_SIG == m_dwSignature);

    hr = m_pmsgref->HrAckMessage(this, pMsgAck);

    return hr;
}

//---[ CDeliveryContext::FVerifyHandle ]---------------------------------------
//
//
//  Description: 
//      Used to perform simple validation that the data being passed is 
//      actually a delivery context.  This should not AV if the handle is bad
//      (as long as the actual function call can be made).
//
//  Parameters:
//      -
//  Returns:
//      True is the this ptr looks like a valid CDeliveryContext.
//
//-----------------------------------------------------------------------------
CDeliveryContext::FVerifyHandle(IMailMsgProperties *pIMailMsgPropeties)
{
    _ASSERT((DELIVERY_CONTEXT_SIG == m_dwSignature) && "bogus delivery context");

    register BOOL fResult = TRUE;
    if (NULL == m_pmsgref)
        fResult = FALSE;
    else if (NULL == m_pmbmap)
        fResult = FALSE;

    if (fResult)
    {
        if (!m_pmsgref->fIsMyMailMsg(pIMailMsgPropeties))
        {
            _ASSERT(0 && "Wrong message acked on connection");
            fResult = FALSE;
        }
    }
    return fResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\defdlvrq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: defdlvrq.cpp
//
//  Description:  Implementation of CAQDeferredDeliveryQueue & 
//      CAQDeferredDeliveryQueueEntry.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/23/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "defdlvrq.h"
#include "aqutil.h"

//---[ CAQDeferredDeliveryQueueEntry::CAQDeferredDeliveryQueueEntry ]----------
//
//
//  Description: 
//      Constructor for CAQDeferredDeliveryQueueEntry class
//  Parameters:
//      IN  pIMailMsgProperties     MailMsg to queue
//      IN  pft                     FILTIME (UT) to defer deliver until
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueueEntry::CAQDeferredDeliveryQueueEntry(
                                  IMailMsgProperties *pIMailMsgProperties,
                                  FILETIME *pft)
{
    _ASSERT(pIMailMsgProperties);
    _ASSERT(pft);

    m_liQueueEntry.Flink = NULL;
    m_liQueueEntry.Blink = NULL;

    memcpy(&m_ftDeferredDeilveryTime, pft, sizeof(FILETIME));

    m_pIMailMsgProperties = pIMailMsgProperties;

    if (m_pIMailMsgProperties)
    {
        m_pIMailMsgProperties->AddRef();

        //Release usage count while this message is pending delivery
        HrReleaseIMailMsgUsageCount(m_pIMailMsgProperties);

    }

    m_fCallbackSet = FALSE;
    m_dwSignature = DEFERRED_DELIVERY_QUEUE_ENTRY_SIG;
}

//---[ CAQDeferredDeliveryQueueEntry::~CAQDeferredDeliveryQueueEntry ]---------
//
//
//  Description: 
//      Descructor for CAQDeferredDeliveryQueueEntry class
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueueEntry::~CAQDeferredDeliveryQueueEntry()
{
    //Release mailmsg properties
    if (m_pIMailMsgProperties)
    {
        m_pIMailMsgProperties->Release();
        m_pIMailMsgProperties = NULL;
    }

    //Remove from list (if in list)
    if (m_liQueueEntry.Flink)
    {
        _ASSERT(m_liQueueEntry.Blink);
        RemoveEntryList(&m_liQueueEntry);
    }
    MARK_SIG_AS_DELETED(m_dwSignature);
}


//---[ CAQDeferredDeliveryQueueEntry::SetCallback ]----------------------------
//
//
//  Description: 
//      Sets callback for queue.  Per Entry state is maintained so we know we 
//      have 1 and only 1 callback per head of queue.
//
//      Queue private lock should be exclusive when this is called
//  Parameters:
//      pvContext       Context for callback function
//      paqinst         Server Instance object
//  Returns:
//      TRUE if a callback is set
//  History:
//      1/13/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQDeferredDeliveryQueueEntry::fSetCallback(PVOID pvContext, 
                                                 CAQSvrInst *paqinst)
{
    if (!m_fCallbackSet && paqinst)
    {
        m_fCallbackSet = TRUE;
        paqinst->SetCallbackTime(CAQDeferredDeliveryQueue::TimerCallback,
                                 pvContext, &m_ftDeferredDeilveryTime);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//---[ CAQDeferredDeliveryQueueEntry::pmsgGetMsg ]-----------------------------
//
//
//  Description: 
//      Get AddRef'd message for this entry
//  Parameters:
//      -
//  Returns:
//      pIMailMsgProperties.
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
IMailMsgProperties *CAQDeferredDeliveryQueueEntry::pmsgGetMsg()
{
    _ASSERT(m_pIMailMsgProperties);
    IMailMsgProperties *pIMailMsgProperties = m_pIMailMsgProperties;

    if (pIMailMsgProperties)
    {
        //Add the usage count the we released earlier on
        HrIncrementIMailMsgUsageCount(m_pIMailMsgProperties);

        //Set to NULL, so caller "owns" this entry's reference count (and
        //usage count).
        m_pIMailMsgProperties = NULL;
    }

    return pIMailMsgProperties;
}


//---[ CAQDeferredDeliveryQueue::CAQDeferredDeliveryQueue ]--------------------
//
//
//  Description: 
//      Constructor for CAQDeferredDeliveryQueue class
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueue::CAQDeferredDeliveryQueue()
{
    m_dwSignature = DEFERRED_DELIVERY_QUEUE_SIG;
    InitializeListHead(&m_liQueueHead);
    m_paqinst = NULL;
    m_cCallbacksPending = 0;
}

//---[ CAQDeferredDeliveryQueue::~CAQDeferredDeliveryQueue ]-------------------
//
//
//  Description: 
//      Default destructor for CAQDeferredDeliveryQueue.
//  Parameters:
//
//  Returns:
//
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQDeferredDeliveryQueue::~CAQDeferredDeliveryQueue()
{
    Deinitialize();
}

//---[ CAQDeferredDeliveryQueue::Initialize ]----------------------------------
//
//
//  Description: 
//      Initialization for CAQDeferredDeliveryQueue
//  Parameters:
//      IN  paqinst         Ptr to virtual server instance object
//  Returns:
//      -
//  History:
//      12/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::Initialize(CAQSvrInst *paqinst)
{
    _ASSERT(paqinst);
    m_paqinst = paqinst;
    m_paqinst->AddRef();
}

//---[ CAQDeferredDeliveryQueue::Deinitialize ]--------------------------------
//
//
//  Description: 
//      Performs first-pass shutdown for CAQDeferredDeliveryQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::Deinitialize()
{
    CAQDeferredDeliveryQueueEntry *pdefqe = NULL;
    LIST_ENTRY *pli = NULL;

    //$$REVIEW - It may be adventagious to remove this lock and rely on the
    //private data lock of the virtual server instance.  This will require 
    //fixing fTryRoutingLock.  Also having a single lock leads to single-thread
    //deadlock issues while we have it exclusively and call to submit.

    m_slPrivateData.ExclusiveLock();
    pli = m_liQueueHead.Flink;

    //Walk queue and delete remaining entries
    while (pli != &m_liQueueHead)
    {
        pdefqe = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(pli);

        if (m_paqinst)
            m_paqinst->ServerStopHintFunction();

        //Make sure we get the next before deleting the entry :)
        pli = pli->Flink;

        _ASSERT(pdefqe);
        delete pdefqe;
    }

    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    m_slPrivateData.ExclusiveUnlock();
}

//---[ CAQDeferredDeliveryQueue::Enqueue ]-------------------------------------
//
//
//  Description: 
//      Enqueues a message for deferred delivery
//  Parameters:
//      IN  pIMailMsgProperties         message to defer
//      IN  pft                         FILETIME to defer delivery too
//  Returns:
//      -   Failures are handled internally
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::Enqueue(IMailMsgProperties *pIMailMsgProperties,
                                  FILETIME *pft)
{
    CAQDeferredDeliveryQueueEntry *pdefqeCurrent = NULL;
    CAQDeferredDeliveryQueueEntry *pdefqeNew = NULL;
    LIST_ENTRY *pli = NULL;
    LARGE_INTEGER   *pLargeIntCurrentDeferredTime = NULL;
    LARGE_INTEGER   *pLargeIntNewDeferredTime = (LARGE_INTEGER *)pft;

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pft);
    
    pdefqeNew = new CAQDeferredDeliveryQueueEntry(pIMailMsgProperties, pft);

    m_slPrivateData.ExclusiveLock();

    if (!pdefqeNew)
    {
        //Handle Out of memory situation
        _ASSERT(m_paqinst); //if we don't have a virtual server we're toast
        if (m_paqinst)
        {
            m_paqinst->DecPendingDeferred();
            //pass off to virtual server object for general failure handling
            m_paqinst->HandleAQFailure(AQ_FAILURE_PENDING_DEFERRED_DELIVERY, 
                                        E_OUTOFMEMORY, pIMailMsgProperties);
        }

        goto Exit;
    }
    pli = m_liQueueHead.Flink;

    //Walk queue and look for entries with a later deferred delivery time.
    while (pli != &m_liQueueHead)
    {
        pdefqeCurrent = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(pli);
        _ASSERT(pdefqeCurrent);
        pLargeIntCurrentDeferredTime = (LARGE_INTEGER *) 
                            pdefqeCurrent->pftGetDeferredDeliveryTime();

        //If we have found an entry with a later time, we're done and will insert
        //in front of this entry
        if (pLargeIntCurrentDeferredTime->QuadPart > pLargeIntNewDeferredTime->QuadPart)
        {
            //back up so insert will happen between current and previous entry
            pli = pli->Blink; 
            break;
        }

        //continue searching forward (same direction as dequeue)
        pli = pli->Flink;
        _ASSERT(pli);
    }

    _ASSERT(pli);
    pdefqeNew->InsertBefore(pli);

    SetCallback();

  Exit:
    m_slPrivateData.ExclusiveUnlock();

}

//---[ CAQDeferredDeliveryQueue::ProcessEntries ]------------------------------
//
//
//  Description: 
//      Processes entries from the front of the queue until there are no 
//      more entries with deferred delivery times in the past.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::ProcessEntries()
{
    CAQDeferredDeliveryQueueEntry *pdefqe = NULL;
    LIST_ENTRY *pli = NULL;
    FILETIME *pftDeferredTime = NULL;
    DWORD dwTimeContext = 0;
    IMailMsgProperties *pIMailMsgProperties = NULL;
    HRESULT hr = S_OK;
    DWORD   cEntriesProcessed = 0;

    m_slPrivateData.ExclusiveLock();
    pli = m_liQueueHead.Flink;

    //if we do not have a virtual server pointer... then we have nothing
    //to do with the processed messages
    if (!m_paqinst)
        goto Exit;

    //Walk queue and delete remaining entries
    while (pli != &m_liQueueHead)
    {
        pdefqe = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(pli);
        _ASSERT(pdefqe);
        pftDeferredTime = pdefqe->pftGetDeferredDeliveryTime();

        //Check if the deferred delivery time is in the past... if not, we are done
        if (!m_paqinst->fInPast(pftDeferredTime, &dwTimeContext))
        {
            if (!cEntriesProcessed)
            {
                //we have processed no entries... and wasted a callback
                //force another callback so messages don't get stranded
                pdefqe->ResetCallbackFlag();
            }
            break;
        }

        cEntriesProcessed++;

        pIMailMsgProperties = pdefqe->pmsgGetMsg();
        delete pdefqe; //we remove from list

        //Release lock, so we do not hold it for external calls to submit
        //the message
        m_slPrivateData.ExclusiveUnlock();

        m_paqinst->DecPendingDeferred();

        //This is the external verions of AQ's submit API which should
        //always succeed... (unless shutdown is happening).
        hr = m_paqinst->HrInternalSubmitMessage(pIMailMsgProperties);

        if (FAILED(hr))
            m_paqinst->HandleAQFailure(AQ_FAILURE_PROCESSING_DEFERRED_DELIVERY, hr,
                                        pIMailMsgProperties);

        pIMailMsgProperties->Release();
        pIMailMsgProperties = NULL;

        //Since we gave up the lock, we need to start from the front of
        //the queue
        m_slPrivateData.ExclusiveLock();
        pli = m_liQueueHead.Flink;
        
    }

    //see if there are any other entries an set a new callback time
    SetCallback();

  Exit:
    m_slPrivateData.ExclusiveUnlock();
}

//---[ CAQDeferredDeliveryQueue::TimerCallback ]-------------------------------
//
//
//  Description: 
//      Callback function that is triggered by the retry-callback code.
//  Parameters:
//      IN  pvContext           A this ptr for the CAQDeferredDeliveryQueue
//                              object.
//  Returns:
//      - 
//  History:
//      12/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::TimerCallback(PVOID pvContext)
{
    CAQDeferredDeliveryQueue *pdefq = (CAQDeferredDeliveryQueue *) pvContext;

    _ASSERT(DEFERRED_DELIVERY_QUEUE_SIG == pdefq->m_dwSignature);

    InterlockedDecrement((PLONG) &pdefq->m_cCallbacksPending);
    pdefq->ProcessEntries();
}


//---[ CAQDeferredDeliveryQueue::SetCallback ]---------------------------------
//
//
//  Description: 
//      Sets the retry callback if the queue is non-empty... Exclusive lock
//      on queue should be held at this point.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/13/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQDeferredDeliveryQueue::SetCallback()
{
    CAQDeferredDeliveryQueueEntry *pdefqe = NULL;
    if (!IsListEmpty(&m_liQueueHead))
    {
        //Set the callback time.
        pdefqe = CAQDeferredDeliveryQueueEntry::pdefqeGetEntry(m_liQueueHead.Flink);
        _ASSERT(pdefqe);
        
        if (pdefqe->fSetCallback(this, m_paqinst))
            InterlockedIncrement((PLONG) &m_cCallbacksPending);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\defdlvrq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: defdlvrq.h
//
//  Description:  Header file for CAQDeferredDeliveryQueue.  This class 
//      implements storage for msgs pending deferred delivery
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/23/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DEFDLVRQ_H__
#define __DEFDLVRQ_H__

#include <aqincs.h>

class CAQSvrInst;

#define DEFERRED_DELIVERY_QUEUE_SIG         'QfeD'
#define DEFERRED_DELIVERY_QUEUE_ENTRY_SIG   'nEQD'

//---[ CAQDeferredDeliveryQueue ]----------------------------------------------
//
//
//  Description: 
//      Priority Queue / timer management for deferred delivery messages.
//  Hungarian: 
//      defq, pdefq
//  
//-----------------------------------------------------------------------------
class CAQDeferredDeliveryQueue
{
  protected:
    DWORD           m_dwSignature;
    LIST_ENTRY      m_liQueueHead;
    CAQSvrInst     *m_paqinst;
    CShareLockNH    m_slPrivateData;
    DWORD           m_cCallbacksPending;
  public:
    CAQDeferredDeliveryQueue();
    ~CAQDeferredDeliveryQueue();
    void Initialize(CAQSvrInst *paqinst);
    void Deinitialize();

    //Functions to enqueue and process entries... Any failures are handled
    //internally (by calling the HandleFailedMessage API).
    void Enqueue(IMailMsgProperties *pIMailMsgProperties, FILETIME *pft);
    void ProcessEntries();

    //callback function to "kick" queue
    static void TimerCallback(PVOID pvContext);
    void SetCallback();
};


//---[ CAQDeferredDeliveryQueueEntry ]-----------------------------------------
//
//
//  Description: 
//      Queue Entry for for deferred delivery queue
//  Hungarian: 
//      defqe, pdefqe
//  
//-----------------------------------------------------------------------------
class CAQDeferredDeliveryQueueEntry
{
  protected:
    DWORD               m_dwSignature;
    LIST_ENTRY          m_liQueueEntry;
    FILETIME            m_ftDeferredDeilveryTime;
    IMailMsgProperties *m_pIMailMsgProperties;
    BOOL                m_fCallbackSet;
  public:
    CAQDeferredDeliveryQueueEntry(IMailMsgProperties *pIMailMsgProperties,
                                  FILETIME *pft);
    ~CAQDeferredDeliveryQueueEntry();

    FILETIME   *pftGetDeferredDeliveryTime() {return &m_ftDeferredDeilveryTime;};
    void        InsertBefore(LIST_ENTRY *pli) 
    {
        _ASSERT(pli);
        InsertHeadList(pli, &m_liQueueEntry)
    };
    IMailMsgProperties *pmsgGetMsg();

    static CAQDeferredDeliveryQueueEntry *pdefqeGetEntry(LIST_ENTRY *pli)
    {
        _ASSERT(pli);
        CAQDeferredDeliveryQueueEntry *pdefqe = CONTAINING_RECORD(pli, 
                                                    CAQDeferredDeliveryQueueEntry,
                                                    m_liQueueEntry);

        _ASSERT(DEFERRED_DELIVERY_QUEUE_ENTRY_SIG == pdefqe->m_dwSignature);
        return pdefqe;
    };

    BOOL fSetCallback(PVOID pvContext, CAQSvrInst *paqinst);
    void ResetCallbackFlag() {m_fCallbackSet = FALSE;};
};


#endif __DEFDLVRQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domain.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: domain.cpp
//
//  Description: Implementation of CDomainMapping, CDomainEntry, and
//      CDomainMappingTable.
//
//      The DomainMappingTable is a domain name hash table that contains the
//      mappings from final destination to queues.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "aqroute.h"
#include "localq.h"
#include "asyncq.h"
#include "mailadmq.h"
#include "tran_evntlog.h"

const DWORD LOCAL_DOMAIN_NAME_SIZE = 512;

//Max mislabled queues in empty list, before we will clean the list
const DWORD MAX_MISPLACED_QUEUES_IN_EMPTY_LIST = 100;


//Callback for retry
void CDomainMappingTable::SpecialRetryCallback(PVOID pvContext)
{
    CDomainMappingTable *pdnt = (CDomainMappingTable *) pvContext;
    _ASSERT(pdnt);
    _ASSERT(DOMAIN_MAPPING_TABLE_SIG == pdnt->m_dwSignature);

    dwInterlockedUnsetBits(&(pdnt->m_dwFlags), DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
    pdnt->ProcessSpecialLinks(0, FALSE);
}

//---[ ReUnreachableErrorToAqueueError ]---------------------------------------
//
//
//  Description:
//      Translates a HRESULT returned from GetNextHop to one that is meaningful
//      to aqueue DSN generation.
//  Parameters:
//      IN HRESULT reErr -- Error from routing.
//      IN OUT HRESULT aqErr -- Corresponding aqueue error code.
//  Returns:
//      Nothing.
//  History:
//      GPulla created.
//
//-----------------------------------------------------------------------------
void ReUnreachableErrorToAqueueError(HRESULT reErr, HRESULT *aqErr)
{
    //
    //  Temporary errors for testing only: I'll change these when
    //  WayneC checks in the header file with the RE_E_ errors for
    //  access-denied and message-too-large (that should be later
    //  today).
    //
    if(E_ACCESSDENIED == reErr)
        *aqErr = AQUEUE_E_ACCESS_DENIED;

    else if(HRESULT_FROM_WIN32(ERROR_MESSAGE_EXCEEDS_MAX_SIZE) == reErr)
        *aqErr = AQUEUE_E_MESSAGE_TOO_LARGE;

    else
        *aqErr = AQUEUE_E_NDR_ALL;

}

//---[ DeinitDomainEntryIteratorFn ]--------------------------------------------
//
//
//  Description:
//      Deletes and releases all internal domain info objects in table
//  Parameters:
//          IN  pvContext   - pointer to context (ignored)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      6/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID DeinitDomainEntryIteratorFn(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    *pfDelete = FALSE;
    *pfContinue = TRUE;
    pdentry->HrDeinitialize();
}

//---[ ReleaseDomainEntryIteratorFn ]------------------------------------------
//
//
//  Description:
//      Deletes and releases all internal domain info objects in table
//  Parameters:
//          IN  pvContext   - pointer to context (ignored)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      6/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID ReleaseDomainEntryIteratorFn(PVOID pvContext, PVOID pvData, BOOL fWildcard,
                    BOOL *pfContinue, BOOL *pfDelete)
{
    ULONG   cRefs;
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    *pfDelete = TRUE;
    *pfContinue = TRUE;
    cRefs = pdentry->Release();
    _ASSERT(!cRefs && "leaking domain entries");
}

//***[ CDomainMapping Methods ]************************************************

//---[ CDomainMapping::Clone ]-------------------------------------------------
//
//
//  Description: Fills the current mapping with data from another DomainMapping
//
//  Parameters:
//      IN pdmap    CDomainMapping to clone
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CDomainMapping::Clone(IN CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMapping::Clone");
    Assert(pdmap);
    m_pdentryDomainID = pdmap->m_pdentryDomainID;
    m_pdentryQueueID  = pdmap->m_pdentryQueueID;
    TraceFunctLeave();
}

//---[ CDomainMapping::HrGetDestMsgQueue ]-------------------------------------
//
//
//  Description: Returns a pointer to the queue that this mapping points to
//
//  Parameters:
//      IN  paqmt    Message Type to get queue for
//      OUT ppdmq    pointer returned
//
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN
//
//-----------------------------------------------------------------------------
HRESULT CDomainMapping::HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                                          OUT CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMapping::HrGetDestMsgQueue");
    HRESULT hr = S_OK;
    Assert(ppdmq);

    if (m_pdentryQueueID == NULL)
    {
        hr = AQUEUE_E_INVALID_DOMAIN;
        goto Exit;
    }

    hr = m_pdentryQueueID->HrGetDestMsgQueue(paqmt, ppdmq);

  Exit:
    TraceFunctLeave();
    return hr;
}

//***[ CDomainEntry Methods ]**************************************************

//---[ CDomainEntry::CDomainEntry() ]------------------------------------------
//
//
//  Description: CDomainEntry constructor
//
//  Parameters:
//      paqinst    - ptr to the virtual server object
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainEntry::CDomainEntry(CAQSvrInst *paqinst) :
            m_slPrivateData("CDomainEntry")
{
    _ASSERT(paqinst);
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::CDomainEntry");
    //Create a mapping that is not compressed
    m_dmap.m_pdentryDomainID = this;
    m_dmap.m_pdentryQueueID = this;
    m_dwSignature = DOMAIN_ENTRY_SIG;

    //init pointers
    m_szDomainName = NULL;
    m_cbDomainName = 0;
    InitializeListHead(&m_liDestQueues);
    InitializeListHead(&m_liLinks);

    m_cLinks = 0;
    m_cQueues = 0;

    m_paqinst = paqinst;
    m_paqinst->AddRef();

    TraceFunctLeave();
}

//---[ CDomainEntry::~CDomainEntry() ]-----------------------------------------
//
//
//  Description: CDomainEntry destructor
//
//  Parameters:
//      -
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainEntry::~CDomainEntry()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::~CDomainEntry");
    PLIST_ENTRY pli = NULL; //used to iterate over lists
    CDestMsgQueue *pdmq = NULL;
    CLinkMsgQueue  *plmq = NULL;

    //Remove all DestMsgQueues from list
    while (!IsListEmpty(&m_liDestQueues))
    {
        pli = m_liDestQueues.Flink;
        _ASSERT((pli != &m_liDestQueues) && "List Macros are broken");
        pdmq = CDestMsgQueue::pdmqGetDMQFromDomainListEntry(pli);
        pdmq->RemoveQueueFromDomainList();
        pdmq->Release();
        m_cQueues--;
    }

    //Remove all links from list
    while (!IsListEmpty(&m_liLinks))
    {
        pli = m_liLinks.Flink;
        plmq = CLinkMsgQueue::plmqGetLinkMsgQueue(pli);
        plmq->fRemoveLinkFromList();
        plmq->Release();
        m_cLinks--;
        _ASSERT((pli != &m_liLinks) && "List Macros are broken");
    }

    FreePv(m_szDomainName);

    if (m_paqinst)
        m_paqinst->Release();

    TraceFunctLeave();
}

//---[ CDomainEntry::HrInitialize ]--------------------------------------------
//
//
//  Description: Initilizer for CDomainEntry.  This should be called BEFORE the
//      entry is inserted into the DMT where other threads can access it.
//
//  Parameters:
//      szDomainName    string of domain name for entry, will *NOT* be copied, this
//                      object will take control of this. This will save a unneeded
//                      buffer copy and allocation per domain entry
//      pdentryQueueID  ptr to the primary entry for this domain (usually this)
//      pdmq            ptr to DestMsgQueue
//      plmq            ptr to LinkMsgQueue to allocate
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if any allocation fails
//
//  It is expected that this is only called by the DMT while creating an entry
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrInitialize(DWORD cbDomainName, LPSTR szDomainName,
                           CDomainEntry *pdentryQueueID, CDestMsgQueue *pdmq,
                           CLinkMsgQueue *plmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrInitialize");
    Assert(szDomainName);
    Assert((pdentryQueueID == this) || (pdmq == NULL));

    HRESULT hr = S_OK;

    m_cbDomainName = cbDomainName;
    m_szDomainName = szDomainName;

    //write domain mapping
    m_dmap.m_pdentryDomainID = this;
    m_dmap.m_pdentryQueueID  = pdentryQueueID;

    //add the queue to our list of queues
    if (pdmq)
    {
        m_slPrivateData.ExclusiveLock();
        m_cQueues++;
        pdmq->AddRef();
        pdmq->InsertQueueInDomainList(&m_liDestQueues);
        m_slPrivateData.ExclusiveUnlock();
    }

    if (plmq)
    {
        m_slPrivateData.ExclusiveLock();
        m_cLinks++;
        plmq->AddRef();
        plmq->InsertLinkInList(&m_liLinks);
        m_slPrivateData.ExclusiveUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrDeinitialize ]------------------------------------------
//
//
//  Description: Deinitializer for CDomainEntry
//
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrDeinitialize");
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL; //used to iterate over lists
    CDestMsgQueue *pdmq = NULL;
    CLinkMsgQueue *plmq = NULL;

    m_slPrivateData.ExclusiveLock();
    while (!IsListEmpty(&m_liDestQueues))
    {
        pli = m_liDestQueues.Flink;
        _ASSERT((pli != &m_liDestQueues) && "List Macros are broken");
        pdmq = CDestMsgQueue::pdmqGetDMQFromDomainListEntry(pli);
        pdmq->HrDeinitialize();
        pdmq->RemoveQueueFromDomainList();
        pdmq->Release();
        m_cQueues--;
        pdmq = NULL;
    }

    //Remove all links from list
    while (!IsListEmpty(&m_liLinks))
    {
        pli = m_liLinks.Flink;
        plmq = CLinkMsgQueue::plmqGetLinkMsgQueue(pli);
        plmq->HrDeinitialize();
        plmq->fRemoveLinkFromList();
        plmq->Release();
        m_cLinks--;
        _ASSERT((pli != &m_liLinks) && "List Macros are broken");
    }

    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    m_slPrivateData.ExclusiveUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrGetDomainMapping ]--------------------------------------
//
//
//  Description: Returns Domain Mapping for this object
//
//  Parameters:
//      OUT pdmap   CDomainMapping for return information
//
//  Returns:
//      S_OK on success
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetDomainMapping(OUT CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetDomainMapping");
    HRESULT hr = S_OK;
    _ASSERT(pdmap);
    pdmap->Clone(&m_dmap);
    TraceFunctLeave();
    return S_OK;
}

//---[ CDomainEntry::HrGetDomainName ]----------------------------------------------
//
//
//  Description: Copies Domain Name. Caller is responsible for freeing string
//
//  Parameters:
//      OUT pszDomainName    string of domain name for entry, will be copied
//
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if any allocation fails
//
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetDomainName(OUT LPSTR *pszDomainName)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetDomainName");
    HRESULT hr = S_OK;
    Assert(pszDomainName);

    if (m_szDomainName == NULL)
    {
        *pszDomainName = NULL;
        goto Exit;
    }

    //Copy domain name
    *pszDomainName = (LPSTR) pvMalloc(m_cbDomainName + sizeof(CHAR));

    if (*pszDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    strcpy(*pszDomainName, m_szDomainName);

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrGetDestMsgQueue ]---------------------------------------
//
//
//  Description: Returns a pointer to the queue that this entry points to
//
//  Parameters:
//      IN  paqmt    Message Type to get domain for
//      OUT ppdmq    pointer returned
//
//  Returns:
//      S_OK on success
//      E_FAIL no queue matching message type is found
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                                        OUT CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetDestMsgQueue");
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CDestMsgQueue *pdmq = NULL;
    _ASSERT(ppdmq);
    _ASSERT(m_dmap.m_pdentryDomainID == this);
    DEBUG_DO_IT(DWORD cQueues = 0);

    if (m_dmap.m_pdentryQueueID == m_dmap.m_pdentryDomainID)
    {
        //this must be the primary entry... scan our own list of queues
        m_slPrivateData.ShareLock();
        pli = m_liDestQueues.Flink;
        while (pli != &m_liDestQueues)
        {
            _ASSERT(m_cQueues >= cQueues);
            DEBUG_DO_IT(cQueues++);
            pdmq = CDestMsgQueue::pdmqIsSameMessageType(paqmt, pli);
            if (pdmq)
                break;

            pli = pli->Flink;
        }
        m_slPrivateData.ShareUnlock();

        if (!pdmq)
            hr = E_FAIL; //no such queue
        else
        {
            pdmq->AddRef();
            *ppdmq = pdmq;
        }
    }
    else
    {
        //we are not primary
        _ASSERT(0 && "Non-primary domain entry... currently only primary entries are supported");
        _ASSERT(IsListEmpty(&m_liDestQueues));  //make sure it matches the profile
        hr = m_dmap.m_pdentryQueueID->HrGetDestMsgQueue(paqmt, ppdmq);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrAddUniqueDestMsgQueue ]---------------------------------
//
//
//  Description:
//      Adds a queue to this entry's list of queues if a queue with the same
//      message type does not already exist.
//
//      Will appropriately AddRef domain.
//  Parameters:
//      IN  pdmqNew         - CDestMsgQueue to add
//      OUT ppdmqCurrent    - Set to curent CDestMsgQueue on failure
//  Returns:
//      S_OK on success
//      E_FAIL if a CDestMsgQueue with same Message type alread exists.
//  History:
//      5/28/98 - MikeSwa Created
//      9/8/98 - MikeSwa Modified to use AddRef/Relase for queues
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrAddUniqueDestMsgQueue(IN  CDestMsgQueue *pdmqNew,
                                OUT CDestMsgQueue **ppdmqCurrent)
{
    _ASSERT(pdmqNew);
    _ASSERT(ppdmqCurrent);
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CDestMsgQueue *pdmq = NULL;
    CAQMessageType *paqmt = pdmqNew->paqmtGetMessageType();
    DEBUG_DO_IT(DWORD cQueues = 0);

    *ppdmqCurrent = NULL;

    m_slPrivateData.ExclusiveLock();
    pli = m_liDestQueues.Flink;

    //First look through list and make sure that there isn't already a
    //queue with this message type
    while (pli != &m_liDestQueues)
    {
        _ASSERT(m_cQueues >= cQueues);
        pdmq = CDestMsgQueue::pdmqIsSameMessageType(paqmt, pli);
        if (pdmq)
        {
            hr = E_FAIL;
            pdmq->AddRef();
            *ppdmqCurrent = pdmq;
            goto Exit;
        }
        DEBUG_DO_IT(cQueues++);
        pli = pli->Flink;
    }

    pdmqNew->AddRef();
    pdmqNew->InsertQueueInDomainList(&m_liDestQueues);
    m_cQueues++;

  Exit:
    m_slPrivateData.ExclusiveUnlock();
    return hr;
}

//---[ CDomainEntry::HrGetLinkMsgQueue ]---------------------------------------
//
//
//  Description:
//      Gets a link for the given schedule id
//  Parameters:
//      IN  paqsched    - ScheduleID to search for
//      OUT pplmq       - returned queue
//  Returns:
//      S_OK on success
//      E_FAIL if no link matching the schudule ID can be found
//  History:
//      6/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrGetLinkMsgQueue(IN CAQScheduleID *paqsched,
                              OUT CLinkMsgQueue **pplmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntry::HrGetLinkMsgQueue");
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CLinkMsgQueue *plmq = NULL;
    _ASSERT(pplmq);
    _ASSERT(m_dmap.m_pdentryDomainID == this);
    DEBUG_DO_IT(DWORD cLinks = 0);

    m_slPrivateData.ShareLock();
    pli = m_liLinks.Flink;
    while (pli != &m_liLinks)
    {
        _ASSERT(m_cLinks >= cLinks);
        DEBUG_DO_IT(cLinks++);
        plmq = CLinkMsgQueue::plmqIsSameScheduleID(paqsched, pli);
        if (plmq)
        {
            plmq->AddRef();
            break;
        }

        pli = pli->Flink;
    }
    m_slPrivateData.ShareUnlock();

    if (!plmq)
        hr = E_FAIL; //no such queue
    else
        *pplmq = plmq;

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntry::HrAddUniqueLinkMsgQueue ]---------------------------------
//
//
//  Description:
//      Inserts a link with a unique schedule ID
//  Parameters:
//      IN  plmqNew     New link to insert
//      OUT plmqCurrent Current link with schedule ID on insert failure
//  Returns:
//      S_OK if insert succeeds
//      E_FAIL if insert fails
//  History:
//      6/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntry::HrAddUniqueLinkMsgQueue(IN  CLinkMsgQueue *plmqNew,
                                    OUT CLinkMsgQueue **pplmqCurrent)
{
    _ASSERT(plmqNew);
    _ASSERT(pplmqCurrent);
    HRESULT hr = S_OK;
    PLIST_ENTRY pli = NULL;
    CLinkMsgQueue *plmq = NULL;
    CAQScheduleID *paqsched = plmqNew->paqschedGetScheduleID();
    DEBUG_DO_IT(DWORD cLinks = 0);

    *pplmqCurrent = NULL;

    m_slPrivateData.ExclusiveLock();
    pli = m_liLinks.Flink;

    //First look through list and make sure that there isn't already a
    //queue with this schedule ID
    while (pli != &m_liLinks)
    {
        _ASSERT(m_cLinks >= cLinks);
        plmq = CLinkMsgQueue::plmqIsSameScheduleID(paqsched, pli);
        if (plmq)
        {
            hr = E_FAIL;
            *pplmqCurrent = plmq;
            plmq->AddRef();
            goto Exit;
        }
        DEBUG_DO_IT(cLinks++);
        pli = pli->Flink;
    }

    plmqNew->InsertLinkInList(&m_liLinks);
    plmqNew->AddRef();
    m_cLinks++;

  Exit:
    m_slPrivateData.ExclusiveUnlock();
    return hr;
}

//---[ CDomainEntry::RemoveDestMsgQueue ]--------------------------------------
//
//
//  Description:
//      Removes empty DMQ from entry.
//  Parameters:
//      IN  pdmq        DMQ to remove from domain entry
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainEntry::RemoveDestMsgQueue(IN CDestMsgQueue *pdmq)
{
    _ASSERT(pdmq && "INVALID Param for internal function");
    m_slPrivateData.ExclusiveLock();
    pdmq->RemoveQueueFromDomainList();
    pdmq->HrDeinitialize();
    pdmq->Release();
    m_cQueues--;
    m_slPrivateData.ExclusiveUnlock();
}

//---[ CDomainEntry::RemoveLinkMsgQueue ]--------------------------------------
//
//
//  Description:
//      Removes an empty LinkMsgQueue from the domain entry
//  Parameters:
//      IN  plmq        Link to remove
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainEntry::RemoveLinkMsgQueue(IN CLinkMsgQueue *plmq)
{
    _ASSERT(plmq && "INVALID Param for internal function");
    m_slPrivateData.ExclusiveLock();
    BOOL fRemove = plmq->fRemoveLinkFromList();
    if (fRemove)
        m_cLinks--;
    m_slPrivateData.ExclusiveUnlock();

    if (fRemove) {

        //do *NOT* call HrDeinitialize here since it will deadlock

        plmq->RemovedFromDMT();
        plmq->Release();
    }
}


//***[ CDomainMappingTable Methods ]*******************************************

//---[ CDomainMappingTable::CDomainMappingTable ]------------------------------
//
//
//  Description: CDomainMappingTable constructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
CDomainMappingTable::CDomainMappingTable() :
            m_slPrivateData("CDomainMappingTable")
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::CDomainMappingTable");
    m_paqinst = NULL;
    m_dwSignature = DOMAIN_MAPPING_TABLE_SIG;
    m_dwInternalVersion = 0;
    m_cOutstandingExternalShareLocks = 0;
    m_cThreadsForEmptyDMQList = 0;

    m_plmqLocal = NULL;
    m_plmqCurrentlyUnreachable = NULL;
    m_plmqUnreachable = NULL;
    m_pmmaqPreCategorized = NULL;
    m_pmmaqPreRouting = NULL;
    m_cSpecialRetryMinutes = 0;
    m_cResetRoutesRetriesPending = 0;

    m_dwFlags = 0;
    InitializeListHead(&m_liEmptyDMQHead);
    TraceFunctLeave();
}

//---[ CDomainMappingTable::~CDomainMappingTable ]------------------------------------------------------------
//
//
//  Description: CDomainMappingTable destructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
CDomainMappingTable::~CDomainMappingTable()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::~CDomainMappingTable");

    //Remove everything from the table
    m_dnt.HrIterateOverSubDomains(NULL, ReleaseDomainEntryIteratorFn, NULL);

    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    if (m_plmqLocal)
        m_plmqLocal->Release();

    if (m_plmqCurrentlyUnreachable)
        m_plmqCurrentlyUnreachable->Release();

    if (m_plmqUnreachable)
        m_plmqUnreachable->Release();

    if (m_pmmaqPreCategorized)
        m_pmmaqPreCategorized->Release();

    if (m_pmmaqPreRouting)
        m_pmmaqPreRouting->Release();

    _ASSERT(!m_cOutstandingExternalShareLocks); //there should be no outstanding sharelocks
    TraceFunctLeave();
}

//---[ CDomainMappingTable::HrInitialize ]-------------------------------------
//
//
//  Description: Performs initialization that may return an error code
//
//  Parameters:
//      IN  paqinst     AQ Svr Inst
//      IN  paradmq     Local Async Queue (passed to local link as part
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInitialize(CAQSvrInst *paqinst,
                                          CAsyncRetryAdminMsgRefQueue *paradmq,
                                          CAsyncMailMsgQueue *pammqPreCatQ,
                                          CAsyncMailMsgQueue *pammqPreRoutingQ)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrInitialize");
    HRESULT hr = S_OK;
    HRESULT hrCurrent = S_OK;
    _ASSERT(paqinst);
    m_paqinst = paqinst;
    m_paqinst->AddRef();

    //------Link for local Queue-----------------------------------------------
    m_plmqLocal = new CLocalLinkMsgQueue(paradmq, g_sGuidLocalLink);
    if (!m_plmqLocal)
        hr = E_OUTOFMEMORY;

    hrCurrent = HrInializeGlobalLink(LOCAL_LINK_NAME,
                                    sizeof(LOCAL_LINK_NAME) - sizeof(CHAR),
                                    (CLinkMsgQueue **) &m_plmqLocal,
                                    LA_KICK,
                                    LI_TYPE_LOCAL_DELIVERY);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //------Link for currently unreachable Queue-------------------------------
    hrCurrent = HrInializeGlobalLink(CURRENTLY_UNREACHABLE_LINK_NAME,
                                    sizeof(CURRENTLY_UNREACHABLE_LINK_NAME) - sizeof(CHAR),
                                    &m_plmqCurrentlyUnreachable,
                                    0,
                                    LI_TYPE_CURRENTLY_UNREACHABLE);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    hrCurrent = HrInializeGlobalLink(UNREACHABLE_LINK_NAME,
                                    sizeof(UNREACHABLE_LINK_NAME) - sizeof(CHAR),
                                    &m_plmqUnreachable,
                                    0,
                                    LI_TYPE_INTERNAL);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //-------Link for precat Queue---------------------------------------------
    m_pmmaqPreCategorized = new CMailMsgAdminQueue(g_sGuidPrecatLink, PRECAT_QUEUE_NAME,
                                       pammqPreCatQ, LA_KICK, LI_TYPE_PENDING_CAT);

    if (!m_pmmaqPreCategorized)
        hr = E_OUTOFMEMORY;

    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //-------Link for prerouting Queue-----------------------------------------
    m_pmmaqPreRouting = new CMailMsgAdminQueue(g_sGuidPreRoutingLink, PREROUTING_QUEUE_NAME,
                                       pammqPreRoutingQ, LA_KICK, LI_TYPE_PENDING_ROUTING);

    if (!m_pmmaqPreRouting)
        hr = E_OUTOFMEMORY;

    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //-------------------------------------------------------------------------

    hrCurrent = m_dnt.HrInit();
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrDeinitialize ]-----------------------------------
//
//
//  Description: Performs cleanup that may return an error code
//
//  Parameters: -
//
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrCurrent = S_OK;

    hr = m_dnt.HrIterateOverSubDomains(NULL, DeinitDomainEntryIteratorFn, NULL);

    //Deinitialize global special links
    hrCurrent = HrDeinitializeGlobalLink((CLinkMsgQueue **) &m_plmqLocal);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    hrCurrent = HrDeinitializeGlobalLink(&m_plmqCurrentlyUnreachable);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    hrCurrent = HrDeinitializeGlobalLink(&m_plmqUnreachable);
    if (FAILED(hrCurrent) && SUCCEEDED(hr))
        hr = hrCurrent;

    //NOTE: This *must* come after Deinitialize of entries
    if (m_paqinst)
    {
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    TraceFunctLeave();
    return hr;
}


//---[ <CDomainMappingTable::HrInializeGlobalLink ]-----------------------------
//
//
//  Description:
//      Initializes a single global link for the DMT.  Configures link to not
//      send notifications to the connection manager, and to
//  Parameters:
//      IN  szLinkName              The link name to use for the link
//      IN  cbLinkName              The string length of the link name
//      OUT pplmq                   Link to allocate/initialize
//      IN  dwSupportedActions    Bitmask specifying what actions are supported on this link
//      IN  dwLinkType              Link type to be returned to admin (LI_TYPE)
//  Returns:
//
//  History:
//      1/27/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInializeGlobalLink(IN  LPCSTR szLinkName,
                                                  IN  DWORD  cbLinkName,
                                                  OUT CLinkMsgQueue **pplmq,
                                                  DWORD dwSupportedActions,
                                                  DWORD dwLinkType)
{
    HRESULT hr = S_OK;

    _ASSERT(pplmq);

    if (!*pplmq)
        *pplmq = new CLinkMsgQueue();

    if (*pplmq)
    {
        //Initialize local queue
        hr = (*pplmq)->HrInitialize(m_paqinst, NULL, cbLinkName,
                                     (LPSTR) szLinkName,
                                     eLinkFlagsAQSpecialLinkInfo, NULL);

        //Set flags so no connections will be made for this link
        (*pplmq)->dwModifyLinkState(   LINK_STATE_PRIV_NO_NOTIFY |
                                       LINK_STATE_PRIV_NO_CONNECTION,
                                       LINK_STATE_NO_ACTION );

        (*pplmq)->SetSupportedActions(dwSupportedActions);
        (*pplmq)->SetLinkType(dwLinkType);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//---[ CDomainMappingTable::HrDeinitializeGlobalLink ]-------------------------
//
//
//  Description:
//      Deinitializes a single global link for the DMT
//  Parameters:
//      IN OUT pplmq        Link to deinitialze / set to NULL
//  Returns:
//      S_OK on success
//      ERROR code from CLinkMsgQueue::HrDeinitialize();
//  History:
//      1/27/99 - MikeSwa Created
//      7/21/99 - MikeSwa Modified - removed free of link domain
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrDeinitializeGlobalLink(IN OUT CLinkMsgQueue **pplmq)
{
    HRESULT hr = S_OK;

    _ASSERT(pplmq);
    if (pplmq && *pplmq)
    {
        hr = (*pplmq)->HrDeinitialize();
        (*pplmq)->Release();
        *pplmq = NULL;
    }
    return hr;
}


//---[ CDomainMappingTable::HrMapDomainName ]----------------------------------
//
//
//  Description:
//      Looks up a DomainName in the DMT.  Will create a new entry if necessary
//
//  Parameters:
//      IN  szDomainName        Domain Name to map
//      IN  paqmtMessageType    Message type as returned by routing
//      IN  pIMessageRouter     IMessageRouter for this message
//      OUT pdmap               Mapping returned - allocated by caller
//      OUT ppdmq               ptr to Queue
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if an allocation fails
//      HRESULT_FROM_WIN32(ERROR_RETRY) if mapping data changes and entire
//          message should be re-mapped
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrMapDomainName(
                IN LPSTR szDomainName,
                IN CAQMessageType *paqmtMessageType,
                IN IMessageRouter *pIMessageRouter,
                OUT CDomainMapping *pdmap,
                OUT CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrMapDomainName");
    _ASSERT(pdmap);
    _ASSERT(ppdmq);
    _ASSERT(szDomainName);
    _ASSERT(szDomainName[0] && "unsupported config - RAID #68208");
    _ASSERT(pIMessageRouter);

    HRESULT                 hr            = S_OK;
    CDomainEntry           *pdentryResult = NULL;
    CDomainEntry           *pdentryExisting = NULL;
    DWORD                   cbDomainName  = 0;
    CInternalDomainInfo    *pIntDomainInfo= NULL;
    BOOL                    fLocal        = FALSE; //Is delivery local?
    BOOL                    fWalkEmptyList= FALSE;
    DOMAIN_STRING           strDomain; //allows quicker lookups/inserts
    CLinkMsgQueue          *plmq          = NULL;

    *ppdmq = NULL;
    cbDomainName = strlen(szDomainName)*sizeof(CHAR);
    INIT_DOMAIN_STRING(strDomain, cbDomainName, szDomainName);

    m_slPrivateData.ShareLock();
    hr = m_dnt.HrFindDomainName(&strDomain, (PVOID *) &pdentryResult);

    //
    //  If succeeded aquire usage lock before we give up DMT lock.
    //  Handle failure cases after releasing lock.
    // 
    if (SUCCEEDED(hr))
    {
        pdentryResult->AddRef();
    }

    fWalkEmptyList = fNeedToWalkEmptyQueueList();
    m_slPrivateData.ShareUnlock();

    //
    //  Check and see if we need to delete empty queues.
    //
    if (fWalkEmptyList)
    {
        if (fDeleteExpiredQueues())
        {
            //something has changes
            hr = HRESULT_FROM_WIN32(ERROR_RETRY);
            goto Exit;
        }
    }

    if (hr == DOMHASH_E_NO_SUCH_DOMAIN) //gotta create a new entry
    {
        DebugTrace((LPARAM) this, "Creating new DMT entry");
        pdentryResult = new CDomainEntry(m_paqinst);
        if (NULL == pdentryResult)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        _ASSERT(m_paqinst);
        hr = m_paqinst->HrGetInternalDomainInfo(cbDomainName, szDomainName, &pIntDomainInfo);
        if (FAILED(hr))
        {
            //It must match the "*" domain at least
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            goto Exit;
        }
        else
        {
            _ASSERT(pIntDomainInfo);
            if (pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
                DOMAIN_INFO_LOCAL_MAILBOX)
            {
                DebugTrace((LPARAM) NULL, "INFO: Local delivery queued.");
                fLocal = TRUE;
            }
        }

        //perform  initialization of domain entry... create queues if needed
        if (fLocal)
        {
            hr = HrInitLocalDomain(pdentryResult, &strDomain,
                        paqmtMessageType, pdmap);
        }
        else
        {
            hr = HrInitRemoteDomain(pdentryResult, &strDomain, pIntDomainInfo,
                        paqmtMessageType, pIMessageRouter, pdmap, ppdmq, &plmq);
        }

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: Initializing %s domain %s - hr 0x%08X",
                (fLocal ? "local" : "remote"), szDomainName, hr);
            goto Exit;
        }

        m_slPrivateData.ExclusiveLock();

        hr = HrPrvInsertDomainEntry(&strDomain, pdentryResult, FALSE, &pdentryExisting);


        //Need to release exclusive lock in if/else clause

        if (SUCCEEDED(hr))  //the insertion succeeded
        {
            pdentryResult->AddRef();
            m_slPrivateData.ExclusiveUnlock();
            DebugTrace((LPARAM) szDomainName, "INFO: Creating new entry in DMT for domain %s", szDomainName);
            _ASSERT((fLocal || *ppdmq) && "Out param should be set here!");  //skip past getting value from table
            if (!fLocal)
                hr = plmq->HrAddQueue(*ppdmq);
            goto Exit;
        }
        else if (DOMHASH_E_DOMAIN_EXISTS == hr) //another inserted first
        {
            hr = S_OK; //not really a failure
            DebugTrace((LPARAM) this, "Another thread inserted in the the DMT before us");
            pdentryExisting->AddRef();
            m_slPrivateData.ExclusiveUnlock();

            _ASSERT(pdentryExisting != pdentryResult);

            //release entry that we could not insert and replace with entry currently
            //in the table
            pdentryResult->HrDeinitialize();
            pdentryResult->Release();
            pdentryResult = NULL;
            pdentryResult = pdentryExisting;

            //Release queue if we have one
            if (*ppdmq)
            {
                (*ppdmq)->Release();
                *ppdmq = NULL;
            }

        }
        else
        {
            m_slPrivateData.ExclusiveUnlock();
            //general failure to insert

            //We must deinitialize the entry to force it to release any
            //queues and links associated with it.
            pdentryResult->HrDeinitialize();
            goto Exit;
        }
    }

    if (!*ppdmq & !fLocal) //we did not create entry in the table
    {
        _ASSERT(pdentryResult);

        //
        //  Prefix wants us to to more than assert.  
        //      If HrFindDomainName() fails silently or 
        //      fails with an error other than AQUEUE_E_INVALID_DOMAIN,
        //      will will hit this code path
        //
        if (!pdentryResult) 
        {
            //
            //  Make sure HR is set.
            //
            if (SUCCEEDED(hr))
                hr = E_FAIL;

            goto Exit;
        }

        //Domain Name already exists in table
        //At this point, we need to pull an existing entry from the mapping
        //get domain mapping
        hr = pdentryResult->HrGetDomainMapping(pdmap);
        if (FAILED(hr))
            goto Exit;

        //get queue
        hr = pdentryResult->HrGetDestMsgQueue(paqmtMessageType, ppdmq);
        if (FAILED(hr))
        {
            //entry exists, but no queue for our message type
            _ASSERT(NULL == *ppdmq); //cannot fail if we create queue

            //$$TODO cache domain config on entry
            if (!pIntDomainInfo)
            {
                hr = m_paqinst->HrGetInternalDomainInfo(cbDomainName, szDomainName,
                                            &pIntDomainInfo);
                if (FAILED(hr))
                {
                    //It must match the "*" domain at least
                    _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
                    goto Exit;
                }
            }

            _ASSERT(pIntDomainInfo);
            if (!(pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
                DOMAIN_INFO_LOCAL_MAILBOX))
            {
                //this is a not a local domain entry
                hr = HrCreateQueueForEntry(pdentryResult, &strDomain, pIntDomainInfo,
                                paqmtMessageType, pIMessageRouter, pdmap, ppdmq);
                if (FAILED(hr))
                    goto Exit;
            }
            else
            {
                fLocal = TRUE;
            }

        }
    }
    _ASSERT((*ppdmq || fLocal) && "Non-local domains must have queue ptrs!");

  Exit:

    if (FAILED(hr)) //cleanup
    {
        if (pdentryResult)
        {
            pdentryResult->Release();
        }

        if (*ppdmq)
        {
            (*ppdmq)->Release();
            *ppdmq = NULL;
        }
    }
    else
    {
        if (*ppdmq) {
            // send link state notification saying that the link has
            // been created
            (*ppdmq)->SendLinkStateNotification();
        }
        if (pdentryResult) pdentryResult->Release();
    }

    if (plmq)
        plmq->Release();

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrPrvGetDomainEntry ]------------------------------
//
//
//  Description:
//      Internal private function to lookup Domain entry for given domain
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      IN      fDMTLocked              TRUE if locks are already
//      OUT     ppdentry                Domain Entry for domain (from DMT)
//  Returns:
//      S_OK on success
//      AQUEUE_E_INVALID_DOMAIN if domain is not found
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrPrvGetDomainEntry(IN  DWORD cbDomainNameLength,
                      IN  LPSTR szDomainName, BOOL fDMTLocked,
                      OUT CDomainEntry **ppdentry)
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;
    DOMAIN_STRING strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(ppdentry);

    INIT_DOMAIN_STRING(strDomain, cbDomainNameLength, szDomainName);

    if (!fDMTLocked)
    {
        m_slPrivateData.ShareLock();
        fLocked = TRUE;
    }

    hr = m_dnt.HrFindDomainName(&strDomain, (PVOID *) ppdentry);
    if (FAILED(hr))
    {
        if (DOMHASH_E_NO_SUCH_DOMAIN == hr)
            hr = AQUEUE_E_INVALID_DOMAIN;
        _ASSERT(NULL == *ppdentry);
        goto Exit;
    }

    (*ppdentry)->AddRef();

  Exit:

    if (fLocked)
        m_slPrivateData.ShareUnlock();

    return hr;
}

//---[ CDomainMappingTable::HrPrvInsertDomainEntry ]---------------------------
//
//
//  Description:
//      Private wrapper function for HrInsertDomainName
//  Parameters:
//      IN  pstrDomainName      Domain Name to insert in DNT
//      IN  pdnetryNew          DomainEntry to insert
//      IN  fTreadAsWildcard    TRUE if DNT to be told to treat as wildcard
//      OUT pdentryOld          Existing DomainEntry if there is one
//  Returns:
//
//  History:
//      10/5/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrPrvInsertDomainEntry(
                     IN  PDOMAIN_STRING  pstrDomainName,
                     IN  CDomainEntry *pdentryNew,
                     IN  BOOL  fTreatAsWildcard,
                     OUT CDomainEntry **ppdentryOld)
{
    HRESULT hr = S_OK;

    hr = m_dnt.HrInsertDomainName(pstrDomainName, pdentryNew, fTreatAsWildcard,
                                  (PVOID *) ppdentryOld);
    if (E_INVALIDARG == hr)
        hr = PHATQ_BAD_DOMAIN_SYNTAX;

    return hr;

}

//---[ CDomainMappingTable::HrInitLocalDomain ]--------------------------------
//
//
//  Description:
//      Performs initialization needed for a local domain when an entry is
//      created in the DMT
//  Parameters:
//      IN OUT pdentry - entry to init
//      IN     pStrDomain - domain name of entry
//      IN     paqmtMessageType Message Type of message
//      OUT    pdmap - Domain Mapping for domain
//  Returns:
//      S_OK  - when all succeeds
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInitLocalDomain(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CAQMessageType *paqmtMessageType,
                            OUT    CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrInitLocalDomain");
    HRESULT hr = S_OK;
    LPSTR   szKey = NULL;

    _ASSERT(pdentry);
    _ASSERT(pStrDomain);
    _ASSERT(pdmap);
    _ASSERT('\0' == pStrDomain->Buffer[pStrDomain->Length]);

    //make copy of string to store in domain entry
    szKey = (LPSTR) pvMalloc(pStrDomain->Length + sizeof(CHAR));
    if (szKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    strcpy(szKey, pStrDomain->Buffer);

    //passes ownership of szKey
    hr = pdentry->HrInitialize(pStrDomain->Length, szKey, pdentry, NULL, NULL);
    if (FAILED(hr))
        goto Exit;

    hr = pdentry->HrGetDomainMapping(pdmap);
    if (FAILED(hr))
        goto Exit;

  Exit:

    if (FAILED(hr) && szKey)
        FreePv(szKey);

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrInitRemoteDomain ]--------------------------------
//
//
//  Description:
//      Performs initialization needed for a remote domain when an entry is
//      created in the DMT.
//  Parameters:
//      IN     pdentry - entry to init
//      IN     pStrDomain - domain name of entry
//      IN     pIntDomainInfo - Internal config info for domain
//      IN     paqmtMessageType - Message type returned by routing
//      IN     pIMessageRouter - Message Router interface for this message
//      OUT    pdmap - Domain Mapping for domain
//      OUT    ppdmq - destmsgqueue for domain
//      OUT    pplmq - LinkMsgQueue that this queue should be associated with
//                  caller should call HrAddQueue once entry is in DMT
//  Returns:
//      S_OK   on success.
//      E_OUTOFMEMORY when allocations fail
//  History:
//      6/24/98 - Mikeswa Modified... added pplmq param and removed call to
//              HrAddQueue
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrInitRemoteDomain(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            OUT    CDomainMapping *pdmap,
                            OUT    CDestMsgQueue **ppdmq,
                            OUT    CLinkMsgQueue **pplmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrInitRemoteDomain");
    HRESULT hr = S_OK;
    HRESULT hrRoutingDiag = S_OK;
    LPSTR   szKey = NULL;
    CDestMsgQueue          *pdmq          = NULL;
    CLinkMsgQueue          *plmq          = NULL;
    BOOL    fEntryInit = FALSE;

    _ASSERT(ppdmq);
    _ASSERT(pplmq);
    _ASSERT(pdentry);
    _ASSERT(pStrDomain);
    _ASSERT(pdmap);
    _ASSERT(pIMessageRouter);
    _ASSERT('\0' == pStrDomain->Buffer[pStrDomain->Length]);

    //Initialze out params
    *ppdmq = NULL;
    *pplmq = NULL;

    //make copy of string to store in domain entry
    szKey = (LPSTR) pvMalloc(pStrDomain->Length + sizeof(CHAR));
    if (szKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    strcpy(szKey, pStrDomain->Buffer);

    hr = HrGetNextHopLink(pdentry, szKey, pStrDomain->Length, pIntDomainInfo,
            paqmtMessageType, pIMessageRouter, FALSE, &plmq, &hrRoutingDiag);
    if (FAILED(hr))
        goto Exit;

    pdmq = new CDestMsgQueue(m_paqinst, paqmtMessageType, pIMessageRouter);
    if (!pdmq)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //passes ownership of szKey & pdmq
    hr = pdentry->HrInitialize(pStrDomain->Length, szKey, pdentry, pdmq, NULL);
    if (FAILED(hr))
        goto Exit;

    fEntryInit = TRUE; //we cannot delete pdmq or szKey now

    //get the newly created domain mapping so we can initialize the queue
    hr = pdentry->HrGetDomainMapping(pdmap);
    if (FAILED(hr))
        goto Exit;

    //Initialize queue to use this domain mapping using the DomainMapping we just got
    hr = pdmq->HrInitialize(pdmap);
    if (FAILED(hr))
        goto Exit;

    //Associate link with DMQ
    pdmq->SetRouteInfo(plmq);

    //Set routing error if there was one.
    pdmq->SetRoutingDiagnostic(hrRoutingDiag);

    *ppdmq = pdmq;
    *pplmq = plmq;

  Exit:

    //Cleanup failure cases
    if (FAILED(hr) && !fEntryInit)
    {
        if (szKey)
            FreePv(szKey);

        if (NULL != pdmq)
        {
            //once domain entry has been initialized, it owns pdmq
            pdmq->HrDeinitialize();
            pdmq->Release();
            _ASSERT(NULL == *ppdmq);
        }

        if (NULL != plmq)
        {
            plmq->HrDeinitialize();
        }
    }

    if (plmq && !*pplmq) //we haven't passed refernce to OUT param
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrCreateQueueForEntry ]----------------------------
//
//
//  Description:
//      Create a new queue for an already existing domain entry.
//
//      Currently, this is done by creating a new queue and link, and
//      attempting to associate the queue with the domain entry.
//  Parameters:
//      IN     pdentry - entry to add queue to
//      IN     pStrDomain - domain name of entry
//      IN     pIntDomainInfo - Internal config info for domain
//      IN     paqmtMessageType - Message type returned by routing
//      IN     pIMessageRouter - Message Router interface for this message
//      IN     pdmap - Domain Mapping for domain
//      OUT    ppdmq - destmsgqueue for domain
//  Returns:
//      S_OK on succcess
//  History:
//      6/2/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrCreateQueueForEntry(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     CDomainMapping *pdmap,
                            OUT    CDestMsgQueue **ppdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrCreateQueueForEntry");
    _ASSERT(pdentry);
    HRESULT hr = S_OK;
    HRESULT hrRoutingDiag = S_OK;
    CDestMsgQueue   *pdmq   = NULL;
    CLinkMsgQueue   *plmq   = NULL;
    LPSTR           szKey   = pdentry->szGetDomainName();

    *ppdmq = NULL;
    _ASSERT(pStrDomain);
    _ASSERT(pdmap);
    _ASSERT(pIMessageRouter);
    _ASSERT('\0' == pStrDomain->Buffer[pStrDomain->Length]);


    hr = HrGetNextHopLink(pdentry, szKey, pStrDomain->Length, pIntDomainInfo,
            paqmtMessageType, pIMessageRouter, FALSE, &plmq, &hrRoutingDiag);
    if (FAILED(hr))
        goto Exit;

    pdmq = new CDestMsgQueue(m_paqinst, paqmtMessageType, pIMessageRouter);
    if (NULL == pdmq)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    DebugTrace((LPARAM) szKey, "INFO: Creating new Destination Message Queue for domain %s", szKey);

    hr = pdmq->HrInitialize(pdmap);
    if (FAILED(hr))
        goto Exit;

    //Associate link with DMQ
    pdmq->SetRouteInfo(plmq);

    //Set routing error if there was one.
    pdmq->SetRoutingDiagnostic(hrRoutingDiag);

    //Now attempt to associate newly created queue/link pair with domain entry
    hr = pdentry->HrAddUniqueDestMsgQueue(pdmq, ppdmq);

    if (SUCCEEDED(hr))
    {
        *ppdmq = pdmq;

        //Only add the queue in this case... if a queue is already in the entry, then
        //the other thread must have already (or soon will) call HrAddQueue... we
        //should not call it twice.
        hr = plmq->HrAddQueue(*ppdmq);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        DebugTrace((LPARAM) this, "INFO: Thread swap while trying to add queue for domain %s", szKey);
        _ASSERT(*ppdmq != pdmq);
        _ASSERT(*ppdmq && "HrAddUniqueDestMsgQueue failed without returning an error code");
        hr = S_OK; //return new value

        //Remove link from DMQ... since we will never call HrAddQueue
        //don't notify link since it was never added
        pdmq->RemoveDMQFromLink(FALSE);
    }


  Exit:

    //Cleanup failure cases (including if queue created is not used)
    if (FAILED(hr) || (*ppdmq != pdmq))
    {
        if (NULL != pdmq)
        {
            //once domain entry has been initialized, it owns pdmq
            pdmq->Release();
        }
    }

    if (NULL != plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::LogDomainUnreachableEvent] ------------------------
//
//
//  Description:
//      Logs an event for an unreachable domain
//  Parameters:
//      IN  fCurrentlyUnreachable   Is the domain currently unreachable or
//                                     completely unreachable?
//      IN  szDomain                Final destination domain
//  History:
//      3/8/99 - AWetmore Created
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::LogDomainUnreachableEvent(BOOL fCurrentlyUnreachable,
                                      LPCSTR szDomain)
{

    DWORD dwMessageId =
        (fCurrentlyUnreachable) ? AQUEUE_DOMAIN_CURRENTLY_UNREACHABLE
                                : AQUEUE_DOMAIN_UNREACHABLE;

    LPSTR rgszSubStrings[1];

    rgszSubStrings[0] = (char*)szDomain;

    if (m_paqinst)
    {
        m_paqinst->HrTriggerLogEvent(
            dwMessageId,                            // Message ID
            TRAN_CAT_QUEUE_ENGINE,                  // Category
            1,                                      // Word count of substring
            (const char**)&rgszSubStrings[0],       // Substring
            EVENTLOG_WARNING_TYPE,                  // Type of the message
            0,                                      // No error code
            LOGEVENT_LEVEL_MINIMUM,                 // Logging level
            "",                                     // Key to identify this event
            LOGEVENT_FLAG_PERIODIC                  // Event logging option
            );
    }
}

//---[ CDomainMappingTable::HrGetNextHopLink ]------------------------------
//
//
//  Description:
//      Creates and initializes the CLinkMsgQueue object for this message
//      (if neccessary).  Calls router to get next hop info
//  Parameters:
//      IN  pdentry             Entry that is being initialized for destination
//      IN  szDomain            Final destination domain
//      IN  cbDomain            string length in bytes of domain (without \0)
//      IN  pIntDomainInfo      Domain info for final destination domain
//      IN  paqmtMessageType    Message type of this message
//      IN  pIMessageRouter     Routing interface for this message
//      IN  fDMTLocked          TRUE if DMT is already locked
//      OUT pplmq               Resulting link msg queue
//      OUT phrRoutingDiag      If next hop is unreachable, this tells us why
//  Returns:
//      S_OK on success
//  History:
//      6/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrGetNextHopLink(
                            IN     CDomainEntry *pdentry,
                            IN     LPSTR szDomain,
                            IN     DWORD cbDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fDMTLocked,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    HRESULT *phrRoutingDiag)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::HrGetNextHopLink");
    HRESULT hr = S_OK;
    BOOL  fCalledGetNextHop = FALSE;
    BOOL  fValidSMTP = FALSE;
    BOOL  fOwnsScheduleId = FALSE;
    LPSTR szRouteAddressType = NULL;
    LPSTR szRouteAddress = NULL;
    LPSTR szRouteAddressClass = NULL;
    LPSTR szConnectorName = NULL;
    DWORD dwScheduleID = 0;
    DWORD dwNextHopType = 0;
    CLinkMsgQueue *plmq = NULL;
    CLinkMsgQueue *plmqTmp = NULL;
    LPSTR szOwnedDomain = NULL; // string buffer that is "owned" by an entry
    CDomainEntry *pdentryLink = NULL; //entry for link
    CDomainEntry *pdentryTmp = NULL;
    DOMAIN_STRING strNextHop;
    DWORD cbRouteAddress = 0;
    CAQScheduleID aqsched;
    IMessageRouterLinkStateNotification *pILinkStateNotify = NULL;
    LinkFlags lf = eLinkFlagsExternalSMTPLinkInfo;
    *phrRoutingDiag = S_OK;

    _ASSERT(pdentry);
    _ASSERT(szDomain);
    _ASSERT(pIntDomainInfo);
    _ASSERT(paqmtMessageType);
    _ASSERT(pIMessageRouter);
    _ASSERT(pplmq);

    hr = pIMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                                (VOID **) &pILinkStateNotify);
    if (FAILED(hr))
    {
        pILinkStateNotify = NULL;
        hr = S_OK;
    }

    //If we can route this domain.... call router to get next hop
    //We do not route TURN/ETRN domains... or local drop domains
    //Also check to see if the domain is configured as a local domain...
    //if it is, return the local link
    if (DOMAIN_INFO_LOCAL_MAILBOX & pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags)
    {
        //The likely scenario of this happening is if a domain was previously
        //configured as remote and then reconfigured as local.
        m_plmqLocal->AddRef();
        *pplmq = m_plmqLocal;
        goto Exit;
    }
    else if (!(pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
        (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY | DOMAIN_INFO_LOCAL_DROP)))
    {
        hr = pIMessageRouter->GetNextHop(MTI_ROUTING_ADDRESS_TYPE_SMTP, szDomain,
                                    paqmtMessageType->dwGetMessageType(), &szRouteAddressType,
                                    &szRouteAddress, &dwScheduleID, &szRouteAddressClass,
                                    &szConnectorName, &dwNextHopType);

        fCalledGetNextHop = TRUE;
        *pplmq = NULL;

        if(MTI_NEXT_HOP_TYPE_UNREACHABLE == dwNextHopType)
        {
            //If the next hop is unreachable, store the reason for the unreachable
            //error into *phrRoutingDiag (which is used by aqueue DSN generation).

            const char *rgszStrings[2] = { szDomain, NULL };

            if (m_paqinst)
            {
                m_paqinst->HrTriggerLogEvent(
                    PHATQ_UNREACHABLE_DOMAIN,           // Message ID
                    TRAN_CAT_QUEUE_ENGINE,              // Category
                    2,                                  // Word count of substring
                    rgszStrings,                        // Substring
                    EVENTLOG_WARNING_TYPE,              // Type of the message
                    hr,                                 // error code
                    LOGEVENT_LEVEL_FIELD_ENGINEERING,   // Logging level
                    "phatq",                            // key to this event
                    LOGEVENT_FLAG_PERIODIC,             // Logging option
                    1,                                  // index of format message string in rgszStrings
                    GetModuleHandle(AQ_MODULE_NAME)     // module handle to format a message
                );
            }

            ReUnreachableErrorToAqueueError(hr, phrRoutingDiag);
            hr = S_OK;
        }

        if (FAILED(hr))
        {
            RequestResetRoutesRetryIfNecessary();
            ErrorTrace((LPARAM) this,
                "GetNextHop failed with hr - 0x%08X", hr);

            //treat all failures as a routing currently unreachable
            hr = S_OK;
            dwNextHopType = MTI_NEXT_HOP_TYPE_CURRENTLY_UNREACHABLE;
        }


        if (MTI_NEXT_HOP_TYPE_CURRENTLY_UNREACHABLE == dwNextHopType)
        {
            LogDomainUnreachableEvent(TRUE, szDomain);
            *pplmq = m_plmqCurrentlyUnreachable;
        }
        else if (MTI_NEXT_HOP_TYPE_UNREACHABLE == dwNextHopType)
        {
            LogDomainUnreachableEvent(FALSE, szDomain);
            *pplmq = m_plmqUnreachable;
        }
        else if ((MTI_NEXT_HOP_TYPE_SAME_VIRTUAL_SERVER == dwNextHopType) ||
            (szRouteAddressType &&
             lstrcmpi(MTI_ROUTING_ADDRESS_TYPE_SMTP, szRouteAddressType)))
        {
            //Handle any cases that might be considered local delivery
            *pplmq = m_plmqLocal;
        }
        else if (!szRouteAddressType || ('\0' == *szRouteAddressType) ||
                 !szRouteAddress || ('\0' == *szRouteAddress))
        {
            //This is a bogus combination of values... try try again
            hr = E_FAIL;
            goto Exit;
        }
        else
        {
            fValidSMTP = TRUE;
            fOwnsScheduleId = TRUE;
            //At this point we should have valid SMTP values for the address
            _ASSERT(szRouteAddressType);
            _ASSERT(szRouteAddress);
            _ASSERT(!lstrcmpi(MTI_ROUTING_ADDRESS_TYPE_SMTP, szRouteAddressType));

            if (MTI_NEXT_HOP_TYPE_PEER_SMTP1_BYPASS_CONFIG_LOOKUP == dwNextHopType ||
                    MTI_NEXT_HOP_TYPE_PEER_SMTP2_BYPASS_CONFIG_LOOKUP == dwNextHopType) {
                lf = eLinkFlagsInternalSMTPLinkInfo;
            }

        }

        if (!fValidSMTP)
        {
            //Must be going to one of them-there global queues.
            hr = S_OK;

            if (*pplmq)
                (*pplmq)->AddRef();
            else
                hr = E_FAIL;

            //Our work here is done
            goto Exit;
        }

    }

    if ((!fCalledGetNextHop) || (!lstrcmpi(szDomain, szRouteAddress)))
    {
        //final destination and next hop are the same
        DebugTrace((LPARAM) this, "DEBUG: Routing case 1 - same next hop and final dest");
        plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                pILinkStateNotify);
        if (!plmq)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        fOwnsScheduleId = FALSE; //link now owns it
        DebugTrace((LPARAM) szDomain, "INFO: Creating new Link for domain %s", szDomain);

        hr = plmq->HrInitialize(m_paqinst, pdentry, cbDomain, szDomain,
                                lf, szConnectorName);
        if (FAILED(hr))
            goto Exit;

        hr = pdentry->HrAddUniqueLinkMsgQueue(plmq, &plmqTmp);
        if (FAILED(hr))
        {
            //Another link was inserted since we called get link msg queue
            DebugTrace((LPARAM) this, "DEBUG: Routing case 2 - next hop link created by other thread");
            _ASSERT(plmqTmp);
            plmq->HrDeinitialize();
            plmq->Release();
            plmq = plmqTmp;
            hr = S_OK;
        }

    }
    else
    {
        //next hop is different from final destination
        cbRouteAddress = strlen(szRouteAddress);

        //First see if there is an entry for this link
        hr = HrPrvGetDomainEntry(cbRouteAddress, szRouteAddress, fDMTLocked, &pdentryLink);
        if (AQUEUE_E_INVALID_DOMAIN == hr)
        {
            //an entry for this link does not exist... add one for this link
            hr = S_OK;
            DebugTrace((LPARAM) this, "DEBUG: Routing case 3 - next hop entry does not exist");

            szOwnedDomain = (LPSTR) pvMalloc(sizeof(CHAR)*(cbRouteAddress+1));
            if (!szOwnedDomain)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            lstrcpy(szOwnedDomain, szRouteAddress);

            pdentryLink = new CDomainEntry(m_paqinst);
            if (!pdentryLink)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                     pILinkStateNotify);
            if (!plmq)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            fOwnsScheduleId = FALSE; //link now owns it

            //passes ownership of szOwnedDomain
            hr = pdentryLink->HrInitialize(cbRouteAddress, szOwnedDomain,
                                        pdentryLink, NULL, plmq);
            if (FAILED(hr))
                goto Exit;

            hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                    szOwnedDomain, lf, szConnectorName);
            if (FAILED(hr))
                goto Exit;

            //insert entry in DMT
            strNextHop.Length = (USHORT) cbRouteAddress;
            strNextHop.Buffer = szOwnedDomain;
            strNextHop.MaximumLength = (USHORT) cbRouteAddress;

            if (!fDMTLocked)
                m_slPrivateData.ExclusiveLock();

            hr = HrPrvInsertDomainEntry(&strNextHop, pdentryLink, FALSE, &pdentryTmp);

            if (hr == DOMHASH_E_DOMAIN_EXISTS)
            {
                DebugTrace((LPARAM) this, "DEBUG: Routing case 4 - next hop entry did not exist... inserted by other thread");
                plmq->Release();
                plmq = NULL;
                pdentryTmp->AddRef();
                pdentryLink->HrDeinitialize();
                pdentryLink->Release();
                pdentryLink = pdentryTmp;
                hr = S_OK;

                //Will fall through to case as if an entry was found by HrGetDomainEntry
            }
            else if (SUCCEEDED(hr))
            {
                pdentryLink->AddRef();
            }

            if (!fDMTLocked)
                m_slPrivateData.ExclusiveUnlock();

            if (FAILED(hr))
                goto Exit;

        }
        else if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: General DMT failure - hr 0x%08X", hr);
            //general failure... bail
            goto Exit;
        }

        if (!plmq)
        {
            DebugTrace((LPARAM) this, "DEBUG: Routing case 5 - next hop entry exists");
            //An entry exists for this next hop... use link if possible
            // 1 - Get link for this schedule ID.. if it exists use it
            // 2 - Create another link and attempt to insert it
            _ASSERT(pdentryLink);
            aqsched.Init(pIMessageRouter, dwScheduleID);

            hr = pdentryLink->HrGetLinkMsgQueue(&aqsched, &plmq);
            if (FAILED(hr))
            {
                hr = S_OK;
                //link does not exist for this schedule id yet
                DebugTrace((LPARAM) this, "DEBUG: Routing case 6 - next hop link does not exist");

                szOwnedDomain = pdentryLink->szGetDomainName();

                plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                         pILinkStateNotify);
                if (!plmq)
                {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }

                fOwnsScheduleId = FALSE; //link now owns it

                hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                        szOwnedDomain, lf, szConnectorName);
                if (FAILED(hr))
                    goto Exit;

                hr = pdentryLink->HrAddUniqueLinkMsgQueue(plmq, &plmqTmp);
                if (FAILED(hr))
                {
                    //Another link was inserted since we called get link msg queue
                    DebugTrace((LPARAM) this, "DEBUG: Routing case 7 - next hop link created by other thread");
                    _ASSERT(plmqTmp);
                    plmq->Release();
                    plmq = plmqTmp;
                    hr = S_OK;
                }
            }
            else
            {
                DebugTrace((LPARAM) this, "DEBUG: Routing case 8 - next hop link exists");
            }

        }

    }

    _ASSERT(plmq && "We should have allocated a link by this point");
    *pplmq = plmq;

  Exit:

    if (pdentryLink)
        pdentryLink->Release();

    if (fCalledGetNextHop)
    {
        //
        // If we have not passed the schedule ID on to a link, we
        // must notify routing that we are not using it (to avoid a leak).
        // This needs to be be done *before* we release the strings
        // and routing interfaces.  If we hit this case, we have
        // either failed to create a link, or another link has
        // been created by another thread.
        //
        if (fOwnsScheduleId && pILinkStateNotify && pIMessageRouter)
        {
            FILETIME ftNotUsed = {0,0};
            DWORD    dwSetNotUsed = LINK_STATE_NO_ACTION;
            DWORD    dwUnsetNotUsed = LINK_STATE_NO_ACTION;
            pILinkStateNotify->LinkStateNotify(
                                        szDomain,
                                        pIMessageRouter->GetTransportSinkID(),
                                        dwScheduleID,
                                        szConnectorName,
                                        LINK_STATE_LINK_NO_LONGER_USED,
                                        0, //consecutive failures
                                        &ftNotUsed,
                                        &dwSetNotUsed,
                                        &dwUnsetNotUsed);
        }

        //
        // Free Strings returned by GetNextHop
        //
        _VERIFY(SUCCEEDED(pIMessageRouter->GetNextHopFree(
            MTI_ROUTING_ADDRESS_TYPE_SMTP,
            szDomain,
            szConnectorName,
            szRouteAddressType,
            szRouteAddress,
            szRouteAddressClass)));


    }

    if (pILinkStateNotify)
        pILinkStateNotify->Release();

    if (FAILED(hr) && plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::HrGetOrCreateLink ]--------------------------------
//
//
//  Description:
//      Gets or creates a link object for a domain name
//  Parameters:
//      IN  szRouteAddress      Final destination domain
//      IN  cbRouteAddress      string length in bytes of domain (without \0)
//      IN  dwScheduleID        Schedule ID for link (used in create)
//      IN  szConnectorName     Name (stringized GUID) of connector in DS
//      IN  pIMessageRouter     Routing interface for this message (used in create)
//      IN  fCreateIfNotExist   Create the link if it doesn't exist?
//      OUT pplmq               Resulting link msg queue
//      OUT pfRemoveOwnedSchedule   FALSE if a new link was created, TRUE on errors
//                                  and in case the link was addref'ed.
//  Returns:
//      S_OK on success
//  History:
//      7/6/1999 - AWetmore Created
//      12/30/1999 - MikeSwa Modified to not notify until connection attempt
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrGetOrCreateLink(
                            IN     LPSTR szRouteAddress,
                            IN     DWORD cbRouteAddress,
                            IN     DWORD dwScheduleID,
                            IN     LPSTR szConnectorName,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fCreateIfNotExist,
                            IN     DWORD linkFlags,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    BOOL *pfRemoveOwnedSchedule)
{
    TraceFunctEnter("CDomainMappingTable::HrGetOrCreateLink");
    HRESULT hr = S_OK;
    BOOL  fValidSMTP = FALSE;
    LPSTR szRouteAddressType = NULL;
    LPSTR szRouteAddressClass = NULL;
    DWORD dwNextHopType = 0;
    CLinkMsgQueue *plmq = NULL;
    CLinkMsgQueue *plmqTmp = NULL;
    LPSTR szOwnedDomain = NULL; // string buffer that is "owned" by an entry
    CDomainEntry *pdentryLink = NULL; //entry for link
    CDomainEntry *pdentryTmp = NULL;
    DOMAIN_STRING strNextHop;
    CAQScheduleID aqsched;
    IMessageRouterLinkStateNotification *pILinkStateNotify = NULL;
    CAQStats aqstats;
    *pfRemoveOwnedSchedule = TRUE;

    _ASSERT(szRouteAddress);
    _ASSERT(pplmq);

    //First see if there is an entry for this link
    hr = HrPrvGetDomainEntry(cbRouteAddress, szRouteAddress, FALSE, &pdentryLink);
    if (AQUEUE_E_INVALID_DOMAIN == hr && fCreateIfNotExist)
    {
        _ASSERT(pIMessageRouter);
        hr = pIMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                                (VOID **) &pILinkStateNotify);
        if (FAILED(hr)) {
            pILinkStateNotify = NULL;
            goto Exit;
        }

        //an entry for this link does not exist... add one for this link
        hr = S_OK;
        DebugTrace((LPARAM) this, "DEBUG: Routing case 3 - next hop entry does not exist");

        szOwnedDomain = (LPSTR) pvMalloc(sizeof(CHAR)*(cbRouteAddress+1));
        if (!szOwnedDomain)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        lstrcpy(szOwnedDomain, szRouteAddress);

        pdentryLink = new CDomainEntry(m_paqinst);
        if (!pdentryLink)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                 pILinkStateNotify);
        if (!plmq)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        *pfRemoveOwnedSchedule = FALSE;

        //passes ownership of szOwnedDomain
        hr = pdentryLink->HrInitialize(cbRouteAddress, szOwnedDomain,
                                    pdentryLink, NULL, plmq);
        if (FAILED(hr))
            goto Exit;

        hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                szOwnedDomain, (LinkFlags) linkFlags, szConnectorName);
        if (FAILED(hr))
            goto Exit;

        //insert entry in DMT
        strNextHop.Length = (USHORT) cbRouteAddress;
        strNextHop.Buffer = szOwnedDomain;
        strNextHop.MaximumLength = (USHORT) cbRouteAddress;

        m_slPrivateData.ExclusiveLock();

        hr = HrPrvInsertDomainEntry(&strNextHop, pdentryLink, FALSE, &pdentryTmp);

        if (hr == DOMHASH_E_DOMAIN_EXISTS)
        {
            DebugTrace((LPARAM) this, "DEBUG: Routing case 4 - next hop entry did not exist... inserted by other thread");
            plmq->Release();
            plmq = NULL;
            pdentryTmp->AddRef();
            pdentryLink->HrDeinitialize();
            pdentryLink->Release();
            pdentryLink = pdentryTmp;
            hr = S_OK;

            //Will fall through to case as if an entry was found by HrGetDomainEntry
        }
        else if (SUCCEEDED(hr))
        {
            pdentryLink->AddRef();
        }

        m_slPrivateData.ExclusiveUnlock();

        if (FAILED(hr))
            goto Exit;

    }
    else if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "ERROR: General DMT failure - hr 0x%08X", hr);
        //general failure... bail
        goto Exit;
    }

    if (!plmq) {
        _ASSERT(pdentryLink);
        DebugTrace((LPARAM) this, "DEBUG: Routing case 5 - next hop entry exists");
        //An entry exists for this next hop... use link if possible
        // 1 - Get link for this schedule ID.. if it exists use it
        // 2 - Create another link and attempt to insert it
        _ASSERT(pdentryLink);
        aqsched.Init(pIMessageRouter, dwScheduleID);

        hr = pdentryLink->HrGetLinkMsgQueue(&aqsched, &plmq);
        if (FAILED(hr) && fCreateIfNotExist)
        {
            hr = S_OK;
            //link does not exist for this schedule id yet
            DebugTrace((LPARAM) this, "DEBUG: Routing case 6 - next hop link does not exist");

            szOwnedDomain = pdentryLink->szGetDomainName();

            if (!pILinkStateNotify) {
                _ASSERT(pIMessageRouter);
                hr = pIMessageRouter->QueryInterface(IID_IMessageRouterLinkStateNotification,
                                        (VOID **) &pILinkStateNotify);
                if (FAILED(hr)) {
                    pILinkStateNotify = NULL;
                    goto Exit;
                }
            }

            plmq = new CLinkMsgQueue(dwScheduleID, pIMessageRouter,
                                     pILinkStateNotify);
            if (!plmq)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            *pfRemoveOwnedSchedule = FALSE;

            hr = plmq->HrInitialize(m_paqinst, pdentryLink, cbRouteAddress,
                    szOwnedDomain, (LinkFlags) linkFlags, szConnectorName);
            if (FAILED(hr))
                goto Exit;

            hr = pdentryLink->HrAddUniqueLinkMsgQueue(plmq, &plmqTmp);
            if (FAILED(hr))
            {
                //Another link was inserted since we called get link msg queue
                DebugTrace((LPARAM) this, "DEBUG: Routing case 7 - next hop link created by other thread");
                _ASSERT(plmqTmp);
                plmq->Release();
                plmq = plmqTmp;
                hr = S_OK;
            }
        } else {
            DebugTrace((LPARAM) this, "DEBUG: Routing case 8 - next hop link exists");
        }

    }

    _ASSERT(plmq && "We should have allocated a link by this point");

    if (plmq) {

        //We count a SetLinkState as a link state notification.... do not
        //notify again before attempting a connection or we will break link
        //state notifications.
        plmq->dwModifyLinkState(LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION,
                                LINK_STATE_NO_ACTION);
        aqstats.m_dwNotifyType = NotifyTypeNewLink | NotifyTypeLinkMsgQueue;
        aqstats.m_plmq = plmq;
        hr = m_paqinst->HrNotify(&aqstats, TRUE);
    }

    if (SUCCEEDED(hr)) *pplmq = plmq;

  Exit:

    if (pdentryLink)
        pdentryLink->Release();

    if (pILinkStateNotify)
        pILinkStateNotify->Release();

    if (FAILED(hr) && plmq)
        plmq->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainMappingTable::AddDMQToEmptyList ]--------------------------------
//
//
//  Description:
//      Used by DMQ to add itself to the list of empty queues.  This function
//      will aquire (and release) the appropriate locks
//  Parameters:
//      IN  pdmq        DestMsgQueue to add to list
//  Returns:
//      -
//  History:
//      9/12/98 - MikeSwa Created
//      5/5/99  - MikeSwa Changed to TryExclusiveLock to avoid potential
//                deadlock.
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::AddDMQToEmptyList(CDestMsgQueue *pdmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainMappingTable::AddDMQToEmptyList");
    if (m_slPrivateData.TryExclusiveLock())
    {
        pdmq->InsertQueueInEmptyQueueList(&m_liEmptyDMQHead);
        m_slPrivateData.ExclusiveUnlock();
    }
    else
    {
        DebugTrace((LPARAM) this,
            "AddDMQToEmptyList could not get m_slPrivateData Lock");
    }
    TraceFunctLeave();
}

//---[ CDomainMappingTable::fNeedToWalkEmptyQueueList ]------------------------
//
//
//  Description:
//      Checks list of Empty queues to see if we need to call
//      fDeleteExpiredQueues().  The caller of this function *must* have
//      m_slPrivateData is shared mode, if it returns TRUE, the caller *must*
//      release the lock and call fDeleteExpiredQueues() (which will aquire
//      the lock Exclusively)
//  Parameters:
//      -
//  Returns:
//      TRUE if fDeleteExpiredQueues should be called.
//  History:
//      9/12/98 - MikeSwa Created
//      6/27/2000 - MikeSwa fixed short-circuit logic
//
//-----------------------------------------------------------------------------
BOOL CDomainMappingTable::fNeedToWalkEmptyQueueList()
{
    BOOL    fRet = FALSE;
    PLIST_ENTRY pli = m_liEmptyDMQHead.Flink;
    CDestMsgQueue *pdmq = NULL;
    DWORD   dwDMQState = 0;
    DWORD   cMisplacedQueues = 0; //# of queues in list that should not be

    _ASSERT(pli);
    if (m_cThreadsForEmptyDMQList)
        return fRet;  //don't bother is someone else is looking

    while (&m_liEmptyDMQHead != pli)
    {
        pdmq = CDestMsgQueue::pdmqGetDMQFromEmptyListEntry(pli);
        _ASSERT(pdmq);
        dwDMQState = pdmq->dwGetDMQState();

        //See if it is empty and expired.. if so, we have a winner
        if (dwDMQState & CDestMsgQueue::DMQ_EMPTY)
        {
            if (dwDMQState & CDestMsgQueue::DMQ_EXPIRED)
            {
               fRet = TRUE;
               break;
            }
        }
        else
        {
            //
            //  The queue is no longer empty... we will remove it
            //  from this list the next time we have the exclusive
            //  lock.
            //
            cMisplacedQueues++;

            //
            //  If there are a large number of non-empty DMQs, we
            //  want wish to return TRUE even though there are no DMQs to
            //  delete... just so we can clean the list of non-empty DMQs.
            //
            if (MAX_MISPLACED_QUEUES_IN_EMPTY_LIST < cMisplacedQueues)
            {
                fRet = TRUE;
                break;
            }
        }
        pli = pli->Flink;

    }


    //NOTE: An optimization here is to only return TRUE if
    //we have not already retured TRUE while the share lock is held.  This
    //would cause only a single thread to block while it walks the list to
    //remove the expired and non-empty DMQs.
    if (fRet)
    {
        if (1 != InterlockedIncrement((PLONG) &m_cThreadsForEmptyDMQList))
        {
            //we are not the first thread...
            //Let another thread do the dirty work
            fRet = FALSE;

            //This decrement cannot = 0, since someone else has incremented
            //and returned TRUE.  The corresponding dec cannot happen until
            //an Exclusive lock is obtains, which cannot until we release
            //the Shared lock we have now.
            InterlockedDecrement((PLONG) &m_cThreadsForEmptyDMQList);
            _ASSERT(m_cThreadsForEmptyDMQList);
        }
    }


    //NOTE: The reason there may be non-empty queues in this list, is that
    //we cannot remove the queues from the list when we ENQUEUE a message
    //because it would deadlock (we already have the m_slPrivateData lock
    //in shared mode), and removing the queue requires this lock in exclusive
    //mode.
    return fRet;
}

//---[ CDomainMappingTable::fDeleteExpiredQueues ]-----------------------------
//
//
//  Description:
//      Removes DMQs from empty list. DMQs will be deleted if they have expired
//      and do not have any messages on them.  Non-empty DMQs will be removed
//      from the list as well.
//
//      The DMT m_slPrivateData lock should *not* be held when this is called.
//      This function will aquire it exclusively.
//
//  Parameters:
//      -
//  Returns:
//      TRUE if any queues, links, or entries were deleted
//      FALSE if no queues were deleted
//  History:
//      9/12/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CDomainMappingTable::fDeleteExpiredQueues()
{
    PLIST_ENTRY     pli = NULL;
    CDestMsgQueue  *pdmq = NULL;
    CLinkMsgQueue  *plmq = NULL;
    DWORD           dwDMQState = 0;
    CDomainMapping *pdmap = NULL;
    CDomainEntry   *pdentry = NULL;
    CDomainEntry   *pdentryOld = NULL;
    BOOL            fRemovedQueues = FALSE;
    HRESULT         hr = S_OK;
    DOMAIN_STRING   strDomain;

    m_slPrivateData.ExclusiveLock();

    //There should be 1 & only thread here
    _ASSERT(1 == m_cThreadsForEmptyDMQList);
    m_cThreadsForEmptyDMQList--;

    pli = m_liEmptyDMQHead.Flink;
    while (&m_liEmptyDMQHead != pli)
    {
        _ASSERT(pli);
        pdmq = CDestMsgQueue::pdmqGetDMQFromEmptyListEntry(pli);
        _ASSERT(pdmq);
        dwDMQState = pdmq->dwGetDMQState();

        if (!(dwDMQState & CDestMsgQueue::DMQ_EMPTY))
        {
            //If it is not empty - remove it from the list
            pli = pli->Flink;
            pdmq->RemoveQueueFromEmptyQueueList();
            continue;
        }
        else if (!(dwDMQState & CDestMsgQueue::DMQ_EXPIRED))
        {
            //If this queue hasn't expired... check the next to see if it is empty
            pli = pli->Flink;
            continue;
        }
        else
        {
            //We need to delete this DMQ
            pli = pli->Flink;  //get next LIST_ENTRY before we delete the queue

            //Add a reference to the DMQ, so we can guarantee its lifespan
            pdmq->AddRef();

            //Remove the queue from the list of empty queues
            pdmq->RemoveQueueFromEmptyQueueList();

            //Get the domain mapping (and domain entry) for this DMQ
            pdmq->GetDomainMapping(&pdmap);
            _ASSERT(pdmap);
            pdentry = pdmap->pdentryGetQueueEntry();

            //Remove the DMQ from its associated link
            plmq = pdmq->plmqGetLink();
            pdmq->RemoveDMQFromLink(TRUE);
            if (plmq)
            {
                //Remove the link from the DMT if it is empty
                plmq->RemoveLinkIfEmpty();
                plmq->Release();
                plmq = NULL;
            }

            //Now that we have the domain entry, we can remove it the DMQ
            //from it.
            _ASSERT(pdentry);
            pdentry->RemoveDestMsgQueue(pdmq);

            //Remove Entry if needed
            if (pdentry->fSafeToRemove())
            {
                //There are no links or queues left on this entry... we
                //can remove it from the hash table and delete it
                pdentry->InitDomainString(&strDomain);
                hr = m_dnt.HrRemoveDomainName(&strDomain, (void **) &pdentryOld);

                _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN != hr);
                if (SUCCEEDED(hr))
                {
                    _ASSERT(pdentryOld == pdentry);
                    pdentryOld = NULL;
                    pdentry->Release();
                    pdentry = NULL;
                }
            }

            //If there are no enqueues pending, this will be the last reference
            //for the DMQ.  If there is a enqueue pending, then there may be
            //references outstanding that will be released when they see the
            //updated DMT version number.
            pdmq->Release();

            fRemovedQueues = TRUE;
        }
    }

    //Update version number, so other threads will know that queues
    //have been removed from the DMT.
    if (fRemovedQueues)
        m_dwInternalVersion++;

    m_slPrivateData.ExclusiveUnlock();

    return fRemovedQueues;
}


//---[ CDomainMappingTable::RequestResetRoutesRetryIfNecessary ]---------------
//
//
//  Description:
//      This is called when routing fails and we need to call reset routes
//      at a later time to try it.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::RequestResetRoutesRetryIfNecessary()
{
    HRESULT hr = S_OK;

    if (DMT_FLAGS_RESET_ROUTES_IN_PROGRESS & m_dwFlags)
        return;

    dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_GET_NEXT_HOP_FAILED);

    //We need to reqest a callback for a later reset routes. We should
    //only allow one callback pending at a time.  If this thread increments
    //the count for a 0->1 transition, then we can request the callback
    if (1 == InterlockedIncrement((PLONG) &m_cResetRoutesRetriesPending))
    {
        hr = m_paqinst->SetCallbackTime(
                    CDomainMappingTable::RetryResetRoutes,
                    this, g_cResetRoutesRetryMinutes);

        if (FAILED(hr))
            InterlockedDecrement((PLONG) &m_cResetRoutesRetriesPending);
    }
}

//---[ CDomainMappingTable::RetryResetRoutes ]--------------------------------
//
//
//  Description:
//      Handles callback for reset routes.  This codepath will be used if
//      GetNextHop failes.  Routing has no internal logic to remember if
//      a failure has happened... and no method of sceduling a callback.  By
//      periodically call reset routes, we can centrally solve this problem
//      for all routing sinks.
//  Parameters:
//      pvThis      "this" pointer for CDomainMappingTable
//  Returns:
//      -
//  History:
//      11/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::RetryResetRoutes(PVOID pvThis)
{
    _ASSERT(pvThis);
    CDomainMappingTable *pdmt = (CDomainMappingTable *)pvThis;
    CAQSvrInst *paqinst = pdmt->m_paqinst;

    //Make sure shutdown has not been started.  This instance is waits for
    //all threads before deleting itself, so it is safe to call in to the local
    //variable
    if (!paqinst)
        return;

    //Decrement the count, so another request can be queued up.
    InterlockedDecrement((PLONG) &(pdmt->m_cResetRoutesRetriesPending));

    //Kick off another reset routes
    paqinst->ResetRoutes(RESET_NEXT_HOPS);
}

//---[ CDomainMappingTable::HrRerouteDomains ]--------------------------------
//
//
//  Description:
//      Reroutes a domain and all it's given subdomains.  Global exclusive
//      routing lock *must* be aquired before this is called.
//  Parameters:
//      IN  pstrDomain      Domain to reroute (NULL is all)
//  Returns:
//      S_OK on success
//  History:
//      11/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrRerouteDomains(DOMAIN_STRING *pstrDomain)
{
    HRESULT         hr = S_OK;
    CRerouteContext RouteContext;
    DWORD           dwFlags = 0;

    RouteContext.m_pdmt = this;
    RouteContext.m_fForceReroute = FALSE;

    m_slPrivateData.ExclusiveLock();

    //Clear the failed bit before we make any calls into routing.  This way
    //we can detect a failure that has happened during this reset routes
    dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_GET_NEXT_HOP_FAILED);

    //Make sure this flag is set.  This will prevent a reset routes request
    //from being generated while this thread is resetting routes.  If
    //GetNextHop is still failing, we want to start the retry timer
    //*after* we finish we reset routes, or we will get stuck in a loop
    //of constant reset routes until GetNextHop succeeds.
    dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_RESET_ROUTES_IN_PROGRESS);

    //First pass... blow away all the routing information for the requested
    //domains
    hr = m_dnt.HrIterateOverSubDomains(NULL,
            CDomainMappingTable::UnrouteSingleDomain, NULL);

    //2nd pass... rebuild routing information for *any* domains that are not
    //Routed.  We have no idea of what DMQ's pointed to the links we just
    //removed the routing info for, so we need to check all domains.
    hr = m_dnt.HrIterateOverSubDomains(NULL,
            CDomainMappingTable::RerouteSingleDomain, &RouteContext);

    dwFlags = dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_RESET_ROUTES_IN_PROGRESS);
    m_slPrivateData.ExclusiveUnlock();

    if (DMT_FLAGS_GET_NEXT_HOP_FAILED & dwFlags)
    {
        //This reset routes failed... we must try again later.
        RequestResetRoutesRetryIfNecessary();
    }

    return hr;
}

//---[ CDomainMappingTable::RerouteSingleDomain ]------------------------------
//
//
//  Description:
//      Function that is used to re-route a single domain.  The the context
//      points to a TRUE, then we will force the re-route of the domain.
//      Otherwise, we will only re-route if no routing information exits.
//  Parameters:
//          IN  pvContext   - pointer to context
//                           (pointer to BOOL that tells if we force a re-route)
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      11/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainMappingTable::RerouteSingleDomain(
                                PVOID pvContext, PVOID pvData,
                                BOOL fWildcard, BOOL *pfContinue,
                                BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pvContext, "CDomainMappingTable::RerouteSingleDomain");
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    CRerouteContext *pRouteContext = NULL;
    CDestMsgQueue *pdmq = NULL;
    CLinkMsgQueue *plmq = NULL;
    DOMAIN_STRING  strDom = {0};
    CInternalDomainInfo *pIntDomainInfo = NULL;
    HRESULT        hr = S_OK;
    HRESULT hrRoutingDiag = S_OK;
    CDomainEntryQueueIterator deqit;
    CAQStats       aqstat;
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);
    _ASSERT(pvContext);

    pRouteContext = (CRerouteContext *)pvContext;
    _ASSERT(pRouteContext->m_pdmt);

    *pfDelete   = FALSE;
    *pfContinue = TRUE;

    //
    // Initialize the aqstat to type reroute
    //
    aqstat.m_dwNotifyType = NotifyTypeReroute;

    if (fWildcard)
        return; //we shouldn't care about wildcard entries

    _ASSERT(pdentry);

    //Get the internal domain info for this domain
    hr = pRouteContext->m_pdmt->m_paqinst->HrGetInternalDomainInfo(
                        pdentry->cbGetDomainNameLength(),
                        pdentry->szGetDomainName(),
                        &pIntDomainInfo);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pRouteContext->m_pdmt, "ERROR: Unable to get config for domain - hr 0x%08X", hr);
        pIntDomainInfo = NULL;
    }

    //Loop through dmq's and blow away their routing information
    hr = deqit.HrInitialize(pdentry);
    if (FAILED(hr))
        pdmq = NULL;
    else
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);

    while (pdmq)
    {
        pdmq->RemoveDMQFromLink(TRUE);
        if (pRouteContext->m_fForceReroute || !pdmq->fIsRouted())
        {
            if (pIntDomainInfo)
            {
                hr = pRouteContext->m_pdmt->HrGetNextHopLink(
                        pdentry, pdentry->szGetDomainName(),
                        pdentry->cbGetDomainNameLength(), pIntDomainInfo,
                        pdmq->paqmtGetMessageType(), pdmq->pIMessageRouterGetRouter(),
                        TRUE /* DMT is locked */, &plmq, &hrRoutingDiag);

                if (FAILED(hr))
                {
                    //$$TODO - Deal with more exotic Get next hop errors
                    ErrorTrace((LPARAM) pRouteContext->m_pdmt,
                        "ERROR: Unable to get next hop for domain - hr 0x%08X", hr);
                }
            }

            //Update with new routing info if we can
            if (pIntDomainInfo && SUCCEEDED(hr))
            {
                hr = plmq->HrAddQueue(pdmq);
                pdmq->SetRouteInfo(plmq);

                //Set routing error if there was one.
                pdmq->SetRoutingDiagnostic(hrRoutingDiag);
            }
            else
            {
                pdmq->RemoveDMQFromLink(TRUE);
            }

            if (plmq)
            {
                //
                // Make sure the link is associated with the connection manager
                //
                hr = plmq->HrNotify(&aqstat, TRUE);
                if (FAILED(hr))
                {
                    //If this fails... we *may* leak an unused link until the
                    //next reset routes (or shutdown).
                    ErrorTrace((LPARAM) pvContext,
                        "HrNotify failed on reroute hr - 0x%08X", hr);
                    hr = S_OK;
                }
                plmq->Release();
                plmq = NULL;
            }
        }
        //On to the next queue for this entry
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);
    }

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    TraceFunctLeave();
}

//---[ CDomainMappingTable::UnrouteSingleDomain ]------------------------------
//
//
//  Description:
//      Function that is used to blow-away all the routing information for
//      a single given domain
//  Parameters:
//          IN  pvContext   - pointer to context (currently not used)
//          IN  pvData      - CDomainEntry for the given domain
//          IN  fWildcardData - TRUE if data is a wildcard entry
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfDelete - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      11/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainMappingTable::UnrouteSingleDomain(
                                    PVOID pvContext, PVOID pvData,
                                    BOOL fWildcard, BOOL *pfContinue,
                                    BOOL *pfDelete)
{
    CDomainEntry *pdentry = (CDomainEntry *) pvData;
    HRESULT hr = S_OK;
    CLinkMsgQueue *plmq = NULL;
    CDestMsgQueue *pdmq = NULL;
    CDomainEntryLinkIterator delit;
    CDomainEntryQueueIterator deqit;
    _ASSERT(pfContinue);
    _ASSERT(pfDelete);

    *pfDelete   = FALSE;
    *pfContinue = TRUE;

    if (fWildcard)
        return; //we shouldn't care about wildcard entries

    _ASSERT(pdentry);

    //Blow-away link routing information
    hr = delit.HrInitialize(pdentry);
    if (FAILED(hr))
        plmq = NULL;
    else
        plmq = delit.plmqGetNextLinkMsgQueue(plmq);
    while (plmq)
    {
        plmq->RemoveAllQueues();
        plmq = delit.plmqGetNextLinkMsgQueue(plmq);
    }

    //Loop through dmq's and blow away their routing information
    hr = deqit.HrInitialize(pdentry);
    if (FAILED(hr))
        pdmq = NULL;
    else
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);
    while (pdmq)
    {
        pdmq->RemoveDMQFromLink(TRUE);
        pdmq = deqit.pdmqGetNextDestMsgQueue(pdmq);
    }
}


//---[ CDomainMappingTable::ProcessSpecialLinks ]------------------------------
//
//
//  Description:
//      Processes all the special global links to handle things like local
//      delivery.
//  Parameters:
//      IN      cSpecialRetryMinutes minutes to retry currently unreachable
//              if 0, will use previous value
//      IN      fRoutingLockHeld
//  Returns:
//      -
//  History:
//      1/26/99 - MikeSwa Created
//      3/25/99 - MikeSwa Added fRoutingLockHeld to fix GetNextMsgRef deadlock
//
//-----------------------------------------------------------------------------
void CDomainMappingTable::ProcessSpecialLinks(DWORD  cSpecialRetryMinutes,
                                              BOOL fRoutingLockHeld)
{
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;
    CAQSvrInst *paqinst = m_paqinst;
    BOOL    fSchedRetry = FALSE;
    BOOL    fShutdownLock = FALSE;

    //If this thread has the routing lock... we are safe from shutdown
    _ASSERT(m_paqinst || !fRoutingLockHeld);
    if (!paqinst)
        return;  //we must be shutting down

    if (!fRoutingLockHeld)
    {
        //It is safe to access paqinst to acquire the shutdown lock because
        //all threads that can call this function will be gone before the
        //reference count on the server instance is 0 (however, this call
        //could happen during deinialization which would cause m_aqinst
        //to be NULL and the following call to return FALSE).
        if (!paqinst->fTryShutdownLock())
            return; //we are shutting down

        //Now we have the shutdown lock... m_aqinst must be safe
        _ASSERT(m_paqinst);
        if (!m_paqinst)
        {
            //might as well be defensive in retail about this.
            paqinst->ShutdownUnlock();
            return;
        }
        fShutdownLock = TRUE;
    }

    if (!(DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK &
          dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK)))
    {
        //we have the lock... only 1 thread at a time should do this

        //Loop over queue and enqueue for local delivery
        while (SUCCEEDED(hr) && m_plmqLocal)
        {
            hr = m_plmqLocal->HrGetNextMsgRef(fRoutingLockHeld, &pmsgref);
            if (FAILED(hr))
                break;

            _ASSERT(pmsgref);
            m_paqinst->QueueMsgForLocalDelivery(pmsgref, TRUE);
            pmsgref->Release();
            pmsgref = NULL;
        }

        //Tell link to walk queues so they will be added to the empty list
        //for deletion
        if (m_plmqLocal)
        {
            m_plmqLocal->GenerateDSNsIfNecessary(TRUE /*check if empty */,
                                                 TRUE /*merge retry queue only*/);
        }

        //NDR all messages in the unreachable link
        if (m_plmqUnreachable)
        {
            //We must hold the routing lock for DSN generation
            if (!fRoutingLockHeld)
                m_paqinst->RoutingShareLock();

            m_plmqUnreachable->SetLastConnectionFailure(AQUEUE_E_NDR_ALL);
            m_plmqUnreachable->GenerateDSNsIfNecessary(FALSE, FALSE);

            if (!fRoutingLockHeld)
                m_paqinst->RoutingShareUnlock();

        }

        if (m_plmqCurrentlyUnreachable)
        {
            if (cSpecialRetryMinutes)
            {
                //new time is sooner... we better ask for a retry
                if (cSpecialRetryMinutes < m_cSpecialRetryMinutes)
                    fSchedRetry = TRUE;

                InterlockedExchange((PLONG)&m_cSpecialRetryMinutes,
                                    cSpecialRetryMinutes);
            }

            if (!(DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK &
                  dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK)))
            {
                //We are the only thread doing this

                //We must hold the routing lock for DSN generation
                if (!fRoutingLockHeld)
                    m_paqinst->RoutingShareLock();

                m_plmqCurrentlyUnreachable->GenerateDSNsIfNecessary(FALSE, FALSE);
                dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
                fSchedRetry = TRUE;

                if (!fRoutingLockHeld)
                    m_paqinst->RoutingShareUnlock();
            }

            //periodically check the currently unreachable link... to genrate NDRs
            if (fSchedRetry)
            {
                dwInterlockedSetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
                if (m_paqinst)
                {
                    hr = m_paqinst->SetCallbackTime(
                                  CDomainMappingTable::SpecialRetryCallback, this,
                                  m_cSpecialRetryMinutes);
                    if (FAILED(hr))
                    {
                        //Unmark bits to we try next time
                        dwInterlockedUnsetBits(&m_dwFlags,
                            DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK);
                        hr = S_OK;
                    }
                }
            }
        }

        //Release the lock
        dwInterlockedUnsetBits(&m_dwFlags, DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK);
    }

    if (fShutdownLock)
    {
        _ASSERT(m_paqinst);
        m_paqinst->ShutdownUnlock();
    }
}


//---[ CDomainMappingTable::HrPrepareForLocalDelivery ]------------------------
//
//
//  Description:
//      Prepares a message for local delivery using the m_plmqLocal Link.
//  Parameters:
//      IN      pmsgref     MsgRef to prepare for delivery
//      IN      fLocal      Prepare delivery for all domains with NULL queues
//      IN      fDelayDSN   Check/Set Delay bitmap (only send 1 Delay DSN).
//      IN      pqlstQueues QuickList of DMQ's
//      IN OUT  pdcntxt     context that must be returned on Ack
//      OUT     pcRecips    # of recips to deliver for
//      OUT     prgdwRecips Array of recipient indexes
//  Returns:
//      S_OK on success
//      E_FAIL if m_plmqLocal is not initialized
//  History:
//      1/26/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainMappingTable::HrPrepareForLocalDelivery(
                                    IN CMsgRef *pmsgref,
                                    IN BOOL fDelayDSN,
                                    IN OUT CDeliveryContext *pdcntxt,
                                    OUT DWORD *pcRecips,
                                    OUT DWORD **prgdwRecips)
{
    if (m_plmqLocal)
    {
        return m_plmqLocal->HrPrepareDelivery(pmsgref, TRUE, fDelayDSN,
                                pdcntxt, pcRecips, prgdwRecips);
    }
    else
        return E_FAIL;
}

DWORD CDomainMappingTable::GetCurrentlyUnreachableTotalMsgCount() {
        return m_plmqUnreachable->cGetTotalMsgCount();
}

//---[ CDomainMappingTable::plmqGetLocalLink ]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the local link object
//  Parameters:
//      -
//  Returns:
//      AddRef'd pointer to the local link object
//  History:
//      2/22/99 - MikeSwa Created
//      1/28/2000 - MikeSwa Modified to make shutdown safe
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDomainMappingTable::plmqGetLocalLink()
{
    CAQSvrInst *paqinst = m_paqinst;
    CLinkMsgQueue *plmq = NULL;

    //
    //  If paqinst is non-NULL, then we have the possibility of not being
    //  shutdown.  If we are shutdown, it is possible that m_plmqLocal is
    //  in the process of being released (which would be a really bad
    //  time to addref/release it).  We can safely access paqinst, since
    //  this class is a member of CAQSvrInst.
    //
    if (paqinst && paqinst->fTryShutdownLock())
    {
        plmq = m_plmqLocal;
        if (plmq)
            plmq->AddRef();
        paqinst->ShutdownUnlock();
    }

    return plmq;
}

//---[ CDomainMappingTable::plmqGetCurrentlyUnreachable]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the currently unreachable link object
//  Parameters:
//      -
//  Returns:
//      AddRef'd pointer to the currently unreachable link object
//  History:
//      6/21/99 - GPulla Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDomainMappingTable::plmqGetCurrentlyUnreachable()
{
    if(m_plmqCurrentlyUnreachable)
        m_plmqCurrentlyUnreachable->AddRef();

    return m_plmqCurrentlyUnreachable;
}

//---[ CDomainMappingTable::pmmaqGetPreCategorized]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the precategorized queue object
//  Parameters:
//      -
//      AddRef'd pointer to the precategorized link object.
//  History:
//      6/21/99 - GPulla Created
//
//-----------------------------------------------------------------------------
CMailMsgAdminQueue *CDomainMappingTable::pmmaqGetPreCategorized()
{
    if(m_pmmaqPreCategorized)
        m_pmmaqPreCategorized->AddRef();

    return m_pmmaqPreCategorized;
}

//---[ CDomainMappingTable::pmmaqGetPreRouting]---------------------------------
//
//
//  Description:
//      Returns an addref'd pointer to the pre routing queue object
//  Parameters:
//      -
//      AddRef'd pointer to the precategorized link object.
//  History:
//      6/21/99 - GPulla Created
//
//-----------------------------------------------------------------------------
CMailMsgAdminQueue *CDomainMappingTable::pmmaqGetPreRouting()
{
    if(m_pmmaqPreRouting)
        m_pmmaqPreRouting->AddRef();

    return m_pmmaqPreRouting;
}

//---[ CDomainEntryIterator::CDomainEntryIterator ]----------------------------
//
//
//  Description:
//      Constructor for CDomainEntryIterator
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDomainEntryIterator::CDomainEntryIterator()
{
    m_dwSignature = DOMAIN_ENTRY_ITERATOR_SIG;
    m_cItems = 0;
    m_iCurrentItem = 0;
    m_rgpvItems = NULL;
}

//---[ CDomainEntryIterator::Recycle ]-----------------------------------------
//
//
//  Description:
//      CDomainEntryIterator Recycle... destroys using virtual functions
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainEntryIterator::Recycle()
{
    DWORD   iCurrentItem = 0;

    for (iCurrentItem = 0; iCurrentItem < m_cItems; iCurrentItem++)
    {
        _ASSERT(m_rgpvItems);
        if (!m_rgpvItems)
            break;

        if (m_rgpvItems[iCurrentItem])
        {
            ReleaseItem(m_rgpvItems[iCurrentItem]);
            m_rgpvItems[iCurrentItem] = NULL;
        }
    }

    if (m_rgpvItems)
    {
        FreePv(m_rgpvItems);
        m_rgpvItems = NULL;
    }
    m_cItems = 0;
    m_iCurrentItem = 0;
}

//---[ CDomainEntryIterator::pvGetNext ]---------------------------------------
//
//
//  Description:
//      Gets the next Item
//  Parameters:
//      -
//  Returns:
//      The next item in the iterator
//      NULL if at last item
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDomainEntryIterator::pvGetNext()
{
    PVOID   pvRet = NULL;
    if (m_rgpvItems && (m_iCurrentItem < m_cItems))
    {
        pvRet = m_rgpvItems[m_iCurrentItem];
        _ASSERT(pvRet);
        m_iCurrentItem++;
    }
    return pvRet;
}

//---[ CDomainEntryIterator::HrInitialize ]------------------------------------
//
//
//  Description:
//      Initializes a CDomainEntryIterator from a given CDomainEntry
//  Parameters:
//      pdentry     CDomainEntry to initialize from
//  Returns:
//      S_OK on success
//      E_POINTER if pdentry is NULL
//      E_INVALIDARG if HrInitialize has already be called for this iterator
//      E_OUTOFMEMORY if we cannot allocate memory for iterator
//  History:
//      8/20/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDomainEntryIterator::HrInitialize(CDomainEntry *pdentry)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainEntryIterator::HrInitialize");
    HRESULT hr = S_OK;
    BOOL    fEntryLocked = FALSE;
    DWORD   cAddedItems = 0;
    DWORD   cItems = 0;
    PLIST_ENTRY pli = NULL;
    PLIST_ENTRY pliHead = NULL;
    CLinkMsgQueue *plmq = NULL;

    _ASSERT(pdentry);
    _ASSERT(!m_rgpvItems && "Iterator initialized twice");

    if (!pdentry)
    {
        hr = E_POINTER;
        ErrorTrace((LPARAM) this, "NULL pdentry used to initialized iterator");
        goto Exit;
    }

    if (m_rgpvItems)
    {
        hr = E_INVALIDARG;
        ErrorTrace((LPARAM) this, "Iterator initialized twice!");
        goto Exit;
    }

    pdentry->m_slPrivateData.ShareLock();
    fEntryLocked = TRUE;

    cItems = cItemsFromDomainEntry(pdentry);
    if (!cItems) //Empty entry
        goto Exit;

    m_rgpvItems = (PVOID *) pvMalloc(sizeof(PVOID) * cItems);

    if (!m_rgpvItems)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace((LPARAM) this,
            "Unable to allocate memory for iterator of size %d", cItems);
        goto Exit;
    }

    ZeroMemory(m_rgpvItems, sizeof(PVOID)*cItems);

    pliHead = pliHeadFromDomainEntry(pdentry);
    _ASSERT(pliHead);
    pli = pliHead->Flink;

    while(pliHead != pli)
    {
        _ASSERT(pli);
        m_rgpvItems[cAddedItems] = pvItemFromListEntry(pli);
        _ASSERT(m_rgpvItems[cAddedItems]);
        if (m_rgpvItems[cAddedItems])
            cAddedItems++;

        pli = pli->Flink;
        _ASSERT(cAddedItems <= cItems); //We've run out of room
        if (cAddedItems > cItems)
            break;
    }
    _ASSERT(cAddedItems == cItems);
    m_cItems = cAddedItems;

  Exit:
    if (fEntryLocked)
        pdentry->m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainEntryLinkIterator ]---------------------------------------------
//
//
//  Description:
//      Releases a CLinkMsgQueue during the CDomainEntryQueueIterator
//      destructor
//  Parameters:
//      pvItem    LMQ to release
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainEntryLinkIterator::ReleaseItem(PVOID pvItem)
{
    CLinkMsgQueue *plmq = (CLinkMsgQueue *) pvItem;
    _ASSERT(plmq);
    plmq->Release();
}

//---[ CDomainEntryLinkIterator::pvItemFromListEntry ]-------------------------
//
//
//  Description:
//      Returns a CLinkMsgQueue item from the given LIST_ENTRY
//  Parameters:
//      pli     LIST_ENTRY to get LMQ from... *must* be non-NULL
//  Returns:
//      PVOID   for Addref'd CLinkMsgQueue
//  History:
//      8/20/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDomainEntryLinkIterator::pvItemFromListEntry(PLIST_ENTRY pli)
{
    CLinkMsgQueue *plmq = CLinkMsgQueue::plmqGetLinkMsgQueue(pli);
    _ASSERT(plmq);
    _ASSERT(pli);

    plmq->AddRef();
    return plmq;
}

//---[ CDomainEntryLinkIterator::plmqGetNextLinkMsgQueue ]---------------------
//
//
//  Description:
//      Gets the next LMQ for this iterator
//  Parameters:
//      plmq to release... addref'd by previous call
//  Returns:
//      Addref'd Next LMQ.
//      NULL if no more left
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDomainEntryLinkIterator::plmqGetNextLinkMsgQueue(
                            CLinkMsgQueue *plmq)
{
    CLinkMsgQueue *plmqNext = (CLinkMsgQueue *) pvGetNext();

    if (plmqNext)
        plmqNext->AddRef();

    if (plmq)
        plmq->Release();

    return plmqNext;
}

//---[ CDomainEntryQueueIterator::pdmqGetNextDestMsgQueue ]--------------------
//
//
//  Description:
//      Get the next DMQ in the iterator
//  Parameters:
//      pdmq    CDestMsgQueue to release... addref'd by previous call
//  Returns:
//      Addref'd next DMQ
//      NULL if no more DMQ's for iterator
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDomainEntryQueueIterator::pdmqGetNextDestMsgQueue(
                            CDestMsgQueue *pdmq)
{
    CDestMsgQueue *pdmqNext = (CDestMsgQueue *) pvGetNext();

    if (pdmqNext)
    {
        pdmqNext->AssertSignature();
        pdmqNext->AddRef();
    }

    if (pdmq)
    {
        pdmq->AssertSignature();
        pdmq->Release();
    }

    return pdmqNext;
}

//---[ CDomainEntryDestIterator::pvItemFromListEntry ]-------------------------
//
//
//  Description:
//      Returns a CDestMsgQueue item from the given LIST_ENTRY
//  Parameters:
//      pli     LIST_ENTRY to get DMQ from... *must* be non-NULL
//  Returns:
//      PVOID   for Addref'd CDestMsgQueue
//  History:
//      8/20/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDomainEntryQueueIterator::pvItemFromListEntry(PLIST_ENTRY pli)
{
    CDestMsgQueue *pdmq = CDestMsgQueue::pdmqGetDMQFromDomainListEntry(pli);
    _ASSERT(pdmq);
    _ASSERT(pli);

    pdmq->AssertSignature();
    pdmq->AddRef();
    return (PVOID) pdmq;
}

//---[ CDomainEntryQueueIterator ]---------------------------------------------
//
//
//  Description:
//      Releases a CDestMsgQueue during the CDomainEntryQueueIterator
//      destructor
//  Parameters:
//      pvItem    DMQ to release
//  Returns:
//      -
//  History:
//      8/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDomainEntryQueueIterator::ReleaseItem(PVOID pvItem)
{
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pvItem;
    _ASSERT(pdmq);
    pdmq->AssertSignature();
    pdmq->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\destmsgq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: destmsgq.h
//
//  Description: 
//      Header file for CDestMsgQueue class.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _DESTMSGQ_H_
#define _DESTMSGQ_H_

#include "cmt.h"
#include <fifoq.h>
#include <rwnew.h>
#include "domain.h"
#include "aqroute.h"
#include <listmacr.h>
#include "aqutil.h"
#include "aqinst.h"
#include "aqstats.h"
#include "aqadmsvr.h"

class CLinkMsgQueue;
class CMsgRef;
class CAQSvrInst;
class CQuickList;

#define DESTMSGQ_SIG ' QMD'
#define DESTMSGRETRYQ_SIG 'QRMD'
#define EMPTY_DMQ_EXPIRE_TIME_MINUTES   1

class CDestMsgQueue;

//---[ CDestMsgRetryQueue ]----------------------------------------------------
//
//
//  Hungarian: dmrq, pmdrq
//
//  Provides a retry interface for requeuing messages to DMQ.  If there are 
//  any outstanding messages for a queue, then someone must hold a reference
//  to this intertace to requeue it.
//
//  This class can only be created as as member of a CDestMsgQueue
//
//-----------------------------------------------------------------------------
class CDestMsgRetryQueue
{
  protected:
    DWORD                   m_dwSignature;
    //Reference count for retry interface.
    //Count is used to determine if it is safe to remove this DMQ from the
    //DMT.  This queue will only be removed when it has no messages and this 
    //count is zero.  The count represents the total number of
    //messages pending Ack on this queue. This is held while the message
    //is sent over the wire, and we determine if the message needs
    //to be retried.
    DWORD                   m_cRetryReferenceCount;
    CDestMsgQueue          *m_pdmq;

    friend class CDestMsgQueue;

    CDestMsgRetryQueue();
    ~CDestMsgRetryQueue() {_ASSERT(!m_cRetryReferenceCount);};
  public:

    DWORD   AddRef() 
        {return InterlockedIncrement((PLONG) &m_cRetryReferenceCount);};
    DWORD   Release() 
        {return InterlockedDecrement((PLONG) &m_cRetryReferenceCount);};

    HRESULT HrRetryMsg(IN CMsgRef *pmsgref); //put message on retry queue 

    VOID CheckForStaleMsgsNextDSNGenerationPass();

};

//---[ CDestMsgQueue ]---------------------------------------------------------
//
//
//  Hungarian: dmq, pmdq
//
//  Provides a priority queue of MsgRef's for the CMT
//-----------------------------------------------------------------------------
class CDestMsgQueue : 
    public IQueueAdminAction,
    public IQueueAdminQueue,
    public CBaseObject
{
public:
    CDestMsgQueue(CAQSvrInst *paqinst, 
        CAQMessageType *paqmtMessageType, IMessageRouter *pIMessageRouter);
    ~CDestMsgQueue();
   
    HRESULT HrInitialize(IN CDomainMapping *pdmap);

    HRESULT HrDeinitialize();

    //Set the routing information for this domain
    void    SetRouteInfo(CLinkMsgQueue *plmq);

    //Queue operations
    inline HRESULT HrEnqueueMsg(IN CMsgRef *pmsgref, BOOL fOwnsTypeRef);

    //Dequeue a message for delivery.  All OUT params are ref-counted, and
    //caller is responsable for releasing
    HRESULT HrDequeueMsg(
                OUT CMsgRef **ppmsgref,           //MsgRef dequeued
                OUT CDestMsgRetryQueue **ppdmrq); //retry interface (optional)

    inline void GetDomainMapping(OUT CDomainMapping **ppdmap);

    //Remerge the retry queue with queues & generate DSNs if required
    HRESULT HrGenerateDSNsIfNecessary(IN CQuickList *pqlQueues, 
                                      IN HRESULT hrConnectionStatus,
                                      IN OUT DWORD *pdwContext);
    
    //Used by queue admin (while walking queues)
    inline void QueueAdminCheckForThawedMsgs() 
            {dwInterlockedSetBits(&m_dwFlags, DMQ_CHECK_FOR_THAWED_MSGS);};
    
    //functions used to manipulate lists of queues
    inline CAQMessageType *paqmtGetMessageType();
    inline IMessageRouter *pIMessageRouterGetRouter();
    inline BOOL     fIsSameMessageType(CAQMessageType *paqmt);
    static inline   CDestMsgQueue *pdmqIsSameMessageType(
                                    CAQMessageType *paqmt,
                                    PLIST_ENTRY pli);

    static inline   CDestMsgQueue *pdmqGetDMQFromDomainListEntry(PLIST_ENTRY pli);

    //Accessor functions for DomainEntry list
    inline void     InsertQueueInDomainList(PLIST_ENTRY pliHead);
    inline void     RemoveQueueFromDomainList();
    inline PLIST_ENTRY pliGetNextDomainListEntry();

    //Accessor functions for "empty-queue" list
    void            MarkQueueEmptyIfNecessary();
    inline void     InsertQueueInEmptyQueueList(PLIST_ENTRY pliHead);
    inline void     RemoveQueueFromEmptyQueueList();
    inline PLIST_ENTRY pliGetNextEmptyQueueListEntry();
    inline DWORD    dwGetDMQState();
    inline void     MarkDMQInvalid();
    void            RemoveDMQFromLink(BOOL fNotifyLink);
    
    //Addref and get link (returns NULL if not routed)
    CLinkMsgQueue  *plmqGetLink();

    static inline   CDestMsgQueue *pdmqGetDMQFromEmptyListEntry(PLIST_ENTRY pli);

    //Method that external users can use to verify the signature for
    //DMQ's passed as contexts or LIST_ENTRY's
    inline void     AssertSignature() {_ASSERT(DESTMSGQ_SIG == m_dwSignature);};

    static HRESULT HrWalkDMQForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext, 
                                   OUT BOOL *pfContinue, OUT BOOL *pfDelete);

    static HRESULT HrWalkQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue, 
                                     OUT BOOL *pfDelete);

    //Called by link to get & set link context
    inline PVOID    pvGetLinkContext() {return m_pvLinkContext;};
    inline void     SetLinkContext(IN PVOID pvLinkContext) {m_pvLinkContext = pvLinkContext;};

    inline BOOL     fIsRouted() {return (m_plmq ? TRUE : FALSE);};

    //update stats after adding or removing a message 
    //This should only be called by member functions and queue iterators
    void UpdateMsgStats(
        IN CMsgRef *pmsgref,                //Msg that was added/removed
        IN BOOL     fAdd);                  //TRUE => message was added


    //Returns an approximation of the age of the oldest message in the queue
    inline void GetOldestMsg(FILETIME *pft);

    //Walk retry queue and remerge messages into normal queues
    void MergeRetryQueue();

    void SendLinkStateNotification(void);

    //Returns TRUE if queue is routed remotely.
    BOOL fIsRemote();

    //Describes DMQ state.  Returned by dwGetDMQState and cached in m_dwFlags
    enum 
    {
        DMQ_INVALID                 = 0x00000001, //This DMQ is no longer valid
        DMQ_IN_EMPTY_QUEUE_LIST     = 0x00000002, //This DMQ is in empty list
        DMQ_SHUTDOWN_SIGNALED       = 0x00000004, //Shutdown has been signaled
        DMQ_EMPTY                   = 0x00000010, //DMQ has no messages
        DMQ_EXPIRED                 = 0x00000020, //DMQ has expired in empty list
        DMQ_QUEUE_ADMIN_OP_PENDING  = 0x00000040, //A queue admin operation is pending
        DMQ_CHECK_FOR_THAWED_MSGS   = 0x00000080, //Msgs on this queue have been thawed
        DMQ_UPDATING_OLDEST_TIME    = 0x00000100, //Spinlock for updating oldest time
        DMQ_CHECK_FOR_STALE_MSGS    = 0x00000200, //Do check filehandles during DSN gen
    };

  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj); 
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD(HrApplyActionToMessage)(
		IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
		BOOL *pfShouldDelete);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return QueryDefaultSupportedActions(pdwSupportedActions, 
                                            pdwSupportedFilterFlags);
    };

  public: //IQueueAdminQueue
    STDMETHOD(HrGetQueueInfo)(
        QUEUE_INFO *pliQueueInfo);

    STDMETHOD(HrGetQueueID)(
        QUEUELINK_ID *pQueueID);

  public:
    //  Return # of failed messages: They are not counted in the m_aqstats of the DMQ
    DWORD cGetFailedMsgs() { return m_fqRetryQueue.cGetCount(); }

    //  Set error code from routing
    void SetRoutingDiagnostic(HRESULT hr) { m_hrRoutingDiag = hr; }

protected:
    DWORD                   m_dwSignature;
    DWORD                   m_dwFlags;
    LIST_ENTRY              m_liDomainEntryDMQs;

    //Type of message (as returned by routing) that is on this queue.
    CAQMessageType           m_aqmt;
    DWORD                    m_cMessageTypeRefs; 
    
    IMessageRouter          *m_pIMessageRouter;

    //Errorcode from routing. This is set to S_OK if there's no errorcode. 
    //Currently this indicates the reason why a destination is unreachable.
    HRESULT                 m_hrRoutingDiag;

    //Members used for DMQ deletion (maintaining a list of empty queues)
    LIST_ENTRY              m_liEmptyDMQs;
    FILETIME                m_ftEmptyExpireTime; //expiration time of empty DMQ
    DWORD                   m_cRemovedFromEmptyList; //# of times on list w/o
                                                     //being deleted.

    CShareLockNH            m_slPrivateData; //Share lock to protect access to m_rgpfqQueues

    //The following three fields encapsulate all of the routing data
    //for this DMQ.  The actual routing data is the pointer to the link,
    //and the context is used by the link to optimize access
    CLinkMsgQueue           *m_plmq;      
    PVOID                   m_pvLinkContext; 

    CAQSvrInst              *m_paqinst;

    //Array of FIFO queues (used to make a priority queue
    CFifoQueue<CMsgRef *>   *m_rgpfqQueues[NUM_PRIORITIES];

    //Retry Qeueue for failed messages
    CFifoQueue<CMsgRef *>   m_fqRetryQueue;

    //class used to store stats
    CAQStats                m_aqstats;

    //which domain is  represented in this destination
    CDomainMapping          m_dmap;

    FILETIME                m_ftOldest;

    CDestMsgRetryQueue      m_dmrq;

    DWORD                   m_cCurrentThreadsEnqueuing;
  protected: //internal interfaces

    //Add Message to front or back of priority queues
    HRESULT HrAddMsg(
        IN CMsgRef *pmsgref,                //Msg to add
        IN BOOL fEnqueue,                   //TRUE => enqueue,FALSE => requeue
        IN BOOL fNotify);                   //TRUE => send notification if needed

    void UpdateOldest(FILETIME *pft);

    //Callers must use CDestMsgRetryQueueClass
    HRESULT HrRetryMsg(IN CMsgRef *pmsgref); //put message on retry queue 

    friend class CDestMsgRetryQueue;
};

//---[ CDestMsgQueue::HrEnqueueMsg ]-------------------------------------------
//
//
//  Description: 
//      Enqueues a message for remote delivery for a given final destination
//      and message type
//  Parameters:
//      pmsgref         AQ Message Reference to enqueue
//      fOwnsTypeRef    TRUE if this queue is responsible for calling
//                      IMessageRouter::ReleaseMessageType
//  Returns:
//      S_OK on success
//      Error code from HrAddMsg
//  History:
//      5/21/98 - MikeSwa added fOwnsTypeRef
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrEnqueueMsg(IN CMsgRef *pmsgref, BOOL fOwnsTypeRef)
{
    HRESULT hr = S_OK;

    hr = HrAddMsg(pmsgref, TRUE, TRUE);
    
    if (fOwnsTypeRef && SUCCEEDED(hr))
        InterlockedIncrement((PLONG) &m_cMessageTypeRefs);

    //Callers should have shutdown lock
    _ASSERT(!(m_dwFlags & (DMQ_INVALID | DMQ_SHUTDOWN_SIGNALED)));
    return hr;
}


//---[ CDestMsgQueue::paqmtGetMessageType ]------------------------------------
//
//
//  Description: 
//      Get the message type for this queue
//  Parameters:
//      -
//  Returns:
//      CAQMessageType * of this queue's message type
//  History:
//      5/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMessageType *CDestMsgQueue::paqmtGetMessageType()
{
    return (&m_aqmt);
}

//---[ CDestMsgQueue::fIsSameMessageType ]-------------------------------------
//
//
//  Description: 
//      Tells if the message type of this queue is the same as the given
//      message type.
//  Parameters:
//      paqmt   - ptr to CAQMessageType to test
//  Returns:
//      TRUE if they match, FALSE if they do not
//  History:
//      5/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CDestMsgQueue::fIsSameMessageType(CAQMessageType *paqmt)
{
    _ASSERT(paqmt);
    return m_aqmt.fIsEqual(paqmt);
}

//---[ CDestMsgQueue::pdmqIsSameMessageType ]----------------------------------
//
//
//  Description: 
//      STATIC function used to determine if a LIST_ENTRY refers to a 
//      CDestMsgQueue with a given message type.
//  Parameters:
//      paqmt   - ptr to CAQMessageType to check against
//      pli     - ptr to list entry to check (must refer to a CDestMsgQueue)
//  Returns:
//      Ptr to CDestMsgQueue if LIST_ENTRY refers to a CDestMsgQueue with
//      the given message type.
//      NULL if no match is not found
//  History:
//      5/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDestMsgQueue::pdmqIsSameMessageType(
                                    CAQMessageType *paqmt,
                                    PLIST_ENTRY pli)
{
    CDestMsgQueue *pdmq = NULL;
    pdmq = CONTAINING_RECORD(pli, CDestMsgQueue, m_liDomainEntryDMQs);
    _ASSERT(DESTMSGQ_SIG == pdmq->m_dwSignature);
    
    //if not the same message type return NULL
    if (!pdmq->fIsSameMessageType(paqmt))
        pdmq = NULL;
    
    return pdmq;
}

//---[ CDestMsgQueue::pdmqGetDMQFromDomainListEntry ]--------------------------
//
//
//  Description: 
//      Returns the CDestMsgQueue associated with a list entry
//  Parameters:
//      IN pli     ptr to list entry to get CDestMsgQueue from
//  Returns:
//      ptr to CDestMsgQueue
//  History:
//      5/28/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDestMsgQueue::pdmqGetDMQFromDomainListEntry(PLIST_ENTRY pli)
{
    _ASSERT(DESTMSGQ_SIG == (CONTAINING_RECORD(pli, CDestMsgQueue, m_liDomainEntryDMQs))->m_dwSignature);
    return (CONTAINING_RECORD(pli, CDestMsgQueue, m_liDomainEntryDMQs));
}

//---[ CDestMsgQueue::InsertQueueInDomainList ]---------------------------------
//
//
//  Description: 
//      Inserts this CDestMsgQueue into the given linked list of queues
//  Parameters:
//      pliHead     - PLIST_ENTRY for list head
//  Returns:
//      -
//  History:
//      5/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::InsertQueueInDomainList(PLIST_ENTRY pliHead)
{
    _ASSERT(NULL == m_liDomainEntryDMQs.Flink);
    _ASSERT(NULL == m_liDomainEntryDMQs.Blink);
    InsertHeadList(pliHead, &m_liDomainEntryDMQs);
}

//---[ CDestMsgQueue::RemoveQueueFromDomainList ]-------------------------------
//
//
//  Description: 
//      Removes this queue from a list of queues
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/27/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::RemoveQueueFromDomainList()
{
    RemoveEntryList(&m_liDomainEntryDMQs);
    m_liDomainEntryDMQs.Flink = NULL;
    m_liDomainEntryDMQs.Blink = NULL;
}

//---[ CDestMsgQueue::pliGetNextDomainListEntry ]-------------------------------
//
//
//  Description: 
//      Gets the pointer to the next list entry for this queue.
//  Parameters:
//      -
//  Returns:
//      The Flink of the queues LIST_ENTRY
//  History:
//      6/16/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
PLIST_ENTRY CDestMsgQueue::pliGetNextDomainListEntry()
{
    return m_liDomainEntryDMQs.Flink;
}

//---[ CDestMsgQueue::InsertQueueInEmptyQueueList ]----------------------------
//
//
//  Description: 
//      Inserts queue at *tail* of DMT empty queue list. The queue that has 
//      been empty the longest should be at the   As with the other EmptyQueue
//      list functions this is called by the DMT, when it has the appropriate 
//      lock for the head of the list.
//
//      Upon insertion, an "expire time" is stamped on the queue. If the queue
//      is still in the list, then it is a candidate for deletion, and will be
//      delete the next time the DMT looks at the queue (everytime HrMapDomain
//      is called).
//
//      NOTE"We need to make sure this function is thread-safe.  Since the
//      DMQ lock is aquired exclusively before this is called, we know that
//      no one will ENQUEUE a messsage.  This function call is tiggered after
//      the retry queues are emptied when a connection finished, so we can
//      also ensure that no one will call this while there are messages to 
//      retry.  

//      It is however (remotely) possible for 2 threads to finish connections 
//      for this queue and thus cause 2 threads to be in this function.
//      The thread that successfully modified the EMPTY bit will be allowed
//      to add the queue to the list.
//  Parameters:
//      IN  pliHead     The head of the list to insert into
//  Returns:
//      -
//  History:
//      9/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::InsertQueueInEmptyQueueList(PLIST_ENTRY pliHead)
{
    _ASSERT(m_paqinst);

    //Now that we have the exclusive lock recheck to make sure there are no messages
    if (m_aqstats.m_cMsgs || m_fqRetryQueue.cGetCount())
        return; 

    //Attempt to set the DMQ_EMPTY bit
    if (DMQ_EMPTY & dwInterlockedSetBits(&m_dwFlags, DMQ_EMPTY))
    {
        //Another thread has set it, we cannot modify the LIST_ENTRY
        return; 
    }

    //If it is already in queue, that means that the queue has gone
    //from empty to non-empty to empty. Insert at tail of list with new time
    if (m_dwFlags & DMQ_IN_EMPTY_QUEUE_LIST)
    {
        _ASSERT(NULL != m_liEmptyDMQs.Flink);
        _ASSERT(NULL != m_liEmptyDMQs.Blink);
        RemoveEntryList(&m_liEmptyDMQs);
        m_cRemovedFromEmptyList++;
    }
    else
    {
        _ASSERT(NULL == m_liEmptyDMQs.Flink);
        _ASSERT(NULL == m_liEmptyDMQs.Blink);
    }

    //Get expire time for this queue
    m_paqinst->GetExpireTime(EMPTY_DMQ_EXPIRE_TIME_MINUTES, 
                              &m_ftEmptyExpireTime, NULL);

    //Mark queue as in empty queue
    dwInterlockedSetBits(&m_dwFlags, DMQ_IN_EMPTY_QUEUE_LIST);

    //Insert into queue
    InsertTailList(pliHead, &m_liEmptyDMQs);
    _ASSERT(pliHead->Blink == &m_liEmptyDMQs);
    _ASSERT(!m_aqstats.m_cMsgs); //No other thread should be able to add msgs
}

//---[ DestMsgQueue::RemoveQueueFromEmptyQueueList ]---------------------------
//
//
//  Description: 
//      Removed the queue from the empty list.  Caller *must* have DMT lock
//      to call this.  DMQ will not call this directly, but will call into
//      DMT .
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::RemoveQueueFromEmptyQueueList()
{
    RemoveEntryList(&m_liEmptyDMQs);
    
    //Increment count now that queue is being removed from empty list
    m_cRemovedFromEmptyList++;

    //Mark queue as not in empty queue
    dwInterlockedUnsetBits(&m_dwFlags, DMQ_IN_EMPTY_QUEUE_LIST);

    m_liEmptyDMQs.Flink = NULL;
    m_liEmptyDMQs.Blink = NULL;
}

//---[ CDestMsgQueue::pliGetNextEmptyQueueListEntry ]--------------------------
//
//
//  Description: 
//      Gets next queue entry in empty list.
//  Parameters:
//      -
//  Returns:
//      Next entry pointed to by list entry
//  History:
//      9/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
PLIST_ENTRY CDestMsgQueue::pliGetNextEmptyQueueListEntry()
{
    return m_liEmptyDMQs.Flink;
}

//---[ CDestMsgQueue::dwGetDMQState ]------------------------------------------
//
//
//  Description: 
//      Returns the state of the DMQ and caches that state in m_dwFlags.  May
//      update DMQ_EXPIRED if DMQ is in empty list and it has expired
//  Parameters:
//      -
//  Returns:
//      Current DMQ state
//  History:
//      9/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CDestMsgQueue::dwGetDMQState()
{
    _ASSERT(DESTMSGQ_SIG == m_dwSignature);
    _ASSERT(m_paqinst);

    if (DMQ_IN_EMPTY_QUEUE_LIST & m_dwFlags)
    {
        //If it is empty and not expired..check if expired
        if ((DMQ_EMPTY & m_dwFlags) && !(DMQ_EXPIRED & m_dwFlags))
        {
            if (m_paqinst->fInPast(&m_ftEmptyExpireTime, NULL))
                dwInterlockedSetBits(&m_dwFlags, DMQ_EXPIRED);
        }
    }

    return m_dwFlags;
}

//---[ CDestMsgQueue::MarkDMQInvalid ]------------------------------------------
//
//
//  Description: 
//      Marks this queue as invalid.  Queue *must* be empty for this to happen
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::MarkDMQInvalid()
{
    _ASSERT(DESTMSGQ_SIG == m_dwSignature);
    _ASSERT(DMQ_EMPTY & m_dwFlags);
    dwInterlockedSetBits(&m_dwFlags, DMQ_INVALID);
}

//---[ CDestMsgQueue::pdmqGetDMQFromEmptyListEntry ]---------------------------
//
//
//  Description: 
//      Returns the DMQ corresponding to a given Empty Queue LIST_ENTRY.
//
//      Will assert that DMQ signature is valid
//  Parameters:
//      IN  pli     Pointer to LIST_ENTRY for queue
//  Returns:
//
//  History:
//      9/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDestMsgQueue *CDestMsgQueue::pdmqGetDMQFromEmptyListEntry(PLIST_ENTRY pli)
{
    _ASSERT(DESTMSGQ_SIG == (CONTAINING_RECORD(pli, CDestMsgQueue, m_liEmptyDMQs))->m_dwSignature);
    return (CONTAINING_RECORD(pli, CDestMsgQueue, m_liEmptyDMQs));
}

//---[ CDestMsgQueue::GetDomainMapping ]---------------------------------------
//
//
//  Description: 
//      Returns the domain mapping for this queue.
//  Parameters:
//      OUT ppdmap  Returned domain mapping
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Modified to not have a return value
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::GetDomainMapping(OUT CDomainMapping **ppdmap)
{
    _ASSERT(ppdmap);
    *ppdmap = &m_dmap; 
}

IMessageRouter *CDestMsgQueue::pIMessageRouterGetRouter()
{
    return m_pIMessageRouter;
}

//---[ CDestMsgQueue::GetOldestMsg ]-------------------------------------------
//
//
//  Description: 
//      Retruns an approximation of the oldest message in the queue
//  Parameters:
//      OUT pft     FILTIME of "oldest" Messate
//  Returns:
//      -
//  History:
//      12/13/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::GetOldestMsg(FILETIME *pft)
{
    _ASSERT(pft);
    if (m_aqstats.m_cMsgs)
        memcpy(pft, &m_ftOldest, sizeof(FILETIME));
    else
        ZeroMemory(pft, sizeof (FILETIME));
}

#endif //_DESTMSGQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\destmsgq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: destmsgq.cpp
//
//  Description: Implementation of the CDestMsgQueue class
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "aqprecmp.h"
#include "fifoqimp.h"
#include "qwiklist.h"
#include "aqutil.h"

//---[ DEST_QUEUE_CONTEXT ]----------------------------------------------------
//
//
//  Description: 
//      Context used for DSN generation.  This is created by 
//      GenerateDSNsIfNecessary() and passed to the DMQ iterator function
//      HrWalkDMQForDSN().
//  Hungarian: 
//      dqcontext, pdqcontext
//  
//-----------------------------------------------------------------------------
class DEST_QUEUE_CONTEXT
{
  private:
    friend HRESULT CDestMsgQueue::HrWalkDMQForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete);
    CDestMsgQueue   *m_pdmq;
    CQuickList      *m_pql;
    HRESULT         m_hrConnectionStatus;
    DWORD           m_cMsgsSeenThisQueue;
    DWORD           m_cDSNsGeneratedThisQueue;
    DWORD           m_dwTickCountStart;
    

  public:
    //Contructor.... initializes and updates DWORD context
    DEST_QUEUE_CONTEXT(IN OUT DWORD *pdwContext, IN CDestMsgQueue *pdmq, 
                        IN CQuickList *pql, IN HRESULT hr) 
    {
        _ASSERT(pdwContext);
        m_pdmq = pdmq;
        m_pql = pql;
        m_hrConnectionStatus = hr;
        m_cMsgsSeenThisQueue = 0;
        m_cDSNsGeneratedThisQueue = 0;


        //Initialize/Update context if it has not been initialized
        if (!*pdwContext)
            *pdwContext = GetTickCount();

        m_dwTickCountStart = *pdwContext;
    }
    
    ~DEST_QUEUE_CONTEXT()
    {
        TraceFunctEnterEx((LPARAM) this, "DEST_QUEUE_CONTEXT::~DEST_QUEUE_CONTEXT");
        DWORD       dwTickDiff = GetTickCount() - m_dwTickCountStart;
        DebugTrace((LPARAM) this, 
            "DSN summary: %d milliseconds - %d msgs - %d DSNs",
            dwTickDiff, m_cMsgsSeenThisQueue, m_cDSNsGeneratedThisQueue);

        _ASSERT(m_cMsgsSeenThisQueue >= m_cDSNsGeneratedThisQueue);
        TraceFunctLeave();
    }

    BOOL    fPastTimeLimit()
    {
        DWORD   dwTickCountDiff = GetTickCount() - m_dwTickCountStart;
        if (dwTickCountDiff >= g_cMaxSecondsPerDSNsGenerationPass*1000)
            return TRUE;
        else
            return FALSE;
    }
};


//context used for QueueAdmin functions
enum 
{
    DMQAdminContextDefault          = 0x00000000,
    DMQAdminContextRetryQueue       = 0x00000001,  //Retry queue is being scanned
};

#define DMQ_ADMIN_CONTEXT_SIG       'CAQD'
#define DMQ_ADMIN_CONTEXT_SIG_FREE  '!AQD'

class CDMQAdminContext
{
  public:
    DWORD           m_dwSignature;
    DWORD           m_dwState;

    CDMQAdminContext()
    {
        m_dwSignature = DMQ_ADMIN_CONTEXT_SIG;
        m_dwState = DMQAdminContextDefault;
    };

    ~CDMQAdminContext()
    {
        m_dwSignature = DMQ_ADMIN_CONTEXT_SIG_FREE;
    }
};


//---[ CDestMsgRetryQueue::CDestMsgRetryQueue ]--------------------------------
//
//
//  Description: 
//      Constructor for CDestMsgRetryQueue.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/25/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDestMsgRetryQueue::CDestMsgRetryQueue()
{
    m_dwSignature = DESTMSGRETRYQ_SIG;
    m_cRetryReferenceCount = 0;
    m_pdmq = NULL;
}

//---[ CDestMsgRetryQueue::HrRetryMsg ]----------------------------------------
//
//
//  Description: 
//      Puts a message into the retry queue
//  Parameters:
//      pmsgref     Message to put into retry queue
//  Returns:
//      S_OK on success
//      E_INVALIDARG if no refcount (asserts in DBG)
//  History:
//      10/25/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgRetryQueue::HrRetryMsg(IN CMsgRef *pmsgref)
{
    _ASSERT(m_pdmq);
    _ASSERT(m_cRetryReferenceCount);
    _ASSERT(DESTMSGRETRYQ_SIG == m_dwSignature);

    if (!m_pdmq || !m_cRetryReferenceCount)
    {
        return E_INVALIDARG;
    }

    m_pdmq->AssertSignature();
    return (m_pdmq->HrRetryMsg(pmsgref));
}

//---[ CDestMsgQueueHrWalkDMQForDSN ]------------------------------------------
//
//
//  Description:
//      Example default function to use with HrMapFn... will always return TRUE
//      to continue and delete the current queued data
//  Parameters:
//      IN  CMsgRef pmsgref,  //ptr to data on queue
//      IN  PVOID pvContext   //list of queues to prepare for DSN
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK
//  History:
//      7/13/98 - MikeSwa Created
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrWalkDMQForDSN(IN CMsgRef *pmsgref, IN PVOID pvContext,
                           OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "CDestMsgQueue::HrWalkDMQForDSN");
    Assert(pfContinue);
    Assert(pfDelete);
    HRESULT hr = S_OK;
    HRESULT hrReason = S_OK;
    DWORD   dwDSNFlags = 0;
    DWORD   dwMsgRefDSNOptions = CMsgRef::MSGREF_DSN_SEND_DELAY | 
                                 CMsgRef::MSGREF_DSN_HAS_ROUTING_LOCK;
    DEST_QUEUE_CONTEXT *pdqcontext = (DEST_QUEUE_CONTEXT *) pvContext;
    CLinkMsgQueue *plmq = NULL;
    CQuickList quicklist;
    CQuickList *pql;
    DWORD dwIndex;

    _ASSERT(pdqcontext->m_pdmq);
    _ASSERT(pdqcontext->m_pql);

    *pfContinue = TRUE;
    *pfDelete = FALSE;

    //See if we got the shutdown hint... if so bail
    if (pdqcontext->m_pdmq->m_paqinst->fShutdownSignaled())
    {
        *pfContinue = FALSE;
        goto Exit;
    }

    //Check and make sure that a routing change is not pending
    if (!pdqcontext->m_pdmq->m_paqinst ||
        !pdqcontext->m_pdmq->m_paqinst->fTryRoutingShareLock())
    {
        *pfContinue = FALSE;
        goto Exit;
    }
    pdqcontext->m_pdmq->m_paqinst->RoutingShareUnlock();

    //Check and see if we have hit our limit.  We force ourselves
    //to generate at least one DSN, so we make some forward progress 
    //each pass.
    if (pdqcontext->m_cDSNsGeneratedThisQueue && pdqcontext->fPastTimeLimit())
    {
        *pfContinue = FALSE;
        hr = HRESULT_FROM_WIN32(E_PENDING);
        goto Exit;
    }

    //Avoid holding the lock while making external calls other than AddRef etc
    pdqcontext->m_pdmq->m_slPrivateData.ShareLock();
    plmq = pdqcontext->m_pdmq->m_plmq;
    if (plmq)
        plmq->AddRef();
    pdqcontext->m_pdmq->m_slPrivateData.ShareUnlock();

    //$$REVIEW: Holding the lock for such a short time is something of a moot
    //point here, since a Sharelock is held at the link level to assure that
    //the qwiklist passed in as part of our context does not change

    if (plmq)
    {
        //We should not send delay DSNs to TURN/ETRN domains
        if (plmq->dwGetLinkState() & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
            dwMsgRefDSNOptions &= ~CMsgRef::MSGREF_DSN_SEND_DELAY;
        plmq->Release();
    }

    if(pdqcontext->m_pdmq->m_hrRoutingDiag != S_OK)
    {
        //
        //  This message is being NDR'ed because routing had a problem with
        //  it. Pass in the HRESULT from routing so that we can use it during
        //  DSN generation. Pass in a quicklist with only the CDestMsgQueue
        //  on which the routing error occured.
        //
        hrReason = pdqcontext->m_pdmq->m_hrRoutingDiag;
        DebugTrace((LPARAM)pmsgref, "Generating DSN due to routing, hr - %08x", hrReason);

        hr = quicklist.HrAppendItem(pdqcontext->m_pdmq, &dwIndex);
        if(FAILED(hr))
        {
            ErrorTrace((LPARAM)pmsgref, "Unable to generate DSN for msg");
            goto Exit;
        }
        pql = &quicklist;
    }
    else
    {
        hrReason = pdqcontext->m_hrConnectionStatus;
        pql = pdqcontext->m_pql;
    }
    
    if (pdqcontext->m_pdmq->m_dwFlags & DMQ_CHECK_FOR_STALE_MSGS)
    {
        DebugTrace((LPARAM) pmsgref, "Enabling checking for stale messages");
        dwMsgRefDSNOptions |= CMsgRef::MSGREF_DSN_CHECK_IF_STALE;
    }

    hr = pmsgref->HrSendDelayOrNDR(dwMsgRefDSNOptions, pql, hrReason, &dwDSNFlags);

    if (FAILED(hr))
        goto Exit;

    //NOTE: Although it would be tempting to return *pfContinue as FALSE if
    //MSGREF_HAS_NOT_EXPIRED was set, it would be wrong since queues may be
    //out of order on startup... and some sink may modify the expiration time
    //(for example... routing may want to expire low-priority messages earlier).

    //We need to remove this message from the queue
    if ((CMsgRef::MSGREF_DSN_SENT_NDR | CMsgRef::MSGREF_HANDLED) & dwDSNFlags)
    {
        *pfDelete = TRUE;
        pdqcontext->m_pdmq->UpdateMsgStats(pmsgref, FALSE);
    }

    //Update counts in context
    pdqcontext->m_cMsgsSeenThisQueue++;

    if ((CMsgRef::MSGREF_DSN_SENT_NDR | CMsgRef::MSGREF_DSN_SENT_DELAY) & dwDSNFlags)
    {
        pdqcontext->m_cDSNsGeneratedThisQueue++;
    }

  Exit:
    if (AQUEUE_E_SHUTDOWN == hr)
    {
        *pfContinue = FALSE;
        hr = S_OK;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrWalkQueueForShutdown ]--------------------------------
//
//
//  Description: 
//      Static function to walk a queue containing msgrefs at shutdown and 
//      clear out all of the IMailMsgs
//  Parameters:
//      IN  CMsgRef pmsgref,  ptr to data on queue
//      IN  PVOID pvContext   Pointer to CDestMsgQueue we are walking for
//                            shutdown.
//      OUT BOOL *pfContinue, TRUE if we should continue
//      OUT BOOL *pfDelete);  TRUE if item should be deleted
//  Returns:
//      S_OK - *always*
//  History:
//      11/18/98 - MikeSwa Created 
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrWalkQueueForShutdown(IN CMsgRef *pmsgref,
                                     IN PVOID pvContext, OUT BOOL *pfContinue, 
                                     OUT BOOL *pfDelete)
{
    TraceFunctEnterEx((LPARAM) pmsgref, "HrWalkMsgRefQueueForShutdown");
    Assert(pfContinue);
    Assert(pfDelete);
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pvContext;
    _ASSERT(pmsgref);
    _ASSERT(pdmq);

    _ASSERT(DESTMSGQ_SIG == pdmq->m_dwSignature);

    *pfContinue = TRUE;
    *pfDelete = TRUE;

    //call server stop hint function
    if (pdmq->m_paqinst)
        pdmq->m_paqinst->ServerStopHintFunction();

    //Update stats
    pdmq->UpdateMsgStats(pmsgref, FALSE);

    pmsgref->AddRef();
    pdmq->m_paqinst->HrQueueWorkItem(pmsgref, fMsgRefShutdownCompletion);

    TraceFunctLeave();
    return S_OK;
}

//---[ CDestMsgQueue::CDestMsgQueue() ]----------------------------------------
//
//
//  Description:
//      Class constructor
//  Parameters:
//      IN  paqinst             AQ virtual server object
//      IN  paqmtMessageType    Message type for this queue
//      IN  pIMessageRouter     IMessageRouter interface for this queue
//  Returns:
//      -
//-----------------------------------------------------------------------------
CDestMsgQueue::CDestMsgQueue(CAQSvrInst *paqinst,
                             CAQMessageType *paqmtMessageType,
                             IMessageRouter *pIMessageRouter)
                    : m_aqmt(paqmtMessageType)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::CDestMsgQueue");
    _ASSERT(paqinst);
    _ASSERT(pIMessageRouter);

    m_dwSignature        = DESTMSGQ_SIG;
    m_dwFlags            = DMQ_EMPTY;
    m_pIMessageRouter    = pIMessageRouter;
    m_plmq               = NULL;
    m_paqinst            = paqinst;
    m_cMessageTypeRefs   = 0;
    m_pvLinkContext      = NULL;
    m_cCurrentThreadsEnqueuing = 0;
    m_hrRoutingDiag      = S_OK;

    m_pIMessageRouter->AddRef();
    m_paqinst->AddRef();

    m_paqinst->IncDestQueueCount();

    m_liDomainEntryDMQs.Flink = NULL;
    m_liDomainEntryDMQs.Blink = NULL;

    m_liEmptyDMQs.Flink = NULL;
    m_liEmptyDMQs.Blink = NULL;
    m_cRemovedFromEmptyList = 0;

    ZeroMemory(m_rgpfqQueues, NUM_PRIORITIES*sizeof(CFifoQueue<CMsgRef *> **));
    ZeroMemory(&m_ftOldest, sizeof (FILETIME));

    m_dmrq.m_pdmq = this;
    TraceFunctLeave();
}

//---[ CDestMsgQueue::~CDestMsgQueue() ]---------------------------------------
//
//
//  Description:
//      Default destructor
//  Parameters:
//      -
//  Returns:
//      -
//-----------------------------------------------------------------------------
CDestMsgQueue::~CDestMsgQueue()
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::~CDestMsgQueue");

    for (int i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
            delete m_rgpfqQueues[i];
    }

    //Make sure we clean up the link even if HrDeinitialize wasn't called
    if (m_plmq)
    {
        m_plmq->HrDeinitialize();
        m_plmq->Release();
        m_plmq = NULL;
    }

    if (m_pIMessageRouter)
    {
        _ASSERT((!m_cMessageTypeRefs) && "Message Type references in destructor");
        m_pIMessageRouter->Release();
        m_pIMessageRouter = NULL;
    }

    if (m_paqinst)
    {
        m_paqinst->DecDestQueueCount();
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    _ASSERT(NULL == m_liDomainEntryDMQs.Flink);
    _ASSERT(NULL == m_liDomainEntryDMQs.Blink);
    _ASSERT(!m_cCurrentThreadsEnqueuing);

    MARK_SIG_AS_DELETED(m_dwSignature);
    TraceFunctLeave();
}

//---[ CDestMsgQueue::HrInitialize() ]-----------------------------------------
//
//
//  Description:
//      Performs initialization that may require allocation
//  Parameters:
//      IN CDomainMapping *pdmap //array of domain mappings to use
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if allocations fail
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrInitialize(IN CDomainMapping *pdmap)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrInitialize");
    HRESULT hr  = S_OK;
    DWORD   i   = 0; //loop counter

    _ASSERT(pdmap);

    if (!pdmap)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //If the queues are compressed (more than one domain name per destination),
    //then each queue will contain multiple domain mappings (1 for each domain)
    m_dmap.Clone(pdmap);

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrDeinitialize ]-----------------------------------------
//
//
//  Description:
//      Deinitialize object
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrDeinitialize");
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    DWORD   cMsgsRemoved =0;

    dwInterlockedSetBits(&m_dwFlags, DMQ_SHUTDOWN_SIGNALED);
    for (int i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
        {
            hrTmp = m_rgpfqQueues[i]->HrMapFn(CDestMsgQueue::HrWalkQueueForShutdown, 
                                               this, &cMsgsRemoved);

            //This should really never fail, since HrMapFn will only return errors from
            //the function walking the queues (which in this case never fails)
            _ASSERT(SUCCEEDED(hrTmp));

            //This *should* have removed all msgs
            _ASSERT(!m_aqstats.m_cMsgs && "Still msgs in queue after Deinit");
        }
    }

    m_fqRetryQueue.HrMapFn(HrWalkMsgRefQueueForShutdown, m_paqinst, NULL);

    if (m_pIMessageRouter)
    {
        if (m_cMessageTypeRefs)
        {
            hr = m_pIMessageRouter->ReleaseMessageType(m_aqmt.dwGetMessageType(),
                                        m_cMessageTypeRefs);
            _ASSERT(SUCCEEDED(hr) && "Release Message Type Failed");
            m_cMessageTypeRefs = 0;
        }
        m_pIMessageRouter->Release();
        m_pIMessageRouter = NULL;
    }
    else
    {
        _ASSERT((!m_cMessageTypeRefs) && "We're leaking message type references");
    }


    if (m_paqinst)
    {
        m_paqinst->DecDestQueueCount();
        m_paqinst->Release();
        m_paqinst = NULL;
    }

    if (m_plmq)
    {
        m_plmq->Release();
        m_plmq = NULL;
    }

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrAddMsg ]----------------------------------------------
//
//
//  Description:
//      Enqueues or Requeues a message to the appropriate priority queue,
//      allocating queue if not present.
//
//      A notification will be sent if needed (& requested) to the associated
//      link object.  The fNotify argument was originally included to prevent
//      messages from the retry queue causing notifications.
//  Parameters:
//      IN CMsgRef *pmsgref - the message ref to enqueue
//      IN BOOL fEnqueue    - TRUE => enqueue and FALSE => requeue
//      IN BOOL fNotify     - TRUE => send notification if necessary.
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrAddMsg(IN CMsgRef *pmsgref, IN BOOL fEnqueue,
                                IN BOOL fNotify)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrAddMsg");
    HRESULT                hr         = S_OK;
    DWORD                  dwFlags    = 0;
    EffectivePriority      priIndex   = eEffPriNormal;
    EffectivePriority      priOld     = eEffPriNormal;  //old pri if updated
    CFifoQueue<CMsgRef *> *pfqQueue   = NULL;
    CFifoQueue<CMsgRef *> *pfqQueueNew= NULL;

    _ASSERT(pmsgref);
    _ASSERT(m_aqmt.fIsEqual(pmsgref->paqmtGetMessageType()));
    _ASSERT(!(m_dwFlags & (DMQ_INVALID | DMQ_SHUTDOWN_SIGNALED)));

    //get the priority from the message reference
    priIndex = pmsgref->PriGetPriority();

    //use priority to get to get ptr to correct queue
    Assert(priIndex < NUM_PRIORITIES);

    pfqQueue = m_rgpfqQueues[priIndex];

    if (NULL == pfqQueue) //we must allocate a queue
    {
        pfqQueueNew = new CFifoQueue<CMsgRef *>();
        if (NULL != pfqQueueNew)
        {
            pfqQueue = (CFifoQueue<CMsgRef *> *) InterlockedCompareExchangePointer(
                                              (VOID **) &(m_rgpfqQueues[priIndex]),
                                              (VOID *) pfqQueueNew,
                                              NULL);
            if (NULL != pfqQueue) 
            {
                //someone else updated first
                delete pfqQueueNew;
            }
            else
            {
                //Our updated worked
                pfqQueue = pfqQueueNew;
            }
            pfqQueueNew = NULL;
        }   
        else //allocation failed
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    //at this point queue ptr should be good
    _ASSERT(pfqQueue);

    //Assume enqueue will work - optimize to avoid dealing with negative stats

    //Mark queue as non-empty
    dwFlags = dwInterlockedUnsetBits(&m_dwFlags, DMQ_EMPTY);
    if (DMQ_EMPTY & dwFlags)
        UpdateOldest(pmsgref->pftGetAge());

    //
    //  Keep track of how many threads are enqueuing so that we know what
    //  is the most we can expect to be off in our message count.
    //
    InterlockedIncrement((PLONG) &m_cCurrentThreadsEnqueuing);
    
    //Add the msg to the appropriate queue
    if (fEnqueue)
        hr = pfqQueue->HrEnqueue(pmsgref);
    else
        hr = pfqQueue->HrRequeue(pmsgref);

    //If the enqueue/requeue succeeded, update the stats. DO NOT update the 
    //stats before the enqueue/requeue attempt. This will cause the link to
    //wake up and start spinning off connections before the msg is enqueued.
    //See bug 88931
    if (SUCCEEDED(hr))
        UpdateMsgStats(pmsgref, TRUE);

    InterlockedDecrement((PLONG) &m_cCurrentThreadsEnqueuing);

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::HrDequeueMsg ]-------------------------------------------
//
//
//  Description:
//      Finds and dequeues the next message.  All OUT parameters are 
//      ref-counted.  The call is responsible for there release
//  Parameters:
//      OUT ppmsgref - MsgRef dequeued
//      OUT ppdmrq   - Ptr to retry interface (can be NULL)
//  Returns:
//      NO_ERROR if successful
//      AQUEUE_E_QUEUE_EMPTY if no messages in queue
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrDequeueMsg(OUT CMsgRef **ppmsgref,
                                    OUT CDestMsgRetryQueue **ppdmrq)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrDequeueMsg");
    Assert(ppmsgref);
    HRESULT             hr         = S_OK;
    DWORD               priCurrent = eEffPriHighPlus; //start at highest priority
    *ppmsgref = NULL;

    Assert(priCurrent < NUM_PRIORITIES);

    hr = AQUEUE_E_QUEUE_EMPTY;

    while (TRUE)
    {

        if (NULL != m_rgpfqQueues[priCurrent])
        {
            hr = m_rgpfqQueues[priCurrent]->HrDequeue(ppmsgref);

            if (SUCCEEDED(hr))
            {
                if ((*ppmsgref)->fIsMsgFrozen())
                {
                    //Msg is frozen, we need to put it in
                    //the retry queue and get the next one

                    //We must call UpdateMsgStats,because
                    //MergeRetryQueue will re-add it.
                    UpdateMsgStats(*ppmsgref, FALSE);
                    hr = HrRetryMsg(*ppmsgref);
                    if (FAILED(hr))
                        goto Exit;
                    (*ppmsgref)->Release();
                    *ppmsgref = NULL;
                    continue;
                }
                else
                {
                    break;
                }
            }
            else if (hr != AQUEUE_E_QUEUE_EMPTY)
            {
                //some unexpected error has occured
                goto Exit;
            }
        }

        //otherwise decrement the priority
        if (priCurrent == eEffPriLow)
            break;

        Assert(eEffPriLow < priCurrent);
        priCurrent--;
    }

    if (FAILED(hr))
        goto Exit;

    Assert(*ppmsgref);
    
    //Before we update stats.  AddRef the retry interface so there is 
    //no timing window where the queue is erroniously marked as empty
    if (ppdmrq)
    {
        *ppdmrq = &m_dmrq;
        m_dmrq.AddRef();
    }

    UpdateMsgStats(*ppmsgref, FALSE);

    //approximate oldest
    UpdateOldest((*ppmsgref)->pftGetAge());


  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::UpdateMsgStats ]---------------------------------------
//
//
//  Description:
//      Updates stats.  A shared lock must be aquired before calling into this.
//  Parameters:
//      IN pmsgref  - message reference added or removed
//      IN fAdd     - TRUE => msgref is being added the queue
//                    FALSE => msgref is being removed from the queue
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::UpdateMsgStats(IN CMsgRef *pmsgref, IN BOOL fAdd)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::UpdateMsgStats");
    Assert(pmsgref);

    CAQStats aqstats;

    if (fAdd)
    {
        m_paqinst->IncQueueMsgInstances();
    }
    else
    {
        m_paqinst->DecQueueMsgInstances();
    }

    aqstats.m_cMsgs = 1;
    aqstats.m_rgcMsgPriorities[pmsgref->PriGetPriority()] = 1;
    aqstats.m_uliVolume.QuadPart = (ULONGLONG) pmsgref->dwGetMsgSize();
    aqstats.m_pdmq = this;
    aqstats.m_dwNotifyType = NotifyTypeDestMsgQueue;
    aqstats.m_dwHighestPri = pmsgref->PriGetPriority();

    //Keep track of the number of *other* domains this is being sent to, so
    //that we can make an accurate guess when to create connections
    aqstats.m_cOtherDomainsMsgSpread = pmsgref->cGetNumDomains()-1;

    //
    //  Make sure that our stats are within reason.  We expect to be negative
    //  for short periods of time, but never more negative than the 
    //  number of threads currently enqueueing.
    //
    _ASSERT(m_aqstats.m_cMsgs+m_cCurrentThreadsEnqueuing < 0xFFFFFFF0);

    m_slPrivateData.ShareLock();

    m_aqstats.UpdateStats(&aqstats, fAdd);

    //send notification off to link
    if (m_plmq)
    {
        //Caller does not care about success of notification... only
        //about updating stats
        m_plmq->HrNotify(&aqstats, fAdd);
    }

    m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
}

//---[ CDestMsgQueue::HrRetryMsg ]---------------------------------------------
//
//
//  Description:
//      Add an message to the queue for retry.  This will put a message in
//      a retry queue (that is not usually checked during HrDequeueMessage)
//  Parameters:
//      IN  pmsgref     Message to add to the queue for retry
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrRetryMsg(IN CMsgRef *pmsgref)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::HrRetryMsg");
    HRESULT hr = S_OK;

    _ASSERT(pmsgref);

    hr = m_fqRetryQueue.HrRequeue(pmsgref);

    //If we couldn't put it in retry queue... retry when all references 
    //have been released
    if (FAILED(hr))
        pmsgref->RetryOnDelete();

    hr = S_OK;

    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::MarkQueueEmptyIfNecessary ]------------------------------
//
//
//  Description: 
//      Checks and sees if it is OK to mark the queue as empty.  Will 
//      insert it in the empty list if needed.
//      If queue is now empty (and not tagged as empty), then we need to put
//      it in the empty queue list.  If it is already tagged as empty, then
//      it is already in the empty queue list with the appropirate expire time.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/25/1999 - MikeSwa Created (separated from MergeRetryQueue())
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::MarkQueueEmptyIfNecessary()
{
    
    //A queue cannot be considered empty if any of the following conditions
    //  - There are messages queued up for delivery
    //  - There are messages pending ack (someone has a reference to the 
    //     retry interface)
    //  - There are messages pending retry

    // if we can't get the shutdown lock then there is no reason to mark the
    // queue as empty, since it will go away when we shutdown
    if (m_paqinst->fTryShutdownLock()) {
        //To be thread safe we should check in the opposite order that they 
        //are set/unset.  On dequeue, we add a ref count, then update stats.  On
        //retry we update the retry stats, and then release.
        //
        if (!m_aqstats.m_cMsgs && 
            !m_dmrq.m_cRetryReferenceCount &&
            !m_fqRetryQueue.cGetCount() && 
            !(m_dwFlags & DMQ_EMPTY))
        {
            m_paqinst->pdmtGetDMT()->AddDMQToEmptyList(this);
        }
        m_paqinst->ShutdownUnlock();
    }

}
//---[ CDestMsgQueue::HrGenerateDSNsIfNecessary ]-----------------------------
//
//
//  Description:
//      Merge Messages from retry queue into main priority queues and 
//      generates DSNs if neccessary.
//  Parameters:
//      IN pqlQueues            List of queues to pass to DSN code
//      IN hrConnectionStatus   HRESULT that should be passed to DSN generation
//                              code.
//      IN OUT pdwContext       Context that is used to throttle
//                              DSN generation.  Should be initialzed to 
//                              0 on first call.  Actually used to store 
//                              the tick count when we started DSN generation
//  Returns:
//      Failures will be handled internally
//      S_OK - success, and all messages processed
//      HRESULT_FROM_WIN32(E_PENDING) - more messages left to processes
//  History:
//      11/10/1999 - MikeSwa Modified to return pending error
//
//-----------------------------------------------------------------------------
HRESULT CDestMsgQueue::HrGenerateDSNsIfNecessary(IN CQuickList *pqlQueues, 
                                                 IN HRESULT hrConnectionStatus,
                                                 IN OUT DWORD *pdwContext)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::GenerateDSNsIfNecessary");
    HRESULT hr = S_OK;
    int     i = 0;
    DEST_QUEUE_CONTEXT dqcontext(pdwContext, this, pqlQueues, hrConnectionStatus);

    //Re-merge retry queue
    MergeRetryQueue();

    //Check re-try queue as well since we may have frozen messages that need to
    //be NDR'd or DSN'd
    hr = m_fqRetryQueue.HrMapFn(CDestMsgQueue::HrWalkDMQForDSN, &dqcontext, NULL);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(E_PENDING) == hr)
        {
            DebugTrace((LPARAM) this, 
                "Hit DSN generation limit, must continue DSN genration later");
            goto Exit;
        }

        ErrorTrace((LPARAM) this, 
            "ERROR: Unable to Check Queues for DSNs - hr 0x%08X", hr);

        hr = S_OK;
    }
   
    for (i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
        {
            hr = m_rgpfqQueues[i]->HrMapFn(CDestMsgQueue::HrWalkDMQForDSN, 
                                            &dqcontext, NULL);
            if (FAILED(hr))
            {
                if (HRESULT_FROM_WIN32(E_PENDING) == hr)
                {
                    DebugTrace((LPARAM) this, 
                        "Hit msg limit, must continue DSN genration later");
                    goto Exit;
                }

                ErrorTrace((LPARAM) this, 
                    "ERROR: Unable to Check Queues for DSNs - hr 0x%08X", hr);
                
                hr = S_OK;
            }
        }
    }

    //
    //  If we where checking for stale messages, we should stop until we
    //  hit another stale message on a message ack
    //
    dwInterlockedUnsetBits(&m_dwFlags, DMQ_CHECK_FOR_STALE_MSGS);


  Exit:
    MarkQueueEmptyIfNecessary();
    TraceFunctLeave();
    return hr;
}

//---[ CDestMsgQueue::MergeRetryQueue ]------------------------------------------
//
//
//  Description: 
//      Merges retry queues with normal queues.  Will keep frozen msgs in
//      retry queue.
//  Parameters:
//      -
//  Returns:    
//      -
//  History:
//      12/13/98 - MikeSwa split from original MergeRetryQueue
//                    (now called GenerateDSNsIfNecessary)
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::MergeRetryQueue()
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::MergeRetryQueue");
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = NULL;
    CMsgRef *pmsgrefFirstFrozen = NULL;
    DWORD   cMsgsInRetry = m_fqRetryQueue.cGetCount();
    DWORD   cMsgsProcessed = 0;

    while (SUCCEEDED(hr))
    {
        //While we have a mechanism to loop through the queue only once by 
        //checking the pmsgrefFirstFrozen pointer.  It is possible that another
        //thread will remove that from the queue (unfreeze, NDR, etc), so it 
        //is important that we have a failsafe mechanism.  Worst case here, is
        //that we will see every message twice, but lets us handle extra
        //messages added to the retry queue.
        if (cMsgsProcessed++ > 2*cMsgsInRetry)
            break;

        hr = m_fqRetryQueue.HrDequeue(&pmsgref);
        if (FAILED(hr))
            break;
           
        //Handle frozen messages sitting in the retry queue
        if (pmsgref->fIsMsgFrozen())
        {
            //Message is frozen, we are keeping it in the retry queue

            hr = m_fqRetryQueue.HrEnqueue(pmsgref);
            if (FAILED(hr))
            {
                //Mark Msgref as retry
                pmsgref->RetryOnDelete();
                ErrorTrace((LPARAM) this, 
                    "ERROR: Unable to add frozen msg to retry queue - msg 0x%X", pmsgref);
            }

            pmsgref->Release();
            
            //See if we've made it all the way through the retry queue
            if (!pmsgrefFirstFrozen)
                pmsgrefFirstFrozen = pmsgref;
            else if (pmsgref == pmsgrefFirstFrozen)
                break;
        }
        else
        {
            //Re-queue non-frozen message for delivery
            hr = HrAddMsg(pmsgref, FALSE, FALSE);

            if (FAILED(hr))
            {
                pmsgref->RetryOnDelete();
                ErrorTrace((LPARAM) this, "ERROR: Unable to merge retry queue - msg 0x%X", pmsgref);
            }

            pmsgref->Release();
        }
    }

    MarkQueueEmptyIfNecessary();
    TraceFunctLeave();
}

//---[ CDestMsgQueue::RemoveDMQFromLink ]--------------------------------------
//
//
//  Description:
//      Removes this DMQ from its associated link
//  Parameters:
//      fNotifyLink     TRUE if not being called by owning link, and link needs
//                      to be notified
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//      11/6/98 - MikeSwa Modified to allow changes to routing info
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::RemoveDMQFromLink(BOOL fNotifyLink)
{
    _ASSERT(DESTMSGQ_SIG == m_dwSignature);    
    CLinkMsgQueue *plmq = NULL;
    CAQStats    aqstats;
    
    m_slPrivateData.ExclusiveLock();
    plmq = m_plmq;
    m_plmq = NULL;
    if (plmq && fNotifyLink)
        memcpy(&aqstats, &m_aqstats, sizeof(CAQStats));
    m_slPrivateData.ExclusiveUnlock();

    if (plmq)
    {
        if (fNotifyLink)
            plmq->RemoveQueue(this, &aqstats);
        plmq->Release();
    }
}

//---[ CDestMsgQueue::SetRouteInfo ]-------------------------------------------
//
//
//  Description: 
//      Sets the routing information for this domain.  Will blow away any 
//      previous routing info.
//  Parameters:
//      IN  plmq        Link to associate with this domain.
//  Returns:
//      -
//  History:
//      11/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::SetRouteInfo(CLinkMsgQueue *plmq)
{
    TraceFunctEnterEx((LPARAM) this, "CDestMsgQueue::SetRouteInfo");
    HRESULT hr = S_OK;
    CAQStats aqstats;
    //First blow-away old routing info
    RemoveDMQFromLink(TRUE);
    
    //Grab lock and update routing info
    m_slPrivateData.ExclusiveLock();
    m_plmq = plmq;
    if (plmq)
    {
        plmq->AddRef();
        memcpy(&aqstats, &m_aqstats, sizeof(CAQStats));
        aqstats.m_dwNotifyType |= NotifyTypeDestMsgQueue;
        hr = plmq->HrNotify(&aqstats, TRUE);
        if (FAILED(hr))
        {
            //nothing really we can do
            ErrorTrace((LPARAM) this, 
                "ERROR: Unable to update link stats - hr 0x%08X", hr);
        }
    }
    m_slPrivateData.ExclusiveUnlock();
    TraceFunctLeave();
}

//---[ CDestMsgQueue::plmqGetLink ]--------------------------------------------
//
//
//  Description: 
//      Returns the Addref'd Link for the Queue.
//  Parameters:
//      -
//  Returns:
//      Ptr to CLinkMsgQueue
//  History:
//      5/14/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CDestMsgQueue::plmqGetLink()
{
    CLinkMsgQueue *plmq = NULL;
    m_slPrivateData.ShareLock();
    plmq = m_plmq;
    if (plmq)
        plmq->AddRef();
    m_slPrivateData.ShareUnlock();

    return plmq;
}


//---[ CDestMsgQueue::HrGetQueueID ]--------------------------------------------
//
//
//  Description: 
//      Gets the QueueID for this DMQ.  Used by Queue Admin
//  Parameters:
//      IN OUT pQueueID     QUEUELINK_ID struct to fill in
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      12/3/98 - MikeSwa Created 
//      2/23/99 - MikeSwa Modified to be part of IQueueAdminQueue interface
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrGetQueueID(QUEUELINK_ID *pQueueID)
{
    DWORD   cbDomainName = m_dmap.pdentryGetQueueEntry()->cbGetDomainNameLength();
    LPSTR   szDomainName = m_dmap.pdentryGetQueueEntry()->szGetDomainName();
    pQueueID->qltType = QLT_QUEUE;
    pQueueID->dwId = m_aqmt.dwGetMessageType();
    m_aqmt.GetGUID(&pQueueID->uuid);

    pQueueID->szName = wszQueueAdminConvertToUnicode(szDomainName, 
                                                             cbDomainName);
    if (!pQueueID->szName)
        return E_OUTOFMEMORY;

    return S_OK;
}


//---[ CDestMsgQueue::HrGetQueueInfo ]------------------------------------------
//
//
//  Description: 
//      Gets the Queue Admin infor for this Queue
//  Parameters:
//      IN OUT pqiQueueInfo     Ptr to Queue Info Stucture to fill
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate memory for queue name.
//  History:
//      12/5/98 - MikeSwa Created 
//      2/22/99 - MikeSwa changed to COM function
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrGetQueueInfo(QUEUE_INFO *pqiQueueInfo)
{
    DWORD   cbDomainName = m_dmap.pdentryGetQueueEntry()->cbGetDomainNameLength();
    LPSTR   szDomainName = m_dmap.pdentryGetQueueEntry()->szGetDomainName();
    HRESULT hr = S_OK;

    //Get # of messages = # in queue + failed msgs
    pqiQueueInfo->cMessages = m_aqstats.m_cMsgs + cGetFailedMsgs();

    //Get DMQ name
    pqiQueueInfo->szQueueName = wszQueueAdminConvertToUnicode(szDomainName, 
                                                              cbDomainName);
    if (!pqiQueueInfo->szQueueName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pqiQueueInfo->cbQueueVolume.QuadPart = m_aqstats.m_uliVolume.QuadPart;

    pqiQueueInfo->dwMsgEnumFlagsSupported = AQUEUE_DEFAULT_SUPPORTED_ENUM_FILTERS;

    //Get Link name
    m_slPrivateData.ShareLock();

    if (m_plmq && !m_plmq->fRPCCopyName(&pqiQueueInfo->szLinkName))
        hr = E_OUTOFMEMORY;

    m_slPrivateData.ShareUnlock();

  Exit:
    return hr;
}

//---[ CDestMsgQueue::UpdateOldest ]-------------------------------------------
//
//
//  Description: 
//      Updates the age of the "oldest" message in the queue
//  Parameters:
//      pft     Ptr to filetime of oldest nessage
//  Returns:
//      -
//  History:
//      12/13/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::UpdateOldest(FILETIME *pft)
{
    DWORD dwFlags = dwInterlockedSetBits(&m_dwFlags, DMQ_UPDATING_OLDEST_TIME);

    if (!(DMQ_UPDATING_OLDEST_TIME & dwFlags))
    {
        //we got the spin lock
        memcpy(&m_ftOldest, pft, sizeof(FILETIME));
        dwInterlockedUnsetBits(&m_dwFlags, DMQ_UPDATING_OLDEST_TIME);
    }
}

//---[ CDestMsgQueue::QueryInterface ]-----------------------------------------
//
//
//  Description: 
//      QueryInterface for CDestMsgQueue that supports:
//          - IQueueAdminAction
//          - IUnknown
//          - IQueueAdminQueue 
//  Parameters:
//
//  Returns:
//
//  History:
//      2/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminQueue == riid)
    {
        *ppvObj = static_cast<IQueueAdminQueue *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CDestMsgQueue::HrApplyQueueAdminFunction ]------------------------------
//
//
//  Description: 
//      Will call the IQueueAdminMessageFilter::Process message for every 
//      message in this queue.  If the message passes the filter, then
//      HrApplyActionToMessage on this object will be called.
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created 
//      4/1/99 - MikeSwa Merged implementations of ApplyQueueAdminFunction
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrApplyQueueAdminFunction(
                     IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_OK;
    DWORD   i = 0;
    DWORD   dwFlags = 0;
    PVOID   pvOldContext = NULL;
    CDMQAdminContext dmqctxt;

    _ASSERT(pIQueueAdminMessageFilter);
    hr = pIQueueAdminMessageFilter->HrSetQueueAdminAction(
                                    (IQueueAdminAction *) this);

    //This is an internal interface that should not fail
    _ASSERT(SUCCEEDED(hr) && "HrSetQueueAdminAction");

    if (FAILED(hr))
        goto Exit;

    pIQueueAdminMessageFilter->HrGetCurrentUserContext(&pvOldContext);
    pIQueueAdminMessageFilter->HrSetCurrentUserContext(&dmqctxt);

    //Apply action to every queue in DMQ
        
    dwInterlockedSetBits(&m_dwFlags, DMQ_QUEUE_ADMIN_OP_PENDING);

    //Map function on retry queue first, because that will make display
    //order more consistant, since messages that where at the front of
    //the queue, will be in the retry queue for retry errors.
    dmqctxt.m_dwState = DMQAdminContextRetryQueue;
    hr = m_fqRetryQueue.HrMapFn(QueueAdminApplyActionToMessages, 
                                pIQueueAdminMessageFilter, NULL);
    dmqctxt.m_dwState = DMQAdminContextDefault;
    if (FAILED(hr))
        goto Exit;


    for (i = 0; i < NUM_PRIORITIES; i++)
    {
        if (NULL != m_rgpfqQueues[i])
        {
            hr = m_rgpfqQueues[i]->HrMapFn(QueueAdminApplyActionToMessages, 
                                           pIQueueAdminMessageFilter, NULL);
            if (FAILED(hr))
            {
                goto Exit;
            }
        }
    }
  

  Exit:
    dwFlags = dwInterlockedUnsetBits(&m_dwFlags, DMQ_QUEUE_ADMIN_OP_PENDING);

    //
    //  NOTE - By doing this here, we will only check DMQ's for which
    //  explicit queue admin actions have happened.  Other DMQ's will wait
    //  for retry or another QAPI action.
    //
    if (DMQ_CHECK_FOR_THAWED_MSGS & dwFlags)
    {
        //We need to walk the retry queue for thawed msgs.  We have to do 
        //it here, because otherwise we might deadlock if this thread called
        //MergeRetryQueue() from within the HrMapFn
        dwInterlockedUnsetBits(&m_dwFlags, DMQ_CHECK_FOR_THAWED_MSGS);
        MergeRetryQueue();
    }

    //Restore inital context
    pIQueueAdminMessageFilter->HrSetCurrentUserContext(pvOldContext);
    return hr;
}

//---[ CDestMsgQueue::HrApplyActionToMessage ]---------------------------------
//
//
//  Description: 
//      Applies an action to this message for this queue.  This will be called
//      by the IQueueAdminMessageFilter during a queue enumeration function.
//  Parameters:
//      IN  *pIUnknownMsg       ptr to message abstraction
//      IN  ma                  Message action to perform
//      IN  pvContext           Context set on IQueueAdminFilter
//      OUT pfShouldDelete      TRUE if the message should be deleted
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created 
//      4/2/99 - MikeSwa Added context
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDestMsgQueue::HrApplyActionToMessage(
                     IUnknown *pIUnknownMsg,
                     MESSAGE_ACTION ma,
                     PVOID  pvContext,
                     BOOL *pfShouldDelete)
{
    HRESULT hr = S_OK;
    CMsgRef *pmsgref = (CMsgRef *)pIUnknownMsg;
    CDMQAdminContext *pdmqctxt = (CDMQAdminContext *)pvContext;
    BOOL    fUpdateStats = TRUE;


    _ASSERT(pmsgref);
    _ASSERT(pfShouldDelete);
    _ASSERT(pdmqctxt);
    _ASSERT(pdmqctxt && (DMQ_ADMIN_CONTEXT_SIG == pdmqctxt->m_dwSignature));

    if (pdmqctxt && 
        (DMQ_ADMIN_CONTEXT_SIG == pdmqctxt->m_dwSignature) &&
        (DMQAdminContextRetryQueue == pdmqctxt->m_dwState))
    {
        //We should not update stats if we are working on the retry queue
        fUpdateStats = FALSE;
    }

    *pfShouldDelete = FALSE;

    switch (ma)
    {
      case MA_DELETE:
        hr = pmsgref->HrQueueAdminNDRMessage((CDestMsgQueue *)this);
        *pfShouldDelete = TRUE;
        break;
      case MA_DELETE_SILENT:
        hr = pmsgref->HrRemoveMessageFromQueue((CDestMsgQueue *)this);
        *pfShouldDelete = TRUE;
        break;
      case MA_FREEZE_GLOBAL:
        pmsgref->GlobalFreezeMessage();
        break;
      case MA_THAW_GLOBAL:
        pmsgref->GlobalThawMessage();
        
        //
        //  Mark this queue as one to check for thawed messages.  
        //
        QueueAdminCheckForThawedMsgs();
        break;
      case MA_COUNT:
      default:
        //do nothing for counting and default
        break;
    }

    if (*pfShouldDelete && SUCCEEDED(hr) && fUpdateStats) {
        UpdateMsgStats(pmsgref, FALSE);
        MarkQueueEmptyIfNecessary();
    }

    return hr;
}

//---[ CDestMsgQueue::fMatchesID ]---------------------------------------------
//
//
//  Description: 
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CDestMsgQueue::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    //This is not used at the DMQ level
    _ASSERT(0 && "Not implemented");
    return E_NOTIMPL;
}

//---[ CDestMsgQueue::SendLinkStateNotification ]------------------------------
//
//
//  Description: 
//      Sends link state notification saying that the link was created.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      8/18/99 - AWetmore Created 
//
//-----------------------------------------------------------------------------
void CDestMsgQueue::SendLinkStateNotification(void) {
    CLinkMsgQueue *plmq = plmqGetLink();
    if (plmq) {
        plmq->SendLinkStateNotificationIfNew();
        plmq->Release();
    }
}

//---[ CDestMsgQueue::fIsRemote ]----------------------------------------------
//
//
//  Description: 
//      Determines if queue is routed remotely.  Caller should have routing 
//      share lock.
//  Parameters:
//      -
//  Returns:
//      TRUE if link is routed remotely
//      FALSE otherwise
//  History:
//      11/29/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CDestMsgQueue::fIsRemote()
{
    CLinkMsgQueue *plmq = plmqGetLink();
    BOOL           fIsRemote = FALSE;
    if (plmq) {
        fIsRemote = plmq->fIsRemote();
        plmq->Release();
    }

    return fIsRemote;
}


//---[ CDestMsgRetryQueue::CheckForStaleMsgsNextDSNGenerationPass ]------------
//
//
//  Description: 
//      Marks the queue as so that we will do the (expensive) check for
//      stale messages during the next DSN generation pass.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      4/18/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID CDestMsgRetryQueue::CheckForStaleMsgsNextDSNGenerationPass()
{
    _ASSERT(m_pdmq);
    dwInterlockedSetBits(&(m_pdmq->m_dwFlags), 
                         CDestMsgQueue::DMQ_CHECK_FOR_STALE_MSGS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\dsnevent.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnevent.h
//
//  Description: Define dsnevent structure. Used to pass parameters to DSN sink
//      with intelligent defaults
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/11/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNEVENT_H__
#define __DSNEVENT_H__

#define DSN_PARAMS_SIG 'PnsD'
const   CHAR    DEFAULT_MTA_TYPE[] = "dns";

#define DSN_LINE_PREFIX " : Line #"
#define DSN_LINE_SUFFIX "!         " //leave space for filename
//This is something of a hack to get the line number in 
#define SET_DEBUG_DSN_CONTEXT(x, linenum) \
{ \
    (x).szDebugContext = __FILE__ DSN_LINE_PREFIX DSN_LINE_SUFFIX; \
    register LPSTR szCurrent = (x).szDebugContext +  \
                                sizeof(__FILE__) +  \
                                sizeof(DSN_LINE_PREFIX) - 2*sizeof(CHAR); \
} //*** See comment below (remove this line when code is fixed)
//The following code will AV in the IIS Build environment
//  if ('!' == *szCurrent) \
//      _itoa(linenum, szCurrent, 10); \
//}

//---[ CDSNParams ]------------------------------------------------------------
//
//
//  Description: 
//      Encapsulated DSN Parameters in a class
//  Hungarian: 
//      dsnparams, *pdsnparams
//  
//-----------------------------------------------------------------------------
class CDSNParams
{
  protected:
    DWORD       m_dwSignature;
  public: //actual parameters of DSN Generation event
    IMailMsgProperties *pIMailMsgProperties;
    DWORD dwStartDomain; //starting index used to init context
    DWORD dwDSNActions;  //type(s) of DSN to generate
    DWORD dwRFC821Status; //global RFC821 status
    HRESULT hrStatus; //global HRESULT

    //OUT param(s)
    IMailMsgProperties *pIMailMsgPropertiesDSN;
    DWORD dwDSNTypesGenerated;
    DWORD cRecips; //# of recipients DSN'd
    LPSTR szDebugContext;  //debug context stampted as "x=" header
  public:
    inline CDSNParams();
};

CDSNParams::CDSNParams()
{
    m_dwSignature = DSN_PARAMS_SIG;
    pIMailMsgProperties = NULL;
    dwStartDomain = 0;
    dwDSNActions = 0;
    dwRFC821Status = 0;
    hrStatus = S_OK;
    pIMailMsgPropertiesDSN = NULL;
    dwDSNTypesGenerated = 0;
    cRecips = 0;
}

#endif //__DSNEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domcfg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: DomCfg.h
//
//  Description: DomainConfigTable header file.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DOMCFG_H__
#define __DOMCFG_H__

#include <baseobj.h>
#include <domhash.h>

#define INT_DOMAIN_INFO_SIG 'fnID'
#define DOMAIN_CONFIG_SIG   ' TCD'

//---[ eIntDomainInfoFlags ]---------------------------------------------------
//
//
//  Description: Internal Domain Info flags
//
//
//-----------------------------------------------------------------------------
typedef enum
{
    INT_DOMAIN_INFO_OK                  = 0x00000000,
    INT_DOMAIN_INFO_INVALID             = 0x80000000,  //The domain info struct
                                                       //has been replaced... if
                                                       //an object has a cached
                                                       //copy it should release it
} eIntDomainInfoFlags;

//---[ CInternalDomainInfo ]---------------------------------------------------
//
//  Description:
//      A entry in CDomainConfigTable.  Basically an internal wrapper for the
//      public DomainInfo struct.
//
//  Hungarian: IntDomainInfo, pIntDomainInfo
//
//-----------------------------------------------------------------------------
class CInternalDomainInfo : public CBaseObject
{
  public:
      CInternalDomainInfo(DWORD dwVersion);
      ~CInternalDomainInfo();
      HRESULT       HrInit(DomainInfo *pDomainInfo);
      DWORD         m_dwSignature;
      DWORD         m_dwIntDomainInfoFlags;
      DWORD         m_dwVersion;
      DomainInfo    m_DomainInfo;
};

//---[ CDomainConfigTable ]----------------------------------------------------
//
//
//  Description:
//      Contains per domain configuration information, and exposes wildcarded
//      hash-table based lookup of this information.
//
//  Hungarian: dct, pdct
//
//-----------------------------------------------------------------------------
class CDomainConfigTable
{
  protected:
    DWORD               m_dwSignature;
    DWORD               m_dwCurrentConfigVersion;
    CInternalDomainInfo *m_pLastStarDomainInfo;
    DOMAIN_NAME_TABLE   m_dnt;
    CShareLockInst      m_slPrivateData;
    DWORD               m_dwFlags;
    CInternalDomainInfo *m_pDefaultDomainConfig;

  public:
    CDomainConfigTable();
    ~CDomainConfigTable();
    HRESULT HrInit();
    HRESULT HrSetInternalDomainInfo(IN CInternalDomainInfo *pDomainInfo);
    HRESULT HrGetInternalDomainInfo(IN  DWORD cbDomainNameLength,
                           IN  LPSTR szDomainName,
                                  OUT CInternalDomainInfo **ppDomainInfo);
    HRESULT HrGetDefaultDomainInfo(OUT CInternalDomainInfo **ppDomainInfo);
    HRESULT HrIterateOverSubDomains(DOMAIN_STRING * pstrDomain,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
    {
        HRESULT hr = S_OK;
        m_slPrivateData.ShareLock();
        hr = m_dnt.HrIterateOverSubDomains(pstrDomain, pfn, pvContext);
        m_slPrivateData.ShareUnlock();
        return hr;
    };

    DWORD   dwGetCurrentVersion() {return m_dwCurrentConfigVersion;};

    void    StartConfigUpdate();
    void    FinishConfigUpdate();

    enum _DomainConfigTableFlags
    {
        DOMCFG_DOMAIN_NAME_TABLE_INIT = 0x00000001,
        DOMCFG_FINISH_UPDATE_PENDING  = 0x00000002, //StartConfig update has been called
        DOMCFG_MULTIPLE_STAR_DOMAINS  = 0x00000004, //There have been more that one
                                                    // "*" domain configured
    };
};

#endif //__DOMCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domcfg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: DomCfg.cpp
//
//  Description: Implementation of CDomainConfigTable and CInternalDomainInfo
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include <domhash.h>
#include "domcfg.h"
#include "aqutil.h"

//Encourage compiler to include symbols for enums
eDomainInfoFlags    g_eDomainInfo       = DOMAIN_INFO_USE_SSL;
eIntDomainInfoFlags g_eIntDomainInfo    = INT_DOMAIN_INFO_INVALID;

//---[ RemoveConfigEntryIteratorFn ]--------------------------------------------
//
//
//  Description: 
//      Deletes and releases all internal domain info objects in table
//  Parameters:
//          IN  pvContext   - pointer to context (ignored)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      6/17/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID RemoveConfigEntryIteratorFn(PVOID pvContext, PVOID pvData, BOOL fWildcard, 
                    BOOL *pfContinue, BOOL *pfDelete)
{
    CInternalDomainInfo *pIntDomainInfo = (CInternalDomainInfo *) pvData;
    *pfDelete = TRUE;
    *pfContinue = TRUE;
    _ASSERT(INT_DOMAIN_INFO_SIG == pIntDomainInfo->m_dwSignature);
    pIntDomainInfo->m_dwIntDomainInfoFlags |= INT_DOMAIN_INFO_INVALID;
    pIntDomainInfo->Release();
}


//---[ RemoveOutdatedConfigEntryIteratorFn ]------------------------------------
//
//
//  Description: 
//      Deletes and releases all outdated internal domain info objects in table.
//      An internal domain entry is considered outdated if its version number
//      does not match the global version number.
//  Parameters:
//          IN  pvContext   - pointer to context (current version number)
//          IN  pvData      - data entry to look at
//          IN  fWildcardData - TRUE if data is a wildcard entry (ignored)
//          OUT pfContinue  - TRUE if iterator should continue to the next entry
//          OUT pfRemoveEntry - TRUE if entry should be deleted
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID RemoveOutdatedConfigEntryIteratorFn(PVOID pvContext, PVOID pvData, 
                    BOOL fWildcard, BOOL *pfContinue, BOOL *pfDelete)
{
    CInternalDomainInfo *pIntDomainInfo = (CInternalDomainInfo *) pvData;
    _ASSERT(INT_DOMAIN_INFO_SIG == pIntDomainInfo->m_dwSignature);
    _ASSERT(pvContext);
    *pfContinue = TRUE;

    if (pIntDomainInfo->m_dwVersion != *((DWORD *)pvContext))
    {
        //make sure it is not the root entry
        if ((1*sizeof(CHAR) == pIntDomainInfo->m_DomainInfo.cbDomainNameLength) &&
            ('*'  == pIntDomainInfo->m_DomainInfo.szDomainName[0]) &&
            ('\0' == pIntDomainInfo->m_DomainInfo.szDomainName[1]))
        {
            //
            //NOTE - It is not expected for this to happen.  We expect
            //SMTP to always provide a default entry.  If SMTP changes such
            //that does not, then dynamic updates would fail, because we never
            //mark the default entry that we create as invalid.  Once a link 
            //picks up this entry, it will never let it go.
            //
            _ASSERT(0 && "SMTP did not supply a * entry");

            //It is the root entry... update verision number
            
            //NOTE: The Root entry is a special case... it is required to be
            //present at all times, and is not always inserted into the 
            //metabase.  Because of this, it's version number may be incorrect,
            //so we need to make sure that we don't remove it.
            *pfDelete = FALSE;
            pIntDomainInfo->m_dwVersion = *((DWORD *)pvContext);
        }
        else
        {
            //The entry is old
            *pfDelete = TRUE;
            pIntDomainInfo->m_dwIntDomainInfoFlags |= INT_DOMAIN_INFO_INVALID;
            pIntDomainInfo->Release();
        }
    }
    else
    {
        *pfDelete = FALSE;
    }
}

//---[ HrCopyStringProperty ]--------------------------------------------------
//
//
//  Description: 
//      Private helper function that is used to allocate and copy string 
//      properties in the DomainInfo struct
//  Parameters:
//      OUT (ref)   szDest      Dest string to allocate and copy to
//      IN          szSource    Source string to copy
//      IN          cbLength    Length of string (without ending '\0'
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT inline HrCopyStringProperty(LPSTR &szDest, const LPSTR szSource, 
                                    DWORD cbLength)
{
    HRESULT hr = S_OK;
    _ASSERT(szSource);  //must have a buffer to copy
    _ASSERT(!szDest);

    szDest = (LPSTR) pvMalloc(cbLength + sizeof(CHAR));
    if (!szDest)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //copy data
    memcpy(szDest, szSource, cbLength);  //copy string
    szDest[cbLength] = '\0';

  Exit:
    return hr;
}

//---[ COPY_DOMAIN_INFO_STRING_PROP ]------------------------------------------
//
//
//  Description: 
//      Macro used to call private helper function HrCopyStringProperty
//  Parameters:
//      pOldDomainInfo      DomainInfo Struct to copy
//      pNewDomainInfo      New DomainInfo stuct to copy to
//      cbProp              Name of size property
//      szProp              Name of string proptery
//  Returns:
//      
//
//-----------------------------------------------------------------------------
#define COPY_DOMAIN_INFO_STRING_PROP(pOldDomainInfo, pNewDomainInfo, cbProp, szProp) \
{                                                                               \
    _ASSERT(!(pNewDomainInfo)->cbProp);                                         \
    _ASSERT(!(pNewDomainInfo)->szProp);                                         \
    (pNewDomainInfo)->cbProp = (pOldDomainInfo)->cbProp;                        \
    if ((pOldDomainInfo)->cbProp)                                               \
        hr = HrCopyStringProperty((pNewDomainInfo)->szProp,                     \
                (pOldDomainInfo)->szProp, (pOldDomainInfo)->cbProp);            \
}

//---[ CInternalDomainInfo::CInternalDomainInfo ]------------------------------
//
//
//  Description: 
//      Object constructor.  Initializes DomainInfo struct
//  Parameters:
//      DWORD   dwVersion   Current DomainConfigTable version
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa - added version
//
//-----------------------------------------------------------------------------
CInternalDomainInfo::CInternalDomainInfo(DWORD dwVersion)
{
    ZeroMemory(&m_DomainInfo.dwDomainInfoFlags, sizeof(DomainInfo) - sizeof(DWORD));
    m_dwIntDomainInfoFlags = INT_DOMAIN_INFO_OK;
    m_dwSignature = INT_DOMAIN_INFO_SIG;
    m_dwVersion = dwVersion;

    //make sure our assumptions about the struct of DomainInfo are valid
    _ASSERT(1 == ((DWORD *) &m_DomainInfo.dwDomainInfoFlags) - ((DWORD *) &m_DomainInfo));

    m_DomainInfo.cbVersion = sizeof(DomainInfo);
}

//---[ CInternalDomainInfo::~CInternalDomainInfo ]-----------------------------
//
//
//  Description: 
//      Class destructor... deallocates any memory associated with the 
//      DomainInfo struct
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CInternalDomainInfo::~CInternalDomainInfo()
{
    _ASSERT(m_DomainInfo.cbVersion == sizeof(DomainInfo));

    if (m_DomainInfo.szDomainName)
        FreePv(m_DomainInfo.szDomainName);

    if (m_DomainInfo.szETRNDomainName)
        FreePv(m_DomainInfo.szETRNDomainName);

    if (m_DomainInfo.szSmartHostDomainName)
        FreePv(m_DomainInfo.szSmartHostDomainName);

    if (m_DomainInfo.szDropDirectory)
        FreePv(m_DomainInfo.szDropDirectory);

    if (m_DomainInfo.szAuthType)
        FreePv(m_DomainInfo.szAuthType);

    if (m_DomainInfo.szUserName)
        FreePv(m_DomainInfo.szUserName);

    if (m_DomainInfo.szPassword)
        FreePv(m_DomainInfo.szPassword);

    if (m_DomainInfo.pvBlob)
        FreePv(m_DomainInfo.pvBlob);

}

//---[ CInternalDomainInfo::HrInit ]-------------------------------------------
//
//
//  Description: 
//      Clones a DomainInfo struct and allocates needed memory
//  Parameters:
//      IN  pDomainInfo     DomainInfo struct to copy
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if allocations fail
//-----------------------------------------------------------------------------
HRESULT CInternalDomainInfo::HrInit(DomainInfo *pDomainInfo)
{
    HRESULT hr = S_OK;

    m_DomainInfo.dwDomainInfoFlags = pDomainInfo->dwDomainInfoFlags;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbDomainNameLength, szDomainName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbETRNDomainNameLength, szETRNDomainName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbSmartHostDomainNameLength, szSmartHostDomainName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbDropDirectoryLength, szDropDirectory);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbAuthTypeLength, szAuthType);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbUserNameLength, szUserName);
    if (FAILED(hr))
        goto Exit;

    COPY_DOMAIN_INFO_STRING_PROP(pDomainInfo, &m_DomainInfo, 
        cbPasswordLength, szPassword);
    if (FAILED(hr))
        goto Exit;

    m_DomainInfo.cEtrnDelayTime = pDomainInfo->cEtrnDelayTime;

    //Copy the blob
    if (pDomainInfo->cbBlob)
    {
        _ASSERT(pDomainInfo->pvBlob);
        m_DomainInfo.pvBlob = (DWORD *) pvMalloc(pDomainInfo->cbBlob);
        if (!m_DomainInfo.pvBlob)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        //copy data
        memcpy(m_DomainInfo.pvBlob, pDomainInfo->pvBlob, pDomainInfo->cbBlob);
        m_DomainInfo.cbBlob = pDomainInfo->cbBlob;
    }

  Exit:
    return hr;
}

//---[ CDomainConfigTable::CDomainConfigTable ]--------------------------------
//
//
//  Description: 
//      Constuctor for CDomainConfig Table
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainConfigTable::CDomainConfigTable() :
                                m_slPrivateData("CDomainConfigTable")
{
    m_dwFlags = 0;
    m_dwSignature = DOMAIN_CONFIG_SIG;
    m_dwCurrentConfigVersion = 0;
    m_pLastStarDomainInfo = NULL;
    m_pDefaultDomainConfig = NULL;
}

//---[ CDomainConfigTable::~CDomainConfigTable ]-------------------------------
//
//
//  Description: 
//      Destructor for CDomainConfig Table
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CDomainConfigTable::~CDomainConfigTable()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::~CDomainConfigTable");
    HRESULT hr = S_OK;

    //Delete all entries from the table
    if (DOMCFG_DOMAIN_NAME_TABLE_INIT & m_dwFlags)
    {
        //iterate over all domains and delete entries in hash table
        m_dnt.HrIterateOverSubDomains(NULL, RemoveConfigEntryIteratorFn, NULL);
        if (m_pDefaultDomainConfig != NULL) {
            m_pDefaultDomainConfig->Release();
            m_pDefaultDomainConfig = NULL;
        }
        m_dwFlags ^= DOMCFG_DOMAIN_NAME_TABLE_INIT;
    }

    TraceFunctLeave();
}

//---[ CDomainConfigTable::HrInit ]--------------------------------------------
//
//
//  Description: 
//      Initializes DOMAIN_NAME_TABLE hash table
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrInit()
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::HrInit");
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfoDefault = NULL;
    DOMAIN_STRING strDomain;

    hr = m_dnt.HrInit();
    if (FAILED(hr))
        goto Exit;

    m_dwFlags |= DOMCFG_DOMAIN_NAME_TABLE_INIT;

    //Part 1
    //
    //Allocate an InternalDomainInfo for m_pDefaultDomainConfig. This
    //will be used for links/connections for which a routing sink has returned
    //no connector
    m_pDefaultDomainConfig = new CInternalDomainInfo(m_dwCurrentConfigVersion);
    if (!m_pDefaultDomainConfig) 
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    m_pDefaultDomainConfig->m_DomainInfo.cbDomainNameLength = 1;
    m_pDefaultDomainConfig->m_DomainInfo.szDomainName = 
        (LPSTR) pvMalloc(2*sizeof(CHAR));
    if (!m_pDefaultDomainConfig->m_DomainInfo.szDomainName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    memcpy(m_pDefaultDomainConfig->m_DomainInfo.szDomainName, "*", 2);


    //Part 2
    //
    //Create default "*" entry in the DCT so that arbitrary domains will have
    //something to match against. Note that this entry is separate from the
    //m_pDefaultDomainConfig entry that is *not* part of the DCT, and is used
    //for links/connections that are *not* supposed to match anything in the DCT
    pIntDomainInfoDefault = new CInternalDomainInfo(m_dwCurrentConfigVersion);
    if (!pIntDomainInfoDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pIntDomainInfoDefault->m_DomainInfo.cbDomainNameLength = 1;
    pIntDomainInfoDefault->m_DomainInfo.szDomainName = (LPSTR) pvMalloc(2*sizeof(CHAR));
    if (!pIntDomainInfoDefault->m_DomainInfo.szDomainName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    memcpy(pIntDomainInfoDefault->m_DomainInfo.szDomainName, "*", 2);

    strDomain.Length = (USHORT) pIntDomainInfoDefault->m_DomainInfo.cbDomainNameLength;
    strDomain.MaximumLength = strDomain.Length;
    strDomain.Buffer = pIntDomainInfoDefault->m_DomainInfo.szDomainName;
    hr = m_dnt.HrInsertDomainName(&strDomain, (PVOID) pIntDomainInfoDefault);

    if (FAILED(hr))
        goto Exit;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDomainConfigTable::HrSetInternalDomainInfo ]---------------------------
//
//
//  Description: 
//      Inserts InternalDomainInfo into hash table based on szDomain
//  Parameters:
//      IN  pIntDomainInfo      Internal DomainInfo to insert
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrSetInternalDomainInfo(
                    IN CInternalDomainInfo *pIntDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::SetInternalDomainInfo");
    HRESULT hr = S_OK;
    DOMAIN_STRING  strDomain;
    CInternalDomainInfo *pIntDomainInfoCurrent = NULL;

    _ASSERT(pIntDomainInfo);
    _ASSERT(pIntDomainInfo->m_DomainInfo.szDomainName);
    _ASSERT(pIntDomainInfo->m_DomainInfo.cbDomainNameLength);
    _ASSERT(pIntDomainInfo->m_dwVersion == m_dwCurrentConfigVersion);

    strDomain.Length = (USHORT) pIntDomainInfo->m_DomainInfo.cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) pIntDomainInfo->m_DomainInfo.cbDomainNameLength;
    strDomain.Buffer = pIntDomainInfo->m_DomainInfo.szDomainName;

    pIntDomainInfo->AddRef();

    //Get Lock on table
    m_slPrivateData.ExclusiveLock();

    //HACK ALERT
    //
    //SMTP calls this routine with info from one of two places:
    //1. For each domain configured in the /smtpsvc/1/domains container in the
    //   metabase. In PT, these entries are populated from address spaces on 
    //   connectors.
    //2. For outbound-security configured at the /smtpsvc/1 (ie, at the VS) 
    //   level, it creates a "dummy" entry for the "*" domain.
    //
    //Unfortunately, this creates a problem if you have a connector with the
    //   * address space, because the insertion in item 2 will overwrite the
    //   insertion for * in item 1. 
    //To handle this case, we keep the "last" * entry received in the 
    //   m_pLastStarDomainInfo. If we receive a second entry, then we know the
    //   m_pLastStarDomainInfo is a domain entry from item 1. Otherwise, it 
    //   is the default config info.
    //

    //
    //If this is the "*" domain, then store it in m_pLastStarDomainInfo, until
    //we decide whether this is really the star domain info from item 1 or 
    //the info from item 2
    //

    if (pIntDomainInfo->m_DomainInfo.cbDomainNameLength == 1 &&
            pIntDomainInfo->m_DomainInfo.szDomainName[0] == '*') {

        if (m_pLastStarDomainInfo == NULL) {
            m_pLastStarDomainInfo = pIntDomainInfo;
            hr = S_OK;
            goto Exit;
        } else {

            // This is the second * domain entry we have seen. Insert the
            // previous entry into the DMT, and keep this one as the last star
            // entry seen.

            pIntDomainInfoCurrent = pIntDomainInfo;
            pIntDomainInfo = m_pLastStarDomainInfo;
            m_pLastStarDomainInfo = pIntDomainInfoCurrent;

            pIntDomainInfoCurrent = NULL;
            dwInterlockedSetBits(&m_dwFlags, DOMCFG_MULTIPLE_STAR_DOMAINS);


        }

    }

    hr = m_dnt.HrInsertDomainName(&strDomain, (PVOID) pIntDomainInfo);
    if (FAILED(hr))
    {
        if (DOMHASH_E_DOMAIN_EXISTS == hr)
        {
            //someone already inserted for this domain
            hr = m_dnt.HrRemoveDomainName(&strDomain, 
                            (PVOID *) &pIntDomainInfoCurrent);
            _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN != hr); //someone violated write-lock
            if (FAILED(hr))
                goto Exit;

            _ASSERT(pIntDomainInfoCurrent);

            //Mark old info as invalid & release
            pIntDomainInfoCurrent->m_dwIntDomainInfoFlags |= INT_DOMAIN_INFO_INVALID;
            _ASSERT(pIntDomainInfoCurrent->m_dwVersion <= pIntDomainInfo->m_dwVersion);
            pIntDomainInfoCurrent->Release();
            pIntDomainInfoCurrent = NULL;

            hr = m_dnt.HrInsertDomainName(&strDomain, (PVOID) pIntDomainInfo);
            _ASSERT(DOMHASH_E_DOMAIN_EXISTS != hr); //someone violated write-lock
            if (FAILED(hr))
                goto Exit;
        }
        else
        {
            goto Exit;
        }
    }

  Exit:
    m_slPrivateData.ExclusiveUnlock();
    TraceFunctLeave();
    return hr;
}

//---[ CDomainConfigTable::HrGetInternalDomainInfo ]---------------------------
//
//
//  Description: 
//      Gets internal Domaininfo stuct from hash table.  Will use wildcard 
//      matching
//  Parameters:
//      IN      cbDomainnameLength      Length of string to search for
//      IN      szDomainName            Domain Name to search for
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if match is found
//      AQUEUE_E_INVALID_DOMAIN if no match is found
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrGetInternalDomainInfo(
                                  IN  DWORD cbDomainNameLength,
                                  IN  LPSTR szDomainName,
                                  OUT CInternalDomainInfo **ppIntDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::GetInternalDomainInfo");
    HRESULT hr = S_OK;
    DOMAIN_STRING  strDomain;

    _ASSERT(cbDomainNameLength);
    _ASSERT(szDomainName);
    _ASSERT(ppIntDomainInfo);

    strDomain.Length = (USHORT) cbDomainNameLength;
    strDomain.MaximumLength = (USHORT) cbDomainNameLength;
    strDomain.Buffer = szDomainName;

    m_slPrivateData.ShareLock();

    //Use wildcard lookup
    hr = m_dnt.HrFindDomainName(&strDomain, (PVOID *) ppIntDomainInfo, FALSE);

    if (FAILED(hr))
    {
        //It should at least match the default domain
        _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN != hr);  
        goto Exit;
    }

    _ASSERT(*ppIntDomainInfo);

    (*ppIntDomainInfo)->AddRef();

  Exit:
    m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
    return hr;
}

//---[ CDomainConfigTable::HrGetDefaultDomainInfo ]---------------------------
//
//
//  Description: 
//      Gets internal Default Domaininfo stuct.
//  Parameters:
//      OUT     ppIntDomainInfo         Domain info returned (must be released)
//  Returns:
//      S_OK    if successful
//      AQUEUE_E_INVALID_DOMAIN if error
//
//-----------------------------------------------------------------------------
HRESULT CDomainConfigTable::HrGetDefaultDomainInfo(
                                  OUT CInternalDomainInfo **ppIntDomainInfo)
{
    TraceFunctEnterEx((LPARAM) this, "CDomainConfigTable::GetDefaultDomainInfo");

    HRESULT hr = S_OK;

    *ppIntDomainInfo = NULL;

    m_slPrivateData.ShareLock();

    if (m_pDefaultDomainConfig != NULL) {
        *ppIntDomainInfo = m_pDefaultDomainConfig;
    } else {
        hr = AQUEUE_E_INVALID_DOMAIN;
        goto Exit;
    }

    _ASSERT(*ppIntDomainInfo);

    (*ppIntDomainInfo)->AddRef();

  Exit:
    m_slPrivateData.ShareUnlock();

    TraceFunctLeave();
    return hr;
}


//---[ CDomainConfigTable::StartConfigUpdate ]---------------------------------
//
//
//  Description: 
//      Signals that the metabase has been updated, and we will now begin to
//      get updated information.  Increments an internal version number that
//      will be used to removed old, outdated entries once all of the config
//      info has been updated.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDomainConfigTable::StartConfigUpdate()
{
    InterlockedIncrement((PLONG) &m_dwCurrentConfigVersion);
    _ASSERT(!(m_dwFlags & DOMCFG_FINISH_UPDATE_PENDING));
    _ASSERT(m_pLastStarDomainInfo == NULL);
    dwInterlockedSetBits(&m_dwFlags, DOMCFG_FINISH_UPDATE_PENDING);
    dwInterlockedUnsetBits(&m_dwFlags, DOMCFG_MULTIPLE_STAR_DOMAINS);
}

//---[ CDomainConfigTable::FinishConfigUpdate ]--------------------------------
//
//
//  Description: 
//      Used to signal when all updated configuration information has been 
//      passed in.  Will then walk all of our cached configuration information
//      and remove outdated entries
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CDomainConfigTable::FinishConfigUpdate()
{
    HRESULT hr = S_OK;
    DWORD   dwCurrentVersion = m_dwCurrentConfigVersion;
    CInternalDomainInfo *pIntDomainInfo = NULL;

    //There should be a matching start
    _ASSERT(m_dwFlags & DOMCFG_FINISH_UPDATE_PENDING);

    //
    //  Get the last "*" domain in case we need to explicitly update the table
    //  with it.
    //
    m_slPrivateData.ShareLock();
    pIntDomainInfo = m_pLastStarDomainInfo;
    if (pIntDomainInfo)
        pIntDomainInfo->AddRef();
    m_slPrivateData.ShareUnlock();

    //
    //  If only 1 "*" domain has been configured, then we have not inserted
    //  it in the DNT, and the actual data there is out of date.  We
    //  need to insert it into the table.
    //
    if (pIntDomainInfo && !(DOMCFG_MULTIPLE_STAR_DOMAINS & m_dwFlags)) 
    {
        HrSetInternalDomainInfo(pIntDomainInfo);
    }

    //
    //  Release the internal domain info if we got it.
    //
    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    dwInterlockedUnsetBits(&m_dwFlags, DOMCFG_FINISH_UPDATE_PENDING);


    //Lock table, remove outdated entries, and update the default domain config
    m_slPrivateData.ExclusiveLock();

    if (m_pLastStarDomainInfo) {
        m_pDefaultDomainConfig->m_dwIntDomainInfoFlags |= 
            INT_DOMAIN_INFO_INVALID;
        m_pDefaultDomainConfig->Release();
        m_pDefaultDomainConfig = m_pLastStarDomainInfo;
        m_pLastStarDomainInfo = NULL;

    }

    hr = m_dnt.HrIterateOverSubDomains(NULL, 
        RemoveOutdatedConfigEntryIteratorFn, &dwCurrentVersion);
    m_slPrivateData.ExclusiveUnlock();

    if (FAILED(hr))
        _ASSERT(DOMHASH_E_NO_SUCH_DOMAIN == hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\domain.h ===
//-----------------------------------------------------------------------------
//
//
//    File: domain.h
//
//    Description:
//      Contains descriptions of the Domain table management structure
//
//    Author: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _DOMAIN_H_
#define _DOMAIN_H_

#include "cmt.h"
#include <baseobj.h>
#include <domhash.h>
#include <rwnew.h>
#include <smtpevent.h>

class CInternalDomainInfo;
class CDestMsgQueue;
class CDomainEntry;
class CDomainMappingTable;
class CAQSvrInst;
class CAQMessageType;
class CLinkMsgQueue;
class CLocalLinkMsgQueue;
class CAQScheduleID;
class CMsgRef;
class CDeliveryContext;
class CAsyncRetryAdminMsgRefQueue;
class CMailMsgAdminQueue;
class CDomainEntryLinkIterator;
class CDomainEntryQueueIterator;
class CDomainEntryIterator;

#include "asyncq.h"

#define DOMAIN_ENTRY_SIG            'tnED'
#define DOMAIN_ENTRY_ITERATOR_SIG   'ItnD'
#define DOMAIN_MAPPING_TABLE_SIG    ' TMD'

//Name used for global 'local' link
#define LOCAL_LINK_NAME                 "LocalLink"
#define UNREACHABLE_LINK_NAME           "UnreachableLink"
#define CURRENTLY_UNREACHABLE_LINK_NAME "CurrentlyUnreachableLink"
#define PRECAT_QUEUE_NAME               "PreCatQueue"
#define PREROUTING_QUEUE_NAME           "PreRoutingQueue"

// {34E2DCCA-C91A-11d2-A6B1-00C04FA3490A}
static const GUID g_sGuidLocalLink =
{ 0x34e2dcca, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

// {CD08CEE0-2A95-11d3-B38E-00C04F6B6167}
static const GUID g_sGuidPrecatLink =
{ 0xcd08cee0, 0x2a95, 0x11d3, { 0xb3, 0x8e, 0x0, 0xc0, 0x4f, 0x6b, 0x61, 0x67 } };

// {98C90E90-2BB5-11d3-B390-00C04F6B6167}
static const GUID g_sGuidPreRoutingLink =
{ 0x98c90e90, 0x2bb5, 0x11d3, { 0xb3, 0x90, 0x0, 0xc0, 0x4f, 0x6b, 0x61, 0x67 } };

#define DMT_FLAGS_SPECIAL_DELIVERY_SPINLOCK   0x80000000
#define DMT_FLAGS_SPECIAL_DELIVERY_CALLBACK   0x40000000

//Bits used to retry GetNextHop after it has failed.  If
//DMT_FLAGS_RESET_ROUTES_IN_PROGRESS is set, then a reset routes attempt is
//in progress, and we should not have more than one attempt pending.  If
//DMT_FLAGS_GET_NEXT_HOP_FAILED is set, then a failure has been encountered
//since the last reset routes.
#define DMT_FLAGS_RESET_ROUTES_IN_PROGRESS    0x20000000
#define DMT_FLAGS_GET_NEXT_HOP_FAILED         0x10000000

//---[ DomainMapping ]---------------------------------------------------------
//
//
//    Hungarian: dmap, pdmap
//
//    unquely identifies a queue / domain name pair.
//    Each Domain mapping that contains the same QueueID, belongs to
//    same queue.
//
//    This entire ID should be treated as an opaque to the outside world.
//
//    This class is essentially an abstraction that can allow us to add another
//    layer of indirection.  Configuration based grouping of queues.... static
//    routing instead of dynamic.
//-----------------------------------------------------------------------------

class CDomainMapping
{
public:
    //removed constructor so we could have this in a union... works fine, but
    //you have to set mapping with manually or via clone
    void Clone(IN CDomainMapping *pdmap);

    //Returns a ptr to the DestMsgQueue associated with this object
    HRESULT HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                              OUT CDestMsgQueue **ppdmq);

    friend   class CDomainEntry;

    //provide sorting operators
    friend bool operator <(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID < pdmap2.m_pdentryDomainID);};
    friend bool operator >(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID > pdmap2.m_pdentryDomainID);};
    friend bool operator <=(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID <= pdmap2.m_pdentryDomainID);};
    friend bool operator >=(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID >= pdmap2.m_pdentryDomainID);};

    //Compressed Queues will not be supported... this will be a sufficient test
    friend bool operator ==(CDomainMapping &pdmap1, CDomainMapping &pdmap2)
            {return (pdmap1.m_pdentryDomainID == pdmap2.m_pdentryDomainID);};

    CDomainEntry *pdentryGetQueueEntry() {return m_pdentryQueueID;};
protected:
    CDomainEntry *m_pdentryDomainID;
    CDomainEntry *m_pdentryQueueID;
};



//---[ CDomainEntry ]----------------------------------------------------------
//
//
//    Hungarian: dentry pdentry
//
//    Represents a entry in the Domain Name Mapping Table
//-----------------------------------------------------------------------------

class CDomainEntry : public CBaseObject
{
protected:
    DWORD           m_dwSignature;
    CShareLockInst  m_slPrivateData; //Share lock used to maintain lists
    CDomainMapping  m_dmap; //Domain mapping for this domain
    DWORD           m_cbDomainName;
    LPSTR           m_szDomainName; //Domain name for this entry
    DWORD           m_cQueues;
    DWORD           m_cLinks;
    CAQSvrInst     *m_paqinst;
    LIST_ENTRY      m_liDestQueues; //linked list of dest queues for this domain name
    LIST_ENTRY      m_liLinks; //linked list of links for this domain name
    friend class    CDomainEntryIterator;
    friend class    CDomainEntryLinkIterator;
    friend class    CDomainEntryQueueIterator;
public:
    CDomainEntry(CAQSvrInst *paqinst);
    ~CDomainEntry();

    HRESULT HrInitialize(
                DWORD cbDomainName,           //string length of domain name
                LPSTR szDomainName,           //domain name for entry
                CDomainEntry *pdentryQueueID, //primary entry for this domain
                CDestMsgQueue *pdmq,          //queue prt for this entry
                                              //NULL if not primary
                CLinkMsgQueue *plmq);


    HRESULT HrDeinitialize();

    //Returns the Domain Mapping associated with this object
    HRESULT HrGetDomainMapping(OUT CDomainMapping *pdmap);

    //Returns the Domain Name associated with this object
    //Caller is responsible for freeing string
    HRESULT HrGetDomainName(OUT LPSTR *pszDomainName);

    //Returns a ptr to the DestMsgQueue associated with this object
    HRESULT HrGetDestMsgQueue(IN CAQMessageType *paqmt,
                              OUT CDestMsgQueue **ppdmq);

    //Add a queue to this domain entry if one does not already exist for that message type
    HRESULT HrAddUniqueDestMsgQueue(IN  CDestMsgQueue *pdmqNew,
                                    OUT CDestMsgQueue **ppdmqCurrent);

    //Returns a ptr to the DestMsgQueue associated with this object
    HRESULT HrGetLinkMsgQueue(IN CAQScheduleID *paqsched,
                              OUT CLinkMsgQueue **pplmq);

    //Add a queue to this domain entry if one does not already exist for that message type
    HRESULT HrAddUniqueLinkMsgQueue(IN  CLinkMsgQueue *plmqNew,
                                    OUT CLinkMsgQueue **pplmqCurrent);

    void    RemoveDestMsgQueue(IN CDestMsgQueue *pdmq);
    void    RemoveLinkMsgQueue(IN CLinkMsgQueue *plmq);

    //returns internal ptr to domain name... use HrGetDomainName if you
    //are not *directly* tied to the life span of a domain entry
    inline LPSTR szGetDomainName() {return m_szDomainName;};
    inline DWORD cbGetDomainNameLength() {return m_cbDomainName;};

    inline void InitDomainString(PDOMAIN_STRING pDomain);

    //Is it safe to get rid of this domain entry?
    inline BOOL    fSafeToRemove() {
        return (BOOL) ((m_lReferences == 1) &&
                            (m_cQueues == 0) &&
                                (m_cLinks == 0));}
};

//---[ CDomainEntryIterator ]--------------------------------------------------
//
//
//  Description:
//      Base iterator class for domain entry.  Provides a consistent snapshot
//      of the elements of a domain entry
//  Hungarian:
//      deit, pdeit
//
//-----------------------------------------------------------------------------
class CDomainEntryIterator
{
  protected:
    DWORD           m_dwSignature;
    DWORD           m_cItems;
    DWORD           m_iCurrentItem;
    PVOID          *m_rgpvItems;
  protected:
    CDomainEntryIterator();
    PVOID               pvGetNext();
    VOID                Recycle();
    virtual VOID        ReleaseItem(PVOID pvItem)
        {_ASSERT(FALSE && "Base virtual function");};
    virtual PVOID       pvItemFromListEntry(PLIST_ENTRY pli)
        {_ASSERT(FALSE && "Base virtual function");return NULL;};
    virtual PLIST_ENTRY pliHeadFromDomainEntry(CDomainEntry *pdentry)
        {_ASSERT(FALSE && "Base virtual function");return NULL;};
    virtual DWORD       cItemsFromDomainEntry(CDomainEntry *pdentry)
        {_ASSERT(FALSE && "Base virtual function");return 0;};
  public:
    HRESULT     HrInitialize(CDomainEntry *pdentry);
    VOID        Reset() {m_iCurrentItem = 0;};
};

//---[ CDomainEntryLinkIterator ]----------------------------------------------
//
//
//  Description:
//      Implementation of CDomainEntryIterator for CLinkMsgQueues
//  Hungarian:
//      delit, pdelit
//
//-----------------------------------------------------------------------------
class CDomainEntryLinkIterator : public CDomainEntryIterator
{
  protected:
    virtual VOID        ReleaseItem(PVOID pvItem);
    virtual PVOID       pvItemFromListEntry(PLIST_ENTRY pli);
    virtual PLIST_ENTRY pliHeadFromDomainEntry(CDomainEntry *pdentry)
        {return &(pdentry->m_liLinks);};
    virtual DWORD       cItemsFromDomainEntry(CDomainEntry *pdentry)
        {return pdentry->m_cLinks;};
  public:
    ~CDomainEntryLinkIterator() {Recycle();};
    CLinkMsgQueue      *plmqGetNextLinkMsgQueue(CLinkMsgQueue *plmq);
};

//---[ CDomainEntryLinkIterator ]----------------------------------------------
//
//
//  Description:
//      Implementation of CDomainEntryIterator for CDestMsgQueues
//  Hungarian:
//      deqit, pdeqit
//
//-----------------------------------------------------------------------------
class CDomainEntryQueueIterator : public CDomainEntryIterator
{
  protected:
    virtual VOID        ReleaseItem(PVOID pvItem);
    virtual PVOID       pvItemFromListEntry(PLIST_ENTRY pli);
    virtual PLIST_ENTRY pliHeadFromDomainEntry(CDomainEntry *pdentry)
        {return &(pdentry->m_liDestQueues);};
    virtual DWORD       cItemsFromDomainEntry(CDomainEntry *pdentry)
        {return pdentry->m_cQueues;};
  public:
    ~CDomainEntryQueueIterator() {Recycle();};
    CDestMsgQueue      *pdmqGetNextDestMsgQueue(CDestMsgQueue *pdmq);
};

class CDomainMappingTable
{
private:
    DWORD               m_dwSignature;
    DWORD               m_dwInternalVersion; //version # used to keep track of queue deletions
    DWORD               m_dwFlags;
    CAQSvrInst         *m_paqinst;
    DWORD               m_cOutstandingExternalShareLocks; //number of outstanding external sharelocks
    LIST_ENTRY          m_liEmptyDMQHead; //head of list for empty DMQ's
    DWORD               m_cThreadsForEmptyDMQList;
    DOMAIN_NAME_TABLE   m_dnt; //where domain names are actually stored
    CShareLockInst      m_slPrivateData;    //Sharelock for accessing Domain Name Table
    CLocalLinkMsgQueue *m_plmqLocal; //Local link Queue
    CLinkMsgQueue      *m_plmqCurrentlyUnreachable; //link for currently unreachable
    CLinkMsgQueue      *m_plmqUnreachable; //link unreachable destinations
    CMailMsgAdminQueue *m_pmmaqPreCategorized; //link for precat queue
    CMailMsgAdminQueue *m_pmmaqPreRouting;   //link for prerouting queue

    DWORD               m_cSpecialRetryMinutes;

    DWORD               m_cResetRoutesRetriesPending;

    HRESULT             HrInitLocalDomain(
                            IN     CDomainEntry *pdentry, //entry to init
                            IN     DOMAIN_STRING *pStrDomain, //Domain name
                            IN     CAQMessageType *paqmtMessageType,    //Message type as returned by routing
                            OUT    CDomainMapping *pdmap); //domain mapping for domain
    HRESULT             HrInitRemoteDomain(
                            IN     CDomainEntry *pdentry, //entry to init
                            IN     DOMAIN_STRING *pStrDomain, //Domain Name
                            IN     CInternalDomainInfo *pIntDomainInfo,  //domain config
                            IN     CAQMessageType *paqmtMessageType,    //Message type as returned by routing
                            IN     IMessageRouter *pIMessageRouter, //router for this message
                            OUT    CDomainMapping *pdmap, //domain mapping for domain
                            OUT    CDestMsgQueue **ppdmq, //destmsgqueue for domain
                            OUT    CLinkMsgQueue **pplmq);
    HRESULT             HrCreateQueueForEntry(
                            IN     CDomainEntry *pdentry,
                            IN     DOMAIN_STRING *pStrDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     CDomainMapping *pdmap,
                            OUT    CDestMsgQueue **ppdmq);
    HRESULT             HrGetNextHopLink(
                            IN     CDomainEntry *pdentry,
                            IN     LPSTR szDomain,
                            IN     DWORD cbDomain,
                            IN     CInternalDomainInfo *pIntDomainInfo,
                            IN     CAQMessageType *paqmtMessageType,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fDMTLocked,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    HRESULT *phrRoutingDiag);

    void LogDomainUnreachableEvent(BOOL fCurrentlyUnreachable,
                                      LPCSTR szDomain);

    //Checks head of EMPTY_LIST to see if there are any expired queues
    //or an excesive number of non-empty queues in the list
    BOOL                fNeedToWalkEmptyQueueList();

    //Used to delete expired queues
    BOOL                fDeleteExpiredQueues();

    //Domain Name Table iterator function used for re-routing
    static VOID RerouteSingleDomain(PVOID pvContext, PVOID pvData,
                                    BOOL fWildcard, BOOL *pfContinue,
                                    BOOL *pfDelete);

    //Destroys all the currently "cached" routing information for a given domain
    static VOID UnrouteSingleDomain(PVOID pvContext, PVOID pvData,
                                    BOOL fWildcard, BOOL *pfContinue,
                                    BOOL *pfDelete);

    HRESULT HrPrvGetDomainEntry(IN  DWORD cbDomainNameLength,
                                IN  LPSTR szDomainName,
                                IN  BOOL  fDMTLocked,
                                OUT CDomainEntry **ppdentry);

    HRESULT HrInializeGlobalLink(IN  LPCSTR szLinkName,
                                 IN  DWORD  cbLinkName,
                                 OUT CLinkMsgQueue **pplmq,
                                 DWORD dwSupportedActions = 0,
                                 DWORD dwLinkType = 0);

    HRESULT HrDeinitializeGlobalLink(IN OUT CLinkMsgQueue **pplmq);

    HRESULT HrPrvInsertDomainEntry(
                     IN  PDOMAIN_STRING  pstrDomainName,
                     IN  CDomainEntry *pdentryNew,
                     IN  BOOL  fTreatAsWildcard,
                     OUT CDomainEntry **ppdentryOld);

    static void RetryResetRoutes(PVOID pvThis);
    void    RequestResetRoutesRetryIfNecessary();
public:
    CDomainMappingTable();
    ~CDomainMappingTable();
    HRESULT HrInitialize(
        CAQSvrInst *paqinst,
        CAsyncRetryAdminMsgRefQueue *paradmq,
        CAsyncMailMsgQueue *pmmaqPrecatQ,
        CAsyncMailMsgQueue *pmmaqPreRoutingQ);

    HRESULT HrDeinitialize();

    //Lookup Domain name; This will create a new entry if neccessary.
    HRESULT HrMapDomainName(
                IN LPSTR szDomainName,     //Domain Name to map
                IN CAQMessageType *paqmtMessageType,    //Message type as returned by routing
                IN IMessageRouter *pIMessageRouter, //router for this message
                OUT CDomainMapping *pdmap, //Mapping returned caller allocated
                OUT CDestMsgQueue **ppdmq);//ptr to Queue

    HRESULT HrGetDomainEntry(IN  DWORD cbDomainNameLength,
                             IN  LPSTR szDomainName,
                             OUT CDomainEntry **ppdentry)
    {
        return HrPrvGetDomainEntry(cbDomainNameLength,
                        szDomainName, FALSE, ppdentry);
    }

    HRESULT HrIterateOverSubDomains(DOMAIN_STRING * pstrDomain,
                                   IN DOMAIN_ITR_FN pfn,
                                   IN PVOID pvContext)
    {
        HRESULT hr = S_OK;
        m_slPrivateData.ShareLock();
        hr = m_dnt.HrIterateOverSubDomains(pstrDomain, pfn, pvContext);
        m_slPrivateData.ShareUnlock();
        return hr;
    };

    //Reroute a given domain (and it's subdomains)
    HRESULT HrRerouteDomains(IN DOMAIN_STRING *pstrDomain);

    HRESULT             HrGetOrCreateLink(
                            IN     LPSTR szRouteAddress,
                            IN     DWORD cbRouteAddress,
                            IN     DWORD dwScheduleID,
                            IN     LPSTR szConnectorName,
                            IN     IMessageRouter *pIMessageRouter,
                            IN     BOOL fCreateIfNotExist,
                            IN     DWORD linkInfoType,
                            OUT    CLinkMsgQueue **pplmq,
                            OUT    BOOL *pfRemoveOwnedSchedule);

    //The following functions are used to check the version number of the DMT.
    //The version number is guananteed remain constant while the DMT Sharelock
    //is held.  While it is not *required* to get lock before getting the
    //version number for the first time, it is required to get the lock (and
    //keep it) while verify that the version number has not changed.  The
    //expected usage of these functions is:
    //DWORD dwDMTVersion = pdmt->dwGetDMTVersion();
    //...
    //pdmt->AquireDMTShareLock();
    //if (pdmt->dwGetDMTVersion() == dwDMTVersion)
    //  ... do stuff that requires consitant DMT version
    //pdmt->ReleaseDMTShareLock();
    inline void  AquireDMTShareLock();
    inline void  ReleaseDMTShareLock();
    inline DWORD dwGetDMTVersion();

    //Used by DestMsgQueue to Add themselves from the empty queue list
    void AddDMQToEmptyList(CDestMsgQueue *pdmq);

    void ProcessSpecialLinks(DWORD  cSpecialRetryMinutes, BOOL fRoutingLockHeld);
    static void SpecialRetryCallback(PVOID pvContext);

    CLinkMsgQueue *plmqGetLocalLink();
    CLinkMsgQueue *plmqGetCurrentlyUnreachable();
    CMailMsgAdminQueue *pmmaqGetPreCategorized();
    CMailMsgAdminQueue *pmmaqGetPreRouting();

    HRESULT HrPrepareForLocalDelivery(
                IN CMsgRef *pmsgref,
                IN BOOL fDelayDSN,
                IN OUT CDeliveryContext *pdcntxt,
                OUT DWORD *pcRecips,
                OUT DWORD **prgdwRecips);

    DWORD GetCurrentlyUnreachableTotalMsgCount();
};


//---[ CDomainEntry::InitDomainString ]----------------------------------------
//
//
//  Description:
//      Initialized a domain string based on this domain's info
//  Parameters:
//      pDomain     - ptr to DOMAIN_STRING to initialize
//  Returns:
//      -
//  History:
//      5/26/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDomainEntry::InitDomainString(PDOMAIN_STRING pDomain)
{
    pDomain->Buffer = m_szDomainName;
    pDomain->Length = (USHORT) m_cbDomainName;
    pDomain->MaximumLength = pDomain->Length;
}

//---[ CDomainMappingTable::AquireDMTShareLock ]-------------------------------
//
//
//  Description:
//      Aquires a share lcok on the DMT's internal lock... must be released
//      with a call to ReleaseDMTShareLock.
//  Parameters:
//
//  Returns:
//
//  History:
//      9/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void  CDomainMappingTable::AquireDMTShareLock()
{
    m_slPrivateData.ShareLock();
    DEBUG_DO_IT(InterlockedIncrement((PLONG) &m_cOutstandingExternalShareLocks));
}

//---[ CDomainMappingTable::ReleaseDMTShareLock ]-------------------------------
//
//
//  Description:
//      Releases a DMT sharelock aquired by AquireDMTShareLock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      9/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void  CDomainMappingTable::ReleaseDMTShareLock()
{
    _ASSERT(m_cOutstandingExternalShareLocks); //Count should not go below 0
    DEBUG_DO_IT(InterlockedDecrement((PLONG) &m_cOutstandingExternalShareLocks));
    m_slPrivateData.ShareUnlock();
}

//---[ CDomainMappingTable::dwGetDMTVersion ]----------------------------------
//
//
//  Description:
//      Returns the internal DMT version number
//  Parameters:
//      -
//  Returns:
//      DMT Version number
//  History:
//      9/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CDomainMappingTable::dwGetDMTVersion()
{
    return m_dwInternalVersion;
}

#define REROUTE_CONTEXT_SIG 'xtCR'

class CRerouteContext
{
  private:
    friend class CDomainMappingTable;
    DWORD               m_dwSignature;
    CDomainMappingTable *m_pdmt;
    BOOL                m_fForceReroute;
  public:
    CRerouteContext()
    {
        m_dwSignature = REROUTE_CONTEXT_SIG;
        m_pdmt = NULL;
        m_fForceReroute = FALSE;
    };
};

void ReUnreachableErrorToAqueueError(HRESULT reErr, HRESULT *aqErr);

#endif //_DOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\failmsgq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: failmsgq.cpp
//
//  Description:
//      Implementation of CFailedMsgQueue class.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/18/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "failmsgq.h"
#include "aqutil.h"
#include <mailmsgi_i.c>

//---[ IMailMsgAQueueListEntry ]----------------------------------------------
//
//
//  Description:
//      Helper function that gets list entry for message.
//  Parameters:
//      IN  pIMailMsgPropertes      Msg to get list entry for
//  Returns:
//      Pointer to list entry
//  History:
//      1/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQueueFailedListEntry *pfliGetListEntryForMsg(
                                  IMailMsgProperties *pIMailMsgProperties)
{
    HRESULT hr = S_OK;
    AQueueFailedListEntry *pfli = NULL;
    IMailMsgAQueueListEntry *pIMailMsgAQueueListEntry = NULL;

    _ASSERT(pIMailMsgProperties);

    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgAQueueListEntry,
                                         (void **) &pIMailMsgAQueueListEntry);

    //This are spec'd to never fail
    _ASSERT(SUCCEEDED(hr));
    _ASSERT(pIMailMsgAQueueListEntry);

    if (pIMailMsgAQueueListEntry)
    {
        hr = pIMailMsgAQueueListEntry->GetListEntry((void **) &pfli);
        _ASSERT(SUCCEEDED(hr));
        _ASSERT(pfli);
        pIMailMsgAQueueListEntry->Release();

        pfli->m_pIMailMsgProperties = pIMailMsgProperties;
        pIMailMsgProperties->AddRef();
    }

    return pfli;
}

//---[ ValidateListEntry ]-----------------------------------------------------
//
//
//  Description:
//      Debug code to do some validation on the list entry pulled off the list
//  Parameters:
//      IN  pfli        list entry struct pulled off of
//  Returns:
//
//  History:
//      1/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
#ifndef DEBUG
#define AQValidateListEntry(x)
#else //is DEBUG
void AQValidateListEntry(AQueueFailedListEntry *pfli)
{
    HRESULT hr = S_OK;
    AQueueFailedListEntry *pfliNew = NULL;
    IMailMsgAQueueListEntry *pIMailMsgAQueueListEntry = NULL;

    _ASSERT(pfli);
    _ASSERT(pfli->m_pIMailMsgProperties);

    hr = pfli->m_pIMailMsgProperties->QueryInterface(IID_IMailMsgAQueueListEntry,
                                         (void **) &pIMailMsgAQueueListEntry);

    //This are spec'd to never fail
    _ASSERT(SUCCEEDED(hr));
    _ASSERT(pIMailMsgAQueueListEntry);
    hr = pIMailMsgAQueueListEntry->GetListEntry((void **) &pfliNew);
    _ASSERT(SUCCEEDED(hr));
    _ASSERT(pfliNew);

    //The list entry returned should be the same one pass into this function
    _ASSERT(pfli == pfliNew);
    pIMailMsgAQueueListEntry->Release();
}
#endif //DEBUG

//---[ CFailedMsgQueue::CFailedMsgQueue ]--------------------------------------
//
//
//  Description:
//      Constuctor for CFailedMsgQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CFailedMsgQueue::CFailedMsgQueue()
{
    m_dwSignature = FAILEDMSGQUEUE_SIG;
    m_cMsgs = 0;
    m_paqinst = NULL;
    m_dwFlags = 0;

    InitializeListHead(&m_liHead);

}

//---[ CFailedMsgQueue::~CFailedMsgQueue ]-------------------------------------
//
//
//  Description:
//      Default destructor for CFailedMsgQueue
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CFailedMsgQueue::~CFailedMsgQueue()
{
    Deinitialize();
}

//---[ CFailedMsgQueue::Initialize ]-------------------------------------------
//
//
//  Description:
//      Initialization routine for CFailedMsgQueue
//  Parameters:
//      IN  paqinst         Ptr to the server instance object
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::Initialize(CAQSvrInst *paqinst)
{
    _ASSERT(paqinst);
    m_paqinst = paqinst;

    if (m_paqinst)
        m_paqinst->AddRef();
}

//---[ CFailedMsgQueue::Deinitialize ]-----------------------------------------
//
//
//  Description:
//      Deinitialization code for CFailedMsgQueue.  Release server instance
//      object.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::Deinitialize()
{
    CAQSvrInst *paqinst = NULL;
    AQueueFailedListEntry *pfli = NULL;

    m_slPrivateData.ExclusiveLock();
    paqinst = m_paqinst;
    m_paqinst = NULL;

    //Loop through list & release messages
    while (!IsListEmpty(&m_liHead))
    {
        pfli = (AQueueFailedListEntry *) m_liHead.Flink;

        _ASSERT(&m_liHead != ((PLIST_ENTRY) pfli));

        _ASSERT(pfli->m_pIMailMsgProperties);

        if (paqinst)
            paqinst->ServerStopHintFunction();

        RemoveEntryList((PLIST_ENTRY)pfli);

        pfli->m_pIMailMsgProperties->Release();
    }
    m_slPrivateData.ExclusiveUnlock();

    if (paqinst)
        paqinst->Release();
}

//---[ CFailedMsgQueue::HandleFailedMailMsg ]----------------------------------
//
//
//  Description:
//      Puts a failed mailmsg in the queue of mailmsgs to retry
//  Parameters:
//      IN  pIMailMsgProperties         MailMsgProperties to try
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::HandleFailedMailMsg(IMailMsgProperties *pIMailMsgProperties)
{
    AQueueFailedListEntry *pfli = NULL;

    if (!pIMailMsgProperties)
    {
        m_slPrivateData.ShareLock();
        if (m_paqinst)
            m_paqinst->DecPendingFailed();
        m_slPrivateData.ShareUnlock();

        return;
    }

    pfli = pfliGetListEntryForMsg(pIMailMsgProperties);

    //If above fails... there is nothing we can do
    _ASSERT(pfli);
    if (!pfli)
        return;

    m_slPrivateData.ExclusiveLock();

    if (!m_paqinst)
    {
        _ASSERT(pfli->m_pIMailMsgProperties);
        pfli->m_pIMailMsgProperties->Release();
        pfli->m_pIMailMsgProperties = NULL;
    }
    else
    {
        InsertTailList(&m_liHead, &(pfli->m_li));
        InterlockedIncrement((PLONG) &m_cMsgs);
    }

    m_slPrivateData.ExclusiveUnlock();

    //Make sure we have a retry pending
    StartProcessingIfNecessary();
}

//---[ CFailedMsgQueue::InternalStartProcessingIfNecessary ]-------------------
//
//
//  Description:
//      Called at various times (ie SubmitMessage) to kick off the processing
//      of Failed Msgs.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::InternalStartProcessingIfNecessary()
{
    CAQSvrInst *paqinst = NULL;
    HRESULT     hr      = S_OK;
    BOOL        fCallbackRequestFailed = FALSE;

    //See if there is work to be done and no one else doing it or scheduled to
    if (!(FMQ_CALLBACK_REQUESTED & m_dwFlags) && m_cMsgs)
    {
        //Try to set the call back bit.... if this thread gets it... arrange for
        //a callback.
        if (!(FMQ_CALLBACK_REQUESTED &
              dwInterlockedSetBits(&m_dwFlags, FMQ_CALLBACK_REQUESTED)))
        {
            //Get Virtual server object in a thread safe manner
            m_slPrivateData.ShareLock();
            paqinst = m_paqinst;
            if (paqinst)
                paqinst->AddRef();
            m_slPrivateData.ShareUnlock();

            //Only worry about trying if we have a virtual server object.
            if (paqinst)
            {
                //Retry in 5 minutes
                hr = paqinst->SetCallbackTime(
                               CFailedMsgQueue::ProcessEntriesCallback,
                               this, 5);
                if (FAILED(hr))
                    fCallbackRequestFailed = TRUE;
            }
            else
            {
                fCallbackRequestFailed = TRUE;
            }

        }
    }

    //We failed to request a callback... unset the flag, so another thread 
    //can try
    if (fCallbackRequestFailed)
        dwInterlockedUnsetBits(&m_dwFlags, FMQ_CALLBACK_REQUESTED);

    if (paqinst)
        paqinst->Release();
}

//---[ CFailedMsgQueue::ProcessEntries ]---------------------------------------
//
//
//  Description:
//      Walks queues of failed IMailMsgs and proccesses them for retry
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::ProcessEntries()
{
    DWORD   cMsgsToProcess = m_cMsgs; //Only walk list once.
    HRESULT hr = S_OK;
    AQueueFailedListEntry *pfli = NULL;
    CAQSvrInst *paqinst = NULL;

    //There should only be 1 thread processing entries, and we should have
    //set the bit
    _ASSERT(FMQ_CALLBACK_REQUESTED & m_dwFlags);

    m_slPrivateData.ExclusiveLock();

    paqinst = m_paqinst;
    if (paqinst)
    {
        paqinst->AddRef();

        while (!IsListEmpty(&m_liHead) && cMsgsToProcess-- && m_paqinst)
        {
            pfli = (AQueueFailedListEntry *) m_liHead.Flink;

            _ASSERT(&m_liHead != ((PLIST_ENTRY) pfli));

            RemoveEntryList((PLIST_ENTRY)pfli);

            m_slPrivateData.ExclusiveUnlock();

            //Verify that pli we have now is the same as what the interface
            //returns
            AQValidateListEntry(pfli);

            paqinst->DecPendingFailed();
            InterlockedDecrement((PLONG) &m_cMsgs);
            hr = paqinst->HrInternalSubmitMessage(pfli->m_pIMailMsgProperties);
            if (FAILED(hr) && (AQUEUE_E_SHUTDOWN != hr) && 
                paqinst->fShouldRetryMessage(pfli->m_pIMailMsgProperties))
            {
                HandleFailedMailMsg(pfli->m_pIMailMsgProperties);
            }

            pfli->m_pIMailMsgProperties->Release();

            //Should be lock when we hit top of loop
            m_slPrivateData.ExclusiveLock();
        }

        paqinst->Release();
        paqinst = NULL;
    }

    m_slPrivateData.ExclusiveUnlock();


}

//---[ CFailedMsgQueue::ProcessEntries ]---------------------------------------
//
//
//  Description:
//      Static function that is used as a retry callback for ProcessEntries.
//  Parameters:
//      IN  pvContext           This ptr of CFailedMsgQueue object
//  Returns:
//      -
//  History:
//      1/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CFailedMsgQueue::ProcessEntriesCallback(PVOID pvContext)
{
    CFailedMsgQueue *pfmq = (CFailedMsgQueue *) pvContext;

    _ASSERT(pfmq);
    _ASSERT(FAILEDMSGQUEUE_SIG == pfmq->m_dwSignature);

    if (pfmq && (FAILEDMSGQUEUE_SIG == pfmq->m_dwSignature))
    {
        pfmq->ProcessEntries();
        _ASSERT(FMQ_CALLBACK_REQUESTED & (pfmq->m_dwFlags));
        dwInterlockedUnsetBits(&(pfmq->m_dwFlags), FMQ_CALLBACK_REQUESTED);
        pfmq->StartProcessingIfNecessary();
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\fifoqimp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: fifoqimp.h
//
//  Description: Implementation for Fifo Queue template
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <fifoq.h>
#include <dbgilock.h>

#define FIFOQ_ASSERT_QUEUE
//#define SHARELOCK_TRY_BROKEN

//some constants used
const DWORD FIFOQ_QUEUE_PAGE_SIZE       = 127; //number of entires per page
const DWORD FIFOQ_QUEUE_MAX_FREE_PAGES  = 200; //maximum # of free pages kept

//$$REVIEW: It might be nice to pick a size that is page size friendly
//  Current of objects is
//      sizeof(PVOID) + sizeof(PVOID)*FIFOQ_QUEUE_PAGE_SIZE = 512 bytes

//---[ CFifoQueuePage ]--------------------------------------------------------
//
//
//  Hungarian: fqp, pfqp
//
//  Single page of a FIFO queue.  Most operations are handled within the actual
//  CFifoQueue class.  FQPAGE is a typedef for this template class within
//  the scope of the CFifoQueue class
//-----------------------------------------------------------------------------
template<class PQDATA>
class CFifoQueuePage
{
public:
    friend class CFifoQueue<PQDATA>;
    CFifoQueuePage() {Recycle();};
protected:
    inline void Recycle();
    inline bool FIsOutOfBounds(IN PQDATA *ppqdata);
    CFifoQueuePage<PQDATA>  *m_pfqpNext;  //Next page in linked list
    CFifoQueuePage<PQDATA>  *m_pfqpPrev;  //previous page in linked list
    PQDATA                   m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE];
#ifdef FIFOQ_ASSERT_QUEUE
    //# of entries on this page that have been removed out of order
    //- Used in assertion routines
    DWORD                   m_cHoles;
#endif //FIFOQ_ASSERT_QUEUE
};

//---[ CFifoQueuePage::Recycle ]-----------------------------------------------
//
//
//  Description:
//      Performs initialization of a page.  Called when a page is created as
//      well as when it is retrieved from the free list
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
template<class PQDATA>
void CFifoQueuePage<PQDATA>::Recycle()
{
    m_pfqpNext = NULL;
    m_pfqpPrev = NULL;
#ifdef FIFOQ_ASSERT_QUEUE
    m_cHoles = 0;
#endif //FIFOQ_ASSERT_QUEUE
}

//---[ CFifoQueuePage::FIsOutOfBounds ]----------------------------------------
//
//
//  Description:
//      Tests to see if a PQDATA ptr is within range of this page
//  Parameters:
//      IN ppqdata - PQDATA ptr to test
//  Returns:
//      TRUE if in bounds
//      FALSE if ptr is out of bounds
//-----------------------------------------------------------------------------
template<class PQDATA>
bool CFifoQueuePage<PQDATA>::FIsOutOfBounds(PQDATA *ppqdata)
{
    return ((ppqdata < m_rgpqdata) ||
            ((m_rgpqdata + (FIFOQ_QUEUE_PAGE_SIZE-1)) < ppqdata));
}

#ifdef DEBUG
#ifdef FIFOQ_ASSERT_QUEUE

//---[ CFifoQueue::AssertQueueFn() ]-------------------------------------------
//
//
//  Description:
//      Perform some rather involved validation of the queue.  Including:
//          - Check Head and Tail page to make sure they conform various
//              retrictions of our data structure
//          - Check count to make sure it reflects data
//      At some point we may wish to add further checking (ie walking the linked
//      list in both directions to validate it).
//  Parameters:
//      fHaveLocks - set to true if the caller has both the head and tail locked
//                   Default value is FALSE.
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
template <class PQDATA>
void CFifoQueue<PQDATA>::AssertQueueFn(BOOL fHaveLocks)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::AssertQueue");
    FQPAGE *pfqpTmp  = NULL; //used to count entries
    DWORD   cEntries = 0;    //what we think count should be

    _ASSERT(FIFOQ_SIG == m_dwSignature);
    //include text in assert, to have it appear in dialog box (if applicable)
    if (!fHaveLocks)
    {
        m_slHead.ShareLock();
        m_slTail.ShareLock();
    }
    if ((m_pfqpHead != NULL) && (NULL != m_pfqpHead->m_pfqpPrev))
    {
        //If Head is not NULL, it should not have a pervious page
        DebugTrace((LPARAM) this, "Queue Assert: Head's Previous ptr is non-NULL");
        Assert(0 && "Queue Assert: Head's Previous is non-NULL");
    }

    if ((m_pfqpTail != NULL) && (NULL != m_pfqpTail->m_pfqpNext))
    {
        //If Tail is not NULL, it should not have a next page
        DebugTrace((LPARAM) this, "Queue Assert: Tail's Next ptr is non-NULL");
        Assert(0 && "Queue Assert: Tail's Next is non-NULL");
    }

    if ((m_pfqpHead != NULL) && (m_pfqpTail != NULL))
    {
        Assert(m_ppqdataTail);
        Assert(m_ppqdataHead);

        if (m_pfqpHead != m_pfqpTail)
        {
            // If Tail and Head are non-NULL and not equal to each other, then they
            // must have non-NULL Prev and Next ptrs (respectively).
            if (NULL == m_pfqpTail->m_pfqpPrev)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Tail's Prev ptr is NULL, Head != Tail");
                Assert(0 && "Queue Assert: Tail's Prev ptr is NULL, Head != Tail");
            }
            if (NULL == m_pfqpHead->m_pfqpNext)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Head's Next ptr is NULL, Head != Tail");
                Assert(0 && "Queue Assert: Head's Next ptr is NULL, Head != Tail");
            }

            //Check count when Head and Tail differ
            pfqpTmp = m_pfqpTail->m_pfqpPrev;
            while (NULL != pfqpTmp)
            {
                cEntries += FIFOQ_QUEUE_PAGE_SIZE - pfqpTmp->m_cHoles;
                pfqpTmp = pfqpTmp->m_pfqpPrev;
            }
            cEntries += (DWORD)(m_ppqdataTail - m_pfqpTail->m_rgpqdata); //tail page
            cEntries -= m_pfqpTail->m_cHoles;
            cEntries -= (DWORD)(m_ppqdataHead - m_pfqpHead->m_rgpqdata); //head page
            if (cEntries != m_cQueueEntries)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, cEntries);
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
        else //Head and Tail are same
        {
            Assert(m_pfqpHead == m_pfqpTail);
            cEntries = (DWORD)(m_ppqdataTail - m_ppqdataHead) - m_pfqpTail->m_cHoles;
            if (cEntries != m_cQueueEntries)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, cEntries);
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
    }
    else if ((m_pfqpHead != NULL) && (m_pfqpTail == NULL))
    {
        //If Tail is NULL, then Head should be as well
        DebugTrace((LPARAM) this, "Queue Assert: Tail is NULL while Head is non-NULL");
        Assert(0 && "Queue Assert: Tail is NULL while Head is non-NULL");
    }
    else if (m_pfqpTail != NULL)
    {
        Assert(m_pfqpHead == NULL);  //should fall out of if/else
        if (NULL == m_pfqpTail->m_pfqpPrev)
        {
            //count is easy here :)
            if (m_cQueueEntries != (size_t) (m_ppqdataTail - m_pfqpTail->m_rgpqdata))
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, (m_ppqdataTail - m_pfqpTail->m_rgpqdata));
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
        else //there is more than 1 page, but head is still NULL
        {
            pfqpTmp = m_pfqpTail->m_pfqpPrev;
            while (NULL != pfqpTmp)
            {
                cEntries += FIFOQ_QUEUE_PAGE_SIZE - pfqpTmp->m_cHoles;
                pfqpTmp = pfqpTmp->m_pfqpPrev;
            }
            cEntries += (DWORD)(m_ppqdataTail - m_pfqpTail->m_rgpqdata) - m_pfqpTail->m_cHoles;
            if (cEntries != m_cQueueEntries)
            {
                DebugTrace((LPARAM) this, "Queue Assert: Count is %d when it should be %d",
                    m_cQueueEntries, cEntries);
                Assert(0 && "Queue Assert: Entry Count is inaccurate");
            }
        }
    }
    else //both head and tail are NULL
    {
        Assert((m_pfqpHead == NULL) && (m_pfqpTail == NULL)); //falls out of if/else
        if (m_cQueueEntries != 0)
        {
            //If both Head and Tail are NULL, them m_cQueueEntries == 0
            DebugTrace((LPARAM) this,
                "Queue Assert: Entry Counter is %d when queue should be empty",
                m_cQueueEntries);
            Assert(0 && "Queue Assert: Entry Counter is non-zero when queue should be empty");
        }
    }


    if (!fHaveLocks) //we aquired the locks in this function
    {
        m_slTail.ShareUnlock();
        m_slHead.ShareUnlock();
    }

    TraceFunctLeave();

}

#define AssertQueue() AssertQueueFn(FALSE)
#define AssertQueueHaveLocks() AssertQueueFn(TRUE)
#else //FIFOQ_ASSERT_QUEUE
#define AssertQueue()
#define AssertQueueHaveLocks()
#endif //FIFOQ_ASSERT_QUEUE
#else //not DEBUG
#define AssertQueue()
#define AssertQueueHaveLocks()
#endif //DEBUG

//---[ CFifoQueue Static Variables ]-------------------------------------------
template <class PQDATA>
volatile CFifoQueuePage<PQDATA> *CFifoQueue<PQDATA>::s_pfqpFree = NULL;

template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFreePages = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFifoQueueObj = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cStaticRefs = 0;
template <class PQDATA>
CRITICAL_SECTION   CFifoQueue<PQDATA>::s_csAlloc;

#ifdef DEBUG
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cAllocated = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cDeleted = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFreeAllocated = 0;
template <class PQDATA>
DWORD              CFifoQueue<PQDATA>::s_cFreeDeleted = 0;
#endif //DEBUG

//---[ CFifoQueue::CFifoQueue ]------------------------------------------------
//
//
//  Description: CFifoQueue constructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
template <class PQDATA>
CFifoQueue<PQDATA>::CFifoQueue<PQDATA>()
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::CFifoQueue");

    m_dwSignature   = FIFOQ_SIG;
    m_cQueueEntries = 0;    //set count of entries to 0
    m_pfqpHead      = NULL; //Initialize page pointers
    m_pfqpTail      = NULL;
    m_pfqpCursor    = NULL;
    m_ppqdataHead   = NULL; //Initialize data pointers
    m_ppqdataTail   = NULL;
    m_ppqdataCursor = NULL;

    InterlockedIncrement((PLONG) &s_cFifoQueueObj);
    TraceFunctLeave();
}

//---[ CFifoQueue::~CFifoQueue ]------------------------------------------------
//
//
//  Description: CFifoQueue destructor
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
template <class PQDATA>
CFifoQueue<PQDATA>::~CFifoQueue<PQDATA>()
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::~CFifoQueue");
    FQPAGE *pfqpTmp = NULL;

    if (m_cQueueEntries != 0)
    {
        PQDATA pqdata = NULL;
        int iLeft = m_cQueueEntries;

        for (int i = iLeft; i > 0; i--)
        {
            if (FAILED(HrDequeue(&pqdata)))
                break;
            Assert(NULL != pqdata);
            pqdata->Release();
        }
    }

    while (m_pfqpHead)
    {
        //If last dequeue could not delete page, then make sure pages
        //are freed
        pfqpTmp = m_pfqpHead->m_pfqpNext;
        FreeQueuePage(m_pfqpHead);
        m_pfqpHead = pfqpTmp;
    }

    InterlockedDecrement((PLONG) &s_cFifoQueueObj);

    TraceFunctLeave();
}

//---[ CFifoQueue::StaticInit() ]--------------------------------------------
//
//
//  Description: Initialization routines for CFifoQueue.  This
//      is excplcitly single threaded.  The limitations are:
//              - Only one thread in this function
//              - You cannot use any queues until this has completed
//
//  Parameters: -
//
//  Returns: -
//
//
//-----------------------------------------------------------------------------
template <class PQDATA>
void CFifoQueue<PQDATA>::StaticInit()
{
    TraceFunctEnter("CFifoQueue::HrStaticInit()");
    DWORD   cRefs = 0;

    //
    //  Add a static ref for each call to this
    //
    cRefs = InterlockedIncrement((PLONG) &s_cStaticRefs);

    if (1 == cRefs)
    {
        InitializeCriticalSection(&s_csAlloc);
    }

    //
    //  Catch unsafe callers
    //
    _ASSERT(cRefs == s_cStaticRefs);

    TraceFunctLeave();
}

//---[ CFifoQueue::StaticDeinit() ]------------------------------------------
//
//
//  Description: Deinitialization routines for CFifoQueue
//
//  Parameters: -
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
template <class PQDATA>
void  CFifoQueue<PQDATA>::StaticDeinit()
{
    TraceFunctEnter("CFifoQueue::HrStaticDeinit()");
    LONG    lRefs   = 0;
    lRefs = InterlockedDecrement((PLONG) &s_cStaticRefs);
    DWORD   cLost   = 0;
    DEBUG_DO_IT(cLost = s_cAllocated - s_cDeleted - s_cFreePages);


    if (lRefs == 0)
    {
        if (0 != cLost)
            ErrorTrace((LPARAM) NULL, "ERROR: CFifoQueue Deinit with %d Lost Pages", cLost);

        //This assert will catch if the any queue pages were allocated but not freed
        _ASSERT(!cLost && "We are leaking some queue pages");

        //There should be no other threads calling into this
        //note quite true, there are still outstanding refs at the time
        FQPAGE  *pfqpCur =  (FQPAGE *) s_pfqpFree;
        while (NULL != pfqpCur)
        {
            s_pfqpFree = pfqpCur->m_pfqpNext;
            delete pfqpCur;
            pfqpCur = (FQPAGE *) s_pfqpFree;
            s_cFreePages--;

            //It is possible to stop all server instances without
            //unloading the DLL.  The cLost Assert will fire on the next
            //shutdown if we don't increment the deleted counter as well...
            //even though we aren't leaking any pages.
            DEBUG_DO_IT(s_cDeleted++);

        }
        //This assert catches if there are any free pages left after we walk the list
        Assert(s_cFreePages == 0);

        DeleteCriticalSection(&s_csAlloc);
    }

    TraceFunctLeave();
}

//---[ CFifoQueue::HrEnqueue ]-------------------------------------------------
//
//
//  Description: Enqueue a new item to the tail of the queue
//
//  Parameters:
//      IN PQDATA pqdata    Data to enqueue
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate page
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrEnqueue(IN PQDATA pqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrEnqueue");
    HRESULT hr      = S_OK;
    FQPAGE *pfqpNew = NULL;  //newly allocated page

    AssertQueue();
    Assert(pqdata);
    pqdata->AddRef();

    m_slTail.ExclusiveLock();

    if ((m_pfqpTail == NULL) || //Queue is empty or needs a new queue page
        (m_pfqpTail->FIsOutOfBounds(m_ppqdataTail)))
    {
        //assert that tail is NULL or 1 past end of previous tail page
        Assert((m_ppqdataTail == NULL) || (m_ppqdataTail == (m_pfqpTail->m_rgpqdata + FIFOQ_QUEUE_PAGE_SIZE)));
        Assert((m_cQueueEntries == 0) || (m_pfqpTail != NULL));

        hr = HrAllocQueuePage(&pfqpNew);
        if (FAILED(hr))
            goto Exit;

        Assert(pfqpNew);

        if (NULL != m_pfqpTail)  //Update Next & prev ptr if not first page
        {
            Assert(NULL == m_pfqpTail->m_pfqpNext);
            m_pfqpTail->m_pfqpNext = pfqpNew;
            pfqpNew->m_pfqpPrev = m_pfqpTail;
        }
#ifndef SHARELOCK_TRY_BROKEN
        else {
            if (m_slHead.TryExclusiveLock())
            {
                //can update head stuff with impunity
                m_pfqpHead = pfqpNew;
                m_ppqdataHead = pfqpNew->m_rgpqdata;
                m_slHead.ExclusiveUnlock();
            }
            //else requeue or MapFn has lock
        }
#endif //SHARELOCK_TRY_BROKEN
        m_pfqpTail = pfqpNew;
        m_ppqdataTail = pfqpNew->m_rgpqdata;

    }

    Assert(!m_pfqpTail->FIsOutOfBounds(m_ppqdataTail));
    Assert(m_ppqdataTail);

    *m_ppqdataTail = pqdata;
    m_ppqdataTail++;

    //increment count
    InterlockedIncrement((PLONG) &m_cQueueEntries);

    m_slTail.ExclusiveUnlock();

  Exit:
    AssertQueue();
    if (FAILED(hr))
        pqdata->Release();
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrDequeue ]-------------------------------------------------
//
//
//  Description: Dequeue an item from the queue
//
//  Parameters:
//      OUT PQDATA *ppqdata Data dequeued
//
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY if the queue is empty
//      E_NOTIMPL if fPrimary is FALSE (for now)
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrDequeue(OUT PQDATA *ppqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrDequeue");
    HRESULT hr = S_OK;

    AssertQueue();
    Assert(ppqdata);

    if (m_cQueueEntries == 0)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }


    m_slHead.ExclusiveLock();

    hr = HrAdjustHead();
    if (FAILED(hr))
    {
        m_slHead.ExclusiveUnlock();
        goto Exit;
    }

    *ppqdata = *m_ppqdataHead;
    *m_ppqdataHead = NULL;

    InterlockedDecrement((PLONG) &m_cQueueEntries);

    m_ppqdataHead++;  //If it crosses page boundary, then HrAdjustQueue
                      //will fix it on next dequeue

#ifndef SHARELOCK_TRY_BROKEN
    //Deal with brand new way of deleting last page
    if ((m_cQueueEntries == 0) && (m_slTail.TryExclusiveLock()))
    {
        //If we cannot access tail ptr, the enqueue in progress and
        //we should not delete the page they are enqueueing on
        if (m_cQueueEntries == 0) //gotta be thread safe
        {
            Assert(m_pfqpHead == m_pfqpTail);

            m_pfqpTail = NULL;
            m_ppqdataTail = NULL;

            m_slTail.ExclusiveUnlock();

            m_ppqdataHead = NULL;

            FreeQueuePage(m_pfqpHead);
            m_pfqpHead = NULL;
        }
        else
            m_slTail.ExclusiveUnlock();

    }
#endif //SHARELOCK_TRY_BROKEN

    m_slHead.ExclusiveUnlock();

  Exit:
    AssertQueue();

    if (FAILED(hr))
        *ppqdata = NULL;
#ifdef DEBUG
    else
        Assert(NULL != *ppqdata);
#endif //DEBUG

    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrRequeue ]--------------------------------------------------
//
//
//  Description:
//      Requeues a message to the head of the queue (like an enqueue that occurs
//      at the head.
//
//  Parameters:
//      IN PQDATA pqdata  data to be enqueued
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if an allocation error occurs
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrRequeue(IN PQDATA pqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrRequeue");
    HRESULT  hr             = S_OK;
    PQDATA  *ppqdataNewHead = NULL;
    BOOL     fHeadLocked    = FALSE;

    AssertQueue();
    Assert(pqdata);
    pqdata->AddRef();

    m_slHead.ExclusiveLock();
    fHeadLocked = TRUE;
    ppqdataNewHead = m_ppqdataHead - 1;

    //There are 2 cases to worry about here
    //  CASE 0: Head page is NULL - Either Queue is empty, or head has not
    //      been updated yet... may be changed into CASE 2 if queue non-empty
    //  CASE 1: Head page is valid and decremented Headptr is on a Head page
    //      In this case, the data can be requeued. Having m_slHead will make
    //      sure that the Head Page is not deleted from underneath us
    //  CASE 2: New Head ptr is invalid.  We need to allocate a new page to
    //      put requeued data on.

    if (NULL == m_pfqpHead)
    {
        //CASE 0
        hr = HrAdjustHead();
        if (FAILED(hr))
        {
            if (AQUEUE_E_QUEUE_EMPTY == hr)
            {
                //Queue is empty... just enqueue
                //But first, release head lock so enqueue has can allocate
                //first page etc....  Otherwise, we would guarantee failure
                //of enqueue TryExlusiveLock and for HrAdjustHead to do the
                //work next time.
                m_slHead.ExclusiveUnlock();
                fHeadLocked = FALSE;

                hr = HrEnqueue(pqdata);
                if (SUCCEEDED(hr))
                    pqdata->Release();
            }

            goto Exit;
        }
        //else will fall through to case 2
    }

    if ((m_pfqpHead != NULL) && !m_pfqpHead->FIsOutOfBounds(ppqdataNewHead))
    {
        //CASE 1
        *ppqdataNewHead = pqdata;
        m_ppqdataHead = ppqdataNewHead;
    }
    else
    {
        //CASE 2
        FQPAGE *pfqpNew = NULL;

        hr = HrAllocQueuePage(&pfqpNew);
        if (FAILED(hr))
            goto Exit;

        //make sure next points to the  head page
        pfqpNew->m_pfqpNext = m_pfqpHead;

        //prev needs to point to the new page
        if (m_pfqpHead)
            m_pfqpHead->m_pfqpPrev = pfqpNew;

        m_pfqpHead = pfqpNew;

        //write the data & update local copy of head
        m_ppqdataHead = &(pfqpNew->m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE-1]);
        *m_ppqdataHead = pqdata;

    }

    InterlockedIncrement((PLONG) &m_cQueueEntries);

  Exit:
    if (fHeadLocked)
        m_slHead.ExclusiveUnlock();
    AssertQueue();

    if (FAILED(hr))
        pqdata->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrPeek ]-----------------------------------------------------
//
//
//  Description:
//      Peeks at the head data on the queue.
//  Parameters:
//      OUT PQDATA *ppqdata   returned data
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY if the queue has no data in it
//      possibly E_FAIL or E_OUTOFMEMORY if one of the supporting functions fail
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrPeek(OUT PQDATA *ppqdata)
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrPeek");
    HRESULT hr            = S_OK;

    AssertQueue();
    Assert(ppqdata);

    if (m_cQueueEntries == 0)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    m_slHead.ExclusiveLock();

    hr = HrAdjustHead();
    if (FAILED(hr))
        goto Exit;

    *ppqdata = *m_ppqdataHead;
    (*ppqdata)->AddRef();

  Exit:
    m_slHead.ExclusiveUnlock();
    AssertQueue();
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrMapFn ]---------------------------------
//
//
//  Description:
//      Advances a secondary cursor until supplied function  returns FALSE
//  Parameters:
//      IN  pFunc - must be a function with the following prototype:
//
//          HRESULT pvFunc(
//                          IN  PQDATA pqdata,  //ptr to data on queue
//                          IN  PVOID pvContext,
//                          OUT BOOL *pfContinue, //TRUE if we should continue
//                          OUT BOOL *pfDelete);  //TRUE if item should be deleted
//      pvFunc must NOT release pqdata.. if it is no longer valid, it should
//      return TRUE in pfDelete, and the calling code will remove it from
//      the queue and release it.
//
//      OUT pcItems - count of queue items removed from queue
//
//  Returns:
//      S_OK on success
//      E_INVALIDARG if pvFunc is not valid
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrMapFn(
              IN MAPFNAPI pFunc,
              IN PVOID pvContext,
              OUT DWORD *pcItems)
{
    //$$TODO: Test the context handle feature
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrMapFn");
    HRESULT  hr               = S_OK;
    FQPAGE  *pfqpCurrent      = NULL;   //The current page we are looking at
    FQPAGE  *pfqpTmp          = NULL;
    PQDATA  *ppqdataCurrent   = NULL;   //The current queue data we are looking at
    PQDATA  *ppqdataLastValid = NULL;   //The last non-NULL queue data
    DWORD    cItems           = 0;
    BOOL     fPageInUse       = FALSE;
    BOOL     fContinue        = FALSE;
    BOOL     fDelete          = FALSE;
    BOOL     fLocked          = FALSE;

    //Variables that make it easier to debug this function
    PQDATA  *ppqdataOldTail   = NULL;
    PQDATA  *ppqdataOldHead   = NULL;

    if (NULL != pcItems)
        *pcItems = 0;

    if (NULL == pFunc)  //$$REVIEW - more validation than this?
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (0 == m_cQueueEntries) //don't even bother if nothing is in the queue
        goto Exit;

    m_slHead.ExclusiveLock();
    m_slTail.ExclusiveLock();

    fLocked = TRUE;
    DebugTrace((LPARAM) this, "MapFn Has Exclusive Locks");

    //make sure that head pointer is adjusted properly
    hr = HrAdjustHead();
    if (FAILED(hr))
    {
        _ASSERT((AQUEUE_E_QUEUE_EMPTY == hr) && "HrAdjustHead failed without AQUEUE_E_QUEUE_EMPTY!!!!");
        hr = S_OK;
    }

    AssertQueueHaveLocks();

    pfqpCurrent = m_pfqpHead;  //start at head and work backwards
    ppqdataCurrent = m_ppqdataHead;

    _ASSERT(pfqpCurrent || !m_cQueueEntries);

    while (NULL != pfqpCurrent)
    {
        DEBUG_DO_IT(ppqdataOldTail = m_ppqdataTail);
        DEBUG_DO_IT(ppqdataOldHead = m_ppqdataHead);

        if (m_cQueueEntries == 0)
        {
            Assert(m_pfqpHead == m_pfqpTail);
            Assert(m_pfqpHead == pfqpCurrent);
            m_pfqpHead = NULL;
            m_pfqpTail = NULL;
            m_ppqdataHead = NULL;
            m_ppqdataTail = NULL;
            FreeQueuePage(pfqpCurrent);
            pfqpCurrent = NULL;
            goto Exit;
        }

        if (pfqpCurrent->FIsOutOfBounds(ppqdataCurrent) ||
            ((m_pfqpTail == pfqpCurrent) && (ppqdataCurrent >= m_ppqdataTail)))
        {
            //We are ready to set pfqpCurrent to point to the next page.. may need to
            //free the old page.

            if (fPageInUse)
            {
                //don't delete the page if there is still something on there
                pfqpCurrent = pfqpCurrent->m_pfqpNext;
            }
            else
            {
                pfqpTmp = pfqpCurrent->m_pfqpNext;
                if (NULL != pfqpTmp)
                    pfqpTmp->m_pfqpPrev = pfqpCurrent->m_pfqpPrev;
                else
                {
                    Assert(pfqpCurrent == m_pfqpTail); //It must be the tail

                    //point the tail to the next page
                    m_pfqpTail = m_pfqpTail->m_pfqpPrev;
                    m_ppqdataTail = ppqdataLastValid + 1;
                    //If last page was not deleted, then the last valid ptr should be on it
                    Assert((NULL == m_pfqpTail) || !m_pfqpTail->FIsOutOfBounds(ppqdataLastValid));
#ifdef FIFOQ_ASSERT_QUEUE
                    //fixup Hole count
                    //will not touch count if Tail ptr is after end of tail page
                    for (PQDATA *ppqdataTmp = m_ppqdataTail;
                         ppqdataTmp < m_pfqpTail->m_rgpqdata + FIFOQ_QUEUE_PAGE_SIZE;
                         ppqdataTmp++)
                    {
                        if (NULL == *ppqdataTmp)
                            m_pfqpTail->m_cHoles--;
                    }
#endif //FIFOQ_ASSERT_QUEUE
                    ppqdataLastValid = NULL;
                }

                if (NULL != pfqpCurrent->m_pfqpPrev)
                {
                    Assert(pfqpCurrent->m_pfqpPrev->m_pfqpNext == pfqpCurrent);
                    pfqpCurrent->m_pfqpPrev->m_pfqpNext = pfqpTmp;
                }
                else
                {
                    //if it does not have a prev pointer is should be the head
                    Assert(pfqpCurrent == m_pfqpHead);
                    Assert(NULL == pfqpCurrent->m_pfqpPrev);
                    if (m_pfqpTail == m_pfqpHead) //be sure to make tail valid
                    {
                        Assert(0); //the 1st if/else now handles this
                    }
                    m_pfqpHead = pfqpTmp;
                    m_ppqdataHead = m_pfqpHead->m_rgpqdata;
                }

                AssertQueueHaveLocks();//try to see what has happened before freeing
                FreeQueuePage(pfqpCurrent);
                pfqpCurrent = pfqpTmp;
                if (NULL != m_pfqpHead) {
                    Assert(NULL == m_pfqpHead->m_pfqpPrev);
                }

                AssertQueueHaveLocks();


            }
            if (NULL == pfqpCurrent)
                break;
            ppqdataCurrent = pfqpCurrent->m_rgpqdata;
            fPageInUse = FALSE;
        }

        Assert(ppqdataCurrent);  //the above should guarantee this

        if (NULL != *ppqdataCurrent)
        {
            hr = pFunc(*ppqdataCurrent, pvContext, &fContinue, &fDelete);
            if (FAILED(hr))
                goto Exit;

            if (fDelete)
            {
                InterlockedDecrement((PLONG) &m_cQueueEntries);
                (*ppqdataCurrent)->Release();
                *ppqdataCurrent = NULL;
#ifdef FIFOQ_ASSERT_QUEUE
                pfqpCurrent->m_cHoles++;  //adjust Hole counter for assertions
#endif //FIFOQ_ASSERT_QUEUE
                cItems++;
            }
            else
            {
                fPageInUse = TRUE;
                ppqdataLastValid = ppqdataCurrent;
            }
            if (!fContinue)
                break;
        }
        ppqdataCurrent++;
    }


  Exit:
    if (fLocked)
    {
        AssertQueueHaveLocks();
        m_slTail.ExclusiveUnlock();
        m_slHead.ExclusiveUnlock();
    }
    else
    {
        AssertQueue();
    }

    if (NULL != pcItems)
        *pcItems = cItems;
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrAdjustHead ]----------------------------------------------
//
//
//  Description:
//      Adjust Head ptr and Head Page ptr if necessary for pending dequeue or
//      peek.  To keep operations thread-safe, you MUST have the head lock
//
//      This function is used because there are many operations that may leave
//      the head page/ptr in an inconsistant state, but very few that actually
//      need them to be consistant.  Rather than running the risk of missing
//      a case where the head ptr is inconsistant, we call this function when
//      we need them to be consistant
//
//      Head page and head ptr may be updated as a side-effect
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY if the queue is empty (or becomes empty)
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrAdjustHead()
{
    TraceFunctEnterEx((LPARAM) this, "CFifoQueue::HrAdjustHead");
    HRESULT hr = S_OK;

    //AssertQueue(); // the locks we are using are not re-entrant.

    //Make sure that something hasn't been dequeued from underneath us
    //at least from our perception of the ptrs
    if (m_cQueueEntries == 0)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    while (TRUE) //handle holes in queue (marked as NULL ptrs)
    {
        //now find an appropriate value for the head ptr
        //  Case 0: if Head Page is NULL, then find first page by searching from
        //          Tail page. This case happens when the queue is truely empty
        //          or first enqueue could not get Tail lock.
        //  Case 1: if Head data pointer is NULL, or invalid and not just
        //          past end of head page, then set it to first thing on
        //          head page.
        //
        //          $$REVIEW - I don't think there are any cases that
        //          can cause (and not case 0).  I will put an assert in to
        //          make sure this is truely the case.
        //  Case 2: if just past end of page, attempt to update head page,
        //          and set to first thing on new head page. This means
        //          that the last item on that page has been dequeued.
        //  Case 3: Within current head page boundaries, keep it as is.
        //          This is the 90% case that happens most often during
        //          normal operation.
        if (NULL == m_pfqpHead)
        {
            //case 0
            DebugTrace((LPARAM) this, "Searching list for Head page");
            m_pfqpHead = m_pfqpTail;
            if (NULL == m_pfqpHead) //there IS nothing in the queue
            {
                Assert(0 == m_cQueueEntries);
                hr = AQUEUE_E_QUEUE_EMPTY;
                goto Exit;
            }

            while (NULL != m_pfqpHead->m_pfqpPrev) //get to first page
            {
                m_pfqpHead = m_pfqpHead->m_pfqpPrev;
            }
            m_ppqdataHead = m_pfqpHead->m_rgpqdata;
        }

        _ASSERT(m_pfqpHead); //otherwise should have returned AQUEUE_E_QUEUE_EMPTY
        if ((m_ppqdataHead == NULL) ||
              (m_pfqpHead->FIsOutOfBounds(m_ppqdataHead) &&
              (m_ppqdataHead != (&m_pfqpHead->m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE]))))
        {
            //case 1
            m_ppqdataHead = m_pfqpHead->m_rgpqdata;

            _ASSERT(0 && "Non-fatal assert... get mikeswa to take a look at this case");
        }
        else if (m_ppqdataHead == (&m_pfqpHead->m_rgpqdata[FIFOQ_QUEUE_PAGE_SIZE]))
        {
            //case 2
            DebugTrace((LPARAM) this, "Deleting page 0x%08X", m_pfqpHead);
            //set new head page
            FQPAGE *pfqpOld = m_pfqpHead;
            m_pfqpHead = m_pfqpHead->m_pfqpNext;
            Assert(m_pfqpHead->m_pfqpPrev == pfqpOld);
            Assert(m_pfqpHead);  //There must be a next head if not empty

            m_pfqpHead->m_pfqpPrev = NULL;
            m_ppqdataHead = m_pfqpHead->m_rgpqdata;

            FreeQueuePage(pfqpOld);

            _ASSERT(m_pfqpHead && (NULL == m_pfqpHead->m_pfqpPrev));

        }

        if (NULL != *m_ppqdataHead)
            break;
        else
        {
            //Case 3
            m_ppqdataHead++;
#ifdef FIFOQ_ASSERT_QUEUE
            Assert(m_pfqpHead->m_cHoles >= 1);
            Assert(m_pfqpHead->m_cHoles <= FIFOQ_QUEUE_PAGE_SIZE);
            m_pfqpHead->m_cHoles--;
#endif //FIFOQ_ASSERT_QUEUE
        }
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::HrAllocQueuePage ]------------------------------------------
//
//
//  Description: Allocates a queue page
//
//  Parameters:
//      OUT FQPAGE **ppfqp  newly allocated page
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY on failure
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT CFifoQueue<PQDATA>::HrAllocQueuePage(FQPAGE **ppfqp)
{
    TraceFunctEnterEx((LPARAM) s_cFreePages, "CFifoQueue::HrAllocQueuePage");
    HRESULT hr              = S_OK;
    FQPAGE *pfqpNew         = NULL;
    FQPAGE *pfqpNext        = NULL;
    FQPAGE *pfqpCheck       = NULL;

    Assert(ppfqp);
    *ppfqp = NULL;

    if (s_cFreePages)
    {
        //
        //  Grab critical section before looking at head of the free list
        //
        EnterCriticalSection(&s_csAlloc);

        pfqpNew = (FQPAGE *) s_pfqpFree;
        if (NULL != pfqpNew)
        {
            pfqpNext = pfqpNew->m_pfqpNext;
            s_pfqpFree = pfqpNext;
            *ppfqp = pfqpNew;
        }
        
        //
        //  Release the critical section now that we are done with the free list
        //
        LeaveCriticalSection(&s_csAlloc);

        //
        //  If our allocation was successfull, bail and return the new page
        //
        if (*ppfqp) 
        {
            InterlockedDecrement((PLONG) &s_cFreePages);
#ifdef DEBUG
            InterlockedIncrement((PLONG) &s_cFreeAllocated);
#endif //DEBUG

            pfqpNew->Recycle();
            goto Exit;
        }

    }

    *ppfqp = new FQPAGE();

    if (*ppfqp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

#ifdef DEBUG
    InterlockedIncrement((PLONG) &s_cAllocated);
#endif //DEBUG

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CFifoQueue::FreeQueuePage ]------------------------------------------------------------
//
//
//  Description: Free's a queue page, by putting it on the free list.
//
//  Parameters:
//      FQPAGE *pfqp    page to free
//  Returns:
//      -
//-----------------------------------------------------------------------------
template <class PQDATA>
void CFifoQueue<PQDATA>::FreeQueuePage(FQPAGE *pfqp)
{
    TraceFunctEnterEx((LPARAM) s_cFreePages, "CFifoQueue::FreeQueuePage");
    Assert(pfqp);
    Assert(pfqp != s_pfqpFree); //check against pushing same thing twice in a row

    FQPAGE *pfqpCheck = NULL;
    FQPAGE *pfqpFree  = NULL;

    if (s_cFreePages < FIFOQ_QUEUE_MAX_FREE_PAGES)
    {
        //
        //  Grab critical section before looking at head of the free list
        //
        EnterCriticalSection(&s_csAlloc);

        //
        //  Update the free list
        //
        pfqpFree = (FQPAGE *) s_pfqpFree;
        pfqp->m_pfqpNext = pfqpFree;
        s_pfqpFree = pfqp;

        //
        //  Release Critical section now that we have updated the freelist
        //
        LeaveCriticalSection(&s_csAlloc);

        InterlockedIncrement((PLONG) &s_cFreePages);
#ifdef DEBUG
        InterlockedIncrement((PLONG) &s_cFreeDeleted);
#endif //DEBUG
    }
    else
    {
        delete pfqp;
#ifdef DEBUG
        InterlockedIncrement((PLONG) &s_cDeleted);
#endif //DEBUG
    }
    TraceFunctLeave();
}

//---[ HrClearQueueMapFn ]-----------------------------------------------------
//
//
//  Description:
//      Example default function to use with HrMapFn... will always return TRUE
//      to continue and delete the current queued data
//  Parameters:
//      IN  PQDATA pqdata,  //ptr to data on queue
//      IN  PVOID pvContext - ignored
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      S_OK
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT HrClearQueueMapFn(IN PQDATA pqdata, IN PVOID pvContext, OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    Assert(pfContinue);
    Assert(pfDelete);
    HRESULT hr = S_OK;

    *pfContinue = TRUE;
    *pfDelete   = TRUE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\failmsgq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: failmsgq.h
//
//  Description:
//      Header file for CFailedMsgQueue class with servers as a holding place
//      for messages that cannot be delivered due to out of memory and other
//      conditions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      1/18/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __FAILMSGQ_H__
#define __FAILMSGQ_H__

#include "aqincs.h"
#include "rwnew.h"

class CMsgRef;
class CAQSvrInst;

#define FAILEDMSGQUEUE_SIG ' QMF'

//---[ CFailedMsgQueue ]-------------------------------------------------------
//
//
//  Description: 
//      Class that abtracts handling of failed messages.  There is no 
//      additional memory allocation need during the processing of the 
//      of these failed messages.  The key design point is that none of these
//      API calls can fail.
//
//      This class contains a single list entries for MailMsgs.  MailMsgs that 
//      have been dropped here must not be referenced by another other thread,
//      or we might break the threading-access restrictions of the mailmsg
//      interface.  Once a MailMsg has been queued, it is encapsultated in a 
//      CMsgRef object, which can be referenced by many threads.  At this point
//      we must wait until all references to that CMsgRef are released.
//   
//  Hungarian: 
//      fmq, pfmq
//  
//-----------------------------------------------------------------------------
class CFailedMsgQueue
{
  private:
    DWORD           m_dwSignature;
    DWORD           m_dwFlags;
    DWORD           m_cMsgs; 
    CAQSvrInst     *m_paqinst;
    LIST_ENTRY      m_liHead;
    CShareLockNH    m_slPrivateData;

    enum
    {
        FMQ_CALLBACK_REQUESTED =    0x00000001,
    };

    void InternalStartProcessingIfNecessary();

  public:
    CFailedMsgQueue();
    ~CFailedMsgQueue();

    void Initialize(CAQSvrInst *paqinst);
    void Deinitialize();

    //Functions called to handle a failure
    void HandleFailedMailMsg(IMailMsgProperties *pIMailMsgProperties);

    //Called on SubmitMessage to kick off processing if necessary
    inline void StartProcessingIfNecessary()
    {
        if (!(FMQ_CALLBACK_REQUESTED & m_dwFlags) && m_cMsgs)
            InternalStartProcessingIfNecessary();
    }

    //Member function and callback function to process entries.
    void ProcessEntries();
    static void ProcessEntriesCallback(PVOID pvContext);
};

//---[ AQueueFailedListEntry ]-------------------------------------------------
//
//
//  Description: 
//      Actual in-memory representation of LIST_ENTRY ptr returned by mailmsg.
//      Memory after LIST_ENTRY is used to store original pointer.
//  Hungarian: 
//      fli, pfli
//  
//-----------------------------------------------------------------------------
typedef struct tagAQueueFailedListEntry 
{
    LIST_ENTRY          m_li;
    IMailMsgProperties *m_pIMailMsgProperties;
} AQueueFailedListEntry;

#endif //__FAILMSGQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\localq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: localq.cpp
//
//  Description:  Implementation for local admin queues
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/23/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "localq.h"
#include "aqadmsvr.h"
#include "asyncq.inl"

//---[ CLocalLinkMsgQueue::CLocalLinkMsgQueue ]---------------------------------
//
//
//  Description: 
//      Default constructor for CLocalLinkMsgQueue
//  Parameters:
//      IN      paradmq         Local async queue
//      IN      guidLink        Router GUID to associate with this link
//  Returns:
//      -
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CLocalLinkMsgQueue::CLocalLinkMsgQueue(
                       CAsyncRetryAdminMsgRefQueue *paradmq, 
                       GUID guidLink) : CLinkMsgQueue(guidLink)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::CLocalLinkMsgQueue");
    //Initialize superclass with our own special GUID
    
    _ASSERT(paradmq);
    m_paradmq = paradmq;

    m_dwLocalLinkSig = LOCAL_LINK_MSG_QUEUE_SIG;
    
    TraceFunctLeave();
}

#ifdef NEVER
//---[ CLinkMsgQueue::fSameNextHop ]-------------------------------------------
//
//
//  Description: 
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  paqsched        ScheduleID to check against
//      IN  szDomain        Domain name to check against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CLocalLinkMsgQueue::fSameNextHop(CAQScheduleID *paqsched, LPSTR szDomain)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::fSameNextHop");
    _ASSERT(paqsched);

    if (!paqsched)
        return FALSE;

    if (!fIsSameScheduleID(paqsched))
        return FALSE;

    //Don't need to check domain name since there is a special GUID to 
    //identify the local link.  This will allow us to match both 
    //"LocalLink" (returned in LinkID) and whatever the current value of
    //the default domain is (we don't have to worry about the clients
    //version becoming outdated).
    
    //Everything matched!
    TraceFunctLeave();
    return TRUE;
}
#endif //NEVER
//---[ CLocalLinkMsgQueue::fMatchesID ]--------------------------------------
//
//
//  Description: 
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CLocalLinkMsgQueue::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);

    CAQScheduleID aqsched(pQueueLinkID->uuid, pQueueLinkID->dwId);

    if (!fIsSameScheduleID(&aqsched))
        return FALSE;

    //Don't need to check domain name since there is a special GUID to 
    //identify the local link.  This will allow us to match both 
    //"LocalLink" (returned in LinkID) and whatever the current value of
    //the default domain is (we don't have to worry about the clients
    //version becoming outdated).
    //Everything matched!

    return TRUE;
}

//---[ CLocalLinkMsgQueue::HrApplyQueueAdminFunction ]-------------------------
//
//
//  Description: 
//      Used by queue admin to apply a function all queues on this link
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrApplyQueueAdminFunction(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;

    hr = CLinkMsgQueue::HrApplyQueueAdminFunction(pIQueueAdminMessageFilter);

    if (FAILED(hr))
        goto Exit;

    //
    //  Pass in CLinkMsgQueue as context, so we can be notified when
    //  a message is removed from the queue (and update our stats)
    //
    _ASSERT(pIQueueAdminMessageFilter);
    hr = pIQueueAdminMessageFilter->HrSetCurrentUserContext((CLinkMsgQueue *) this);
    if (FAILED(hr))
        goto Exit;

    _ASSERT(m_paradmq);
    hr = m_paradmq->HrApplyQueueAdminFunction(pIQueueAdminMessageFilter);
    if (FAILED(hr))
        goto Exit;

    hr = pIQueueAdminMessageFilter->HrSetCurrentUserContext(NULL);

  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ CLocalLinkMsgQueue::HrGetLinkInfo ]-------------------------------------
//
//
//  Description: 
//      Fills in the details for a LINK_INFO struct.  RPC is resonsible for
//      freeing memory.
//  Parameters:
//      IN OUT pliLinkInfo  Ptr to link info struct to fill
//  Returns:
//      S_OK if successful
//      E_OUTOFMEMORY if unable to allocate memory
//  History:
//      2/23/99 - MikeSwa Created 
//      7/1/99 - MikeSwa Added LinkDiagnostic
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrGetLinkInfo(LINK_INFO *pliLinkInfo,
                                               HRESULT   *phrLinkDiagnostic)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;
    CRefCountedString *prstrDefaultDomain = NULL;
    hr = CLinkMsgQueue::HrGetLinkInfo(pliLinkInfo, phrLinkDiagnostic);
    QUEUE_INFO qi;

    _ASSERT(m_paradmq);

    //
    //  Get our queue state from our base asyncq implementation
    //
    pliLinkInfo->fStateFlags = m_paradmq->dwQueueAdminLinkGetLinkState();

    //This is the local link
    pliLinkInfo->fStateFlags |= LI_TYPE_LOCAL_DELIVERY;

    if (m_paqinst)
        prstrDefaultDomain = m_paqinst->prstrGetDefaultDomain();

        
    //Copy Default local domain name instead of "LocalLink"
    if (prstrDefaultDomain && 
        prstrDefaultDomain->cbStrlen() && 
        prstrDefaultDomain->szStr())
    {
        if (pliLinkInfo->szLinkName)
        {
            QueueAdminFree(pliLinkInfo->szLinkName);
            pliLinkInfo->szLinkName = NULL;
        }

        pliLinkInfo->szLinkName = wszQueueAdminConvertToUnicode(
                                        prstrDefaultDomain->szStr(),
                                        prstrDefaultDomain->cbStrlen());
        if (!pliLinkInfo->szLinkName)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pliLinkInfo->szLinkName[prstrDefaultDomain->cbStrlen()] = '\0';
    }

    //Get the queue info from the local queue for size totals
    ZeroMemory(&qi, sizeof(QUEUE_INFO));
    hr = m_paradmq->HrGetQueueInfo(&qi); 
    if (FAILED(hr))
        goto Exit;

    //Clean up allocated stuff
    if (qi.szQueueName)
        QueueAdminFree(qi.szQueueName);

    if (qi.szLinkName)
        QueueAdminFree(qi.szLinkName);

  Exit:

    if (prstrDefaultDomain)
        prstrDefaultDomain->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CLocalLinkMsgQueue::HrApplyActionToLink ]-------------------------------
//
//
//  Description: 
//      Applies the specified QueueAdmin action to this link
//  Parameters:
//      IN  la          Link action to apply
//  Returns:
//      S_OK on success
//      E_INVALIDARG if bogus action is given
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrApplyActionToLink(LINK_ACTION la)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;

    //It is important to release that it does not make sense to re-apply these
    //actions back to the LMQ, becuase it is actually the CAsyncRetryQueue
    //that affects the state of this.
    _ASSERT(m_paradmq);

    if (LA_KICK == la)
    {
        //kick the link
        m_paradmq->StartRetry();
    }
    else if (LA_FREEZE == la)
    {
        //Admin wants this link to stop sending mail inbound to the store
        //$$REVIEW - Does this make sense for local queues
    }
    else if (LA_THAW == la)
    {
        //Thaw that which was previously frozen
        //$$REVIEW - Requires freeze functionality to make sense
    }
    else
    {
        //invalid arg
        hr = E_INVALIDARG;
        goto Exit;
    }

  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ CLocalLinkMsgQueue::HrGetNumQueues ]------------------------------------
//
//
//  Description: 
//      Returns the number of queues on this link
//  Parameters:
//      OUT pcQueues        # numbr of queues
//  Returns:
//      S_OK on success
//      E_POINTER if pcQueues is not valid
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrGetNumQueues(DWORD *pcQueues)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    HRESULT hr = S_OK;
    hr = CLinkMsgQueue::HrGetNumQueues(pcQueues);
    if (SUCCEEDED(hr))
    {
        _ASSERT(pcQueues);
        (*pcQueues)++; //Add extra count for local async queue
    }

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrGetQueueIDs ]--------------------------------------------
//
//
//  Description: 
//      Gets the Queue IDs for DMQs associated with this link.  Used by Queue
//      Admin.
//  Parameters:
//      IN OUT pcQueues     Sizeof array/ number of queues found
//      IN OUT rgQueues     Array to dump queue info into
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY on out of memory failure
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//  History:
//      2/23/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLocalLinkMsgQueue::HrGetQueueIDs(
                                    DWORD *pcQueues,
                                    QUEUELINK_ID *rgQueues)
{
    TraceFunctEnterEx((LPARAM) this, "CLocalLinkMsgQueue::HrApplyQueueAdminFunction");
    _ASSERT(pcQueues);
    _ASSERT(rgQueues);
    HRESULT hr = S_OK;
    
    //Check to make sure we have room for the additional queue ID
    if (*pcQueues < (m_cQueues+1))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    //Make sure that thread-safe check in CLinkMsgQueue allows room 
    //for our local queue.
    (*pcQueues)--;

    hr = CLinkMsgQueue::HrGetQueueIDs(pcQueues, rgQueues);
    if (FAILED(hr))
    {
        //Tell caller we need room for our queue as well
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
            (*pcQueues)++; 

        goto Exit;
    }

    hr = m_paradmq->HrGetQueueID(&rgQueues[*pcQueues]);
    if (FAILED(hr))
        goto Exit;

    (*pcQueues)++;
  Exit:

    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\localq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: localq.h
//
//  Description:  Header file for CLocalLinkMsgQueue class... a subclass of 
//      CLinkMsgQueue that provides the additional functionality need to 
//      admin a local queue
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/23/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __LOCALQ_H__
#define __LOCALQ_H__

#include "linkmsgq.h"

#define LOCAL_LINK_MSG_QUEUE_SIG 'QMLL'

//---[ CLocalLinkMsgQueue ]----------------------------------------------------
//
//
//  Description: 
//      Derived class of CLinkMsgQueue that provides that additional queue 
//      admin functionality required to handle local delivery
//  Hungarian: 
//      llmq, pllmq
//  
//-----------------------------------------------------------------------------
class CLocalLinkMsgQueue :
    public CLinkMsgQueue
{
  protected:
    DWORD                            m_dwLocalLinkSig;
    CAsyncRetryAdminMsgRefQueue     *m_paradmq;
  public:
    CLocalLinkMsgQueue(CAsyncRetryAdminMsgRefQueue *paradmq, 
                       GUID guidLink);

    virtual BOOL fIsRemote() {return FALSE;};

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return QueryDefaultSupportedActions(pdwSupportedActions, 
                                            pdwSupportedFilterFlags);
    };

  public: //IQueueAdminLink
    STDMETHOD(HrGetLinkInfo)(
        LINK_INFO *pliLinkInfo,
        HRESULT   *phrLinkDiagnostic);

    STDMETHOD(HrApplyActionToLink)(
        LINK_ACTION la);

    STDMETHOD(HrGetNumQueues)(
        DWORD *pcQueues);

    STDMETHOD(HrGetQueueIDs)(
        DWORD *pcQueues,
        QUEUELINK_ID *rgQueues);

};

#endif //__LOCALQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\linkmsgq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: linkmsgq.cpp
//
//  Description: Implementation of CLinkMsgQueue object.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "dcontext.h"
#include "aqnotify.h"
#include "connmgr.h"
#include "dbgilock.h"
#include "domcfg.h"
#include "smtpconn.h"
#include "smproute.h"

#define CONNECTION_BUFFER_SIZE 10

LinkFlags li; //encourage symbols to appear debug versions


//---[ CLinkMsgQueue::RestartDSNGenerationIfNecessary ]------------------------
//
//
//  Description:
//      Static wrapper to continue generating DSNs after we have hit our
//      limit of time spent in DSNs generation
//  Parameters:
//      pvContext   - "this" pointer for CLinkMsgQueue
//      dwStatus    - Completion Status
//  Returns:
//      TRUE always
//  History:
//      11/10/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fRestartDSNGenerationIfNecessary(PVOID pvContext,
                                                    DWORD dwStatus)
{
    TraceFunctEnterEx((LPARAM) pvContext, "CLinkMsgQueue::fRestartDSNGenerationIfNecessary");
    CLinkMsgQueue *plmq = (CLinkMsgQueue *) pvContext;
    BOOL           fHasShutdownLock = FALSE;
    BOOL           fHasRoutingLock = FALSE;

    _ASSERT(plmq);
    _ASSERT(LINK_MSGQ_SIG == plmq->m_dwSignature);

    DebugTrace((LPARAM) plmq, "Attempting to restart DSN generation");

    //Don't try DSN generation if this is not a normal completion
    if (dwStatus != ASYNC_WORK_QUEUE_NORMAL)
        goto Exit;

    //Only attempt to continue DSN genration if we cannot create a connection
    //now and have no current connections
    if (plmq->m_cConnections)
    {
        DebugTrace((LPARAM) plmq,
            "We have %d connections... skipping DSN generation",
            plmq->m_cConnections);
        goto Exit;
    }

    if (fFlagsAllowConnection(plmq->m_dwLinkStateFlags))
    {
        DebugTrace((LPARAM) plmq,
            "We can create a connection, skipping DSN generation - flags 0x%X",
            plmq->m_dwLinkStateFlags);
        goto Exit;
    }

    //We need to grab the shutdown and routing lock... just like
    //normal DSN generation.
    if (!plmq->m_paqinst->fTryShutdownLock())
        goto Exit;

    fHasShutdownLock = TRUE;

    if (!plmq->m_paqinst->fTryRoutingShareLock())
        goto Exit;

    fHasRoutingLock = TRUE;

    //Call to generate DSNs... pass in parameters to always check the
    //queues and walk for DSN generation (not just remerge).
    plmq->GenerateDSNsIfNecessary(TRUE, FALSE);

  Exit:
    if (fHasRoutingLock)
        plmq->m_paqinst->RoutingShareUnlock();

    if (fHasShutdownLock)
        plmq->m_paqinst->ShutdownUnlock();

    plmq->Release();
    TraceFunctLeave();
    return TRUE;
}

//---[ CLinkMsgQueue::HrGetInternalInfo ]---------------------------------------
//
//
//  Description:
//      Private function to get cached link info, and update cached data if
//      needed.
//
//      NOTE:  This is the only way the cached data should be access (other than
//          startup and shutdown).
//  Parameters:
//      OUT     ppIntDomainInfo     (can be NULL)
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if queue is shutting down.
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetInternalInfo(OUT CInternalDomainInfo **ppIntDomainInfo)
{
    HRESULT hr = S_OK;
    _ASSERT(m_cbSMTPDomain);
    _ASSERT(m_szSMTPDomain);

    if (ppIntDomainInfo)
        *ppIntDomainInfo = NULL;

    //If we don't currently have domain info and it was not a failure
    //condition... don't reget domain info
    if (!m_pIntDomainInfo && !(eLinkFlagsGetInfoFailed & m_dwLinkFlags))
        goto Exit;

    m_slInfo.ShareLock();

    //Verify Domain Config Info
    while (!m_pIntDomainInfo ||
        (m_pIntDomainInfo->m_dwIntDomainInfoFlags & INT_DOMAIN_INFO_INVALID))
    {
        m_slInfo.ShareUnlock();
        m_slInfo.ExclusiveLock();
        //another may have gotten exclusive lock in meantime
        if (m_pIntDomainInfo &&
            !(m_pIntDomainInfo->m_dwIntDomainInfoFlags & INT_DOMAIN_INFO_INVALID))
        {
            //another thread has updated info
            m_slInfo.ExclusiveUnlock();
            m_slInfo.ShareLock();
            continue;
        }

        //Domain info is no longer valid at this point
        if (m_pIntDomainInfo)
        {
            m_pIntDomainInfo->Release();
            m_pIntDomainInfo = NULL;
        }

        if (m_dwLinkFlags & eLinkFlagsExternalSMTPLinkInfo) {
            hr = m_paqinst->HrGetInternalDomainInfo(m_cbSMTPDomain, m_szSMTPDomain,
                                &m_pIntDomainInfo);
        } else {
            hr = m_paqinst->HrGetDefaultDomainInfo(&m_pIntDomainInfo);
        }

        if (FAILED(hr))
        {
            dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsGetInfoFailed);
            m_slInfo.ExclusiveUnlock();
            _ASSERT(AQUEUE_E_SHUTDOWN == hr);
            goto Exit;
        }

        _ASSERT(m_pIntDomainInfo);
        //Handle change of TURN/ETRN
        if (m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
             (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))
        {
            if (!(m_dwLinkStateFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN))
            {
                //Modify link flags to account for TURN/ETRN
                dwInterlockedSetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_CONFIG_TURN_ETRN);
            }
        }
        else if (m_dwLinkStateFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
        {
            //We used to be TURN/ETRN, but are no-longer configured as such
            dwInterlockedUnsetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_CONFIG_TURN_ETRN);
        }

        m_slInfo.ExclusiveUnlock();
        m_slInfo.ShareLock();
    }

    //Now we have info... set out param and addref
    if (ppIntDomainInfo)
    {
        *ppIntDomainInfo = m_pIntDomainInfo;
        m_pIntDomainInfo->AddRef();
    }

    //Clear failure bit if set
    if (eLinkFlagsGetInfoFailed & m_dwLinkFlags)
        dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsGetInfoFailed);

    m_slInfo.ShareUnlock();

   Exit:
    return hr;
}


//---[ CLinkMsgQueue::InternalInit ]------------------------------------------
//
//
//  Description:
//      Default constructor for CLinkMsgQueue.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/25/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::InternalInit()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::InternalInit");
    m_dwSignature       = LINK_MSGQ_SIG;
    m_dwLinkFlags       = eLinkFlagsClear;
    m_dwLinkStateFlags  = LINK_STATE_SCHED_ENABLED |
                          LINK_STATE_RETRY_ENABLED |
                          LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY;
    m_paqinst           = NULL;
    m_cQueues           = 0;
    m_cConnections      = 0;
    m_szSMTPDomain      = NULL;
    m_cbSMTPDomain      = 0;
    m_pIntDomainInfo    = NULL;
    m_pdentryLink       = NULL;
    m_lConnMgrCount     = 0;
    m_lConsecutiveConnectionFailureCount = 0;
    m_lConsecutiveMessageFailureCount = 0;
    m_liLinks.Flink     = NULL;
    m_liLinks.Blink     = NULL;
    m_szConnectorName   = NULL;
    m_dwRoundRobinIndex = 0;
    m_pILinkStateNotify = NULL;
    m_hrDiagnosticError      = S_OK;
    m_szDiagnosticVerb[0]    = '\0';
    m_szDiagnosticResponse[0]= '\0';
    m_hrLastConnectionFailure= S_OK;

    ZeroMemory(&m_ftNextRetry, sizeof(FILETIME));
    ZeroMemory(&m_ftNextScheduledCallback, sizeof(FILETIME));
    ZeroMemory(&m_ftEmptyExpireTime, sizeof(FILETIME));

    AssertPrivateLinkStateFlags();

    //normally links are for remote delivery, in special cases like the currently unreachable
    //queue they are not. so we need a type field to differentiate between links, so that some
    //actions can be performed differently for the special links.
    SetLinkType(LI_TYPE_REMOTE_DELIVERY);

    //all actions are supported by default, but special links like currently unreachable may
    //set this bitmask to specify that certain actions are unsupported. when such an unsupported
    //action is commanded, nothing happens.
    SetSupportedActions(LA_KICK | LA_FREEZE | LA_THAW);

    InitializeListHead(&m_liConnections);
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::CLinkMsgQueue ]------------------------------------------
//
//
//  Description:
//      Class constuctor
//  Parameters:
//      IN dwScheduleID         Schedule ID to associate with link
//      IN pIMessageRouter      Router for this link
//      IN pILinkStateNotify    Scheduler Interface for this link
//  Returns:
//      -
//-----------------------------------------------------------------------------
CLinkMsgQueue::CLinkMsgQueue(DWORD dwScheduleID,
                         IMessageRouter *pIMessageRouter,
                         IMessageRouterLinkStateNotification *pILinkStateNotify)
                         : m_aqsched(pIMessageRouter, dwScheduleID),
                         m_slQueues("CLinkMsgQueue::m_slQueues"),
                         m_slConnections("CLinkMsgQueue::m_slConnections"),
                         m_slInfo("CLinkMsgQueue::m_slInfo")
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::CLinkMsgQueue2");

    InternalInit();


    m_pILinkStateNotify = pILinkStateNotify;
    if (m_pILinkStateNotify)
        m_pILinkStateNotify->AddRef();

    TraceFunctLeave();
}

//---[ CLinkMsgQueue::~CLinkMsgQueue ]------------------------------------------------------------
//
//
//  Description:
//      Class destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CLinkMsgQueue::~CLinkMsgQueue()
{
    // tell routing that this link is going away
    DWORD dw = dwModifyLinkState(LINK_STATE_LINK_NO_LONGER_USED, 0);
    if (!(dw & LINK_STATE_LINK_NO_LONGER_USED))
        SendLinkStateNotification();

    if (NULL != m_paqinst)
    {
        m_paqinst->DecNextHopCount();
        m_paqinst->Release();
    }

    if (NULL != m_pIntDomainInfo)
        m_pIntDomainInfo->Release();

    if (NULL != m_pdentryLink)
        m_pdentryLink->Release();

    if (m_szConnectorName)
        FreePv(m_szConnectorName);

    if (m_szSMTPDomain)
        FreePv(m_szSMTPDomain);

    if (m_pILinkStateNotify)
        m_pILinkStateNotify->Release();

    _ASSERT(IsListEmpty(&m_liConnections) && "Leaked connections");

}

//---[ CLinkMsgQueue::HrInitialize ]-----------------------------------------
//
//
//  Description: Performs initialization that may return an error code
//
//  Parameters:
//      IN  paqinst              Server Instance Object
//      IN  pdmap        Domain Mapping of SMTP Domain this link is for
//      IN  cbSMTPDomain
//      IN  szSMTPDomain SMTP Domain that link is being created for
//      IN  paqsched     Schedule ID returned by routing sink
//      IN  szConnectorName
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrInitialize(CAQSvrInst *paqinst,
                                    CDomainEntry *pdentryLink, DWORD cbSMTPDomain,
                                    LPSTR szSMTPDomain,
                                    LinkFlags lf,
                                    LPSTR szConnectorName)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrInitialize");
    HRESULT hr = S_OK;
    DWORD   cbConnectorName = 0;

    _ASSERT(szSMTPDomain);
    _ASSERT(cbSMTPDomain);
    _ASSERT(paqinst);

    m_paqinst = paqinst;
    if (m_paqinst)
    {
        m_paqinst->AddRef();
        m_paqinst->IncNextHopCount();
    }

    m_pdentryLink = pdentryLink;
    if (m_pdentryLink)
        m_pdentryLink->AddRef();

    m_szSMTPDomain = (LPSTR) pvMalloc(cbSMTPDomain+sizeof(CHAR));
    if (!m_szSMTPDomain)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace((LPARAM) this, "Error unable to allocate m_szSMTPDomain");
        goto Exit;
    }

    strcpy(m_szSMTPDomain, szSMTPDomain);
    m_cbSMTPDomain = cbSMTPDomain;

    if (szConnectorName)
    {
        cbConnectorName = lstrlen(szConnectorName) + sizeof(CHAR);
        m_szConnectorName = (LPSTR) pvMalloc(cbConnectorName);
        if (!m_szConnectorName)
        {
            hr = E_OUTOFMEMORY;
            ErrorTrace((LPARAM) this, "Error unable to allocate m_szConnectorName");
            goto Exit;
        }
        strcpy(m_szConnectorName, szConnectorName);

    }

    if (lf == eLinkFlagsInternalSMTPLinkInfo) {

        hr = m_paqinst->HrGetDefaultDomainInfo(&m_pIntDomainInfo);

    } else if (lf == eLinkFlagsExternalSMTPLinkInfo) {

        hr = m_paqinst->HrGetInternalDomainInfo(
                            cbSMTPDomain,
                            szSMTPDomain,
                            &m_pIntDomainInfo);
    } else {

        // linkInfoType can only be one of these 3 bits. Since we tested for
        // the above two, assert that it is the third type.

        _ASSERT(lf == eLinkFlagsAQSpecialLinkInfo);

    }

    m_dwLinkFlags |= lf;

    if (m_pIntDomainInfo &&
          m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &
         (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))
    {
        //Modify link flags to account for TURN/ETRN
        dwInterlockedSetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_CONFIG_TURN_ETRN);
    }

  Exit:

    //Turn off notifications if we failed
    if (FAILED(hr))
        dwModifyLinkState(LINK_STATE_LINK_NO_LONGER_USED, LINK_STATE_NO_ACTION);

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrDeinitialize ]-----------------------------------------
//
//
//  Description: Release link to m_paqinst object.
//
//  Parameters: -
//
//  Returns: S_OK on success
//
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrDeinitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrDeinitialize");
    HRESULT hr = S_OK;

    dwModifyLinkState(LINK_STATE_NO_ACTION,
                      LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY);
    RemoveAllQueues();

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::RemovedFromDMT ]-----------------------------------------
//
//
//  Description: Notification to the link that the DMT is removing it
//
//  Parameters: -
//
//  Returns: -
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemovedFromDMT()
{
    TraceFunctEnter("CLinkMsgQueue::RemovedFromDMT");

    // tell routing that this link is going away
    DWORD dw = dwModifyLinkState(LINK_STATE_LINK_NO_LONGER_USED, 0);
    if (!(dw & LINK_STATE_LINK_NO_LONGER_USED))
        SendLinkStateNotification();

    TraceFunctLeave();
}


//---[ CLinkMsgQueue::AddConnection ]----------------------------------------
//
//
//  Description:
//      Add a connection instance to this link
//  Parameters:
//      IN  pSMTPConn Connection to add to link
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::AddConnection(CSMTPConn *pSMTPConn)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrAddConnection");
    _ASSERT(pSMTPConn);

    _ASSERT(!(m_dwLinkStateFlags & LINK_STATE_PRIV_NO_CONNECTION));

    InterlockedIncrement((PLONG) &m_cConnections);

    m_slConnections.ExclusiveLock();
    pSMTPConn->InsertConnectionInList(&m_liConnections);
    m_slConnections.ExclusiveUnlock();

    DebugTrace((LPARAM) this, "Adding connection #%d to link", m_cConnections);
    TraceFunctLeave();
}
//---[ CLinkMsgQueue::RemoveConnection ]---------------------------------------
//
//
//  Description:
//      Remove a connection from the link
//  Parameters:
//      IN  pSMTPConn               Connection to remove from link
//      IN  fForceDSNGeneration     Force DSN generation
//  Returns:
//      - Always succeeds
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveConnection(IN CSMTPConn *pSMTPConn,
                                     IN BOOL fForceDSNGeneration)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::RemoveConnection");
    BOOL    fNoConnections = FALSE;
    BOOL    fMergeOnly = fFlagsAllowConnection(m_dwLinkStateFlags) &&
                         !fForceDSNGeneration;
    _ASSERT(pSMTPConn);

    _ASSERT(!(m_dwLinkStateFlags & LINK_STATE_PRIV_NO_CONNECTION));

    if (!m_paqinst)
        return;

    m_paqinst->RoutingShareLock();
    m_slConnections.ExclusiveLock();

    pSMTPConn->RemoveConnectionFromList();
    InterlockedDecrement((PLONG) &m_cConnections);

    fNoConnections = IsListEmpty(&m_liConnections);

    m_slConnections.ExclusiveUnlock();
    //Only generate DSNs if we have been kicked into retry
    if (fNoConnections)
    {
        //Generate DSNs if we cannot connect connect
        GenerateDSNsIfNecessary(TRUE, fMergeOnly);
        dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsConnectionVerifed);
    }
    m_paqinst->RoutingShareUnlock();
    DebugTrace((LPARAM) this, "Removing connection #%d to link", m_cConnections);
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::GenerateDSNsIfNecessary ]--------------------------------
//
//
//  Description:
//      Walks queues and generates DSNs if necessary.
//  Parameters:
//      BOOL    fCheckIfEmpty - check queues even if we think we are empty
//                          This is an optimization that should be used
//                          when we know there are no messages in the
//                          retry queues (like the Unreachable or
//                          CurrentlyUnreachable link)
//      BOOL    fMergeOnly - Only merge retry queues, do not walk for DSNs
//                          This improves perf for the cases were we have not
//                          had a connection error and really don't need to
//                          walk the queues.
//  Returns:
//      -
//  History:
//      1/27/99 - MikeSwa Created (pulled from RemoveConnection)
//      2/2/99 - MikeSwa Added fMergeOnly flag
//      11/10/1999 - MikeSwa Updated to be more release locks after generating
//              a max number of DSNs.
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::GenerateDSNsIfNecessary(BOOL fCheckIfEmpty, BOOL fMergeOnly)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::GenerateDSNsIfNecessary");
    DWORD   iQueues = 0;
    CDestMsgQueue *pdmq = NULL;
    PVOID   pvContext = NULL;
    HRESULT hrDSN = m_hrLastConnectionFailure;
    HRESULT hr = S_OK;
    BOOL    fRestartLater = FALSE;
    DWORD   dwDSNContext = 0;


    //If this link is configured as a TURN/ETRN link, we do not want to
    //immediately NDR the domain because if subject us to DOS attacks.
    //We only want to generate expire DSNs
    if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & m_dwLinkStateFlags)
        hrDSN = AQUEUE_E_HOST_NOT_RESPONDING;

    if (!fCheckIfEmpty && !m_aqstats.m_cMsgs)
        return;

    if (!(LINK_STATE_PRIV_GENERATING_DSNS &
        dwInterlockedSetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_GENERATING_DSNS)))
    {

        if (m_paqinst && m_paqinst->fTryShutdownLock())
        {
            //Don't attempt to requeue if we are shutting down
            m_slQueues.ShareLock();
            pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);
            while (pdmq)
            {
                pdmq->AssertSignature();
                if (fMergeOnly)
                    pdmq->MergeRetryQueue();
                else
                    hr = pdmq->HrGenerateDSNsIfNecessary(&m_qlstQueues, hrDSN, &dwDSNContext);

                if (FAILED(hr) && (HRESULT_FROM_WIN32(E_PENDING) == hr))
                {
                    fRestartLater = TRUE;
                    break;
                }

                iQueues++;
                pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);
                _ASSERT(iQueues <= m_cQueues);
            }

            m_slQueues.ShareUnlock();
            m_paqinst->ShutdownUnlock();
        }

        if (fRestartLater)
        {
            //We have hit our limit on the number of messages to process
            //at one time.  Schedule a callback to process more later
            DebugTrace((LPARAM) this,
                "Will continue DSN generation at a later time - 0x%X", hr);

            AddRef();  //Completion function will release on failure
            m_paqinst->HrQueueWorkItem(this,
                                   CLinkMsgQueue::fRestartDSNGenerationIfNecessary);
        }
        dwInterlockedUnsetBits(&m_dwLinkStateFlags, LINK_STATE_PRIV_GENERATING_DSNS);
    }
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetDomainInfo ]----------------------------------------
//
//
//  Description:
//      Returns domain info for SMTP connection.
//  Parameters:
//      OUT pcbSMTPDomain   String length of domain name
//      OUT pszSMTPDomain   String containing domain info (memory managed byt DMT)
//      OUT ppIntDomainInfo Internal Domain Info for link's next hop
//  Returns:
//      S_OK on success
//      AQUEUE_E_LINK_INVALID if link is no longer valud
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetDomainInfo(OUT DWORD *pcbSMTPDomain,
                        OUT LPSTR *pszSMTPDomain,
                        OUT CInternalDomainInfo **ppIntDomainInfo)
{
    HRESULT hr = S_OK;

    _ASSERT(pcbSMTPDomain);
    _ASSERT(pszSMTPDomain);
    _ASSERT(ppIntDomainInfo);

    hr = HrGetInternalInfo(ppIntDomainInfo);
    if (FAILED(hr))
    {
        goto Exit;
    }
    else if (!*ppIntDomainInfo)
    {
        //If HrGetInternalInfoFails the first time, it will return NULL
        //subsequent times.  Make sure we do not return success and a
        //NULL pointer.  When this happens, the link will go into retry
        hr = E_FAIL;
        goto Exit;
    }

    *pcbSMTPDomain = m_cbSMTPDomain;
    *pszSMTPDomain = m_szSMTPDomain;

  Exit:
    return hr;
}


//---[ CLinkMsgQueue::HrGetSMTPDomain ]----------------------------------------
//
//
//  Description:
//      Returns the SMTP Domain for this link.
//  Parameters:
//      OUT pcbSMTPDomain   String length of returned domain
//      OUT pszSMTPDomain   Returned SMTP Domain string.  The Link will manager
//                          The memory for this, and will remain valid as long
//                          as the link is in existance.
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetSMTPDomain(OUT DWORD *pcbSMTPDomain,
                                       OUT LPSTR *pszSMTPDomain)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetSMTPDomain");
    HRESULT hr = S_OK;
    _ASSERT(pcbSMTPDomain);
    _ASSERT(pszSMTPDomain);

    if (m_dwLinkFlags & eLinkFlagsInvalid)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }


    *pcbSMTPDomain = m_cbSMTPDomain;
    *pszSMTPDomain = m_szSMTPDomain;

    if (NULL == m_szSMTPDomain)
    {
        hr = AQUEUE_E_LINK_INVALID;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrAddQueue ]---------------------------------------------
//
//
//  Description:
//      Add DestMsgQueues to the link.
//  Parameters:
//
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocate space to store queue
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrAddQueue(IN CDestMsgQueue *pdmqNew)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrAddQueue");
    HRESULT hr  = S_OK;
    DWORD   dwIndex = 0;
    CDestMsgQueue *pdmqOld = NULL;
    PVOID   pvContext = NULL;

    //If we are adding a queue... this should not be set
    _ASSERT(!(LINK_STATE_LINK_NO_LONGER_USED & m_dwLinkStateFlags));

    m_slQueues.ExclusiveLock();

    //
    //  Clear the marked as empty bit (if set)
    //
    dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsMarkedAsEmpty);

    _ASSERT(pdmqNew);

#ifdef DEBUG
    // We have seen cases where it looks like a DMQ has been added to a link
    // multiple times (via this call).  We need to make assert that this
    // is not the case here.
    for (dwIndex = 0; dwIndex < m_cQueues; dwIndex++)
    {
        pdmqOld = (CDestMsgQueue *) m_qlstQueues.pvGetItem(dwIndex, &pvContext);

        //If these match, it means that someone is adding this queue twice...
        if (pdmqOld == pdmqNew)
        {
            _ASSERT(0 && "Adding queue twice to link... get mikeswa");
        }
    }
#endif //DEBUG

    dwIndex = 0;
    pdmqOld = NULL;
    pvContext = NULL;
    pdmqNew->AddRef();
    hr =  m_qlstQueues.HrAppendItem(pdmqNew, &dwIndex);

    if (FAILED(hr))
        goto Exit;

    //Set DMQ's link context to index inserted in quick list
    pdmqNew->SetLinkContext(ULongToPtr(dwIndex));
    m_cQueues++;

  Exit:
    m_slQueues.ExclusiveUnlock();

    //Now that the first queue has been added, this can be deleted if empty
    dwModifyLinkState(LINK_STATE_NO_ACTION,
                      LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY);
    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::RemoveQueue ]--------------------------------------------
//
//
//  Description:
//      Removes a given queue from the link.  Queue *must* be associated with
//      link (this will be asserted).
//  Parameters:
//      IN  pdmq        DMQ to remove from link
//      IN  paqstats    Stats associated with DMQ
//  Returns:
//      -
//  History:
//      9/14/98 - MikeSwa Created
//      5/14/99 - MikeSwa Removed code to automatically remove link
//                from DMT if there are no queues.  This is now done in
//                CLinkMsgQueue::RemoveLinkIfEmpty
//      8/10/99 - MikeSwa added check of pdmqOther.  While operartions on
//                the quick list are thread safe, there is nothing procting us
//                from another thread calling RemoveQueue or RemoveAllQueues
//                before we get the lock.  If this is the case, then we have
//                the change to double-decrement m_cQueues, which could lead to
//                an AV in GetNextMessage
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveQueue(IN CDestMsgQueue *pdmq, IN CAQStats *paqstats)
{
    TraceFunctEnterEx((LPARAM) this, "RemoveQueue");
    _ASSERT(pdmq);
    CDestMsgQueue *pdmqOther = NULL;
    CDestMsgQueue *pdmqCheck = NULL;
    PVOID   pvContext = NULL;
    DWORD   dwIndex = 0;
    BOOL    fFoundQueue = FALSE;

    //Aquire exclusive lock and remove DMQ from list
    m_slQueues.ExclusiveLock();

    //While the follow line *may* produce a sundown warning is is 100% correct
    //The context is created and "owned" by this object.  Currently it is an
    //array index, but eventually it may be a pointer to more interesting context
    //structure.
    dwIndex = (DWORD) (DWORD_PTR)pdmq->pvGetLinkContext();

    pdmqOther = (CDestMsgQueue *) m_qlstQueues.pvGetItem(dwIndex, &pvContext);
    if (pdmqOther && (pdmqOther == pdmq))
    {
        fFoundQueue = TRUE;

        //Now that we found it... remove it from the link
        pdmqCheck = (CDestMsgQueue *) m_qlstQueues.pvDeleteItem(dwIndex, &pvContext);
        m_cQueues--;

        //The link context should be the index of the DMQ
        _ASSERT(pdmqCheck == pdmqOther);

        //Get new item at old index & update context
        pdmqOther = (CDestMsgQueue *) m_qlstQueues.pvGetItem(dwIndex, &pvContext);

        //If pdmqOther is NULL, then we have no more queues
        //(or it was the last in the list)
        _ASSERT(pdmqOther || !m_cQueues || (dwIndex == m_cQueues));

        //Update change in stats
        m_aqstats.UpdateStats(paqstats, FALSE);

        if (m_cQueues)
        {
            if (pdmqOther)
                pdmqOther->SetLinkContext(ULongToPtr(dwIndex));
        }
    }
    else
    {
        //While not technically an error, this means that another thread has removed
        //this (or all) queues, and it is not in the link
        ErrorTrace((LPARAM) this,
            "Found Queue 0x%0X instead of 0x%08X at index %d",
            (DWORD_PTR) pdmqOther, (DWORD_PTR) pdmq, dwIndex);
    }

    m_slQueues.ExclusiveUnlock();

    //Release reference to DMQ
    if (fFoundQueue)
        pdmq->Release();

    TraceFunctLeave();
}


//---[ CLinkMsgQueue::RemoveLinkIfEmpty ]--------------------------------------
//
//
//  Description:
//      Removes a link from the DomainEntry if it is empty.  This behavior
//      used to be part of RemoveQueue, but was removed because it could
//      lead to a link being removed from the DMT hash table, but still
//      creating connections.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/14/99 - MikeSwa Created (as potential Windows2000 Beta3 QFE fix)
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveLinkIfEmpty()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::RemoveLinkIfEmpty");
    DWORD dwLinkFlags = 0;
    DWORD dwRoutingInterestedFlags = LINK_STATE_CONNECT_IF_NO_MSGS |
                                     LINK_STATE_DO_NOT_DELETE |
                                     LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY |
                                     LINK_STATE_ADMIN_HALT |
                                     LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY;

    //Bail early if we know we don't need to grab the lock
    if (m_cQueues || !m_pdentryLink)
        return;

    if (m_slQueues.TryExclusiveLock())
    {
        if (!m_cQueues &&
            !(dwRoutingInterestedFlags & m_dwLinkStateFlags))
        {
            //It might be prudent to to delete this link if:
            // - There are no messages
            // - Routing has not shown a interest in this queue
            // - This link has also expired


            //
            //  Mark link as empty
            //
            dwLinkFlags = dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsMarkedAsEmpty);

            //
            //  If we set the flag, then set the expire timer.  Otherwise remove
            //  the link.
            //
            if (!(eLinkFlagsMarkedAsEmpty & dwLinkFlags))
            {
                m_paqinst->GetExpireTime(EMPTY_LMQ_EXPIRE_TIME_MINUTES,
                                        &m_ftEmptyExpireTime, NULL);
            }
            else if (m_paqinst->fInPast(&m_ftEmptyExpireTime, NULL))
            {
                if (m_pdentryLink)
                {
                    DebugTrace((LPARAM) this,
                               "Removing empty link %s with flags 0x%08X",
                               (m_szSMTPDomain ? m_szSMTPDomain : "(NULL)"),
                               m_dwLinkStateFlags);
                    m_pdentryLink->RemoveLinkMsgQueue(this);
                    m_pdentryLink->Release();
                    m_pdentryLink = NULL;
                }

                //We need to artificially increase the connection manager count
                //so it will not be enqueue'd in the connmgr again
                IncrementConnMgrCount();
            }
        }

        m_slQueues.ExclusiveUnlock();
    }
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetNextMsg ]-------------------------------------------
//
//
//  Description:
//      Gets the next message from the queue
//  Parameters:
//      IN OUT CDeliveryContext *pdcntxt - delivery context for connection
//      OUT IMailMsgProperties **ppIMailMsgProperties  - IMsg dequeued
//      OUT DWORD *pcIndexes          - size of array
//      OUT DWORD **prgdwRecipIndex   - Array of recipient indexes
//  Returns:
//      S_OK on success
//      E_INVALIDARG if invalid parameters are given
//
//  History:
//      6/17/98 - MikeSwa Modified to use connection's delivery context
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetNextMsg(IN OUT CDeliveryContext *pdcntxt,
                OUT IMailMsgProperties **ppIMailMsgProperties,
                OUT DWORD *pcIndexes, OUT DWORD **prgdwRecipIndex)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetNextMsg");
    Assert(ppIMailMsgProperties);
    Assert(pdcntxt);
    Assert(prgdwRecipIndex);
    Assert(pcIndexes);

    HRESULT           hr         = S_OK;
    CMsgRef          *pmsgref    = NULL;
    CMsgBitMap       *pmbmap     = NULL;
    DWORD             cDomains   = 0;
    BOOL              fLockedShutdown = FALSE;
    BOOL              fLockedQueues = FALSE;
    DWORD             iQueues    = 0;
    DWORD             dwCurrentRoundRobinIndex = m_dwRoundRobinIndex;
    CDestMsgQueue     *pdmq = NULL;
    CDestMsgRetryQueue *pdmrq = NULL;
    PVOID             pvContext = NULL;
    BOOL              fDoneWithQueue = FALSE;

    if (m_dwLinkFlags & eLinkFlagsInvalid)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }

    //Don't even bother to wait for queue lock if routing change is pending
    if (m_dwLinkFlags & eLinkFlagsRouteChangePending)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    //Make sure domain info is updated & we should still be sending messages
    //If we can't schedule... we still might be allowed to send messages because
    //of TURN.
    if (!fCanSchedule() && !(m_dwLinkStateFlags & LINK_STATE_PRIV_TURN_ENABLED))
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }


    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    m_paqinst->RoutingShareLock();
    fLockedShutdown = TRUE;

    m_slQueues.ShareLock();
    fLockedQueues = TRUE;

    if (m_cQueues == 0)
    {
        //There are currently no queue associated with this link
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    //$$TODO impose some ordering on these queues
    for (iQueues = 0; iQueues < m_cQueues && SUCCEEDED(hr) && !pmsgref; iQueues++)
    {
        pmsgref = NULL;
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(
                        (iQueues+dwCurrentRoundRobinIndex)%m_cQueues, &pvContext);

        _ASSERT(pdmq);
        pdmq->AssertSignature();


        //Loop until the queue is empty or we get a message that hasn't
        //already been delivered by another queue on this link
        do
        {
            //Usually, we only want to attempt to dequeue from a queue once.
            fDoneWithQueue = TRUE;

            //Release retry interface if we have one
            if (pdmrq)
            {
                pdmrq->Release();
                pdmrq = NULL;
            }

            //get msg reference
            hr = pdmq->HrDequeueMsg(&pmsgref, &pdmrq);
            if (FAILED(hr))
            {

                if (AQUEUE_E_QUEUE_EMPTY == hr)
                {
                    hr = S_OK;
                    continue;  //get message from next queue
                }
                else
                {
                    goto Exit;
                }
            }

            //prepare for delivery and generate delivery context
            hr = pmsgref->HrPrepareDelivery(FALSE /*remote only */,
                                            FALSE /*not a Delay DSN */,
                                            &m_qlstQueues, pdmrq,
                                            pdcntxt, pcIndexes, prgdwRecipIndex);

            if (AQUEUE_E_MESSAGE_HANDLED == hr)
            {
                //the message has already been handled for this queue
                pmsgref->Release();
                pmsgref = NULL;
                hr = S_OK;

                //We want to stay on this queue until it is empty
                fDoneWithQueue = FALSE;
            }
            else if ((AQUEUE_E_MESSAGE_PENDING == hr) ||
                    ((FAILED(hr)) && pmsgref->fShouldRetry()))
            {
                //AQUEUE_E_MESSAGE_PENDING means that the message
                //is currently pending delivery for another connection
                //on this link.  We will requeue it, and remove only after it
                //has been completly delivered for this link
                hr = pdmrq->HrRetryMsg(pmsgref);
                if (FAILED(hr))
                    pmsgref->RetryOnDelete();

                pmsgref->Release();
                pmsgref = NULL;
                hr = S_OK;

                //We want to stay on this queue until it is empty
                fDoneWithQueue = FALSE;
            }
            else if (FAILED(hr))
            {
                //The message has been deleted out from underneath us
                pmsgref->Release();
                pmsgref = NULL;
                hr = S_OK;

                //We want to stay on this queue until it is empty
                fDoneWithQueue = FALSE;
            }
        } while (!fDoneWithQueue);

    }

    //Visit a new queue on every GetNextMsg
    InterlockedIncrement((PLONG) &m_dwRoundRobinIndex);

    if (pmsgref && SUCCEEDED(hr)) //we got a message
    {
        *ppIMailMsgProperties = pmsgref->pimsgGetIMsg();
        pmsgref = NULL;
    }
    else //We have failed or do not have a message
    {
        *ppIMailMsgProperties = NULL;
        if (SUCCEEDED(hr)) //don't overwrite other error
            hr = AQUEUE_E_QUEUE_EMPTY;
        else
            ErrorTrace((LPARAM) this, "GetNextMsg returning hr - 0x%08X", hr);
    }

  Exit:

    if (pdmrq)
        pdmrq->Release();

    if (NULL != pmsgref)
        pmsgref->Release();

    if (fLockedQueues)
        m_slQueues.ShareUnlock();

    if (fLockedShutdown)
    {
        m_paqinst->RoutingShareUnlock();
        m_paqinst->ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrAckMsg ]-------------------------------------------------
//
//
//  Description:
//      Acknowledges the delivery of a message (success/error codes are put in
//      the envelope by the transport).
//
//  Parameters:
//      IN pIMsg        IMsg to acknowledge
//      IN dwMsgContext Context that was returned by GetNextMessage
//      IN eMsgStatus   Summary of Delivery status of message
//      IN dwStatusCode Status code returned by protocol
//      IN cbExtendedStatus Size of extended status buffer
//      IN szExtendedStatus String containing extended status returned by
//                      remote server
//  Returns:
//      S_OK on success
//      E_INVALIDARG if dwMsgContext is invalid
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrAckMsg(MessageAck *pMsgAck)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;
    _ASSERT(m_paqinst);

    if (NULL == pMsgAck->pvMsgContext)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (MESSAGE_STATUS_ALL_DELIVERED & pMsgAck->dwMsgStatus)
    {
        m_lConsecutiveMessageFailureCount = 0;
        if (!(m_dwLinkFlags & eLinkFlagsConnectionVerifed))
            dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsConnectionVerifed);
        if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & m_dwLinkStateFlags)
        {
            //We delivered successfully as TURN/ETRN... we need to update count
            m_paqinst->IncTURNETRNDelivered();
        }
    }

    hr = HrGetInternalInfo(&pIntDomainInfo);
    if (SUCCEEDED(hr) && pIntDomainInfo)
    {
        if (DOMAIN_INFO_LOCAL_DROP &
            pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags)
        {
            pMsgAck->dwMsgStatus |= MESSAGE_STATUS_DROP_DIRECTORY;
        }
        pIntDomainInfo->Release();
    }
    hr = m_paqinst->HrAckMsg(pMsgAck);

  Exit:
    return hr;
}

//---[  CLinkMsgQueue::HrNotify ]----------------------------------------------
//
//
//  Description:
//      Recieve notification from one of our DestMsgQueues.
//  Parameters:
//      IN  paqstats    Notification object sent
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrNotify(IN CAQStats *paqstats, BOOL fAdd)
{
    HRESULT hr = S_OK;
    DWORD   dwTmp = 0;
    DWORD   dwNotifyType = 0;
    BOOL    fCheckIfNotifyShouldContinue = FALSE;
    _ASSERT(paqstats);

    //Update our own version of stats
    m_aqstats.UpdateStats(paqstats, fAdd);

    //Don't notify if we're configured not to
    if (LINK_STATE_PRIV_NO_NOTIFY & m_dwLinkStateFlags)
        return hr;

    //See if new message update
    if (paqstats->m_dwNotifyType & NotifyTypeDestMsgQueue)
    {
        //$$NOTE:
        //At some point it may be interesting to use the information passed by the
        //DMQ to adjust it's place in the queue (ie. priority).  Currently, we
        //don't care.
        fCheckIfNotifyShouldContinue = TRUE;
    }

    //
    //  If this is a reroute... this may be a new link (with no messages), we
    //  should make sure we add it to the connection manager.
    //
    if (paqstats->m_dwNotifyType & NotifyTypeReroute)
        fCheckIfNotifyShouldContinue = TRUE;

    if (fCheckIfNotifyShouldContinue && fAdd)
    {
        //Wait until we have messages or are rerouting before sending a
        //notification that might add this link to the connection manager
        if ((m_aqstats.m_cMsgs ||
             (paqstats->m_dwNotifyType & NotifyTypeReroute)) &&
           !(eLinkFlagsSentNewNotification & m_dwLinkFlags))
        {

            //Attempt to set first notification flag
            dwTmp = m_dwLinkFlags; //if already set before while, make sure IF fails
            while (!(eLinkFlagsSentNewNotification & m_dwLinkFlags))
            {
                dwTmp = m_dwLinkFlags;
                dwTmp = InterlockedCompareExchange((PLONG) &m_dwLinkFlags,
                    (LONG) (dwTmp | eLinkFlagsSentNewNotification),
                    (LONG) dwTmp);
            }
            if (!(dwTmp & eLinkFlagsSentNewNotification)) //this thread set it
            {

                // Set the type to notify new link so it will be added to
                // the connection manager
                dwNotifyType |= NotifyTypeNewLink;
            }
        }

    }

    if (fAdd) //only send notifcation on when we are adding a new message
    {
        //If we are adding messages... this should not be set
        _ASSERT(!(LINK_STATE_LINK_NO_LONGER_USED & m_dwLinkStateFlags));

        //Change into link notification
        //Connection manager needs to know, in case this link deserves another
        //connection
        paqstats->m_dwNotifyType = dwNotifyType | NotifyTypeLinkMsgQueue;
        paqstats->m_plmq = this;
        hr = m_paqinst->HrNotify(paqstats, fAdd);
    }

    return hr;
}

//---[ CLinkMsgQueue::dwModifyLinkState ]--------------------------------------
//
//
//  Description:
//      Sets and unsets state flags for this link
//  Parameters:
//      IN  dwLinkStateToSet    Combination of flags to set
//      IN  dwLinkStateToUnset  Combination of flags to unset
//
//      NOTE: dwLinkStateToSet and dwLinkStateToUnset should not overlap
//  Returns:
//      Original state of links
//  History:
//      9/22/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD  CLinkMsgQueue::dwModifyLinkState(IN DWORD dwLinkStateToSet,
                                        IN DWORD dwLinkStateToUnset)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::dwModifyLinkState");
    DWORD   dwOrigState = m_dwLinkStateFlags;
    DWORD   dwIntermState = m_dwLinkStateFlags;
    DWORD   dwSetBits = dwLinkStateToSet & ~dwLinkStateToUnset;
    DWORD   dwUnsetBits = dwLinkStateToUnset & ~dwLinkStateToSet;

    //we shouldn't do this internally... lets make the operations cancel each other
    _ASSERT(!(dwLinkStateToSet & dwLinkStateToUnset));
    _ASSERT(dwSetBits == dwLinkStateToSet);
    _ASSERT(dwUnsetBits == dwLinkStateToUnset);

    //If info is being updated, we should let it set config-related bits
    m_slInfo.ShareLock();
    if (dwSetBits)
        dwOrigState = dwInterlockedSetBits(&m_dwLinkStateFlags, dwSetBits);

    if (dwUnsetBits)
        dwIntermState = dwInterlockedUnsetBits(&m_dwLinkStateFlags, dwUnsetBits);

    //Make sure we return the correct return value
    if (dwUnsetBits && !dwSetBits)
        dwOrigState = dwIntermState;

    m_slInfo.ShareUnlock();

    DebugTrace((LPARAM) this,
        "ModifyLinkState set:%08X unset:%08X orig:%08X new:%08X",
        dwLinkStateToSet, dwLinkStateToUnset, dwOrigState, m_dwLinkStateFlags);

    TraceFunctLeave();
    return dwOrigState;
}

//---[ CLinkMsgQueue::ScheduledCallback ]--------------------------------------
//
//
//  Description:
//      Callback function for scheduled connection callbacks
//  Parameters:
//      pvContext       this pointer for CLinkMsgQueue
//  Returns:
//      -
//  History:
//      1/16/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::ScheduledCallback(PVOID pvContext)
{
    CLinkMsgQueue  *plmq = (CLinkMsgQueue *) pvContext;
    HRESULT         hr = S_OK;
    IConnectionManager *pIConnectionManager = NULL;
    CConnMgr       *pConnMgr = NULL;
    DWORD           dwLinkState = 0;

    _ASSERT(plmq);
    _ASSERT(LINK_MSGQ_SIG == plmq->m_dwSignature);

    plmq->SendLinkStateNotification();
    dwLinkState = plmq->m_dwLinkStateFlags;


    //If connections are now allowed... we should kick the connection manager
    _ASSERT(plmq->m_paqinst);
    if (plmq->m_paqinst && plmq->fFlagsAllowConnection(dwLinkState))
    {
        hr = plmq->m_paqinst->HrGetIConnectionManager(&pIConnectionManager);
        if (SUCCEEDED(hr))
        {
            _ASSERT(pIConnectionManager);

            pConnMgr = (CConnMgr *) pIConnectionManager;
            if (pConnMgr)
                pConnMgr->KickConnections();
        }
    }

    //Release AddRef from callback
    plmq->Release();

}

//---[ CLinkMsgQueue::SendLinkStateNotification ]------------------------------
//
//
//  Description:
//      Sends notification if to scheduler/routing sink
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/11/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::SendLinkStateNotification()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::SendLinkStateNotification");
    HRESULT     hr              = S_OK;
    GUID        guidRouter      = GUID_NULL;
    DWORD       dwStateToSet    = LINK_STATE_NO_ACTION;
    DWORD       dwStateToUnset  = LINK_STATE_NO_ACTION;
    DWORD       dwResultingLinkState = LINK_STATE_NO_ACTION;
    DWORD       dwOriginalLinkState = LINK_STATE_NO_ACTION;
    DWORD       dwHiddenStateMask = ~(LINK_STATE_RESERVED |
                                      LINK_STATE_CONNECT_IF_NO_MSGS |
                                      LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY);
    FILETIME    ftNextAttempt;
    BOOL        fSendNotify = TRUE;
    DWORD       dwCurrentLinkState = m_dwLinkStateFlags;

    //
    // We should not send any notifications after we have notified routing
    // that we are going away.  We copy dwCurrentLinkState to a stack
    // variable so that this is thread safe.  If another thread sets
    // LINK_STATE_LINK_NO_LONGER_USED after this check, we will still pass
    // in the original value.
    //
    if (dwCurrentLinkState & LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED)
    {
        fSendNotify = FALSE;
    }
    else if (dwCurrentLinkState & LINK_STATE_LINK_NO_LONGER_USED)
    {
        //
        //  Try to be the first thread to set this.  If we are then we can
        //  continue with the notification
        //
        dwOriginalLinkState = dwModifyLinkState(LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED,
                                                LINK_STATE_NO_ACTION);
        if (dwOriginalLinkState & LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED)
            fSendNotify = FALSE;
    }


    if (m_pILinkStateNotify && fSendNotify)
    {
        ZeroMemory(&ftNextAttempt, sizeof(FILETIME));
        m_aqsched.GetGUID(&guidRouter);
        hr = m_pILinkStateNotify->LinkStateNotify(m_szSMTPDomain, guidRouter,
            m_aqsched.dwGetScheduleID(), m_szConnectorName,
            (dwHiddenStateMask & dwCurrentLinkState),
            (DWORD) m_lConsecutiveConnectionFailureCount, &ftNextAttempt,
            &dwStateToSet, &dwStateToUnset);

        DebugTrace((LPARAM) this,
            "LinkStateNotify set:0x%08X unset:0x%08X hr:0x%08x",
            dwStateToSet, dwStateToUnset, hr);
        //Modify link state only on success and when we aren't deleting it
        if (SUCCEEDED(hr) &&
            !(m_dwLinkStateFlags & LINK_STATE_LINK_NO_LONGER_USED))
        {
            // schedule a callback if one was requested
            if (ftNextAttempt.dwLowDateTime != 0 ||
                ftNextAttempt.dwHighDateTime != 0)
            {
                DebugTrace((LPARAM) this,
                    "Schedule with FileTime %x:%x provided",
                    ftNextAttempt.dwLowDateTime,
                    ftNextAttempt.dwHighDateTime);
                InternalUpdateFileTime(&m_ftNextScheduledCallback,
                                       &ftNextAttempt);
                //callback with next attempt
                AddRef(); //Addref self as context
                hr = m_paqinst->SetCallbackTime(
                        CLinkMsgQueue::ScheduledCallback,
                        this,
                        &ftNextAttempt);
                if (FAILED(hr))
                    Release(); //callback will not happen... release context
            }

            if (!(LINK_STATE_CONNECT_IF_NO_MSGS & dwStateToSet))
            {
                //Routing has not explicitly set LINK_STATE_CONNECT_IF_NO_MSGS.
                //We must unset it because we hid it from routing.  The reason
                //we do this is to allow Routers that are not interested in
                //link-lifetime managment to set LINK_STATE_CONNECT_IF_NO_MSGS
                //and not have to worry about race conditions that could
                //cause a link to be delted while they are requesting a ping
                dwStateToUnset  |= LINK_STATE_CONNECT_IF_NO_MSGS;
            }

            //
            //  If not explicitly set, this bit is reset.  Similar reasons
            //  as above.
            //
            if (!(LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY & dwStateToSet))
            {
                 dwStateToUnset |= LINK_STATE_DO_NOT_DELETE_UNTIL_NEXT_NOTIFY;
            }

            if (!(m_dwLinkStateFlags & LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION)) {
                dwStateToSet |= LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION;
            }

            if ((LINK_STATE_NO_ACTION != dwStateToSet) ||
                (LINK_STATE_NO_ACTION != dwStateToUnset))
            {

                dwModifyLinkState(dwStateToSet, dwStateToUnset);
            }
        }
    }
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::fShouldConnect ------------------------------------------
//
//
//  Description:
//      Function that is used to determine if a connection should be
//      made.
//      Uses a heursitic to decide if a connection should be made if multiple
//      queues are routed to this link.. and thus the message count may be
//      larger than it should be (since a message is counted once for each
//      DMQ it is on).
//  Parameters:
//      IN  cMaxLinkConnections         Maximum # of connections per link
//      IN  cMinMessagesPerConnection   Minimum # of messages per link before
//                                      creating an additional connection.
//  Returns:
//      TRUE    If a connection should be created
//      FALSE   Otherwise
//  History:
//      11/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fShouldConnect(IN DWORD cMaxLinkConnections,
                                   IN DWORD cMinMessagesPerConnection)
{
    BOOL    fConnect = FALSE;
    DWORD   cHeuristicMsgs = 0;
    DWORD   cHeuristicCheck = 0;
    DWORD   cCurrentMsgs = m_aqstats.m_cMsgs;
    DWORD   cTotalQueues = m_paqinst->cGetDestQueueCount();
    DWORD   cQueues = m_cQueues; //so it doesn't change on us

    //If we have more than 1 queue and there is a total of more than 1 queue
    //we can use a heurisitc to estimate actual # of messages to send, but
    //don't bother with Heuristic if we are already over our max # of
    //connections.
    if ((m_cConnections < cMaxLinkConnections) &&
        (1 < cTotalQueues) && (1 < cQueues) && cCurrentMsgs)
    {
        //m_aqstats.m_cOtherDomainsMsgSpread is the total # of *other* DMQs
        //a message is associated with (per DMQ).  If all of the DMQs for all
        //messages are on this link then:
        //      m_cOtherDomainsMsgSpread
        //is equal to:
        //      m_cMsgs*m_cMsgs*(cQueues-1).
        //The following function... uses a probabilistic estimate to
        //determine the number of messages that will be sent out this link.
        //Since we cannot always assume that all messages on this link were
        //queued to DMQ's assoicated with this link... we adjust the
        //counted value by a factor of:
        //      ((cQueues-1)/(cTotalQueues-1))
        //To determine the average # of domains per message (and hence the
        //# of times is it counted), we use:
        //  (m_cOtherDomainsMsgSpread+m_cMsgs)/m_cMsgs
        //To get a more accurate average, we modify the m_cOtherDomainsMsgSpread
        //by the probability factor above.
        //Finally:
        //To get our heuristic, we divide the number of msgs by the average
        //number of domains.
        cHeuristicCheck = cCurrentMsgs +
                          m_aqstats.m_cOtherDomainsMsgSpread *
                          ((cQueues-1)/(cTotalQueues-1));

        //This should be non-zero... but can happen if the counts are wrong and
        //m_aqstats.m_cOtherDomainsMsgSpread is negative
        _ASSERT(cHeuristicCheck);

        if (cHeuristicCheck) //but we might as well be defensive
        {
            cHeuristicMsgs = (cCurrentMsgs*cCurrentMsgs)/cHeuristicCheck;
            //Don't let the heuristic make us think there are no msgs to deliver
            if (!cHeuristicMsgs && cCurrentMsgs)
                cHeuristicMsgs = cCurrentMsgs;
        }
        else
        {
            cHeuristicMsgs = cCurrentMsgs;
        }


    }
    else
    {
        cHeuristicMsgs = cCurrentMsgs;
    }

    if ((m_cConnections < cMaxLinkConnections) &&
        (cHeuristicMsgs > m_cConnections*cMinMessagesPerConnection) &&
        fCanSchedule())
    {
        //If we have no had a successful message only open 1 connection
        if (!(m_dwLinkFlags & eLinkFlagsConnectionVerifed))
        {
            if (m_cConnections < 3)
                fConnect = TRUE;
        }
        else
            fConnect = TRUE;
    }
    else if (fCanSchedule() && !cHeuristicMsgs &&
             ((LINK_STATE_CONNECT_IF_NO_MSGS & m_dwLinkStateFlags) &&
             !m_cConnections))
    {
        //We want to create a connection to probe link state
        fConnect = TRUE;
    }
    return fConnect;
}

//---[ CLinkMsgQueue::HrCreateConnectionIfNeeded ]-----------------------------
//
//
//  Description:
//
//  Parameters:
//      IN  cMaxLinkConnections         Maximum # of connections per link
//      IN  cMinMessagesPerConnection   Minimum # of messages per link before
//                                      creating an additional connection.
//      IN  cMaxMessagesPerConnection   Max messages to send on a single
//                                      connection (0 is unlimited)
//      IN  pConnMgr                    Ptr to instance connection manger
//      OUT pSMTPConn                   New connection object for this link
//  Returns:
//      S_OK on success if connection is needed
//      S_FALSE on success if connection is not needed
//      E_OUTOFMEMORY if connection object could not be created
//  History:
//      11/5/98 - MikeSwa Created
//      12/7/1999 - MikeSwa Updated to make sure linkstate notify happens first
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrCreateConnectionIfNeeded(
                                       IN  DWORD cMaxLinkConnections,
                                       IN  DWORD cMinMessagesPerConnection,
                                       IN  DWORD cMaxMessagesPerConnection,
                                       IN  CConnMgr *pConnMgr,
                                       OUT CSMTPConn **ppSMTPConn)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrCreateConnectionIfNeeded");
    HRESULT hr = S_FALSE;
    _ASSERT(ppSMTPConn);
    *ppSMTPConn = NULL;
    CSMTPConn *pSMTPConn = NULL;

    //We cannot create a connection until we have done our link state
    //notification, because routing needs to have an opportunity to
    //set the schedule for a link
    SendLinkStateNotificationIfNew();

    //Should we create a connection?
    if (!fShouldConnect(cMaxLinkConnections, cMinMessagesPerConnection))
        goto Exit;

    //Try and be the thread that can create a connection
    if (((DWORD) InterlockedIncrement((PLONG) &m_cConnections)) > cMaxLinkConnections)
    {
        InterlockedDecrement((PLONG) &m_cConnections);
        goto Exit;
    }

    *ppSMTPConn = new CSMTPConn(pConnMgr, this, cMaxMessagesPerConnection);

    if (!*ppSMTPConn)
    {
        InterlockedDecrement((PLONG) &m_cConnections);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //Grab lock and insert into list
    m_slConnections.ExclusiveLock();
    (*ppSMTPConn)->InsertConnectionInList(&m_liConnections);
    m_slConnections.ExclusiveUnlock();

  Exit:

    //Make sure our return result is correct.
    if (SUCCEEDED(hr))
    {
        if (*ppSMTPConn)
        {
            DebugTrace((LPARAM) this,
                "Creating connection - linkstate:0x%08X",
                m_dwLinkStateFlags);
            hr = S_OK;
        }
        else
        {
            DebugTrace((LPARAM) this,
                "Not creating connection - linkstate 0x%08X",
                m_dwLinkStateFlags);
            hr = S_FALSE;
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::RemoveAllQueues ]----------------------------------------
//
//
//  Description:
//      Removes all queues from a link, without deleting or invalidating a
//      link.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::RemoveAllQueues()
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::RemoveAllQueues");
    PVOID   pvContext = NULL;
    CDestMsgQueue *pdmq = NULL;

    //Walk list of queues and release them
    dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsRouteChangePending);
    m_slQueues.ExclusiveLock();
    pdmq = (CDestMsgQueue *) m_qlstQueues.pvDeleteItem(0, &pvContext);
    while (pdmq)
    {
        m_cQueues--;
        pdmq->AssertSignature();
        pdmq->RemoveDMQFromLink(FALSE);
        pdmq->Release();
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvDeleteItem(0, &pvContext);
    }
    m_aqstats.Reset();
    dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsRouteChangePending);
    m_slQueues.ExclusiveUnlock();

    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetLinkInfo ]------------------------------------------
//
//
//  Description:
//      Fills in the details for a LINK_INFO struct.  RPC is resonsible for
//      freeing memory.
//  Parameters:
//      IN OUT pliLinkInfo  Ptr to link info struct to fill
//  Returns:
//      S_OK if successful
//      E_OUTOFMEMORY if unable to allocate memory
//  History:
//      12/3/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to be IQueueAdminLink method
//      6/10/99 - MikeSwa Modified to support new QueueAdmin functionality
//      7/1/99 - MikeSwa Added LinkDiagnostic
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrGetLinkInfo(LINK_INFO *pliLinkInfo,
                                          HRESULT   *phrLinkDiagnostic)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetLinkInfo");
    pliLinkInfo->cMessages = m_aqstats.m_cMsgs;
    pliLinkInfo->fStateFlags = 0;
    FILETIME ftCurrent;
    FILETIME ftOldest;
    FILETIME *pftNextConnection = NULL;
    BOOL     fFoundOldest = FALSE;
    DWORD    iQueues = 0;
    PVOID    pvContext = NULL;
    CDestMsgQueue *pdmq = NULL;
    HRESULT  hr = S_OK;

    //
    //Determine the state... check in order of most to least important
    //
    if (GetLinkType() == LI_TYPE_CURRENTLY_UNREACHABLE)
        pliLinkInfo->fStateFlags = LI_READY;
    else if (LINK_STATE_ADMIN_HALT & m_dwLinkStateFlags)
        pliLinkInfo->fStateFlags = LI_FROZEN;
    else if (m_cConnections)
        pliLinkInfo->fStateFlags = LI_ACTIVE;
    else if (!(LINK_STATE_RETRY_ENABLED & m_dwLinkStateFlags))
        pliLinkInfo->fStateFlags = LI_RETRY;
    else if (!(LINK_STATE_SCHED_ENABLED & m_dwLinkStateFlags))
        pliLinkInfo->fStateFlags = LI_SCHEDULED;
    else if (m_lConsecutiveConnectionFailureCount)
        pliLinkInfo->fStateFlags = LI_RETRY;
    else if (LINK_STATE_PRIV_CONFIG_TURN_ETRN & m_dwLinkStateFlags)
        pliLinkInfo->fStateFlags = LI_REMOTE;
    else //default to ready
        pliLinkInfo->fStateFlags = LI_READY;

    pliLinkInfo->fStateFlags |= GetLinkType();

    //Write diagnostic
    if (phrLinkDiagnostic)
        *phrLinkDiagnostic = m_hrDiagnosticError;

    //Get Size
    pliLinkInfo->cbLinkVolume.QuadPart = m_aqstats.m_uliVolume.QuadPart;

    //Find stOldestMessage
    m_slQueues.ShareLock();
    for (iQueues = 0;iQueues < m_cQueues; iQueues++)
    {
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);

        if (!pdmq) continue;

        pdmq->GetOldestMsg(&ftCurrent);
        //
        //  If we got a valid time, and it is earlier than the time we have
        //  now, then use it as the oldest for the link
        //
        if ((ftCurrent.dwLowDateTime || ftCurrent.dwHighDateTime) &&
            (!fFoundOldest || (0 < CompareFileTime(&ftOldest, &ftCurrent))))
        {
            memcpy(&ftOldest, &ftCurrent, sizeof(FILETIME));
            fFoundOldest = TRUE;
        }

        //  Also count the failed messages (they're counted separately in the DMQ)
        pliLinkInfo->cMessages += pdmq->cGetFailedMsgs();
    }
    m_slQueues.ShareUnlock();


    //If we have not found an oldest, and the time is non-zero
    //and we have messages, then report it.
    if (fFoundOldest &&
       (ftOldest.dwLowDateTime || ftOldest.dwHighDateTime) &&
       pliLinkInfo->cMessages)
    {
        FileTimeToSystemTime(&ftOldest, &pliLinkInfo->stOldestMessage);
    }
    else
    {
        ZeroMemory(&pliLinkInfo->stOldestMessage, sizeof(SYSTEMTIME));
    }

    //
    //  Get next connection attempt time based on the state we are reporting
    //
    if (LI_RETRY & pliLinkInfo->fStateFlags)
    {
        pftNextConnection = &m_ftNextRetry;
    }
    else if (LI_SCHEDULED & pliLinkInfo->fStateFlags)
    {
        pftNextConnection = &m_ftNextScheduledCallback;
    }

    //
    //  If we are reporting a time, and it is non-zero, convert it to
    //  a system time.
    //
    if (pftNextConnection &&
        (pftNextConnection->dwHighDateTime || pftNextConnection->dwLowDateTime))
    {
        FileTimeToSystemTime(pftNextConnection,
                             &pliLinkInfo->stNextScheduledConnection);
        if (LI_SCHEDULED & pliLinkInfo->fStateFlags)
        {
            //
            //  Currently times are displayed at :02, :17, :32:, and :47... we will
            //  fudge the display time to that it actually says :00, :15, :30, :45
            //  to give the admin a better "admin experience" by rouding off to
            //  the nearest 5 minutes.
            //
            pliLinkInfo->stNextScheduledConnection.wMinute -=
                (pliLinkInfo->stNextScheduledConnection.wMinute % 5);
        }
    }
    else
    {
        //
        //  In this case, we don't have a time.
        //
        ZeroMemory(&pliLinkInfo->stNextScheduledConnection, sizeof(SYSTEMTIME));
    }

    if (m_szConnectorName)
    {
        pliLinkInfo->szLinkDN = wszQueueAdminConvertToUnicode(m_szConnectorName, 0);
        if (!pliLinkInfo->szLinkDN)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else
    {
        pliLinkInfo->szLinkDN = NULL;
    }

    //$$TODO - Fill in pliLinkInfo->szExtendedStateInfo as appropriate
    pliLinkInfo->szExtendedStateInfo = NULL;

    if (!fRPCCopyName(&pliLinkInfo->szLinkName))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pliLinkInfo->dwSupportedLinkActions = m_dwSupportedActions;

  Exit:
    if (FAILED(hr))
    {
        //Cleanup allocated memory
        if (pliLinkInfo->szLinkDN)
        {
            QueueAdminFree(pliLinkInfo->szLinkDN);
            pliLinkInfo->szLinkDN = NULL;
        }

        if (pliLinkInfo->szLinkName)
        {
            QueueAdminFree(pliLinkInfo->szLinkName);
            pliLinkInfo->szLinkName = NULL;
        }

        if (pliLinkInfo->szExtendedStateInfo)
        {
            QueueAdminFree(pliLinkInfo->szExtendedStateInfo);
            pliLinkInfo->szExtendedStateInfo = NULL;
        }
    }

    //
    // Sanity checks to make sure we aren't passing back a zero'd
    // FILETIME converted to a system time (which would have a
    // year of 1601).
    //
    _ASSERT(1601 != pliLinkInfo->stNextScheduledConnection.wYear);
    _ASSERT(1601 != pliLinkInfo->stOldestMessage.wYear);

    TraceFunctLeave();
    return hr;
}

//---[ CLinkMsgQueue::HrGetLinkID ]---------------------------------------------
//
//
//  Description:
//      Fills in the QUEUELINK_ID structure for this link.  Caller must free
//      memory allocated for link name
//  Parameters:
//      IN OUT  pLinkID     Ptr to link id struct to fill in
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if memory allocation fails
//  History:
//      12/3/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to IQueueAdminLink method
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetLinkID(QUEUELINK_ID *pLinkID)
{
    pLinkID->qltType = QLT_LINK;
    pLinkID->dwId = m_aqsched.dwGetScheduleID();
    m_aqsched.GetGUID(&pLinkID->uuid);

    if (!fRPCCopyName(&pLinkID->szName))
        return E_OUTOFMEMORY;
    else
        return S_OK;
}

//---[ CLinkMsgQueue::HrGetQueueIDs ]--------------------------------------------
//
//
//  Description:
//      Gets the Queue IDs for DMQs associated with this link.  Used by Queue
//      Admin.
//  Parameters:
//      IN OUT pcQueues     Sizeof array/ number of queues found
//      IN OUT rgQueues     Array to dump queue info into
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY on out of memory failure
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if array is too small
//  History:
//      12/3/98 - MikeSwa Created
//      2/22/99 - MikeSwa Updated to IQueueAdminLink function
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrGetQueueIDs(DWORD *pcQueues, QUEUELINK_ID *rgQueues)
{
    _ASSERT(pcQueues);
    _ASSERT(rgQueues);
    HRESULT hr = S_OK;
    DWORD   iQueues = 0;
    PVOID   pvContext = NULL;
    CDestMsgQueue *pdmq = NULL;
    QUEUELINK_ID *pCurrentQueueID = rgQueues;

    m_slQueues.ShareLock();

    if (*pcQueues < m_cQueues)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *pcQueues = 0;

    //Iterate over all queues and get IDs
    for (iQueues = 0; iQueues < m_cQueues && SUCCEEDED(hr); iQueues++)
    {
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvContext);

        _ASSERT(pdmq);
        hr = pdmq->HrGetQueueID(pCurrentQueueID);
        if (FAILED(hr))
            goto Exit;

        pCurrentQueueID++;
        (*pcQueues)++;
    }


  Exit:
    m_slQueues.ShareUnlock();
    return hr;
}


//---[ CLinkMsgQueue::HrApplyQueueAdminFunction ]------------------------------
//
//
//  Description:
//      Used by queue admin to apply a function all queues on this link
//  Parameters:
//      IN  pIQueueAdminMessageFilter
//  Returns:
//      S_OK on success
//  History:
//      12/11/98 - MikeSwa Created
//      2/22/99 - MikeSwa Modified to IQueueAdminAction interface
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrApplyQueueAdminFunction(
                          IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
{
    HRESULT hr = S_OK;
    DWORD   iQueues = 0;
    PVOID   pvListContext = NULL;
    CDestMsgQueue *pdmq = NULL;
    IQueueAdminAction *pIQueueAdminAction = NULL;

    m_slQueues.ShareLock();

    //Iterate over all queues and get IDs
    for (iQueues = 0; iQueues < m_cQueues && SUCCEEDED(hr); iQueues++)
    {
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(iQueues, &pvListContext);

        _ASSERT(pdmq);

        hr = pdmq->QueryInterface(IID_IQueueAdminAction,
                                  (void **) &pIQueueAdminAction);
        if (FAILED(hr))
            goto Exit;

        _ASSERT(pIQueueAdminAction);

        hr = pIQueueAdminAction->HrApplyQueueAdminFunction(
                                        pIQueueAdminMessageFilter);
        if (FAILED(hr))
            goto Exit;
    }

  Exit:
    m_slQueues.ShareUnlock();

    if (pIQueueAdminAction)
        pIQueueAdminAction->Release();

    return hr;
}


//---[ CLinkMsgQueue::InternalUpdateFileTime ]---------------------------------
//
//
//  Description:
//      Updates an internal filetime in a thread safe manner.  This does not
//      guarantee that the filetime will be updated, but does guarantee that
//      if it is updated, the filetime is not corrupt.
//
//      NOTE: these file times are used only for display purposes by the
//      Queue Admin
//  Parameters:
//      pftDest     Ptr to member variable to update
//      pftSrc      Pft to source filetime
//  Returns:
//      -
//  History:
//      1/11/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::InternalUpdateFileTime(FILETIME *pftDest, FILETIME *pftSrc)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::InternalUpdateFileTime");
    if (pftDest && pftSrc)
    {
        DebugTrace((LPARAM) this,
                    "Updating filetime from %x:%x to %x:%x",
                    pftDest->dwLowDateTime, pftDest->dwHighDateTime,
                    pftSrc->dwLowDateTime, pftSrc->dwHighDateTime);

        if (!(eLinkFlagsFileTimeSpinLock &
              dwInterlockedSetBits(&m_dwLinkFlags, eLinkFlagsFileTimeSpinLock)))
        {
            //We got the spinlock
            memcpy(pftDest, pftSrc, sizeof(FILETIME));
            dwInterlockedUnsetBits(&m_dwLinkFlags, eLinkFlagsFileTimeSpinLock);
        }
    }
    TraceFunctLeave();
}

//---[ CLinkMsgQueue::HrGetNextMsgRef ]----------------------------------------
//
//
//  Description:
//      Returns the next MsgRef to be delivered without doing the
//      PrepareDelivery step.  This is used in gateway delivery to route the
//      message to the locally.  Additionally, this will mark all a the
//      gateway DMQ's as local on the msgref, so that a subsequent reroute
//      will only affect messages that have not already been put in the
//      local delivery queue.
//  Parameters:
//      IN      fRoutingLockHeld    TRUE is routing lock is already held
//      OUT     ppmsgref            Returned Msg
//  Returns:
//      S_OK on success
//      AQUEUE_E_QUEUE_EMPTY otherwise
//  History:
//      1/26/99 - MikeSwa Created
//      3/25/99 - MikeSwa Added fRoutingLockHeld to fix deadlock
//      2/17/2000 - MikeSwa Modified for gateway delivery reroute
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrGetNextMsgRef(IN  BOOL fRoutingLockHeld,
                                       OUT CMsgRef **ppmsgref)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkMsgQueue::HrGetNextMsg");
    _ASSERT(ppmsgref);

    HRESULT           hr         = S_OK;
    BOOL              fLockedShutdown = FALSE;
    BOOL              fLockedQueues = FALSE;
    DWORD             iQueues    = 0;
    DWORD             dwCurrentRoundRobinIndex = m_dwRoundRobinIndex;
    CDestMsgQueue     *pdmq = NULL;
    PVOID             pvContext = NULL;

    if (m_dwLinkFlags & eLinkFlagsInvalid)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }

    //Don't even bother to wait for queue lock if routing change is pending
    if ((m_dwLinkFlags & eLinkFlagsRouteChangePending) || !m_aqstats.m_cMsgs)
    {
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    //Make sure domain info is updated & we should still be sending messages
    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    //Current implementation of sharelocks are not share reentrant.  Only
    //grab lock if caller has not.
    if (!fRoutingLockHeld)
        m_paqinst->RoutingShareLock();

    fLockedShutdown = TRUE;

    m_slQueues.ShareLock();
    fLockedQueues = TRUE;

    if (m_cQueues == 0)
    {
        //There are currently no queue associated with this link
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    //$$TODO impose some ordering on these queues
    for (iQueues = 0;
         iQueues < m_cQueues && SUCCEEDED(hr) && !(*ppmsgref);
         iQueues++)
    {
        *ppmsgref = NULL;
        pdmq = (CDestMsgQueue *) m_qlstQueues.pvGetItem(
                        (iQueues+dwCurrentRoundRobinIndex)%m_cQueues, &pvContext);

        _ASSERT(pdmq);
        pdmq->AssertSignature();

        //get msg reference
        hr = pdmq->HrDequeueMsg(ppmsgref, NULL);
        if (FAILED(hr))
        {
            if (AQUEUE_E_QUEUE_EMPTY == hr)
                hr = S_OK;
            else
                goto Exit;
        }

        //
        //  Mark this as a local queue for this message
        //
        if (*ppmsgref)
            (*ppmsgref)->MarkQueueAsLocal(pdmq);
    }

    //Visit a new queue on every GetNextMsg
    InterlockedIncrement((PLONG) &m_dwRoundRobinIndex);

  Exit:

    if (fLockedQueues)
        m_slQueues.ShareUnlock();

    if (fLockedShutdown)
    {
        //If routing lock is not held by caller, then we must release it
        if (!fRoutingLockHeld)
            m_paqinst->RoutingShareUnlock();
        m_paqinst->ShutdownUnlock();
    }

    if (!*ppmsgref)
        hr = AQUEUE_E_QUEUE_EMPTY;

    TraceFunctLeave();
    return hr;
}


//---[ CLinkMsgQueue::HrPrepareDelivery ]--------------------------------------
//
//
//  Description:
//      Prepares delivery for a message for this link
//  Parameters:
//      IN      pmsgref     MsgRef to prepare for delivery
//      IN      fQueuesLock TRUE is m_slQueues is locked already
//      IN      fLocal      Prepare delivery for all domains with NULL queues
//      IN      fDelayDSN   Check/Set Delay bitmap (only send 1 Delay DSN).
//      IN      pqlstQueues QuickList of DMQ's
//      IN OUT  pdcntxt     context that must be returned on Ack
//      OUT     pcRecips    # of recips to deliver for
//      OUT     prgdwRecips Array of recipient indexes
//  Returns:
//      S_OK on success
//      Failure code from CMsgRef::HrPrepareDelivery
//  History:
//      1/26/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CLinkMsgQueue::HrInternalPrepareDelivery(
                                IN CMsgRef *pmsgref,
                                IN BOOL fQueuesLocked,
                                IN BOOL fLocal,
                                IN BOOL fDelayDSN,
                                IN OUT CDeliveryContext *pdcntxt,
                                OUT DWORD *pcRecips,
                                OUT DWORD **prgdwRecips)
{
    HRESULT hr = S_OK;
    BOOL    fQueuesLockedByUs = FALSE;

    _ASSERT(pmsgref);

    if (!pmsgref)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!fQueuesLocked)
    {
        m_slQueues.ShareLock();
        fQueuesLockedByUs = TRUE;
    }

    hr = pmsgref->HrPrepareDelivery(fLocal, fDelayDSN, &m_qlstQueues, NULL,
                                    pdcntxt, pcRecips, prgdwRecips);

    if (FAILED(hr))
        goto Exit;

  Exit:

    if (fQueuesLockedByUs)
        m_slQueues.ShareUnlock();

    return hr;

}

//---[ CLinkMsgQueue::SetDiagnosticInfo ]--------------------------------------
//
//
//  Description:
//      Sets the diagnostic information for this link
//  Parameters:
//      IN      hrDiagnosticError       Error code... if SUCCESS we thow away
//                                      the rest of the information
//      IN      szDiagnosticVerb        String pointing to the protocol
//                                      verb that caused the failure.
//      IN      szDiagnosticResponse    String that contains the remote
//                                      servers response.
//  Returns:
//      -
//  History:
//      2/18/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::SetDiagnosticInfo(
                    IN  HRESULT hrDiagnosticError,
                    IN  LPCSTR szDiagnosticVerb,
                    IN  LPCSTR szDiagnosticResponse)
{
    m_slInfo.ExclusiveLock();
    m_hrDiagnosticError = hrDiagnosticError;

    //zero original buffers
    ZeroMemory(&m_szDiagnosticVerb, sizeof(m_szDiagnosticVerb));
    ZeroMemory(&m_szDiagnosticResponse, sizeof(m_szDiagnosticResponse));

    //copy buffers
    if (szDiagnosticVerb)
        strncpy(m_szDiagnosticVerb, szDiagnosticVerb,
            sizeof(m_szDiagnosticVerb)-1);

    if (szDiagnosticResponse)
        strncpy(m_szDiagnosticResponse, szDiagnosticResponse,
            sizeof(m_szDiagnosticResponse)-1);

    m_slInfo.ExclusiveUnlock();
}

//---[ CLinkMsgQueue::GetDiagnosticInfo ]--------------------------------------
//
//
//  Description:
//      Gets the diagnostic information for this link
//  Parameters:
//      IN  LPSTR   szDiagnosticVerb    - buffer to receive the verb that
//                                        caused the error
//      IN  DWORD   cDiagnosticVerb     - length of the buffer
//      IN  LPSTR   szDiagnosticResponse- buffer to recieve the response
//                                        of the error
//      IN  DWORD   cbDiagnosticResponse- length of buffer
//      OUT HRESULT *phrDiagnosticError - HRESULT for error
//  Returns:
//      -
//  History:
//      3/9/99 - AWetmore Created
//      8/2/99 - Mikeswa...updated to use m_slInfo.
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::GetDiagnosticInfo(
                    IN  LPSTR   szDiagnosticVerb,
                    IN  DWORD   cbDiagnosticVerb,
                    IN  LPSTR   szDiagnosticResponse,
                    IN  DWORD   cbDiagnosticResponse,
                    OUT HRESULT *phrDiagnosticError)
{
    if (szDiagnosticVerb)
        ZeroMemory(szDiagnosticVerb, cbDiagnosticVerb);

    if (szDiagnosticResponse)
        ZeroMemory(szDiagnosticResponse, cbDiagnosticResponse);

    m_slInfo.ShareLock();
    if (phrDiagnosticError)
        *phrDiagnosticError = m_hrDiagnosticError;

    //copy buffers
    if (*m_szDiagnosticVerb && szDiagnosticVerb)
        strncpy(szDiagnosticVerb, m_szDiagnosticVerb, cbDiagnosticVerb);

    if (*m_szDiagnosticResponse && szDiagnosticResponse)
        strncpy(szDiagnosticResponse,
                m_szDiagnosticResponse,
                cbDiagnosticResponse);

    m_slInfo.ShareUnlock();
}

//---[ CLinkMsgQueue::HrApplyActionToMessage ]---------------------------------
//
//
//  Description:
//      Applies an action to this message for this queue.  This will be called
//      by the IQueueAdminMessageFilter during a queue enumeration function.
//
//      This code path is currently not executed... eventually me may consider
//      doing this to allow a DSN to be generated per link.
//
//      For this to be called.  CLinkMsgQueue::HrApplyActionToMessage would
//      need to iterate over the DMQ's queues with it's own IQueueAdminAction
//      iterface pointed to by the filter intead of the DMQ's.
//
//  Parameters:
//      IN  *pIUnknownMsg       ptr to message abstraction
//      IN  ma                  Message action to perform
//      IN  pvContext           Context set on IQueueAdminFilter
//      OUT pfShouldDelete      TRUE if the message should be deleted
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created
//      4/2/99 - MikeSwa Added context
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrApplyActionToMessage(
        IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
        BOOL *pfShouldDelete)
{
    _ASSERT(0 && "Not reachable");
    return E_NOTIMPL;
}

//---[ CLinkMsgQueue::HrApplyActionToLink ]------------------------------------
//
//
//  Description:
//      Applies the specified QueueAdmin action to this link
//  Parameters:
//      IN  la          Link action to apply
//  Returns:
//      S_OK on success
//      E_INVALIDARG if bogus action is given
//  History:
//      2/22/99 - MikeSwa Created (moved most of code from
//                          CAQSvrInst::SetLinkState)
//
//-----------------------------------------------------------------------------
STDMETHODIMP  CLinkMsgQueue::HrApplyActionToLink(LINK_ACTION la)
{
    DWORD   dwLinkFlagsToSet = LINK_STATE_NO_ACTION;
    DWORD   dwLinkFlagsToUnset = LINK_STATE_NO_ACTION;
    HRESULT hr = S_OK;

    //Is action supported?
    if (!fActionIsSupported(la))
        goto Exit;

    //figure out how we want to change the link state
    if (LA_KICK == la)
    {
        //kick the link
        dwLinkFlagsToSet = LINK_STATE_RETRY_ENABLED |
                           LINK_STATE_ADMIN_FORCE_CONN;
        dwLinkFlagsToUnset = LINK_STATE_ADMIN_HALT;
    }
    else if (LA_FREEZE == la)
    {
        //Admin wants this link to stop sending mail outbound
        dwLinkFlagsToSet = LINK_STATE_ADMIN_HALT;
        dwLinkFlagsToUnset = LINK_STATE_ADMIN_FORCE_CONN;
    }
    else if (LA_THAW == la)
    {
        //Unset frozen flags
        dwLinkFlagsToUnset = LINK_STATE_ADMIN_HALT;
    }
    else
    {
        //invalid arg
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwModifyLinkState(dwLinkFlagsToSet, dwLinkFlagsToUnset);

  Exit:
    return hr;

}

//---[ CLinkMsgQueue::QueryInterface ]-----------------------------------------
//
//
//  Description:
//      QueryInterface for CDestMsgQueue that supports:
//          - IQueueAdminAction
//          - IUnknown
//          - IQueueAdminLink
//  Parameters:
//
//  Returns:
//
//  History:
//      2/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminLink == riid)
    {
        *ppvObj = static_cast<IQueueAdminLink *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CLinkMsgQueue::HrGetNumQueues ]-----------------------------------------
//
//
//  Description:
//      Returns the number of queues on this link
//  Parameters:
//      OUT pcQueues        # numbr of queues
//  Returns:
//      S_OK on success
//      E_POINTER if pcQueues is not valid
//  History:
//      2/22/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CLinkMsgQueue::HrGetNumQueues(DWORD *pcQueues)
{
    HRESULT hr = S_OK;

    _ASSERT(pcQueues);
    if (!pcQueues)
    {
        hr = E_POINTER;
        goto Exit;
    }

    *pcQueues = cGetNumQueues();
  Exit:
    return hr;
}



//---[ CLinkMsgQueue::fMatchesID ]---------------------------------------------
//
//
//  Description:
//      Used to determine if this link matches a given scheduleID/link pair
//  Parameters:
//      IN  QueueLinkID         ID to match against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      2/23/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CLinkMsgQueue::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);
    _ASSERT(pQueueLinkID->szName);
    CAQScheduleID aqsched(pQueueLinkID->uuid, pQueueLinkID->dwId);

    if (!fIsSameScheduleID(&aqsched))
        return FALSE;

    if (!fBiStrcmpi(m_szSMTPDomain, pQueueLinkID->szName))
        return FALSE;

    //Everything matched!
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\mailadmq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: mailadmq.cpp
//
//  Description:  Implementation for CMailMsgAdminQueue
//
//  Author: Gautam Pulla (GPulla)
//
//  History:
//      6/24/1999 - GPulla Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "linkmsgq.h"
#include "mailadmq.h"
#include "asyncq.inl"

//-----------------------------------------------------------------------------
//  Description:
//      Used to query the admin interfaces for CMailMsgAdminQueue
//  Parameters:
//      IN  REFIID   riid    GUID for interface
//      OUT LPVOID   *ppvObj Ptr to Interface.
//
//  Returns:
//      S_OK            Interface supported by this class.
//      E_POINTER       NULL parameter.
//      E_NOINTERFACE   No such interface exists.
//  History:
//      6/25/1999 - GPulla Created
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminQueue::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminAction == riid)
    {
        *ppvObj = static_cast<IQueueAdminAction *>(this);
    }
    else if (IID_IQueueAdminLink == riid)
    {
        *ppvObj = static_cast<IQueueAdminLink *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CMailMsgAdminQueue::CMailMsgAdminQueue]---------------------------------
//
//
//  Description: 
//      Default constructor for CMailMsgAdminQueue
//  Parameters: 
//      IN  GUID  guidLink             GUID to associate with this object 
//      IN  LPSTR szQueueName          Name to associate with admin object
//      IN  CAsyncMailMsgQueue *pammq  Async MailMsg queue for precat or prerouting
//      IN  DWORD dwSupportedActions   OR'ed bitmask of supported LI_ACTIONs
//      IN  DWORD dwLinkType           Bit-Field identifying this admin object    
//  
//  Returns:
//      -
//  History:
//      6/25/1999 - GPulla Created 
//
//-----------------------------------------------------------------------------

CMailMsgAdminQueue::CMailMsgAdminQueue(
                                       GUID guid, 
                                       LPSTR szQueueName, 
                                       CAsyncMailMsgQueue *pammq,
                                       DWORD dwSupportedActions,
                                       DWORD dwLinkType
                                       )
                                            : m_aqsched(guid, 0)
{
    _ASSERT(pammq);
    _ASSERT(szQueueName);
    
    m_guid = guid;
    m_cbQueueName = lstrlen(szQueueName);

    m_szQueueName = (LPSTR) pvMalloc(m_cbQueueName+1);
    _ASSERT(m_szQueueName);

    if(m_szQueueName)
        lstrcpy(m_szQueueName, szQueueName);

    m_pammq = pammq;
    
    m_dwLinkType = dwLinkType;
    m_dwSupportedActions = dwSupportedActions;

    m_dwSignature = MAIL_MSG_ADMIN_QUEUE_VALID_SIGNATURE;
}

//---[CMailMsgAdminQueue::~CMailMsgAdminQueue]---------------------------------
//  Description:
//      Destructor.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------

CMailMsgAdminQueue::~CMailMsgAdminQueue()
{
    if (m_szQueueName)
        FreePv(m_szQueueName);
    m_dwSignature = MAIL_MSG_ADMIN_QUEUE_INVALID_SIGNATURE;
}

//---[CMailMsgAdminQueue::HrGetLinkInfo]---------------------------------------
//  Description:
//      Gets information about this admin object. Note that the diagnostic error
//      is not implemented for this object but the parameter is supported purely
//      to support the IQueueAction interface.
//  Parameters:
//      OUT LINK_INFO *pliLinkInfo Struct to fill information into.
//      OUT HRESULT   *phrDiagnosticError Diagnostic error if any, for this link
//  Returns:
//      S_OK on success
//      E_POINTER if argument is NULL
//      E_OUTOFMEMORY if unable to allocate memory for returning information.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------

STDMETHODIMP CMailMsgAdminQueue::HrGetLinkInfo(LINK_INFO *pliLinkInfo, HRESULT *phrDiagnosticError)
{
    TraceFunctEnterEx((LPARAM) this, "CMailMsgAdminQueue::HrGetLinkInfo");
    HRESULT hr = S_OK;

    _ASSERT(m_pammq);
    _ASSERT(pliLinkInfo);

    if(!m_pammq)
    {
        hr = S_FALSE;
        goto Exit;
    }
        
    if(!pliLinkInfo)
    {
        hr = E_POINTER;
        goto Exit;
    }

    //
    //  Get the link state from our base queue implementation
    //
    pliLinkInfo->fStateFlags = m_pammq->dwQueueAdminLinkGetLinkState();

    pliLinkInfo->fStateFlags |= GetLinkType();
    pliLinkInfo->szLinkName = wszQueueAdminConvertToUnicode(m_szQueueName, m_cbQueueName);

    if (!pliLinkInfo->szLinkName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //We return 0 since size statistics are not calculated
    pliLinkInfo->cbLinkVolume.QuadPart = 0;

    //
    // Include the items queued for retry in the total count
    //
    pliLinkInfo->cMessages = m_pammq->cQueueAdminGetNumItems();

    pliLinkInfo->dwSupportedLinkActions = m_dwSupportedActions;

    //Write diagnostic
    *phrDiagnosticError = S_OK;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[CMailMsgAdminQueue::HrGetNumQueues]-------------------------------------
//  Description:
//      Used to query number of queues in object. Since this class does not
//      expose the one queue it contains, 0 is returned,
//  Parameters:
//      OUT DWORD *pcQueues     # of queues (0) written to this.
//  Returns:
//      S_OK unless...
//      E_POINTER parameter is not allocated
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminQueue::HrGetNumQueues(DWORD *pcQueues)
{
    _ASSERT (pcQueues);
    if (!pcQueues)
        return E_POINTER;

    *pcQueues = 0;
    return S_OK;
}

//---[CMailMsgAdminQueue::HrApplyActionToLink]---------------------------------
//  Description:
//      Applies action to the embedded queue. Only kicking the queue is supported.
//  Parameters:
//      IN LINK_ACTION  la  Action to apply.
//  Returns:
//      S_OK            Action was successfully applied.
//      S_FALSE         Action not supported or severe error.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminQueue::HrApplyActionToLink(LINK_ACTION la)
{
    HRESULT hr = S_OK;

    _ASSERT(LA_KICK == la);
    _ASSERT(m_pammq);
    if (!m_pammq)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if (LA_KICK == la)
    {
        m_pammq->StartRetry(); //kick off processing
        hr = S_OK;
    }
    else
        hr = S_FALSE;

Exit:        
    return hr;
}

//---[CMailMsgAdminQueue::HrGetQueueIDs]---------------------------------------
//  Description:
//      Returns an enumeration of embedded queues in this object. Since the one
//      emmbedded queue is not exposed, zero queues are returned.
//  Parameters:
//      OUT DWORD           *pcQueues   Number of queues (0)
//      OUT QUEUELINK_ID    *rgQueues   Array into which queueIDs are returned.
//  Returns:
//      S_OK        Success
//      E_POINTER   pcQueues is NULL
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
STDMETHODIMP CMailMsgAdminQueue::HrGetQueueIDs(DWORD *pcQueues, QUEUELINK_ID *rgQueues)
{
    TraceFunctEnterEx((LPARAM) this, "CMailMsgAdminQueue::HrGetQueueIDs");

    _ASSERT(pcQueues);
    _ASSERT(rgQueues);
    HRESULT hr = S_OK;

    if(!pcQueues)
    {
        hr = E_POINTER;
        goto Exit;
    }

    *pcQueues = 0;

Exit:
    TraceFunctLeave();
    return hr;
}

//---[CMailMsgAdminQueue::fMatchesID]------------------------------------------
//  Description:
//      Checks if this admin object matches a specified ID.
//  Parameters:
//      IN  QUEUELINK_ID    *pQueueLinkID   Ptr to ID to be matched against.
//  Returns:
//      TRUE    on match.
//      FALSE   if did not matched or unrecoverable error (m_szQueueName not alloced)
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE CMailMsgAdminQueue::fMatchesID(QUEUELINK_ID *pQueueLinkID)
{
    _ASSERT(pQueueLinkID);
    _ASSERT(pQueueLinkID->szName);
    _ASSERT(m_szQueueName);

    if(!m_szQueueName)
        return FALSE;
        
    CAQScheduleID aqsched(pQueueLinkID->uuid, pQueueLinkID->dwId);

    if (!fIsSameScheduleID(&aqsched))
        return FALSE;

    if (!fBiStrcmpi(m_szQueueName, pQueueLinkID->szName))
        return FALSE;

    //Everything matched!
    return TRUE;
}

//---[CMailMsgAdminQueue::fIsSameScheduleID]-----------------------------------
//  Description:
//      Helper function for fMatchesID()
//  Parameters:
//  Returns:
//      TRUE    if schedule IDs are identical
//      FALSE   otherwise.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
BOOL CMailMsgAdminQueue::fIsSameScheduleID(CAQScheduleID *paqsched)
{
    return (m_aqsched.fIsEqual(paqsched));
}

//---[CMailMsgAdminQueue::HrGetLinkID]-----------------------------------------
//  Description:
//      Get the ID for this admin object.
//  Parameters:
//      OUT QUEUELINK_ID *pLinkID   struct into which to put ID.
//  Returns:
//      S_OK            Successfully copied out ID.
//      E_POINTER       out struct is NULL.
//      E_OUTOFMEMORY   Cannot allocate memory for output of ID name.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
HRESULT CMailMsgAdminQueue::HrGetLinkID(QUEUELINK_ID *pLinkID)
{
    HRESULT hr = S_OK;

    _ASSERT(pLinkID);
    if(!pLinkID)
    {
        hr = E_POINTER;
        goto Exit;
    }
    
    pLinkID->qltType = QLT_LINK;
    pLinkID->dwId = m_aqsched.dwGetScheduleID();
    m_aqsched.GetGUID(&pLinkID->uuid);

    if (!fRPCCopyName(&pLinkID->szName))
        hr = E_OUTOFMEMORY;
    else
        hr = S_OK;

Exit:
    return hr;
}

//---[CMailMsgAdminQueue::fRPCCopyName]----------------------------------------
//  Description:
//      Helper function to create a unicode copy of the string identifying
//      this admin object. The unicode string is de-allocated by RPC.
//  Parameters:
//      OUT LPWSTR  *pwszLinkName    Ptr to wchar string allocated and written
//                                   into by this function.
//  Returns:
//      TRUE    On success.
//      FALSE   if there is no name for this object
//      FALSE   if memory cannot be allocated for unicode string.
//  History:
//      6/24/1999 - GPulla created
//-----------------------------------------------------------------------------
BOOL CMailMsgAdminQueue::fRPCCopyName(OUT LPWSTR *pwszLinkName)
{
    _ASSERT(pwszLinkName);

    if (!m_cbQueueName || !m_szQueueName)
        return FALSE;

    *pwszLinkName = wszQueueAdminConvertToUnicode(m_szQueueName, 
                                                  m_cbQueueName);
    if (!pwszLinkName)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\linkmsgq.h ===
//-----------------------------------------------------------------------------
//
//
//    File: linkmsgq.h
//
//    Description:
//        This provides a description of one of the external interfaces provided
//        by the CMT.  CLinkMsgQueue provides Route factoring with an interface
//        to get the next message for a given link.
//
//    Owner: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef _LINKMSGQ_H_
#define _LINKMSGQ_H_

#include "cmt.h"
#include <rwnew.h>
#include <baseobj.h>
#include <aqueue.h>
#include "domain.h"
#include "aqroute.h"
#include "smproute.h"
#include <listmacr.h>
#include "qwiklist.h"
#include "dcontext.h"
#include "aqstats.h"
#include "aqnotify.h"
#include "aqadmsvr.h"

class CAQSvrInst;
class CDestMsgQueue;
class CConnMgr;
class CSMTPConn;
class CInternalDomainInfo;

#define LINK_MSGQ_SIG ' QML'

//Define private link state flags
//NOTE - Be sure to add new private flags to AssertPrivateLinkStateFlags as well
#define LINK_STATE_PRIV_CONFIG_TURN_ETRN            0x80000000
#define LINK_STATE_PRIV_ETRN_ENABLED                0x40000000
#define LINK_STATE_PRIV_TURN_ENABLED                0x20000000
#define LINK_STATE_PRIV_NO_NOTIFY                   0x10000000
#define LINK_STATE_PRIV_NO_CONNECTION               0x08000000
#define LINK_STATE_PRIV_GENERATING_DSNS             0x04000000
#define LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY      0x02000000
#define LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION      0x01000000
#define LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED    0x00400000

#define EMPTY_LMQ_EXPIRE_TIME_MINUTES               2

//---[ enum LinkFlags ]--------------------------------------------------------
//
//
//  Hungarian: lf, pfl
//
//  Private link data flags
//-----------------------------------------------------------------------------
typedef enum _LinkFlags
{
    eLinkFlagsClear                 = 0x00000000,
    eLinkFlagsSentNewNotification   = 0x00000001,
    eLinkFlagsRouteChangePending    = 0x00000002,
    eLinkFlagsFileTimeSpinLock      = 0x00000004,
    eLinkFlagsDiagnosticSpinLock    = 0x00000008,
    eLinkFlagsConnectionVerifed     = 0x00000010,
    eLinkFlagsGetInfoFailed         = 0x00000020,
    eLinkFlagsAQSpecialLinkInfo     = 0x00000040,
    eLinkFlagsInternalSMTPLinkInfo  = 0x00000080,
    eLinkFlagsExternalSMTPLinkInfo  = 0x00000100,
    eLinkFlagsMarkedAsEmpty         = 0x00000200,
    eLinkFlagsInvalid               = 0x80000000,   //link has been tagged as invalid
} LinkFlags, *PLinkFlags;

//inline function to verify that private flags are only using reserved bits
inline void AssertPrivateLinkStateFlags()
{
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_CONFIG_TURN_ETRN));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_ETRN_ENABLED));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_TURN_ENABLED));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_NO_NOTIFY));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_NO_CONNECTION));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_GENERATING_DSNS));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION));
    _ASSERT(!(~LINK_STATE_RESERVED & LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED));
}

// {34E2DCCB-C91A-11d2-A6B1-00C04FA3490A}
static const GUID g_sDefaultLinkGuid =
{ 0x34e2dccb, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

//---[ CLinkMsgQueue ]---------------------------------------------------------
//
//
//    Hungarian: linkq, plinkq
//
//
//-----------------------------------------------------------------------------
class CLinkMsgQueue :
    public IQueueAdminAction,
    public IQueueAdminLink,
    public CBaseObject,
    public IAQNotify
{
protected:
    DWORD           m_dwSignature;
    DWORD           m_dwLinkFlags;    //private data
    DWORD           m_dwLinkStateFlags; //Link state flags (private + eLinkStateFlagsf)
    CAQSvrInst     *m_paqinst;         //ptr to the virtual server intance object
    DWORD           m_cQueues;         //Number of queues on Link
    CQuickList      m_qlstQueues;
    CDomainEntry   *m_pdentryLink;     //Domain Entry for link
    DWORD           m_cConnections;    //Number of current connections
    DWORD           m_dwRoundRobinIndex; //Used to round-robin through queues
    CShareLockInst  m_slConnections; //lock to access connections
    CShareLockInst  m_slInfo;      //share lock for link info
    CShareLockInst  m_slQueues;   //lock to access queues
    DWORD           m_cbSMTPDomain;    //byte count of next hop domain name
    LPSTR           m_szSMTPDomain;    //ptr to string of next hop
    CInternalDomainInfo *m_pIntDomainInfo;  //internal config info for domain
    LONG            m_lConnMgrCount;   //Count used by connection manager

    //
    //  We have 2 failure counts to keep track of the 2 types of failures.
    //  m_lConsecutiveConnectionFailureCount keeps track of the number consecutive
    //  failures to make a connection to a remote machine.
    //  m_lConsecutiveMessageFailureCount tracks the number of failures to actually
    //  send a message.  They will be different if we can connect to a remote
    //  server but cannot (or have not) sent mail.  m_lConsecutiveConnectionFailureCount
    //  is reported to routing, so that mail will be routed to this link, while
    //  m_lConsecutiveMessageFailureCount is used to determine the retry interval.
    //  By doing this, we can avoid resetting our retry times if we successfully
    //  connect, but cannot actually send a message.
    //
    LONG            m_lConsecutiveConnectionFailureCount;
    LONG            m_lConsecutiveMessageFailureCount;

    LPSTR           m_szConnectorName;
    IMessageRouterLinkStateNotification *m_pILinkStateNotify;

    //Filetimes reported to queue admin
    FILETIME        m_ftNextRetry;
    FILETIME        m_ftNextScheduledCallback;

    //Message statistics
    CAQStats        m_aqstats;

    CAQScheduleID   m_aqsched;    //ScheduleID returned by routing
    LIST_ENTRY      m_liLinks;     //linked list of links for this domain
    LIST_ENTRY      m_liConnections; //linked list of connections for this domain

    //Diagnostic information returned by SMTPSVC
    HRESULT         m_hrDiagnosticError;
    CHAR            m_szDiagnosticVerb[20];  //failed protocol VERB
    CHAR            m_szDiagnosticResponse[100]; //response from remote server


    //See comments near SetLinkType()/GetLinkType() and
    //SetSupportedActions()/fActionIsSupported() functions.
    DWORD           m_dwSupportedActions;
    DWORD           m_dwLinkType;

    //
    //  Used by RemoveLinkIfEmpty to make sure that we cache links for
    //  a period of time after them become empty.  This is only
    //  valid when the eLinkFlagsMarkedAsEmpty bit is set.
    //
    FILETIME        m_ftEmptyExpireTime;

    //Gets & verifies internal domain info
    HRESULT HrGetInternalInfo(OUT CInternalDomainInfo **ppIntDomainInfo);
    static inline BOOL fFlagsAllowConnection(DWORD dwFlags);
    HRESULT         m_hrLastConnectionFailure;

    void            InternalUpdateFileTime(FILETIME *pftDest, FILETIME *pftSrc);

    void            InternalInit();

    HRESULT CLinkMsgQueue::HrInternalPrepareDelivery(
                                IN CMsgRef *pmsgref,
                                IN BOOL fQueuesLocked,
                                IN BOOL fLocal,
                                IN BOOL fDelayDSN,
                                IN OUT CDeliveryContext *pdcntxt,
                                OUT DWORD *pcRecips,
                                OUT DWORD **prgdwRecips);


    //Static callback used to restart DSN generation
    static BOOL     fRestartDSNGenerationIfNecessary(PVOID pvContext,
                                                    DWORD dwStatus);

public:
    CLinkMsgQueue(GUID guid = g_sDefaultLinkGuid) : m_aqsched(guid, 0)
            {InternalInit();};

    CLinkMsgQueue(DWORD dwScheduleID,
                  IMessageRouter *pIMessageRouter,
                  IMessageRouterLinkStateNotification *pILinkStateNotify);
    ~CLinkMsgQueue();

    void SetLinkType(DWORD dwLinkType) { m_dwLinkType = dwLinkType; }
    DWORD GetLinkType() { return m_dwLinkType; }

    //For some links, certain actions are not supported:
    //but they use the same class (CLinkMsgQueue) as others for which
    //the actions are supported. For example CurrentlyUnreachable does
    //not support freeze/thaw. So we need to maintain for the currently
    //unreachable object, a list of actions that are supported, so it
    //does not set the flags corresponding to an unsupported action
    //when that action is commanded.

    void SetSupportedActions(DWORD dwSupported) { m_dwSupportedActions = dwSupported; }
    DWORD fActionIsSupported(LINK_ACTION la) { return (m_dwSupportedActions & la); }

    BOOL    fCanSchedule()  //Can this link be scheduled
    {
        HrGetInternalInfo(NULL);  //make sure link state flags are up to date
        DWORD dwFlags = m_dwLinkStateFlags;
        return fFlagsAllowConnection(dwFlags);
    }

    BOOL    fCanSendCmd()  //Is this link scheduled to send command on next connection
    {
        //Logic :
        //  Every time we see this flag set, the connection that is created also will
        //  be used to send a command
        //
        DWORD dwFlags = m_dwLinkStateFlags;
        return (dwFlags & LINK_STATE_CMD_ENABLED);
    }

    BOOL    fShouldConnect(IN DWORD cMaxLinkConnections,
                           IN DWORD cMinMessagesPerConnection);

    //returns S_OK if connection is needed, S_FALSE if not.
    HRESULT HrCreateConnectionIfNeeded(IN  DWORD cMaxLinkConnections,
                                       IN  DWORD cMinMessagesPerConnection,
                                       IN  DWORD cMaxMessagesPerConnection,
                                       IN  CConnMgr *pConnMgr,
                                       OUT CSMTPConn **ppSMTPConn);

    LONG    IncrementConnMgrCount() {return InterlockedIncrement(&m_lConnMgrCount);}
    LONG    DecrementConnMgrCount() {return InterlockedDecrement(&m_lConnMgrCount);}

    //
    //  Connection failure API.  This is used by the connection manager.  We
    //  will always return the message failure count, since this is what we
    //  want to pass to the retry sink.  However, we will not allow the
    //  connection manager to reset this count since only we should during
    //  ack message.
    //
    LONG    IncrementFailureCounts()
    {
        InterlockedIncrement(&m_lConsecutiveConnectionFailureCount);
        return InterlockedIncrement(&m_lConsecutiveMessageFailureCount);
    }
    LONG    cGetMessageFailureCount() {return m_lConsecutiveMessageFailureCount;}
    void    ResetConnectionFailureCount(){InterlockedExchange(&m_lConsecutiveConnectionFailureCount, 0);}

    DWORD   cGetConnections() {return m_cConnections;};

    HRESULT HrInitialize(IN  CAQSvrInst *paqinst,
                         IN  CDomainEntry *pdentryLink,
                         IN  DWORD cbSMTPDomain,
                         IN  LPSTR szSMTPDomain,
                         IN  LinkFlags lf,
                         IN  LPSTR szConnectorName);

    HRESULT HrDeinitialize();

    void    AddConnection(IN CSMTPConn *pSMTPConn); //Add Connection to link
    void    RemoveConnection(IN CSMTPConn *pSMTPConn,
                             IN BOOL fForceDSNGeneration);

    HRESULT HrGetDomainInfo(OUT DWORD *pcbSMTPDomain,
                            OUT LPSTR *pszSMTPDomain,
                            OUT CInternalDomainInfo **ppIntDomainInfo);

    HRESULT HrGetSMTPDomain(OUT DWORD *pcbSMTPDomain,
                            OUT LPSTR *pszSMTPDomain);

    //Queue manipulation routines
    HRESULT HrAddQueue(IN CDestMsgQueue *pdmqNew);
    void    RemoveQueue(IN CDestMsgQueue *pdmq, IN CAQStats *paqstats);
    void    RemoveLinkIfEmpty();

    //Called by DMT to signal complete routing change
    void    RemoveAllQueues();

    // Called by DMT when this link is orphaned
    void    RemovedFromDMT();


    // This function dequeues the next available message.The message
    // retrieved will be the top one approximatly ordered by quality/class
    // and arrival time.
    HRESULT HrGetNextMsg(
                IN OUT CDeliveryContext *pdcntxt, //delivery context for connection
                OUT IMailMsgProperties **ppIMailMsgProperties, //IMsg dequeued
                OUT DWORD *pcIndexes,           //size of array
                OUT DWORD **prgdwRecipIndex);   //Array of recipient indexes

    //Acknowledge the message ref.
    //There should be one Ack for every dequeue from a link.
    HRESULT HrAckMsg(IN MessageAck *pMsgAck);

    //Gets the next message ref without getting delivery context or
    //preparing for delivery
    HRESULT HrGetNextMsgRef(IN BOOL fRoutingLockHeld, OUT CMsgRef **ppmsgref);

    //Calls CMsgRef prepare delivery for all the messages
    HRESULT HrPrepareDelivery(
                IN CMsgRef *pmsgref,
                IN BOOL fLocal,
                IN BOOL fDelayDSN,
                IN OUT CDeliveryContext *pdcntxt,
                OUT DWORD *pcRecips,
                OUT DWORD **prgdwRecips)
    {
        return HrInternalPrepareDelivery(pmsgref, FALSE, fLocal, fDelayDSN,
                                         pdcntxt, pcRecips, prgdwRecips);
    }

    //Recieve notifications from contained queues
    HRESULT HrNotify(IN CAQStats *paqstats, BOOL fAdd);

    // Gather statistical information for link mangment
    DWORD cGetTotalMsgCount() {return m_aqstats.m_cMsgs;};

    //functions used to manipulate lists of queues
    inline CAQScheduleID *paqschedGetScheduleID();
    inline BOOL     fIsSameScheduleID(CAQScheduleID *paqsched);
    static inline   CLinkMsgQueue *plmqIsSameScheduleID(
                                    CAQScheduleID *paqsched,
                                    PLIST_ENTRY pli);

    static inline   CLinkMsgQueue *plmqGetLinkMsgQueue(PLIST_ENTRY pli);

    inline PLIST_ENTRY pliGetNextListEntry();

    inline void     InsertLinkInList(PLIST_ENTRY pliHead);
    inline BOOL     fRemoveLinkFromList();

    DWORD  dwModifyLinkState(IN DWORD dwLinkStateToSet,
                             IN DWORD dwLinkStateToUnset);

    //Used to send notification to routing/scheduling sink
    void   SendLinkStateNotification();

    void   SendLinkStateNotificationIfNew() {
        if (m_pILinkStateNotify &&
            !(m_dwLinkStateFlags & LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION))
            SendLinkStateNotification();
    }

    DWORD  dwGetLinkState() {return m_dwLinkStateFlags;};

    void   SetLastConnectionFailure(HRESULT hrLastConnectionFailure)
        {m_hrLastConnectionFailure = hrLastConnectionFailure;};

    inline BOOL fRPCCopyName(OUT LPWSTR *pwszLinkName);

    DWORD  cGetNumQueues() {return m_cQueues;};

    void SetNextRetry(FILETIME *pft)
    {
        _ASSERT(pft);
        InternalUpdateFileTime(&m_ftNextRetry, pft);
    };

    void SetNextScheduledConnection(FILETIME *pft)
    {
        _ASSERT(pft);
        InternalUpdateFileTime(&m_ftNextScheduledCallback, pft);
    };

    static void ScheduledCallback(PVOID pvContext);

    void GenerateDSNsIfNecessary(BOOL fCheckIfEmpty, BOOL fMergeOnly);

    void SetDiagnosticInfo(
                    IN  HRESULT hrDiagnosticError,
                    IN  LPCSTR szDiagnosticVerb,
                    IN  LPCSTR szDiagnosticResponse);
    void GetDiagnosticInfo(
                    IN  LPSTR   szDiagnosticVerb,
                    IN  DWORD   cDiagnosticVerb,
                    IN  LPSTR   szDiagnosticResponse,
                    IN  DWORD   cbDiagnosticResponse,
                    OUT HRESULT *phrDiagnosticError);

    virtual BOOL fIsRemote() {return TRUE;};
  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) { return CBaseObject::AddRef(); };
    STDMETHOD_(ULONG, Release)(void) { return CBaseObject::Release(); };

  public: //IQueueAdminAction
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter);

    STDMETHOD(HrApplyActionToMessage)(
        IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
        BOOL *pfShouldDelete);

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        return QueryDefaultSupportedActions(pdwSupportedActions,
                                            pdwSupportedFilterFlags);
    };

  public: //IQueueAdminLink
    STDMETHOD(HrGetLinkInfo)(
        LINK_INFO *pliLinkInfo,
        HRESULT   *phrLinkDiagnostic);

    STDMETHOD(HrApplyActionToLink)(
        LINK_ACTION la);

    STDMETHOD(HrGetLinkID)(
        QUEUELINK_ID *pLinkID);

    STDMETHOD(HrGetNumQueues)(
        DWORD *pcQueues);

    STDMETHOD(HrGetQueueIDs)(
        DWORD *pcQueues,
        QUEUELINK_ID *rgQueues);
};

//---[ CLinkMsgQueue::paqschedGetScheduleID ]----------------------------------
//
//
//  Description:
//      Returns the schedule ID for this link
//  Parameters:
//      -
//  Returns:
//      ScheduleID for this link
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQScheduleID *CLinkMsgQueue::paqschedGetScheduleID()
{
    return (&m_aqsched);
}

//---[ CLinkMsgQueue::fIsSameScheduleID ]--------------------------------------
//
//
//  Description:
//      Checks if a given schedule ID is the same as ours
//  Parameters:
//      paqsched    - ScheduleID to check against
//  Returns:
//      TRUE if same schedule ID
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fIsSameScheduleID(CAQScheduleID *paqsched)
{
    return (m_aqsched.fIsEqual(paqsched));
}

//---[ CLinkMsgQueue::plmqIsSameScheduleID ]-----------------------------------
//
//
//  Description:
//      Gets the link if it matches the given schedule ID
//  Parameters:
//      paqsched    - ScheduleID to check
//      pli         - list entry to get link for
//  Returns:
//      pointer to link if scheduleID matches..
//      NULL otherwise
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CLinkMsgQueue::plmqIsSameScheduleID(
                                    CAQScheduleID *paqsched,
                                    PLIST_ENTRY pli)
{
    CLinkMsgQueue *plmq = CONTAINING_RECORD(pli, CLinkMsgQueue, m_liLinks);
    _ASSERT(LINK_MSGQ_SIG == plmq->m_dwSignature);

    if (!plmq->fIsSameScheduleID(paqsched))
        plmq = NULL;

    return plmq;
}

//---[ CLinkMsgQueue::plmqGetLinkMsgQueue ]------------------------------------
//
//
//  Description:
//      Returns the LinkMsgQueue associated with the given list entry
//  Parameters:
//      pli     - List entry to get Link for
//  Returns:
//      pointer to link for list entry
//  History:
//      6/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CLinkMsgQueue::plmqGetLinkMsgQueue(PLIST_ENTRY pli)
{
    _ASSERT(LINK_MSGQ_SIG == (CONTAINING_RECORD(pli, CLinkMsgQueue, m_liLinks))->m_dwSignature);
    return (CONTAINING_RECORD(pli, CLinkMsgQueue, m_liLinks));
}

//---[ CLinkMsgQueue::InsertLinkInList ]---------------------------------------
//
//
//  Description:
//      Inserts link in given linked list
//  Parameters:
//      pliHead     - Head of list to insert in
//  Returns:
//      -
//  History:
//      6/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CLinkMsgQueue::InsertLinkInList(PLIST_ENTRY pliHead)
{
    _ASSERT(NULL == m_liLinks.Flink);
    _ASSERT(NULL == m_liLinks.Blink);
    InsertHeadList(pliHead, &m_liLinks);
};

//---[ CLinkMsgQueue::fRemoveLinkFromList ]-------------------------------------
//
//
//  Description:
//      Remove link from link list
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/9/98 - MikeSwa Created
//      6/11/99 - MikeSwa Modified to allow multiple calls
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fRemoveLinkFromList()
{
    if (m_liLinks.Flink && m_liLinks.Blink)
    {
        RemoveEntryList(&m_liLinks);
        m_liLinks.Flink = NULL;
        m_liLinks.Blink = NULL;
        return TRUE;
    } else {
        return FALSE;
    }
};

//---[ CLinkMsgQueue::pliGetNextListEntry ]----------------------------------
//
//
//  Description:
//      Gets the pointer to the next list entry for this queue.
//  Parameters:
//      -
//  Returns:
//      The Flink of the queues LIST_ENTRY
//  History:
//      6/16/98 -  Created
//
//---------------------------------------------------------------------------
PLIST_ENTRY CLinkMsgQueue::pliGetNextListEntry()
{
    return m_liLinks.Flink;
};


//---[ CLinkMsgQueue::fFlagsAllowConnection ]---------------------------------
//
//
//  Description:
//      Static helper function that examines if a given set of flags will
//      allow a connection.  Used by fCanSchedule and the linkstate debugger
//      extension.
//  Parameters:
//      IN dwFlags      Flags to check
//  Returns:
//      TRUE if a connection can be made, FALSE otherwise
//  History:
//      9/30/98 - MikeSwa Created (separated out from fCanSchedule)
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fFlagsAllowConnection(DWORD dwFlags)
{
    //Logic :
    //  We make a connection for a link, if the admin has not specified an override and
    //  one of the following conditions is met
    //   -the force a connection NOW flag has been set
    //   -the command enable flag has been set
    //   -the ETRN or TURN enable flag has been set
    //   -the retry enable as well as the schedule enable flag has been set
    //      (and domain is not TURN only).
    //

    BOOL fRet = FALSE;
    if (dwFlags & LINK_STATE_ADMIN_HALT)
        fRet = FALSE;
    else if (dwFlags & LINK_STATE_PRIV_NO_CONNECTION)
        fRet = FALSE;
    else if (dwFlags & LINK_STATE_PRIV_GENERATING_DSNS)
        fRet = FALSE;
    else if (dwFlags & LINK_STATE_ADMIN_FORCE_CONN)
        fRet = TRUE;
    else if (dwFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
    {
        //Obey retry flag... even for ETRN domains
        if ((dwFlags & LINK_STATE_PRIV_ETRN_ENABLED) &&
            (dwFlags & LINK_STATE_RETRY_ENABLED))
            fRet = TRUE;
        else
            fRet = FALSE;
    }
    else if ((dwFlags & LINK_STATE_RETRY_ENABLED) &&
        (dwFlags & LINK_STATE_SCHED_ENABLED))
        fRet = TRUE;

    return fRet;
}


//---[ CLinkMsgQueue::fRPCCopyName ]--------------------------------------------
//
//
//  Description:
//      Used by Queue admin functions to copy the name of this link
//  Parameters:
//      IN  pszLinkName         UNICODE copy of name
//  Returns:
//      TRUE on success
//      FALSE on failure
//  History:
//      12/5/98 - MikeSwa Created
//      6/7/99 - MikeSwa Changed to UNICODE
//
//-----------------------------------------------------------------------------
BOOL CLinkMsgQueue::fRPCCopyName(OUT LPWSTR *pwszLinkName)
{
    _ASSERT(pwszLinkName);

    if (!m_cbSMTPDomain || !m_szSMTPDomain)
        return FALSE;

    *pwszLinkName = wszQueueAdminConvertToUnicode(m_szSMTPDomain,
                                                  m_cbSMTPDomain);
    if (!pwszLinkName)
        return FALSE;

    return TRUE;
}
#endif // _LINKMSGQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\mem.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: mem.cpp
//
//  Description:  
//    File that initializes required staxmem globals
//
//  Author: Mike Swafford (MikeSwa)
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "aqprecmp.h"

HANDLE g_hTransHeap = NULL;
PVOID  g_pvHeapReserve = NULL;
BOOL   g_fNoHeapFree = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\mailadmq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: mailadmq.h
//
//  Description: Header file for CMailMsgAdminQueue class, which provides the 
//      underlying implementation of pre-categorization and pre-routing queue.
//
//  Author: Gautam Pulla(GPulla)
//
//  History:
//      6/23/1999 - GPulla Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __MAILMSGADMQ_H__
#define __MAILMSGADMQ_H__

#define MAIL_MSG_ADMIN_QUEUE_VALID_SIGNATURE 'QAMM'
#define MAIL_MSG_ADMIN_QUEUE_INVALID_SIGNATURE '!QAM'

//-----------------------------------------------------------------------------
//
//  CMailMsgAdminQueue
//  
//  Hungarian: pmmaq, mmaq
//
//  This class is a wrapper for CAsyncMailMsgQueue to provide objects of that 
//  class (precat, prerouting) with an admin interface. Only a limited amount 
//  of the admin functionality (compared to the locallink or other links) is 
//  provided.
//-----------------------------------------------------------------------------

class CMailMsgAdminQueue : 
    public CBaseObject,
    public IQueueAdminAction,
    public IQueueAdminLink
{
protected:
	DWORD							 m_dwSignature;
    GUID                             m_guid;
    DWORD                            m_cbQueueName;
    LPSTR                            m_szQueueName;   
    CAsyncMailMsgQueue               *m_pammq;
    DWORD                            m_dwSupportedActions;
    DWORD                            m_dwLinkType;
    CAQScheduleID                    m_aqsched;

public:
    CMailMsgAdminQueue (GUID  guid, 
                        LPSTR szLinkName, 
                        CAsyncMailMsgQueue *pammq,
                        DWORD dwSupportedActions,
                        DWORD dwLinkType);
    ~CMailMsgAdminQueue();
    
public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj); 
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

public: //IQueueAdminAction

    //Applying admin functions is unsupported except kicking 
    //which is accomplished via HrApplyActionToLink(). This
    //function only exists in order to support the admin itf.
    STDMETHOD(HrApplyQueueAdminFunction)(
                IQueueAdminMessageFilter *pIQueueAdminMessageFilter)
    { return S_FALSE; }

    //Applying actions to messages is unsupported. This 
    //function only exists in order to support the admin itf.
    STDMETHOD(HrApplyActionToMessage)(
        IUnknown *pIUnknownMsg,
        MESSAGE_ACTION ma,
        PVOID pvContext,
        BOOL *pfShouldDelete)
    { return S_FALSE; }

    STDMETHOD_(BOOL, fMatchesID)
        (QUEUELINK_ID *QueueLinkID);

    STDMETHOD(QuerySupportedActions)(DWORD  *pdwSupportedActions,
                                   DWORD  *pdwSupportedFilterFlags)
    {
        //
        // We don't support anything on the internal queues
        //
        *pdwSupportedActions = 0;
        *pdwSupportedFilterFlags = 0;
        return S_OK;
    };

public: //IQueueAdminLink
    STDMETHOD(HrGetLinkInfo)(
        LINK_INFO *pliLinkInfo, HRESULT *phrDiagnosticError);

    STDMETHOD(HrApplyActionToLink)(
        LINK_ACTION la);

    STDMETHOD(HrGetLinkID)(
        QUEUELINK_ID *pLinkID);

    STDMETHOD(HrGetNumQueues)(
        DWORD *pcQueues);

    STDMETHOD(HrGetQueueIDs)(
        DWORD *pcQueues,
        QUEUELINK_ID *rgQueues);

public:

    DWORD GetLinkType() { return m_dwLinkType; }
    BOOL fRPCCopyName(OUT LPWSTR *pwszLinkName);
    BOOL fIsSameScheduleID(CAQScheduleID *paqsched);
};

#endif __MAILMSGADMQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgguid.h ===
//-----------------------------------------------------------------------------
//
//
//  File: msgguid.h
//
//  Description: Contains definitions of CAQMsgGuidList and CAQMsgGuidListEntry 
//      which provide functionality to supersede outdated msg ID's
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/10/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __MSGGUID_H__
#define __MSGGUID_H__

#include <cpool.h>

class CMsgRef;
class CAQMsgGuidList;
class CAQSvrInst;

#define MSGGUIDLIST_SIG                 ' LGM'
#define MSGGUIDLIST_ENTRY_SIG           'EgsM'
#define MSGGUIDLIST_ENTRY_SIG_INVALID   'sgM!'

//---[ CAQMsgGuidListEntry ]---------------------------------------------------
//
//
//  Description: 
//      Entry for CAQMsgGuidList
//  Hungarian: 
//      mgle, pmgle
//  
//-----------------------------------------------------------------------------
class CAQMsgGuidListEntry : public CBaseObject
{
  protected:
    DWORD           m_dwSignature;
    CMsgRef        *m_pmsgref;
    LIST_ENTRY      m_liMsgGuidList;
    CAQMsgGuidList *m_pmgl;
    GUID            m_guidMsgID;
  public:
    static  CPool   s_MsgGuidListEntryPool;
    void * operator new (size_t stIgnored); //should not be used
    void operator delete(void *p, size_t size);

    CAQMsgGuidListEntry(CMsgRef *pmsgref, GUID *pguid, PLIST_ENTRY pliHead,
                        CAQMsgGuidList *pmgl);
    ~CAQMsgGuidListEntry();

    //Used by CAQMsgGuidList
    static inline CAQMsgGuidListEntry * pmgleGetEntry(PLIST_ENTRY pli);
    inline BOOL fCompareGuid(GUID *pguid);
    inline CMsgRef *pmsgrefGetAndClearMsgRef();

    //Used by CMsgRef to remove from list when done delivering msg
    void        RemoveFromList();

    void        SupersedeMsg();
};

//---[ CAQMsgGuidList ]--------------------------------------------------------
//
//
//  Description: 
//      Class that exposes functionality to store and search for message ID's.
//      Used to provide "supersedes msg ID" functionality
//  Hungarian: 
//      mgl, pmgl
//  
//-----------------------------------------------------------------------------
class CAQMsgGuidList 
{
  protected:
    DWORD           m_dwSignature;
    DWORD          *m_pcSupersededMsgs;
    LIST_ENTRY      m_liMsgGuidListHead;
    CShareLockNH    m_slPrivateData;
  public:
    CAQMsgGuidList(DWORD *pcSupersededMsgs = NULL);
    ~CAQMsgGuidList();

    CAQMsgGuidListEntry *pmgleAddMsgGuid(CMsgRef *pmsgref, 
                                         GUID *pguidID, 
                                         GUID *pguidSuperseded);
    void Deinitialize(CAQSvrInst *paqinst);
    void RemoveFromList(PLIST_ENTRY pli);
    
};

inline void *CAQMsgGuidListEntry::operator new(size_t size) 
{
    return s_MsgGuidListEntryPool.Alloc();
}

inline void CAQMsgGuidListEntry::operator delete(void *p, size_t size) 
{
    s_MsgGuidListEntryPool.Free(p);
}

#endif //__MSGGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgref.h ===
//-----------------------------------------------------------------------------
//
//
//  File: msgref.h
//
//  Description: Definition of Queueing MsgRef object
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _MSGREF_H_
#define _MSGREF_H_

#include "cmt.h"
#include "baseobj.h"
#include "bitmap.h"
#include "domain.h"
#include "aqueue.h"
#include "aqroute.h"
#include "qwiklist.h"
#include "dcontext.h"
#include <mailmsg.h>
#include "msgguid.h"
#include "aqutil.h"
#include "aqadmsvr.h"

class CDestMsgQueue;
class CAQSvrInst;
class CAQStats;

// {34E2DCC8-C91A-11d2-A6B1-00C04FA3490A}
static const GUID IID_CMsgRef = 
{ 0x34e2dcc8, 0xc91a, 0x11d2, { 0xa6, 0xb1, 0x0, 0xc0, 0x4f, 0xa3, 0x49, 0xa } };

//FLAGS that say which IMsg data we care about
#define MSGREF_VALID_FLAGS  (eMsgSize | eMsgArriveTime | eMsgPriority)

//MsgRef signature
#define MSGREF_SIG          'feRM'

//max number of domains for CPool allocator
#define MSGREF_STANDARD_DOMAINS 12

//
// Make sure the "standard" CPool size is
//  - large enough to accommidate any padding in the CPoolMsgRef struct
//  - QWORD alligned so 64-bit machines are happy
//
#define MSGREF_STANDARD_CPOOL_SIZE \
    (((sizeof(CPoolMsgRef) - sizeof(CMsgRef) + \
      CMsgRef::size(MSGREF_STANDARD_DOMAINS)) + 0x10) & ~0xF)

//A Note about bitmaps
//The Recips bitmap represents the responsible recipients for a destination, 
//or message request. 1 means that the tansport should attempt to deliver for 
//this connection. 

#ifdef DEBUG
_declspec(selectany) DWORD g_cDbgMsgRefsCpoolAllocated = 0;
_declspec(selectany) DWORD g_cDbgMsgRefsExchmemAllocated = 0;
_declspec(selectany) DWORD g_cDbgMsgRefsCpoolFailed = 0;
_declspec(selectany) DWORD g_cDbgMsgIdHashFailures = 0;
_declspec(selectany) DWORD g_cDbgMsgRefsPendingRetryOnDelete = 0;
#endif //DEBUG

//define reserved message status codes ... should be in MESSAGE_STATUS_RESERVED
#define MESSAGE_STATUS_LOCAL_DELIVERY   0x80000000
#define MESSAGE_STATUS_DROP_DIRECTORY   0x40000000

//---[ CMsgRef ]---------------------------------------------------------------
//
//
//    Hungarian: msgref, pmsgref
//
//    Persistable message reference object used throughout advanced queuing
//-----------------------------------------------------------------------------
class CMsgRef : 
    public IUnknown, 
    public CBaseObject
{
public:
    static  CPool   s_MsgRefPool;
    //override the new operator
    void * operator new (size_t stIgnored,
                    unsigned int cDomains); //Number of domains in message
    void * operator new (size_t stIgnored); //should not be used
    void operator delete(void *p, size_t size);

    CMsgRef(DWORD cDomains, IMailMsgQueueMgmt *pIMailMsg, 
        IMailMsgProperties *pIMailMsgProperties, CAQSvrInst *paqinst,
        DWORD dwMessageType, GUID guidMessageRouter);
    ~CMsgRef();
    
    //perform initialization and determine the queues for this message.
    //A NULL Queue signifies local delivery
    HRESULT HrInitialize(
                IN  IMailMsgRecipients *pIRecipList, //recipient interface for msg
                IN  IMessageRouter *pIMessageRouter, //Router for this message
                IN  DWORD  dwMessageType,
                OUT DWORD *pcLocalRecips,
                OUT DWORD *pcRemoteRecips,
                OUT DWORD *pcQueues,       //# of queues for this message
                OUT CDestMsgQueue **rgpdmqQueues);   //array of queue ptrs

    //Get the effective priority of the message
    inline  EffectivePriority PriGetPriority() 
        {return (EffectivePriority) (MSGREF_PRI_MASK & m_dwDataFlags);};

    inline IMailMsgProperties *pimsgGetIMsg()
        {Assert(m_pIMailMsgProperties);m_pIMailMsgProperties->AddRef();return m_pIMailMsgProperties;};

    inline BOOL fIsMyMailMsg(IMailMsgProperties *pIMailMsgProperties)
        {return (pIMailMsgProperties == m_pIMailMsgProperties);};

    //get the size of the message content
    inline DWORD    dwGetMsgSize()
        {return(m_cbMsgSize);};

    inline DWORD    cGetNumDomains() {return(m_cDomains);};

    //get the size of the class (including all extras)
    inline  size_t   size() 
        {return (size(m_cDomains));};
    
    //Return the delivery context needed for delivery over a given link
    //Do NOT free prgdwRecips... it will disappear with the AckMessage
    HRESULT HrPrepareDelivery(
                IN BOOL fLocal,             //prepare for local domains as well
                IN BOOL fDelayDSN,          //Check/Set DelayDSN bitmap
                IN CQuickList *pqlstQueues,  //array of DestMsgQueues
                IN CDestMsgRetryQueue* pdmrq, //retry interface for message
                IN OUT CDeliveryContext *pdcntxt, //context that must be returned on Ack
                OUT DWORD *pcRecips,           //#of recips to deliver 
                OUT DWORD **prgdwRecips);  //array of recip indexes

    //Acknowledge (non)delivery of a msg
    HRESULT HrAckMessage(  
                IN CDeliveryContext *pdcntxt,  //Delivery context of message
                IN MessageAck *pMsgAck); //Delivery status of message
  
    CAQMessageType *paqmtGetMessageType() {return &m_aqmtMessageType;};

    //size that can be used by new operator
    static inline  size_t  size(DWORD cDomains) 
    {
        return (sizeof(CMsgRef) + 
                (cDomains-1)*sizeof(CDestMsgQueue *) +  //cDomains dmq ptrs
                (cDomains + 3) * (CMsgBitMap::size(cDomains)) + //bitmaps
                (cDomains*2) * sizeof(DWORD));
    };

    //Send Delay or NDR DSN's if the message has expired
    HRESULT HrSendDelayOrNDR(
                IN  DWORD dwDSNOptions,      //Flags for DSN generation
                IN  CQuickList *pqlstQueues, //list of DestMsgQueues
                IN  HRESULT hrStatus,        //Status to Pass to DSN generation
                OUT DWORD *pdwDSNFlags);     //description of what the result was

    //bit flag return values for HrSendDelayOrNDR
    enum
    {
        MSGREF_DSN_SENT_NDR     = 0x00000001, //Message NDR-expired and NDR was sent
        MSGREF_DSN_SENT_DELAY   = 0x00000002, //Message Delay-expired and Delay DSN was sent
        MSGREF_HANDLED          = 0x00000004, //Message has been completely handled
        MSGREF_HAS_NOT_EXPIRED  = 0x00000008, //Message younger than it's exipiration dates
    };

    //bit flag options for DSN generation
    enum
    {
        MSGREF_DSN_LOCAL_QUEUE      = 0x00000001, //This is for a local queue
        MSGREF_DSN_SEND_DELAY       = 0x00000002, //Allow Delay DSNs
        MSGREF_DSN_CHECK_IF_STALE   = 0x00000004, //Force open handle to check if stale
        MSGREF_DSN_HAS_ROUTING_LOCK = 0x80000000, //This thread holds the routing lock
    };

    void SupersedeMsg();

    BOOL fMatchesQueueAdminFilter(CAQAdminMessageFilter *paqmf);
    HRESULT HrGetQueueAdminMsgInfo(MESSAGE_INFO *pMsgInfo);
    HRESULT HrRemoveMessageFromQueue(CDestMsgQueue *pdmq);
    HRESULT HrQueueAdminNDRMessage(CDestMsgQueue *pdmq);
    void GlobalFreezeMessage();
    void GlobalThawMessage();

    BOOL fIsMsgFrozen() {return(MSGREF_MSG_FROZEN & m_dwDataFlags);};
    FILETIME *pftGetAge() {return &m_ftQueueEntry;};

    void RetryOnDelete();

    void PrepareForShutdown() {ReleaseMailMsg(FALSE);};

    //Checks if the message can be retried (the backing storage may
    //have been deleted).
    BOOL fShouldRetry(); 

    void GetStatsForMsg(IN OUT CAQStats *paqstat);

    void MarkQueueAsLocal(IN CDestMsgQueue *pdmq);

    void CountMessageInRemoteTotals();

  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj); 
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

  protected:
    DWORD            m_dwSignature;
    CAQSvrInst      *m_paqinst;
    DWORD            m_dwDataFlags;  //private data flags
    DWORD            m_cbMsgSize;    //Size of message content in bytes
    FILETIME         m_ftQueueEntry; //time that message was enqueued
    FILETIME         m_ftLocalExpireDelay;
    FILETIME         m_ftLocalExpireNDR;
    FILETIME         m_ftRemoteExpireDelay;
    FILETIME         m_ftRemoteExpireNDR;

    CAQMsgGuidListEntry *m_pmgle;
    DWORD            m_cDomains;     //number of DOMAINS this message is destined for
    CAQMessageType   m_aqmtMessageType; //Message type
    IMailMsgQueueMgmt  *m_pIMailMsgQM;    //Reference to message Queue mgmt
    IMailMsgProperties *m_pIMailMsgProperties; //reference to message
    IMailMsgRecipients *m_pIMailMsgRecipients;
    DWORD            m_cTimesRetried;
    DWORD            m_dwMsgIdHash;
    volatile DWORD   m_cInternalUsageCount; 
    CDestMsgQueue   *m_rgpdmqDomains[1]; //Actual size is m_cDomains
    
    static inline   BOOL    fIsStandardSize(DWORD cDomains)
    {
        return (MSGREF_STANDARD_DOMAINS >= cDomains);
    }

    HRESULT HrOneTimeInit();
    HRESULT HrPrvRetryMessage(CDeliveryContext *pdcntxt, DWORD dwMsgStatus);
    HRESULT HrPromoteMessageStatusToMailMsg(CDeliveryContext *pdcntxt, 
                                            MessageAck *pMsgAck);
    
    HRESULT HrUpdateExtendedStatus(LPSTR szCurrentStatus,
                                   LPSTR *pszNewStatus);

    //private methods to get at "hidden" data.
    CMsgBitMap      *pmbmapGetDomainBitmap(DWORD iDomain);
    CMsgBitMap      *pmbmapGetHandled();
    CMsgBitMap      *pmbmapGetPending();
    CMsgBitMap      *pmbmapGetDSN();
    DWORD           *pdwGetRecipIndexStart();
    void             SetRecipIndex(DWORD iDomain, DWORD iLowRecip, DWORD iHighRecip);
    void             GetRecipIndex(DWORD iDomain, DWORD *piLowRecip, DWORD *piHighRecip);
    void             BounceUsageCount();
    static BOOL      fBounceUsageCountCompletion(PVOID pvContext, DWORD dwStatus);
    void             ReleaseAndBounceUsageOnMsgAck(DWORD dwMsgStatus);
    void             ReleaseMailMsg(BOOL fForceRelease);
    void             SyncBounceUsageCount();  //synchronous version of BounceUsageCount

    //Checks to see if the backing mailmsg has been deleted (or is about to 
    //be deleted).
    BOOL             fMailMsgMarkedForDeletion() 
        {return ((MSGREF_MAILMSG_DELETE_PENDING | MSGREF_MAILMSG_DELETED) & m_dwDataFlags);};

    //Marks the mailmsg for deletion.  MailMsg will be deleted when the usage
    //count drops.
    void             MarkMailMsgForDeletion();

    //Used to make sure that calling thread is the only one that will call Delete()
    //on the MailMsg.  Will set the MSGREF_MAILMSG_DELETED and call Delete().  
    //Only called in ReleaseMailMsg() and InternalReleaseUsage().  The caller is
    //responsible for making sure that other threads are not reading the mailmsg or
    //have a usage count
    VOID             ThreadSafeMailMsgDelete();

    //Internal versions of AddUsage/ReleaseUsage.  Wraps the actual mailmsg calls, and
    //allows the CMsgRef to call delete on the MailMsg while there are still outstanding
    //references on it.  Uses m_cInternalUsageCount to maintain a count.
    HRESULT          InternalAddUsage();
    HRESULT          InternalReleaseUsage();

    enum //bitmasks for private flags
    {
        MSGREF_VERSION_MASK             = 0xE0000000,
        MSGREF_MSG_COUNTED_AS_REMOTE    = 0x08000000,
        MSGREF_MSG_LOCAL_RETRY          = 0x04000000,
        MSGREF_MSG_REMOTE_RETRY         = 0x02000000,
        MSGREF_USAGE_COUNT_IN_USE       = 0x01000000,
        MSGREF_SUPERSEDED               = 0x00800000, //Msg has been superseed
        MSGREF_MSG_INIT                 = 0x00400000, //HrInitialize has been called 
        MSGREF_MSG_FROZEN               = 0x00200000,
        MSGREF_MSG_RETRY_ON_DELETE      = 0x00100000,
        MSGREF_ASYNC_BOUNCE_PENDING     = 0x00040000,
        MSGREF_MAILMSG_RELEASED         = 0x00020000,
        MSGREF_MAILMSG_DELETE_PENDING   = 0x00010000, //A delete is pending on this msg
        MSGREF_MAILMSG_DELETED          = 0x00008000, //The backing store for the mailmsg 
                                                      //has been deleted.
        MSGREF_PRI_MASK                 = 0x0000000F,
        MSGREF_VERSION                  = 0x00000000,

        //used by allocators
        MSGREF_CPOOL_SIG_MASK   = 0xFFFF0000,
        MSGREF_CPOOL_SIG        = 0xC0070000,
        MSGREF_CPOOL_ALLOCATED  = 0x00000001,
        MSGREF_STANDARD_SIZE    = 0x00000002,
    };


    static  DWORD   s_cMsgsPendingBounceUsage;
    
    //Messages that have been marked pending delete, but have not been deleted
    static  DWORD   s_cCurrentMsgsPendingDelete;  

    //Total number of messages that have been marked pending delete
    static  DWORD   s_cTotalMsgsPendingDelete;    
    
    //Total number of messages that have been deleted after being marked
    //for delete pending
    static  DWORD   s_cTotalMsgsDeletedAfterPendingDelete;

    //Total number of messages that have had ::Deleted, but are still in 
    //memory because someone has an outstanding reference to the msgref
    static  DWORD   s_cCurrentMsgsDeletedNotReleased;
};

//---[ CPoolMsgRef ]-----------------------------------------------------------
//
//
//  Description: 
//      Struct used as a hidden wrapper for CMsgRef allocation... used 
//      exclusively by the CMsgRef new and delete operators
//  Hungarian: 
//      cpmsgref, pcpmsgref
//  
//-----------------------------------------------------------------------------
typedef struct _CPoolMsgRef
{
    DWORD   m_dwAllocationFlags;
    CMsgRef m_msgref;
} CPoolMsgRef;

//Cannot use default CMsgRef new operator
inline void * CMsgRef::operator new(size_t stIgnored)
{
    _ASSERT(0 && "Use new that specifies # of domains");
    return NULL;
}

inline void CMsgRef::operator delete(void *p, size_t size) 
{
    CPoolMsgRef *pcpmsgref = CONTAINING_RECORD(p, CPoolMsgRef, m_msgref);
    _ASSERT((pcpmsgref->m_dwAllocationFlags & MSGREF_CPOOL_SIG_MASK) == MSGREF_CPOOL_SIG);

    if (pcpmsgref->m_dwAllocationFlags & MSGREF_CPOOL_ALLOCATED)
    {
        s_MsgRefPool.Free((void *) pcpmsgref);
    }
    else
    {
        FreePv((void *) pcpmsgref);
    }
}


// Layout of private data bit fields
// -------------------------------------
// |332|2222222221111111111987654|3210|
// |109|8765432109876543210      |    |
// -------------------------------------
// |   |                         |  ^--- Effective routing priority (max 16) 
// |   |                         |       (Keep least significant so it can be 
// |   |                         |       used as an array index)
// |   |           ^-------------------- General msgref flags
// | ^---------------------------------- Version number 


//Actual data is variable-sized and extends beyond the class structure.  
//Use the public functions to access it.  When persisting, be sure to persist 
//the entire thing (use size() to see how big it really is).

// +----------+
// |          |
// |          | constant-size data structure CMsgRef
// |          |
// +----------+
// |          |
// |          | m_cDomains CDestMsgQueue pointers - Tells which queues this
// |          |   message is on.
// +----------+
// |          | Handled bitmap           \
// |          | Delivery pending bitmap   >- bitmaps are variable sized
// |          | Delay DSN's sent bitmap  /    (up to 32 domains fit in a DWORD)
// +----------+
// |          |
// |          | m_cDomains Domain responsibility bitmaps - used with
// |          |   the concept of "compressed" queues... not fully supported yet
// +----------+
// |          |
// |          | m_cDomains (x2) Recipient Index (start and stop... inclusive)
// |          | 
// +----------+

#endif //_MSGREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgref.cpp ===
//-----------------------------------------------------------------------------
//
//
//      File: msgref.cpp
//
//      Description:
//              Implementation of CMT Message reference
//
//      Author: mikeswa
//
//      Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "dcontext.h"
#include "dsnevent.h"
#include "aqutil.h"

CPool CMsgRef::s_MsgRefPool(MSGREF_SIG);
DWORD CMsgRef::s_cMsgsPendingBounceUsage = 0;
DWORD CMsgRef::s_cCurrentMsgsPendingDelete = 0;  
DWORD CMsgRef::s_cTotalMsgsPendingDelete = 0;    
DWORD CMsgRef::s_cTotalMsgsDeletedAfterPendingDelete = 0;
DWORD CMsgRef::s_cCurrentMsgsDeletedNotReleased = 0;

//Assumed default msg size (if no hint is present)
#define DEFAULT_MSG_HINT_SIZE 1000

#ifndef DEBUG
#define _VERIFY_RECIPS_HANDLED(pIRecipList, iStartRecipIndex, cRecipCount)
#else
#define _VERIFY_RECIPS_HANDLED(pIRecipList, iStartRecipIndex, cRecipCount) \
    VerifyRecipsHandledFn(pIRecipList, iStartRecipIndex, cRecipCount);

//---[ VerifyRecipsHandleFn ]--------------------------------------------------
//
//
//  Description: 
//      Verifies that all recipients in a given range have been handled.
//  Parameters:
//      pIRecipList         IMailMsgRecipients Interface for message
//      iStartRecipIndex    The first recipient to verify
//      cRecipCount         The count of recipients to verify
//  Returns:
//      -
//      Asserts on failures
//  History:
//      10/5/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void VerifyRecipsHandledFn(IMailMsgRecipients *pIRecipList,
                          DWORD iStartRecipIndex,
                          DWORD cRecipCount)
{
    HRESULT hr = S_OK;
    DWORD   dwCurrentRecipFlags = 0;
    for (DWORD j = iStartRecipIndex; j < cRecipCount + iStartRecipIndex; j++)
    {
        dwCurrentRecipFlags = 0;
        hr = pIRecipList->GetDWORD(j, IMMPID_RP_RECIPIENT_FLAGS, 
                                        &dwCurrentRecipFlags);
        if (SUCCEEDED(hr))
            _ASSERT(RP_HANDLED & dwCurrentRecipFlags);
    }
}

#endif //DEBUG

//#ifndef DEBUG
#if 1
#define _VERIFY_QUEUE_PTR(paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues)
#else //DEBUG defined
#define _VERIFY_QUEUE_PTR(paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues) \
    VerifyQueuePtrFn(paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues)


//---[ VerifyQueuePtrFn ]-------------------------------------------------------
//
//
//  Description: 
//      Debug function to verify that the queue ptr returned by HrMapDomain is
//      valid and does not confict with previous queue pointers.
//  Parameters:
//      paqinst - ptr to CMQ object
//      szCurrentDomain - Domain that ptr is for
//      pdmq    - Queue ptr to verify
//      cQueues - Number of queues so far
//      rgpdmqQueues    - Array of queues so far
//  Returns:
//      -
//  History:
//      6/1/98 - MikeSwa Created 
//      8/14/98 - MikeSwa Modified to handled shutdown
//
//-----------------------------------------------------------------------------
void VerifyQueuePtrFn(CAQSvrInst *paqinst, LPSTR szCurrentDomain, CDestMsgQueue *pdmq, 
                 DWORD cQueues, CDestMsgQueue **rgpdmqQueues)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pDomainInfo = NULL;
    DWORD j;

    //verify that non-local domains have queue ptrs
    hr = paqinst->HrGetInternalDomainInfo(strlen(szCurrentDomain), szCurrentDomain,
                                &pDomainInfo);

    if (AQUEUE_E_SHUTDOWN == hr)
        return;

    _ASSERT(SUCCEEDED(hr));
    if (!(pDomainInfo->m_DomainInfo.dwDomainInfoFlags & DOMAIN_INFO_LOCAL_MAILBOX))
        _ASSERT(pdmq && "NULL DesMsgQueue returned for NON-LOCAL domain");

    pDomainInfo->Release();

    //verify that Recip list is not returning domains out of order
    if (pdmq)
    {
        for (j = 0; j < cQueues; j++)
        {
            //check if ptr has been used yet
            if (rgpdmqQueues[j] == pdmq)
            {
                _ASSERT(0 && "IMailMsg Domain interface is broken");
            }
        }
    }

}
#endif //DEBUG

//---[ fAllRecipsInRangeHandled ]----------------------------------------------
//
//
//  Description: 
//      Utility function that iterates through recipients in a range (usually
//      a single domain) and determines if all the recipients have been handled.
//  Parameters:
//      pIRecipList         IMailMsgRecipients Interface for message
//      iStartRecipIndex    The first recipient to verify
//      cRecipCount         The count of recipients to verify
//  Returns:
//      TRUE    if *all* of the recipients in the range are handle
//      FALSE   if one or more of the recipients in the range are not handled,
//  History:
//      10/25/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL fAllRecipsInRangeHandled(IMailMsgRecipients *pIRecipList,
                          DWORD iStartRecipIndex,
                          DWORD cRecipCount)
{
    HRESULT hr = S_OK;
    DWORD   dwCurrentRecipFlags = 0;
    BOOL    fAreHandled = TRUE;

    _ASSERT(cRecipCount);

    for (DWORD j = iStartRecipIndex; j < cRecipCount + iStartRecipIndex; j++)
    {
        dwCurrentRecipFlags = 0;
        hr = pIRecipList->GetDWORD(j, IMMPID_RP_RECIPIENT_FLAGS, 
                                        &dwCurrentRecipFlags);
        if (FAILED(hr) || !(RP_HANDLED & dwCurrentRecipFlags))
        {
                fAreHandled = FALSE;
                break;
        }
    }

    if (fAreHandled) {
        _VERIFY_RECIPS_HANDLED(pIRecipList, iStartRecipIndex, cRecipCount);
    }

    return fAreHandled;
}

//---[ CMsgRef::new ]----------------------------------------------------------
//
//
//  Description: 
//      Overide the new operator to allow for the variable size of this class.
//      CPool is used for the 90% case allocations, while exchmem is used
//      for odd-size allocations.
//  Parameters:
//      cDomains    the number of domains this message is being delivered to.
//  Returns:
//      -
//-----------------------------------------------------------------------------
void * CMsgRef::operator new(size_t stIgnored, unsigned int cDomains)
{
    CPoolMsgRef *pcpmsgref = NULL;
    DWORD   dwAllocationFlags = MSGREF_CPOOL_SIG;
    if (fIsStandardSize(cDomains)) 
    {
        dwAllocationFlags |= MSGREF_STANDARD_SIZE;
        //if our expected standard size... then use cpool allocator
        pcpmsgref = (CPoolMsgRef *) s_MsgRefPool.Alloc(); 
        if (pcpmsgref)
        {
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsCpoolAllocated));
            dwAllocationFlags |= MSGREF_CPOOL_ALLOCATED;
        }
        else
        {
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsCpoolFailed));
        }
    }

    if (!pcpmsgref)
    {
        pcpmsgref = (CPoolMsgRef *) pvMalloc((unsigned int)(sizeof(CPoolMsgRef) - sizeof(CMsgRef) + size(cDomains)));
        if (pcpmsgref)
        {
            DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsExchmemAllocated));
        }
    }

    if (pcpmsgref)
    {
        pcpmsgref->m_dwAllocationFlags = dwAllocationFlags;
        return ((void *) &(pcpmsgref->m_msgref));
    }
    else
    {
        return NULL;
    }
}


//---[ CMsgRef::CMsgRef ]------------------------------------------------------
//
//
//  Description: 
//      Constructor for CMsgRef
//  Parameters:
//      cDomains    the number of domains this msg is being delivered to
//      pimsg       ptr to the imsg object for this message
//  Returns:
//
//
//-----------------------------------------------------------------------------
CMsgRef::CMsgRef(DWORD cDomains, IMailMsgQueueMgmt *pIMailMsgQM, 
                 IMailMsgProperties *pIMailMsgProperties,
                 CAQSvrInst *paqinst, DWORD dwMessageType, GUID guidRouter) 
                 : m_aqmtMessageType(guidRouter, dwMessageType)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::CMsgRef");
    _ASSERT(pIMailMsgQM);
    _ASSERT(pIMailMsgProperties);
    _ASSERT(paqinst);
    
    pIMailMsgQM->AddRef();
    pIMailMsgProperties->AddRef();
    paqinst->AddRef();

    m_dwSignature       = MSGREF_SIG;
    m_dwDataFlags       = MSGREF_VERSION;
    m_cDomains          = cDomains;
    m_pIMailMsgQM       = pIMailMsgQM;
    m_pIMailMsgProperties = pIMailMsgProperties;
    m_pIMailMsgRecipients = NULL;
    m_paqinst           = paqinst;
    m_pmgle             = NULL;
    m_cbMsgSize         = 0; //initialize from IMsg
    m_dwMsgIdHash       = dwQueueAdminHash(NULL);
    m_cTimesRetried     = 0;
    m_cInternalUsageCount = 1;  //Initialize to 1 like the mailmsg usage count

    //initialize stuff that is past traditional end of object
    ZeroMemory(m_rgpdmqDomains, (size(cDomains)+sizeof(CDestMsgQueue *)-sizeof(CMsgRef)));
    TraceFunctLeave();
}

//---[ CMsgRef::~CMsgRef ]------------------------------------------------------------
//
//
//  Description: 
//      CMsgRef Destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CMsgRef::~CMsgRef()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::~CMsgRef");
    HRESULT hr = S_OK;
    DWORD i = 0;
    
    _ASSERT(m_paqinst);
    
    _ASSERT(!(MSGREF_USAGE_COUNT_IN_USE & m_dwDataFlags));  //this should never remain set
    
    //There should be corresponding calls to AddUsage/ReleaseUsage
    _ASSERT(m_cInternalUsageCount == 1); 

    //Release MsgGuidListEntry if we have one
    if (m_pmgle)
    {
        m_pmgle->RemoveFromList();
        m_pmgle->Release();
    }

    ReleaseMailMsg(TRUE);  //Force commit/delete/release of associated mailmsg

    //Update count of messages that have had ::Delete called on them
    //but not been released.
    if ((MSGREF_MAILMSG_DELETE_PENDING & m_dwDataFlags) &&
        (MSGREF_MAILMSG_DELETED & m_dwDataFlags))
    {
        InterlockedDecrement((PLONG) &s_cCurrentMsgsDeletedNotReleased);
    }
    //Release references to DestMsgQueues
    for (i = 0; i < m_cDomains; i++)
    {
        if (m_rgpdmqDomains[i])
        {
            m_rgpdmqDomains[i]->Release();
            m_rgpdmqDomains[i] = NULL;
        }
    }

    m_paqinst->Release();
    TraceFunctLeave();
}


//---[ CMsgRef::ReleaseMailMsg ]-----------------------------------------------
//
//
//  Description: 
//      Release this objects mailmsg... do the necessary commit/delete
//  Parameters:
//      fForceRelease       TRUE mailmsg must be released (used by desctructor)
//                          FALSE release mailmsg if shutdown is happening
//  Returns:
//      -
//  History:
//      7/7/99 - MikeSwa Created 
//      10/8/99 - MikeSwa Fixed problem when SpinLock fials
//
//-----------------------------------------------------------------------------
void CMsgRef::ReleaseMailMsg(BOOL fForceRelease)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::ReleaseMailMsg");
    HRESULT hr = S_OK;

    if (!fForceRelease && !m_paqinst->fShutdownSignaled())
        return; //we'll let the actual release handle this case

    //Make sure no one is trying to bounce usage
    if (!fTrySpinLock(&m_dwDataFlags, MSGREF_USAGE_COUNT_IN_USE))
    {
        //Someone is... this should not happen on the final release
        DebugTrace((LPARAM) this, "Someone else using mailmsg... bailing");
        _ASSERT(!fForceRelease);
        return;
    }

    if (MSGREF_MAILMSG_RELEASED &
        dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MAILMSG_RELEASED))
    {
        //Someone else has already come along and done this
        ReleaseSpinLock(&m_dwDataFlags, MSGREF_USAGE_COUNT_IN_USE);
        return;
    }

    if (NULL != m_pIMailMsgQM)
    {
        if ((m_dwDataFlags & MSGREF_SUPERSEDED) || 
            pmbmapGetHandled()->FAllSet(m_cDomains))
        {
            //The message has been handled (or superseded)... we can delete it
            ThreadSafeMailMsgDelete();
        }

        //Releasing the message will commit it if dirty (and not-deleted)
        m_pIMailMsgQM->Release();
        m_pIMailMsgQM = NULL;

        m_paqinst->DecMsgsInSystem(
                m_dwDataFlags & MSGREF_MSG_REMOTE_RETRY, 
                m_dwDataFlags & MSGREF_MSG_COUNTED_AS_REMOTE,
                m_dwDataFlags & MSGREF_MSG_LOCAL_RETRY);
    }

    if (m_dwDataFlags & MSGREF_MSG_RETRY_ON_DELETE)
    {
        //Retry msg
        DEBUG_DO_IT(InterlockedDecrement((PLONG) &g_cDbgMsgRefsPendingRetryOnDelete));
        m_paqinst->HandleAQFailure(AQ_FAILURE_MSGREF_RETRY, 
                    E_FAIL, m_pIMailMsgProperties);
    }

    if (NULL != m_pIMailMsgProperties)
    {
        m_pIMailMsgProperties->Release();
        m_pIMailMsgProperties = NULL;
    }

    if (NULL != m_pIMailMsgRecipients)
    {
        m_pIMailMsgRecipients->Release();
        m_pIMailMsgRecipients = NULL;
    }

    ReleaseSpinLock(&m_dwDataFlags, MSGREF_USAGE_COUNT_IN_USE);
    TraceFunctLeave();
}

//---[ CMsgRef::HrInitialize() ]-----------------------------------------------
//
//
//  Description: 
//      Perform initialization for the msgref object.  Queries the DMT for 
//      queues for each of the domains that this message is being sent to.
//
//      Can be called multiple times if needed (e.g., if the DMT version
//      changes before the messages are queued).
//  Parameters:
//      IN     paqinst      Ptr to CMQ object
//      IN     pIRecipList  interface for recipients of msg
//      IN     pIMessageRouter Router for this message
//      IN     dwMessageType Msg Type for message
//      OUT    pcLocalRecips - # of local recipients
//      OUT    pcRemoteRecips - # of remote recipients
//      OUT    pcQueues     # of queues for this message
//      IN OUT rgdmqQueues  Array of queue ptrs
//          Allocated by calling routine (to ease memory management)
//          must be at least cDomains long
//      
//  Returns:
//      S_OK on success
//      E_INVALIDARG if the data we need is not preset
//      AQUEUE_E_INVALID_MSG_ID if the message id is too long??
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrInitialize(IN  IMailMsgRecipients *pIRecipList,
                              IN  IMessageRouter *pIMessageRouter,
                              IN  DWORD dwMessageType,
                              OUT DWORD *pcLocalRecips,
                              OUT DWORD *pcRemoteRecips,
                              OUT DWORD *pcQueues,
                              IN  OUT CDestMsgQueue **rgpdmqQueues)
{
    const DWORD     IMSG_MAX_DOMAIN_LEN = 512;
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrInitialize");
    HRESULT         hr  = S_OK;
    CDomainMapping  dmap;  //value returned by DMT
    CDestMsgQueue  *pdmq = NULL;   //ptr to queue returned by DMT
    DWORD           i;           //tmp counter
    BOOL            fUsed = FALSE;
    BOOL            fLocked = FALSE;  //has the aqinst been locked?
    char            szCurrentDomain[IMSG_MAX_DOMAIN_LEN +1];  //Current Domain name
    DWORD           iCurrentLowRecip = 0;  //current low recip index
    DWORD           cCurrentRecipCount = 0; //current recipient count
    DWORD           cQueues = 0;
    DWORD           cCachedIMsgHandles = 0;
  
    _ASSERT(m_paqinst);
    _ASSERT(pcQueues);
    _ASSERT(rgpdmqQueues);
    _ASSERT(m_pIMailMsgQM);
    _ASSERT(m_pIMailMsgProperties);
    _ASSERT(pIMessageRouter);
    _ASSERT(pcLocalRecips);
    _ASSERT(pcRemoteRecips);
    _ASSERT(pIRecipList);

    *pcLocalRecips = 0;
    *pcRemoteRecips = 0;

    pIRecipList->AddRef();
    
    //If being called for a 2nd time... release old info 
    //even though it might be the same... we don't want to leak
    if (m_pIMailMsgRecipients)
        m_pIMailMsgRecipients->Release();

    m_pIMailMsgRecipients = pIRecipList;

    //Reset Message type in case it was updated
    m_aqmtMessageType.SetMessageType(dwMessageType);

    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }

    fLocked = TRUE;

    if (!(MSGREF_MSG_INIT & m_dwDataFlags))
    {
        hr = HrOneTimeInit();
        if (FAILED(hr))
            goto Exit;
    }

    for (i = 0; i < m_cDomains; i++)
    {
        //$$REVIEW: When to we need to check and make sure that it is a 
        //  properly formatted Domain Name... currently X400 will work too!!

        hr = pIRecipList->DomainItem(i, IMSG_MAX_DOMAIN_LEN +1, szCurrentDomain, 
                &iCurrentLowRecip, &cCurrentRecipCount);
        if (FAILED(hr))
            goto Exit;

        //
        // This is a quick fix for Milestone 2 so that we can send
        // mail to external X400 addresses.  Their szCurrentDomain
        // will be empty string.  Substitute that with " " which is
        // added as a local domain
        //
        if(*szCurrentDomain == '\0') {
            //
            // jstamerj 1998/07/24 12:24:48: 
            //   We can't handle an empty string, so translate this to " "
            //
            szCurrentDomain[0] = ' ';
            szCurrentDomain[1] = '\0';
        }

        if (fAllRecipsInRangeHandled(pIRecipList, iCurrentLowRecip, cCurrentRecipCount))
        {
            //All recipients for this domain have been handled, we do not need to 
            //queue it up for delivery.  Typical reasons for this are:
            // - address that have been rejected by cat, but there are valid 
            //   local recips
            // - On restart if some recipients for a message still have not been
            //   delivered
            pmbmapGetHandled()->HrMarkBits(m_cDomains, 1, &i, TRUE);
            if (FAILED(hr))
                ErrorTrace((LPARAM) this, "HrMarkBits returned hr 0x%08X", hr);

            pdmq = NULL;
        }
        else
        {
            hr = m_paqinst->pdmtGetDMT()->HrMapDomainName(szCurrentDomain, &m_aqmtMessageType,
                                        pIMessageRouter, &dmap, &pdmq);
            if (FAILED(hr))
            {
                if (PHATQ_BAD_DOMAIN_SYNTAX == hr)
                {
                    //The domain name is malformed... we should not attempt delivery
                    //for this domain, but  should deliver rest of message
                    _VERIFY_RECIPS_HANDLED(pIRecipList, iCurrentLowRecip, cCurrentRecipCount);

                    ErrorTrace((LPARAM) this, 
                        "Encountered invalid domain %s", szCurrentDomain);

                    //Set this domain as handled
                    pmbmapGetHandled()->HrMarkBits(m_cDomains, 1, &i, TRUE);
                    if (FAILED(hr))
                        ErrorTrace((LPARAM) this, "HrMarkBits returned hr 0x%08X", hr);
                }
                else
                    goto Exit;
            }
        }

        //HrInitialize is being called a 2nd time... release old queues so we don't leak
        if (m_rgpdmqDomains[i])
            m_rgpdmqDomains[i]->Release();

        m_rgpdmqDomains[i] = pdmq;

        //keep track of local/remote recip counts
        if (pdmq)
            *pcRemoteRecips += cCurrentRecipCount;
        else
            *pcLocalRecips += cCurrentRecipCount;

        _ASSERT(cCurrentRecipCount);

        _VERIFY_QUEUE_PTR(m_paqinst, szCurrentDomain, pdmq, cQueues, rgpdmqQueues);

        rgpdmqQueues[cQueues] = pdmq;    //save new ptr
        SetRecipIndex(cQueues, iCurrentLowRecip, cCurrentRecipCount + iCurrentLowRecip -1);
        cQueues++;

        //set bit in bitmap
        hr = pmbmapGetDomainBitmap(i)->HrMarkBits(m_cDomains, 1, &i, TRUE);
        _ASSERT(SUCCEEDED(hr) && "Bitmap code failed");

    }
  
    *pcQueues = cQueues;
  Exit:

    if (FAILED(hr))
    {
        //Release references to DestMsgQueues
        for (i = 0; i < m_cDomains; i++)
        {
            if (m_rgpdmqDomains[i])
            {
                m_rgpdmqDomains[i]->Release();
                m_rgpdmqDomains[i] = NULL;
            }
        }
    }

    if (fLocked)
    {
        m_paqinst->ShutdownUnlock();
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::HrOneTimeInit ]------------------------------------------------
//
//
//  Description: 
//      Perform 1-time message initialization (HrInitialize can be called 
//      multiple times... this function encapuslates that things that only
//      need to be done once).
//
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//  History:
//      10/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrOneTimeInit()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrOneTimeInit");
    HRESULT hr = S_OK;
    DWORD   cbProp = 0;
    GUID    guidID = GUID_NULL;
    GUID    *pguidID = NULL;
    GUID    guidSupersedes;
    GUID    *pguidSupersedes = NULL;
    BOOL    fFoundMsgID = FALSE;
    CHAR    szBuffer[300];
    

    _ASSERT(!(MSGREF_MSG_INIT & m_dwDataFlags));

    //get data we want from the IMsg
    //The info we want to include follows
    //  -Time IMsg entered the system (creation time)
    //  -Message Priority
    //  -Message Size
    //  -Supersedeable message ID
    //  -Hash of Message ID

    szBuffer[(sizeof(szBuffer)-1)/sizeof(CHAR)] = '\0';
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_MSG_ID,
                                sizeof(szBuffer), &cbProp,(BYTE *) szBuffer);
    //$$REVIEW - do we care about MsgID's bigger than 300 bytes
    if (SUCCEEDED(hr))
        fFoundMsgID = TRUE; 

    //Don't pass on error
    hr = S_OK;

    //Get Hash of message ID.
    if (fFoundMsgID)
        m_dwMsgIdHash = dwQueueAdminHash(szBuffer);

    if (!m_pmgle)
    {
        //Although, we know that this function has not successfully
        //completed... it is possible that it failed, so we check
        //to make sure we don't leak a m_pmgle
        hr = m_pIMailMsgProperties->GetStringA(IMMPID_MP_MSG_GUID,
                sizeof(szBuffer), szBuffer);
        if (SUCCEEDED(hr))
        {
            //Try to parse GUID from the string
            if (fAQParseGuidString(szBuffer, sizeof(szBuffer), &guidID))
            {
                pguidID = &guidID;

                hr = m_pIMailMsgProperties->GetStringA(IMMPID_MP_SUPERSEDES_MSG_GUID,
                    sizeof(szBuffer), szBuffer);
                if (SUCCEEDED(hr))
                {
                    if (fAQParseGuidString(szBuffer, sizeof(szBuffer), 
                                            &guidSupersedes))
                    {
                        pguidSupersedes = &guidSupersedes;
                    }
                }
            }
        }


        //If this message has a GUID... add it to the superseded this
        if (pguidID)
        {
            _ASSERT(m_paqinst);
            m_pmgle = m_paqinst->pmglGetMsgGuidList()->pmgleAddMsgGuid(this, 
                                pguidID, pguidSupersedes);

            //We don't care about the return results... if the allocation
            //fails, then we just treat it as if it did not have an ID.
        }
    }

    //Get time message was queued
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_ARRIVAL_FILETIME, 
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftQueueEntry);
    if (FAILED(hr))
    {
        //Message should not make it this far without being stamped with
        _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);
        goto Exit;
    }

    //Get Various expire times
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_DELAY, 
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftLocalExpireDelay);
    if (FAILED(hr))
    {
        //Message should not make it this far without being stamped with
        _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);
        goto Exit;
    }
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_LOCAL_EXPIRE_NDR, 
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftLocalExpireNDR);
    if (FAILED(hr))
    {
        //Message should not make it this far without being stamped with
        _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);
        goto Exit;
    }
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_EXPIRE_DELAY, 
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftRemoteExpireDelay);
    if (FAILED(hr))
    {
        //Message should not make it this far without being stamped with
        _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);
        goto Exit;
    }
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_EXPIRE_NDR, 
            sizeof(FILETIME), &cbProp, (BYTE *) &m_ftRemoteExpireNDR);
    if (FAILED(hr))
    {
        //Message should not make it this far without being stamped with
        _ASSERT(MAILMSG_E_PROPNOTFOUND != hr);
        goto Exit;
    }

    //Get the size of the message
    hr = m_pIMailMsgProperties->GetDWORD(IMMPID_MP_MSG_SIZE_HINT, &m_cbMsgSize);
    if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND != hr)
        {
            ErrorTrace((LPARAM) this, 
                "ERROR Getting content IMMPID_MP_MSG_SIZE_HINT returned hr - 0x%08X", hr);
            goto Exit;
        }
        hr = S_OK;
        m_cbMsgSize = DEFAULT_MSG_HINT_SIZE;
    }

    //$$TODO: Map to effective routing priority - just use Normal now
    m_dwDataFlags |= (eEffPriNormal & MSGREF_PRI_MASK);

    m_dwDataFlags |= MSGREF_MSG_INIT;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::HrPrepareDelivery ]--------------------------------------------
//
//
//  Description: 
//      Prepares a msgreference for delivery on the given list of queues.
//
//      Caller is NOT responsible for freeing prgdwRecips, 
//      This should automatically be freed with the message context.
//
//      If this function succeeds, then a usage count will have been added
//      to this mailmsg.  The caller is responsible for calling AckMessage
//      (which releases the usage count) or calling ReleaseUsage explicitly.
//  Parameters:
//      IN BOOL fLocal  Prepare delivery for all domains with NULL queues
//      IN BOOL fDelayDSN - Check/Set Delay bitmap (only send 1 Delay DSN).
//      IN CQuickList *pqlstQueues   array of DMQ's
//      IN CDestMsgRetryQueue *pmdrq - Retry interface for this delivery attempt
//          Will be NULL for local delivery, becasue we will never requeue a local
//          message to its original DMQ.
//      IN OUT CDeliveryContext *pdcntxt context that must be returned on Ack
//      OUT DWORD       *pcRecips      # of recips to deliver for 
//      OUT CMsgBitMap **prgdwRecips  Array of recipient indexes
//  Returns:
//      S_OK on success
//      AQUEUE_E_MESSAGE_HANDLED if the message has already been handled
//      AQUEUE_E_MESSAGE_PENDING if all the the requested recipients are 
//              either handled or currently pending delivery for another thread
//      E_FAIL if any of the M1 requirements are not met
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrPrepareDelivery(IN BOOL fLocal, IN BOOL fDelayDSN, 
                                   IN CQuickList *pqlstQueues,
                                   IN CDestMsgRetryQueue* pdmrq,
                                   OUT CDeliveryContext *pdcntxt,
                                   OUT DWORD *pcRecips, OUT DWORD **prgdwRecips)

{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrPrepareDelivery");

    //assert IN parameters
    _ASSERT(fLocal || pqlstQueues);

    //assert OUT parameters
    _ASSERT(pdcntxt);
    _ASSERT(prgdwRecips);
    _ASSERT(pcRecips);

    //assume average of 4 recips per domain for return list
    const DWORD RECIPIENT_PREALLOCATION_FACTOR = 4;  //we may need to tweak this.
    HRESULT     hr              = S_OK;
    CMsgBitMap *pmbmapTmp       = NULL;
    CMsgBitMap *pmbmapCurrent   = NULL;
    DWORD       i,j,k           = 0;    //loop variables
    DWORD       *pdwRecipBuffer = NULL; //The buffer for recipient indexes
    DWORD       iCurrentIndex   = 0;    //Current index into the buffer
    DWORD       cdwRecipBuffer  = 0;    //current size of recipient buffer (in DWORDS)
    DWORD       iRecipLow       = 0;    //Recipient index limits
    DWORD       iRecipHigh      = 0;   
    CDestMsgQueue *pdmq         = NULL;
    PVOID       pvContext       = NULL;
    DWORD       cDest           = pqlstQueues ? pqlstQueues->dwGetCount() : 0;
    DWORD       dwStartDomain   = 0;
    DWORD       dwLastDomain    = 0;
    BOOL        fAddedUsage     = FALSE;
    BOOL        fRecipsPending  = FALSE;

    _ASSERT((fLocal || cDest) && "We must deliver somewhere");
    _ASSERT(m_pIMailMsgRecipients);

    //check if msg has been superseded
    if (m_dwDataFlags & MSGREF_SUPERSEDED) 
    {
        hr = AQUEUE_E_MESSAGE_HANDLED;
        goto Exit;
    }

    //Pre-allocate recipient buffer.  It would be very interesting to determine
    //the best way to do this.  It might involve tuning the default factor, or 
    //using CPOOL to allocate the 90% case.
    cdwRecipBuffer = cDest * RECIPIENT_PREALLOCATION_FACTOR;
    pdwRecipBuffer = (DWORD *) pvMalloc(cdwRecipBuffer * sizeof(DWORD));
    if (NULL == pdwRecipBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //HOW IT WORKS:
    //  Here are the steps used to prepare a msgref for delivery
    //  1-Determine which domains it needs to be delivered for on this queue
    //  2-Filter out any domains that have already been handled
    //  3-Mark the domains as pending (and make sure we aren't delivering 
    //      to domains that are pending).
    //  The above accomplished by using logical operations on bitmap objects

    pmbmapTmp = new(m_cDomains) CMsgBitMap(m_cDomains);
    if (NULL == pmbmapTmp)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (cDest == 0)
    {
        //make sure local makes it through the loop once
        _ASSERT(fLocal);
        cDest = 1;
    }

    //Use group operation to group together like domains
    //Both lists of domain mappings must be strictly sorted
    for (i = 0; i < m_cDomains; i++)
    {
        for (j = 0; j < cDest; j++)
        {
            //$$NOTE: Currently this nested loop is O(n^2)
            if (pqlstQueues)
            {
                pdmq = (CDestMsgQueue *) pqlstQueues->pvGetItem(j, &pvContext);
                
                if(pdmq)
                    pdmq->AssertSignature();
                else
                    _ASSERT(fLocal);
            }

            if ((m_rgpdmqDomains[i] == pdmq) || 
                (fLocal && !m_rgpdmqDomains[i]))
            {
                pmbmapCurrent = pmbmapGetDomainBitmap(i);

                //The order of the following 5 bitmap operations is important
                //to ensure that 2 threads do not get the same recipients
                //The ACK performs the following similar operations:
                //  - Sets handled bits
                //  - Unsets pending bits
           
                //Check against handled
                if (pmbmapGetHandled()->FTest(m_cDomains, pmbmapCurrent))
                    continue;

                //Check against DSN
                if (fDelayDSN && pmbmapGetDSN()->FTest(m_cDomains,pmbmapCurrent))
                    continue;

                //Check (and set) against pending
                if (!pmbmapGetPending()->FTestAndSet(m_cDomains, pmbmapCurrent))
                {
                    fRecipsPending = TRUE;
                    continue;
                }

                // Recheck against handled.  If we remove this re-check, then
                // there is a possibility that a thread will come along
                // check handle, another thread will ack (setting handled 
                // and unsetting pending), then the first thread comes 
                // along and sets pending thereby defeating our locking
                // mechanism.
                if (pmbmapGetHandled()->FTest(m_cDomains, pmbmapCurrent))
                {
                    //We need to unset the pending bit we just set
                    hr = pmbmapCurrent->HrFilterUnset(m_cDomains, pmbmapGetPending());
                    DebugTrace((LPARAM) this, 
                        "Backout pending bits in PrepareForDelivery - hr", hr);
                                        
                    //This will succeed unless another thread has munged the 
                    //bitmap
                    _ASSERT(SUCCEEDED(hr)); 
                                        
                    hr = S_OK; //caller can do nothing about this
                    continue;
                }

                //Check (and set) against DSN
                if (fDelayDSN)
                {
                    //This should not be able to happen, since another thread
                    //must have come along and sent pending to get this far
                    _VERIFY(pmbmapGetDSN()->FTestAndSet(m_cDomains,pmbmapCurrent));
                }

                //Everything checks out... we can deliver to this domain
                hr = pmbmapTmp->HrGroupOr(m_cDomains, 1, &pmbmapCurrent);
                if (FAILED(hr))
                   goto Exit;

                //Create list of recipients.
                GetRecipIndex(i, &iRecipLow, &iRecipHigh);  //get the limits
                //make sure we have enough room to do this
                if ((iCurrentIndex + (iRecipHigh - iRecipLow) + 1) >= cdwRecipBuffer)
                {
                    //reallocate generously (enough for now + our estimate for future)
                    cdwRecipBuffer += (iRecipHigh - iRecipLow) + 1 
                                   + RECIPIENT_PREALLOCATION_FACTOR* (cDest-(j+1));
                    pdwRecipBuffer = (DWORD *) pvRealloc((void *) pdwRecipBuffer, 
                                                    cdwRecipBuffer*sizeof(DWORD));
                    if (NULL == pdwRecipBuffer)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                }

                //Make sure we have the usage count to call SetNextDomain
                if (!fAddedUsage)
                {
                    hr = InternalAddUsage();
                    if (FAILED(hr))
                        goto Exit;

                    fAddedUsage = TRUE;
                }

                //Check to see if this message is marked for deletion
                if (fMailMsgMarkedForDeletion())
                {
                    hr = AQUEUE_E_MESSAGE_HANDLED;
                    goto Exit;
                }

                if (!iCurrentIndex) //first domain
                {
                    dwStartDomain = i;
                }
                else
                {
                    hr = m_pIMailMsgRecipients->SetNextDomain(dwLastDomain, i, 
                        FLAG_OVERWRITE_EXISTING_LINKS);
                    if (FAILED(hr))
                    {
                        ErrorTrace((LPARAM) this, "ERROR: SetNextDomain Failed - hr 0x%08X", hr);
                        goto Exit;
                    }
                }

                //save last valid domain
                dwLastDomain = i;

                DebugTrace((LPARAM) this, "INFO: Sending recipients %d thru %d for domain %d:%d", iRecipLow, iRecipHigh, j, i);
                for (k = iRecipLow; k <= iRecipHigh; k++)
                {
                    pdwRecipBuffer[iCurrentIndex] = k;
                    iCurrentIndex++;
                }

                _ASSERT(iCurrentIndex <= cdwRecipBuffer);
            }
        }
    }


    if (pmbmapTmp->FAllClear(m_cDomains)) 
    {
        //there is nothing to do for this message
        if (fRecipsPending)
            hr = AQUEUE_E_MESSAGE_PENDING;
        else
            hr = AQUEUE_E_MESSAGE_HANDLED;
        goto Exit;
    }

    _ASSERT(fAddedUsage);
    if (dwStartDomain == dwLastDomain)
    {
        //There is only 1 domain... we never called SetNextDomain.. we need to
        //overwrite any previous domain link information
        hr = m_pIMailMsgRecipients->SetNextDomain(dwStartDomain, dwStartDomain, 
                                                FLAG_SET_FIRST_DOMAIN);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this, "ERROR: SetNextDomain for first domain Failed - hr 0x%08X", hr);
            goto Exit;
        }
    }

    //Initialize delivery context
    pdcntxt->Init(this, pmbmapTmp, iCurrentIndex, pdwRecipBuffer, dwStartDomain, pdmrq);

    //Write other OUT parameters
    *pcRecips = iCurrentIndex; 
    *prgdwRecips = pdwRecipBuffer;

    //set pointers to NULL so we don't delete them
    pdwRecipBuffer = NULL;
    pmbmapTmp = NULL;

Exit:

    if (FAILED(hr) && pmbmapTmp && !pmbmapTmp->FAllClear(m_cDomains))
    {
        //We need to unset the DNS and pending bits we have set
        pmbmapTmp->HrFilterUnset(m_cDomains, pmbmapGetPending());

        if (fDelayDSN)
            pmbmapTmp->HrFilterUnset(m_cDomains, pmbmapGetDSN());

    }

    if (pmbmapTmp)
        delete pmbmapTmp;

    if (pdwRecipBuffer)
        FreePv(pdwRecipBuffer);

    //Make sure we don't leave an extra usage count on failure
    if (fAddedUsage && FAILED(hr))
        InternalReleaseUsage();

    TraceFunctLeave();
    return hr;
}


//---[ CMsgRef::HrAckMessage ]-------------------------------------------------
//
//
//  Description: 
//      Acknowledges (un)delivery attempts for a message.  Will look at the  
//      IMsg and determine which queues the msgref needs to be requeued to.
//  Parameters: 
//      IN pdcntxt      Delivery context of message
//      IN pMsgAck      Delivery status of message
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrAckMessage(IN CDeliveryContext *pdcntxt,
                              IN MessageAck *pMsgAck)

{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrAckMessage");
    _ASSERT(pdcntxt);
    _ASSERT(pdcntxt->m_pmbmap);
    _ASSERT(pMsgAck);

    HRESULT     hr          = S_OK;
    CDSNParams  dsnparams;
    dsnparams.dwStartDomain = pdcntxt->m_dwStartDomain;
    
    //Do we need to send DSN's?
    if (MESSAGE_STATUS_CHECK_RECIPS & pMsgAck->dwMsgStatus)
    {
        //recipients need to be handled by the DSN code
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE;

        //we may need to send relay DSN's as well
        dsnparams.dwDSNActions |= DSN_ACTION_RELAYED;

        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;

        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;
    }
    else if (((MESSAGE_STATUS_DROP_DIRECTORY | 
               MESSAGE_STATUS_LOCAL_DELIVERY)
              & pMsgAck->dwMsgStatus) &&
             !(MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus))
    {
        //This was a successful local (or drop) delivery
        //  - NDR all undelivered
        //  - Generate any success DSNs if necessary
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE_ALL | 
                                 DSN_ACTION_DELIVERED |
                                 DSN_ACTION_RELAYED;
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;

        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;
    }
    else if (MESSAGE_STATUS_NDR_ALL & pMsgAck->dwMsgStatus)
    {
        //
        //  NDR all undelivered recipients
        //

        //
        //  Use specific extended status codes if there is no
        //  detailed per-recipient information
        //
        hr = HrPromoteMessageStatusToMailMsg(pdcntxt, pMsgAck);
        if (FAILED(hr))
        {
            //
            //  This is a non-fatal error, we should still attempt
            //  DSN generation... otherwise the sender will get
            //  no indication of the failure.
            //
            ErrorTrace((LPARAM) this, 
                "HrPromoteMessageStatusToMailMsg failed with 0x%08X", hr);
            hr = S_OK;
        }

        dsnparams.dwDSNActions = DSN_ACTION_FAILURE_ALL;
        if (MESSAGE_STATUS_DSN_NOT_SUPPORTED & pMsgAck->dwMsgStatus)
            dsnparams.dwDSNActions |= DSN_ACTION_RELAYED;

        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;

        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;

    }
    else if (((MESSAGE_STATUS_DROP_DIRECTORY |
               MESSAGE_STATUS_LOCAL_DELIVERY)
              & pMsgAck->dwMsgStatus) &&
             (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus))
    {
        //This was a retryable local (or drop) delivery failure
        //  - NDR all hard failures
        //  - Generate any success DSNs if necessary
        dsnparams.dwDSNActions = DSN_ACTION_FAILURE |
                                 DSN_ACTION_DELIVERED |
                                 DSN_ACTION_RELAYED;
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;
        hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams, FALSE);
        if (FAILED(hr))
            goto Exit;
    }

    //See if we also need to retry this message
    if (MESSAGE_STATUS_RETRY & pMsgAck->dwMsgStatus)
    {
        _ASSERT(!((MESSAGE_STATUS_ALL_DELIVERED | MESSAGE_STATUS_NDR_ALL) & pMsgAck->dwMsgStatus));
        hr = HrPrvRetryMessage(pdcntxt, pMsgAck->dwMsgStatus);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        //If retry is not specifically requested, we set the handled bits
        hr = pdcntxt->m_pmbmap->HrFilterSet(m_cDomains, pmbmapGetHandled());
        if (FAILED(hr))
            goto Exit;

        //If this message has a supersedable ID... remove it from list if 
        //we are done
        if (m_pmgle && pmbmapGetHandled()->FAllSet(m_cDomains))
        {
            m_pmgle->RemoveFromList();
        }
        //There should be something that was not set in the handled bitmap
        _ASSERT(! pdcntxt->m_pmbmap->FAllClear(m_cDomains));
    }


    //Unset Pending bitmap
    hr = pdcntxt->m_pmbmap->HrFilterUnset(m_cDomains, pmbmapGetPending());
    if (FAILED(hr))
        goto Exit;

  Exit:

    ReleaseAndBounceUsageOnMsgAck(pMsgAck->dwMsgStatus);

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::HrSendDelayOrNDR ]---------------------------------------------
//
//
//  Description: 
//      Determines if a message has expired (for Delay or NDR) and generates 
//      a DSN if neccessary.
//  Parameters:
//      IN  dwDSNOptions Flags describing DSN generation
//          MSGREF_DSN_LOCAL_QUEUE      This is for a local queue
//          MSGREF_DSN_SEND_DELAY       Allow Delay DSNs
//          MSGREF_DSN_HAS_ROUTING_LOCK This thread holds the routing lock
//      IN  pqlstQueues List of DestMsgQueues to DSN
//      IN  hrStatus    Status to Pass to DSN generation
//                      (if Status is AQUEUE_E_NDR_ALL... then message will
//                      be NDR'd regardless of timeout).
//      OUT pdwDSNFlags Reports disposition of message
//          MSGREF_DSN_SENT_NDR     Message NDR-expired and NDR was sent
//          MSGREF_DSN_SENT_DELAY   Message Delay-expired and Delay DSN was sent
//          MSGREF_HANDLED          Message has been completely handled
//          MSGREF_HAS_NOT_EXPIRED  Message younger than it's exipiration dates
//  Returns:
//      S_OK on success
//      AQUEUE_E_SHUTDOWN if shutdown is in progress
//  History:
//      7/13/98 - MikeSwa Created 
//      8/14/98 - MikeSwa Modified to add support for local expire
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrSendDelayOrNDR(
                IN  DWORD dwDSNOptions,             
                IN  CQuickList *pqlstQueues,
                IN  HRESULT hrStatus,
                OUT DWORD *pdwDSNFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrSendDelayOrNDR");
    HRESULT hr = S_OK;
    BOOL        fSendDSN    = FALSE;
    BOOL        fSendNDR    = FALSE;
    DWORD       dwTimeContext = 0;
    DWORD       dwFlags = 0;
    FILETIME    *pftExpireTime;
    CDSNParams  dsnparams;
    CDeliveryContext dcntxt;
    BOOL        fPendingSet = FALSE;  //pending bitmap has been set
    BOOL        fReleaseUsageNeeded = FALSE; //has an extra usage count been added by Prepare Delivery?
    BOOL        fShouldRetryMsg = TRUE;

    //any allocations done in PrepareDelivery will be freed by ~CDeliveryContext
    DWORD       cRecips = 0;
    DWORD       *rgdwRecips = NULL;
    

    _ASSERT(pdwDSNFlags);
    _ASSERT(MSGREF_SIG == m_dwSignature);

    *pdwDSNFlags = 0;

    //Shutdown lock should already be aquired... but lets make sure that the 
    //service shutdown thread is not waiting for it.
    if (!m_paqinst->fTryShutdownLock())
    {
        hr = AQUEUE_E_SHUTDOWN;
        goto Exit;
    }
    m_paqinst->ShutdownUnlock();


    //
    //  We need to open up the file and see what is going on.  This will
    //  force a RFC822 rendering of the message content and open 
    //  the content file.
    //
    if (dwDSNOptions & MSGREF_DSN_CHECK_IF_STALE)
    {
        //
        //  If we cannot retry the message, it is stale and we shold 
        //  drop it.  This will open the handles for a message, but
        //  we will always call BounceUsageCount at the end of this call
        //
        InternalAddUsage();
        fShouldRetryMsg = fShouldRetry();
        InternalReleaseUsage();

        if (!fShouldRetryMsg) 
        {
            *pdwDSNFlags = MSGREF_HANDLED;
            goto Exit;
        }
    }

    //if this message has been superseded... remove it from the running
    //Also if the message has already been marked for deletion
    if ((m_dwDataFlags & MSGREF_SUPERSEDED) || fMailMsgMarkedForDeletion())
    {
        *pdwDSNFlags = MSGREF_HANDLED;
        goto Exit;
    }

    //Make sure we check the correct local/remote expire time
    if (MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions)
        pftExpireTime = &m_ftLocalExpireNDR;
    else
        pftExpireTime = &m_ftRemoteExpireNDR;

    //
    //  Default to status passed in
    //
    dsnparams.hrStatus = hrStatus;

    if ((AQUEUE_E_NDR_ALL == hrStatus) ||
        (AQUEUE_E_LOOPBACK_DETECTED == hrStatus) || 
        (AQUEUE_E_ACCESS_DENIED == hrStatus) ||
        (AQUEUE_E_MESSAGE_TOO_LARGE == hrStatus))
    {
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        *pdwDSNFlags |= MSGREF_DSN_SENT_NDR;
        fSendDSN = TRUE;
        fSendNDR = TRUE;
        dsnparams.dwDSNActions |= DSN_ACTION_FAILURE_ALL;
    }
    else if (m_paqinst->fInPast(pftExpireTime, &dwTimeContext))
    {
        SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
        *pdwDSNFlags |= MSGREF_DSN_SENT_NDR;
        fSendDSN = TRUE;
        fSendNDR = TRUE;
        dsnparams.dwDSNActions |= DSN_ACTION_FAILURE_ALL;
        dsnparams.hrStatus = AQUEUE_E_MSG_EXPIRED;
    }
    else if (MSGREF_DSN_SEND_DELAY & dwDSNOptions)
    {
        //NDR is not needed, but perhaps delay is

        //Make sure we check the correct local/remote expire time
        if (MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions)
            pftExpireTime = &m_ftLocalExpireDelay;
        else
            pftExpireTime = &m_ftRemoteExpireDelay;


        if (m_paqinst->fInPast(pftExpireTime, &dwTimeContext))
        {
            SET_DEBUG_DSN_CONTEXT(dsnparams, __LINE__);
            *pdwDSNFlags |= MSGREF_DSN_SENT_DELAY;
            fSendDSN = TRUE;
            dsnparams.dwDSNActions |= DSN_ACTION_DELAYED;
            dsnparams.hrStatus = AQUEUE_E_MSG_EXPIRED;
        }
    }

    if (!fSendDSN)
    {
        //message has not expired for Delay or NDR
        *pdwDSNFlags |= MSGREF_HAS_NOT_EXPIRED;
        goto Exit;
    }

    //Prepare delivery for NDR/DSN's (setting DSN bitmap for delays)
    hr = HrPrepareDelivery(MSGREF_DSN_LOCAL_QUEUE & dwDSNOptions, 
                           ((*pdwDSNFlags) & MSGREF_DSN_SENT_DELAY) ? TRUE : FALSE, 
                           pqlstQueues, NULL, &dcntxt, 
                           &cRecips, &rgdwRecips);

    //make sure we don't delete ourselves when stack context goes away
    dcntxt.m_pmsgref = NULL; 

    if (AQUEUE_E_MESSAGE_HANDLED == hr)
    {
        //nothing to do for the message
        //if *not* filtering against Delay... 
        //then there are no undelivered recips.  Return this info
        if (!((*pdwDSNFlags) & MSGREF_DSN_SENT_DELAY))
            *pdwDSNFlags = MSGREF_HANDLED;
        else
            *pdwDSNFlags = MSGREF_HAS_NOT_EXPIRED; //delay wasn't actually sent

        hr = S_OK;
        goto Exit;
    }
    else if (AQUEUE_E_MESSAGE_PENDING == hr)
    {
        //This message is currently being processed by other threads
        //It has not been handled (so it should not be removed from the queue),
        //but it is not an error condition
        *pdwDSNFlags = 0;
        hr = S_OK;
        goto Exit;
    }
    else if (FAILED(hr))
    {
        *pdwDSNFlags = 0;

        goto Exit;
    }
    
    fPendingSet = TRUE; //we will need to unset the pending bitmap
    fReleaseUsageNeeded = TRUE;

    dsnparams.dwStartDomain = dcntxt.m_dwStartDomain;
    dsnparams.pIMailMsgProperties = m_pIMailMsgProperties;
    hr = m_paqinst->HrTriggerDSNGenerationEvent(&dsnparams,
                            MSGREF_DSN_HAS_ROUTING_LOCK & dwDSNOptions);
    if (FAILED(hr))
    {
        *pdwDSNFlags = 0;
        goto Exit;
    }

    if (S_FALSE == hr) //no DSN generated
    {
        if (fSendNDR) //Expire has passed...remove message from queue
            *pdwDSNFlags = MSGREF_HANDLED;
        else
            *pdwDSNFlags = 0;
        hr = S_OK;
        //continue through function... still remove from queue even if NOTIFY=NEVER
    }

    //if NDR was generated, set handled bits
    if (fSendNDR)
    {   
        //Set Handled bitmap
        hr = dcntxt.m_pmbmap->HrFilterSet(m_cDomains, pmbmapGetHandled());
        if (FAILED(hr))
            goto Exit;

        //If this message has a supersedable ID... remove it from list if 
        //we are done
        if (m_pmgle && pmbmapGetHandled()->FAllSet(m_cDomains))
        {
            m_pmgle->RemoveFromList();
        }

        //There should be something that was not set in the handled bitmap
        _ASSERT(! dcntxt.m_pmbmap->FAllClear(m_cDomains));
    }
    

  Exit:
    //Unset Pending bitmap
    if (fPendingSet)
    {
        dcntxt.m_pmbmap->HrFilterUnset(m_cDomains, pmbmapGetPending());
    }

    _ASSERT(m_pIMailMsgQM);
    if (fReleaseUsageNeeded)
    {
        //we called HrPrepareDelivery which added an extra usage count
        InternalReleaseUsage();
    }

    //While we are walking queues... bounce usage count - this will conserve handles
    BounceUsageCount();

    TraceFunctLeave();
    return hr;
}

//---[ HrPrvRetryMessage ]-----------------------------------------------------
//
//
//  Description: 
//      Queues Message for retry
//  Parameters:
//      pdcntxt     Delivery context set by HrPrepareDelivery
//      dwMsgStatus Status flags passed back with Ack
//  Returns:
//      S_OK on success
//  History:
//      7/13/98 - MikeSwa Created (separated from HrAckMessage())
//      5/25/99 - MikeSwa Modified - Now we requeue only to DMQ that message
//                  was originally dequeued from.  This is for X5:105384, so 
//                  that we do not double-count messages that have been
//                  ack'd retry
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrPrvRetryMessage(CDeliveryContext *pdcntxt, DWORD dwMsgStatus)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrPrvRetryMessage");
    _ASSERT(pdcntxt);
    HRESULT hr = S_OK;
    DWORD   i = 0;
    DWORD   j = 0;
    BOOL    fLocked = FALSE;
    BOOL    fLocal = (MESSAGE_STATUS_LOCAL_DELIVERY & dwMsgStatus) ? TRUE : FALSE;
    DWORD   dwNewFlags = fLocal ? MSGREF_MSG_LOCAL_RETRY : MSGREF_MSG_REMOTE_RETRY;
    CDestMsgRetryQueue *pdmrq = NULL;

    //make sure retry flags are set for this message
    DWORD   dwOldFlags = dwInterlockedSetBits(&m_dwDataFlags, dwNewFlags);
    
    DebugTrace((LPARAM) this, "INFO: Message queued for retry");
    InterlockedIncrement((PLONG) &m_cTimesRetried);

    //update global counters if first retry attempt
    if (!(dwNewFlags & dwOldFlags)) //this is the first time for this type of retry
        m_paqinst->IncRetryCount(fLocal);

    if (fLocal)
        goto Exit;

    //
    //  Check and see if we should even bother requeuing the message.
    //
    if (!fShouldRetry())
    {
        DebugTrace((LPARAM) this, "Message is no longer valid... dropping");

        //
        //  Since we have found a stale message on this queue, we should 
        //  tell it to scan on its next DSN generation pass
        //
        pdmrq = pdcntxt->pdmrqGetDMRQ();
        pdmrq->CheckForStaleMsgsNextDSNGenerationPass();
        goto Exit;
    }

    //Requeue Message for remote delivery
    if (m_paqinst->fTryShutdownLock())
    {
        //Don't retry messages if shutdown is happening
        fLocked = TRUE;

        pdmrq = pdcntxt->pdmrqGetDMRQ();
        _ASSERT(pdmrq && "Delivery Context not initialized correctly");

        if (pdmrq)
        {
            hr = pdmrq->HrRetryMsg(this);
            if (FAILED(hr))
                goto Exit;
        }
    }
    else 
    {
        hr = S_OK;  //shutdown is happening, not a real failure case
    }

  Exit:
    if (fLocked)
        m_paqinst->ShutdownUnlock();

    TraceFunctLeave();
    return hr;
}
//---[ CMsgRef::pmbmapGetDomainBitmap]-----------------------------------------
//
//
//  Description: 
//      Protected method to get the Domain Bitmap for a given domain
//  Parameters:
//      iDomain index to the domain wanted
//  Returns:
//      ptr to the domain bitmap for the given domain
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetDomainBitmap(DWORD iDomain)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetDomainBitmap");
    CMsgBitMap     *pmbmap = NULL;
    _ASSERT(iDomain < m_cDomains);

    //recall structure of memory, responsibility maps start 3 after end of 
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    pmbmap = (CMsgBitMap *) ((DWORD_PTR) pmbmap + (3+iDomain)*CMsgBitMap::size(m_cDomains));

    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pmbmapGetHandled]------------------------------------------------------------
//
//
//  Description: 
//      Protected method to get the Handled  Bitmap
//  Parameters:
//      -
//  Returns:
//      ptr to the handled bitmap 
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetHandled()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetHandled");
    CMsgBitMap     *pmbmap = NULL;

    //recall structure of memory, responsibility maps start after end of 
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pmbmapGetPending]------------------------------------------------------------
//
//
//  Description: 
//      Protected method to get the pending Bitmap
//  Parameters:
//      -
//  Returns:
//      ptr to the pending bitmap 
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetPending()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetPending");
    CMsgBitMap     *pmbmap = NULL;

    //recall structure of memory, responsibility maps start 1 after end of 
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    pmbmap = (CMsgBitMap *) ((DWORD_PTR) pmbmap + CMsgBitMap::size(m_cDomains));
    
    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pmbmapGetDSN]------------------------------------------------------------
//
//
//  Description: 
//      Protected method to get the Handled Bitmap
//  Parameters:
//      -
//  Returns:
//      ptr to the DSN bitmap 
//
//-----------------------------------------------------------------------------
CMsgBitMap *CMsgRef::pmbmapGetDSN()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::pmbmapGetDSN");
    CMsgBitMap     *pmbmap = NULL;

    //recall structure of memory, responsibility maps start 3 after end of 
    //domain mappings
    pmbmap = (CMsgBitMap *) (m_rgpdmqDomains + m_cDomains);

    pmbmap = (CMsgBitMap *) ((DWORD_PTR) pmbmap + 2*CMsgBitMap::size(m_cDomains));
    
    TraceFunctLeave();
    return pmbmap;
}

//---[ CMsgRef::pdwGetRecipIndexStart ]----------------------------------------
//
//
//  Description: 
//      Returns the start index of the Array of recipient indexes
//  Parameters:
//      -
//  Returns:
//      See above
//
//-----------------------------------------------------------------------------
DWORD *CMsgRef::pdwGetRecipIndexStart()
{
    DWORD_PTR   dwTmp = 0;
    _ASSERT(m_cDomains);

    //Array of Recipient Indexes start after last CMsgBitmap
    dwTmp = (DWORD_PTR) pmbmapGetDomainBitmap(m_cDomains-1);  //will assert if arg larger
    dwTmp += CMsgBitMap::size(m_cDomains);

    _ASSERT(((DWORD_PTR) this + size(m_cDomains)) > dwTmp);
    _ASSERT(dwTmp);

    return (DWORD *) dwTmp;
}

//---[ CMsgRef::SetRecipIndex ]-----------------------------------------------
//
//
//  Description: 
//      Set the starting and stoping recipient index for a given domain. Each
//      Domain in the message has an inclusive range of recipients associated 
//      with it.  When the message is prepared for delivery, these ranges are
//      expanded into a list of recipient indexes.
//  Parameters:
//      IN  iDomain     Index of Domain to set range for
//      IN  iLowRecip   Index of lower recipient
//      IN  iHighRecip  Index of higher recipient
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CMsgRef::SetRecipIndex(DWORD iDomain, DWORD iLowRecip, DWORD iHighRecip)
{
    _ASSERT(iDomain < m_cDomains);
    _ASSERT(iLowRecip <= iHighRecip);
    DWORD   *rgdwRecipIndex = pdwGetRecipIndexStart();

    rgdwRecipIndex[2*iDomain] = iLowRecip;
    rgdwRecipIndex[2*iDomain+1] = iHighRecip;
}


//---[ CMsgRef::GetRecipIndex ]------------------------------------------------
//
//
//  Description: 
//      Get the recipient index for a given Domain index.  Used when generating
//      a list of recipient indexes to delivery for.
//  Parameters:
//      IN  iDomain     Index of Domain to get range for
//      OUT piLowRecip  Returned lower index of recipient range
//      OUT piHighRecip Returned higher index of recipient range
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CMsgRef::GetRecipIndex(DWORD iDomain, DWORD *piLowRecip, DWORD *piHighRecip)
{
    _ASSERT(iDomain < m_cDomains);
    _ASSERT(piLowRecip && piHighRecip);
    DWORD   *rgdwRecipIndex = pdwGetRecipIndexStart();

    *piLowRecip = rgdwRecipIndex[2*iDomain];
    *piHighRecip = rgdwRecipIndex[2*iDomain+1];

    _ASSERT(*piLowRecip <= *piHighRecip);
}

//---[ CMsgRef::SupersedeMsg ]-------------------------------------------------
//
//
//  Description: 
//      Used to flag this message as superseded by a newer msg
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::SupersedeMsg()
{
    dwInterlockedSetBits(&m_dwDataFlags, MSGREF_SUPERSEDED);
}

//---[ CMsgRef::fMatchesQueueAdminFilter ]--------------------------------------
//
//
//  Description: 
//      Checks a message against a queue admin message filter to see if it
//      is a match
//  Parameters:
//      IN paqmf        Message Filter to check against
//  Returns:
//      TRUE if it matches
//      FALSE if it does not
//  History:
//      12/7/98 - MikeSwa Created 
//      2/17/99 - MikeSwa updated with better recipient checking
//
//-----------------------------------------------------------------------------
BOOL CMsgRef::fMatchesQueueAdminFilter(CAQAdminMessageFilter *paqmf)
{
    _ASSERT(paqmf);
    HRESULT hr = S_OK;
    BOOL    fMatch = TRUE;
    BOOL    fUsageAdded = FALSE;
    DWORD   dwFilterFlags = paqmf->dwGetMsgFilterFlags();
    LPSTR   szSender = NULL;
    LPSTR   szMsgId = NULL;
    LPSTR   szRecip = NULL;
    BOOL    fFoundRecipString = FALSE;

    //Check to see if this message is marked for deletion
    if (fMailMsgMarkedForDeletion())
    {
        fMatch = FALSE;
        goto Exit;
    }

    if (!dwFilterFlags)
    {
        fMatch = FALSE;
        goto Exit;
    }

    if (AQ_MSG_FILTER_ALL & dwFilterFlags)
    {
        fMatch = TRUE;
        goto Exit;
    }

    //Check MsgRef props first
    if (AQ_MSG_FILTER_LARGER_THAN & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesSize(m_cbMsgSize);
        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_OLDER_THAN & dwFilterFlags)
    {
        fMatch = paqmf->fMatchesTime(&m_ftQueueEntry);
        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_FROZEN & dwFilterFlags)
    {
        fMatch = fIsMsgFrozen();
        if (AQ_MSG_FILTER_INVERTSENSE & dwFilterFlags)
            fMatch = !fMatch;

        if (!fMatch)
            goto Exit;
    }

    if (AQ_MSG_FILTER_FAILED & dwFilterFlags)
    {
        if (m_cTimesRetried)
            fMatch = TRUE;
        else
            fMatch = FALSE;

        if (AQ_MSG_FILTER_INVERTSENSE & dwFilterFlags)
            fMatch = !fMatch;

        if (!fMatch)
            goto Exit;
    }

    //If we haven't failed by this point, we may need to AddUsage and read 
    //props from the mailmsg.  Double-check to make sure that we need to 
    //add usage.
    if (!((AQ_MSG_FILTER_MESSAGEID | AQ_MSG_FILTER_SENDER | AQ_MSG_FILTER_RECIPIENT) & 
           dwFilterFlags))
        goto Exit;  //don't have to check props

    //If we are only interested in MSGID... check hash first
    if (AQ_MSG_FILTER_MESSAGEID & dwFilterFlags)
    {
        //If we are  interested in ID & hash doesn't match then leave
        if (!paqmf->fMatchesIdHash(m_dwMsgIdHash))
        {
            fMatch = FALSE;
            goto Exit;
        }
    }

    hr = InternalAddUsage();
    if (FAILED(hr))
        goto Exit;
    fUsageAdded = TRUE;

    //Check to see if this message is marked for deletion
    if (fMailMsgMarkedForDeletion())
    {
        fMatch = FALSE;
        goto Exit;
    }

    //$$NOTE - A potential optimization would be to store the a checksum of the 
    //message ID, and check that before opening the P1 and pulling down props.
    //This might be a little more difficult for sender and recipient since they are
    //potentially more that straight string matches
    if (AQ_MSG_FILTER_MESSAGEID & dwFilterFlags)
    {
        hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, IMMPID_MP_RFC822_MSG_ID, 
                                       &szMsgId);
        if (FAILED(hr))
            szMsgId = NULL;
        fMatch = paqmf->fMatchesId(szMsgId);
        if (!fMatch)
        {
            DEBUG_DO_IT(g_cDbgMsgIdHashFailures++);
            goto Exit;
        }
    }


    if (AQ_MSG_FILTER_SENDER & dwFilterFlags)
    {
        hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, IMMPID_MP_RFC822_FROM_ADDRESS, 
                                       &szSender);

        if (FAILED(hr))
            szSender = NULL;

        //If No P2 sender... use P1
        if (!szSender)
        {
            //IMMPID_MP_SENDER_ADDRESS_SMTP
            hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, 
                                           IMMPID_MP_SENDER_ADDRESS_SMTP, 
                                           &szSender);

            if (FAILED(hr))
                szSender = NULL;
        }
        fMatch = paqmf->fMatchesSender(szSender);
        if (!fMatch)
            goto Exit;
    }
 
    if (AQ_MSG_FILTER_RECIPIENT & dwFilterFlags)
    {
        //Check To, CC, and BCC recipients (if present)
        hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, 
                    IMMPID_MP_RFC822_TO_ADDRESS, &szRecip);

        if (SUCCEEDED(hr) && szRecip)
        {
            fFoundRecipString = TRUE;
            fMatch = paqmf->fMatchesRecipient(szRecip);
        }

        //Check CC recip props if no match was found
        if (!fFoundRecipString || !fMatch)
        {
            hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, 
                    IMMPID_MP_RFC822_CC_ADDRESS, &szRecip);
            if (SUCCEEDED(hr) && szRecip && !fMatch)
            {
                fFoundRecipString = TRUE;
                fMatch = paqmf->fMatchesRecipient(szRecip);
            }
        }

        //Check BCC recip props if no match was found
        if (!fFoundRecipString || !fMatch)
        {
            hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, 
                    IMMPID_MP_RFC822_BCC_ADDRESS, &szRecip);
            if (SUCCEEDED(hr) && szRecip && !fMatch)
            {
                fFoundRecipString = TRUE;
                fMatch = paqmf->fMatchesRecipient(szRecip);
            }
        }

        //Check P1 recips if no P2 recips are present
        //$$REVIEW - One could say that it would be resonable to *always*
        //check the P1 recips if we did not match the P2 recips.  However, 
        //until we fix the P1 recip checking to be faster than linear, 
        //I would hold off.
        if (!fFoundRecipString)
            fMatch = paqmf->fMatchesP1Recipient(m_pIMailMsgProperties);

        //If after checking all this recipient information, if we didn't
        //find a match, then bail.
        if (!fMatch)
            goto Exit;
    }

  Exit:

    if (szSender)
        QueueAdminFree(szSender);

    if (szMsgId)
        QueueAdminFree(szMsgId);

    if (szRecip)
        QueueAdminFree(szRecip);

    if (fUsageAdded)
    {
        InternalReleaseUsage();
        BounceUsageCount();
    }
    return fMatch;
}

//---[ CMsgRef::HrGetQueueAdminMsgInfo ]----------------------------------------
//
//
//  Description: 
//      Fills out a queue admin MESSAGE_INFO structure.  All allocations are 
//      done with pvQueueAdminAlloc to be freed by the RPC code
//  Parameters:
//      IN OUT pMsgInfo     MESSAGE_INFO struct to dump data to
//  Returns:
//      S_OK on success
//      AQUEUE_E_MESSAGE_HANDLED if the underlying message has been deleted
//      E_OUTOFMEMORY if an allocation failu
//  History:
//      12/7/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrGetQueueAdminMsgInfo(MESSAGE_INFO *pMsgInfo)
{
    HRESULT hr = S_OK;
    BOOL    fUsageAdded = FALSE;
    FILETIME ftSubmitted; //Origination time property buffer
    DWORD   cbProp = 0;
    LPSTR   szRecipients = NULL;
    LPSTR   szCCRecipients = NULL;
    LPSTR   szBCCRecipients = NULL;


    if (fNormalPri(m_dwDataFlags & MSGREF_PRI_MASK))
        pMsgInfo->fMsgFlags = MP_NORMAL;
    else if (fHighPri(m_dwDataFlags & MSGREF_PRI_MASK))
        pMsgInfo->fMsgFlags = MP_HIGH;
    else 
        pMsgInfo->fMsgFlags = MP_LOW;

    if (MSGREF_MSG_FROZEN & m_dwDataFlags)
        pMsgInfo->fMsgFlags |= MP_MSG_FROZEN;

    //Report the number of failures
    pMsgInfo->cFailures = m_cTimesRetried;
    if (pMsgInfo->cFailures)
        pMsgInfo->fMsgFlags |= MP_MSG_RETRY;

    hr = InternalAddUsage();
    if (FAILED(hr))
        goto Exit;
    fUsageAdded = TRUE;

    //Check to see if this message is marked for deletion
    if (fMailMsgMarkedForDeletion())
    {
        hr = AQUEUE_E_MESSAGE_HANDLED;
        goto Exit;
    }

    //Get Sender
    hr = HrQueueAdminGetUnicodeStringProp(m_pIMailMsgProperties, 
                                          IMMPID_MP_RFC822_FROM_ADDRESS, 
                                          &pMsgInfo->szSender);
    if (FAILED(hr))
        goto Exit;

    //If no P2 sender... use the P1
    if (!pMsgInfo->szSender)
    {
        hr = HrQueueAdminGetUnicodeStringProp(m_pIMailMsgProperties, 
                                              IMMPID_MP_SENDER_ADDRESS_SMTP, 
                                              &pMsgInfo->szSender);
        if (FAILED(hr))
            goto Exit;
    }

    hr = HrQueueAdminGetUnicodeStringProp(m_pIMailMsgProperties, 
                                          IMMPID_MP_RFC822_MSG_SUBJECT, 
                                          &pMsgInfo->szSubject);
    if (FAILED(hr))
        goto Exit;
    
//See X5:113280 for details.  Basically, the P2 recipients are broken for 
//any messages that go over BDAT.... hence we are not displaying them until
//the underlying SMTP bug is fixed
    pMsgInfo->cRecipients = -1;
    pMsgInfo->cCCRecipients = -1;
    pMsgInfo->cBCCRecipients = -1;
#ifdef NEVER
    //Get the P2 To, CC, BCC, and associated recipient counts
    hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, IMMPID_MP_RFC822_TO_ADDRESS, 
                                   &szRecipients, &cbProp);
    if (FAILED(hr))
        goto Exit;

    pMsgInfo->cRecipients = cQueueAdminGetNumRecipsFromRFC822(
                                        szRecipients, cbProp);

    if (szRecipients)
    {
        pMsgInfo->szRecipients = wszQueueAdminConvertToUnicode(szRecipients,
                                                               cbProp-1);
        if (!pMsgInfo->szRecipients)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, IMMPID_MP_RFC822_CC_ADDRESS, 
                                   &szCCRecipients, &cbProp);
    if (FAILED(hr))
        goto Exit;

    pMsgInfo->cCCRecipients = cQueueAdminGetNumRecipsFromRFC822(
                                        szCCRecipients, cbProp);

    if (szCCRecipients)
    {
        pMsgInfo->szCCRecipients = wszQueueAdminConvertToUnicode(szCCRecipients, 
                                                                 cbProp-1);
        if (!pMsgInfo->szCCRecipients)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    hr = HrQueueAdminGetStringProp(m_pIMailMsgProperties, IMMPID_MP_RFC822_BCC_ADDRESS, 
                                   &szBCCRecipients, &cbProp);
    if (FAILED(hr))
        goto Exit;
    
    pMsgInfo->cBCCRecipients = cQueueAdminGetNumRecipsFromRFC822(
                                        szBCCRecipients, cbProp);


    if (szBCCRecipients)
    {
        pMsgInfo->szBCCRecipients = wszQueueAdminConvertToUnicode(szBCCRecipients, 
                                                                  cbProp-1);
        if (!pMsgInfo->szBCCRecipients)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
#endif //NEVER

    //Get MsgID
    hr = HrQueueAdminGetUnicodeStringProp(m_pIMailMsgProperties, 
                                          IMMPID_MP_RFC822_MSG_ID, 
                                          &pMsgInfo->szMessageId);
    if (FAILED(hr))
        goto Exit;

    //If there were no RFC822 recipient headers... build our own header list
    QueueAdminGetRecipListFromP1IfNecessary(m_pIMailMsgProperties, pMsgInfo);
 
    pMsgInfo->cbMessageSize = m_cbMsgSize;

    //Get submission and expiration times
    if (!FileTimeToSystemTime(&m_ftQueueEntry, &pMsgInfo->stReceived))
        ZeroMemory(&pMsgInfo->stReceived, sizeof(SYSTEMTIME));

    if (!FileTimeToSystemTime(&m_ftRemoteExpireNDR, &pMsgInfo->stExpiry))
        ZeroMemory(&pMsgInfo->stExpiry, sizeof(SYSTEMTIME));

    
    //Get the time the message entered the org
    hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_ORIGINAL_ARRIVAL_TIME,
                    sizeof(FILETIME), &cbProp, (BYTE *) &ftSubmitted);
    if (FAILED(hr))
    {
        //Time was not written... use entry time.
        hr = S_OK;
        memcpy(&ftSubmitted, &m_ftQueueEntry, sizeof(FILETIME));
    }

    if (!FileTimeToSystemTime(&ftSubmitted, &pMsgInfo->stSubmission))
        ZeroMemory(&pMsgInfo->stSubmission, sizeof(SYSTEMTIME));
  Exit:

    if (szRecipients)
        QueueAdminFree(szRecipients);
                                                                    
    if (szCCRecipients)
        QueueAdminFree(szCCRecipients);

    if (szBCCRecipients)
        QueueAdminFree(szBCCRecipients);

    if (fUsageAdded)
    {
        InternalReleaseUsage();
        BounceUsageCount();
    }

    return hr;
}


//---[ CMsgRef::BounceUsageCount ]---------------------------------------------
//
//
//  Description: 
//      Bounces usage count off of 0 to close handles.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/7/98 - MikeSwa Created 
//      7/6/99 - MikeSwa Modified - made async
//      10/27/1999 - MikeSwa - spun-pff SyncBounceUsageCount()
//
//-----------------------------------------------------------------------------
void CMsgRef::BounceUsageCount()
{
    DWORD dwFlags = 0;

    //Bounce usage count - this will conserve handles
    dwFlags = dwInterlockedSetBits(&m_dwDataFlags, MSGREF_ASYNC_BOUNCE_PENDING);
   
    //If the bit was *not* already set, then it is safe to call release usage
    if (!(MSGREF_ASYNC_BOUNCE_PENDING & dwFlags))
    {
        if (m_paqinst)
        {
            if (g_cMaxIMsgHandlesAsyncThreshold > 
                (DWORD) InterlockedIncrement((PLONG)&s_cMsgsPendingBounceUsage))
            {
                AddRef();
                m_paqinst->HrQueueWorkItem(this, 
                                      CMsgRef::fBounceUsageCountCompletion);
                //Completion function is still called on failure
            }
            else
            {
                //There are too many messages pending async commit.  We
                //should force a synchronous bounce
                SyncBounceUsageCount();
            }
        }
    }
}

//---[ CMsgRef::SyncBounceUsageCount ]-----------------------------------------
//
//
//  Description: 
//      Forces synchronous bounce usage.  Can be used when there are too many
//      messages pending async bounce usage or if you want to bounce usage
//      immediately (to force deletion of a message marked for deletion).
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/27/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::SyncBounceUsageCount()
{
    BOOL  fCompletionRet = FALSE;

    AddRef();

    //Call the async bounce usage function directly
    fCompletionRet = fBounceUsageCountCompletion(this,
                                            ASYNC_WORK_QUEUE_NORMAL);
    _ASSERT(fCompletionRet); //This is hardcoded to return TRUE
    if (!fCompletionRet)
        Release();
}

//---[ CMsgRef::fBounceUsageCountCompletion ]----------------------------------
//
//
//  Description: 
//      Async completion for BounceUsageCount
//  Parameters:
//      IN      pvContext   CMsgRef to bounce usage count on
//  Returns:
//      TRUE always
//  History:
//      7/6/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CMsgRef::fBounceUsageCountCompletion(PVOID pvContext, DWORD dwStatus)
{
    CMsgRef *pmsgref = (CMsgRef *) pvContext;

    _ASSERT(pmsgref);
    _ASSERT(MSGREF_SIG == pmsgref->m_dwSignature);

    //Don't bounce usage while where are trying to shutdown
    if (ASYNC_WORK_QUEUE_SHUTDOWN != dwStatus)
    {
        //NOTE - Make sure 2 threads don't call ReleaseUsage before AddUsage 
        //(which might cause the usage count to drop below 0).
        if (fTrySpinLock(&(pmsgref->m_dwDataFlags), MSGREF_USAGE_COUNT_IN_USE))
        {
            //Make sure another thread has not released the mailmsg
            //for shutdown.
            if (  pmsgref->m_pIMailMsgQM && 
                !(MSGREF_MAILMSG_RELEASED & pmsgref->m_dwDataFlags))
            {
                pmsgref->InternalReleaseUsage();
                pmsgref->InternalAddUsage();
            }

            //Unset the lock usage count bit (since this thread set it)
            ReleaseSpinLock(&(pmsgref->m_dwDataFlags), MSGREF_USAGE_COUNT_IN_USE);
        }
    }

    //Unset the bit set in BounceUsageCount
    dwInterlockedUnsetBits(&(pmsgref->m_dwDataFlags), MSGREF_ASYNC_BOUNCE_PENDING);
    InterlockedDecrement((PLONG)&s_cMsgsPendingBounceUsage);

    pmsgref->Release();
    return TRUE;  //This function never retries
}


//---[ CMsgRef::HrRemoveMessageFromQueue ]-------------------------------------
//
//
//  Description: 
//      Remove a message from the specified queue
//  Parameters:
//      IN pdmq         Queue to remove message from
//  Returns:
//      S_OK on success
//  History:
//      12/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrRemoveMessageFromQueue(CDestMsgQueue *pdmq)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    BOOL  fLocal = !pdmq;  //If no link is specified... it is local

    //Search for matching queue
    for (i = 0; i < m_cDomains; i++)
    {
        //
        //  Check and see if this domain is an exact match.  This will work
        //  for local as well, since we mark the queue as NULL when we move
        //  it to the local queue.
        //
        if (pdmq == m_rgpdmqDomains[i]) 
        {
            //just check pending bits
            if (!pmbmapGetPending()->FTest(m_cDomains, pmbmapGetDomainBitmap(i)))
            {
                //Set Handled bits so no one else will try to deliver
                pmbmapGetHandled()->FTestAndSet(m_cDomains, pmbmapGetDomainBitmap(i));
            }

            //
            // Stop if we aren't searching for local domains (since we can
            // only have one match in that case).
            //
            if (!fLocal)
                break;
        }
    }
    return hr;
}   

//---[ CMsgRef::HrQueueAdminNDRMessage ]---------------------------------------
//
//
//  Description: 
//      Forcably NDRs a message for a given queue.
//  Parameters:
//      IN  pdmq    Queue to NDR message for
//  Returns:
//      S_OK on success
//  History:
//      12/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrQueueAdminNDRMessage(CDestMsgQueue *pdmq)
{
    HRESULT     hr = S_OK;
    CQuickList  qlst;
    CQuickList *pqlst = NULL;
    BOOL        fLocal = TRUE;
    DWORD       iListIndex = 0;
    DWORD       dwDSNFlags = 0;

    if (pdmq)
    {
        hr = qlst.HrAppendItem(pdmq, &iListIndex);
        if (FAILED(hr))
            goto Exit;

        pqlst = &qlst;
        fLocal = FALSE;

    }

    //Force NDR from this queue
    hr = HrSendDelayOrNDR(fLocal ? MSGREF_DSN_LOCAL_QUEUE : 0, 
                          pqlst, AQUEUE_E_NDR_ALL, 
                          &dwDSNFlags);

    if (FAILED(hr))
        goto Exit;
            
  Exit:
    return hr;
}   


//---[ CMsgRef::GlobalFreezeMessage ]------------------------------------------
//
//
//  Description: 
//      Freezes a message for all queues that it is on.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::GlobalFreezeMessage()
{
    dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MSG_FROZEN);
}

//---[ CMsgRef::GlobalFreezeMessage ]------------------------------------------
//
//
//  Description: 
//      Thaws a previously frozen messages.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/12/98 - MikeSwa Created 
//      2/17/2000 - MikeSwa Modified to move the kick of the DMQ up a level.
//
//-----------------------------------------------------------------------------
void CMsgRef::GlobalThawMessage()
{
    dwInterlockedUnsetBits(&m_dwDataFlags, MSGREF_MSG_FROZEN);
}


//---[ CMsgRef::RetryOnDelete ]------------------------------------------------
//
//
//  Description: 
//      Marks a message to retry on delete.  Basically, we hit an error
//      that requires retrying the message at a later time (i.e. - cannot 
//      allocate a queue page).  However, we cannot put the message into the
//      failed retry queue until all other threads are done accessing it.
//
//      This call will mark the MsgRef so that it will be retried after its
//      final release.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/19/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::RetryOnDelete()
{
    if (!(MSGREF_MSG_RETRY_ON_DELETE &
        dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MSG_RETRY_ON_DELETE)))
    {
        DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsPendingRetryOnDelete));
    }
}


//---[ CMsgRef::QueryInterface ]-----------------------------------------------
//
//
//  Description: 
//      QueryInterface for CMsgRef that supports:
//          - IUnknown
//          - CMsgRef
//
//      This is designed primarily to allow Queue Admin functionality to run
//      against a CMsgRef object as well a "true" COM interface like
//      IMailMsgProperties.
//  Parameters:
//
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CMsgRef::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<CMsgRef *>(this);
    }
    else if (IID_CMsgRef == riid)
    {
        *ppvObj = static_cast<CMsgRef *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ ReleaseAndBounceUsageOnMsgAck ]-----------------------------------------
//
//
//  Description: 
//      Decides if the message should be commited on the message ack.
//  Parameters:
//      DWORD       dwMsgStatus     Status of msg ack
//  Returns:
//      -
//  History:
//      7/6/99 - MikeSwa Created 
//      9/9/99 - Mikeswa Updated to be more aggressive about closing handles
//      10/27/1999 - MikeSwa Added code to delete handled messages
//
//-----------------------------------------------------------------------------
void CMsgRef::ReleaseAndBounceUsageOnMsgAck(DWORD dwMsgStatus)
{
    BOOL    fBounceUsage = FALSE;

    if (MESSAGE_STATUS_RETRY & dwMsgStatus)
    {
        //If this message was Ack'd retry... we should try an bounce the usage
        //count and close the associated handle.
        fBounceUsage = TRUE;
    }
    else if (g_cMaxIMsgHandlesThreshold < m_paqinst->cCountMsgsForHandleThrottling(m_pIMailMsgProperties))
    {
        //If we are over our alloted number of messages in the system, we should 
        //close the message even if was ACK'd OK.  The only time we don't want
        //to is if all domains have been handled.  In this case, we are about
        //to delete the message and usually do not want to commit it first. 
        if (!pmbmapGetHandled()->FAllSet(m_cDomains))
            fBounceUsage = TRUE;
        
    }

    //
    //  Release the usage count added by HrPrepareDelivery
    //  NOTE: This must come before the call to Bounce... or the 
    //  call to bounce usage will have no effect.  It must also 
    //  occur after the above call to cCountMsgsForHandleThrottling, 
    //  because it may request a property from the mailmsg.
    //
    InternalReleaseUsage();


    if (pmbmapGetHandled()->FAllSet(m_cDomains))
    {
        //There is are 2 known cases were the above could leave
        //the message handles open for a while.  In both cases, this message
        //must be queued to multiple DMQs on the same link, and be completely
        //delivered.  In one case, the message is dequeued during delivery and
        //sits on the retry queue until it is remerged.  In another case, the
        //message sits on the delivery queue until a thead pulls it off and 
        //discovers that it is already handled.  
        
        //To avoid this, we will mark the message for deletion when the 
        //intneral usage count drops to 0.
        MarkMailMsgForDeletion();
    }

    if (fMailMsgMarkedForDeletion())
    {
        //Force synchronous bounce usgage since delete should be much
        //quicker than commit
        SyncBounceUsageCount();
    }
    else if (fBounceUsage)
    {
        BounceUsageCount();
    }
}

//---[ CMsgRef::MarkMailMsgForDeletion ]---------------------------------------
//
//
//  Description: 
//      Sets the bit saying the that we are done with the mailmsg, and it 
//      should delete it the next time the usage count drops to 0.
//
//      To force deletion, the caller should bounce the usage count after
//      calling.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/26/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::MarkMailMsgForDeletion()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::MarkMailMsgForDeletion");
    DWORD   dwOrigFlags = 0;

    DebugTrace((LPARAM) this, 
        "Marking message with ID hash of 0x%x for deletion", m_dwMsgIdHash);

    dwOrigFlags = dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MAILMSG_DELETE_PENDING);

    //If we were the first thread to set this, then update the counters
    if (!(dwOrigFlags & MSGREF_MAILMSG_DELETE_PENDING))
    {
        InterlockedIncrement((PLONG) &s_cCurrentMsgsPendingDelete);
        InterlockedIncrement((PLONG) &s_cTotalMsgsPendingDelete);
    }
    
    _ASSERT(fMailMsgMarkedForDeletion());

    TraceFunctLeave();
}

//---[ CMsgRef::ThreadSafeMailMsgDelete ]--------------------------------------
//
//
//  Description: 
//      Used to make sure that calling thread is the only one that will call 
//      Delete() on the MailMsg.  Will set the MSGREF_MAILMSG_DELETED and call 
//      Delete().  Only called in ReleaseMailMsg() and InternalReleaseUsage().  
//
//      The caller is responsible for making sure that other threads are not 
//      reading the mailmsg or have a usage count.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/27/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
VOID CMsgRef::ThreadSafeMailMsgDelete()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::ThreadSafeMailMsgDelete");
    DWORD   dwOrigFlags = 0;
    HRESULT hr = S_OK;
    
    //Try to set the MSGREF_MAILMSG_DELETED.  
    dwOrigFlags = dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MAILMSG_DELETED);

    //If we are the first thread to set it, then we can Delete()
    if (!(dwOrigFlags & MSGREF_MAILMSG_DELETED))
    {
        hr = m_pIMailMsgQM->Delete(NULL);

        if (FAILED(hr))
            ErrorTrace((LPARAM) this, "Delete failed with hr 0x%08X", hr);

        //If this message was marked as pending delete, then update
        //the appropriate counters
        if (dwOrigFlags & MSGREF_MAILMSG_DELETE_PENDING)
        {
            InterlockedDecrement((PLONG) &s_cCurrentMsgsPendingDelete);
            InterlockedIncrement((PLONG) &s_cTotalMsgsDeletedAfterPendingDelete);
            InterlockedIncrement((PLONG) &s_cCurrentMsgsDeletedNotReleased);
        }
    }

    TraceFunctLeave();
}

//---[ CMsgRef::InternalAddUsage ]---------------------------------------------
//
//
//  Description: 
//      Wraps the mailmsg call to AddUsage.  Allows CMsgRef to call Delete() 
//      on the underlying mailmsg while there are still references to the
//      CMsgRef.
//      
//      Calling InternalAddUsage does not guarantee that there is backing
//      storage for the MailMsg.  Callers must call fMailMsgMarkedForDeletion()
//      *after* calling InternalAddUsage()
//
//      We do guarantee that if InternalAddUsage() is called and a then
//      subsequent call to fMailMsgMarkedForDeletion() returns TRUE, then 
//      the mailmsg will not be deleted until after the corresponding
//      call to InternalReleaseUsage();
//  Parameters:
//      -
//  Returns:
//      S_OK if the message is deleted and we did not call into mailmsg
//      Error/Success code from mailmsg if we called in.
//  History:
//      10/26/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::InternalAddUsage()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::InternalAddUsage");
    HRESULT hr = S_OK;

    InterlockedIncrement((PLONG) &m_cInternalUsageCount);

    if (!fMailMsgMarkedForDeletion() && m_pIMailMsgQM)
    {
        hr = m_pIMailMsgQM->AddUsage();
    }

    //If the call to AddUsage failed, we need to decrement our own count
    if (FAILED(hr))
    {
        InterlockedDecrement((PLONG) &m_cInternalUsageCount);
        ErrorTrace((LPARAM) this, "AddUsage failed 0x%0X", hr);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::InternalReleaseUsage ]-----------------------------------------
//
//
//  Description: 
//      Wraps the mailmsg call to ReleaseUsage.  Allows us to call Delete()
//      on the mailmsg while there are still references to this CMsgRef.
//
//      If MSGREF_MAILMSG_DELETE_PENDING is set but Delete() has not yet been 
//      called, this will call Delete() when the usage count hits 0.
//  Parameters:
//      -
//  Returns:
//      S_OK if the message is deleted and we did not call into mailmsg
//      Error/Success code from mailmsg if we called in.
//  History:
//      10/26/1999 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::InternalReleaseUsage()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::InternalReleaseUsage");
    HRESULT hr = S_OK;
    DWORD   dwOrigFlags = 0;
    
    //We need to call into mailmsg *before* we decrement the usage count. It is 
    //theoretically possible that this would cause an extra commit after we 
    //have decided to delete the message, but since we check right before 
    //calling the timing window is very small.
    if (m_pIMailMsgQM && !fMailMsgMarkedForDeletion())
        hr = m_pIMailMsgQM->ReleaseUsage();

    _ASSERT(m_cInternalUsageCount); //Should never go negative

    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ReleaseUsage failed - 0x%0X", hr);

    //If we have dropped the usage count to zero, then we need to check
    //and see if we need to call delete.  
    //The "at rest" value of m_cInternalUsageCount is 1, but BounceUsage 
    //(which calls this function) can cause it to drop to 0.
    if (0 == InterlockedDecrement((PLONG) &m_cInternalUsageCount))
    {
        //We need to be absolutely thread safe about calling delete.  Not only
        //do we need to ensure that a single thread calls Delete(), but we
        //also need to ensure that someone has not called InternalAddUsage()
        //before MSGREF_MAILMSG_DELETE_PENDING was set, but after the
        //above InterlockedDecrement() was called.  
        //
        //If we check for the MSGREF_MAILMSG_DELETE_PENDING before the 
        //aboved InterlockedDecrement, we can run into a timing window where 
        //the final InternalReleaseUsage does not detect that we need to delete 
        //the mailmsg.  
        //
        //To avoid these issues, we will check the m_cInternalUsageCount
        //again.  If it is still zero, then we will proceed, because we know
        //that the count hit zero after MSGREF_MAILMSG_DELETE_PENDING was set.
        //If the count is *not* currently zero, we know that a later thread
        //will release the usage count and hit this code path.
        if (fMailMsgMarkedForDeletion())
        {
            if (!m_cInternalUsageCount)
                ThreadSafeMailMsgDelete();
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::ShouldRetry ]--------------------------------------------------
//
//
//  Description: 
//      Determines if we should retry this message if an error occurs.  Will
//      return FALSE if we *know* that the backing store has been deleted.
//  Parameters:
//      -
//  Returns:
//      TRUE if we should rety the message
//      FALSE, the backing store for the message is gone... drop it
//  History:
//      1/6/2000 - MikeSwa Created 
//      4/12/2000 - MikeSwa modified to call CAQSvrInst member
//
//-----------------------------------------------------------------------------
BOOL CMsgRef::fShouldRetry()
{
    IMailMsgProperties *pIMailMsgProperties = m_pIMailMsgProperties;

    if (pIMailMsgProperties && m_paqinst)
        return m_paqinst->fShouldRetryMessage(pIMailMsgProperties, FALSE);
    else
        return FALSE;
}


//---[ CMsgRef::GetStatsForMsg ]-----------------------------------------------
//
//
//  Description: 
//      Fills in a CAQStats for this message
//  Parameters:
//      IN OUT  paqstat         Stats to fill in
//  Returns:
//      NULL
//  History:
//      1/15/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::GetStatsForMsg(IN OUT CAQStats *paqstat)
{
    _ASSERT(paqstat);
    paqstat->m_cMsgs = 1;
    paqstat->m_rgcMsgPriorities[PriGetPriority()] = 1;
    paqstat->m_uliVolume.QuadPart = (ULONGLONG) dwGetMsgSize();
    paqstat->m_dwHighestPri = PriGetPriority();
}

//---[ CMsgRef::MarkQueueAsLocal ]---------------------------------------------
//
//
//  Description: 
//      Marks a given DMQ as local.  This is used in the gateway delivery 
//      path to prevent messages from being lost if a reroute happens after
//      it has been moved to the local delivery queue. 
//  Parameters:
//      pdmq            Queue to mark as local for this message
//  Returns:
//      -
//  History:
//      2/17/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::MarkQueueAsLocal(IN CDestMsgQueue *pdmq)
{
    DWORD i = 0;

    //
    //Search for matching queue
    //
    for (i = 0; i < m_cDomains; i++)
    {
        if (pdmq == m_rgpdmqDomains[i])
        {
            //
            //  Exact match found.  Set pointer to NULL and release it. 
            //  The caller (CLinkMsgQueue) should still have a reference to 
            //  the queue.
            //
            if (InterlockedCompareExchangePointer((void **) &m_rgpdmqDomains[i], NULL, pdmq) == (void *) pdmq)
                pdmq->Release();

            return;
        }
    }
    _ASSERT(0 && "Requested DMQ not found!!!!");
}


//---[ CountMessageInRemoteTotals ]--------------------------------------------
//
//
//  Description: 
//      Count this message in the totals for remote messages.  This means that
//      we need to decrement the count when this message is released.
//      
//      There is no exactly equivalent local count.  The counters for local 
//      delivery has based on queue length and can have multiple counts per
//      message object (as can some of the remote counts as well).
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/28/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CMsgRef::CountMessageInRemoteTotals()
{
    dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MSG_COUNTED_AS_REMOTE);
}


//---[ CMsgRef::HrPromoteMessageStatusToMailMsg ]------------------------------
//
//
//  Description: 
//      Promotes extended status from MessageAck to mailmsg recipient property
//      if there is not already specific information there.  
//  Parameters:
//      pdcntxt     Delivery context for this message
//      pMsgAck     Ptr to MessageAck structure for this message
//  Returns:
//      S_OK on success
//  History:
//      3/20/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrPromoteMessageStatusToMailMsg(CDeliveryContext *pdcntxt, 
                                                 MessageAck *pMsgAck)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrPromoteMessageStatusToMailMsg");
    HRESULT hr = S_OK;
    HRESULT hrRecipStatus = S_OK;
    HRESULT hrTmp = S_OK;
    RECIPIENT_FILTER_CONTEXT rpfctxt;
    BOOL    fContextInit = FALSE;
    DWORD   iCurrentRecip = 0;
    DWORD   dwProp = 0; //place holder for recipient status property
    LPSTR   szExtendedStatus = NULL;
    DWORD   dwRecipMask = RP_DSN_HANDLED |              // No DSN generated
                          RP_DSN_NOTIFY_NEVER |         // NOTIFY!=NEVER
                          (RP_DELIVERED ^ RP_HANDLED);  // Not delivered
    DWORD   dwRecipFlags = 0;


    _ASSERT(pdcntxt);
    _ASSERT(pMsgAck);
    _ASSERT(m_pIMailMsgRecipients);

    //
    //  If we have no extended status, then there is nothing for us to do
    //  
    if (!(pMsgAck->dwMsgStatus & MESSAGE_STATUS_EXTENDED_STATUS_CODES) ||
        !pMsgAck->cbExtendedStatus ||
        !pMsgAck->szExtendedStatus)
    {
        DebugTrace((LPARAM) this, "No extended status codes in MessageAck");
        goto Exit;
    }

    //
    //  If this was actually not a protocol error, SMTP may not have put
    //  the full status codes on it.  Instead of "250 2.0.0 OK" it may 
    //  have just put "OK".  We should not write this to mailmsg as is, but 
    //  should instead fix up string so it is what the DSN sink expects.
    //
    hr = HrUpdateExtendedStatus(pMsgAck->szExtendedStatus, &szExtendedStatus);
    if (FAILED(hr)) 
    {
        ErrorTrace((LPARAM) this, 
            "Unable to get etended status from %s - hr 0x%08X", 
            pMsgAck->szExtendedStatus, hr);
        hr = S_OK; //non-fatal error... eat it
        goto Exit;
    }

    //
    //  Initialize recipient filter context so we can iterate over the
    //  recipients
    //
    hr = m_pIMailMsgRecipients->InitializeRecipientFilterContext(&rpfctxt, 
                                    pdcntxt->m_dwStartDomain, dwRecipFlags, 
                                    dwRecipMask);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, 
            "InitializeRecipientFilterContext failed with 0x%08X", hr);
        goto Exit;
    }

    fContextInit = TRUE;
    DebugTrace((LPARAM) this, 
        "Init recip filter context with mask 0x%08X and flags 0x%08X and domain %d",
        dwRecipMask, dwRecipFlags, pdcntxt->m_dwStartDomain);

    //
    //  Loop over each recipient and update their properties if needed
    //
    for (hr = m_pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
         SUCCEEDED(hr);
         hr = m_pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip))
    {
        DebugTrace((LPARAM) this, "Looking at recipient %d", iCurrentRecip);
        //
        //  See if we have an HRESULT... if it *is* there and is a failure 
        //  then continue on to the next recipient
        //
        hrRecipStatus = S_OK;
        hr = m_pIMailMsgRecipients->GetDWORD(iCurrentRecip, 
                IMMPID_RP_ERROR_CODE, (DWORD *) &hrRecipStatus);
        if (SUCCEEDED(hr) && FAILED(hrRecipStatus))
        {
            DebugTrace((LPARAM) this, 
                "Recipient %d already has a status of 0x%08X", 
                iCurrentRecip, hrRecipStatus);
            continue;
        }
 

        //
        //  Check for existing status property
        //
        hr = m_pIMailMsgRecipients->GetDWORD(iCurrentRecip, 
                IMMPID_RP_SMTP_STATUS_STRING, &dwProp);
        if (MAILMSG_E_PROPNOTFOUND != hr)
        {
            DebugTrace((LPARAM) this,
                "Recipient %d has a status string (hr 0x%08X)", 
                iCurrentRecip, hr);
            continue;
        }

        //
        //  There is no detailed information on the recipient.  We should
        //  promote the extended status from the message ack to the recipient
        //
        hr = m_pIMailMsgRecipients->PutStringA(iCurrentRecip,
                 IMMPID_RP_SMTP_STATUS_STRING, szExtendedStatus);
        if (FAILED(hr)) 
        {
            ErrorTrace((LPARAM) this, 
                "Unable to write %s to recip %d - hr 0x%08X", 
                szExtendedStatus, iCurrentRecip, hr);
            goto Exit;
        }
        DebugTrace((LPARAM) this, 
            "Wrote extended status %s to recip %d", 
            szExtendedStatus, iCurrentRecip);
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;  //we just reached the end of the context

  Exit:
    //
    //  Terminate context if init was called
    //
    if (fContextInit) 
    {
        hrTmp = m_pIMailMsgRecipients->TerminateRecipientFilterContext(&rpfctxt);
        if (FAILED(hrTmp))
        {
            ErrorTrace((LPARAM) this, 
                "TerminateRecipientFilterContext failed 0x%08X", hr);
        }
    }

    TraceFunctLeave();
    return hr;
}

//
//  These are strings defined in smtpcli.hxx that are used in smtpout.cxx
//  in calls to m_ResponseContext.m_cabResponse.Append().  These strings 
//  are not in the normal protocol format of "xxx x.x.x Error string"
//  
//      g_cNumExtendedStatusStrings     Number of hard-coded strings
//      g_rgszSMTPExtendedStatus        SMTP extended status
//      g_rgszSMTPUpdatedExtendedStatus Full protocol strings.
//  
const DWORD g_cNumExtendedStatusStrings = 4;
const CHAR  g_rgszSMTPExtendedStatus[g_cNumExtendedStatusStrings][200] = {
    "Msg Size greater than allowed by Remote Host",
    "Body type not supported by Remote Host",
    "Failed to authenticate with Remote Host",
    "Failed to negotiate secure channel with Remote Host",
};

const CHAR  g_rgszSMTPUpdatedExtendedStatus[g_cNumExtendedStatusStrings][200] = {
    "450 5.2.3 Msg Size greater than allowed by Remote Host",
    "554 5.6.1 Body type not supported by Remote Host",
    "505 5.7.3 Failed to authenticate with Remote Host",
    "505 5.7.3 Failed to negotiate secure channel with Remote Host",
};


//---[ CMsgRef::HrUpdateExtendedStatus ]---------------------------------------
//
//
//  Description: 
//      Sometime SMTP is lazy about returning actual protocol-complient
//      strings for internal errors.  If this is not a valid status string, 
//      then we should check against the strings that we know SMTP generates
//      and make it a protocol string that can be used in DSN generation.
//
//  Parameters:
//      IN  szCurrentStatus     current status
//      OUT pszNewStatus        New protcol friendly status string.  This
//                              is a const that does not need to be freed
//  Returns:
//      S_OK on succcess
//      E_FAIL when we cannot extract a protocol string from the
//          extended status string.
//  History:
//      3/20/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrUpdateExtendedStatus(LPSTR szCurrentStatus,
                                     LPSTR *pszNewStatus)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrUpdateExtendedStatus");
    HRESULT hr = S_OK;
    DWORD   iCurrentExtendedStatus = 0;

    _ASSERT(szCurrentStatus);
    _ASSERT(pszNewStatus);

    *pszNewStatus = szCurrentStatus;

    //
    //  If it starts with a 2 4 or 5, then we know it is not one of the
    //  non-protocol strings
    //
    if (('2' == *szCurrentStatus) || 
        ('4' == *szCurrentStatus) || 
        ('5' == *szCurrentStatus))
    {
        DebugTrace((LPARAM) this, 
            "Status %s is already in protocol format", szCurrentStatus);
        goto Exit;
    }

    //
    //  check against all well-known status
    //
    for (iCurrentExtendedStatus = 0; 
         iCurrentExtendedStatus < g_cNumExtendedStatusStrings;
         iCurrentExtendedStatus++)
    {
        if (0 == lstrcmpi(szCurrentStatus, g_rgszSMTPExtendedStatus[iCurrentExtendedStatus]))
        {
            *pszNewStatus = (CHAR *) g_rgszSMTPUpdatedExtendedStatus[iCurrentExtendedStatus];
            DebugTrace((LPARAM) this, "Updating to status \"%s\" from status \"%s\"",
                szCurrentStatus, *pszNewStatus);

            //
            //  Our strings should match (modulo the new prefix)
            //
            _ASSERT(0 == lstrcmpi(szCurrentStatus, *pszNewStatus + sizeof("xxx x.x.x")));
            goto Exit;
        }
    }

    hr = E_FAIL;
  Exit:
    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\intrnlqa.h $(O)\intrnlqa_i.c : intrnlqa.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\intrnlqa_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\intrnlqa_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqadmin.h $(O)\aqadmin_i.c : $(STAXINC)\export\aqadmin.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqadmin_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqadmin_i.c \
    -header $@ \
    -tlb $(O)\aqadmin.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqadmrpc.h $(O)\aqadmrpc_s.c : ..\inc\aqadmrpc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -client none \
    -sstub $(O)\aqadmrpc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqmsg.h $(O)\aqmsg.rc $(O)\aqmsg.bin: $(STAXINC)\export\aqerr.mc $(STAXINC)\export\caterr.mc $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\aqerr.mc + /a $(STAXINC)\export\caterr.mc + /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqmsg.rc
    del  $(O)\tmp.rc
	copy $(O)\msg00001.bin $(O)\aqmsg.bin

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00003.bin: ..\..\server\smtpmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a ..\..\server\smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\ntpch.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ntpch.cpp
//
//  Description:  NT PCH File - Includes the real .cpp file.  This lets us
//                 generate a seperate obj file to satisfy the NT build env.
//
//
//-----------------------------------------------------------------------------

#include <aqprecmp.h>

#include "aqprecmp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgguid.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: msgguid.cpp
//
//  Description: Implementation of AQMsgGuidList and CAQMsgGuidListEntry
//      classes which provide the functionality to supersede outdated
//      msg ID's.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/10/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "msgguid.h"

CPool CAQMsgGuidListEntry::s_MsgGuidListEntryPool(MSGGUIDLIST_ENTRY_SIG);
//
//  A brief note about locks for thess classes.
//
//  The CAMsgGuidList* classes are protected by a single per-virtual server
//  ShareLock (m_slPrivateData of course).  These locks are non-reentrant, so
//  it is critical that we do not hold these locks while doing something that
//  may cause a locking call back into us (like releasing a CMsgReference).
//

//---[ CAQMsgGuidListEntry::CAQMsgGuidListEntry ]------------------------------
//
//
//  Description: 
//      Constructor for CAQMsgGuidListEntry
//  Parameters:
//      pmsgref         Ptr to CMsgRef for this ID
//      pguid           GUID ID of this message
//      pliHead         Head of list to add to
//      pmgl            List this entry belongs to
//  Returns:
//      -
//  History:    
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry::CAQMsgGuidListEntry(CMsgRef *pmsgref, GUID *pguid, 
                                         PLIST_ENTRY pliHead, CAQMsgGuidList *pmgl) 
{
    _ASSERT(pmsgref);
    _ASSERT(pguid);
    _ASSERT(pmgl);
    _ASSERT(pliHead);

    m_dwSignature = MSGGUIDLIST_ENTRY_SIG;
    m_pmsgref = pmsgref;
    m_pmsgref->AddRef();
    m_pmgl = pmgl;

    memcpy(&m_guidMsgID, pguid, sizeof(GUID));

    InsertHeadList(pliHead, &m_liMsgGuidList);
}


//---[ CAQMsgGuidListEntry::~CAQMsgGuidListEntry ]-----------------------------
//
//
//  Description: 
//      Destructor for CAQMsgGuidListEntry
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry::~CAQMsgGuidListEntry()
{
    //we should not still be in a list
    _ASSERT(!m_liMsgGuidList.Flink);
    _ASSERT(!m_liMsgGuidList.Blink);

    m_dwSignature = MSGGUIDLIST_ENTRY_SIG_INVALID;

    //It is safe to release the message ref here, since there is no way it 
    //can call back into use (unless there is a ref-counting bug).
    if (m_pmsgref)
        m_pmsgref->Release();

    m_pmgl = NULL;
}

//---[ CAQMsgGuidListEntry::pmgleGetEntry ]------------------------------------
//
//
//  Description: 
//      Static function to get entry from LIST_ENTRY
//
//      NOTE: inline function for use by CAQMsgGuidList only
//  Parameters:
//      pli         LIST ENTRY
//  Returns:
//      pointer to associated CAQMsgGuidListEntry
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry *CAQMsgGuidListEntry::pmgleGetEntry(PLIST_ENTRY pli)
{
    _ASSERT(pli);
    CAQMsgGuidListEntry *pmgle = CONTAINING_RECORD(pli, 
                CAQMsgGuidListEntry, m_liMsgGuidList);
    ASSERT(pmgle->m_dwSignature == MSGGUIDLIST_ENTRY_SIG);
    return pmgle;
}
    
//---[ CAQMsgGuidListEntry::fCompareGuid ]-------------------------------------
//
//
//  Description: 
//      Function used by CAQMsgGuidList to determine if this has a the GUID
//      matching the superseded ID.
//
//      NOTE: inline function for use by CAQMsgGuidList only
//  Parameters:
//      pguid       GUID to check against
//  Returns:
//      TRUE if they match
//      FALSE otherwise
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAQMsgGuidListEntry::fCompareGuid(GUID *pguid)
{
    _ASSERT(pguid);
    return (0 == memcmp(pguid, &m_guidMsgID, sizeof(GUID)));
}

//---[ CAQMsgGuidListEntry::RemoveFromList ]-----------------------------------
//
//
//  Description: 
//      Used by CMsgRef to remove an entry from the list once delivery is 
//      complete.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidListEntry::RemoveFromList()
{
    _ASSERT(m_pmgl);
    m_pmgl->RemoveFromList(&m_liMsgGuidList);
}

//---[ CAQMsgGuidListEntry::pmsgrefGetAndClearMsgRef ]-------------------------
//
//
//  Description: 
//      First phase shutdown/deletion of object. Will set to NULL and return 
//      orginal msgref pointer.  When caller releases lock, they should release
//      the returned msgref.
// 
//      NOTE: Releasing the msgref while holding onto m_slPrivateData can 
//      lead to a deadlock.  m_slPrivateData should be held while this 
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CMsgRef *CAQMsgGuidListEntry::pmsgrefGetAndClearMsgRef()
{
    CMsgRef *pmsgref = m_pmsgref;
    m_pmsgref = NULL;
    return pmsgref;
}

//---[ CAQMsgGuidListEntry::SupersedeMsg ]-------------------------------------
//
//
//  Description: 
//      Function to supersede msg associated with this object.  Will flag the
//      associated CMsgRef as "non-deliverable"
//
//      NOTE: Should have MsgGuidList Write lock when calling
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidListEntry::SupersedeMsg()
{
    m_pmsgref->SupersedeMsg();
    m_pmsgref->Release();
    m_pmsgref = NULL;
}

//---[ CAQMsgGuidList::CAQMsgGuidList ]-----------------------------------------
//
//
//  Description: 
//      Constructor for CAQMsgGuidList.
//  Parameters:
//      pcSupersededMsgs        Ptr to DWORD to InterlockedIncrement for
//                              a count of superseded messages.
//                              (can be NULL if no counters are wanted)
//  Returns:
//      -
//  History:    
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidList::CAQMsgGuidList(DWORD *pcSupersededMsgs)
{
    m_dwSignature = MSGGUIDLIST_SIG;
    m_pcSupersededMsgs = pcSupersededMsgs;
    InitializeListHead(&m_liMsgGuidListHead);
}

//---[ CAQMsgGuidList::~CAQMsgGuidList ]---------------------------------------
//
//
//  Description: 
//      Desctructor for CAQMsgGuidList
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQMsgGuidList::~CAQMsgGuidList()
{
    Deinitialize(NULL);
    _ASSERT(IsListEmpty(&m_liMsgGuidListHead));
}

//---[ CAQMsgGuidList::pmgleAddMsgGuid ]---------------------------------------
//
//
//  Description: 
//      Adds a message ID/Msg to the list of msg GUIDs.  Will also search for 
//      the superseded msg GUID ID from the tail of the list.
//
//      This is meant as a server-side optimization.  There is *no* attempt
//      to recover from out of memory situations.
//  Parameters:
//      pmsgref             MsgRef associated with this ID
//      pguidID             GUID ID of this message
//      pguidSuperseded     GUID ID of message superseded by this message
//      
//  Returns:
//      Pointer to list entry for this msg (caller *must* Release)
//      NULL if no entry allocated
//  History:
//      10/11/98 - MikeSwa Created 
//      05/08/99 - MikeSwa Fixed AV 
//
//-----------------------------------------------------------------------------
CAQMsgGuidListEntry *CAQMsgGuidList::pmgleAddMsgGuid(CMsgRef *pmsgref, 
                                                     GUID *pguidID, 
                                                     GUID *pguidSuperseded)
{
    _ASSERT(pmsgref);
    _ASSERT(pguidID);
    CAQMsgGuidListEntry *pmgle = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    CMsgRef *pmsgrefSuperseded = NULL;

    //First search list for matching GUID
    m_slPrivateData.ShareLock();
    pliCurrent = m_liMsgGuidListHead.Blink;
    while (pliCurrent && (pliCurrent != &m_liMsgGuidListHead))
    {
        pmgle = CAQMsgGuidListEntry::pmgleGetEntry(pliCurrent);
        if (pguidSuperseded && pmgle->fCompareGuid(pguidSuperseded))
        {
            //we found a match... addref it and stop looking
            pmgle->AddRef();
            break;
        }

        //NOTE: We may want to consider adding functionality that 
        //would allow us to supersede messages that are added to the 
        //system later... if some layer of abstaction (like the pickup dir)
        //causes out of order submission, this would allow us to handle
        //that case.  It could require:
        //  - Additional check of current ID against all superseded ID's (2x cost)
        //  - Additional storage of original superseded ID's.

        pmgle = NULL;
        pliCurrent = pliCurrent->Blink;
    }
    m_slPrivateData.ShareUnlock();

    m_slPrivateData.ExclusiveLock();
    if (pmgle)
    {
        //make sure someone else hasn't removed it from the list
        if (pliCurrent->Blink && pliCurrent->Flink)
        {
            //If we found a match supersede
            if (m_pcSupersededMsgs)
                InterlockedIncrement((PLONG) m_pcSupersededMsgs);
            pmgle->SupersedeMsg();
            RemoveEntryList(pliCurrent);
            pliCurrent->Flink = NULL;
            pliCurrent->Blink = NULL;

            pmsgrefSuperseded = pmgle->pmsgrefGetAndClearMsgRef();
            //Release once for entry in list, and once for AddRef above
            _VERIFY(pmgle->Release());
            pmgle->Release();
        }
    }

    pmgle = new CAQMsgGuidListEntry(pmsgref, pguidID, &m_liMsgGuidListHead, this);
    if (pmgle)
        pmgle->AddRef();

    m_slPrivateData.ExclusiveUnlock();

    if (pmsgrefSuperseded)
        pmsgrefSuperseded->Release();

    return pmgle;
}

//---[ CAQMsgGuidList::Deinitialize ]------------------------------------------
//
//
//  Description: 
//      Walks list and released all msg id objects.  Calls server stop hint 
//      function if provided.
//  Parameters:
//      painst      Ptr to virtual server object to call stop hint function
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidList::Deinitialize(CAQSvrInst *paqinst)
{
    PLIST_ENTRY pliCurrent = NULL;
    CAQMsgGuidListEntry *pmgle = NULL;
    CMsgRef *pmsgref = NULL;

    m_slPrivateData.ExclusiveLock();

    //Walk entire list and release all objects
    while (!IsListEmpty(&m_liMsgGuidListHead))
    {
        pliCurrent = m_liMsgGuidListHead.Flink;
        _ASSERT(pliCurrent);
        pmgle = CAQMsgGuidListEntry::pmgleGetEntry(pliCurrent);
        _ASSERT(pmgle);
        RemoveEntryList(pliCurrent);
        pliCurrent->Flink = NULL;
        pliCurrent->Blink = NULL;
    
        //we must unlock to Deinitalize and release won't deadlock
        m_slPrivateData.ExclusiveUnlock();
        //Send shutdown hint
        if (paqinst)
            paqinst->ServerStopHintFunction();

        pmsgref = pmgle->pmsgrefGetAndClearMsgRef();
        if (pmsgref)
            pmsgref->Release();

        pmgle->Release();

        //Lock so we can check if list is empty
        m_slPrivateData.ExclusiveLock();
    }
    m_slPrivateData.ExclusiveUnlock();
}

//---[ CAQMsgGuidList::RemoveFromList ]----------------------------------------
//
//
//  Description: 
//      Used by a CAQMsgGuidListEntry to remove itself from the list in a 
//      thread-safe manner.  The CAQMsgGuidListEntry is called by the CMsgRef
//      when it is completely handled.
//  Parameters:
//      pli         PLIST_ENTRY to remove from list
//  Returns:
//      -
//  History:
//      10/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQMsgGuidList::RemoveFromList(PLIST_ENTRY pli)
{
    _ASSERT(pli);
    CAQMsgGuidListEntry *pmgle = CAQMsgGuidListEntry::pmgleGetEntry(pli);
    CMsgRef *pmsgref = NULL;
    m_slPrivateData.ExclusiveLock();

    if (pli->Flink && pli->Blink)
    {
        //Only remove from list once
        RemoveEntryList(pli);
        pli->Flink = NULL;
        pli->Blink = NULL;
        pmsgref = pmgle->pmsgrefGetAndClearMsgRef();
        //Caller must still have reference
        _VERIFY(pmgle->Release());
    }
    m_slPrivateData.ExclusiveUnlock();

    //Do not release while holding lock
    if (pmsgref)
        pmsgref->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\propstrm.h ===
//----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  Module:  rwstream.h
//
//  Description:  Contains definition of the read only / write only 
//                mailmsg property stream in epoxy shared memory.
//
//      10/20/98 - MaheshJ Created 
//      8/17/99 - MikeSwa Modified to use files instead of shared memory 
//----------------------------------------------------------------------------

#ifndef __PROPSTRM_H__
#define __PROPSTRM_H__

#define     FILE_PROPERTY_STREAM        'mrtS'
#define     FILE_PROPERTY_STREAM_FREE   'mtS!'

//---[ CFilePropertyStream ]--------------------------------------------------
//
//
//  Description: 
//      Implementation of IMailMsgPropertyStream that saves property
//      stream to a file
//  Hungarian: 
//      fstrm, pfstrm
//  
//-----------------------------------------------------------------------------
class CFilePropertyStream :
    public CBaseObject,
	public IMailMsgPropertyStream
{
public:
    CFilePropertyStream();
    ~CFilePropertyStream();

    HRESULT HrInitialize(LPSTR szFileName);

	//
	// IUnknown
	//
	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

    ULONG STDMETHODCALLTYPE AddRef() {return CBaseObject::AddRef();};

    ULONG STDMETHODCALLTYPE Release() {return CBaseObject::Release();};

	//
	// IMailMsgPropertyStream
	//
	HRESULT STDMETHODCALLTYPE GetSize(
                IMailMsgProperties *pMsg,
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadBlocks(
                IMailMsgProperties *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE WriteBlocks(
                IMailMsgProperties *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

    HRESULT STDMETHODCALLTYPE StartWriteBlocks(
                IMailMsgProperties *pMsg,
                DWORD dwBlocksToWrite,
				DWORD dwTotalBytesToWrite
                );
	
	HRESULT STDMETHODCALLTYPE EndWriteBlocks(IN IMailMsgProperties *pMsg);

    HRESULT STDMETHODCALLTYPE CancelWriteBlocks(IMailMsgProperties *pMsg);

private:
    DWORD   m_dwSignature;
    HANDLE  m_hDestFile;
};

#endif //__PROPSTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiklist.cpp ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.cpp
//
//	Description:  Implementation of CQuickList
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/98 - MikeSwa Created 
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "qwiklist.h"

CPool CQuickList::s_QuickListPool;

//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description: 
//      Default contructor for CQuikList... initializes as head of list
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG;

    //ASSERT constants 
    _ASSERT(!(~QUICK_LIST_INDEX_MASK & QUICK_LIST_PAGE_SIZE));
    _ASSERT((~QUICK_LIST_INDEX_MASK + 1)== QUICK_LIST_PAGE_SIZE);
    m_dwCurrentIndexStart = 0;
    InitializeListHead(&m_liListPages);
    m_cItems = 0;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
}


//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description: 
//      Constructor for QQuickList, inserts it into the tail of current list
//  Parameters:
//
//  Returns:
//
//  History:
//      6/15/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList(CQuickList *pqlstHead)
{
    _ASSERT(pqlstHead);
    _ASSERT(pqlstHead->m_liListPages.Blink);
    CQuickList *pqlstTail = CONTAINING_RECORD(pqlstHead->m_liListPages.Blink, CQuickList, m_liListPages);
    _ASSERT(QUICK_LIST_SIG == pqlstTail->m_dwSignature);
    m_dwSignature = QUICK_LIST_SIG;
    m_dwCurrentIndexStart = pqlstTail->m_dwCurrentIndexStart + QUICK_LIST_PAGE_SIZE;
    m_cItems = QUICK_LIST_LEAF_PAGE;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
    InsertTailList(&(pqlstHead->m_liListPages), &m_liListPages);
}


//---[ CQuickList::~CQuickList ]-----------------------------------------------
//
//
//  Description: 
//      CQuickList destructor
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CQuickList::~CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG_DELETE;
    CQuickList *pqlstCurrent = NULL;
    CQuickList *pqlstNext = NULL;
    if (QUICK_LIST_LEAF_PAGE != m_cItems)
    {
        //head node... loop through every thing and delete leaf pages
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Flink, 
                        CQuickList, m_liListPages);
        while (this != pqlstCurrent)
        {
            pqlstNext = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, 
                        CQuickList, m_liListPages);
            delete pqlstCurrent;
            pqlstCurrent = pqlstNext;
        }
    }
}


//---[ CQuickList::pvGetItem ]-------------------------------------------------
//
//
//  Description: 
//      Looks up item at given index
//  Parameters:
//      IN     dwIndex      Index of item to lookup
//      IN OUT ppvContext   Context for speeding up lookup
//  Returns:
//      Value of item at index
//      NULL if index is out of ranges
//  History:
//      6/15/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
PVOID CQuickList::pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext)
{
    _ASSERT(ppvContext);
    PVOID pvReturn = NULL;
    BOOL  fSearchForwards = TRUE;
    DWORD dwForwardDist = 0;
    DWORD dwBackwardDist = 0;
    DWORD dwMaxStartingIndex = m_cItems & QUICK_LIST_INDEX_MASK;
    CQuickList *pqlstDirection = NULL;
    CQuickList *pqlstCurrent = (CQuickList *) *ppvContext;
    CQuickList *pqlstSentinal = NULL;
    DWORD cDbgItems = m_cItems;

    if (dwIndex >= m_cItems)
        return NULL;

    if (!pqlstCurrent)
        pqlstCurrent = this;

    pqlstSentinal = pqlstCurrent;

    //short circuit direction logic
    if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
    {
        pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
        *ppvContext = pqlstCurrent;
        _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
        goto Exit;
    }

    //determine which direction to go in (we want to traverse the smallest # of pages
    //possible
    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwForwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwForwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwBackwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwBackwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    //fix up distances to account for going through the 0th page
    //max distance is dwMaxStartingIndex/2
    if (dwBackwardDist > dwMaxStartingIndex/2)
        dwBackwardDist -= dwMaxStartingIndex;
        
    if (dwForwardDist > dwMaxStartingIndex/2)
        dwForwardDist -= dwMaxStartingIndex;

    if (dwForwardDist > dwBackwardDist)
        fSearchForwards = FALSE;

    //$$NOTE: current lookup time is O(lg base{QUICK_LIST_PAGE_BASE} (n))/2. 
    //Consecutive lookups will be O(1) (because of the hints)
    do 
    {
        if (fSearchForwards)  
        {
            //going forward is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
        }
        else
        {
            //going backwards is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
        }
        
        _ASSERT(QUICK_LIST_SIG == pqlstCurrent->m_dwSignature);
        if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
        {
            pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
            _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
            break;
        }

    } while (pqlstSentinal != pqlstCurrent); //stop when we return to list head

    *ppvContext = pqlstCurrent;
    _ASSERT((cDbgItems == m_cItems) && "Non-threadsafe access to CQuickList");

  Exit:
    return pvReturn;
}

//---[ CQuickList::pvDeleteItem ]----------------------------------------------
//
//
//  Description: 
//      Will remove item at a given index from the quick list.
//
//      If you need to determine the data at that has been moved into this 
//      index, call pvGetItem with the returned context, and it will return
//      without needing to search.
//  Parameters:
//      IN     dwIndex      Index of item to lookup
//      IN OUT ppvContext   Context for speeding up lookup
//  Returns:
//      Value of item that was removed.
//      NULL if index is out of ranges
//  History:
//      9/10/98 - MikeSwa Created 
//      11/5/98 - MikeSwa Fixed problem about not always marking deleted 
//                entry NULL.
//
//-----------------------------------------------------------------------------
PVOID CQuickList::pvDeleteItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext)
{
    PVOID pvItem = NULL;
    PVOID pvLast = NULL; //last item in list
    CQuickList *pqlstCurrent = NULL;  //page that index is on
    CQuickList *pqlstLast = NULL;     //last page
    DWORD dwLastIndex = m_cItems - 1;

    //Check to make sure that the index is valid
    if (dwIndex >= m_cItems)
        goto Exit;

    //Use single function to look up index and find quick list page
    pvItem = pvGetItem(dwIndex, (PVOID *) &pqlstCurrent);

    _ASSERT(pvItem); //we checked the index... and we cannot insert NULL ptrs
    _ASSERT(QUICK_LIST_SIG == pqlstCurrent->m_dwSignature);
    _ASSERT(pqlstCurrent->fIsIndexOnThisPage(dwIndex));

    //Now that we know the index and the page... we can move that last
    //entry in the list to this index.
    pqlstLast = CONTAINING_RECORD(m_liListPages.Blink, CQuickList, m_liListPages);
    _ASSERT(QUICK_LIST_SIG == pqlstLast->m_dwSignature);
    _ASSERT(pqlstLast->fIsIndexOnThisPage(dwLastIndex));
    if (dwLastIndex != dwIndex)
    {
        //In general if we are not deleting the last entry... we need to move
        //the last entry to the current index
         pvLast = pqlstLast->m_rgpvData[dwLastIndex & ~QUICK_LIST_INDEX_MASK];
         _ASSERT(pvLast); //shouldn't be NULL!

         //Now that we have last item... write it!
         pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK] = pvLast;

         //NULL the old last entry
        pqlstLast->m_rgpvData[dwLastIndex & ~QUICK_LIST_INDEX_MASK] = NULL;
    }
    else 
    {
        //if we deleted that last entry... the current and last pages 
        //should be the same
        _ASSERT(pqlstLast == pqlstCurrent);

        //Set emptied data pointer to NULL
        pqlstLast->m_rgpvData[dwLastIndex & ~QUICK_LIST_INDEX_MASK] = NULL;
    }

    //Decrement total count
    m_cItems--;
    _ASSERT(QUICK_LIST_LEAF_PAGE != m_cItems);

    //Determine if it is neccessary to delete the last page
    if (!(dwLastIndex & ~QUICK_LIST_INDEX_MASK) && m_cItems)
    {
        //dwLastIndex was the only entry on the last page & it wasn't the head page

        //Unless the above test is wrong... the last page is *not* the head page
        _ASSERT(QUICK_LIST_LEAF_PAGE == pqlstLast->m_cItems);
        _ASSERT(this != pqlstLast);

        //Remove from list
        RemoveEntryList(&(pqlstLast->m_liListPages));

        if (pqlstCurrent == pqlstLast) //we cannot return a deleted context
            pqlstCurrent = this;

        delete pqlstLast;
    }
  
    //Safety check to make sure another thread hasn't come along 
    _ASSERT(m_cItems == dwLastIndex);

  Exit:
    if (ppvContext)
        *ppvContext = pqlstCurrent;

    return pvItem;
}

//---[ CQuickList::HrAppendItem ]-----------------------------------------------
//
//
//  Description: 
//      Appends new data item to end of array
//  Parameters:
//      IN  pvData      - Data to insert
//      OUT pdwIndex    - Index data was inserted at
//  Returns:
//      E_OUTOFMEMORY if unable to allocate another page
//      E_INVALIDARG if pvData is NULL
//  History:
//      6/15/98 - MikeSwa Created 
//      9/9/98 - MikeSwa - Added pdwIndex OUT param
//
//-----------------------------------------------------------------------------
HRESULT CQuickList::HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    CQuickList *pqlstCurrent = NULL;

    _ASSERT(pvData && "Cannot insert NULL pointers");

    if (!pvData)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (m_cItems && !(m_cItems & ~QUICK_LIST_INDEX_MASK)) //on page boundary
    {
        //there is not room on the last page
        pqlstCurrent = new CQuickList(this);
        if (!pqlstCurrent)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else if (!(m_cItems & QUICK_LIST_INDEX_MASK))
    {
        pqlstCurrent = this;
    }
    else 
    {
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Blink, CQuickList, m_liListPages);
    }

    _ASSERT(pqlstCurrent->fIsIndexOnThisPage(m_cItems));
    pqlstCurrent->m_rgpvData[m_cItems & ~QUICK_LIST_INDEX_MASK] = pvData;

    //Set OUT param to index (before we increment the count)
    if (pdwIndex)
        *pdwIndex = m_cItems;

    m_cItems++;
    _ASSERT(QUICK_LIST_LEAF_PAGE != m_cItems);
  
  Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\propstrm.cpp ===
//----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  Module:  rwstream.cpp
//
//  Description:  Contains implementation of the read only / write only 
//                mailmsg property stream in epoxy shared memory.
//
//      10/20/98 - MaheshJ Created 
//      8/17/99 - MikeSwa Modified to use files instead of shared memory 
//----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "propstrm.h"


// Constructor.
CFilePropertyStream::CFilePropertyStream()
{
    TraceFunctEnter("CFilePropertyStream::CFilePropertyStream");

    m_dwSignature = FILE_PROPERTY_STREAM;
    m_hDestFile = NULL;

    TraceFunctLeave();
}

// Destructor.
CFilePropertyStream::~CFilePropertyStream()
{
    TraceFunctEnter("CFilePropertyStream::~CFilePropertyStream");

    _ASSERT(FILE_PROPERTY_STREAM == m_dwSignature);
    m_dwSignature = FILE_PROPERTY_STREAM_FREE;

    if (m_hDestFile && (INVALID_HANDLE_VALUE != m_hDestFile))
        _VERIFY(CloseHandle(m_hDestFile));

    TraceFunctLeave();
}

//---[ CFilePropertyStream::HrInitialize ]-------------------------------------
//
//
//  Description: 
//      Creates a file for the property stream 
//  Parameters:
//      szFileName      Name of file to create for the property stream
//  Returns:
//      S_OK on success
//      NT error from Create File
//  History:
//      8/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CFilePropertyStream::HrInitialize(LPSTR szFileName)
{
    TraceFunctEnterEx((LPARAM) this, "CFilePropertyStream::HrInitialize");
    HRESULT hr = S_OK;
    m_hDestFile = CreateFile(szFileName,
                              GENERIC_WRITE, 
                              0, 
                              NULL,
                              CREATE_ALWAYS,
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);

    if (INVALID_HANDLE_VALUE == m_hDestFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, 
            "Unable to create badmail reason file - err 0x%08X - file %s",
            hr, szFileName);
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }
    TraceFunctLeave();
    return hr;
}

//---[ CFilePropertyStream::QueryInterface ]-----------------------------------------
//
//
//  Description: 
//      QueryInterface for CFilePropertyStream that supports:
//          - IMailMsgPropertyStream
//  Parameters:
//
//  Returns:
//
//  History:
//      8/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CFilePropertyStream::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IMailMsgPropertyStream *>(this);
    }
    else if (IID_IMailMsgPropertyStream == riid)
    {
        *ppvObj = static_cast<IMailMsgPropertyStream *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

// Property stream methods.

// Start a write transaction.
HRESULT STDMETHODCALLTYPE    
CFilePropertyStream::StartWriteBlocks(IN IMailMsgProperties *pMsg,
                                              IN DWORD dwBlocksToWrite,
				                              IN DWORD dwTotalBytesToWrite)
{
    HRESULT hr = S_OK;

    TraceFunctEnter("CFilePropertyStream::StartWriteBlocks");

    // Should be writing something.
    _ASSERT(dwBlocksToWrite > 0);
    _ASSERT(dwTotalBytesToWrite > 0);

    //We actually don't case, since we will just dump this to a file
    TraceFunctLeave();
    return(hr);
}

// End a write transaction.
HRESULT STDMETHODCALLTYPE    
CFilePropertyStream::EndWriteBlocks(IN IMailMsgProperties *pMsg)
{
    TraceFunctEnter("CFilePropertyStream::EndWriteBlocks");
    HRESULT hr = S_OK;
    TraceFunctLeave();
    return(hr);
}

// Cancel a write transaction.
HRESULT STDMETHODCALLTYPE    
CFilePropertyStream::CancelWriteBlocks(IN IMailMsgProperties *pMsg)
{
    TraceFunctEnter("CFilePropertyStream::CancelWriteBlocks");
    HRESULT hr = S_OK;
    TraceFunctLeave();
    return(hr);
}

// Get the size of the stream.
HRESULT STDMETHODCALLTYPE 
CFilePropertyStream::GetSize(IN IMailMsgProperties *pMsg,
                                     IN DWORD          *  pdwSize,
				                     IN IMailMsgNotify	* pNotify)
{
    TraceFunctEnter("CFilePropertyStream::GetSize");
    HRESULT hr = E_NOTIMPL;
    TraceFunctLeave();
    return(hr);
}

// Read blocks from the stream.
HRESULT STDMETHODCALLTYPE 
CFilePropertyStream::ReadBlocks(IN IMailMsgProperties *pMsg,
                                        IN DWORD			 dwCount,
				                        IN DWORD			*pdwOffset,
				                        IN DWORD			*pdwLength,
				                        IN BYTE			   **ppbBlock,
				                        IN IMailMsgNotify	*pNotify)
{
    TraceFunctEnter("CFilePropertyStream::ReadBlocks");
    HRESULT hr       = E_NOTIMPL;
    ErrorTrace((LPARAM) this, "ReadBlocks call on CFilePropertyStream!");
    TraceFunctLeave();
    return(hr);
}

// Write blocks to the stream.	
HRESULT STDMETHODCALLTYPE 
CFilePropertyStream::WriteBlocks(IN IMailMsgProperties *pMsg,
                                         IN DWORD			dwCount,
                                         IN DWORD			*pdwOffset,
                                         IN DWORD			*pdwLength,
                                         IN BYTE			**ppbBlock,
                                         IN IMailMsgNotify	*pNotify)
{
    TraceFunctEnter("CFilePropertyStream::WriteBlocks");
    HRESULT hr       = S_OK;
    DWORD   irgCount = 0;
    DWORD   cbWritten = 0;
    OVERLAPPED ov;

    ZeroMemory(&ov, sizeof(OVERLAPPED));


    if ((0 == dwCount)||
        (NULL == pdwOffset)||
        (NULL == pdwLength)||
        (NULL == ppbBlock))
    {
        hr = E_INVALIDARG;
        DebugTrace((LPARAM)this,
                   "WriteBlocks failed with hr : 0x%x",
                   hr);
        goto Exit;
    }

    if (!m_hDestFile)
    {
        ErrorTrace((LPARAM) this,
                   "WriteBlocks called with no file handle");
        hr = E_FAIL;
        _ASSERT(0 && "WriteBlocks called with no file handle");
        goto Exit;
    }

    for (irgCount = 0; irgCount < dwCount; irgCount++)
    {
        ov.Offset = pdwOffset[irgCount];
        cbWritten = 0;
        if (!WriteFile(m_hDestFile, ppbBlock[irgCount], pdwLength[irgCount], 
            &cbWritten, &ov))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM)this,
                        "WriteFile of blob %d failed with hr : 0x%08X",
                        irgCount, hr);
            goto Exit;
        }
    }

Exit:
    TraceFunctLeave();
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiktime.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: qwiktime.cpp
//
//  Description:  Implementation of CAQQuickTime class
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/9/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "qwiktime.h"

//The basic premise is to use GetTickCount to get a reasonable accurate 
//time information in a DWORD.  GetTickCount is only valid for 50 days, and
//has an accuracy of 1 ms.  50 days is just not long enough.
//MSchofie was kind enough to prepare the following table:
//Bit shift Resolution (seconds)    Uptime(years)
//3         0.008                   1.088824217
//4         0.016                   2.177648434
//5         0.032                   4.355296868
//6         0.064                   8.710593736
//7         0.128                   17.42118747
//8         0.256                   34.84237495
//9         0.512                   69.68474989
//10        1.024                   139.3694998
//11        2.048                   278.7389996
//12        4.096                   557.4779991
//13        8.192                   1114.955998
//14        16.384                  2229.911997
//15        32.768                  4459.823993
//16        65.536                  8919.647986

//The initial implementation used 16 bits, which had an error of about 66 
//seconds, which drove our poor Y2K tester nuts.  8 bits (34 years uptime)
//seems much more reasonable.

//The system tick is shifted right INTERNAL_TIME_TICK_BITS and stored in
//the least significant INTERNAL_TIME_TICK_BITS bits of the internal time.  
//The upper 32-INTERNAL_TIME_TICK_BITS bits
//is used to count the number of times the count rolls over
#define INTERNAL_TIME_TICK_BITS             8
#define INTERNAL_TIME_TICK_MASK             0x00FFFFFF

//Number where tick count has wrapped
const LONGLONG INTERNAL_TIME_TICK_ROLLOVER_COUNT     
                                            = (1 << (32-INTERNAL_TIME_TICK_BITS));
const LONGLONG TICKS_PER_INTERNAL_TIME      = (1 << INTERNAL_TIME_TICK_BITS);

//conversion constants
//There are 10^6 milliseconds per nanosecond (FILETIME is in 100 nanosecond counts)
const LONGLONG FILETIMES_PER_TICK           = 10000;
const LONGLONG FILETIMES_PER_INTERNAL_TIME  = (FILETIMES_PER_TICK*TICKS_PER_INTERNAL_TIME);
const LONGLONG FILETIMES_PER_MINUTE         = (FILETIMES_PER_TICK*1000*60);

//---[ CAQQuickTime::CAQQuickTime ]--------------------------------------------
//
//
//  Description: 
//      Default Constructor for CAQQuickTime.  Will call GetSystemTime once to 
//      get start up time... GetTickCount is used for all other calls.
//  Parameters:
//      -
//  Returns:
//
//  History:
//      7/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CAQQuickTime::CAQQuickTime()
{
    DWORD  dwTickCount = GetTickCount();
    LARGE_INTEGER *pLargeIntSystemStart = (LARGE_INTEGER *) &m_ftSystemStart;

    m_dwSignature = QUICK_TIME_SIG;

    //Get internal time and start file time
    GetSystemTimeAsFileTime(&m_ftSystemStart);

    //convert tick count to internal time
    m_dwLastInternalTime = dwTickCount >> INTERNAL_TIME_TICK_BITS;

    //adjust start time so that it is the time when the tick count was zero
    pLargeIntSystemStart->QuadPart -= (LONGLONG) dwTickCount * FILETIMES_PER_TICK;

    //Some asserts to validate constants
    _ASSERT(!(INTERNAL_TIME_TICK_ROLLOVER_COUNT & INTERNAL_TIME_TICK_MASK));
    _ASSERT((INTERNAL_TIME_TICK_ROLLOVER_COUNT >> 1) & INTERNAL_TIME_TICK_MASK);

}

//---[ CAQQuickTime::dwGetInternalTime ]---------------------------------------
//
//
//  Description: 
//      Gets internal time using GetTickCount... and makes sure that when 
//      GetTickCount wraps, the correct time is returned.
//  Parameters:
//      -
//  Returns:
//      DWORD internal time
//  History:
//      7/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CAQQuickTime::dwGetInternalTime()
{
    DWORD dwCurrentTick = GetTickCount();
    DWORD dwLastInternalTime = m_dwLastInternalTime;
    DWORD dwCurrentInternalTime;
    DWORD dwCheck;

    dwCurrentInternalTime = dwCurrentTick >> INTERNAL_TIME_TICK_BITS;

    _ASSERT(dwCurrentInternalTime == (INTERNAL_TIME_TICK_MASK & dwCurrentInternalTime));
    
    //see if rolled over our tick count
    while ((dwLastInternalTime & INTERNAL_TIME_TICK_MASK) > dwCurrentInternalTime)
    {
        dwLastInternalTime = m_dwLastInternalTime;

        //it is possible that we have rolled over the tick count
        //first make sure it is not just a thread-timing issue
        dwCurrentTick = GetTickCount();
        dwCurrentInternalTime = dwCurrentTick >> INTERNAL_TIME_TICK_BITS;

        if ((dwLastInternalTime & INTERNAL_TIME_TICK_MASK) > dwCurrentInternalTime)
        {
            dwCurrentInternalTime |= (~INTERNAL_TIME_TICK_MASK & dwLastInternalTime);
            dwCurrentInternalTime += INTERNAL_TIME_TICK_ROLLOVER_COUNT;

            //attempt interlocked exchange to update internal last internal time
            dwCheck = (DWORD) InterlockedCompareExchange((PLONG) &m_dwLastInternalTime,
                                                  (LONG) dwCurrentInternalTime,
                                                  (LONG) dwLastInternalTime);

            if (dwCheck == dwLastInternalTime)  //exchange worked
                goto Exit;
        }
               
    }

  _ASSERT(dwCurrentInternalTime == (INTERNAL_TIME_TICK_MASK & dwCurrentInternalTime));
  dwCurrentInternalTime |= (~INTERNAL_TIME_TICK_MASK & m_dwLastInternalTime);

  Exit:
    return dwCurrentInternalTime;
}

//---[ CAQQuickTime::GetExpireTime ]-------------------------------------------
//
//
//  Description: 
//      Get the expriation time for cMinutesExpireTime from now.
//  Parameters:
//      IN     cMinutesExpireTime   # of minutes in future to set time
//      IN OUT pftExpireTime        Filetime to store new expire time
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//
//  History:
//      7/10/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CAQQuickTime::GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext)
{
    TraceFunctEnterEx((LPARAM) this, "CAQQuickTime::GetExpireTime");
    _ASSERT(pftExpireTime);
    DWORD dwInternalTime = 0;
    LARGE_INTEGER *pLargeIntTime = (LARGE_INTEGER *) pftExpireTime;

    if (pdwExpireContext)
        dwInternalTime = *pdwExpireContext;

    if (!dwInternalTime)
    {
        dwInternalTime = dwGetInternalTime();
        //save internal time as context
        if (pdwExpireContext)
            *pdwExpireContext = dwInternalTime;
    }

    memcpy(pftExpireTime, &m_ftSystemStart, sizeof(FILETIME));

    //set to current time
    pLargeIntTime->QuadPart += (LONGLONG) dwInternalTime * FILETIMES_PER_INTERNAL_TIME;

    //set cMinutesExpireTime into the future
    pLargeIntTime->QuadPart += (LONGLONG) cMinutesExpireTime * FILETIMES_PER_MINUTE;

    DebugTrace((LPARAM) this, "INFO: Creating file time for %d minutes of 0x%08X %08X", 
        cMinutesExpireTime, pLargeIntTime->HighPart, pLargeIntTime->LowPart);
    TraceFunctLeave();

}

//---[ CAQQuickTime::fInPast ]-------------------------------------------------
//
//
//  Description: 
//      Determines if a given file time has already happened
//  Parameters:
//      IN     pftExpireTime        FILETIME with expiration
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//      TRUE if expire time is in the past
//      FALSE if expire time is in the future
//  History:
//      7/11/98 - MikeSwa Created 
//  Note:
//      You should NOT use the same context used to get the filetime, because
//      it will always return FALSE
//
//-----------------------------------------------------------------------------
BOOL CAQQuickTime::fInPast(IN FILETIME *pftExpireTime, 
                           IN OUT DWORD *pdwExpireContext)
{
    _ASSERT(pftExpireTime);
    DWORD          dwInternalTime = 0;
    FILETIME       ftCurrentTime = m_ftSystemStart;
    LARGE_INTEGER *pLargeIntCurrentTime = (LARGE_INTEGER *) &ftCurrentTime;
    LARGE_INTEGER *pLargeIntExpireTime = (LARGE_INTEGER *) pftExpireTime;
    BOOL           fInPast = FALSE;

    if (pdwExpireContext)
        dwInternalTime = *pdwExpireContext;

    if (!dwInternalTime)
    {
        dwInternalTime = dwGetInternalTime();
        //save internal time as context
        if (pdwExpireContext)
            *pdwExpireContext = dwInternalTime;
    }

    //Get current time
    pLargeIntCurrentTime->QuadPart += (LONGLONG) dwInternalTime * FILETIMES_PER_INTERNAL_TIME;

    if (pLargeIntCurrentTime->QuadPart > pLargeIntExpireTime->QuadPart)
        fInPast =  TRUE;

    return fInPast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\refstr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: refstr.cpp
//
//  Description:  Implementation of CRefCountedString and helper functions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/11/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "refstr.h"

//---[ CRefCountedString ]-----------------------------------------------------
//
//
//  Description: 
//      Initializes a ref-counted string to the given string.
//  Parameters:
//      szStr       String to initialize to
//      cbStrlen    Length of string to initialize to
//  Returns:
//      TRUE on success
//      FALSE if required memory could not be allocated.
//  History:
//      11/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CRefCountedString::fInit(LPSTR szStr, DWORD cbStrlen)
{
    _ASSERT(CREFSTR_SIG_VALID == m_dwSignature);

    //We allow init of an empty string
    if (!cbStrlen || !szStr)
    {
        m_cbStrlen = 0;
        m_szStr = NULL;
        return TRUE;
    }

    _ASSERT(szStr);
    _ASSERT(cbStrlen);

    m_cbStrlen = cbStrlen;
    m_szStr = (LPSTR) pvMalloc(sizeof(CHAR) * (cbStrlen+1));
    if (!m_szStr)
        return FALSE;


    memcpy(m_szStr, szStr, cbStrlen);
    m_szStr[cbStrlen] = '\0';
    return TRUE;
}


//---[ HrUpdateRefCountedString ]----------------------------------------------
//
//
//  Description: 
//      Function to update a ref-counted string.  Typically used to update 
//      config strings.
//  Parameters:
//      pprstrCurrent       Ptr to ptr to string.  Will be replaced with 
//                          an updated version if neccessary.
//      szNew               The new string.
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if we could not allocate the memory required to handle
//          this.
//  History:
//      11/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT HrUpdateRefCountedString(CRefCountedString **pprstrCurrent, LPSTR szNew)
{
    _ASSERT(pprstrCurrent);
    HRESULT hr = S_OK;
    DWORD   cbStrLen = 0;
    CRefCountedString *prstrNew = *pprstrCurrent;
    CRefCountedString *prstrCurrent = *pprstrCurrent;

    if (!szNew)
        prstrNew = NULL;  //we don't want to do a strcmp here
    else 
        cbStrLen = lstrlen(szNew);
    
    if (prstrNew)
    {
        //First free up old info... if different
        if (!prstrCurrent->szStr() ||
            lstrcmp(prstrCurrent->szStr(), szNew))
        {
            //strings are different... blow away old info
            prstrNew = NULL;
        }
    }

    //Check if either old string is different, or there was no old string
    if (!prstrNew)
    {
        //only update and allocate if changed
        prstrNew = new CRefCountedString();
        if (prstrNew)
        {
            if (!prstrNew->fInit(szNew, cbStrLen))
            {
                prstrNew->Release();
                prstrNew = NULL;
            }
        }

        if (!prstrNew)
        {
            //We ran into some failure
            hr = E_OUTOFMEMORY;
        }
        else //release old value & save New
        {
            if (prstrCurrent)
            {
                prstrCurrent->Release();
                prstrCurrent = NULL;
            }
            *pprstrCurrent = prstrNew;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiktime.h ===
//-----------------------------------------------------------------------------
//
//
//  File: qwiktime.h
//
//  Description: Header for CAQQuickTime class... a class to handle filling 
//      and comparing FILETIME by using the GetTickCount instead of using
//      GetSystemTime
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/9/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __QWIKTIME_H__
#define __QWIKTIME_H__

#define QUICK_TIME_SIG 'miTQ'

class CAQQuickTime
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_dwLastInternalTime;
    FILETIME    m_ftSystemStart;

    DWORD dwGetInternalTime();
  public:
    CAQQuickTime();

    void GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext); //if non-zero, will use last time

    BOOL fInPast(IN FILETIME *pftExpireTime, IN OUT DWORD *pdwExpireContext);
};

#endif //__QWIKTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\refstr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: refstr.h
//
//  Description:  Definition/Implementation of refcounted string.  Used to hold
//      dynamic config data.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/8/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __REFSTR_H__
#define __REFSTR_H__

#define CREFSTR_SIG_VALID   'rtSR'
#define CREFSTR_SIG_INVALID 'rtS!'

//---[ CRefCountedString ]-----------------------------------------------------
//
//
//  Description: 
//      Implemenation of a ref-counted string.  Designed to hold config data, 
//      so that it can be passed to event sinks without holding a share lock.
//  Hungarian: 
//      rstr, prstr
//  
//-----------------------------------------------------------------------------
class CRefCountedString : public CBaseObject
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_cbStrlen;     //length of string w/o NULL
    LPSTR       m_szStr;        //string data
  public:
    CRefCountedString()
    {
        m_dwSignature = CREFSTR_SIG_VALID;
        m_cbStrlen = 0;
        m_szStr = NULL;
    };

    ~CRefCountedString()
    {
        if (m_szStr)
            FreePv(m_szStr);
        m_szStr = NULL;
        m_cbStrlen = 0;
        m_dwSignature = CREFSTR_SIG_INVALID;
    }

    //Used to allocate memory for string
    // return FALSE if allocation fails
    BOOL fInit(LPSTR szStr, DWORD cbStrlen);

    //Return strlen of string
    DWORD cbStrlen() 
    {
        _ASSERT(CREFSTR_SIG_VALID == m_dwSignature);
        return m_cbStrlen;
    };

    //Returns string
    LPSTR szStr() 
    {
        _ASSERT(CREFSTR_SIG_VALID == m_dwSignature);
        return m_szStr;
    };

};

HRESULT HrUpdateRefCountedString(CRefCountedString **pprstrCurrent, LPSTR szNewString);


#endif //__REFSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiklist.h ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.h
//
//	Description: Provides a quick paged/growable list implementation.
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/98 - MikeSwa Created 
//      9/9/98 - MikeSwa Modified to include functionality to delete entries
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __QWIKLIST_H__
#define __QWIKLIST_H__

#include <aqincs.h>
#include <listmacr.h>

#define QUICK_LIST_SIG  'tsLQ'
#define QUICK_LIST_SIG_DELETE 'slQ!'
    
const DWORD QUICK_LIST_PAGE_SIZE = 16;  //must be a power of 2

//Mask used to quickly determine if a given index is on the current page
const DWORD QUICK_LIST_INDEX_MASK = ~(QUICK_LIST_PAGE_SIZE-1);

//When m_cItems is set to this value... we know this is not the head page.
const DWORD QUICK_LIST_LEAF_PAGE = 0xFFFF7EAF;

class CQuickList
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_dwCurrentIndexStart;
    LIST_ENTRY  m_liListPages;
    DWORD       m_cItems;
    PVOID       m_rgpvData[QUICK_LIST_PAGE_SIZE];
    inline BOOL fIsIndexOnThisPage(DWORD dwIndex);
  public:
    static CPool s_QuickListPool;
    void *operator new(size_t size);
    void operator delete(void *p, size_t size);

    CQuickList(); //initialize entry as head
    CQuickList(CQuickList *pqlstHead); //initialize as new page in list
    ~CQuickList();

    DWORD dwGetCount() {return m_cItems;};
    PVOID pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext);
    PVOID pvDeleteItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext);
    HRESULT HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex);
};

//---[ CQuickList::fIsIndexOnThisPage ]----------------------------------------
//
//
//  Description: 
//      Returns TRUE is the given index is on this page
//  Parameters:
//      dwIndex     - Index to check for 
//  Returns:
//      TRUE if index is on this page... FALSE otherwise
//  History:
//      6/15/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CQuickList::fIsIndexOnThisPage(DWORD dwIndex)
{
    return ((dwIndex & QUICK_LIST_INDEX_MASK) == m_dwCurrentIndexStart);
}


inline void *CQuickList::operator new(size_t size) 
{
    return s_QuickListPool.Alloc();
}

inline void CQuickList::operator delete(void *p, size_t size) 
{
    s_QuickListPool.Free(p);
}

#endif //__QWIKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\shutdown.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: shutdown.cpp
//
//  Description:  Implementation of CSyncShutdown.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "shutdown.h"
#include "aqutil.h"

//---[ CSyncShutdown::~CSyncShutdown ]-----------------------------------------
//
//
//  Description: 
//      CSyncShutdown Destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CSyncShutdown::~CSyncShutdown()
{
    //There should not be any outstanding locks
    m_dwSignature = CSyncShutdown_SigFree;
    _ASSERT(0 == (m_cReadLocks & ~SYNC_SHUTDOWN_SIGNALED));
}

//---[ CSyncShutdown::fTryShutdownLock ]---------------------------------------
//
//
//  Description: 
//      Trys to aquire Shared lock to guard against shutdown happening.  This
//      call will *not* block, but may cause the thread calling SignalShutdown
//      to block.
//  Parameters:
//      -
//  Returns:
//      TRUE if shutdown lock can be aquired and shutdown has not started.
//      FALSE if lock cannot be aquired (thread in SignalShutdown) or if 
//          SYNC_SHUTDOWN_SIGNALED has already been set.
//
//-----------------------------------------------------------------------------
BOOL CSyncShutdown::fTryShutdownLock()
{

    if (m_cReadLocks & SYNC_SHUTDOWN_SIGNALED)
        return FALSE;
    else if (!m_slShutdownLock.TryShareLock())  //Never block for the lock..
        return FALSE;

    //Check bit again... now that we have sharelock
    if (m_cReadLocks & SYNC_SHUTDOWN_SIGNALED)
    {
        m_slShutdownLock.ShareUnlock();
        return FALSE;
    }

    //In retail, m_cReadLocks is only used for the SYNC_SHUTDOWN_SIGNALED flag
    DEBUG_DO_IT(InterlockedIncrement((PLONG) &m_cReadLocks));
    return TRUE;
}

//---[ CSyncShutdown::ShutdownUnlock ]-----------------------------------------
//
//
//  Description: 
//      Releases a perviously aquired share lock.  Must be matched with a 
//      *succeeding* call to fTryShutdownLock().
//  Parameters:
//      -
//  Returns:
//      -
//
//      Will assert if called more times than there are outstanding share locks
//
//-----------------------------------------------------------------------------
void CSyncShutdown::ShutdownUnlock()
{
    _ASSERT(0 < (m_cReadLocks & ~SYNC_SHUTDOWN_SIGNALED));

    //In retail, m_cReadLocks is only used for the SYNC_SHUTDOWN_SIGNALED flag
    DEBUG_DO_IT(InterlockedDecrement((PLONG) &m_cReadLocks));
    m_slShutdownLock.ShareUnlock();
}

//---[ CSyncShutdown::SignalShutdown ]-----------------------------------------
//
//
//  Description: 
//      Aquires the Exclusive lock & sets the shutdown flag, which will prevent
//      Any further shared locks from being aquired.  
//
//      This call *may* block, and should not be called by a thread that 
//      already owns a shared shutdown lock.  This is unlikely to happen, since
//      This should only be called by a thread that stopping the server
//      instance.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CSyncShutdown::SignalShutdown()
{

    //Let everyone know that we are shutting down... once this is called, no
    //one will be able to grab the lock shared.
    SetShutdownHint();

    //Wait until all threads that have acquired the lock are done
    m_slShutdownLock.ExclusiveLock();
    m_slShutdownLock.ExclusiveUnlock();
    
    //Now all calls to fTryShutdownLock should fail
    _ASSERT(!fTryShutdownLock());
}

//---[ CSyncShutdown::SetShutdownHint ]----------------------------------------
//
//
//  Description: 
//      Sets the shutdown hint so that further calls to fTryShutdownLock
//      will fail.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/7/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CSyncShutdown::SetShutdownHint()
{
    dwInterlockedSetBits(&m_cReadLocks, SYNC_SHUTDOWN_SIGNALED);

    //Now all calls to fTryShutdownLock should fail
    _ASSERT(!fTryShutdownLock());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\shutdown.h ===
//-----------------------------------------------------------------------------
//
//
//  File: shutdown.h
//
//  Description:  An inheritable class that uses SharedLock to synchronize 
//      shutdown.
//
//  Author: mikeswa
//
//  History:
//      9/4/98 - MikeSwa Modified to have a non-blocking fTryShutdownLock.
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __SHUTDOWN_H__
#define __SHUTDOWN_H__

class CSyncShutdown;

#include <aqincs.h>
#include <rwnew.h>

#define CSyncShutdown_Sig       'tuhS'
#define CSyncShutdown_SigFree   'thS!'

//Bit in m_cReadLocks used to signal that shudown is in progress
const DWORD SYNC_SHUTDOWN_SIGNALED = 0x80000000;

//---[ CSyncShutdown ]---------------------------------------------------------
//
//
//  Synchronization object that is a base class for AQ objects.  This is 
//  designed to allow objects to know when it is OK to access member variables,
//  and is really only needed in components that have external threads calling
//  in (current CAQSvrInst and CConnMgr).
//
//  The basic usage is to call fTryShutdownLock() before access member data.  If
//  it fails, return AQUEUE_E_SHUTDOWN... otherwise you can access member data
//  until you call ShutdownUnlock().  Neither of these calls will block:
//
//      if (!fTryShutdownLock())
//      {
//          hr = AQUEUE_E_SHUTDOWN;
//          goto Exit;
//      }
//      ...
//      ShutdownUnlock();
//
//  SignalShutdown should be called during the inheriting function's
//  HrDeInitialize().  This will cause all further calls to fTryShutdownLock()
//  to fail.  This call will block until all threads that have had a successful
//  fTryShutdownLock() call ShutdownUnlock().
//
//-----------------------------------------------------------------------------
class CSyncShutdown
{
  private:
    DWORD           m_dwSignature;
    DWORD           m_cReadLocks;  //Keep track of the number of read locks
    CShareLockNH    m_slShutdownLock;
  public:
    CSyncShutdown() 
    {
        m_dwSignature = CSyncShutdown_Sig;
        m_cReadLocks = 0;
    };
    ~CSyncShutdown();
    BOOL     fTryShutdownLock();
    void     ShutdownUnlock();
    void     SignalShutdown();

    BOOL     fShutdownSignaled() {return (m_cReadLocks & SYNC_SHUTDOWN_SIGNALED);};
    //Assert that can be used to verify that the lock is held by somethread
    void     AssertShutdownLockAquired() {_ASSERT(m_cReadLocks & ~SYNC_SHUTDOWN_SIGNALED);};

    void     SetShutdownHint(); //causes future calls to fTryShutdownLock to fail
};

#endif //__SHUTDOWN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smtpconn.h ===
//-----------------------------------------------------------------------------
//
//
//  File: SMTPConn.h 
//
//  Description: Declaration of the CSMTPConn class which implements the
//      ISMTPConnection interface
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __SMTPCONN_H_
#define __SMTPCONN_H_

#include <cpoolmac.h>
#include <baseobj.h>
#include <aqueue.h>
#include "linkmsgq.h"
#include "dcontext.h"

class CConnMgr;
class CAQSvrInst;
class CInternalDomainInfo;

#define SMTP_CONNECTION_SIG 'nocS'

//---[ CSMTPConn ]-------------------------------------------------------------
//
//
//  Hungarian: SMTPConn, pSMTPConn
//
//  
//-----------------------------------------------------------------------------
class CSMTPConn :
   public ISMTPConnection,
   public CBaseObject
{
protected:
    DWORD            m_dwSignature;
    CLinkMsgQueue   *m_plmq;
    CConnMgr        *m_pConnMgr;
    CInternalDomainInfo *m_pIntDomainInfo;
    DWORD            m_cFailedMsgs;
    DWORD            m_cTriedMsgs;
    DWORD            m_cMaxMessagesPerConnection;
    DWORD            m_dwConnectionStatus;
    LPSTR            m_szDomainName;
    DWORD            m_cbDomainName;
    CDeliveryContext m_dcntxtCurrentDeliveryContext;
    LIST_ENTRY       m_liConnections;
    DWORD            m_cAcks;
    DWORD            m_dwTickCountOfLastAck;
                
public:
    static CPool     s_SMTPConnPool;
    void *operator new(size_t size);
    void operator delete(void *p, size_t size);

    CSMTPConn(CConnMgr *pConnMgr, CLinkMsgQueue *plmq, DWORD cMaxMessagesPerConnection);
    ~CSMTPConn();
    
    DWORD   cGetFailedMsgCount() {return m_cFailedMsgs;};
    DWORD   cGetTriedMsgCount() {return m_cTriedMsgs;};
    DWORD   dwGetConnectionStatus() {return m_dwConnectionStatus;};
    inline CLinkMsgQueue *plmqGetLink();

    inline void     InsertConnectionInList(PLIST_ENTRY pliHead);
    inline void     RemoveConnectionFromList();

// IUnknown
public:
    //CBaseObject handles addref and release
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) {return E_NOTIMPL;};
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};
// ISMTPConnection
public:
    STDMETHOD(GetDomainInfo)(/*[in, out]*/ DomainInfo *pDomainInfo);
    STDMETHOD(AckConnection)(/*[in]*/ DWORD dwConnectionStatus) 
        {m_dwConnectionStatus = dwConnectionStatus;return S_OK;};
    STDMETHOD(AckMessage)(/*[in]*/ MessageAck *pMsgAck);
    STDMETHOD(GetNextMessage)(
        /*[out]*/ IMailMsgProperties **ppIMailMsgProperties, 
        /*[out]*/ DWORD **ppvMsgContext, 
        /*[out]*/ DWORD *pcIndexes, 
        /*[out, size_is(*pcIndexes)]*/ DWORD *prgdwRecipIndex[]);

    STDMETHOD(SetDiagnosticInfo)(
        IN  HRESULT hrDiagnosticError,
        IN  LPCSTR szDiagnosticVerb,
        IN  LPCSTR szDiagnosticResponse);
};

//---[ CSMTPConn::plmqGetLink ]-------------------------------------------------
//
//
//  Description: 
//      Returns an AddRef'd link pointer for this connection. Caller must call
//      Release.
//  Parameters:
//      -
//  Returns:
//      link pointer for this connection (if there is one)
//      NULL if no link pointer
//  History:
//      6/11/98 - MikeSwa Added check for NULL link 
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CSMTPConn::plmqGetLink() 
{
    if (m_plmq)
    {
        m_plmq->AddRef();
        return m_plmq;
    }
    else
    {
        return NULL;
    }
};

//---[ CSMTPConn::InsertConnectionInList ]---------------------------------------
//
//
//  Description: 
//      Inserts link in given linked list
//  Parameters:
//      pliHead     - Head of list to insert in
//  Returns:
//      -
//  History:
//      6/16/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CSMTPConn::InsertConnectionInList(PLIST_ENTRY pliHead)
{
    _ASSERT(pliHead);
    _ASSERT(NULL == m_liConnections.Flink);
    _ASSERT(NULL == m_liConnections.Blink);
    InsertHeadList(pliHead, &m_liConnections);
};

//---[ CSMTPConn::RemoveConnectionFromList ]-------------------------------------
//
//
//  Description: 
//      Remove link from link list
//  Parameters:
//      - 
//  Returns:
//      -
//  History:
//      6/16/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CSMTPConn::RemoveConnectionFromList()
{
    RemoveEntryList(&m_liConnections);
    m_liConnections.Flink = NULL;
    m_liConnections.Blink = NULL;
};


inline void *CSMTPConn::operator new(size_t size) 
{
    return s_SMTPConnPool.Alloc();
}

inline void CSMTPConn::operator delete(void *p, size_t size) 
{
    s_SMTPConnPool.Free(p);
}

#endif //__SMTPCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\testmapfn.h ===
//-----------------------------------------------------------------------------
//
//
//	File: testmapfn.h
//
//	Description:	Prototype to test map fn in CFifoQueue
//
//	Author: mikeswa
//
//	Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _TESTMAPFN_H_
#define _TESTMAPFN_H_

#include "aqincs.h"

//---[ HrTestMapFn ]-----------------------------------------------------
//
//
//  Description: 
//      Example default function to use with HrMapFn... will always return TRUE
//      to continue and delete the current queued data
//  Parameters:
//      IN  PQDATA pqdata,  //ptr to data on queue
//      IN  PVOID pvContext - Context passed by calling fuction
//      OUT BOOL *pfContinue, //TRUE if we should continue
//      OUT BOOL *pfDelete);  //TRUE if item should be deleted
//  Returns:
//      NOERROR
//
//-----------------------------------------------------------------------------
template <class PQDATA>
HRESULT HrTestMapFn(IN PQDATA pqdata, IN PVOID pvContext, OUT BOOL *pfContinue, OUT BOOL *pfDelete)
{
    Assert(pfContinue);
    Assert(pfDelete);
    HRESULT hr = NOERROR;
    static DWORD cAttempts = 0;
    
    *pfContinue = TRUE;

    if (cAttempts == 50)
    {
        cAttempts = 0;
        *pfDelete   = TRUE;
    }
    else 
    {
        *pfDelete = FALSE;
        cAttempts++;
    }

    return hr;
}

#endif //_TESTMAPFN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smproute.cpp ===
//-----------------------------------------------------------------------------
//
//
//	File: smproute.cpp
//
//	Description:
//		Implementation of CSimpleMessageRouter.
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		5/20/98 - MikeSwa Created
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "smproute.h"
#include "domcfg.h"

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
#undef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
//If you are interested is using the default router to test how AQ handles
//multiple message types and schedule ID's, the uncomment the following
//#define AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

//---[ CAQDefaultMessageRouter::CAQDefaultMessageRouter ]----------------------
//
//
//  Description:
//      Constructor for CSimpleMessageRouter
//  Parameters:
//      pguid   - pointer to GUID to use to identify self
//  Returns:
//      -
//  History:
//      5/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQDefaultMessageRouter::CAQDefaultMessageRouter(GUID *pguid, CAQSvrInst *paqinst)
{
    _ASSERT(paqinst);
    m_dwSignature = AQ_DEFAULT_ROUTER_SIG;
    m_cPeakReferences = 1;

    ZeroMemory(&m_rgcMsgTypeReferences, NUM_MESSAGE_TYPES*sizeof(DWORD));

    if (pguid)
        memcpy(&m_guid, pguid, sizeof(GUID));
    else
        ZeroMemory(&m_guid, sizeof(GUID));

    m_dwCurrentReference = 0;

    m_paqinst = paqinst;
    m_paqinst->AddRef();

}

//---[ CAQDefaultMessageRouter::~CAQDefaultMessageRouter ]---------------------
//
//
//  Description:
//      Destructor for CAQDefaultMessageRouter.  Will assert that all message
//      types have been release correctly
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQDefaultMessageRouter::~CAQDefaultMessageRouter()
{
    m_paqinst->Release();
    for (int i = 0; i < NUM_MESSAGE_TYPES; i++)
        _ASSERT((0 == m_rgcMsgTypeReferences[i]) && "Message Types were not released");
}

//---[ CAQDefaultMessageRouter::GetTransportSinkID ]---------------------------
//
//
//  Description:
//      Returns GUID id for this messager router interface
//  Parameters:
//      -
//  Returns:
//      GUID for this IMessageRouter
//  History:
//      5/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
GUID CAQDefaultMessageRouter::GetTransportSinkID()
{
    return m_guid;
}

//---[ CAQDefaultMessageRouter::GetMessageType ]-------------------------------
//
//
//  Description:
//      Wrapper for routing get-message-type event.
//  Parameters:
//      IN  pIMailMsg   IMailMsgProperties of message to classify
//      OUT pdwMsgType  DWORD message type of message
//  Returns:
//      S_OK on success
//      failure code from routing event
//  History:
//      5/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQDefaultMessageRouter::GetMessageType(
            IN  IMailMsgProperties *pIMailMsg,
            OUT DWORD *pdwMessageType)
{
    HRESULT hr = S_OK;
    DWORD   dwMessageType = InterlockedIncrement((PLONG) &m_dwCurrentReference);
    _ASSERT(pdwMessageType);

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    //For debug versions we will autostress ourselves by generating msg types

    //simulate failures
    if (0 == (dwMessageType % NUM_MESSAGE_TYPES))
        return E_FAIL;

    dwMessageType %= NUM_MESSAGE_TYPES;
#else
    dwMessageType = 0;
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

    InterlockedIncrement((PLONG) &m_rgcMsgTypeReferences[dwMessageType]);
    *pdwMessageType = dwMessageType;
    return hr;
}



//---[ CAQDefaultMessageRouter::ReleaseMessageType ]---------------------------
//
//
//  Description:
//      Wrapper for ReiReleaseMessageType... releases references to message
//      type returned by HrGetMessageType.
//  Parameters:
//      IN dwMessageType    Msg type (as return by HrGetNextMessage) to release
//      IN dwReleaseCount   Number of references to release
//  Returns:
//      S_OK on success
//  History:
//      5/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQDefaultMessageRouter::ReleaseMessageType(
            IN DWORD dwMessageType,
            IN DWORD dwReleaseCount)
{
    HRESULT hr = S_OK;

    _ASSERT(dwMessageType < NUM_MESSAGE_TYPES);
    _ASSERT(m_rgcMsgTypeReferences[dwMessageType]);
    _ASSERT(m_rgcMsgTypeReferences[dwMessageType] >= dwReleaseCount);
    _ASSERT(0 == (dwReleaseCount & 0x80000000)); //non-negative

    InterlockedExchangeAdd((PLONG) &m_rgcMsgTypeReferences[dwMessageType], -1 * (LONG) dwReleaseCount);
    return hr;
}

//---[ CAQDefaultMessageRouter::GetNextHop ]------------------------------------
//
//
//  Description:
//      Wrapper for routing ReiGetNextHop.  Returns the <domain, schedule id>
//      pair for the next hop link
//  Parameters:
//
//  Returns:
//      S_OK on success
//  History:
//      5/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQDefaultMessageRouter::GetNextHop(
            IN LPSTR szDestinationAddressType,
            IN LPSTR szDestinationAddress,
            IN DWORD dwMessageType,
            OUT LPSTR *pszRouteAddressType,
            OUT LPSTR *pszRouteAddress,
            OUT LPDWORD pdwScheduleID,
            OUT LPSTR *pszRouteAddressClass,
            OUT LPSTR *pszConnectorName,
            OUT LPDWORD pdwNextHopType)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;

    _ASSERT(dwMessageType < NUM_MESSAGE_TYPES);
    _ASSERT(!lstrcmpi(MTI_ROUTING_ADDRESS_TYPE_SMTP, szDestinationAddressType));
    _ASSERT(szDestinationAddress);
    _ASSERT(pdwNextHopType);
    _ASSERT(pszConnectorName);
    _ASSERT(pszRouteAddressType);
    _ASSERT(pszRouteAddress);
    _ASSERT(pszRouteAddressClass);

    //For now, we will use essentially non-routed behavior... every thing will
    //go it's own link, and will use the same schedule ID.  No address class
    //will be returned.
    *pdwNextHopType = MTI_NEXT_HOP_TYPE_EXTERNAL_SMTP;

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    //Use m_dwCurrentReference to randomize schedule Id
    *pdwScheduleID = m_dwCurrentReference & 0x00000002;
#else //retail build
    *pdwScheduleID = 0;
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

    pszConnectorName = NULL;

    *pszRouteAddressType = MTI_ROUTING_ADDRESS_TYPE_SMTP;
    *pszRouteAddressClass = NULL;

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    //Get smarthost for this domain if stressing routing
    hr = m_paqinst->HrGetInternalDomainInfo( strlen(szDestinationAddress),
               szDestinationAddress, &pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    if (pIntDomainInfo->m_DomainInfo.szSmartHostDomainName)
    {
        //smart host exists... use it
        *pszRouteAddress = (LPSTR) pvMalloc(sizeof(CHAR) *
            (pIntDomainInfo->m_DomainInfo.cbSmartHostDomainNameLength+1));
        if (!*pszRouteAddress)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        lstrcpy(*pszRouteAddress, pIntDomainInfo->m_DomainInfo.szSmartHostDomainName);
    }
    else
    {
        *pszRouteAddress = szDestinationAddress;
    }
  Exit:
#else //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    *pszRouteAddress = szDestinationAddress;
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    return hr;
}

//---[ CAQDefaultMessageRouter::GetNextHopFree ]------------------------------------
//
//
//  Description:
//      Wrapper for routing ReiGetNextHopFree.
//      Free's the strings allocated in GetNextHop
//      NOTE: szDestinationAddressType/szDestinationAddress will never
//      be free'd.  They are arguments as an optimization trick (to
//      avoid alloc/freeing when szDestinationAddress=szRouteAddress)
//
//  Parameters:
//      szDestinationAddressType: DestinationAddressType passed into GetNextHopF
//      szDestinationAddress: DestinationAddress passed into GetNextHop
//
//  Returns:
//      S_OK on success
//  History:
//      jstamerj 1998/07/10 19:52:56: Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQDefaultMessageRouter::GetNextHopFree(
    IN LPSTR szDestinationAddressType,
    IN LPSTR szDestinationAddress,
    IN LPSTR szConnectorName,
    IN LPSTR szRouteAddressType,
    IN LPSTR szRouteAddress,
    IN LPSTR szRouteAddressClass)
{
    //
    // The only string necessary to free is szRouteAddress
    //
    if(szRouteAddress && (szRouteAddress != szDestinationAddress))
        FreePv(szRouteAddress);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smproute.h ===
//-----------------------------------------------------------------------------
//
//
//  File: smproute.h
//
//  Description:
//      Simple routing header file.  Defines a simple/default IMessageRouter
//      as well as constants that are defined in rei.h (which currently 
//      uses the old IMsg).
//
//  Author: Mike Swafford - mikeswa
//
//  History:
//      5/19/98 - mikeswa Created 
//      1/23/99 - MikeSwa Moved important constants to smtpevent.idl
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __SMPROUTE_H__
#define __SMPROUTE_H__

#include <aqincs.h>
#include <smtpevent.h>

class CAQSvrInst;

#define AQ_DEFAULT_ROUTER_SIG 'RDQA'
#define NUM_MESSAGE_TYPES   4
class CAQDefaultMessageRouter : 
    public IMessageRouter,
    public CBaseObject
{
public:
    CAQDefaultMessageRouter(GUID *pguid, CAQSvrInst *paqinst);
    ~CAQDefaultMessageRouter();
public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) {return E_NOTIMPL;};
    STDMETHOD_(ULONG, AddRef)(void) {InterlockedIncrement((PLONG) &m_cPeakReferences);return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};
public: //IMessageRouter
    STDMETHOD_(GUID,GetTransportSinkID) ();
    STDMETHOD (GetMessageType) (
        IN  IMailMsgProperties *pIMailMsg,
        OUT DWORD *pdwMessageType);

    STDMETHOD (ReleaseMessageType) (
        IN DWORD dwMessageType,
        IN DWORD dwReleaseCount);

    STDMETHOD (GetNextHop) (
        IN LPSTR szDestinationAddressType, 
        IN LPSTR szDestinationAddress, 
        IN DWORD dwMessageType, 
        OUT LPSTR *pszRouteAddressType, 
        OUT LPSTR *pszRouteAddress, 
        OUT LPDWORD pdwScheduleID, 
        OUT LPSTR *pszRouteAddressClass, 
        OUT LPSTR *pszConnectorName, 
        OUT LPDWORD pdwNextHopType);

    STDMETHOD (GetNextHopFree) (
        IN LPSTR szDestinationAddressType,
        IN LPSTR szDestinationAddress,
        IN LPSTR szConnectorName,
        IN LPSTR szRouteAddressType,
        IN LPSTR szRouteAddress,
        IN LPSTR szRouteAddressClass);

    STDMETHOD (ConnectionFailed) (
            IN LPSTR pszConnectorName)
    {
        return S_OK;
    }

protected:
    DWORD   m_dwSignature;
    DWORD   m_rgcMsgTypeReferences[NUM_MESSAGE_TYPES];
    DWORD   m_dwCurrentReference;
    GUID    m_guid; //My TransportSinkID
    DWORD   m_cPeakReferences;
    CAQSvrInst *m_paqinst;
};

#endif //__SMPROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqadm.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadm.cpp
//
//  Description: Implementation of CAQAdmin which implements IAQAdmin
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"
#include "aqadmin.h"
#include "aqadm.h"

CAQAdmin::CAQAdmin() {
}

CAQAdmin::~CAQAdmin() {
}

HRESULT CAQAdmin::GetVirtualServerAdminITF(LPCWSTR wszComputer,
                                           LPCWSTR wszVirtualServer,
										   IVSAQAdmin **ppIVSAQAdmin)
{
    TraceFunctEnter("CAQAdmin::GetVirtualServerAdminITF");
    
    if (ppIVSAQAdmin == NULL || wszVirtualServer == NULL) 
        return E_POINTER;

    if (((wszComputer != NULL) && (*wszComputer == NULL)) || *wszVirtualServer == NULL) 
        return E_INVALIDARG;

    CVSAQAdmin *pVSAdmin = new CVSAQAdmin;
	HRESULT hr = S_OK;

	if (pVSAdmin == NULL) return E_OUTOFMEMORY;
	hr = pVSAdmin->Initialize(wszComputer, wszVirtualServer);
	if (FAILED(hr)) {
		delete pVSAdmin;
		pVSAdmin = NULL;
	} 

	*ppIVSAQAdmin = pVSAdmin;

    TraceFunctLeave();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smtpconn.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: 
//      smtpconn.cpp
//  Description:
//      Implementation of CSMTPConn
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "SMTPConn.h"
#include "connmgr.h"
#include "domcfg.h"

CPool CSMTPConn::s_SMTPConnPool;

//---[ CSMTPConn::CSMTPConn() ]------------------------------------------------
//
//
//  Description: 
//      CSMTPConn constructor
//  Parameters:
//      IN  pConnMgr                    Ptr to instance connection manager
//      IN  plmq                        Ptr to link for this connection
//      IN  cMaxMessagesPerConnection   Max messages to send per connection
//                                      0 implies unlimited
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CSMTPConn::CSMTPConn(CConnMgr *pConnMgr, CLinkMsgQueue *plmq, 
                     DWORD cMaxMessagesPerConnection)
{
    _ASSERT(pConnMgr);
    _ASSERT(plmq);

    m_dwSignature = SMTP_CONNECTION_SIG;
    m_pConnMgr = pConnMgr;
    m_pIntDomainInfo = NULL;
    m_plmq = plmq;
    m_cFailedMsgs = 0;
    m_cTriedMsgs = 0;
    m_cMaxMessagesPerConnection = cMaxMessagesPerConnection;
    m_dwConnectionStatus = CONNECTION_STATUS_OK;
    m_szDomainName = NULL;
    m_cbDomainName = 0;
    m_liConnections.Flink = NULL;
    m_liConnections.Blink = NULL;
    m_cAcks = 0;
    m_dwTickCountOfLastAck = 0;

    if (plmq)
    {
        plmq->AddRef();
    }
}
                     
//---[ CSMTPConn::~CSMTPConn() ]-----------------------------------------------
//
//
//  Description: 
//      CSMTPConn default destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CSMTPConn::~CSMTPConn()
{
    HRESULT hrConnectionStatus = S_OK;
    BOOL    fHardErrorForceNDR = FALSE;
    _ASSERT(m_cAcks == m_cTriedMsgs);
    if (m_plmq != NULL)
    {
        _ASSERT(m_pConnMgr);
        m_pConnMgr->ReleaseConnection(this, &fHardErrorForceNDR);

        switch(m_dwConnectionStatus)
        {
            case CONNECTION_STATUS_OK:
                hrConnectionStatus = S_OK;
                break;
            case CONNECTION_STATUS_FAILED:
                hrConnectionStatus = AQUEUE_E_HOST_NOT_RESPONDING;
                break;
            case CONNECTION_STATUS_DROPPED:
                hrConnectionStatus = AQUEUE_E_CONNECTION_DROPPED;
                break;
            case CONNECTION_STATUS_FAILED_LOOPBACK:
                hrConnectionStatus = AQUEUE_E_LOOPBACK_DETECTED;
                break;
            case CONNECTION_STATUS_FAILED_NDR_UNDELIVERED:
                hrConnectionStatus = AQUEUE_E_NDR_ALL;
                break;
            default:
                _ASSERT(0 && "Undefined Connection Status");
                hrConnectionStatus = S_OK;
        }

        m_plmq->SetLastConnectionFailure(hrConnectionStatus);
        m_plmq->RemoveConnection(this, fHardErrorForceNDR);

        m_plmq->Release();

        //We should kick the connection manager, because if we were generating
        //DSNs, no connection could be made
        m_pConnMgr->KickConnections();
    }

    if (m_pIntDomainInfo)
        m_pIntDomainInfo->Release();

}

//---[ CSMTPConn::GetNextMessage ]---------------------------------------------
//
//
//  Description: 
//      Implementation of ISMTPConnection::GetNextMsg.
//      Gets the next message queued for this connection and determines which 
//      recipients should be delivered for this connection.
//  Parameters:
//      OUT ppimsg          New IMsg top be delivered
//      OUT pdwMsgContext   A 32-bit Context that needs to be provided in the 
//                          message ack.
//      OUT pcIndexes       The number of index in prgdwRecipIndex
//      OUT prgdwRecipIndex Recipient indexes that the caller is responsible 
//                          for attempting delivery to.
//  Returns:
//
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::GetNextMessage(
        OUT IMailMsgProperties  **ppIMailMsgProperties, 
        OUT DWORD ** ppvMsgContext, 
        OUT DWORD *  pcIndexes, 
        OUT DWORD ** prgdwRecipIndex)
{
    TraceFunctEnterEx((LPARAM) this, "CSMTPConn::GetNextMessage");
    HRESULT hr = S_OK;

   //We get the next message only if we are under the batch limit

    if(m_cMaxMessagesPerConnection && 
       (m_cTriedMsgs >= m_cMaxMessagesPerConnection) &&
       (!m_pIntDomainInfo || 
        !((DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY) &
          m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags)))
    {
        //SMTP does not check - but we may need a specific error for this case
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    if (m_pConnMgr && m_pConnMgr->fConnectionsStoppedByAdmin())
    {
        //Admin has requested that all outbound connections stop
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    hr = m_plmq->HrGetNextMsg(&m_dcntxtCurrentDeliveryContext, ppIMailMsgProperties, 
                              pcIndexes, prgdwRecipIndex);
    if (FAILED(hr))
        goto Exit;  
    //this will automagically catch the queue empty case...
    //If the Link has no more messages it will return AQUEUE_E_QUEUE_EMPTY, which
    //should cause the caller to Release() and query GetNextConnection again.

    *ppvMsgContext = (DWORD *) &m_dcntxtCurrentDeliveryContext;

    //increment the messages served
    InterlockedIncrement((PLONG)&m_cTriedMsgs);

  Exit:
    if (!m_cTriedMsgs)
        DebugTrace((LPARAM) this, "GetNextMessage called, but no messages tried for this connection");

    //rewrite error for SMTPSVC
    if (AQUEUE_E_QUEUE_EMPTY == hr)
        hr = HRESULT_FROM_WIN32(ERROR_EMPTY);

    TraceFunctLeave();
    return hr;
}

//---[ CSMTPConn::AckMessage ]-------------------------------------------------
//
//
//  Description: 
//      Acknowledges the delivery of a message (success/error codes are put in
//      the envelope by the transport).
//
//      Implements ISMTPConnection::AckMessage();
//  Parameters:
//      IN pIMsg        IMsg to acknowledge
//      IN dwMsgContext Context that was returned by GetNextMessage
//      IN eMsgStatus   Status of message
//  Returns:
//      S_OK on success
//      E_INVALIDARG if dwMsgContext is invalid
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::AckMessage(/*[in]*/ MessageAck *pMsgAck)
{
    HRESULT hr = S_OK;
    DWORD   dwTickCount = GetTickCount();
    _ASSERT(m_plmq);
    _ASSERT(pMsgAck);

    if (!(pMsgAck->dwMsgStatus & MESSAGE_STATUS_ALL_DELIVERED))
    {
        m_cFailedMsgs++;
    }


    InterlockedIncrement((PLONG)&m_cAcks);
    _ASSERT(m_cAcks == m_cTriedMsgs);
    hr = m_plmq->HrAckMsg(pMsgAck);

    m_dwTickCountOfLastAck = dwTickCount; //Set after assert so we can compare

    return hr;
}

//---[ CSMTPConn::GetSMTPDomain ]----------------------------------------------
//
//
//  Description: 
//      Returns the SMTPDomain of the link associated with this connections.
//
//      $$REVIEW:
//      This method does not allocate new memory for this string, but instead 
//      relies on the good intentions of the SMTP stack (or test driver) to 
//      not overwrite this memory. If we ever expose this interface externally,
//      then we should revert to allocating memory and doing a buffer copy
//
//      Implements ISMTPConnection::GetSMTPDomain
//  Parameters:
//      IN OUT  pDomainInfo     Ptr to DomainInfo struct supplied by caller
//                              and filled in here
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::GetDomainInfo(IN OUT DomainInfo *pDomainInfo)
{
    HRESULT hr = S_OK;

    _ASSERT(pDomainInfo->cbVersion >= sizeof(DomainInfo));
    _ASSERT(pDomainInfo);

    if (NULL == m_plmq)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }

    if (!m_pIntDomainInfo)
    {
        //Try to get domain info
        hr = m_plmq->HrGetDomainInfo(&m_cbDomainName, &m_szDomainName,
                            &m_pIntDomainInfo);
        if (FAILED(hr))
        {
            m_pIntDomainInfo = NULL;
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            goto Exit;
        }
    }

    _ASSERT(m_pIntDomainInfo);
    _ASSERT(m_cbDomainName);
    _ASSERT(m_szDomainName);

    // Is it OK to send client side commands on this connection
    // If not, we reset those domain info flags so SMTp cannot see them
    if(!m_plmq->fCanSendCmd())
    {
         m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &= ~(DOMAIN_INFO_SEND_TURN | DOMAIN_INFO_SEND_ETRN);
    }

    // If SMTP doesn't have the DOMAIN_INFO_TURN_ON_EMPTY then it is the older,
    // broken SMTP and we shouldn't allow TURN on empty to work.
    if ((m_plmq->cGetTotalMsgCount() == 0) && 
        !(m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & 
          DOMAIN_INFO_TURN_ON_EMPTY))
    {
         m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &= ~DOMAIN_INFO_SEND_TURN;
    }

    //copy everything but size
    memcpy(&(pDomainInfo->dwDomainInfoFlags), 
            &(m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags), 
            sizeof(DomainInfo) - sizeof(DWORD));

    //make sure our assumptions about the struct of DomainInfo are valid
    _ASSERT(1 == ((DWORD *) &(pDomainInfo->dwDomainInfoFlags)) - ((DWORD *) pDomainInfo));

    //we've filled pDomainInfo with the info for our Domain
    if (pDomainInfo->szDomainName[0] == '*')
    {
        //we matched a wildcard domain... substitute our domain name
        pDomainInfo->cbDomainNameLength = m_cbDomainName;
        pDomainInfo->szDomainName = m_szDomainName;
    }
    else
    {
        //if it wasn't a wildcard match... strings should match!
        _ASSERT(0 == _stricmp(m_szDomainName, pDomainInfo->szDomainName));
    }

  Exit:
    return hr;
}


//---[ CSMTPConn::SetDiagnosticInfo ]------------------------------------------
//
//
//  Description: 
//      Sets the extra diagnostic information for this connection.
//  Parameters:
//      IN      hrDiagnosticError       Error code... if SUCCESS we thow away
//                                      the rest of the information
//      IN      szDiagnosticVerb        String pointing to the protocol
//                                      verb that caused the failure.
//      IN      szDiagnosticResponse    String that contains the remote
//                                      servers response.
//  Returns:
//      S_OK always
//  History:
//      2/18/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::SetDiagnosticInfo(
                    IN  HRESULT hrDiagnosticError,
                    IN  LPCSTR szDiagnosticVerb,
                    IN  LPCSTR szDiagnosticResponse)
{

    TraceFunctEnterEx((LPARAM) this, "CSMTPConn::SetDiagnosticInfo");

    if (m_plmq && FAILED(hrDiagnosticError))
    {
        m_plmq->SetDiagnosticInfo(hrDiagnosticError, szDiagnosticVerb,
                                  szDiagnosticResponse);
    }
    TraceFunctLeave();
    return S_OK; //always return S_OK
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqmsg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqmsg.cpp
//
//  Description:  Implementation of CAQMessage class which implements
//          Queue Admin client interface IAQMessage
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CAQMessage::CAQMessage(CEnumMessages *pEnumMsgs, DWORD iMessage) {
    TraceFunctEnter("CAQMessage::CAQMessage");
    
    _ASSERT(pEnumMsgs);
    pEnumMsgs->AddRef();
    m_pEnumMsgs = pEnumMsgs;
    m_iMessage = iMessage;

    TraceFunctLeave();
}

CAQMessage::~CAQMessage() {
    TraceFunctEnter("CAQMessage::~CAQMessage");
    
    m_pEnumMsgs->Release();

    TraceFunctLeave();
}

HRESULT CAQMessage::GetInfo(MESSAGE_INFO *pMessageInfo) {
    TraceFunctEnter("CAQMessage::GetInfo");
    
    if (!pMessageInfo) 
    {
        TraceFunctLeave();
        return E_POINTER;
    }

    memcpy(pMessageInfo, 
           &(m_pEnumMsgs->m_rgMessages[m_iMessage]), 
           sizeof(MESSAGE_INFO));

    TraceFunctLeave();
    return S_OK;
}

//---[ CAQMessage::GetContentStream ]------------------------------------------
//
//
//  Description: 
//      Returns a stream for the content of the message
//  Parameters:
//      OUT     ppIStream       Stream for content
//      OUT     pwszContentType String containing content type (if known)
//  Returns:
//      E_NOTIMPL
//  History:
//      6/4/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAQMessage::GetContentStream(
                OUT IStream **ppIStream,
                OUT LPWSTR  *pwszContentType)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqmsg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqmsg.h
//
//  Description:  Implementation of Queue Admin client interfae IAQMessage
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __AQMSG_H__
#define __AQMSG_H__

class CEnumMessages;

class CAQMessage :
	public CComRefCount,
	public IAQMessage
{
	public:
		CAQMessage(CEnumMessages *pEnumMsgs, DWORD iMessage);
		virtual ~CAQMessage();

		HRESULT Initialize(LPCSTR szVirtualServerDN);

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IAQMessage) {
				*ppv = static_cast<IAQMessage *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IAQMessage
		COMMETHOD GetInfo(MESSAGE_INFO *pMessageInfo);
        COMMETHOD GetContentStream(
                OUT IStream **ppIStream,
                OUT LPWSTR  *pwszContentType);

    private:
        CEnumMessages *m_pEnumMsgs;
        DWORD m_iMessage;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqadm.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadm.h
//
//  Description:  Header for CAQAdmin which implements IAQAdmin.  This is 
//      the primary (initial) interface for Queue Admin, which is used to get 
//      a pointer to a virtual server instance interface (IVSAQAdmin)
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __AQADM_H__
#define __AQADM_H__

class CAQAdmin :
	public IAQAdmin,
	public CComObjectRoot,
	public CComCoClass<CAQAdmin, &CLSID_AQAdmin>
{
	public:
		CAQAdmin();
		virtual ~CAQAdmin();

		BEGIN_COM_MAP(CAQAdmin)
			COM_INTERFACE_ENTRY(IAQAdmin)
		END_COM_MAP()

		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx, 
									   L"Advanced Queue Administration API",
									   L"AQAdmin.Admin.1", 
									   L"AQAdmin.Admin"
									   );

		// IAQAdmin
        COMMETHOD GetVirtualServerAdminITF(LPCWSTR wszComputer,
                                           LPCWSTR wszVirtualServerDN,
										   IVSAQAdmin **ppivsaqadmin);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqrpcstb.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcstb.cpp
//
//  Description:  Implmentation of client side RPC stub wrappers.
//      Also contains implementation of required RPC bind/unbind functions
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "stdinc.h"
#include "aqadmrpc.h"


//---[ AQUEUE_HANDLE_bind ]----------------------------------------------------
//
//
//  Description: 
//      Implements bind for implicit AQUEUE_HANDLE
//  Parameters:
//      wszServerName       Server to bind to
//  Returns:
//      Binding handle on success
//      NULL on failure
//  History:
//      6/5/99 - MikeSwa Created  (adpated from SMTP_HANDLE_bind)
//
//-----------------------------------------------------------------------------
handle_t AQUEUE_HANDLE_bind (AQUEUE_HANDLE wszServerName)
{
    TraceFunctEnterEx((LPARAM) NULL, "AQUEUE_HANDLE_bind");
    handle_t    hBinding = NULL;
    RPC_STATUS  status = RPC_S_OK;
    RPC_STATUS  statusFree = RPC_S_OK; //status for cleanup operations
    WCHAR       wszTCPProtSeq[] = L"ncacn_ip_tcp";
    WCHAR       wszLocalProtSeq[] = L"ncalrpc";
    WCHAR      *wszProtSeq = wszTCPProtSeq;
    WCHAR      *wszNetworkAddress = wszServerName;
    WCHAR      *wszStringBinding = NULL;
    BOOL        fLocal = FALSE;

    //If no server is specified... 
    if (!wszServerName || !*wszServerName)
    {
        //Change binding arguments to be local
        fLocal = TRUE;
        wszProtSeq = wszLocalProtSeq;
        wszNetworkAddress = NULL;
        DebugTrace((LPARAM) NULL, "No server name specified... binding as local");
    }

    status = RpcStringBindingComposeW(NULL, // ObjUuid
                                      wszProtSeq, 
                                      wszNetworkAddress,
                                      NULL, // Endpoint
                                      NULL, // Options
                                      &wszStringBinding);

    if (RPC_S_OK != status)
    {
        ErrorTrace((LPARAM) NULL, 
            "RpcStringBindingComposeW failed with error 0x%08X", status);
        goto Exit;
    }

    DebugTrace((LPARAM) NULL, "Using RPC binding string - %S", wszStringBinding);

    status = RpcBindingFromStringBindingW(wszStringBinding, &hBinding);
    if (RPC_S_OK != status)
    {
        ErrorTrace((LPARAM) NULL,
            "RpcBindingFromStringBindingW failed with error 0x%08X", status);
        goto Exit;
    }

    //Set appropriate auth level
    if (!fLocal)
    {
        status = RpcBindingSetAuthInfoW(hBinding, 
                                        AQUEUE_RPC_INTERFACE,
                                        RPC_C_AUTHN_LEVEL_CONNECT,
                                        RPC_C_AUTHN_WINNT,
                                        NULL,
                                        NULL);
        if (RPC_S_OK != status)
        {
            ErrorTrace((LPARAM) NULL,
                "RpcBindingSetAuthInfoW failed with error 0x%08X", status);
            goto Exit;
        }
    }

  Exit:

    //Free binding string
    if (wszStringBinding)
    {
        statusFree = RpcStringFreeW(&wszStringBinding);
        if (RPC_S_OK != statusFree)
        {
            ErrorTrace((LPARAM) NULL, 
                "RpcStringFreeW failed with 0x%08X", statusFree);
        }
    }

    //Free handle on failure (if needed)
    if ((RPC_S_OK != status) && hBinding)
    {
        statusFree = RpcBindingFree(&hBinding);
        if (RPC_S_OK != statusFree)
        {
            ErrorTrace((LPARAM) hBinding, 
                "RpcBindingFree failed with 0x%08X", statusFree);
        }
        
        hBinding = NULL;
    }

    DebugTrace((LPARAM) hBinding, 
        "AQUEUE_HANDLE_bind returning with status 0x%08X", status);
    TraceFunctLeave();
    return hBinding;
}

//---[ AQUEUE_HANDLE_unbind ]--------------------------------------------------
//
//
//  Description: 
//      Implements unbind for AQUEUE_HANDLE_unbind
//  Parameters:
//      wszServerName       Server bound to (not used)
//      hBinding            Binding to free
//  Returns:
//      -
//  History:
//      6/5/99 - MikeSwa Created (adpated from SMTP_HANDLE_unbind)
//
//-----------------------------------------------------------------------------
void AQUEUE_HANDLE_unbind (AQUEUE_HANDLE wszServerName, handle_t hBinding)
{
    TraceFunctEnterEx((LPARAM) hBinding, "AQUEUE_HANDLE_unbind");
	UNREFERENCED_PARAMETER(wszServerName);
    RPC_STATUS  status = RPC_S_OK;

    status = RpcBindingFree(&hBinding);
    if (RPC_S_OK != status)
    {
        ErrorTrace((LPARAM) hBinding, 
            "RpcBindingFree failed with error 0x%08X", status);
    }
    TraceFunctLeave();
}


//---[ MIDL_user_allocate ]----------------------------------------------------
//
//
//  Description: 
//      MIDL memory allocation
//  Parameters:
//      size : Memory size requested.
//  Returns:
//      Pointer to the allocated memory block.
//  History:
//      6/5/99 - MikeSwa Created (taken from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
PVOID MIDL_user_allocate(IN size_t size)
{
    PVOID pvBlob = NULL;

    pvBlob = pvMalloc(size);
    //pvBlob = LocalAlloc( LPTR, size);

    return(pvBlob);

}

//---[ MIDL_user_free ]--------------------------------------------------------
//
//
//  Description: 
//    MIDL memory free .
//  Parameters:
//    IN    pvBlob    Pointer to a memory block that is freed.
//  Returns:
//      -
//  History:
//      6/5/99 - MikeSwa Created (from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
VOID MIDL_user_free(IN PVOID pvBlob)
{
    FreePv(pvBlob);
    //LocalFree(pvBlob);
} 


//---[ TraceMessageFilter ]----------------------------------------------------
//
//
//  Description: 
//      Function used to trace the message filter in a safe manner
//  Parameters:
//      IN  pvParam             User param to pass to tracing
//      IN  pmfMessageFilter    Message filter
//  Returns:
//      -
//  History:
//      6/14/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void TraceMessageFilter(LPARAM pvParam, MESSAGE_FILTER *pmfMessageFilter)
{
    TraceFunctEnterEx(pvParam, "TraceMessageFilter");
    if (pmfMessageFilter)
    {
        RpcTryExcept {
            DebugTrace(pvParam, 
                "Message Filter ID is %S", 
                pmfMessageFilter->szMessageId);
            DebugTrace(pvParam, 
                "Message Filter Sender is %S", 
                pmfMessageFilter->szMessageSender);
            DebugTrace(pvParam, 
                "Message Filter Recipient is %S", 
                pmfMessageFilter->szMessageRecipient);
            DebugTrace(pvParam, 
                "Message Filter version is %ld", 
                pmfMessageFilter->dwVersion);
        } RpcExcept (1) {
            ErrorTrace(pvParam, "Exception while tracing message filter");
        } RpcEndExcept
    }
    TraceFunctLeave();
}

//---[ TraceMessageEnumFilter ]------------------------------------------------
//
//
//  Description: 
//      Wrapper function that can safely dump a MESSAGE_ENUM_FILTER
//  Parameters:
//      IN  pvParam                 User param to pass to tracing
//      IN  pmfMessageEnumFilter    MESSAGE_ENUM_FILTER to trace
//  Returns:
//      -
//  History:
//      6/14/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void TraceMessageEnumFilter(LPARAM pvParam, 
                            MESSAGE_ENUM_FILTER *pmfMessageEnumFilter)
{
    TraceFunctEnterEx((LPARAM) pvParam, "TraceMessageEnumFilter");
    if (pmfMessageEnumFilter)
    {
        RpcTryExcept {
            DebugTrace(pvParam, 
                "Message Enum Filter Sender is %S", 
                pmfMessageEnumFilter->szMessageSender);
            DebugTrace(pvParam, 
                "Message Enum Filter Recipient is %S", 
                pmfMessageEnumFilter->szMessageRecipient);
            DebugTrace(pvParam, 
                "Message Enum Filter version is %ld", 
                pmfMessageEnumFilter->dwVersion);
        } RpcExcept (1) {
            ErrorTrace(pvParam, "Exception while tracing message enum filter");
        } RpcEndExcept
    }
    TraceFunctLeave();
}

//The following are the the client side wrappers of the RPC calls.  These
//include tracing and exception handling.
NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToLinks(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction)
{
    NET_API_STATUS apiStatus;
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQApplyActionToLinks");

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQApplyActionToLinks(wszServer,
                                              wszInstance,
                                              laAction);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQApplyActionToLinks - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, 
        "AQApplyActionToMessages returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}

NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToMessages(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQApplyActionToMessages");
    NET_API_STATUS apiStatus;

    TraceMessageFilter((LPARAM) pmfMessageFilter, pmfMessageFilter);

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQApplyActionToMessages(wszServer,
                                                 wszInstance,
                                                 pqlQueueLinkId,
                                                 pmfMessageFilter,
                                                 maMessageAction,
                                                 pcMsgs);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQApplyActionToMessages - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, 
        "AQApplyActionToMessages returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetQueueInfo");
    NET_API_STATUS apiStatus;

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetQueueInfo(wszServer,
                                        wszInstance,
                                        pqlQueueId,
                                        pqiQueueInfo);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQGetQueueInfo - 0x%08X", apiStatus);
    } RpcEndExcept

    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo,
    HRESULT         *phrLinkDiagnostic)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetLinkInfo");
    NET_API_STATUS apiStatus;
    _ASSERT(phrLinkDiagnostic);

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetLinkInfo(wszServer,
                                       wszInstance,
                                       pqlLinkId,
                                       pliLinkInfo,
                                       phrLinkDiagnostic);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQGetLinkInfo - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQGetLinkInfo returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQSetLinkState(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetLinkInfo");
    NET_API_STATUS apiStatus;

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQSetLinkState(wszServer,
                                       wszInstance,
                                       pqlLinkId,
                                       la);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQSetLinkState - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQSetLinkState returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**rgLinks)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetLinkInfo");
    NET_API_STATUS apiStatus;

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetLinkIDs(wszServer,
                                      wszInstance,
                                      pcLinks,
                                      rgLinks);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQGetLinkIDs - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQGetLinkIDs returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**rgQueues)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetQueueIDs");
    NET_API_STATUS apiStatus;

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetQueueIDs(wszServer,
                                       wszInstance,
                                       pqlLinkId,
                                       pcQueues,
                                       rgQueues);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQGetQueueIDs - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQGetQueueIDs returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetMessageProperties(
    LPWSTR          	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**rgMsgs)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetMessageProperties");
    NET_API_STATUS apiStatus;

    TraceMessageEnumFilter((LPARAM)pmfMessageEnumFilter, pmfMessageEnumFilter);
    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetMessageProperties(wszServer,
                                                wszInstance,
                                                pqlQueueLinkId,
                                                pmfMessageEnumFilter,
                                                pcMsgs,
                                                rgMsgs);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQGetMessageProperties - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, 
        "AQGetMessageProperties returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


//---[ ClientAQQuerySupportedActions ]-----------------------------------------
//
//
//  Description: 
//      Client stub for querying supported actions
//  Parameters:
//      IN  wszServer               The server to connect to
//      IN  wszInstance             The virtual server instance to connect to
//      IN  pqlQueueLinkId          The queue/link we are interested in
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK on success
//      Internal error from RPC or server on failure
//  History:
//      6/15/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
NET_API_STATUS
NET_API_FUNCTION
ClientAQQuerySupportedActions(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
    DWORD           *pdwSupportedActions,
    DWORD           *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQQuerySupportedActions");
    NET_API_STATUS apiStatus;

    RpcTryExcept {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQQuerySupportedActions(wszServer,
                                                wszInstance,
                                                pqlQueueLinkId,
                                                pdwSupportedActions,
                                                pdwSupportedFilterFlags);
    } RpcExcept (1) {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL, 
            "RPC exception on AQQuerySupportedActions - 0x%08X", apiStatus);
    } RpcEndExcept

    DebugTrace((LPARAM) NULL, 
        "AQQuerySupportedActions returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlink.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlink.cpp
//
//  Description: Implementation of CEnumVSAQLinks which implements IEnumVSAQLinks
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CEnumVSAQLinks::CEnumVSAQLinks(CVSAQAdmin *pVS,
                               DWORD cLinks,
                               QUEUELINK_ID *rgLinks) 
{
    _ASSERT(cLinks == 0 || rgLinks);
    _ASSERT(pVS);
    m_dwSignature = CEnumVSAQLinks_SIG;
    pVS->AddRef();
    m_rgLinks = rgLinks;
    m_pVS = pVS;
    m_iLink = 0;
    m_cLinks = cLinks;

    if (m_rgLinks)
        m_prefp = new CQueueLinkIdContext(m_rgLinks, cLinks);
    else
        m_prefp = NULL;
}

CEnumVSAQLinks::~CEnumVSAQLinks() {
    if (m_prefp)
    {
        m_rgLinks = NULL;
        m_prefp->Release();
        m_prefp = NULL;
    }

    if (m_pVS) 
    {
        m_pVS->Release();
        m_pVS = NULL;
    }
}

//---[ CEnumVSAQLinks::Next ]--------------------------------------------------
//
//
//  Description: 
//      Gets the next IVSAQLink for this enumerator
//  Parameters:
//      IN      cElements   Elements to return
//      IN OUT  rgElements  Array to recieve new elements
//      OUT     pcGetched   Number of elements returned
//  Returns:
//      S_OK on success
//      S_FALSE with no more elements
//      E_POINTER on NULL args
//  History:
//      1/30/99 - MikeSwa Fixed AV on bogus args
//
//-----------------------------------------------------------------------------
HRESULT CEnumVSAQLinks::Next(ULONG cElements,
			   				 IVSAQLink **rgElements,
				  			 ULONG *pcFetched)
{
    DWORD iLinkNew = m_iLink + cElements;
    DWORD i;
    HRESULT hr = S_OK;

    if (!rgElements || !pcFetched)
    {
        hr = E_POINTER;
        goto Exit;
    }

    // make sure we don't go past the end of the array
    if (iLinkNew > m_cLinks) iLinkNew = m_cLinks;

    // make a CVSAQLink object for each element and copy it into the user's
    // array
	(*pcFetched) = 0;
    for (i = m_iLink; (i < iLinkNew); i++) {
        rgElements[(*pcFetched)] = 
            (IVSAQLink *) new CVSAQLink(m_pVS, &(m_rgLinks[i]));

        // make sure that the allocation worked
        if (rgElements[(*pcFetched)] == NULL) {
            // remember how far we were able to go.
            iLinkNew = i;
            // if it didn't work and this was the first element then we
            // return out of memory.  if its not the first element then
            // return what we've built up so far.
            if (i == 0) hr = E_OUTOFMEMORY;
            // drop out of the loop
            break;
        } else {
			(*pcFetched)++;
		}
    }
	
    _ASSERT(*pcFetched <= cElements);
        
    m_iLink = iLinkNew;

    if (SUCCEEDED(hr) && *pcFetched < cElements) hr = S_FALSE;

  Exit:
    if (FAILED(hr))
    {
        if (pcFetched)
            *pcFetched = 0;
    }
	return hr;
}

//---[ CEnumVSAQLinks::Skip ]--------------------------------------------------
//
//
//  Description: 
//      Skips forward the specified number of elements in the enumerator
//  Parameters:
//      IN  cElements       The number of elements to skip forward
//  Returns:
//      S_OK    Success, next element will be returned by Next()
//      S_FALSE Overflow, enumerator must be reset to return more elements
//  History:
//      2/2/99 - MikeSwa fixed overflow handling
//
//-----------------------------------------------------------------------------
HRESULT CEnumVSAQLinks::Skip(ULONG cElements) 
{
    m_iLink += cElements;
    if ((m_iLink >= m_cLinks) || (m_iLink < cElements)) 
    {
        m_iLink = m_cLinks;
        return S_FALSE;
    } 
    else 
    {
        return S_OK;
    }
}

HRESULT CEnumVSAQLinks::Reset() {
    m_iLink = 0;
    return S_OK;
}

//---[ CEnumLinkQueues::Clone ]------------------------------------------------
//
//
//  Description: 
//      Clones this enumerator
//  Parameters:
//      OUT ppEnum      New enumerator
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocated associated memory
//      E_POINTER if ppEnum is NULL
//  History:
//      2/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CEnumVSAQLinks::Clone(IEnumVSAQLinks **ppEnum) {
    if (!m_prefp)
        return E_OUTOFMEMORY;

    if (!ppEnum)
        return E_POINTER;

    *ppEnum = (IEnumVSAQLinks *) new CEnumVSAQLinks(m_pVS, m_cLinks, NULL);

    if (!*ppEnum)
        return E_OUTOFMEMORY;

    ((CEnumVSAQLinks *)(*ppEnum))->m_rgLinks = m_rgLinks;
    ((CEnumVSAQLinks *)(*ppEnum))->m_prefp = m_prefp;
    ((CEnumVSAQLinks *)(*ppEnum))->m_iLink = m_iLink;
    m_prefp->AddRef();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlink.h ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlink.h
//
//  Description: Header for CEnumVSAQLinks which implements IEnumVSAQLinks.
//      This provides an enumerator for all links on a virtual server.
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __ENUMLINK_H__
#define __ENUMLINK_H__

class CQueueLinkIdContext;

#define CEnumVSAQLinks_SIG 'eLAQ'

class CEnumVSAQLinks :
	public CComRefCount,
	public IEnumVSAQLinks
{
	public:
        //
        // pVS - pointer to the virtual server admin.  should be AddRef'd
        //       before calling this.  will be released in destructor.
        // cLinks - the size of rgLinks
        // rgLinks - array of link IDs
        //
		CEnumVSAQLinks(CVSAQAdmin *pVS, 
                       DWORD cLinks,
                       QUEUELINK_ID *rgLinks);
		virtual ~CEnumVSAQLinks();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IEnumVSAQLinks) {
				*ppv = static_cast<IEnumVSAQLinks *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IEnumVSAQLinks
		COMMETHOD Next(ULONG cElements,
					   IVSAQLink **rgElements,
					   ULONG *pcFetched);
		COMMETHOD Skip(ULONG cElements);
		COMMETHOD Reset();
		COMMETHOD Clone(IEnumVSAQLinks **ppEnum);

    private:
        DWORD               m_dwSignature;
        CVSAQAdmin         *m_pVS;              // pointer to virtual server
        QUEUELINK_ID       *m_rgLinks;          // the array of links
        DWORD               m_cLinks;           // the size of rgLinks
        DWORD               m_iLink;            // the current link
        CQueueLinkIdContext *m_prefp;
};


//QUEUELINK_ID helper routines
inline BOOL fCopyQueueLinkId(QUEUELINK_ID *pqliDest, const QUEUELINK_ID *pqliSrc)
{
    //Copies the struct and allocates memory for strings
    memcpy(pqliDest, pqliSrc, sizeof(QUEUELINK_ID));
    if (pqliSrc->szName)
    {
        pqliDest->szName = (LPWSTR) MIDL_user_allocate(
                    (wcslen(pqliSrc->szName) + 1)* sizeof(WCHAR));
        if (!pqliDest->szName)
        {
            ZeroMemory(pqliDest, sizeof(QUEUELINK_ID));
            return FALSE;
        }
        wcscpy(pqliDest->szName, pqliSrc->szName);
    }
    return TRUE;
};

inline VOID FreeQueueLinkId(QUEUELINK_ID *pli)
{
    if (pli->szName)
        MIDL_user_free(pli->szName);
    pli->szName = NULL;
};
                      
//---[ CQueueLinkIdContext ]---------------------------------------------------
//
//
//  Description: 
//      Context used to ref-count array of QUEUELINK_IDs
//  
//-----------------------------------------------------------------------------
class   CQueueLinkIdContext : public CComRefCount
{
  protected:
        QUEUELINK_ID       *m_rgLinks;          // the array of links
        DWORD               m_cLinks;           // the size of rgLinks
  public:
    CQueueLinkIdContext(QUEUELINK_ID *rgLinks, DWORD cLinks)
    {
        m_rgLinks = rgLinks;
        m_cLinks = cLinks;
    };
    ~CQueueLinkIdContext()
    {
        if (m_rgLinks)
        {
            for (DWORD i = 0; i < m_cLinks; i++)
            {
                FreeQueueLinkId(&m_rgLinks[i]);
            }
            MIDL_user_free(m_rgLinks);
        }
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\dllmain.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dllmain.cpp
//
//  Description: DLL main for aqadmin.dll
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"
#include "resource.h"

#include "initguid.h"
#include "aqadmin.h"

HANDLE g_hTransHeap = NULL;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AQAdmin, CAQAdmin)
END_OBJECT_MAP()

BOOL  g_fHeapInit = FALSE;
BOOL  g_fModuleInit = FALSE;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
        if (!TrHeapCreate())
            return FALSE;
        g_fHeapInit = TRUE;

		_Module.Init(ObjectMap,hInstance);
        g_fModuleInit = TRUE;
        
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {

        if (g_fModuleInit)
		  _Module.Term();
        
        if (g_fHeapInit)
          TrHeapDestroy();

        g_fHeapInit = FALSE;
        g_fModuleInit = FALSE;
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {
	_Module.UnregisterServer();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqrpcstb.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcstb.h
//
//  Description: Header file for client-side RPC stub.  All functions are
//      client-side wrappers for the remote RPC implementation.  The naming
//      convention is that the client-side has the "Client" prefix, while the
//      remote RPC server functions do not.  The client side implementation is
//      wrapped in this manner to supply a single point to maintain exception
//      handling and any RPC overhead.
//
//      The RPC versions of these functions are defined in aqadmrpc.idl
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQRPCSTB_H__
#define __AQRPCSTB_H__

#include <inetcom.h>
#ifndef NET_API_FUNCTION
#define NET_API_FUNCTION _stdcall
#endif

NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToLinks(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction);

NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToMessages(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo,
    HRESULT         *hrLinkDiagnostic);

NET_API_STATUS
NET_API_FUNCTION
ClientAQSetLinkState(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**rgLinks);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**rgQueues);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetMessageProperties(
    LPWSTR          	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**rgMsgs);

NET_API_STATUS
NET_API_FUNCTION
ClientAQQuerySupportedActions(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
    DWORD           *pdwSupportedActions,
    DWORD           *pdwSupportedFilterFlags);

#endif //__AQRPCSTB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/96	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enummsgs.h ===
//-----------------------------------------------------------------------------
//
//
//  File: enummsgs.h
//
//  Description: Header file for CEnumMessages which implements IAQEnumMessages
//      Provides ability to enumerate over messages for a single queue.
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __ENUMMSGS_H__
#define __ENUMMSGS_H__

class CMessageInfoContext;

class CEnumMessages :
	public CComRefCount,
	public IAQEnumMessages
{
	public:
		CEnumMessages(MESSAGE_INFO *rgMessages, DWORD cMessages);
		virtual ~CEnumMessages();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IAQEnumMessages) {
				*ppv = static_cast<IAQEnumMessages *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IAQEnumMessages
		COMMETHOD Next(ULONG cElements, 
					   IAQMessage **rgElements,
					   ULONG *pcReturned);
		COMMETHOD Skip(ULONG cElements);
		COMMETHOD Reset();
		COMMETHOD Clone(IAQEnumMessages **ppEnum);
    private:
        MESSAGE_INFO   *m_rgMessages;
        DWORD           m_cMessages; 
        DWORD           m_iMessage;
        CMessageInfoContext     *m_prefp;

        friend CAQMessage;
};

inline VOID FreeMessageInfo(PMESSAGE_INFO pMessageInfo)
{
    if (pMessageInfo->szMessageId)
        MIDL_user_free(pMessageInfo->szMessageId);

    if (pMessageInfo->szSender)
        MIDL_user_free(pMessageInfo->szSender);

    if (pMessageInfo->szSubject)
        MIDL_user_free(pMessageInfo->szSubject);

    if (pMessageInfo->szRecipients)
        MIDL_user_free(pMessageInfo->szRecipients);

    if (pMessageInfo->szCCRecipients)
        MIDL_user_free(pMessageInfo->szCCRecipients);

    if (pMessageInfo->szBCCRecipients)
        MIDL_user_free(pMessageInfo->szBCCRecipients);

    if (pMessageInfo->mszEnvRecipients)
        MIDL_user_free(pMessageInfo->mszEnvRecipients);
}

//---[ CMessageInfoContext ]---------------------------------------------------
//
//
//  Description: 
//      Context used to ref-count array of MESSAGE_INFO
//  
//-----------------------------------------------------------------------------
class   CMessageInfoContext : public CComRefCount
{
  protected:
        MESSAGE_INFO       *m_rgMessages;          // the array of messages
        DWORD               m_cMessages;           // the size of rgmessages
  public:
    CMessageInfoContext(MESSAGE_INFO *rgMessages, DWORD cMessages)
    {
        m_rgMessages = rgMessages;
        m_cMessages = cMessages;
    };
    ~CMessageInfoContext()
    {
        if (m_rgMessages)
        {
            for (DWORD i = 0; i < m_cMessages; i++)
            {
                FreeMessageInfo(&m_rgMessages[i]);
            }
            MIDL_user_free(m_rgMessages);
        }
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\linkq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: linkq.h
//
//  Description: Header for CLinkQueue which implements ILinkQueue
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __LINKQ_H__
#define __LINKQ_H__

class CQueueInfoContext;

class CLinkQueue :
	public CComRefCount,
	public ILinkQueue,
    public IAQMessageAction,
    public IUniqueId
{
	public:
		CLinkQueue(CVSAQAdmin *pVS,
                   QUEUELINK_ID *pqlidQueueId);
		virtual ~CLinkQueue();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<ILinkQueue *>(this);
			} else if (iid == IID_ILinkQueue) {
				*ppv = static_cast<ILinkQueue *>(this);
			} else if (iid == IID_IAQMessageAction) {
				*ppv = static_cast<IAQMessageAction *>(this);
			} else if (iid == IID_IUniqueId) {
				*ppv = static_cast<IUniqueId *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// ILinkQueue
		COMMETHOD GetInfo(QUEUE_INFO *pQueueInfo);
		COMMETHOD GetMessageEnum(MESSAGE_ENUM_FILTER *pFilter,
								 IAQEnumMessages **ppEnum);

        //IAQMessageAction
		COMMETHOD ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs);
        COMMETHOD QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                        OUT DWORD *pdwSupportedFilterFlags);

        // IUniqueId
        COMMETHOD GetUniqueId(QUEUELINK_ID **ppqlid);

private:
        CVSAQAdmin *m_pVS;
        QUEUELINK_ID m_qlidQueueId;
        CQueueInfoContext *m_prefp;
};

//---[ CQueueInfoContext ]------------------------------------------------------
//
//
//  Description: 
//      Context to handle memory requirement of queue info
//  
//-----------------------------------------------------------------------------
class CQueueInfoContext : public CComRefCount
{
  protected:
        QUEUE_INFO          m_QueueInfo;          // the array of links
  public:
    CQueueInfoContext(PQUEUE_INFO pQueueInfo)
    {
        if (pQueueInfo)
            memcpy(&m_QueueInfo, pQueueInfo, sizeof(QUEUE_INFO));
        else
            ZeroMemory(&m_QueueInfo, sizeof(QUEUE_INFO));
    };

    ~CQueueInfoContext()
    {
        if (m_QueueInfo.szLinkName)
            MIDL_user_free(m_QueueInfo.szLinkName);

        if (m_QueueInfo.szQueueName)
            MIDL_user_free(m_QueueInfo.szQueueName);
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\linkq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: linkq.cpp
//
//  Description: Implementation of CLinkQueue which implements ILinkQueue
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CLinkQueue::CLinkQueue(CVSAQAdmin *pVS,
                       QUEUELINK_ID *pqlidQueueId) 
{
    TraceFunctEnterEx((LPARAM) this, "CLinkQueue::CLinkQueue");
    _ASSERT(pVS);
    pVS->AddRef();
    m_pVS = pVS;
    m_prefp = NULL;
    
    if (!fCopyQueueLinkId(&m_qlidQueueId, pqlidQueueId))
        ErrorTrace((LPARAM) this, "Unable to copy queue ID");

    TraceFunctLeave();
}

CLinkQueue::~CLinkQueue() {
    if (m_pVS) {
        m_pVS->Release();
        m_pVS = NULL;
    }

    if (m_prefp) {
        m_prefp->Release();
        m_prefp = NULL;
    }

    FreeQueueLinkId(&m_qlidQueueId);
}

HRESULT CLinkQueue::GetInfo(QUEUE_INFO *pQueueInfo) {
    TraceFunctEnter("CLinkQueue::GetInfo");
    
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    if (!pQueueInfo)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (CURRENT_QUEUE_ADMIN_VERSION != pQueueInfo->dwVersion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Release old info
    if (m_prefp) {
        m_prefp->Release();
        m_prefp = NULL;
    }

    rc = ClientAQGetQueueInfo(m_pVS->GetComputer(),
                            m_pVS->GetVirtualServer(),
                            &m_qlidQueueId,
                            pQueueInfo);
    if (rc) {
        hr = HRESULT_FROM_WIN32(rc);
        goto Exit;
    }

    m_prefp = new CQueueInfoContext(pQueueInfo);
    if (!m_prefp)
    {
        ErrorTrace((LPARAM) this, "Error unable to alloc queue context.");
    }
     
  Exit:
    TraceFunctLeave();
	return hr;
}

//---[ CLinkQueue::GetMessageEnum ]--------------------------------------------
//
//
//  Description: 
//      Gets a IAQEnumMessages for this link queue based on the specified 
//      filter.
//  Parameters:
//      IN  pFilter     Filter specifying messages we are interestered in
//      OUT ppEnum      IAQEnumMessages returned by search
//  Returns:
//      S_OK on success
//      E_POINTER when NULL pointer values are passed in.
//  History:
//      1/30/99 - MikeSwa Fixed AV on invalid args
//
//-----------------------------------------------------------------------------
HRESULT CLinkQueue::GetMessageEnum(MESSAGE_ENUM_FILTER *pFilter,
								   IAQEnumMessages **ppEnum)
{
    TraceFunctEnter("CVSAQLink::GetMessageEnum");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    DWORD cMessages;
    MESSAGE_INFO *rgMessages = NULL;
    CEnumMessages *pEnumMessages = NULL;

    if (!pFilter || !ppEnum)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQGetMessageProperties(m_pVS->GetComputer(), 
                                    m_pVS->GetVirtualServer(), 
                                    &m_qlidQueueId,
                                    pFilter,
                                    &cMessages,
                                    &rgMessages);
    if (rc) {
        hr = HRESULT_FROM_WIN32(rc);
    } else {
        pEnumMessages = new CEnumMessages(rgMessages, cMessages);
        if (pEnumMessages == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    *ppEnum = pEnumMessages;

    if (FAILED(hr)) {
        if (rgMessages) MIDL_user_free(rgMessages);
        if (pEnumMessages) delete pEnumMessages;
        *ppEnum = NULL;
    } 
    
  Exit:
    TraceFunctLeave();
    return hr;	
}

HRESULT CLinkQueue::ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										  MESSAGE_ACTION Action, 
                                          DWORD *pcMsgs) {
    TraceFunctEnter("CVSAQLink::ApplyActionToMessages");
    
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    if (!pFilter  || !pcMsgs)
    {
        hr = E_POINTER;
        if (pcMsgs)
            *pcMsgs = 0;
        goto Exit;
    }
    rc = ClientAQApplyActionToMessages(m_pVS->GetComputer(),
                                     m_pVS->GetVirtualServer(),
                                     &m_qlidQueueId,
                                     pFilter,
                                     Action, pcMsgs);
    if (rc) hr = HRESULT_FROM_WIN32(rc);

  Exit:
    TraceFunctLeave();
	return hr;	
}


//---[ CLinkQueue::QuerySupportedActions ]-------------------------------------
//
//
//  Description: 
//      Function that describes which actions are supported on this interface
//  Parameters:
//      OUT     pdwSupportedActions     Supported message actions
//      OUT     pdwSupportedFilterFlags Supported filter flags
//  Returns:
//      S_OK on success
//      E_POINTER on NULL args
//  History:
//      6/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CLinkQueue::QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                          OUT DWORD *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkQueue::QuerySupportedActions");
    HRESULT hr = S_OK;
    NET_API_STATUS rc;

    if (!pdwSupportedActions || !pdwSupportedFilterFlags)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQQuerySupportedActions(m_pVS->GetComputer(),
                                       m_pVS->GetVirtualServer(),
                                       &m_qlidQueueId,
                                       pdwSupportedActions,
                                       pdwSupportedFilterFlags);
    if (rc) 
        hr = HRESULT_FROM_WIN32(rc);

    if (FAILED(hr))
    {
        if (pdwSupportedActions)
            *pdwSupportedActions = 0;

        if (pdwSupportedFilterFlags)
            *pdwSupportedFilterFlags = 0;

    }

  Exit:
    TraceFunctLeave();
    return hr;
}




//---[ CVSAQLink::GetUniqueId ]---------------------------------------------
//
//
//  Description: 
//      Returns a canonical representation of this queue.
//  Parameters:
//      OUT pqlid - pointer to QUEUELINK_ID to return
//  Returns:
//      S_OK on success
//      E_POINTER on failure
//  History:
//      12/5/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CLinkQueue::GetUniqueId(OUT QUEUELINK_ID **ppqlid)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkQueue::GetUniqueId");
    HRESULT hr = S_OK;

    if (!ppqlid) {
        hr = E_POINTER;
        goto Exit;
    }

    *ppqlid = &m_qlidQueueId;

  Exit:
    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enummsgs.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: enummsgs.cpp
//
//  Description:  Implementation of CEnumMessages which implements 
//      IAQEnumMessages
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CEnumMessages::CEnumMessages(MESSAGE_INFO *rgMessages, DWORD cMessages)
{
    m_rgMessages = rgMessages;
    m_cMessages = cMessages;
    m_iMessage = 0;

    if (m_rgMessages)
        m_prefp = new CMessageInfoContext(rgMessages, m_cMessages);
    else
        m_prefp = NULL;
}

CEnumMessages::~CEnumMessages() 
{
    if (m_prefp)
    {
        m_rgMessages = NULL;
        m_prefp->Release();
        m_prefp = NULL;
    }
}

//---[ CEnumMessages::Next ]---------------------------------------------------
//
//
//  Description: 
//      Gets the next IAQMessage for this enumerator
//  Parameters:
//      IN      cElements   Elements to return
//      IN OUT  rgElements  Array to recieve new elements
//      OUT     pcGetched   Number of elements returned
//  Returns:
//      S_OK on success
//      S_FALSE with no more elements
//      E_POINTER on NULL args
//  History:
//      1/30/99 - MikeSwa Fixed AV on bogus args
//
//-----------------------------------------------------------------------------
HRESULT CEnumMessages::Next(ULONG cElements,
			   				 	IAQMessage **rgElements,
				  			 	ULONG *pcFetched)
{
    DWORD iMsgNew = m_iMessage + cElements;
    DWORD i;
    HRESULT hr = S_OK;

    if (!rgElements || !pcFetched)
    {
        hr = E_POINTER;
        goto Exit;
    }

    // make sure we don't go past the end of the array
    if (iMsgNew > m_cMessages) iMsgNew = m_cMessages;

    // make a CVSAQLink object for each element and copy it into the user's
    // array
	(*pcFetched) = 0;
    for (i = m_iMessage; (i < iMsgNew); i++) {
        rgElements[(*pcFetched)] = 
            (IAQMessage *) new CAQMessage(this, i);

        // make sure that the allocation worked
        if (rgElements[(*pcFetched)] == NULL) {
            // remember how far we were able to go.
            iMsgNew = i;
            // if it didn't work and this was the first element then we
            // return out of memory.  if its not the first element then
            // return what we've built up so far.
            if (i == 0) hr = E_OUTOFMEMORY;
            // drop out of the loop
            break;
        } else {
			(*pcFetched)++;
		}
    }
	
    _ASSERT(*pcFetched <= cElements);
        
    m_iMessage = iMsgNew;

    if (SUCCEEDED(hr) && *pcFetched < cElements) hr = S_FALSE;

  Exit:
    if (FAILED(hr))
    {
        if (pcFetched)
            *pcFetched = 0;
    }
	return hr;	
}

//---[ CEnumMessages::Skip ]---------------------------------------------------
//
//
//  Description: 
//      Skips forward the specified number of elements in the enumerator
//  Parameters:
//      IN  cElements       The number of elements to skip forward
//  Returns:
//      S_OK    Success, next element will be returned by Next()
//      S_FALSE Overflow, enumerator must be reset to return more elements
//  History:
//      2/2/99 - MikeSwa fixed overflow handling
//
//-----------------------------------------------------------------------------
HRESULT CEnumMessages::Skip(ULONG cElements) 
{
    m_iMessage += cElements;
    if ((m_iMessage >= m_cMessages) || (m_iMessage < cElements))
    {
        m_iMessage = m_cMessages;
        return S_FALSE;
    } 
    else 
    {
        return S_OK;
    }	
}

HRESULT CEnumMessages::Reset() {
    m_iMessage = 0;
    return S_OK;
}

//---[ CEnumMessages::Clone ]--------------------------------------------------
//
//
//  Description: 
//      Clones this enumerator
//  Parameters:
//      OUT ppEnum      New enumerator
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocated associated memory
//      E_POINTER if ppEnum is NULL
//  History:
//      2/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CEnumMessages::Clone(IAQEnumMessages **ppEnum) 
{
    if (!m_prefp)
        return E_OUTOFMEMORY;

    if (!ppEnum)
        return E_POINTER;

    *ppEnum = (IAQEnumMessages *) new CEnumMessages(NULL, m_cMessages);

    if (!*ppEnum)
        return E_OUTOFMEMORY;

    ((CEnumMessages *)(*ppEnum))->m_rgMessages = m_rgMessages;
    ((CEnumMessages *)(*ppEnum))->m_prefp = m_prefp;
    ((CEnumMessages *)(*ppEnum))->m_iMessage = m_iMessage;
    m_prefp->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\makefile.inc ===
$(O)\aqadmin.h $(O)\aqadmin.c : $(STAXINC)\export\aqadmin.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqadmin_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqadmin.c \
    -header $@ \
    -tlb $(O)\aqadmin.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqadmrpc.h $(O)\aqadmrpc_c.c : ..\..\inc\aqadmrpc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -server none \
    -cstub $(O)\aqadmrpc_c.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\aqerr.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc
    copy $(O)\msg00001.bin $(O)\aqerr.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlnkq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlinkq.h
//
//  Description: Header for CEnumLinkQueues which implements IEnumLinkQueues
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __ENUMLNKQ_H__
#define __ENUMLNKQ_H__

class CEnumLinkQueues :
	public CComRefCount,
	public IEnumLinkQueues
{
	public:
		CEnumLinkQueues(CVSAQAdmin *pVS, 
                        QUEUELINK_ID *rgQueueIds, 
                        DWORD cQueueIds);
		virtual ~CEnumLinkQueues();

		HRESULT Initialize(LPCSTR szVirtualServerDN);

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IEnumLinkQueues) {
				*ppv = static_cast<IEnumLinkQueues *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IEnumLinkQueues
		COMMETHOD Next(ULONG cElements, 
					   ILinkQueue **rgElements,
					   ULONG *pcReturned);
		COMMETHOD Skip(ULONG cElements);
		COMMETHOD Reset();
		COMMETHOD Clone(IEnumLinkQueues **ppEnum);
    private:
        CVSAQAdmin     *m_pVS;
        QUEUELINK_ID   *m_rgQueueIds;
        DWORD           m_cQueueIds;
        DWORD           m_iQueueId;
        CQueueLinkIdContext *m_prefp;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlnkq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlinkq.cpp
//
//  Description: Implementation of CEnumLinkQueues which implements 
//      IEnumLinkQueues
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CEnumLinkQueues::CEnumLinkQueues(CVSAQAdmin *pVS,
                                 QUEUELINK_ID *rgQueueIds,
                                 DWORD cQueueIds) 
{
    _ASSERT(rgQueueIds);
    _ASSERT(pVS);
    pVS->AddRef();
    m_rgQueueIds = rgQueueIds;
    m_pVS = pVS;
    m_iQueueId = 0;
    m_cQueueIds = cQueueIds;

    if (m_rgQueueIds)
        m_prefp = new CQueueLinkIdContext(m_rgQueueIds, cQueueIds);
    else 
        m_prefp = NULL;
}

CEnumLinkQueues::~CEnumLinkQueues() {

    if (m_prefp)
    {
        m_rgQueueIds = NULL;
        m_prefp->Release();
        m_prefp = NULL;
    }

    if (m_pVS) 
    {
        m_pVS->Release();
        m_pVS = NULL;
    }
}

//---[ CEnumLinkQueues::Next ]-------------------------------------------------
//
//
//  Description: 
//      Gets the next ILinkQueue for this enumerator
//  Parameters:
//      IN      cElements   Elements to return
//      IN OUT  rgElements  Array to recieve new elements
//      OUT     pcGetched   Number of elements returned
//  Returns:
//      S_OK on success
//      S_FALSE with no more elements
//      E_POINTER on NULL args
//  History:
//      1/30/99 - MikeSwa Fixed AV on bogus args
//
//-----------------------------------------------------------------------------
HRESULT CEnumLinkQueues::Next(ULONG cElements,
                              ILinkQueue **rgElements,
                              ULONG *pcFetched)
{
    DWORD iQueueIdNew = m_iQueueId + cElements;
    DWORD i;
    HRESULT hr = S_OK;

    if (!rgElements || !pcFetched)
    {
        hr = E_POINTER;
        goto Exit;
    }

    // make sure we don't go past the end of the array
    if (iQueueIdNew > m_cQueueIds) iQueueIdNew = m_cQueueIds;

    // make a CVSAQLink object for each element and copy it into the user's
    // array
	(*pcFetched) = 0;
    for (i = m_iQueueId; (i < iQueueIdNew); i++) {
        rgElements[(*pcFetched)] = 
            (ILinkQueue *) new CLinkQueue(m_pVS, &(m_rgQueueIds[i]));

        // make sure that the allocation worked
        if (rgElements[(*pcFetched)] == NULL) {
            // remember how far we were able to go.
            iQueueIdNew = i;
            // if it didn't work and this was the first element then we
            // return out of memory.  if its not the first element then
            // return what we've built up so far.
            if (i == 0) hr = E_OUTOFMEMORY;
            // drop out of the loop
            break;
        } else {
			(*pcFetched)++;
		}
    }
	
    _ASSERT(*pcFetched <= cElements);
        
    m_iQueueId = iQueueIdNew;

    if (SUCCEEDED(hr) && *pcFetched < cElements) hr = S_FALSE;

  Exit:
    if (FAILED(hr))
    {
        if (pcFetched)
            *pcFetched = 0;
    }

	return hr;
}

//---[ CEnumLinkQueues::Skip ]-------------------------------------------------
//
//
//  Description: 
//      Skips forward the specified number of elements in the enumerator
//  Parameters:
//      IN  cElements       The number of elements to skip forward
//  Returns:
//      S_OK    Success, next element will be returned by Next()
//      S_FALSE Overflow, enumerator must be reset to return more elements
//  History:
//      2/2/99 - MikeSwa fixed overflow handling
//
//-----------------------------------------------------------------------------
HRESULT CEnumLinkQueues::Skip(ULONG cElements) 
{
    m_iQueueId += cElements;
    if ((m_iQueueId >= m_cQueueIds) || (m_iQueueId < cElements))
    {
        m_iQueueId = m_cQueueIds;
        return S_FALSE;
    } 
    else 
    {
        return S_OK;
    }
}

HRESULT CEnumLinkQueues::Reset() {
    m_iQueueId = 0;
    return S_OK;
}

//---[ CEnumLinkQueues::Clone ]------------------------------------------------
//
//
//  Description: 
//      Clones this enumerator
//  Parameters:
//      OUT ppEnum      New enumerator
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocated associated memory
//      E_POINTER if ppEnum is NULL
//  History:
//      2/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CEnumLinkQueues::Clone(IEnumLinkQueues **ppEnum) 
{
    if (!m_prefp)
        return E_OUTOFMEMORY;

    if (!ppEnum)
        return E_POINTER;

    *ppEnum = (IEnumLinkQueues *) new CEnumLinkQueues(m_pVS, NULL, m_cQueueIds);

    if (!*ppEnum)
        return E_OUTOFMEMORY;

    ((CEnumLinkQueues *)(*ppEnum))->m_rgQueueIds = m_rgQueueIds;
    ((CEnumLinkQueues *)(*ppEnum))->m_prefp = m_prefp;
    ((CEnumLinkQueues *)(*ppEnum))->m_iQueueId = m_iQueueId;
    m_prefp->AddRef();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\stdatl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdinc.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (DWORD)((dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL));

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqadm.h ===
//-----------------------------------------------------------------------------
//
//
//  File: vsaqadm.h
//
//  Description: Header for CVSAQAdmin which implements IVSAQAdmin.  This is
//      the top level interface for a virtual server. It provides the ability
//      to enumerate links, stop/start all outbound connections, and apply 
//      actions to all messages based on a filter
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __VSAQADM_H__
#define __VSAQADM_H__

#define CVSAQAdmin_SIG 'SVAQ'

class CVSAQAdmin :
	public CComRefCount,
	public IVSAQAdmin,
    public IAQMessageAction
{
	public:
		CVSAQAdmin();
		virtual ~CVSAQAdmin();

		HRESULT Initialize(LPCWSTR wszComputer, LPCWSTR wszVirtualServer);
        WCHAR *GetComputer() { return m_wszComputer; }
        WCHAR *GetVirtualServer() { return m_wszVirtualServer; }

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IVSAQAdmin *>(this);
			} else if (iid == IID_IVSAQAdmin) {
				*ppv = static_cast<IVSAQAdmin *>(this);
			} else if (iid == IID_IAQMessageAction) {
				*ppv = static_cast<IAQMessageAction *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IVSAQAdmin
		COMMETHOD GetLinkEnum(IEnumVSAQLinks **ppEnum);
		COMMETHOD StopAllLinks();
		COMMETHOD StartAllLinks();
        COMMETHOD GetGlobalLinkState();

        //IAQMessageAction
		COMMETHOD ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs);
        COMMETHOD QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                        OUT DWORD *pdwSupportedFilterFlags);

    private:
        DWORD  m_dwSignature;
        WCHAR *m_wszComputer;
        WCHAR *m_wszVirtualServer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqlink.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: vsaqlink.cpp
//
//  Description: Implementation of CVSAQLink which implements IVSAQLink
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CVSAQLink::CVSAQLink(CVSAQAdmin *pVS, QUEUELINK_ID *pqlidLink) {
    TraceFunctEnter("CVSAQLink::CVSAQLink");
    
    _ASSERT(pVS);
    pVS->AddRef();
    m_pVS = pVS;
    m_prefp = NULL;

    if (!fCopyQueueLinkId(&m_qlidLink, pqlidLink))
        ErrorTrace((LPARAM) this, "Unable to copy queue ID");

    TraceFunctLeave();
}

CVSAQLink::~CVSAQLink() {
    TraceFunctEnter("CVSAQLink::");
    
    if (m_pVS) {
        m_pVS->Release();
        m_pVS = NULL;
    }

    if (m_prefp) {
        m_prefp->Release();
        m_prefp = NULL;
    }

    FreeQueueLinkId(&m_qlidLink);

    TraceFunctLeave();
}

HRESULT CVSAQLink::GetInfo(LINK_INFO *pLinkInfo) {
    TraceFunctEnter("CVSAQLink::GetInfo");
    
    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    HRESULT hrLinkDiagnostic = S_OK;
    WCHAR   szDiagnostic[1000] = L"";
    DWORD   dwFacility = 0;
#ifdef PLATINUM
    HINSTANCE   hModule = GetModuleHandle("phatqadm.dll");
#else
    HINSTANCE   hModule = GetModuleHandle("aqadmin.dll");
#endif
    DWORD   cbDiagnostic = 0;
    DWORD   dwErr;

    if (!pLinkInfo)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (CURRENT_QUEUE_ADMIN_VERSION != pLinkInfo->dwVersion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Release old info
    if (m_prefp) {
        m_prefp->Release();
        m_prefp = NULL;
    }

    rc = ClientAQGetLinkInfo(m_pVS->GetComputer(),
                           m_pVS->GetVirtualServer(),
                           &m_qlidLink,
                           pLinkInfo,
                           &hrLinkDiagnostic);

    if (rc) 
    {
        hr = HRESULT_FROM_WIN32(rc);
        goto Exit;
    }

    m_prefp = new CLinkInfoContext(pLinkInfo);
    if (!m_prefp)
    {
        ErrorTrace((LPARAM) this, "Error unable to alloc link context.");
    }

    //Get extended diagnotic information from HRESULT
    if (!(pLinkInfo->fStateFlags & LI_RETRY) || SUCCEEDED(hrLinkDiagnostic))
        goto Exit; //We don't have any interesting error messages to report

    if (!hModule)
    {
        //If we don't have a module... don't return an message string
        ErrorTrace((LPARAM) this, "Unable to get module handle for aqadmin\n");
        goto Exit;
    }
    
    dwFacility = ((0x0FFF0000 & hrLinkDiagnostic) >> 16);

    //If it is not ours... then "un-HRESULT" it
    if (dwFacility != FACILITY_ITF)
        hrLinkDiagnostic &= 0x0000FFFF;

    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |  
                   FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_HMODULE,
                   hModule,
                   hrLinkDiagnostic,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   szDiagnostic,    
                   sizeof(szDiagnostic),    
                   NULL);

    //FormatMessageW returns 0 on failure
    if (!dwErr)
    {
        //We probably did not find the error in our message table
        dwErr = GetLastError();
        ErrorTrace((LPARAM) this, 
            "Error formatting message for link diagnostic 0x%08X", dwErr);

        goto Exit;
    }

    DebugTrace((LPARAM) this, "Found Link Diagnostic %S", szDiagnostic);

    cbDiagnostic = (wcslen(szDiagnostic) + 1) * sizeof(WCHAR);
   
    pLinkInfo->szExtendedStateInfo = (LPWSTR) MIDL_user_allocate(cbDiagnostic);
    if (!pLinkInfo->szExtendedStateInfo)
    {
        ErrorTrace((LPARAM) this, "Unable to allocate szExtendedStateInfo");
        goto Exit;
    }
    
    wcscpy(pLinkInfo->szExtendedStateInfo, szDiagnostic);

    //If it ends with a CRLF... off with it!
    if (L'\r' == pLinkInfo->szExtendedStateInfo[cbDiagnostic/sizeof(WCHAR) - 3])
        pLinkInfo->szExtendedStateInfo[cbDiagnostic/sizeof(WCHAR) - 3] = L'\0';

  Exit:
    TraceFunctLeave();
	return hr;
}

HRESULT CVSAQLink::SetLinkState(LINK_ACTION la) {
    TraceFunctEnter("CVSAQLink::SetLinkState");
    
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQSetLinkState(m_pVS->GetComputer(),
                           m_pVS->GetVirtualServer(),
                           &m_qlidLink,
                           la);
    if (rc) hr = HRESULT_FROM_WIN32(rc);

    TraceFunctLeave();
	return hr;	
}

//---[ CVSAQLink::GetQueueEnum ]-----------------------------------------------
//
//
//  Description: 
//      Gets a IEnumLinkQueues for this link
//  Parameters:
//      OUT ppEnum      IEnumLinkQueues returned by search
//  Returns:
//      S_OK on success
//      S_FALSE... there are no queues
//      E_POINTER when NULL pointer values are passed in.
//  History:
//      1/30/99 - MikeSwa Fixed AV on invalid args
//      6/18/99 - MikeSwa Fixed case where there are no queues
//
//-----------------------------------------------------------------------------
HRESULT CVSAQLink::GetQueueEnum(IEnumLinkQueues **ppEnum) {
    TraceFunctEnter("CVSAQLink::GetQueueEnum");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    DWORD cQueueIds;
    QUEUELINK_ID *rgQueueIds = NULL;
    CEnumLinkQueues *pEnumQueues = NULL;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQGetQueueIDs(m_pVS->GetComputer(), 
                           m_pVS->GetVirtualServer(), 
                           &m_qlidLink,
                           &cQueueIds,
                           &rgQueueIds);
    if (rc) 
    {
        hr = HRESULT_FROM_WIN32(rc);
    } 
    else if (!rgQueueIds || !cQueueIds)
    {
        DebugTrace((LPARAM) this, "Found link with no queues");
        hr = S_FALSE;
        *ppEnum = NULL;
        goto Exit;
    }
    else 
    {
        pEnumQueues = new CEnumLinkQueues(m_pVS, rgQueueIds, cQueueIds);
        if (pEnumQueues == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
    }

    *ppEnum = pEnumQueues;

    if (FAILED(hr)) 
    {
        if (rgQueueIds) MIDL_user_free(rgQueueIds);
        if (pEnumQueues) delete pEnumQueues;
        *ppEnum = NULL;
    } 

  Exit:
    TraceFunctLeave();
    return hr;	
}

HRESULT CVSAQLink::ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs) {
    TraceFunctEnter("CVSAQLink::ApplyActionToMessages");
    
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    if (!pFilter || !pcMsgs)
    {
        hr = E_POINTER;
        if (pcMsgs)
            *pcMsgs = 0;
    }
    else
    {
        rc = ClientAQApplyActionToMessages(m_pVS->GetComputer(),
                                         m_pVS->GetVirtualServer(),
                                         &m_qlidLink,
                                         pFilter,
                                         Action,
                                         pcMsgs);
        if (rc) 
            hr = HRESULT_FROM_WIN32(rc);
    }

    TraceFunctLeave();
	return hr;	
}

//---[ CVSAQLink::QuerySupportedActions ]-------------------------------------
//
//
//  Description: 
//      Function that describes which actions are supported on this interface
//  Parameters:
//      OUT     pdwSupportedActions     Supported message actions
//      OUT     pdwSupportedFilterFlags Supported filter flags
//  Returns:
//      S_OK on success
//      E_POINTER on bogus pointer
//  History:
//      6/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQLink::QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                          OUT DWORD *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CVSAQLink::QuerySupportedActions");
    HRESULT hr = S_OK;
    NET_API_STATUS rc;

    if (!pdwSupportedActions || !pdwSupportedFilterFlags)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQQuerySupportedActions(m_pVS->GetComputer(),
                                       m_pVS->GetVirtualServer(),
                                       &m_qlidLink,
                                       pdwSupportedActions,
                                       pdwSupportedFilterFlags);
    if (rc) 
        hr = HRESULT_FROM_WIN32(rc);

  Exit:
    if (FAILED(hr))
    {
        if (pdwSupportedActions)
            *pdwSupportedActions = 0;

        if (pdwSupportedFilterFlags)
            *pdwSupportedFilterFlags = 0;

    }

    TraceFunctLeave();
    return hr;
}


//---[ CVSAQLink::GetUniqueId ]---------------------------------------------
//
//
//  Description: 
//      Returns a canonical representation of this link.
//  Parameters:
//      OUT pqlid - pointer to QUEUELINK_ID to return
//  Returns:
//      S_OK on success
//      E_POINTER on failure
//  History:
//      12/5/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQLink::GetUniqueId(OUT QUEUELINK_ID **ppqlid)
{
    TraceFunctEnterEx((LPARAM) this, "CVSAQLink::GetUniqueId");
    HRESULT hr = S_OK;

    if (!ppqlid) {
        hr = E_POINTER;
        goto Exit;
    }

    *ppqlid = &m_qlidLink;

  Exit:
    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\aqadmcli.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadmcli.cpp
//
//  Description:
//      Unit test for AQAdmin interface
//
//  Author: 
//      Aldrin Teganeanu (aldrint)
//      Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Updated to new AQAdmin interface
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

const CLSID CLSID_MAQAdmin = {0x0427FFA4,0xAF27,0x11d2,{0x8F,0xAF,0x00,0xC0,0x4F,0xA3,0x78,0xFF}};

//Utility for converting To UNICODE... uses LocalAlloc()
LPWSTR  wszGetUnicodeArg(LPSTR szSrc, DWORD cSrc)
{
    LPWSTR  wszDest = NULL;
    CHAR    chSave = '\0';
    if (!szSrc || !cSrc)
        return NULL;

    wszDest = (LPWSTR) LocalAlloc(LPTR, (cSrc+1)*sizeof(WCHAR));
    if (!wszDest)
        return NULL;

    chSave = szSrc[cSrc];
    szSrc[cSrc] = '\0';
    MultiByteToWideChar(CP_ACP,
                        0,
                        szSrc,
                        -1,
                        wszDest,
                        cSrc+1);
    szSrc[cSrc] = chSave;

    return wszDest;
}


//prints queue link info if it has it
void PrintQueueLinkInfo(IUnknown *pIUnknown)
{

    HRESULT hr = S_OK;
    IUniqueId *pIUniqueId = NULL;
    QUEUELINK_ID *pqlid = NULL;
    CHAR    szGuid[100] = "";

    hr = pIUnknown->QueryInterface(IID_IUniqueId, 
                                   (void **) &pIUniqueId);
    if (FAILED(hr))
        goto Exit;

    hr = pIUniqueId->GetUniqueId(&pqlid);
    if (FAILED(hr)) {
        printf ("GetQueueLinkId failied with hr 0x%08X\n", hr);
        goto Exit;
    }

    //
    //  Get string-ized form of GUID
    //
    StringFromGUID2(pqlid->uuid, (LPOLESTR) szGuid, sizeof(szGuid)-1);
    
    
    printf("QLID:: type %s : Name %S : ID 0x%08X : Guid %S\n",
        (pqlid->qltType == QLT_LINK) ? "link" : ((pqlid->qltType == QLT_QUEUE) ? "queue" : "none"),
        pqlid->szName, pqlid->dwId, szGuid);

  Exit:
    if (pIUniqueId)
        pIUniqueId->Release();

}
//Helper function qo QI and call ApplyActionToMessages
HRESULT ApplyActionToMessages(IUnknown *pIUnknown,
                              MESSAGE_FILTER *pFilter,
                              MESSAGE_ACTION Action,
                              DWORD *pcMsgs)
{
    HRESULT hr = S_OK;
    IAQMessageAction *pIAQMessageAction = NULL;
    if (!pIUnknown)
        return E_POINTER;

    hr = pIUnknown->QueryInterface(IID_IAQMessageAction, 
                                   (void **) &pIAQMessageAction);
    if (FAILED(hr))
        return hr;
    if (!pIAQMessageAction)
        return E_FAIL;

    hr = pIAQMessageAction->ApplyActionToMessages(pFilter, Action, pcMsgs);
    pIAQMessageAction->Release();
    return hr;
}

HRESULT CAQAdminCli::SetMsgAction(MESSAGE_ACTION *pAction, CCmdInfo *pCmd)
{
	char buf[64];
	HRESULT hr = S_OK;

	hr = pCmd->GetValue("ma", buf);
	if(SUCCEEDED(hr))
	{
		// set the action
		if(!lstrcmpi(buf, "DEL"))
			(*pAction) = MA_DELETE;
		else if(!lstrcmpi(buf, "DEL_S"))
			(*pAction) = MA_DELETE_SILENT;
		else if(!lstrcmpi(buf, "FREEZE"))
			(*pAction) = MA_FREEZE_GLOBAL;
		else if(!lstrcmpi(buf, "THAW"))
			(*pAction) = MA_THAW_GLOBAL;
		else if(!lstrcmpi(buf, "COUNT"))
			(*pAction) = MA_COUNT;
		else
			hr = E_FAIL;
	}

	return hr;
}


//---[ CAQAdminCli::SetServer ]------------------------------------------------
//
//
//  Description: 
//      Sets the remote server and virtual server to connect to
//  Parameters:
//      IN  szServerName        The name of the server to connect to 
//      IN  szVSNumber          The stringized version number of the virtual
//                              server to connect to.
//  Returns:
//      S_OK on success
//      Error code from GetVirtualServerAdminITF
//  History:
//      6/5/99 - MikeSwa Updated to supply UNICODE arguments
//
//-----------------------------------------------------------------------------
HRESULT CAQAdminCli::SetServer(LPSTR szServerName, LPSTR szVSNumber)
{
	IVSAQAdmin *pTmpVS = NULL;
    WCHAR   wszServerName[200];
    WCHAR   wszVSNumber[200] = L"1";
    DWORD   cServerName = 0;
    DWORD   cVSNumber = 0;
	HRESULT hr = S_OK;

    *wszServerName = L'\0';
    if (szServerName && *szServerName)
    {
        cServerName = strlen(szServerName);
        if (cServerName*sizeof(WCHAR) < sizeof(wszServerName))
        {
                MultiByteToWideChar(CP_ACP,
                            0,
                            szServerName,
                            -1,
                            wszServerName,
                            cServerName+1);
        }
    }

    if (szVSNumber && *szVSNumber)
    {
        cVSNumber = strlen(szVSNumber);
        if (cVSNumber*sizeof(WCHAR) < sizeof(wszVSNumber))
        {
                MultiByteToWideChar(CP_ACP,
                            0,
                            szVSNumber,
                            -1,
                            wszVSNumber,
                            cVSNumber+1);
        }
    }

	// not going to release the old server until I'm sure
	// that I got the new one.
	hr = m_pAdmin->GetVirtualServerAdminITF(wszServerName, wszVSNumber, &pTmpVS);
	if(FAILED(hr)) 
	{
        printf("Error: GetVirtualServerAdminITF for \"%s\" failed with 0x%x\n", szServerName, hr);
    }
	else
	{
		if(NULL != m_pVS)
			m_pVS->Release();

		m_pVS = pTmpVS;
	}

	return hr;
}


BOOL CAQAdminCli::StringToUTCTime(LPSTR szTime, SYSTEMTIME *pstUTCTime)
{
	// read the date
	WORD wMonth, wDay, wYear, wHour, wMinute, wSecond, wMilliseconds;
	BOOL res;

	int n = sscanf(szTime, "%d/%d/%d %d:%d:%d:%d", 
					&(wMonth),
					&(wDay),
					&(wYear),
					&(wHour),
					&(wMinute),
					&(wSecond),
					&(wMilliseconds));

	if(n == 7)
	{
		// check if it's GMT or UTC time
		if(NULL == strstr(szTime, "UTC") && NULL == strstr(szTime, "GMT"))
		{
			// this is local time
			SYSTEMTIME stLocTime;
			ZeroMemory(&stLocTime, sizeof(SYSTEMTIME));

			stLocTime.wMonth = wMonth;
			stLocTime.wDay = wDay;
			stLocTime.wYear = wYear;
			stLocTime.wHour = wHour;
			stLocTime.wMinute = wMinute;
			stLocTime.wSecond = wSecond;
			stLocTime.wMilliseconds = wMilliseconds;
			
			// convert from local time to UTC time
			if(!LocalTimeToUTC(&stLocTime, pstUTCTime))
			{
				printf("Cannot convert from local time to UTC\n");
				res = FALSE;
				goto Exit;
			}
		}
		else
		{
			// it's already UTC time
			pstUTCTime->wMonth = wMonth;
			pstUTCTime->wDay = wDay;
			pstUTCTime->wYear = wYear;
			pstUTCTime->wHour = wHour;
			pstUTCTime->wMinute = wMinute;
			pstUTCTime->wSecond = wSecond;
			pstUTCTime->wMilliseconds = wMilliseconds;
		}				
	}

Exit:
	return res;
}


BOOL CAQAdminCli::LocalTimeToUTC(SYSTEMTIME *pstLocTime, SYSTEMTIME *pstUTCTime)
{
	// the only way I know how to do it is:
	// - convert local system time to local file time
	// - convert local file time to UTC file time
	// - convert UTC file time to UTC system time

	FILETIME ftLocTime, ftUTCTime;
	BOOL res;

	res = SystemTimeToFileTime(pstLocTime, &ftLocTime);
	res = res && LocalFileTimeToFileTime(&ftLocTime, &ftUTCTime);
	res = res && FileTimeToSystemTime(&ftUTCTime, pstUTCTime);
	
	return res;
}

void CAQAdminCli::FreeStruct(LINK_INFO *pStruct)
{
	if(NULL != pStruct->szLinkName)
	{
		pStruct->szLinkName = NULL;
	}
}

void CAQAdminCli::FreeStruct(QUEUE_INFO *pStruct)
{
	if(NULL != pStruct->szQueueName)
	{
		pStruct->szQueueName = NULL;
	}
    if(NULL != pStruct->szLinkName)
	{
		pStruct->szLinkName = NULL;
	}
}

void CAQAdminCli::FreeStruct(MESSAGE_INFO *pStruct)
{
	if(NULL != pStruct->szMessageId)
	{
		pStruct->szMessageId = NULL;
	}
    if(NULL != pStruct->szSender)
	{
		pStruct->szSender = NULL;
	}
    if(NULL != pStruct->szSubject)
	{
		pStruct->szSubject = NULL;
	}
    if(NULL != pStruct->szRecipients)
	{
		pStruct->szRecipients = NULL;
	}
    if(NULL != pStruct->szCCRecipients)
	{
		pStruct->szCCRecipients = NULL;
	}
    if(NULL != pStruct->szBCCRecipients)
	{
		pStruct->szBCCRecipients = NULL;
	}
}


void CAQAdminCli::FreeStruct(MESSAGE_FILTER *pStruct)
{
	if(NULL != pStruct->szMessageId)
	{
		LocalFree((void*)pStruct->szMessageId);
		pStruct->szMessageId = NULL;
	}
    if(NULL != pStruct->szMessageSender)
	{
		LocalFree((void*)pStruct->szMessageSender);
		pStruct->szMessageSender = NULL;
	}
    if(NULL != pStruct->szMessageRecipient)
	{
		LocalFree((void*)pStruct->szMessageRecipient);
		pStruct->szMessageRecipient = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// Method:		SetMsgFilter()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::SetMsgFilter(MESSAGE_FILTER *pFilter, CCmdInfo *pCmd)
{
	HRESULT hr = S_OK;
	char *buf = NULL;
	int nFlagsOK = 0;

	ZeroMemory(pFilter, sizeof(MESSAGE_FILTER));
	pFilter->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
	hr = pCmd->AllocValue("flags", &buf);
	if(SUCCEEDED(hr))
	{
		// set the filter type
		char *token = strtok(buf, "|");
		while(token != NULL)
		{
			// strip the spaces
			char *st, *en;
			for(st = token; isspace(*st); st++);
			for(en = st; *en; en++);
			for(--en; en > st && isspace(*en); en--);
			
			if(en - st + 1 > 0)
			{
				// found a flag
				char flag[64];
				ZeroMemory(flag, sizeof(flag));
				CopyMemory(flag, st, en - st + 1);

				if(!lstrcmpi(flag, "MSGID"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_MESSAGEID;
				}
				else if(!lstrcmpi(flag, "SENDER"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_SENDER;
				}
				else if(!lstrcmpi(flag, "RCPT"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_RECIPIENT;
				}
				else if(!lstrcmpi(flag, "SIZE"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_SIZE;
				}
				else if(!lstrcmpi(flag, "TIME"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_TIME;
				}
				else if(!lstrcmpi(flag, "FROZEN"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_FROZEN;
				}
				else if(!lstrcmpi(flag, "NOT"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_INVERTSENSE;
				}
				else if(!lstrcmpi(flag, "ALL"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_ALL;
				}
			}

			token = strtok(NULL, "|");	
		}
	}
	
	// if no valid flags or no flags at all fail
	if(0 == nFlagsOK)
	{
		printf("Error: no flags specified for the filter\n");
		hr = E_FAIL;
		goto Exit;
	}
	
	// set the message id
	nFlagsOK = 0;
	hr = pCmd->AllocValue("id", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
            pFilter->szMessageId = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageId)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
		    nFlagsOK++;
		}
	}

	// set the message sender
	nFlagsOK = 0;
	hr = pCmd->AllocValue("sender", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
            pFilter->szMessageSender = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageSender)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
    	    nFlagsOK++;
		}
	}

	// set the message recipient
	nFlagsOK = 0;
	hr = pCmd->AllocValue("rcpt", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			pFilter->szMessageRecipient = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageRecipient)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
			nFlagsOK++;
		}
	}

	// set the min message size
	nFlagsOK = 0;
	hr = pCmd->AllocValue("size", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			char aux[64];
			CopyMemory(aux, st, en - st + 1);
			int n = atoi(aux);
			pFilter->dwLargerThanSize = n;
			nFlagsOK++;
		}
	}

	// set the message date
	nFlagsOK = 0;
	hr = pCmd->AllocValue("date", &buf);
	if(SUCCEEDED(hr))
	{
		if(StringToUTCTime(buf, &(pFilter->stOlderThan)))
			nFlagsOK++;
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
	{
		ZeroMemory(&(pFilter->stOlderThan), sizeof(SYSTEMTIME));
	}

	// if we came this far all is well
	hr = S_OK;
Exit:
	if(NULL != buf)
		delete [] buf;

	// TODO: validate the filter
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		SetMsgEnumFilter()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////

//1/18/99: AldrinT: updated flag parsing for SENDER and RCPT
HRESULT CAQAdminCli::SetMsgEnumFilter(MESSAGE_ENUM_FILTER *pFilter, CCmdInfo *pCmd)
{
	HRESULT hr;
	char *buf = NULL;
	int nFlagsOK = 0;

	ZeroMemory(pFilter, sizeof(MESSAGE_ENUM_FILTER));
	pFilter->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
	hr = pCmd->AllocValue("ft", &buf);
	if(SUCCEEDED(hr))
	{
		// set the filter type
		char *token = strtok(buf, "|");
		while(token != NULL)
		{
			// strip the spaces
			char *st, *en;
			for(st = token; isspace(*st); st++);
			for(en = st; *en; en++);
			for(--en; en > st && isspace(*en); en--);
			
			if(en - st + 1 > 0)
			{
				// found a flag
				char flag[64];
				ZeroMemory(flag, sizeof(flag));
				CopyMemory(flag, st, en - st + 1);

				if(!lstrcmpi(flag, "FIRST_N"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_FIRST_N_MESSAGES;
				}
				else if(!lstrcmpi(flag, "OLDER"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_OLDER_THAN;
				}
				else if(!lstrcmpi(flag, "OLDEST"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_N_OLDEST_MESSAGES;
				}
				else if(!lstrcmpi(flag, "LARGER"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_LARGER_THAN;
				}
				else if(!lstrcmpi(flag, "LARGEST"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_N_LARGEST_MESSAGES;
				}
				else if(!lstrcmpi(flag, "FROZEN"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_FROZEN;
				}
				else if(!lstrcmpi(flag, "NOT"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_INVERTSENSE;
				}
				else if(!lstrcmpi(flag, "ALL"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_ALL;
				}
				else if(!lstrcmpi(flag, "SENDER"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_SENDER;
				}
				else if(!lstrcmpi(flag, "RCPT"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_RECIPIENT;
				}
			}

			token = strtok(NULL, "|");	
		}
	}
	

// Ifdef'd code because this is actually a valid state for skipping messages
//      12/13/98 - MikeSwa
#ifdef NEVER
	// if no valid flags or no flags at all, fail
	if(0 == nFlagsOK)
	{
		printf("Error: no flags specified for the filter\n");
		hr = E_FAIL;
		goto Exit;
	}
#endif 

	// set the message number
	nFlagsOK = 0;
	hr = pCmd->AllocValue("mn", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a flag
			char flag[64];
			ZeroMemory(flag, sizeof(flag));
			CopyMemory(flag, st, en - st + 1);
			int n = atoi(flag);
			if(0 == n)
			{
				printf("Error: message no. is 0 or not an integer. Using default.\n");
			}
			else
			{
				nFlagsOK++;
				pFilter->cMessages = n;
			}
		}
	}


	// set the message size
	nFlagsOK = 0;
	hr = pCmd->AllocValue("ms", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a flag
			char flag[64];
			ZeroMemory(flag, sizeof(flag));
			CopyMemory(flag, st, en - st + 1);
			int n = atoi(flag);
			nFlagsOK++;
			pFilter->cbSize = n;
		}
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
		pFilter->cbSize = 0;

	// set the message date
	nFlagsOK = 0;
	hr = pCmd->AllocValue("md", &buf);
	if(SUCCEEDED(hr))
	{
		if(StringToUTCTime(buf, &(pFilter->stDate)))
			nFlagsOK++;
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
	{
		ZeroMemory(&(pFilter->stDate), sizeof(SYSTEMTIME));
	}

	// set the skip message number
	nFlagsOK = 0;
	hr = pCmd->AllocValue("sk", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a flag
			char flag[64];
			ZeroMemory(flag, sizeof(flag));
			CopyMemory(flag, st, en - st + 1);
			int n = atoi(flag);
			nFlagsOK++;
			pFilter->cSkipMessages = n;
		}
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
	{
		pFilter->cSkipMessages = 0;
	}

	// set the sender value
	nFlagsOK = 0;
	hr = pCmd->AllocValue("msndr", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			pFilter->szMessageSender = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageSender)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
			nFlagsOK++;
		}
	}

	// set the recipient value
	nFlagsOK = 0;
	hr = pCmd->AllocValue("mrcpt", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			pFilter->szMessageRecipient = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageRecipient)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
			nFlagsOK++;
		}
	}

    if(!pFilter->mefType)
    {
		pFilter->cMessages = 1;
		pFilter->mefType |= MEF_FIRST_N_MESSAGES;
    }

	// if we came this far all is well
	hr = S_OK;
	// TODO: validate the filter
	if(NULL != buf)
		delete [] buf;
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		IsContinue()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
BOOL CAQAdminCli::IsContinue(LPSTR pszTag, LPWSTR wszVal)
{
	int nValidTags = 0;
    CHAR  szVal[200] = "";

	for(CCmdInfo::CArgList *p = m_pFilterCmd->pArgs; NULL != p; p = p->pNext)
	{
		// set the tag to the default value if not already set
		if(p->szTag[0] == 0 && m_pFilterCmd->szDefTag[0] != 0)
			lstrcpy(p->szTag, m_pFilterCmd->szDefTag);
		// count valid tags
		if(!lstrcmpi(p->szTag, pszTag))
			nValidTags++;
	}

	if(!nValidTags)
		return TRUE;

    //Convert in param to ASCII
    WideCharToMultiByte(CP_ACP, 0, wszVal, -1, szVal, 
                        sizeof(szVal), NULL, NULL);

	for(p = m_pFilterCmd->pArgs; NULL != p; p = p->pNext)
	{
		if(pszTag && lstrcmpi(p->szTag, pszTag))
			continue;

		if(szVal && lstrcmpi(p->szVal, szVal))
			continue;

		return TRUE;						
	}

	return FALSE;
}



////////////////////////////////////////////////////////////////////////////
// Method:		PrintMsgInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::PrintMsgInfo()
{
	HRESULT hr;
	int nCrtLink, nCrtQueue, nCrtMsg;

	IEnumVSAQLinks *pLinkEnum = NULL;
	IEnumLinkQueues *pQueueEnum = NULL;
	IAQEnumMessages *pMsgEnum = NULL;

    IVSAQLink *pLink = NULL;
	ILinkQueue *pQueue = NULL;
	IAQMessage *pMsg = NULL;

	LINK_INFO linkInf;
	QUEUE_INFO queueInf;
	MESSAGE_INFO msgInf;
	ZeroMemory(&linkInf, sizeof(LINK_INFO));
	ZeroMemory(&queueInf, sizeof(QUEUE_INFO));
	ZeroMemory(&msgInf, sizeof(MESSAGE_INFO));
		
	hr = m_pVS->GetLinkEnum(&pLinkEnum);
	if(FAILED(hr)) 
	{
		printf("GetLinkEnum failed with 0x%x\n", hr);
		goto Exit;
	}

	for(nCrtLink = 1; TRUE; nCrtLink++) 
	{
		if(NULL != pLink)
		{
			pLink->Release();
			pLink = NULL;
		}
		FreeStruct(&linkInf);
		hr = GetLink(pLinkEnum, &pLink, &linkInf);
		if(hr == S_FALSE)
		{
			if(nCrtLink == 1)
				puts("No links.");
			goto Exit;
		}
		else if(FAILED(hr))
		{
			break;
		}
		else if(hr == S_OK)
		{
			// check if we want messages for this link
			if(!IsContinue("ln", linkInf.szLinkName))
				continue;

			hr = pLink->GetQueueEnum(&pQueueEnum);
			if(FAILED(hr)) 
			{
				printf("Error: Link %d: pLink->GetQueueEnum failed with 0x%x\n", nCrtLink, hr);
				continue;
			}

			for(nCrtQueue = 1; TRUE; nCrtQueue++) 
			{
				if(NULL != pQueue)
				{
					pQueue->Release();
					pQueue = NULL;
				}
				FreeStruct(&queueInf);
				hr = GetQueue(pQueueEnum, &pQueue, &queueInf);
				if(hr == S_FALSE)
				{
					if(nCrtQueue == 1)
						puts("No queues.");
					break;
				}
				else if(FAILED(hr))
					break;
			
				// check if we want messages for this queue
				if(!IsContinue("qn", queueInf.szQueueName))
					continue;

				if(!lstrcmpi(m_pActionCmd->szCmdKey, "MSG_INFO"))
				{
					MESSAGE_ENUM_FILTER Filter;			
	
					// enum the messages
					SetMsgEnumFilter(&Filter, m_pFilterCmd);
				
					hr = pQueue->GetMessageEnum(&Filter, &pMsgEnum);
					if(FAILED(hr)) 
					{
						printf("Error: Link %d, Queue %d: pQueue->GetMessageEnum failed with 0x%x\n", nCrtLink, nCrtQueue, hr);
						continue;
					}
				
					printf("---- Messages in queue %S ----\n", queueInf.szQueueName);
					
					for(nCrtMsg = 1; TRUE; nCrtMsg++) 
					{
						FreeStruct(&msgInf);
						hr = GetMsg(pMsgEnum, &pMsg, &msgInf);
						if(NULL != pMsg)
						{
							pMsg->Release();
							pMsg = NULL;
						}
						if(hr == S_FALSE)
						{
							if(nCrtMsg == 1)
								puts("No messages.");
							break;
						}
						else if(hr == S_OK)
						{
							PInfo(nCrtMsg, msgInf);
						}
						else if(FAILED(hr))
							break;
					}
				}
				else if(!lstrcmpi(m_pActionCmd->szCmdKey, "DEL_MSG"))
				{
					MESSAGE_FILTER Filter;
                    DWORD cMsgs = 0;

					hr = SetMsgFilter(&Filter, m_pFilterCmd);
					if(SUCCEEDED(hr))
					{
						hr = ApplyActionToMessages(pQueue, &Filter, MA_DELETE_SILENT, &cMsgs);
						if(FAILED(hr))
							printf("Error: Link %d, Queue %d: pQueue->ApplyActionToMessages failed with 0x%x\n", nCrtLink, nCrtQueue, hr);
						else
							printf("Operation succeeded on %d messages\n", cMsgs);
					}

					FreeStruct(&Filter);
				}
			}
			if(NULL != pQueue)
			{
				pQueue->Release();
				pQueue = NULL;
			}
			if(NULL != pQueueEnum)
			{
				pQueueEnum->Release();
				pQueueEnum = NULL;
			}
		}
	
	}

Exit:
	FreeStruct(&linkInf);
	FreeStruct(&queueInf);
	FreeStruct(&msgInf);
	
	if(NULL != pLink)
	{
		pLink->Release();
		pLink = NULL;
	}
	if(NULL != pLinkEnum)
	{
		pLinkEnum->Release();
	}
    if(NULL != pMsgEnum)
    {
        pMsgEnum->Release();
    }
	return hr;
}



////////////////////////////////////////////////////////////////////////////
// Method:		PrintQueueInfo()
// Member of:	CAQAdminCli
// Arguments:	none
// Returns:		S_OK
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::PrintQueueInfo()
{
	HRESULT hr;
	int nCrtLink, nCrtQueue;

	IEnumVSAQLinks *pLinkEnum = NULL;
	IEnumLinkQueues *pQueueEnum = NULL;
    IVSAQLink *pLink = NULL;
	ILinkQueue *pQueue = NULL;
	
	LINK_INFO linkInf;
	QUEUE_INFO queueInf;
	ZeroMemory(&linkInf, sizeof(LINK_INFO));
	ZeroMemory(&queueInf, sizeof(QUEUE_INFO));
			
		
	hr = m_pVS->GetLinkEnum(&pLinkEnum);
	if(FAILED(hr)) 
	{
		printf("Error: GetLinkEnum failed with 0x%x\n", hr);
		goto Exit;
	}

	for(nCrtLink = 1; TRUE; nCrtLink++) 
	{
		if(NULL != pLink)
		{
			pLink->Release();
			pLink = NULL;
		}
		FreeStruct(&linkInf);
		hr = GetLink(pLinkEnum, &pLink, &linkInf);
		if(hr == S_FALSE)
		{
			if(nCrtLink == 1)
				puts("No links.");
			break;
		}
		else if(FAILED(hr))
		{
			break;
		}
		else if(hr == S_OK)
		{
			// check if we want queues for this link
			if(!IsContinue("ln", linkInf.szLinkName))
				continue;

			hr = pLink->GetQueueEnum(&pQueueEnum);
			if(FAILED(hr)) 
			{
				printf("Error: Link %d: pLink->GetQueueEnum failed with 0x%x\n", nCrtLink, hr);
				continue;
			}

            PrintQueueLinkInfo(pLink);
			printf("---- Queues for link %S ----\n", linkInf.szLinkName);
				
			for(nCrtQueue = 1; TRUE; nCrtQueue++) 
			{
				if(NULL != pQueue)
				{
					pQueue->Release();
					pQueue = NULL;
				}
				FreeStruct(&queueInf);
				hr = GetQueue(pQueueEnum, &pQueue, &queueInf);

				if(hr == S_FALSE)
				{
					if(nCrtQueue == 1)
						puts("No queues.");
					break;
				}
				else if(FAILED(hr))
				{
					break;
				}
				else if(hr == S_OK)
				{
					// check if we want this queue
					if(!IsContinue("qn", queueInf.szQueueName))
						continue;

                    PrintQueueLinkInfo(pQueue);
					if(!lstrcmpi(m_pActionCmd->szCmdKey, "QUEUE_INFO"))
						PInfo(nCrtQueue, queueInf);
					else if(!lstrcmpi(m_pActionCmd->szCmdKey, "MSGACTION"))
					{
						MESSAGE_ACTION Action;
						MESSAGE_FILTER Filter;
						char buf[64];
						ZeroMemory(buf, sizeof(buf));

						hr = SetMsgAction(&Action, m_pFilterCmd);
						if(FAILED(hr))
						{
							printf("Error: must specify a message action\n");
						}
						else
						{
							DWORD cMsgs = 0;
							// set the filter
							hr = SetMsgFilter(&Filter, m_pFilterCmd);
							if(SUCCEEDED(hr))
							{
								hr = ApplyActionToMessages(pQueue, &Filter, Action, &cMsgs);
								if(FAILED(hr))
								{
									printf("Link %S, Queue %S: pLink->ApplyActionToMessages failed with 0x%x\n", linkInf.szLinkName, queueInf.szQueueName, hr);
								}
								else
									printf("Link %S, Queue %S: pLink->ApplyActionToMessages succeeded on %d Messages\n", linkInf.szLinkName, queueInf.szQueueName, cMsgs);
							}
							FreeStruct(&Filter);
						}				
					}
				}
			}
			if(NULL != pQueueEnum)
			{
				pQueueEnum->Release();
				pQueueEnum = NULL;
			}
            if(NULL != pQueue)
			{
			    pQueue->Release();
				pQueue = NULL;
            }
		}
	
		if(NULL != pLink)
		{
			pLink->Release();
			pLink = NULL;
		}
	}

Exit:
	FreeStruct(&linkInf);
	FreeStruct(&queueInf);
	if(NULL != pLinkEnum)
	{
		pLinkEnum->Release();
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		PrintLinkInfo()
// Member of:	CAQAdminCli
// Arguments:	none
// Returns:		S_OK
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::PrintLinkInfo()
{
	HRESULT hr;
	IEnumVSAQLinks *pLinkEnum = NULL;
	int nCrt = 0;

	LINK_INFO linkInf;
	ZeroMemory(&linkInf, sizeof(LINK_INFO));
    
	hr = m_pVS->GetLinkEnum(&pLinkEnum);
	if(FAILED(hr)) 
	{
		printf("Error: GetLinkEnum failed with 0x%x\n", hr);
		goto Exit;
	}

	for(nCrt = 1; TRUE; nCrt++) 
	{
		IVSAQLink *pLink = NULL;
		FreeStruct(&linkInf);
		hr = GetLink(pLinkEnum, &pLink, &linkInf);

		if(hr == S_FALSE)
		{
			if(nCrt == 1)
				puts("No links.");
			break;
		}
		else if(FAILED(hr))
		{
			break;
		}
		else if(hr == S_OK)
		{
			// check if we want link info. for this link
			if(!IsContinue("ln", linkInf.szLinkName))
            {
			    pLink->Release();
                pLink = NULL;
				continue;
            }

			if(!lstrcmpi(m_pActionCmd->szCmdKey, "LINK_INFO"))
				PInfo(nCrt, linkInf);
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "FREEZE"))
			{
				hr = pLink->SetLinkState(LA_FREEZE);
				if(SUCCEEDED(hr))
					printf("Link %S was frozen\n", linkInf.szLinkName);
				else
					printf("Link %S: SetLinkState() failed with 0x%x\n", linkInf.szLinkName, hr);
			}
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "THAW"))
			{
				hr = pLink->SetLinkState(LA_THAW);
				if(SUCCEEDED(hr))
					printf("Link %S was un-frozen\n", linkInf.szLinkName);
				else
					printf("Link %S: SetLinkState() failed with 0x%x\n", linkInf.szLinkName, hr);
			}
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "KICK"))
			{
				hr = pLink->SetLinkState(LA_KICK);
				if(SUCCEEDED(hr))
					printf("Link %S was kicked\n", linkInf.szLinkName);
				else
					printf("Link %S: SetLinkState() failed with 0x%x\n", linkInf.szLinkName, hr);
			}
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "MSGACTION"))
			{
				MESSAGE_ACTION Action;
				MESSAGE_FILTER Filter;
				char buf[64];
				ZeroMemory(buf, sizeof(buf));

				hr = SetMsgAction(&Action, m_pFilterCmd);
				if(FAILED(hr))
				{
					printf("Error: must specify a message action\n");
				}
				else
				{
					DWORD cMsgs = 0;
					// set the filter
					hr = SetMsgFilter(&Filter, m_pFilterCmd);
					if(SUCCEEDED(hr))
					{
						hr = ApplyActionToMessages(pLink, &Filter, Action, &cMsgs);
						if(FAILED(hr))
						{
							printf("Link %S: pLink->ApplyActionToMessages failed with 0x%x\n", linkInf.szLinkName, hr);
						}
						else
							printf("Link %S: pLink->ApplyActionToMessages succeeded on %d Messages\n", linkInf.szLinkName, cMsgs);
					}
					FreeStruct(&Filter);
				}				
			}
		}
	
        if(NULL != pLink)
        {
			pLink->Release();
            pLink = NULL;
        }
	}
Exit:
	FreeStruct(&linkInf);
	if(NULL != pLinkEnum)
	{
		pLinkEnum->Release();
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		PInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::PInfo(int nCrt, MESSAGE_INFO msgInf)
{
	// convert the UTC time to local time
	SYSTEMTIME stLocSubmit, stLocRecv, stLocExpire;
	BOOL res;
    CHAR szTimeSuffix[] = " UTC";
    LPWSTR wszCurrent = NULL;
   	SYSTEMTIME *pstSubmit = &msgInf.stSubmission;
	SYSTEMTIME *pstReceived = &msgInf.stReceived;
	SYSTEMTIME *pstExpire = &msgInf.stExpiry;

	res = SystemTimeToTzSpecificLocalTime(NULL, &msgInf.stSubmission, &stLocSubmit);
	res = res && SystemTimeToTzSpecificLocalTime(NULL, &msgInf.stReceived, &stLocRecv);
	res = res && SystemTimeToTzSpecificLocalTime(NULL, &msgInf.stExpiry, &stLocExpire);

	if(res)
    {
        //Use localized times 
		pstSubmit = &stLocSubmit;
		pstReceived = &stLocRecv;
		pstExpire = &stLocExpire;
        szTimeSuffix[1] = '\0'; //" \0TC"
    }

    printf("%d.Message ID: %S, Priority: %s %s, Version: %ld, Size: %ld\n"
           "  Flags 0x%08X\n"
           "  %ld EnvRecipients (%ld bytes): \n", 
			nCrt,
			msgInf.szMessageId, 
			msgInf.fMsgFlags & MP_HIGH ? "High" : (msgInf.fMsgFlags & MP_NORMAL ? "Normal" : "Low"),
            msgInf.fMsgFlags & MP_MSG_FROZEN ? "(frozen)" : "",
			msgInf.dwVersion,
			msgInf.cbMessageSize,
            msgInf.fMsgFlags,
            msgInf.cEnvRecipients,
            msgInf.cbEnvRecipients);

    //spit out recipients
    wszCurrent = msgInf.mszEnvRecipients;
    while (wszCurrent && *wszCurrent)
    {
        printf("\t%S\n", wszCurrent);
        while (*wszCurrent)
            wszCurrent++;
        wszCurrent++;
    }

    //print error if msgInf.mszEnvRecipients is malformed
    if ((1+wszCurrent-msgInf.mszEnvRecipients)*sizeof(WCHAR) != msgInf.cbEnvRecipients)
    {
        printf("\tERROR mszEnvRecipients malformatted (found %ld instead of %ld bytes)\n",
            (wszCurrent-msgInf.mszEnvRecipients)*sizeof(WCHAR),
            msgInf.cbEnvRecipients);
    }

    
    printf("  %ld Recipients: %S\n"
           "  %ld Cc recipients: %S\n"
           "  %ld Bcc recipients: %S\n"
           "  Sender: %S\n"
           "  Subject: %S\n"
           "  Submitted: %d/%d/%d at %d:%02d:%02d:%03d%s\n"
           "  Received:  %d/%d/%d at %d:%02d:%02d:%03d%s\n"
           "  Expires:   %d/%d/%d at %d:%02d:%02d:%03d%s\n"
           "  %ld Failed Delivery attempts\n",
			msgInf.cRecipients, 
			msgInf.szRecipients,
			msgInf.cCCRecipients,
			msgInf.szCCRecipients,
			msgInf.cBCCRecipients,
			msgInf.szBCCRecipients,
			msgInf.szSender,
			msgInf.szSubject,
			pstSubmit->wMonth,
			pstSubmit->wDay,
			pstSubmit->wYear,
			pstSubmit->wHour,
			pstSubmit->wMinute,
			pstSubmit->wSecond,
			pstSubmit->wMilliseconds,
            szTimeSuffix,
			pstReceived->wMonth,
			pstReceived->wDay,
			pstReceived->wYear,
			pstReceived->wHour,
			pstReceived->wMinute,
			pstReceived->wSecond,
			pstReceived->wMilliseconds,
            szTimeSuffix,
			pstExpire->wMonth,
			pstExpire->wDay,
			pstExpire->wYear,
			pstExpire->wHour,
			pstExpire->wMinute,
			pstExpire->wSecond,
			pstExpire->wMilliseconds,
            szTimeSuffix,
            msgInf.cFailures);
}

////////////////////////////////////////////////////////////////////////////
// Method:		PInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::PInfo(int nCrt, QUEUE_INFO queueInf)
{
	printf(	"%d.Name: %S, Version: %ld, No. of messages: %ld\n"
			"  Link name: %S, Volume: %ld\n",
			nCrt,
			queueInf.szQueueName, 
			queueInf.dwVersion, 
			queueInf.cMessages, 
			queueInf.szLinkName,
			queueInf.cbQueueVolume);
}

////////////////////////////////////////////////////////////////////////////
// Method:		PInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::PInfo(int nCrt, LINK_INFO linkInf)
{
	// convert the UTC time to local time
	SYSTEMTIME stLocNextConn, stLocOldest;
	BOOL res;
	char *pszFormat, *pszState;
	SYSTEMTIME *pstNext, *pstOld;
    char szSupportedLinkActions[50] = "";

    if (linkInf.fStateFlags & LI_ACTIVE )
		pszState = "Active";
    else if (linkInf.fStateFlags & LI_READY)
		pszState = "Ready";
	else if (linkInf.fStateFlags & LI_RETRY)
		pszState = "Retry";
	else if (linkInf.fStateFlags & LI_SCHEDULED)
		pszState = "Scheduled";
	else if (linkInf.fStateFlags & LI_REMOTE)
		pszState = "Remote";
	else if (linkInf.fStateFlags & LI_FROZEN)
		pszState = "Frozen";
	else
		pszState = "Unknown";

    if (linkInf.dwSupportedLinkActions & LA_FREEZE)
        strcpy(szSupportedLinkActions, "Freeze");
    if (linkInf.dwSupportedLinkActions & LA_THAW)
        strcat(szSupportedLinkActions, " Thaw");
    if (linkInf.dwSupportedLinkActions & LA_KICK)
        strcat(szSupportedLinkActions, " Kick");

    if (!szSupportedLinkActions[0])
        strcpy(szSupportedLinkActions, "Link can only be viewed.");

	res = SystemTimeToTzSpecificLocalTime(NULL, &linkInf.stNextScheduledConnection, &stLocNextConn);
	res = res && SystemTimeToTzSpecificLocalTime(NULL, &linkInf.stOldestMessage, &stLocOldest);

	if(res)
	{
		pszFormat = "%d.Name: %S, Version: %ld\n"
					"  No. of messages: %ld, State: %s [0x%08X], Volume: %ld\n"
					"  Next scheduled connection: %d/%d/%d at %d:%02d:%02d:%03d\n"
					"  Oldest message: %d/%d/%d at %d:%02d:%02d:%03d\n"
                    "  Supported Link Actions: %s\n"
                    "  Link Diagnostic: %S\n";
		pstNext = &stLocNextConn;
		pstOld = &stLocOldest;
	}
	else
	{
		pszFormat = "%d.Name: %S, Version: %ld\n"
					"  No. of messages: %ld, State: %s [0x%08X], Volume: %ld\n"
					"  Next scheduled connection: %d/%d/%d at %d:%02d:%02d:%03d UTC\n"
					"  Oldest message: %d/%d/%d at %d:%02d:%02d:%03d UTC\n"
                    "  Supported Link Actions: %s\n"
                    "  Link Diagnostic: %S\n";
		pstNext = &linkInf.stNextScheduledConnection;
		pstOld = &linkInf.stOldestMessage;
	}
	
	printf(pszFormat, 
			nCrt,
			linkInf.szLinkName, 
			linkInf.dwVersion, 
			linkInf.cMessages, 
			pszState,
            linkInf.fStateFlags,
			linkInf.cbLinkVolume.LowPart,
			pstNext->wMonth,
			pstNext->wDay,
			pstNext->wYear,
			pstNext->wHour,
			pstNext->wMinute,
			pstNext->wSecond,
			pstNext->wMilliseconds,
			pstOld->wMonth,
			pstOld->wDay,
			pstOld->wYear,
			pstOld->wHour,
			pstOld->wMinute,
			pstOld->wSecond,
			pstOld->wMilliseconds,
            szSupportedLinkActions,
            linkInf.szExtendedStateInfo);
}


////////////////////////////////////////////////////////////////////////////
// Method:		GetMsg()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetMsg(IN IAQEnumMessages *pMsgEnum, OUT IAQMessage **ppMsg, IN OUT MESSAGE_INFO *pMsgInf)
{
	HRESULT hr;
	DWORD cFetched;

	hr = pMsgEnum->Next(1, ppMsg, &cFetched);
	if(hr == S_FALSE)
	{
		goto Exit;
	}
	else if(FAILED(hr)) 
	{
		printf("pMsgEnum->Next failed with 0x%x\n", hr);
		goto Exit;
	}
	else if(NULL == (*ppMsg))
	{
		printf("pMsg is NULL.\n", hr);
		goto Exit;
	}
	else
	{
		ZeroMemory(pMsgInf, sizeof(MESSAGE_INFO));
        pMsgInf->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
		hr = (*ppMsg)->GetInfo(pMsgInf);
		if(FAILED(hr))
		{
			printf("pMsg->GetInfo failed with 0x%x\n", hr);
			goto Exit;
		}
	}

Exit:
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		GetQueue()
// Member of:	CAQAdminCli
// Arguments:	
// Returns:		S_FALSE - no more links
//				S_OK - success
// Description:	Caller must allocate pQueueInf
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetQueue(IN IEnumLinkQueues *pQueueEnum, OUT ILinkQueue **ppQueue, IN OUT QUEUE_INFO *pQueueInf)
{
	HRESULT hr;
	DWORD cFetched;

    if (NULL == pQueueEnum)
         return S_FALSE;

	hr = pQueueEnum->Next(1, ppQueue, &cFetched);
	if(hr == S_FALSE)
	{
		goto Exit;
	}
	else if(FAILED(hr)) 
	{
		printf("pQueueEnum->Next failed with 0x%x\n", hr);
		goto Exit;
	}
	else if(NULL == (*ppQueue))
	{
		printf("pQueue is NULL.\n", hr);
		goto Exit;
	}
	else
	{
		ZeroMemory(pQueueInf, sizeof(QUEUE_INFO));
        pQueueInf->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
		hr = (*ppQueue)->GetInfo(pQueueInf);
		if(FAILED(hr))
		{
			printf("pQueue->GetInfo failed with 0x%x\n", hr);
			goto Exit;
		}
	}

Exit:
	return hr;
}



////////////////////////////////////////////////////////////////////////////
// Method:		GetLink()
// Member of:	CAQAdminCli
// Arguments:	
// Returns:		S_FALSE - no more links
//				S_OK - success
// Description:	Caller must allocate pLinkInf
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetLink(IN IEnumVSAQLinks *pLinkEnum, OUT IVSAQLink **ppLink, IN OUT LINK_INFO *pLinkInf)
{
	HRESULT hr;
	DWORD cFetched;

	hr = pLinkEnum->Next(1, ppLink, &cFetched);
	if(hr == S_FALSE)
	{
		goto Exit;
	}
	else if(FAILED(hr)) 
	{
		printf("pLinkEnum->Next failed with 0x%x\n", hr);
		goto Exit;
	}
	else if(NULL == (*ppLink))
	{
		printf("pLink is NULL.\n", hr);
		goto Exit;
	}
	else
	{
		ZeroMemory(pLinkInf, sizeof(LINK_INFO));
        pLinkInf->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
		hr = (*ppLink)->GetInfo(pLinkInf);
		if(FAILED(hr))
		{
			printf("pLink->GetInfo failed with 0x%x\n", hr);
            if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr)
                printf("RPC Server Unavailable.\n");
            else if ( hr == E_POINTER )
                printf("Null pointer.\n");
            else if ( hr == E_OUTOFMEMORY )
                printf("Out of memory.\n");
            else if ( hr == E_INVALIDARG )
                printf("Invalid argument.\n");
            else
                printf("Unknown error.\n");
			goto Exit;
		}
	}

Exit:
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		~CAQAdminCli()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CAQAdminCli::~CAQAdminCli()
{
	if(NULL != m_pFilterCmd)
		delete (CCmdInfo*) m_pFilterCmd;
	if(NULL != m_pActionCmd)
		delete (CCmdInfo*) m_pActionCmd;
}

////////////////////////////////////////////////////////////////////////////
// Method:		Cleanup()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::Cleanup()
{
    if(m_pAdmin) 
		m_pAdmin->Release();
	if(m_pVS) 
		m_pVS->Release();
}

////////////////////////////////////////////////////////////////////////////
// Method:		CAQAdminCli()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CAQAdminCli::CAQAdminCli()
{
	m_pAdmin = NULL; 
	m_pVS = NULL;
	m_dwDispFlags = (DispFlags) (DF_LINK | DF_QUEUE | DF_MSG);
	m_pFilterCmd = NULL;
	m_pActionCmd = NULL;
	m_fUseMTA = FALSE;
}

////////////////////////////////////////////////////////////////////////////
// Method:		StopAllLinks()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::StopAllLinks()
{
	HRESULT hr;

	hr = m_pVS->StopAllLinks();
	if(FAILED(hr))
	{
		printf("m_pAdmin->StopAllLinks failed with 0x%x\n", hr);
	}
	else
		printf("StopAllLinks succeeded\n", hr);

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		StartAllLinks()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::StartAllLinks()
{
	HRESULT hr;

	hr = m_pVS->StartAllLinks();
	if(FAILED(hr))
	{
		printf("StartAllLinks failed with 0x%x\n", hr);
	}
	else
		printf("StartAllLinks succeeded\n", hr);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		GetGlobalLinkState()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetGlobalLinkState()
{
	HRESULT hr;

	hr = m_pVS->GetGlobalLinkState();
	if(FAILED(hr))
	{
		printf("GetGlobalLinkState failed with 0x%x\n", hr);
	}
	else if (S_OK == hr)
    {
		printf("Links UP\n");
    }
    else
    {
		printf("Links STOPPED by admin\n");
    }

	return hr;
}

HRESULT CAQAdminCli::MessageAction(MESSAGE_FILTER *pFilter, MESSAGE_ACTION action)
{
	HRESULT hr = S_OK;
    DWORD   cMsgs = 0;

	hr = ApplyActionToMessages(m_pVS, pFilter, action, &cMsgs);
	if(FAILED(hr))
	{
		printf("m_pAdmin->ApplyActionToMessages failed with 0x%x\n", hr);
	}
	else
		printf("ApplyActionToMessages succeeded on %d Messages\n", cMsgs);

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		Help()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::Help()
{
	puts(	"\n   Commands:\n"
			"====================\n"
			"setserver [sn] [,vs=VSnumber] - sets the server to administer. Default is localhost,\n"
			"                                first virtual server\n"
			"linkinfo [ln,ln,...]          - prints link information for specified links or\n"
			"                                for all links (no arguments)\n"
			"queueinfo [ln,ln,...]         - prints queue information for specified links or\n"
			"                                for all links (no arguments)\n"
			"msginfo [qn,qn,...,] eflt     - prints message information for specified queues or\n"
			"                                for all queues (no 'qn' arguments)\n"
			"delmsg [qn,qn,...,] flt       - deletes messages from specified queues or\n"
			"                                from all queues (no 'qn' arguments)\n"
			"msgaction mac, flt            - applies msg. action to specified messages\n"
			"linkaction ln [,ln,...], lac  - applies link action to specified links\n"
			"  [, mac, flt]                  if action is \"MSGACTION\", must specify mac and flt\n"
			"queueaction qn [,qn,...], qac - applies queue action to specified queues\n"
			"  [, mac, flt]                  if action is \"MSGACTION\", must specify mac and flt\n"
			"stopalllinks                  - stops all the links\n"
			"startalllinks                 - starts all the links\n"
			"checklinks                    - checks the global status of the links\n"
			"freezelink ln [,ln,...]       - freezes the specified links\n"
			"meltlink ln [,ln,...]         - un-freezes the specified links\n"
			"kicklink ln [,ln,...]         - kicks (forces a connect) for the specified links\n"
			"useMTA                        - uses the MTA AQ administrator\n"
			"useSMTP                       - uses the SMTP AQ administrator\n"
			"?, help                       - this help\n"
			"quit                          - exits the program\n"
			"!cmd                          - executes shell command 'cmd'\n"
			"\nwhere\n\n"
			"ln = link name\n"
			"qn = queue name\n"
			"sn = server name\n"
			"mac = \"ma=<action>\" message action. Actions are: \"DEL\"|\"DEL_S\"|\"FREEZE\"|\"THAW\"|\"COUNT\"\n"
			"lac = \"la=<action>\" link action. Actions: \"KICK\"|\"FREEZE\"|\"THAW\"|\"MSGACTION\"\n"
			"qac = \"qa=<action>\" queue action. Actions: \"MSGACTION\"\n"
			"eflt = \"token,token,...\" msg. enum. filter. Following tokens are suported:\n"
			"  \"ft=<flags>\" Flags are: \"FIRST_N\"|\"OLDER\"|\"OLDEST\"|\"LARGER\"|\"LARGEST\"|\"NOT\"|\"SENDER\"|\"RCPT\"|\"ALL\"\n"
			"       (filter type. Flags can be or'ed)\n"
			"  \"mn=<number>\" (number of messages)\n"
			"  \"ms=<number>\" (message size)\n"
			"  \"md=<date>\" (message date mm/dd/yy hh:mm:ss:mil [UTC])\n"
			"  \"sk=<number>\" (skip messages)\n"
			"  \"msndr=<string>\" (message sender)\n"
			"  \"mrcpt=<string>\" (message recipient)\n"
			"flt = \"token,token,...\" msg. filter. Following tokens are suported:\n"
			"  \"flags=<flags>\" Flags are: \"MSGID\"|\"SENDER\"|\"RCPT\"|\"SIZE\"|\"TIME\"|\"FROZEN\"|\"NOT\"|\"ALL\"\n"
			"       (filter flags. Flags can be or'ed)\n"
			"  \"id=<string>\" (message id as shown by msginfo)\n"
			"  \"sender=<string>\" (the sender of the message)\n"
			"  \"rcpt=<string>\" (the recipient of the message)\n"
			"  \"size=<number>\" (the minimum message size)\n"
			"  \"date=<date>\" (oldest message date mm/dd/yy hh:mm:ss:mil [UTC])\n"
		);
}

////////////////////////////////////////////////////////////////////////////
// Method:		Init()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::Init()
{
	HRESULT hr;

	hr = CoCreateInstance(CLSID_AQAdmin, 
                          NULL, 
                          CLSCTX_INPROC_SERVER,
                          IID_IAQAdmin, 
                          (void **) &m_pAdmin);
    if(FAILED(hr)) 
	{
        printf("CoCreateInstance failed with 0x%x\n", hr);
        goto Exit;
    }

	hr = m_pAdmin->GetVirtualServerAdminITF(NULL, L"1", &m_pVS);
	if(FAILED(hr)) 
	{
        printf("GetVirtualServerAdminITF failed with 0x%x\n", hr);
        goto Exit;
    }
Exit:
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		Init()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::UseMTA(BOOL fUseMTA)
{
	HRESULT hr;
	IAQAdmin *pAdminTmp = NULL;

	// don't release the old one unless you can create the new one.
	if(fUseMTA)
		hr = CoCreateInstance(CLSID_MAQAdmin, 
							  NULL, 
							  CLSCTX_INPROC_SERVER,
							  IID_IAQAdmin, 
							  (void **) &pAdminTmp);
	else
		hr = CoCreateInstance(CLSID_AQAdmin, 
							  NULL, 
							  CLSCTX_INPROC_SERVER,
							  IID_IAQAdmin, 
							  (void **) &pAdminTmp);
    
    if(FAILED(hr)) 
	{
        printf("CoCreateInstance failed with 0x%x\n", hr);
        goto Exit;
    }
	else
	{
		if(NULL != m_pAdmin)
		{
			m_pAdmin->Release();
			m_pAdmin = NULL;
		}

		m_pAdmin = pAdminTmp;
		m_fUseMTA = fUseMTA;

		printf("AQ Admin is %s.\n", fUseMTA ? "MTA" : "SMTP");
	}

	hr = m_pAdmin->GetVirtualServerAdminITF(NULL, L"1", &m_pVS);
	if(FAILED(hr)) 
	{
        printf("GetVirtualServerAdminITF failed with 0x%x\n", hr);
        goto Exit;
    }
Exit:
	return hr;
}

HRESULT ExecuteCmd(CAQAdminCli& Admcli, LPSTR szCmd)
{
	HRESULT hr = S_OK;
	BOOL fQuit = FALSE;

    // see if it's a system command
	if(szCmd[0] == '!')
	{
		system(szCmd + 1);
		goto Exit;
	}

	Admcli.m_pFilterCmd = new CCmdInfo(szCmd);
	if(NULL == Admcli.m_pFilterCmd)
	{
		printf("Cannot allocate command info.\n");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "quit"))
	{
		fQuit = TRUE;
		goto Exit;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "freezelink"))
	{
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			Admcli.m_pActionCmd = new CCmdInfo("FREEZE");
			Admcli.PrintLinkInfo();
			delete (CCmdInfo*) Admcli.m_pActionCmd;
			Admcli.m_pActionCmd = NULL;
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "meltlink"))
	{
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			Admcli.m_pActionCmd = new CCmdInfo("THAW");
			Admcli.PrintLinkInfo();
			delete (CCmdInfo*) Admcli.m_pActionCmd;
			Admcli.m_pActionCmd = NULL;
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "kicklink"))
	{
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			Admcli.m_pActionCmd = new CCmdInfo("KICK");
			Admcli.PrintLinkInfo();
			delete (CCmdInfo*) Admcli.m_pActionCmd;
			Admcli.m_pActionCmd = NULL;
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "linkaction"))
	{
		char buf[64];

		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			// check there's an action
			hr = Admcli.m_pFilterCmd->GetValue("la", buf);
			if(FAILED(hr))
			{
				printf("Error: must have a link action\n");
			}
			else
			{
				Admcli.m_pActionCmd = new CCmdInfo(buf);
				Admcli.PrintLinkInfo();
				delete (CCmdInfo*) Admcli.m_pActionCmd;
				Admcli.m_pActionCmd = NULL;
			}
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "queueaction"))
	{
		char buf[64];

		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("qn");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("qn", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one queue name\n");
		}
		else
		{
			// check there's an action
			hr = Admcli.m_pFilterCmd->GetValue("qa", buf);
			if(FAILED(hr))
			{
				printf("Error: must have a queue action\n");
			}
			else
			{
				Admcli.m_pActionCmd = new CCmdInfo(buf);
				Admcli.PrintQueueInfo();
				delete (CCmdInfo*) Admcli.m_pActionCmd;
				Admcli.m_pActionCmd = NULL;
			}
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "linkinfo"))
	{
		//Admcli.m_dwDispFlags = CAQAdminCli::DF_LINK;
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		Admcli.m_pActionCmd = new CCmdInfo("LINK_INFO");
		Admcli.PrintLinkInfo();
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "queueinfo"))
	{
		//Admcli.m_dwDispFlags = CAQAdminCli::DF_QUEUE;
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		Admcli.m_pActionCmd = new CCmdInfo("QUEUE_INFO");
		Admcli.PrintQueueInfo();
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "msginfo"))
	{
		//Admcli.m_dwDispFlags = CAQAdminCli::DF_MSG;
		//Admcli.GetLinkInfo();	
		// set default tag to 'qn'
		Admcli.m_pFilterCmd->SetDefTag("qn");
		Admcli.m_pActionCmd = new CCmdInfo("MSG_INFO");
		Admcli.PrintMsgInfo();			
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "delmsg"))
	{
		// set default tag to 'qn'
		Admcli.m_pFilterCmd->SetDefTag("qn");
		Admcli.m_pActionCmd = new CCmdInfo("DEL_MSG");
		Admcli.PrintMsgInfo();			
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "useMTA"))
	{
		Admcli.UseMTA(TRUE);
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "useSMTP"))
	{
		Admcli.UseMTA(FALSE);
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "msgaction"))
	{
		MESSAGE_ACTION Action;
		MESSAGE_FILTER Filter;
		char buf[64];
		BOOL fActOK = TRUE;
		ZeroMemory(buf, sizeof(buf));

		// set default tag to 'ma'
		Admcli.m_pFilterCmd->SetDefTag("ma");
		Admcli.m_pFilterCmd->GetValue("ma", buf);

		// set the action
		hr = Admcli.SetMsgAction(&Action, Admcli.m_pFilterCmd);
		if(FAILED(hr))
		{
			printf("Error: must specify an action\n");
			fActOK = FALSE;
		}

		if(fActOK)
		{
			// set the filter
			hr = Admcli.SetMsgFilter(&Filter, Admcli.m_pFilterCmd);
			if(SUCCEEDED(hr))
			{
				Admcli.MessageAction(&Filter, Action);
			}
			Admcli.FreeStruct(&Filter);
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "stopalllinks"))
	{
		Admcli.StopAllLinks();			
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "startalllinks"))
	{
		Admcli.StartAllLinks();			
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "setserver"))
	{
		char buf[MAX_SERVER_NAME];
		char vsn[32];
		char *pServer = NULL;
		Admcli.m_pFilterCmd->SetDefTag("sn");
		hr = Admcli.m_pFilterCmd->GetValue("sn", buf);
		if(FAILED(hr))
			pServer = NULL;			
		else
			pServer = (LPSTR)buf;

		hr = Admcli.m_pFilterCmd->GetValue("vs", vsn);
		if(FAILED(hr))
			lstrcpy(vsn, "1");			
		
		hr = Admcli.SetServer(pServer, (LPSTR)vsn);			
		if(FAILED(hr))
			printf("setserver failed. Using the old server.\n");
		else
			printf("setserver succeeded.\n");
	}
    else if (!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "checklinks"))
    {
        Admcli.GetGlobalLinkState();
    }
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "?") || 
			!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "help"))
	{
		Admcli.Help();			
	}
	else
	{
		puts("Unknown command. Type '?' for on-line help");
	}
	
	if(Admcli.m_pFilterCmd)
	{
		delete Admcli.m_pFilterCmd;
		Admcli.m_pFilterCmd = NULL;
	}

Exit:
	// S_FALSE means "quit" for the main command loop. Return S_OK 
	// (or error) unless fQuit is true
	if(fQuit)
		return S_FALSE;
	else if(S_FALSE == hr)
		return S_OK;
	else
		return hr;
}

int __cdecl main(int argc, char **argv) 
{
    HRESULT hr;
	char szCmd[4096];
	char szCmdTmp[MAX_CMD_LEN];
	
	CAQAdminCli Admcli;
	
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr)) 
	{
        printf("CoInitializeEx failed w/ 0x%x\n", hr);
        return hr;
    }

	hr = Admcli.Init();
    if(FAILED(hr)) 
	{
        goto Exit;
    }

	// check if we have cmd line commands
	if(argc > 1)
	{
		for(int i = 1; i < argc; i++)
		{
			if(!lstrcmpi(argv[i], "-?") || !lstrcmpi(argv[i], "/?"))
			{
				Admcli.Help();
				goto Exit;
			}
			else
			{
				// this is a command
				ZeroMemory(szCmd, sizeof(szCmd));
					
				if(argv[i][0] == '\"' && argv[i][lstrlen(argv[i])-1] == '\"')
				{
					// strip quotes
					CopyMemory(szCmd, argv[i]+1, lstrlen(argv[i])-2);
				}
				else
					CopyMemory(szCmd, argv[i], lstrlen(argv[i]));

				ExecuteCmd(Admcli, szCmd);
			}
		}

		goto Exit;
	}

	puts("\nAQ administrator tool v 1.0\nType '?' or 'help' for list of commands.\n");
	while(TRUE)
	{
		char *cmd = NULL;
		printf(">");
		
		ZeroMemory(szCmd, sizeof(szCmd));
		if(!Admcli.m_fUseMTA)
		{
			szCmd[0] = 127;
			cmd = _cgets(szCmd);
		}
		else
		{
			// read line by line until CRLF.CRLF
			do
			{
				ZeroMemory(szCmdTmp, sizeof(szCmdTmp));
				szCmdTmp[0] = 127;
				cmd = _cgets(szCmdTmp);
				if(!lstrcmp(cmd, "."))
					break;
				lstrcat(szCmd, cmd);
			}
			while(TRUE);
			
			cmd = szCmd;
		}
		
		hr = ExecuteCmd(Admcli, cmd);
		if(S_FALSE == hr)
			break;
	}
 
Exit:
	Admcli.Cleanup();
    CoUninitialize();

    return hr;
}

#include "aqadmin.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\stdinc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);

#define COMMETHOD HRESULT STDMETHODCALLTYPE 

class CComRefCount {
protected:
    LONG    m_cRefs;

public:
    CComRefCount() {
        m_cRefs = 1;
    }
    virtual ~CComRefCount() {}

    ULONG _stdcall AddRef() {
        _ASSERT(m_cRefs);
        return InterlockedIncrement(&m_cRefs);
    }
    ULONG _stdcall Release() {
        LONG r = InterlockedDecrement(&m_cRefs);
        _ASSERT(r >= 0);
        if (r == 0) delete this;
		return r;
    }
};

//---[ CComRefPtr ]------------------------------------------------------------
//
//
//  Description: 
//      Class that wraps a reference count around a data pointer.  Data must
//      have been allocated via MIDL_user_alloc.  Used to control the lifespan of 
//      allocated memory via AddRef() and Release()
//  Hungarian: 
//      refp, prefp
//  History:
//      2/2/99 - MikeSwa Created
//  
//-----------------------------------------------------------------------------
class CComRefPtr : public CComRefCount {
protected:
    PVOID   m_pvData;
public:
    CComRefPtr() {
        _ASSERT(0 && "Invalid Usage");
        m_pvData = NULL;
    };
    CComRefPtr(PVOID pvData)
    {
        m_pvData = pvData;
    };
    ~CComRefPtr()
    {
        if (m_pvData)
            MIDL_user_free(m_pvData);
    };
    PVOID pvGet() {return m_pvData;};
};

#include "aqadmtyp.h"
#include "resource.h"
#include "aqadmin.h"
#include <transmem.h>
						 
#ifdef PLATINUM
#include <aqmem.h>
#include "phatqmsg.h"
#include "exaqadm.h"
#else  //not PLATINUM
#include "aqerr.h"
#endif //PLATINUM

#include "aqrpcstb.h"
#include "aqadm.h"
#include "vsaqadm.h"
#include "enumlink.h"
#include "aqmsg.h"
#include "enummsgs.h"
#include "enumlnkq.h"
#include "vsaqlink.h"
#include "linkq.h"

extern QUEUELINK_ID g_qlidNull;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqadm.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: csaqadm.cpp
//
//  Description: Implementation of CVSAQAdmin which implements IVSAQAdmin
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CVSAQAdmin::CVSAQAdmin() {
    TraceFunctEnter("VSAQAdmin::CVSAQAdmin");
    
    m_dwSignature = CVSAQAdmin_SIG;
    m_wszComputer = NULL;
    m_wszVirtualServer = NULL;

    TraceFunctLeave();
}

CVSAQAdmin::~CVSAQAdmin() {
    TraceFunctEnter("CVSAQAdmin");
    
    if (m_wszComputer) {
        delete[] m_wszComputer;
        m_wszComputer = NULL;
    }

    if (m_wszVirtualServer) {
        delete[] m_wszVirtualServer;
        m_wszVirtualServer = NULL;
    }

    TraceFunctLeave();
}

//---[ CVSAQAdmin::Initialize ]------------------------------------------------
//
//
//  Description: 
//      Initialize the CVSAQAdmin interface. Copies ID strings
//  Parameters:
//      IN  wszComputer         The name of the computer this interface is for
//      IN  wszVirtualServer    The virtual server that this interface is for
//  Returns:
//      S_OK onsuccess
//      E_OUTOFMEMORY on memory failures
//      E_POINTER on NULL arguments
//  History:
//      6/4/99 - MikeSwa Changed to UNICODE 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::Initialize(LPCWSTR wszComputer, LPCWSTR wszVirtualServer) {
    TraceFunctEnter("CVSAQAdmin::Initialize");

    if (!wszVirtualServer) return E_POINTER;

    DWORD cComputer;
    DWORD cVirtualServer = wcslen(wszVirtualServer) + 1;

    if (wszComputer != NULL) {
        cComputer = wcslen(wszComputer) + 1;
        m_wszComputer = new WCHAR[cComputer];
        if (m_wszComputer == NULL) {
            TraceFunctLeave();
            return E_OUTOFMEMORY;
        }
        wcscpy(m_wszComputer, wszComputer);
    }

    m_wszVirtualServer = new WCHAR[cVirtualServer];
    if (m_wszVirtualServer == NULL) {
        TraceFunctLeave();
        return E_OUTOFMEMORY;
    }
    wcscpy(m_wszVirtualServer, wszVirtualServer);

    TraceFunctLeave();
	return S_OK;
}

//---[CVSAQAdmin::GetLinkEnum ]------------------------------------------------
//
//
//  Description: 
//      Gets a IEnumVSAQLinks for this virtual server
//  Parameters:
//      OUT ppEnum      IEnumVSAQLinks returned by search
//  Returns:
//      S_OK on success
//      E_POINTER when NULL pointer values are passed in.
//  History:
//      1/30/99 - MikeSwa Fixed AV on invalid args
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::GetLinkEnum(IEnumVSAQLinks **ppEnum) {
    TraceFunctEnter("CVSAQAdmin::GetLinkEnum");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    DWORD cLinks = 0;
    QUEUELINK_ID *rgLinks = NULL;
    CEnumVSAQLinks *pEnumLinks = NULL;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQGetLinkIDs(m_wszComputer, m_wszVirtualServer, &cLinks, &rgLinks);
    if (rc) {
        hr = HRESULT_FROM_WIN32(rc);
    } else {
        pEnumLinks = new CEnumVSAQLinks(this, cLinks, rgLinks);
        if (pEnumLinks == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    *ppEnum = pEnumLinks;

    if (FAILED(hr)) {
        if (rgLinks) MIDL_user_free(rgLinks);
        if (pEnumLinks) delete pEnumLinks;
        *ppEnum = NULL;
    } 
    
  Exit:
    TraceFunctLeave();
    return hr;
}

HRESULT CVSAQAdmin::StopAllLinks() {
    TraceFunctEnter("CVSAQAdmin::StopAllLinks");
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQApplyActionToLinks(m_wszComputer, m_wszVirtualServer, LA_FREEZE);
    if (rc) hr = HRESULT_FROM_WIN32(rc);
    
    TraceFunctLeave();
    return hr;
}

HRESULT CVSAQAdmin::StartAllLinks() 
{
    TraceFunctEnter("CVSAQAdmin::StartAllLinks");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQApplyActionToLinks(m_wszComputer, m_wszVirtualServer, LA_THAW);
    if (rc) hr = HRESULT_FROM_WIN32(rc);
    
    TraceFunctLeave();
    return hr;
}

HRESULT CVSAQAdmin::ApplyActionToMessages(MESSAGE_FILTER *pmfFilter,
									   	  MESSAGE_ACTION ma,
                                          DWORD *pcMsgs)
{
    TraceFunctEnter("CVSAQAdmin::ApplyActionToMessages");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    QUEUELINK_ID qlId;
    ZeroMemory(&qlId, sizeof(QUEUELINK_ID));
    qlId.qltType = QLT_NONE;

    if (!pmfFilter  || !pcMsgs)
    {
        hr = E_POINTER;
        if (pcMsgs)
            *pcMsgs = 0;
        goto Exit;
    }

    rc = ClientAQApplyActionToMessages(m_wszComputer, m_wszVirtualServer, 
                                    &qlId, pmfFilter, ma, pcMsgs);
    if (rc) hr = HRESULT_FROM_WIN32(rc);
        
  Exit:
    if (FAILED(hr))
    {
        if (pcMsgs)
            *pcMsgs = 0;
    }

    TraceFunctLeave();
	return hr;
}


//---[ CVSAQAdmin::GetGlobalLinkState ]----------------------------------------
//
//
//  Description: 
//      Used to get global state of links (re Stop|StartAllLinks)
//  Parameters:
//      -
//  Returns:
//      S_OK if links are started
//      S_FALSE if not
//  History:
//      1/13/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::GetGlobalLinkState()
{
    TraceFunctEnter("CVSAQAdmin::GetGlobalLinkState");
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQApplyActionToLinks(m_wszComputer, m_wszVirtualServer, LA_INTERNAL);
    if (rc && (S_FALSE != rc)) 
        hr = HRESULT_FROM_WIN32(rc);
    else if (S_FALSE == rc)
        hr = S_FALSE;
    
    TraceFunctLeave();
    return hr;
}

//---[ CVSAQAdmin::QuerySupportedActions ]-------------------------------------
//
//
//  Description: 
//      Function that describes which actions are supported on this interface
//  Parameters:
//      OUT     pdwSupportedActions     Supported message actions
//      OUT     pdwSupportedFilterFlags Supported filter flags
//  Returns:
//      S_OK on success
//      E_POINTER on bogus args
//  History:
//      6/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                          OUT DWORD *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CVSAQAdmin::QuerySupportedActions");
    HRESULT hr = S_OK;
    NET_API_STATUS rc;
    QUEUELINK_ID qlId;
    ZeroMemory(&qlId, sizeof(QUEUELINK_ID));
    qlId.qltType = QLT_NONE;

    if (!pdwSupportedActions || !pdwSupportedFilterFlags)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQQuerySupportedActions(m_wszComputer,
                                       m_wszVirtualServer,
                                       &qlId,
                                       pdwSupportedActions,
                                       pdwSupportedFilterFlags);
    if (rc) 
        hr = HRESULT_FROM_WIN32(rc);

  Exit:
    if (FAILED(hr))
    {
        if (pdwSupportedActions)
            *pdwSupportedActions = 0;

        if (pdwSupportedFilterFlags)
            *pdwSupportedFilterFlags = 0;

    }

    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\aqadmcli.h ===
#ifndef __AQADMCLI__
#define __AQADMCLI__

const unsigned MAX_CMD_LEN = 127; // reading command with _cgets
const unsigned MAX_SERVER_NAME = 64;

class CAQAdminCli
{
public:
	enum DispFlags 
	{
		DF_NONE  = 0x00000000,
		DF_LINK  = 0x00000001,
		DF_QUEUE = 0x00000002,
		DF_MSG   = 0x00000004
	};

private:
	IAQAdmin *m_pAdmin;
	IVSAQAdmin *m_pVS;
	
public:
	DispFlags m_dwDispFlags;
	CCmdInfo *m_pFilterCmd;
	CCmdInfo *m_pActionCmd;

   	BOOL m_fUseMTA;

public:
	CAQAdminCli();
	~CAQAdminCli();
	void Help();
	
	HRESULT GetQueue(IN IEnumLinkQueues *pQueueEnum, OUT ILinkQueue **ppQueue, IN OUT QUEUE_INFO *pQueueInf);
	HRESULT PrintQueueInfo();

	HRESULT GetLink(IN IEnumVSAQLinks *pLinkEnum, OUT IVSAQLink **ppLink, IN OUT LINK_INFO *pLinkInf);
	HRESULT PrintLinkInfo();

	HRESULT GetMsg(IN IAQEnumMessages *pMsgEnum, OUT IAQMessage **ppMsg, IN OUT MESSAGE_INFO *pMsgInf);
	HRESULT PrintMsgInfo();

	BOOL IsContinue(LPSTR pszTag, LPWSTR pszVal);
	inline void PInfo(int nCrt, LINK_INFO linkInf);
	inline void PInfo(int nCrt, QUEUE_INFO queueInf);
	inline void PInfo(int nCrt, MESSAGE_INFO msgInf);
	HRESULT SetMsgEnumFilter(MESSAGE_ENUM_FILTER *pFilter, CCmdInfo *pCmd);
	HRESULT SetMsgFilter(MESSAGE_FILTER *pFilter, CCmdInfo *pCmd);
	HRESULT SetServer(LPSTR pszServerName, LPSTR pszVSNumber);
	HRESULT SetMsgAction(MESSAGE_ACTION *pAction, CCmdInfo *pCmd);
	HRESULT ExecuteCmd(CAQAdminCli& Admcli, LPSTR szCmd);
	HRESULT UseMTA(BOOL fUseMTA);


	HRESULT Init();
	HRESULT StopAllLinks();
	HRESULT StartAllLinks();
    HRESULT GetGlobalLinkState();
	HRESULT MessageAction(MESSAGE_FILTER *pFilter, MESSAGE_ACTION action);
	void Cleanup();

	void FreeStruct(MESSAGE_FILTER *pStruct);
	void FreeStruct(LINK_INFO *pStruct);
	void FreeStruct(QUEUE_INFO *pStruct);
	void FreeStruct(MESSAGE_INFO *pStruct);

	BOOL LocalTimeToUTC(SYSTEMTIME *stLocTime, SYSTEMTIME *stUTCTime);
	BOOL StringToUTCTime(LPSTR szTime, SYSTEMTIME *pstUTCTime);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqlink.h ===
//-----------------------------------------------------------------------------
//
//
//  File: vsaqlink.h
//
//  Description: Header for CVSAQLink which implements IVSAQLink.  This is the
//      top level interface for a single link on a virtual server.  Provides 
//      functionality to:
//          - Get information about a link
//          - Set the state of a link
//          - Get an enumerator for a final destination queues associated
//              with this link.
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __VSAQLINK_H__
#define __VSAQLINK_H__

class CLinkInfoContext;

class CVSAQLink :
	public CComRefCount,
	public IVSAQLink,
    public IAQMessageAction,
    public IUniqueId
{
	public:
		CVSAQLink(CVSAQAdmin *pVS, QUEUELINK_ID *pqlidLink);
		virtual ~CVSAQLink();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IVSAQLink *>(this);
			} else if (iid == IID_IVSAQLink) {
				*ppv = static_cast<IVSAQLink *>(this);
			} else if (iid == IID_IAQMessageAction) {
				*ppv = static_cast<IAQMessageAction *>(this);
			} else if (iid == IID_IUniqueId) {
				*ppv = static_cast<IUniqueId *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IVSAQLink
		COMMETHOD GetInfo(LINK_INFO *pLinkInfo);
		COMMETHOD SetLinkState(LINK_ACTION la);
		COMMETHOD GetQueueEnum(IEnumLinkQueues **ppEnum);

        //IAQMessageAction
		COMMETHOD ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs);
        COMMETHOD QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                        OUT DWORD *pdwSupportedFilterFlags);

        // IUniqueId
        COMMETHOD GetUniqueId(QUEUELINK_ID **ppqlid);

    private:
        CVSAQAdmin          *m_pVS;          // pointer to virtual server
        QUEUELINK_ID         m_qlidLink;     // the array of links
        CLinkInfoContext    *m_prefp;
};

//---[ CLinkInfoContext ]------------------------------------------------------
//
//
//  Description: 
//      Context to handle memory requirement of link info
//  
//-----------------------------------------------------------------------------
class CLinkInfoContext : public CComRefCount
{
  protected:
        LINK_INFO          m_LinkInfo;          
  public:
    CLinkInfoContext(PLINK_INFO pLinkInfo)
    {
        if (pLinkInfo)
            memcpy(&m_LinkInfo, pLinkInfo, sizeof(LINK_INFO));
        else
            ZeroMemory(&m_LinkInfo, sizeof(LINK_INFO));
    };

    ~CLinkInfoContext()
    {
        if (m_LinkInfo.szLinkName)
            MIDL_user_free(m_LinkInfo.szLinkName);

        if (m_LinkInfo.szLinkDN)
            MIDL_user_free(m_LinkInfo.szLinkDN);

        if (m_LinkInfo.szExtendedStateInfo)
            MIDL_user_free(m_LinkInfo.szExtendedStateInfo);
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\util.cpp ===
// Sink.cpp : Implementation of CRoutingSinkApp and DLL registration.

#include "stdinc.h"

////////////////////////////////////////////////////////////////////////////
// Method:		CCmdInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CCmdInfo::CCmdInfo(LPSTR szCmd)
{
	nArgNo = 0; 
	pArgs = NULL;
	ZeroMemory(szDefTag, sizeof(szDefTag));
	ZeroMemory(szCmdKey, sizeof(szCmdKey));
	ParseLine(szCmd, this);
}

////////////////////////////////////////////////////////////////////////////
// Method:		~CCmdInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CCmdInfo::~CCmdInfo()
{
	while(NULL != pArgs) 
	{
		CArgList *tmp = pArgs->pNext;
		delete pArgs;
		pArgs = tmp;
	}
}


void CCmdInfo::SetDefTag(LPSTR szTag)
{
	if(szTag && szTag[0])
		lstrcpy(szDefTag, szTag);

	for(CArgList *p = pArgs; NULL != p; p = p->pNext)
	{
		// set the tag to the default value if not already set
		if(p->szTag[0] == 0 && szDefTag[0] != 0)
			lstrcpy(p->szTag, szDefTag);
	}
}

////////////////////////////////////////////////////////////////////////////
// Method:		GetValue()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::GetValue(LPSTR szTag, LPSTR szVal)
{
	HRESULT hr = E_FAIL;

	if(NULL != szTag)
	{
		// set the search parameters
		pSearchPos = pArgs;
		lstrcpy(szSearchTag, szTag);
	}

	for(CArgList *p = pSearchPos; NULL != p; p = p->pNext)
	{
		if(!lstrcmpi(p->szTag, szSearchTag))
		{
			if(NULL != szVal)
				lstrcpy(szVal, p->szVal);
			hr = S_OK;
			pSearchPos = p->pNext;
			break;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		GetValue()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::AllocValue(LPSTR szTag, LPSTR* pszVal)
{
	HRESULT hr = E_FAIL;

	if(NULL != szTag)
	{
		// set the search parameters
		pSearchPos = pArgs;
		lstrcpy(szSearchTag, szTag);
	}

	for(CArgList *p = pSearchPos; NULL != p; p = p->pNext)
	{
		if(!lstrcmpi(p->szTag, szSearchTag))
		{
			if(NULL != (*pszVal))
				delete [] (*pszVal);

			(*pszVal) = new char[lstrlen(p->szVal) + 1];
			if(NULL == (*pszVal))
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				lstrcpy((*pszVal), p->szVal);
				hr = S_OK;
				pSearchPos = p->pNext;
			}
			break;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		ParseLine()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::ParseLine(LPSTR szCmd, CCmdInfo *pCmd)
{
	HRESULT hr = E_FAIL;

	// quick hack for keeping info on quoted strings
	unsigned nQStart[64];
	unsigned nQEnd[64];
	unsigned nQIdx = 0;
	BOOL fInQ = FALSE;
	unsigned nFirstEqualPos = 0;
	char *s, *token;

	ZeroMemory(&nQStart, sizeof(nQStart));
	ZeroMemory(&nQEnd, sizeof(nQEnd));

	// find out where the arguments begin
	for(s = szCmd; !isspace(*s); s++);
	
	int nPref = (int) (s - szCmd);
	// scan the buffer for quoted strings
	for(s = szCmd; *s; s++)
	{
		if(*s == '"')
		{
			if(fInQ)
			{
				nQEnd[nQIdx++] = (unsigned) (s - szCmd - nPref);
				fInQ = FALSE;
			}
			else
			{
				nQStart[nQIdx] = (unsigned) (s - szCmd - nPref);
				fInQ = TRUE;
			}
		}
	}

	// get the position of the first equal sign
	s = strchr(szCmd, '=');
	nFirstEqualPos = (unsigned) (s - szCmd - nPref);
	
	// get the command code
	token = strtok(szCmd, " ");
	if(NULL == token)
	{	
		pCmd->szCmdKey[0] = 0;
		goto Exit;
	}
	else
		lstrcpy(pCmd->szCmdKey, token);

	// we have a partial command. return S_OK
	hr = S_OK;

	// build the argument list
	do
	{
		char *en, *mid;
		char buf[1024];
		ZeroMemory(buf, sizeof(buf));
		char *token = NULL;
		BOOL fInQ;

		do
		{
			fInQ = FALSE;
			token = strtok(NULL, ",");
	
			if(NULL == token)
				break;

			lstrcat(buf, token);

			// if ',' is in a quoted string concatenate to buf and continue
			for(unsigned i = 0; i < nQIdx; i++)
			{
				unsigned nAux = (unsigned) (token - szCmd + lstrlen(token) - nPref);
				if(nAux > nQStart[i] &&  nAux < nQEnd[i])
				{
					lstrcat(buf, ",");
					fInQ = TRUE; 
					break;
				}
			}
		}
		while(fInQ);

		
		if(buf[0] == '\0')
			break;
		else
			token = (LPSTR)buf;

		// strip spaces
		for(; isspace(*token); token++);
		
		// check if there's anything left
		if(!(*token))
			continue;

		for(en = token; *en; en++);
		for(--en; isspace(*en); en--);
		// check if there's anything left
		if(token > en)
			continue;

		// allocate a pair object
		CCmdInfo::CArgList *tmp = new CCmdInfo::CArgList;
		if(NULL == tmp)
		{
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		// insert into list
		tmp->pNext = pCmd->pArgs;
		pCmd->pArgs = tmp;

		// set the no. of pairs
		pCmd->nArgNo++;
				
		// set the values
		// if first '=' is in quoted string, treat whole expression as
		// untagged value.
		fInQ = FALSE;
		for(unsigned i = 0; i < nQIdx; i++)
		{
			if(nFirstEqualPos > nQStart[i] &&  nFirstEqualPos < nQEnd[i])
			{
				fInQ = TRUE;
				break;
			}
		}

		mid = fInQ ? NULL : strchr(token, '=');
		
		if(NULL == mid)
		{
			// this is not a pair. Treating as un-named value.
			// remove the quotes around the value
			if(token[0] == '"' && token[en - token] == '"')
			{
				token++;
				en--;
			}
			tmp->SetVal(token, (unsigned) (en - token + 1));
		}
		else
		{
			// set the tag
			for(char *t = mid - 1; isspace(*t); t--);
			// check if we have a tag (might be something like "..., = value"
			if(t - token + 1 > 0)
				CopyMemory(tmp->szTag, token, t - token + 1);

			// set the value
			for(t = mid + 1; isspace(*t) && t < en; t++);
			
			// remove the quotes around the value
			if(t[0] == '"' && t[en - t] == '"')
			{
				t++;
				en--;
			}
			tmp->SetVal(t, (unsigned) (en - t + 1));
		}

	}while(TRUE);
	

Exit:
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		StringToHRES()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::StringToHRES(LPSTR szVal, HRESULT *phrRes)
{
	HRESULT hr = S_OK;

	if(isdigit(*szVal))
	{
		DWORD hr;
		int n;

		if(*szVal == '0' && tolower(*(szVal+1)) == 'x' && isxdigit(*(szVal+2)))
			// read as hex number
			n = sscanf(szVal+2, "%lx", &hr);
		else
			// read as dec number
			n = sscanf(szVal, "%lu", &hr);

		if(n == 1)
			(*phrRes) = (HRESULT)hr;
	}
	else if(isalpha(*szVal))
	{
		// see if this a HRESULT code
		if(!lstrcmp(szVal, "S_OK"))					(*phrRes) = S_OK;
		else if(!lstrcmp(szVal, "S_FALSE"))			(*phrRes) = S_FALSE;
		else if(!lstrcmp(szVal, "E_FAIL"))			(*phrRes) = E_FAIL;
		else if(!lstrcmp(szVal, "E_OUTOFMEMORY"))	(*phrRes) = E_OUTOFMEMORY;
		else
			hr = S_FALSE;
	}
	else
		hr = S_FALSE;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\stdinc.h ===
//-----------------------------------------------------------------------------
//
//
//  File: stdinc.h
//
//  Description: Precompiled header file
//
//  Author: Mike Swafford (MikeSwa)
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <ole2.h>
#include "aqadmin.h"
#include "aqadmtyp.h"
#include <conio.h>
#include <stdlib.h>
#include "util.h"
#include "aqadmcli.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\makefile.inc ===
$(O)\aqadmin.h $(O)\aqadmin.c : $(STAXINC)\export\aqadmin.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(O)\aqadmin.c \
    -dlldata $(O)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqadmin.c \
    -header $@ \
    -tlb $(O)\aqadmin.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\util.h ===
#ifndef __CMD_INFO__
#define __CMD_INFO__

// defines the argument list for a command
class CCmdInfo 
{
public:
	// defines a "TAG = value" pair
	struct CArgList
	{
		char szTag[64];
		char *szVal;
		CArgList *pNext;

		CArgList() 
		{
			pNext = NULL; 
			szVal = NULL;
			//ZeroMemory(szVal, sizeof(szVal));
			ZeroMemory(szTag, sizeof(szTag));
		};

		LPSTR SetVal(LPSTR pszSrc, unsigned nSize)
		{
			if(NULL != szVal)
				delete [] szVal;

			szVal = new char[nSize + 1];
			if(NULL != szVal)
			{
				CopyMemory(szVal, pszSrc, nSize);
				szVal[nSize] = 0;
			}

			return szVal;
		}

		~CArgList()
		{
			if(NULL != szVal)
				delete [] szVal;
		}
	};

	int nArgNo;
	CArgList *pArgs;
	char szCmdKey[64];
	char szDefTag[64];
	
	CArgList *pSearchPos;
	char szSearchTag[64];
	
	CCmdInfo(LPSTR szCmd);
	~CCmdInfo();
public:
	void SetDefTag(LPSTR szTag);
	HRESULT GetValue(LPSTR szTag, LPSTR szVal);
	HRESULT AllocValue(LPSTR szTag, LPSTR* szVal);
private:
	HRESULT ParseLine(LPSTR szCmd, CCmdInfo *pCmd);
	HRESULT StringToHRES(LPSTR szVal, HRESULT *phrRes);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\aqdbgext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgext.cpp
//
//  Description: Advanced Queuing Debug Extensions.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_
#include "aqincs.h"
#include "aqdbgext.h"
#ifdef PLATINUM
#include <ptrwinst.h>
#else
#include <rwinst.h>
#endif //PLATINUM
#include <aqinst.h>
#include <domhash.h>
#include <destmsgq.h>
#include <linkmsgq.h>
#include <hashentr.h>
#include <rwinst.h>
#include <fifoqdbg.h>

extern DWORD g_cbClasses;
extern DWORD g_dwFlavorSignature;

BOOL    g_fVersionChecked = FALSE;

#define AQ_MIN(x, y) ((x) > (y) ? (y) : (x))
HANDLE g_hTransHeap;  //Needed for to link because of transmem.h

const DWORD MAX_DOM_PATH_SIZE = 512;

const CHAR    _LINK_STATE_UP[]       = "UP        ";
const CHAR    _LINK_STATE_DOWN[]     = "DOWN      ";
const CHAR    _LINK_STATE_ACTIVE[]   = "ACTIVE    ";
const CHAR    _LINK_STATE_TURN[]     = "TURN      ";
const CHAR    _LINK_STATE_RETRY[]    = "RETRY     ";
const CHAR    _LINK_STATE_DSN[]      = "DSN       ";
const CHAR    _LINK_STATE_SPECIAL[]  = "SPECIAL   ";

#define LINK_STATE_UP       (LPSTR) _LINK_STATE_UP
#define LINK_STATE_DOWN     (LPSTR) _LINK_STATE_DOWN
#define LINK_STATE_ACTIVE   (LPSTR) _LINK_STATE_ACTIVE
#define LINK_STATE_TURN     (LPSTR) _LINK_STATE_TURN
#define LINK_STATE_RETRY    (LPSTR) _LINK_STATE_RETRY
#define LINK_STATE_DSN      (LPSTR) _LINK_STATE_DSN
#define LINK_STATE_SPECIAL  (LPSTR) _LINK_STATE_SPECIAL

//lower case function names
AQ_DEBUG_EXTENSION_IMP(dumpservers) {DumpServers(DebugArgs);}
AQ_DEBUG_EXTENSION_IMP(offsets) {Offsets(DebugArgs);}
AQ_DEBUG_EXTENSION_IMP(dumpdnt) {DumpDNT(DebugArgs);}

AQ_DEBUG_EXTENSION_IMP(Offsets)
{
    dprintf("CDestMsgQueue m_liDomainEntryDMQs - 0x%X\n", FIELD_OFFSET(CDestMsgQueue, m_liDomainEntryDMQs));
    dprintf("CDestMsgQueue m_liEmptyDMQs - 0x%X\n", FIELD_OFFSET(CDestMsgQueue, m_liEmptyDMQs));
    dprintf("CLinkMsgQueue m_liLinks - 0x%X\n", FIELD_OFFSET(CLinkMsgQueue, m_liLinks));
    dprintf("CLinkMsgQueue m_liConnections - 0x%X\n", FIELD_OFFSET(CLinkMsgQueue, m_liConnections));
    dprintf("CAQSvrInst m_liVirtualServers - 0x%X\n", FIELD_OFFSET(CAQSvrInst, m_liVirtualServers));
    dprintf("CRETRY_HASH_ENTRY m_QLEntry - 0x%X\n", FIELD_OFFSET(CRETRY_HASH_ENTRY, m_QLEntry));
    dprintf("CRETRY_HASH_ENTRY m_HLEntry - 0x%X\n", FIELD_OFFSET(CRETRY_HASH_ENTRY, m_HLEntry));
    dprintf("CShareLockInst m_liLocks - 0x%X\n", FIELD_OFFSET(CShareLockInst, m_liLocks));
}



AQ_DEBUG_EXTENSION_IMP(dumpoffsets)
{
    _dumpoffsets(hCurrentProcess, hCurrentThread,
                 dwCurrentPc, pExtensionApis, szArg);
}

//---[ cpoolusage ]------------------------------------------------------------
//
//
//  Description:
//      Dumps the CPool usage for our known CPools.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/31/2000 - Mikeswa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(cpoolusage)
{
    CHAR    rgKnownCPools[][200] = {
//                "pttrace!g_pFreePool",
                "exstrace!g_pFreePool",
//                "phatcat!CPoolBuffer__sm_PoolNHeapBuffersPool",
                "aqueue!CQuickList__s_QuickListPool",
                "aqueue!CSMTPConn__s_SMTPConnPool",
                "aqueue!CMsgRef__s_MsgRefPool",
                "aqueue!CAQMsgGuidListEntry__s_MsgGuidListEntryPool",
                "aqueue!CAsyncWorkQueueItem__s_CAsyncWorkQueueItemPool",
                "aqueue!CRETRY_HASH_ENTRY__PoolForHashEntries",
//                "drviis!CIMsgWrapper__m_CIMsgWrapperPool",
//                "drviis!CQueueItem__m_CQueueItemPool",
                "mailmsg!CBlockMemoryAccess__m_Pool",
                "mailmsg!CMsg__m_Pool",
                "mailmsg!CMailMsgRecipientsAdd__m_Pool",
                "smtpsvc!SMTP_CONNECTION__Pool",
                "smtpsvc!SMTP_CONNOUT__Pool",
                "smtpsvc!CAddr__Pool",
                "smtpsvc!CAsyncMx__Pool",
                "smtpsvc!CAsyncSmtpDns__Pool",
                "smtpsvc!CBuffer__Pool",
                "smtpsvc!CIoBuffer__Pool",
                "smtpsvc!CBlockMemoryAccess__m_Pool",
                "smtpsvc!CDropDir__m_Pool",
                ""
            };

    DWORD    rgdwPool[5];
    DWORD    cTotalBytes = 0;
    DWORD    cCurrentBytes = 0;
    DWORD    cInstanceBytes = 0;
    DWORD    cInstances = 0;
    DWORD    dwSignature = 0;
    CHAR    *pch = NULL;
    DWORD    i = 0;
    PVOID    pvPool = NULL;

    //
    //  Loop over all known pools and display data
    //
    dprintf("Total Bytes\t# Instances \tInstance Size \tSignature\tName\n");
   dprintf("=================================================================\n");
    while (rgKnownCPools[i] && rgKnownCPools[i][0]) {
        pvPool = (PVOID) GetExpression(rgKnownCPools[i]);

        if (!pvPool ||
            !ReadMemory(pvPool, rgdwPool, sizeof(rgdwPool), NULL)) {
            dprintf("Unable to read pool %s at %p\n", rgKnownCPools[i], pvPool);
        } else {
            cInstances = rgdwPool[3];
            cInstanceBytes = rgdwPool[2];
            dwSignature = rgdwPool[0];
            pch = (CHAR *) &dwSignature;
            dprintf("%d\t\t%d\t\t%d\t\t0x%08X\t%s\n",
                cInstanceBytes*cInstances, cInstances,
                cInstanceBytes, rgdwPool[0], rgKnownCPools[i]);
            cTotalBytes += cInstanceBytes*cInstances;
        }
        i++;
   }
   dprintf("=================================================================\n");
   dprintf("\tTotal Bytes = %d\n\n", cTotalBytes);

}

//---[ remotecmd ]------------------------------------------------------------
//
//
//  Description:
//      start a remote cmd window
//  Parameters:
//      name of the pipe
//  Returns:
//      -
//  History:
//      5/31/2000 - AWetmore Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(remotecmd)
{
    char szParameters[1024];
    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    if (!szArg || ('\0' == szArg[0]))
        goto Usage;

    _snprintf(szParameters, 1024, "remote /s cmd %s", szArg);
    dprintf("\nRunning %s\n", szParameters);

    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    if (!CreateProcess(NULL,
                       szParameters,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NEW_CONSOLE,
                       NULL,
                       NULL,
                       &si,
                       &pi))
    {
        dprintf("CreateProcess failed with %u\n", GetLastError());
    } else {
        dprintf("Started process %i\n", pi.dwProcessId);
    }


  Exit:
    dprintf("\n");
    return;

  Usage:
    //
    //  Display usage message
    //
    dprintf("\nUsage:\n");
    dprintf("\tremotecmd <pipename>\n");
    goto Exit;
}


//---[ findbytes ]-------------------------------------------------------------
//
//
//  Description:
//      Searches for a given byte-pattern in a memory address sapce
//  Parameters:
//      Pattern of bytes to search for.  Expected format is a sequence of
//      space separated hex digits.
//  Returns:
//      -
//  History:
//      5/9/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(findbytes)
{
#ifdef WIN64
    const DWORD_PTR cbVMSize = 0xFFFFFFFFFFFFFFFF;
#else //not WIN64
    const DWORD_PTR cbVMSize = 0xFFFFFFFF;
#endif //WIN64
    BYTE        rgbBytesToFind[200];
    LONG        lCurrentValue = 0;
    CHAR        rgchCurrentValue[3] = "00";
    LPSTR       szStop = NULL;
    DWORD_PTR   cBytesToFind = 0;
    DWORD_PTR   cChunksChecked = 0;
    DWORD_PTR   cChunkSize = 0;
    DWORD_PTR   iChunk = 0;
    BYTE        pbChunk[0x1000];
    PBYTE       pbStopAddr = pbChunk + sizeof(pbChunk);
    PBYTE       pbCurrent = NULL;
    DWORD_PTR   cChunks = cbVMSize/sizeof(pbChunk);
    DWORD_PTR   cChunksInPercent = 1;
    DWORD_PTR   pvEffectiveAddressOtherProc = NULL;
    DWORD       cComplaints = 0;
    DWORD       cMemchkMatches = 0;
    DWORD       cFullSigMatches = 0;
    LPCSTR      szCurrentArg = szArg;


    if (!szArg || ('\0' == szArg[0]))
        goto Usage;

    //
    //  Parse command line args
    //
    while (*szCurrentArg)
    {
        //
        //  Loop over whitespace
        //
        while (*szCurrentArg && isspace(*szCurrentArg)) szCurrentArg++;

        //
        //  Make sure we have at least pair of characters as expected
        //
        if (!*(szCurrentArg+1))
            break;

        //
        //  Convert from hex characters to binary
        //
        lCurrentValue = strtol(szCurrentArg, &szStop, 16);
        if ((lCurrentValue > 0xFF) || (lCurrentValue < 0))
            goto Usage;

        //
        //  Copy to our search buffer
        //
        rgbBytesToFind[cBytesToFind] = (BYTE) lCurrentValue;
        cBytesToFind++;

        //
        //  Make sure our search buffer is big enough for the next byte
        //
        if (cBytesToFind >= sizeof(rgbBytesToFind))
        {
            dprintf("Search for max pattern of %d bytes\n", cBytesToFind);
            break;
        }

        szCurrentArg += 2;  //Skip to next known whitespace
    }

    if (!cBytesToFind)
    {
        dprintf("\nYou must specify at least one byte to search for\n");
        goto Usage;
    }

    //
    //  Used to display progress
    //
    cChunksInPercent = cChunks/100;

    //
    //  Calculate memory size for 32-bit machines
    //
    cChunkSize = cbVMSize/cChunks;

    if (cChunkSize < 1024)
    {
        dprintf("ERROR: Chunk size of 0x%p is too small", cChunkSize);
        goto Exit;
    }

    //
    //  Make sure we are cool wrt to buffer size
    //
    if (cChunkSize > sizeof(pbChunk))
    {
        dprintf("ERROR: Chunksize of 0x%p is larger than max size of 0x%p",
                cChunkSize, sizeof(pbChunk));
        goto Exit;
    }

    //
    //  Loop over chunks --
    //      $$REVIEW -  does not find patterns that span 1K chunks...
    //      this is probably OK, since this is an unlikely scenario.  Most
    //      byte patterns will be DWORD (signatures) or pointer sized.
    //
    for (iChunk = 0; iChunk < cChunks; iChunk++)
    {
        //
        //  Give some status
        //
        if ((iChunk % cChunksInPercent) == 0)
            dprintf(".");

        //
        //  Address should be page aligned
        //
        if (((iChunk*cChunkSize) & 0xFFF) && (cComplaints < 100))
        {
            cComplaints++;
            dprintf("0x%p not alligned at index %d", (iChunk*cChunkSize), iChunk);
        }

        //
        //  Do a memory search for the first byte
        //
        if (!ReadMemory((DWORD)iChunk*cChunkSize, pbChunk, (DWORD)cChunkSize, NULL))
            continue; //on to the next buffer chunk

        //
        //  Now that we have a chunk... look for our sig
        //
        pbCurrent = pbChunk;
        while (pbCurrent < pbStopAddr-cBytesToFind)
        {
            pbCurrent = (PBYTE) memchr(pbCurrent,
                                       rgbBytesToFind[0],
                                       pbStopAddr-pbCurrent);

            //
            //  See if we have a match
            if (!pbCurrent)
                break;

            cMemchkMatches++;

            pvEffectiveAddressOtherProc = iChunk*cChunkSize+(pbCurrent-pbChunk);

            //
            //  See if the full pattern matches
            //
            if (!memcmp(rgbBytesToFind, pbCurrent, cBytesToFind))
            {
                cFullSigMatches++;
                dprintf("\nFound match at 0x%p\n", pvEffectiveAddressOtherProc);
            }

            if (0 != memcmp(rgbBytesToFind, pbCurrent, 1))
            {
                cComplaints++;
                if (cComplaints < 100)
                    dprintf("Messed up %02X %02X - %02X %02X\n",
                        rgbBytesToFind[0], rgbBytesToFind[1],
                        pbCurrent[0], pbCurrent[1]);
            }


            pbCurrent++;

        }

        cChunksChecked++;
    }

    //
    //  Give some summary information
    //
    dprintf("\nChecked 0x%p chunks (%d%%) searching from 0x%p to 0x%p",
            cChunksChecked,
            (DWORD)(100*cChunksChecked/cChunks), NULL,
            cChunkSize*(cChunks+1)-1);
    dprintf("\nFound %d partial matches and %d full matches",
            cMemchkMatches, cFullSigMatches);

  Exit:
    dprintf("\n");
    return;

  Usage:
    //
    //  Display usage message
    //
    if (szCurrentArg && *szCurrentArg)
        dprintf("Error at %s\n", szCurrentArg);

    dprintf("\nUsage:\n");
    dprintf("\tfindbytes <aa> [<bb> ...]\n");
    dprintf("\t\tBytes should be specifed as 2 hexadecimal characters\n");
    dprintf("\nExamples:\n");
    dprintf("\tTo search for the signature \"LMQ \"\n");
    dprintf("\t\tfindbytes %02X %02X %02X %02X\n", 'L', 'M', 'Q', ' ');
    goto Exit;

}


//---[ findsig ]---------------------------------------------------------------
//
//
//  Description:
//      Searches for a given class signature in a memory address sapce
//  Parameters:
//      The Siganature to look for.
//  Returns:
//      -
//  History:
//      5/3/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(findsig)
{
    CHAR    szNewArg[200];
    LPCSTR  szCurrentArg = szArg;
    CHAR    szSig[5] = "    ";
    DWORD   iChar = 0;

    if (!szArg || ('\0' == szArg[0]))
        goto Usage;


    //
    //  Loop over whitespace
    //
    while (*szCurrentArg && isspace(*szCurrentArg)) szCurrentArg++;

    //
    //  Grab the first 4 characters and convert them to binary
    //
    for( iChar = 0; iChar < 4; iChar++)
    {
        if (!szCurrentArg[iChar])
            break;

        szSig[iChar] = szCurrentArg[iChar];
    }

    dprintf("Searching for Signature \"%s\"...\n", szSig);

    sprintf(szNewArg, "%02X %02X %02X %02X", szSig[0], szSig[1], szSig[2], szSig[3]);

    //
    //  Just use the code in findbytes to do the actual search
    //
    dprintf("Calling findbytes %s\n", szNewArg);
    findbytes(hCurrentProcess, hCurrentThread, dwCurrentPc,
                     pExtensionApis, szNewArg);

  Exit:
    return;

  Usage:
    dprintf("\nUsage:\n");
    dprintf("\tfindsig <XXXX>\n");
    goto Exit;

}

//---[ hashthread ]------------------------------------------------------------
//
//
//  Description:
//      Uses the CThreadIdBlock hashing mechanism to return the hashed value
//      for a thread.
//  Parameters:
//      Thread Id to hash
//      Max hash value
//  Returns:
//      -
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(hashthread)
{
    //Arguement should be thread Id
    DWORD dwThreadId = GetCurrentThreadId();
    DWORD dwMax = 1000;
    DWORD dwThreadHash = 0;
    CHAR  szArgBuffer[200];
    LPSTR szCurrentArg = NULL;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("Warning... using default thead id and max\n");
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwThreadId = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                dwMax = (DWORD) GetExpression(szCurrentArg);
            else
                dprintf("Warning... using default max hash\n");
        }
    }

    //Try hashing the ID
    dwThreadHash = dwHashThreadId(dwThreadId, dwMax);
    dprintf("Thread Id 0x%0X hashes to index 0x%0X (%d) with max 0x%08X (%d)\n", dwThreadId,
             dwThreadHash, dwThreadHash, dwMax, dwMax);
}

//---[ dumplock ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps all of the information in the CThreadIdBlocks for a given
//      CShareLockInst.
//  Parameters:
//      Address of CShareLockInst
//  Returns:
//      -
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dumplock)
{
    BYTE    pbBuffer[sizeof(CShareLockInst)];
    BYTE    pbThreadBlocks[1000*sizeof(CThreadIdBlock)];
    PVOID   pvLock = NULL;
    PVOID   pvNextBlock = NULL;
    CThreadIdBlock  tblkCurrent;
    CThreadIdBlock  *ptblkCurrent = NULL;
    CThreadIdBlock  *ptblkArray = NULL;
    DWORD   cNumBlocks = 0;
    DWORD   iBlock = 0;
    DWORD   cThreads = 0;
    DWORD   cLockCount = 0;
    DWORD   cLockedThreads = 0;
    BOOL    fDisplayedHashHeader = FALSE;

    ZeroMemory(pbBuffer, sizeof(pbBuffer));
    ZeroMemory(pbThreadBlocks, sizeof(pbThreadBlocks));

    if (!szArg || ('\0' == szArg[0]) || !(pvLock = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a lock address\n");
        return;
    }

    //read the whole lock into our buffer
    if (!ReadMemory(pvLock, &pbBuffer, sizeof(pbBuffer), NULL))
    {
        dprintf("Error unable read memory at 0x%0X\n", pvLock);
        return;
    }

    cNumBlocks = ((CShareLockInst *)pbBuffer)->m_cMaxTrackedSharedThreadIDs;
    pvNextBlock = ((CShareLockInst *)pbBuffer)->m_rgtblkSharedThreadIDs;

    if (!cNumBlocks || !pvNextBlock)
    {
        dprintf("Thread tracking is not enabled for this lock");
        return;
    }

    if (cNumBlocks > sizeof(pbThreadBlocks)/sizeof(CThreadIdBlock))
        cNumBlocks = sizeof(pbThreadBlocks)/sizeof(CThreadIdBlock);

    if (!ReadMemory(pvNextBlock, &pbThreadBlocks,
                    cNumBlocks*sizeof(CThreadIdBlock), NULL))
    {
        dprintf("Error, unable to read %d blocks at 0x%0X", cNumBlocks, pvNextBlock);
        return;
    }

    ptblkArray = (CThreadIdBlock *) pbThreadBlocks;
    for (iBlock = 0; iBlock < cNumBlocks; iBlock++ && ptblkArray++)
    {
        ptblkCurrent = ptblkArray;
        fDisplayedHashHeader = FALSE;
        while (ptblkCurrent)
        {
            if (ptblkCurrent != ptblkArray)
            {
                //Read into this process
                if (!ReadMemory(ptblkCurrent, &tblkCurrent,
                    sizeof(CThreadIdBlock), NULL))
                {
                    dprintf("Error reading block at 0x%0X", ptblkCurrent);
                    break;
                }
                ptblkCurrent = &tblkCurrent;
            }

            if (THREAD_ID_BLOCK_SIG != ptblkCurrent->m_dwSignature)
            {
                dprintf("Warning... bad signature on block 0x%0X\n",
                    ((BYTE *)pvNextBlock) + iBlock*sizeof(CThreadIdBlock));
                break;
            }

            //See if this block has any data
            if (THREAD_ID_BLOCK_UNUSED != ptblkCurrent->m_dwThreadId)
            {

                //Only dump info if the recursion count is non-zero
                if (ptblkCurrent->m_cThreadRecursionCount)
                {
                    if (!fDisplayedHashHeader)
                    {
                        fDisplayedHashHeader = TRUE;
                        dprintf("Thread Hash 0x%0X (%d)\n", iBlock, iBlock);
                    }
                    dprintf("%s\tThread 0x%08X has count of %d - Next link of 0x%08X\n",
                        (ptblkCurrent == ptblkArray) ? "+" : "",
                        ptblkCurrent->m_dwThreadId,
                        ptblkCurrent->m_cThreadRecursionCount,
                        ptblkCurrent->m_ptblkNext);

                    cLockedThreads++;
                }

                cThreads++;
                cLockCount += ptblkCurrent->m_cThreadRecursionCount;
            }
            ptblkCurrent = ptblkCurrent->m_ptblkNext;
        }
    }

    dprintf("===================================================================\n");
    dprintf("%d threads with %d total lock count (%d threads holding locks)\n",
            cThreads, cLockCount, cLockedThreads);
}

//---[ workqueue ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps a summary of items in the async work queue
//  Parameters:
//
//  Returns:
//
//  History:
//      9/13/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(workqueue)
{
    SETCALLBACKS();
    const DWORD MAX_COMPLETION_FUNCTIONS = 10;
    PVOID   rgpvFnName[MAX_COMPLETION_FUNCTIONS];
    DWORD   rgcFnCount[MAX_COMPLETION_FUNCTIONS];
    BYTE    pbWorkItem[sizeof(CAsyncWorkQueueItem)];
    PVOID   pvQueue = NULL;
    PVOID   pvWorkItem = NULL;
    PVOID   pvFn = NULL;
    DWORD   i = 0;
    DWORD   cItems = 0;
    char    SymbolName[ 200 ];
    ULONG_PTR Displacement;
    CFifoQueueDbgIterator fifoqdbg(pExtensionApis);

    ZeroMemory(&rgpvFnName, sizeof(rgpvFnName));
    ZeroMemory(&rgcFnCount, sizeof(rgcFnCount));
    ZeroMemory(&pbWorkItem, sizeof(pbWorkItem));
    ZeroMemory(&SymbolName, sizeof(SymbolName));

    if (!szArg || ('\0' == szArg[0]) ||
        !(pvQueue = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a queue address\n");
        return;
    }


    //Get FifoqOffset
    pvQueue = (PVOID) &(((CAsyncWorkQueue *)pvQueue)->m_asyncq.m_fqQueue);

    if (!fifoqdbg.fInit(hCurrentProcess, pvQueue))
    {
        dprintf("Error initializing queue iterator for address 0x%08X\n", pvQueue);
        return;
    }

    while (pvWorkItem = fifoqdbg.pvGetNext())
    {
        cItems++;
        if (!ReadMemory(pvWorkItem, &pbWorkItem, sizeof(pbWorkItem), NULL))
        {
            dprintf("Error reading memory at  0x%0X\n", pvWorkItem);
            continue;
        }

        pvFn = ((CAsyncWorkQueueItem *)pbWorkItem)->m_pfnCompletion;

        for (i = 0; i < MAX_COMPLETION_FUNCTIONS; i++)
        {
            if (pvFn == rgpvFnName[i])
            {
                rgcFnCount[i]++;
                break;
            }
            else if (!rgpvFnName[i])
            {
                rgpvFnName[i] = pvFn;
                rgcFnCount[i] = 1;
                break;
            }
        }
    }

    dprintf("# Calls\t| Address\t\t| Function Name\n");
    dprintf("------------------------------------------------------------\n");
    for (i = 0; i < MAX_COMPLETION_FUNCTIONS; i++)
    {
        if (!rgpvFnName[i])
            break;

        g_lpGetSymbolRoutine( rgpvFnName[i], (PCHAR)SymbolName, &Displacement );
        dprintf( "%d\t| 0x%08X\t| %s\n", rgcFnCount[i], rgpvFnName[i], SymbolName);
    }
    dprintf("------------------------------------------------------------\n");
    dprintf("Total %d pending work queue items\n", cItems);

#ifdef NEVER
    //Dump fifoqdbg
    dprintf("CFifoQueueDbgIterator: page %d, index %d, pages %d\n ",
        fifoqdbg.m_iCurrentPage, fifoqdbg.m_iCurrentIndexInPage,
        fifoqdbg.m_cPagesLoaded);
#endif
}

//---[ dumpqueue ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps the *entire* contents of a queue
//  Parameters:
//      szArg
//          - String-ized address of CFifoQ to dump
//          - [optional] msg to search for
//  Returns:
//      -
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION(dumpqueue)
{
    const   DWORD   cStoppingRule = 10000;
    CQueueDbgIterator qdbg(pExtensionApis);
    BYTE    pbMsgRef[sizeof(CMsgRef)];
    PVOID   pvMsgRef = NULL;
    PVOID   pvMailMsg = NULL;
    PVOID   pvQueue = NULL;
    DWORD   cItems = 0;
    BOOL    fIsMsgRef = FALSE;
    CHAR    szArgBuffer[200];
    LPSTR   szCurrentArg = NULL;
    PVOID   pvSearch = NULL;
    DWORD   cMatchSearch = 0;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("You must specify a queue address\n");
        return;
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            pvQueue = (PVOID)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pvSearch = (PVOID) GetExpression(szCurrentArg);
        }
        else
        {
            pvQueue = (PVOID) GetExpression(szArg);
        }

    }

    if (!pvQueue)
    {
        dprintf("You must specify a queue address\n");
        return;
    }

    if (!qdbg.fInit(hCurrentProcess, pvQueue))
    {
        dprintf("Unable to get the a queue for address 0x%X\n", pvQueue);
        return;
    }

    while ((pvMsgRef = qdbg.pvGetNext()) && (cItems++ < cStoppingRule))
    {
        fIsMsgRef = FALSE;
        if (cItems > qdbg.cGetCount())
        {
            cItems--;
            break;
        }


        //Try to read it as a CMsgRef
        if (ReadMemory(pvMsgRef, pbMsgRef, sizeof(pbMsgRef), NULL))
        {
            if (MSGREF_SIG == ((CMsgRef *)pbMsgRef)->m_dwSignature)
            {
                fIsMsgRef = TRUE;
                pvMailMsg = ((CMsgRef *)pbMsgRef)->m_pIMailMsgProperties;
            }
        }

        //Print it out if it matches our search (or we have no search)
        if (!pvSearch || (pvSearch == pvMsgRef) || (pvSearch == pvMailMsg))
        {
            cMatchSearch++;
            if (pvSearch)
                dprintf("\n****\n");

            if (fIsMsgRef)
                dprintf("\t0x%08X\t0x%08X\n", pvMsgRef, pvMailMsg);
            else
                dprintf("\t0x%08X\n", pvMsgRef);

            if (pvSearch)
                dprintf("****\n\n");
        }

    }

    if (pvSearch)
       dprintf("Found %d matches to search\n", cMatchSearch);
}

//---[ displaytickcount ]------------------------------------------------------
//
//
//  Description:
//      Converts a tick count to a readable time
//  Parameters:
//      szArg - String-ized tick count in hex
//  Returns:
//      -
//  History:
//      10/29/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(displaytickcount)
{
    DWORD   dwTickCountToDisplay = (DWORD)GetExpression(szArg);
    DWORD   dwCurrentTickCount = GetTickCount();
    DWORD   dwTickDifference = dwCurrentTickCount - dwTickCountToDisplay;
    FILETIME    ftCurrentUTC;
    FILETIME    ftDisplayUTC;
    FILETIME    ftDisplayLocal;
    ULARGE_INTEGER uliTimeAdjust;
    SYSTEMTIME  stDisplayLocal;

    static char  *s_rgszMonth[ 12 ] =
    {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    };

    static char *s_rgszWeekDays[7] =
    {
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
    };

    GetSystemTimeAsFileTime(&ftCurrentUTC);

    //Adjust the current filetime to local
    memcpy(&uliTimeAdjust, &ftCurrentUTC, sizeof(FILETIME));
    uliTimeAdjust.QuadPart -= (((ULONGLONG)dwTickDifference)*((ULONGLONG)10000));
    memcpy(&ftDisplayUTC, &uliTimeAdjust, sizeof(FILETIME));

    FileTimeToLocalFileTime(&ftDisplayUTC, &ftDisplayLocal);

    ZeroMemory(&stDisplayLocal, sizeof(stDisplayLocal));
    FileTimeToSystemTime(&ftDisplayLocal, &stDisplayLocal);

    dprintf("\n%s, %d %s %04d %02d:%02d:%02d (localized)\n",
            s_rgszWeekDays[stDisplayLocal.wDayOfWeek],
            stDisplayLocal.wDay, s_rgszMonth[ stDisplayLocal.wMonth - 1 ],
            stDisplayLocal.wYear, stDisplayLocal.wHour,
            stDisplayLocal.wMinute, stDisplayLocal.wSecond);

}

//---[ queueusage ]------------------------------------------------------------
//
//
//  Description:
//      Dumps the usage count averages for a given fifoq.  If we are dumping
//      CMsgRefs, it will dump the pointers to the various MailMsg interfaces
//      as well.
//  Parameters:
//      szArg   String-ized address of CFifoQ to dump
//  Returns:
//      -
//  History:
//      10/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(queueusage)
{
    const   DWORD   cbUsageCountOffset = 0x20;
    const   DWORD   cbContentHandleOffset = 0x90+cbUsageCountOffset;
    const   DWORD   cbStreamHandleOffset = 0x8+cbContentHandleOffset;
    const   DWORD   cStoppingRule = 10000;
    const   DWORD   cMaxUsageCountToTrack = 6;
    CFifoQueueDbgIterator fifoqdbg(pExtensionApis);
    BYTE    pbMsgRef[4*sizeof(CMsgRef)]; //leave room for bitmaps
    BYTE    pbMailMsg[cbStreamHandleOffset+sizeof(PVOID)];
    PVOID   pvMsgRef = NULL;
    PVOID   pvMailMsg = NULL;
    PVOID   pvQueue = NULL;
    DWORD   cItems = 0;
    DWORD   cCurrentUsageCount = 0;
    DWORD   cTotalUsageCount = 0;
    DWORD   cMaxUsageCount = 0;
    DWORD   cMinUsageCount = 200;
    DWORD   rgcUsageCounts[cMaxUsageCountToTrack];
    PVOID   pvHandle = NULL;
    DWORD   cMsgsWithOpenContentHandles = 0;
    DWORD   cMsgsWithOpenStreamHandles = 0;
    BOOL    fVerbose = FALSE;

    ZeroMemory(rgcUsageCounts, sizeof(rgcUsageCounts));

    if (!szArg || ('\0' == szArg[0]) ||
        !(pvQueue = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a queue address\n");
        return;
    }

    if (!fifoqdbg.fInit(hCurrentProcess, pvQueue))
    {
        dprintf("Unable to get the a queue for address 0x%X\n", pvQueue);
        return;
    }

    while ((pvMsgRef = fifoqdbg.pvGetNext()) && (cItems++ < cStoppingRule))
    {
        if (cItems > fifoqdbg.cGetCount())
        {
            cItems--;
            break;
        }

        //Read CMsgRef into this process
        if (!ReadMemory(pvMsgRef, pbMsgRef, sizeof(pbMsgRef), NULL))
        {
            dprintf("Unable to read MsgRef at address 0x%X, index %d\n",
                    pvMsgRef, cItems);
            cItems--;
            break;
        }

        //Get inteface ptr for mailmsg from CMsgRef
        pvMailMsg = ((CMsgRef *)pbMsgRef)->m_pIMailMsgQM;

        if (!ReadMemory(pvMailMsg, pbMailMsg, sizeof(pbMailMsg), NULL))
        {
            dprintf("Unable to read MailMsg Ptr at address 0x%X for MsgRef 0x%X, index %d\n",
                    pvMailMsg, pvMsgRef, cItems);
            cItems--;
            break;
        }

        //Check and see if this message has a content (P2) handle open
        if (*(pbMailMsg + cbContentHandleOffset))
            cMsgsWithOpenContentHandles++;

        //Check and see if this message has a stream (P1) handle open
        if (*(pbMailMsg + cbStreamHandleOffset))
            cMsgsWithOpenStreamHandles++;

        if (fVerbose &&
            ((*(pbMailMsg + cbStreamHandleOffset)) ||
             (*(pbMailMsg + cbStreamHandleOffset))))
        {
            dprintf("Message at address 0x%X has open handles\n", pvMsgRef);
        }

        cCurrentUsageCount = (DWORD) *(pbMailMsg + cbUsageCountOffset);
        cTotalUsageCount += cCurrentUsageCount;

        if (cCurrentUsageCount > cMaxUsageCount)
            cMaxUsageCount = cCurrentUsageCount;

        if (cCurrentUsageCount < cMinUsageCount)
            cMinUsageCount = cCurrentUsageCount;

        if (cCurrentUsageCount >= cMaxUsageCountToTrack)
        {
            dprintf("\n****\n");
            dprintf("High usage count of %d found on MailMsg 0x%X, MsgRef 0x%X, item %d\n",
                    cCurrentUsageCount, pvMailMsg, pvMsgRef, cItems);
            dprintf("\n****\n");
            cCurrentUsageCount = cMaxUsageCountToTrack-1;
        }

        //Save count for summaries
        rgcUsageCounts[cCurrentUsageCount]++;
    }

    //Generate and display summary information
    if (!cItems)
    {
        dprintf("No Messages found in queue 0x%X\n", pvQueue);
    }
    else
    {
        dprintf("\n==================================================================\n");
        dprintf("Usage Count Summary\n");
        dprintf("------------------------------------------------------------------\n");
        dprintf("\t%d\t\tTotal Message\n", cItems);
        dprintf("\t%d\t\tTotal Messages with open content handles\n", cMsgsWithOpenContentHandles);
        dprintf("\t%d\t\tTotal Messages with open stream handles\n", cMsgsWithOpenStreamHandles);
        dprintf("\t%d\t\tTotal Usage Count\n", cTotalUsageCount);
        dprintf("\t%d\t\tMax Usage Count\n", cMaxUsageCount);
        dprintf("\t%d\t\tMin Usage Count\n", cMinUsageCount);
        dprintf("\t%f\tAverage Usage Count\n", ((float)cTotalUsageCount)/((float)cItems));
        for (DWORD i = 0; i < cMaxUsageCountToTrack-1; i++)
        {
            dprintf("\t%d\t\tMessages with Usage count of %d\n", rgcUsageCounts[i], i);
        }
        dprintf("\t%d\t\tMessages with Usage count of %d or greater\n",
            rgcUsageCounts[cMaxUsageCountToTrack-1], cMaxUsageCountToTrack-1);
        dprintf("==================================================================\n");
    }
}

//---[ dmqusage ]--------------------------------------------------------------
//
//
//  Description:
//      Debugger extension that wraps the queue usage debugger extension
//      to display the usage counts for all queues
//  Parameters:
//      szArg   String-ized address of DMQ to dump
//  Returns:
//      -
//  History:
//      10/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dmqusage)
{
    PVOID   pvQueue = NULL;
    PVOID   pvDMQ = NULL;
    BYTE    pbDMQ[sizeof(CDestMsgQueue)];
    CHAR    szQueueAddress[30];
    DWORD   iQueue = 0;

    if (!szArg || ('\0' == szArg[0]) ||
        !(pvDMQ = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a queue address\n");
        return;
    }

    if (!ReadMemory(pvDMQ, pbDMQ, sizeof(pbDMQ), NULL))
    {
        dprintf("Unable to read DMQ at address 0x%X\n", pvDMQ);
        return;
    }

    dprintf("\n\n******************************************************************\n");
    dprintf("Start USAGE COUNT STATS for DMQ 0x%0X\n", pvDMQ);
    dprintf("******************************************************************\n");

    for (iQueue = 0; iQueue < NUM_PRIORITIES; iQueue++)
    {
        pvQueue = ((CDestMsgQueue *)pbDMQ)->m_rgpfqQueues[iQueue];
        if (!pvQueue)
            continue;  //nothing as every been queued to this queue

        //Only display the queue if we think we have messages
        //$$TODO - We could actual read this queue into memory and check it,
        //but since we currently only support 1 priority, this will do.
        if (((CDestMsgQueue *)pbDMQ)->m_aqstats.m_cMsgs)
        {
            wsprintf(szQueueAddress, "0x%X", pvQueue);
            queueusage(hCurrentProcess, hCurrentThread, dwCurrentPc,
                        pExtensionApis, szQueueAddress);
        }
    }

    //Display retry queue, if there are messages there
    if (((CDestMsgQueue *)pbDMQ)->m_fqRetryQueue.m_cQueueEntries)
    {
        pvQueue = ((PBYTE)pvDMQ) + FIELD_OFFSET(CDestMsgQueue, m_fqRetryQueue);
        wsprintf(szQueueAddress, "0x%X", pvQueue);
        queueusage(hCurrentProcess, hCurrentThread, dwCurrentPc,
                    pExtensionApis, szQueueAddress);
    }

    dprintf("\n\n******************************************************************\n");
    dprintf("End USAGE COUNT STATS for DMQ 0x%0X\n", pvDMQ);
    dprintf("******************************************************************\n");
}

//---[ dntusage ]--------------------------------------------------------------
//
//
//  Description:
//      Debugger extension that wrap dmqusage.  Call dmqusage for every DMQ
//      in the DNT.
//  Parameters:
//      szArg   string-ize address of dnt (DOMAIN_NAME_TABLE)
//  Returns:
//      -
//  History:
//      10/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dntusage)
{
    BYTE  pbBuffer[sizeof(DOMAIN_NAME_TABLE)];
    PDOMAIN_NAME_TABLE pdnt = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntryRealAddress = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pPathEntry = NULL;
    BYTE  pbEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)];
    CHAR  pBuffer[MAX_DOM_PATH_SIZE] = "Root Entry";
    LPSTR pEntryBuffer = NULL;
    LPSTR pEntryBufferStop = NULL;
    DWORD dwLength = 0;
    DWORD dwSig = 0;
    CHAR  szFinalDest[MAX_DOM_PATH_SIZE];
    BYTE  pbDomainEntry[sizeof(CDomainEntry)];
    CDomainEntry  *pdentry = (CDomainEntry *) pbDomainEntry;
    CHAR  szDMQAddress[30];
    DWORD cQueuesPerEntry = 0;
    DWORD cMaxQueuesPerEntry = 1000;
    PLIST_ENTRY pliHead = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    LIST_ENTRY liCurrent;


    //Define buffers for parsing addresses... the sizes are clearly overkill, and
    //I'm not too worried about overflow in a debugger extension
    CHAR                        szAddress[MAX_DOM_PATH_SIZE];
    CHAR                        szDumpArg[MAX_DOM_PATH_SIZE] = "";
    LPSTR                       szParsedArg = (LPSTR) szArg;
    LPSTR                       szCurrentDest = NULL;

    //Allow people who are used to typeing dump CFoo@Address... keep using the @ sign
    if ('@' == *szParsedArg)
        szParsedArg++;

    //Get Address of DomainNameTable
    szCurrentDest = szAddress;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szParsedArg-szArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';


    //Eat white space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Copy name of struct to dump at each node
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '@';
    szCurrentDest++;  //szCurrentDest now points to place to copy address to

    pdnt = (PDOMAIN_NAME_TABLE) GetExpression(szAddress);

    if (!pdnt)
    {
        dprintf("ERROR: Unable to Get DOMAIN_NAME_TABLE from argument %s\n", szArg);
        return;
    }

    if (!ReadMemory(pdnt, pbBuffer, sizeof(DOMAIN_NAME_TABLE), NULL))
    {
        dprintf("ERROR: Unable to read process memory\n");
        return;
    }

    pdnt = (PDOMAIN_NAME_TABLE)pbBuffer;
    pEntry = &(pdnt->RootEntry);

    while(pEntry)
    {
        //We are not interested in wildcard data
        if (pEntry->pData)
        {
            //Display link state information
            if (!ReadMemory(pEntry->pData, pbDomainEntry, sizeof(CDomainEntry), NULL))
            {
                dprintf("ERROR: Unable to read domain entry from @0x%08X\n", pEntry->pData);
                return;
            }

            pliHead = (PLIST_ENTRY) (((BYTE *)pEntry->pData) + FIELD_OFFSET(CDomainEntry, m_liDestQueues));
            pliCurrent = pdentry->m_liDestQueues.Flink;

            //Get final destination string
            if (!ReadMemory(pdentry->m_szDomainName, szFinalDest, pdentry->m_cbDomainName, NULL))
            {
                dprintf("ERROR: Unable to read final destination name from @0x%08X\n",
                        pdentry->m_szDomainName);
                return;
            }

            szFinalDest[pdentry->m_cbDomainName] = '\0';

            //Loop and display each DMQ
            cQueuesPerEntry = 0;
            while (pliHead != pliCurrent)
            {
                cQueuesPerEntry++;

                if (cQueuesPerEntry > cMaxQueuesPerEntry)
                {
                    dprintf("ERROR: More than %d queues for this entry\n", cQueuesPerEntry);
                    return;
                }
                if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read link LIST_ENTRY @0x%08X\n", pliCurrent);
                    return;
                }

                wsprintf(szDMQAddress, "0x%X",
                  CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs));
                dmqusage(hCurrentProcess, hCurrentThread, dwCurrentPc,
                        pExtensionApis, szDMQAddress);

                pliCurrent = liCurrent.Flink;
            }
        }


        //Now determine what the "next" entry is
        if (pEntry->pFirstChildEntry != NULL)
        {
            pEntryRealAddress = pEntry->pFirstChildEntry;
        }
        else if (pEntry->pSiblingEntry != NULL)
        {
            pEntryRealAddress = pEntry->pSiblingEntry;
        }
        else
        {
            for (pEntryRealAddress = pEntry->pParentEntry;
                    pEntryRealAddress != NULL;
                        pEntryRealAddress = pEntry->pParentEntry)
            {
                //must read parent entry into our buffer
                if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory of parent domain entry 0x%08X\n", pEntryRealAddress);
                    pEntry = NULL;
                    break;
                }
                pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;

                if (pEntry->pSiblingEntry != NULL)
                    break;

            }
            if (pEntry != NULL)
            {
                pEntryRealAddress = pEntry->pSiblingEntry;
            }
        }

        if (pEntryRealAddress)
        {
            if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
            {
                dprintf("ERROR: Unable to read process memory on domain entry 0x%08X\n",
                    pEntryRealAddress);
                pEntry = NULL;
                break;
            }
            pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;
        }
        else
        {
            pEntry = NULL;
        }
    }
}

//---[ walkcpool ]-------------------------------------------------------------
//
//
//  Description:
//      Will walk a given CPool object.  Validate headers, and dump currently
//      used objects.
//
//      ***NOTE*** This version only works on DBG CPool implementations (since
//      RTL does not have the headerinfo).  I could write a more complex
//      version that checks and sees if this each pool object is in the
//      freelist, but I will leave that as an exercise to the reader.
//  Parameters:
//      szArg   - String containing arguments
//          Address of CPool object to dump
//          Offset of additional address to dump
//  Returns:
//      -
//  History:
//      9/30/1999 - MikeSwa Created
//
#define HEAD_SIGNATURE  (DWORD)'daeH'
#define TAIL_SIGNATURE  (DWORD)'liaT'

#define FREE_STATE      (DWORD)'eerF'
#define USED_STATE      (DWORD)'desU'
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(walkcpool)
{
    PVOID   pvCPool = NULL;
    DWORD   cbCPoolData = 0;
    DWORD   cCommited = 0;
    DWORD   cFragments = 0;
    DWORD   cBuffersPerFragment = 0;
    DWORD   iCurrentBufferInFragment = 0;
    DWORD   iCurrentFragment = 0;
    PVOID  *pvFragment = NULL;
    PVOID   pvCPoolData = NULL;
    BYTE    pbCPoolBuffer[sizeof(CPool)];
    BYTE    pbCPoolDataBuffer[100];
    LPSTR   szCurrentArg = NULL;
    CHAR    szArgBuffer[200];
    DWORD_PTR cbOffset = 0;
    DWORD_PTR dwptrData = 0;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("You must specify a Pool address\n");
        return;
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            pvCPool = (PVOID)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                cbOffset = (DWORD_PTR) GetExpression(szCurrentArg);
        }
        else
        {
            pvCPool = (PVOID) GetExpression(szArg);
        }

    }

    if (!ReadMemory(pvCPool, pbCPoolBuffer, sizeof(CPool), NULL))
    {
        dprintf("Unable to read memory at 0x%x\n", pvCPool);
        return;
    }

    dprintf("Dumping CPool at address 0x%08X\n", pvCPool);

    //Get interesting values from CPool
    cbCPoolData = *((PDWORD)(pbCPoolBuffer + 0x8));
    cCommited = *((PDWORD)(pbCPoolBuffer + 0xc));
    cFragments =  *((PDWORD)(pbCPoolBuffer + 0x54));
    cBuffersPerFragment = *((PDWORD)(pbCPoolBuffer + 0x50));

    dprintf("CPool data size is %d bytes (0x%x)\n", cbCPoolData, cbCPoolData);
    dprintf("CPool fragment count is %d\n", cFragments);
    dprintf("CPool has %d buffers per fragment\n", cBuffersPerFragment);
    dprintf("CPool has %d commited buffers\n", cCommited);

    if (!cbCPoolData)
    {
        dprintf("Invalid CPool\n");
        return;
    }

    //Loop over the fragment and dump each one
    pvFragment = (PVOID *) (pbCPoolBuffer + 0x58);
    for (iCurrentFragment = 0;
         iCurrentFragment < cFragments;
         iCurrentFragment++ || pvFragment++)
    {
        pvCPoolData = *pvFragment;

        if (!pvCPoolData)
            continue;

        dprintf("CPool Fragment #%d at 0x%08X\n", iCurrentFragment, pvCPoolData);

        for (iCurrentBufferInFragment = 0;
             iCurrentBufferInFragment < cBuffersPerFragment;
             iCurrentBufferInFragment++)
        {
            if (!ReadMemory(pvCPoolData, pbCPoolDataBuffer, 100, NULL))
            {
                dprintf("\tUnable to read CPool buffer data at 0x%x\n", pvCPoolData);
                break;
            }

            if (HEAD_SIGNATURE != ((DWORD *)pbCPoolDataBuffer)[1])
            {
                dprintf("\tHit bad signature at 0x%08X\n", pvCPoolData);
                break; //bad signature bail
            }

            if (USED_STATE == ((DWORD *)pbCPoolDataBuffer)[2])
            {
                dprintf("\tAllocated block found at offset %d (0x%08X)\n",
                        iCurrentBufferInFragment, pvCPoolData);
                if (cbOffset)
                {
                    if (ReadMemory(((PBYTE)pvCPoolData)+cbOffset, &dwptrData,
                                sizeof(DWORD_PTR), NULL))
                    {
                        dprintf("\t\tData 0x%X found at address 0x%X\n",
                            dwptrData, ((PBYTE)pvCPoolData)+cbOffset);
                    }
                }
            }
            pvCPoolData = ((BYTE *)pvCPoolData) + cbCPoolData;

            if (!(--cCommited))
            {
                dprintf("\tLast block is in fragment at offset %d (0x%08X)\n",
                    iCurrentBufferInFragment, pvCPoolData);
                break; //We're done
            }
        }
    }

}

//---[ CheckVersion ]----------------------------------------------------------
//
//
//  Description:
//      Checks the AQ version to make sure that this debugger extension will
//      work with it.
//  Parameters:
//
//  Returns:
//
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(CheckVersion)
{
    DWORD   cbAQClasses = 0;
    DWORD   dwAQFlavorSignature = '    ';
    PVOID   pcbAQClasses = (PVOID) GetExpression("aqueue!g_cbClasses");
    PVOID   pdwAQFlavorSignature = (PVOID) GetExpression("aqueue!g_dwFlavorSignature");
    PCHAR   pch = NULL;

    //Read the version information stamped in AQ
    ReadMemory(pcbAQClasses, &cbAQClasses, sizeof(DWORD), NULL);
    ReadMemory(pdwAQFlavorSignature, &dwAQFlavorSignature, sizeof(DWORD), NULL);

    if (!g_fVersionChecked)
    {
        dprintf("AQueue Internal Version Info (#'s should match):\n");
        pch = (PCHAR) &g_dwFlavorSignature;
        dprintf("\taqdbgext %c%c%c%c 0x%08X\n",  *(pch), *(pch+1), *(pch+2), *(pch+3), g_cbClasses);
        pch = (PCHAR) &dwAQFlavorSignature;
        dprintf("\taqueue    %c%c%c%c 0x%08X\n\n",  *(pch), *(pch+1), *(pch+2), *(pch+3), cbAQClasses);
    }

    g_fVersionChecked = FALSE;
    if (dwAQFlavorSignature != g_dwFlavorSignature)
        dprintf("\n\nWARNING: DBG/RTL aqueue.dll & aqdbgext.dll mismatch\n\n");
    else if (g_cbClasses != cbAQClasses)
        dprintf("\n\nWARNING: aqueue.dll & aqdbgext.dll version mismatch\n\n");
    else
        g_fVersionChecked = TRUE;

}

//---[ DumpServers ]------------------------------------------------------------
//
//
//  Description:
//      Dumps pointers to the CAQSvrInst for each virtual server
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(DumpServers)
{
    PVOID pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    DWORD *pcInstances = (DWORD *) GetExpression("aqueue!g_cInstances");
    DWORD cInstances = 0;
    LIST_ENTRY liCurrent;
    BYTE  pbBuffer[sizeof(CAQSvrInst)];
    CAQSvrInst *paqinst = (CAQSvrInst *) pbBuffer;
    PVOID pCMQAddress = NULL;
    DWORD dwInstance = 0;
    CHAR  szDumpArg[40] = "";
    CHAR  szArgBuffer[200];
    LPSTR szCurrentArg = NULL;

    CheckVersion(DebugArgs);
    if (!szArg || ('\0' == szArg[0]))
    {
        dwInstance = 0;
        pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwInstance = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pvListHead = (PVOID) GetExpression(szCurrentArg);
            else
                pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
        }
    }

    if (!pvListHead)
    {
        dprintf("ERROR: Unable to determine LIST_ENTRY for virtual servers\n");
        dprintf("  If you are using windbg, you should specify the value as the\n");
        dprintf("  2nd argument.  You can determine the address value by typeing:\n");
        dprintf("      x " AQUEUE_VIRTUAL_SERVER_SYMBOL "\n");
        dprintf("  You may also have bad symbols for aqueue.dll.\n");
        return;
    }

    if (!ReadMemory(pvListHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("ERROR: Unable to read entry @ aqueue!g_liVirtualServers 0x%08X", pvListHead);
        return;
    }

    if (!ReadMemory(pcInstances, &cInstances, sizeof(DWORD), NULL))
    {
        //For you windbg users out there
        dprintf("\n\n%Virtual Server Instance(s)\n\n");
    }
    else
    {
        dprintf("\n\n%d Virtual Server Instance(s)\n\n", cInstances);
    }

    dprintf("Class@Address              Server Instance\n");
    dprintf("==========================================\n");
    while (liCurrent.Flink != pvListHead)
    {
        pCMQAddress = CONTAINING_RECORD(liCurrent.Flink, CAQSvrInst, m_liVirtualServers);


        if (!ReadMemory(pCMQAddress, paqinst, sizeof(CAQSvrInst), NULL))
        {
            dprintf("ERROR: Unable to CAQSvrInst @0x%08X", pCMQAddress);
            return;
        }

        if (CATMSGQ_SIG != paqinst->m_dwSignature)
        {
            dprintf("@0x%08X INVALID SIGNATURE - list entry @0x%08X\n", pCMQAddress, liCurrent.Flink);
        }
        else
        {
            dprintf("CAQSvrInst@0x%08X    %d\n", pCMQAddress, paqinst->m_dwServerInstance);
            if (paqinst->m_dwServerInstance == dwInstance)
                wsprintf(szDumpArg, "CAQSvrInst@0x%08X", pCMQAddress);
        }


        if (!ReadMemory(liCurrent.Flink, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("ERROR: Unable to read entry @0x%08X", liCurrent.Flink);
            return;
        }


    }

    //Dump the interesting instance
    if ('\0' != szDumpArg[0])
        _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);

}

//---[ DumpDNT ]------------------------------------------------------------
//
//
//  Description:
//      Dumps the contents of a DOMAIN_NAME_TABLE
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(DumpDNT)
{
    BYTE  pbBuffer[sizeof(DOMAIN_NAME_TABLE)];
    PDOMAIN_NAME_TABLE pdnt = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntryRealAddress = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pPathEntry = NULL;
    BYTE  pbEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)];
    BYTE  pbPathEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)]; //buffer for putter path name entries in
    BYTE  pbPathEntryBuffer[MAX_DOM_PATH_SIZE];
    CHAR                        pBuffer[MAX_DOM_PATH_SIZE] = "Root Entry";
    LPSTR                       pPathBuffer = NULL;
    LPSTR                       pPathBufferStop = NULL;
    LPSTR                       pEntryBuffer = NULL;
    LPSTR                       pEntryBufferStop = NULL;
    DWORD                       dwLength = 0;
    DWORD dwSig = 0;

    //Define buffers for parsing addresses... the sizes are clearly overkill, and
    //I'm not too worried about overflow in a debugger extension
    CHAR                        szAddress[MAX_DOM_PATH_SIZE];
    CHAR                        szDumpArg[MAX_DOM_PATH_SIZE] = "";
    LPSTR                       szParsedArg = (LPSTR) szArg;
    LPSTR                       szCurrentDest = NULL;

    //Allow people who are used to typeing dump CFoo@Address... keep using the @ sign
    if ('@' == *szParsedArg)
        szParsedArg++;

    //Get Address of DomainNameTable
    szCurrentDest = szAddress;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szParsedArg-szArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';


    //Eat white space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Copy name of struct to dump at each node
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '@';
    szCurrentDest++;  //szCurrentDest now points to place to copy address to

    pdnt = (PDOMAIN_NAME_TABLE) GetExpression(szAddress);

    if (!pdnt)
    {
        dprintf("ERROR: Unable to Get DOMAIN_NAME_TABLE from argument %s\n", szArg);
        return;
    }

    if (!ReadMemory(pdnt, pbBuffer, sizeof(DOMAIN_NAME_TABLE), NULL))
    {
        dprintf("ERROR: Unable to read process memory\n");
        return;
    }

    pPathBuffer = pBuffer;
    pPathBufferStop = pPathBuffer + (MAX_DOM_PATH_SIZE / sizeof(CHAR) -1 );

    pEntryRealAddress = (PDOMAIN_NAME_TABLE_ENTRY)
                ((BYTE *)pdnt + FIELD_OFFSET(DOMAIN_NAME_TABLE, RootEntry));
    pdnt = (PDOMAIN_NAME_TABLE) pbBuffer;

    pEntry = &(pdnt->RootEntry);
    dprintf("Entry ID    # Children  pData       pWildCard    Path\n");
    dprintf("===========================================================================\n");
    while(pEntry)
    {
        //only display interesting entries
        if (pEntry->pData || pEntry->pWildCardData)
        {
           //Get full path name of this domain entry
            pPathEntry = pEntry;
            pPathBuffer = pBuffer;
            while (pPathEntry && pPathEntry->pParentEntry && pPathBuffer < pPathBufferStop)
            {
                //dump current entries portion of the string
                if (pPathBuffer != pBuffer) //already made first pass -- Add delimter
                {
                    *pPathBuffer++ = '.';
                }

                //read partial path name from debuggee
                if (!ReadMemory(pPathEntry->PathSegment.Buffer, pbPathEntryBuffer,
                         AQ_MIN(MAX_DOM_PATH_SIZE, pPathEntry->PathSegment.Length), NULL))
                {
                    dprintf("ERROR: Unable to read process memory for path segment 0x%08X\n",
                        pPathEntry->PathSegment.Buffer);
                    break;
                }

                pEntryBuffer = (CHAR *) pbPathEntryBuffer;
                pEntryBufferStop = pEntryBuffer;
                pEntryBuffer += (pPathEntry->PathSegment.Length / sizeof(CHAR) -1 );

                while (pPathBuffer < pPathBufferStop && pEntryBuffer >= pEntryBufferStop)
                {
                    *pPathBuffer++ = *pEntryBuffer--;
                }
                *pPathBuffer = '\0'; //make sure we terminate
                pPathEntry = pPathEntry->pParentEntry;

                //read next part of path name from debuggee
                if (!ReadMemory(pPathEntry, pbPathEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory for path entry 0x%08x\n", pPathEntry);
                    pPathEntry = NULL;
                }
                else
                {
                    pPathEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbPathEntry;
                }
            }

            dprintf("0x%08.8X  %10.10d  0x%08.8X  0x%08.8X   %s\n", pEntryRealAddress,
                pEntry->NoOfChildren, pEntry->pData, pEntry->pWildCardData, pBuffer);

            //Dump structs if requested
            if ('@' != *szDumpArg)
            {
                if (pEntry->pData)
                {
                    //Write address string
                    wsprintf(szCurrentDest, "0x%08X", pEntry->pData);

                    //Call ptdbgext dump function
                    _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);
                }

                if (pEntry->pWildCardData)
                {
                    //Write address string
                    wsprintf(szCurrentDest, "0x%08X", pEntry->pWildCardData);

                    //Call ptdbgext dump function
                    _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);
                }

            }
        }

        //Get the next entry... in order of child, sibling, closest ancestor with sibling
        if (pEntry->pFirstChildEntry != NULL)
        {
            pEntryRealAddress = pEntry->pFirstChildEntry;
        }
        else if (pEntry->pSiblingEntry != NULL)
        {
            pEntryRealAddress = pEntry->pSiblingEntry;
        }
        else
        {
            for (pEntryRealAddress = pEntry->pParentEntry;
                    pEntryRealAddress != NULL;
                        pEntryRealAddress = pEntry->pParentEntry)
            {
                //must read parent entry into our buffer
                if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory of parent domain entry 0x%08X\n", pEntryRealAddress);
                    pEntry = NULL;
                    break;
                }
                pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;

                if (pEntry->pSiblingEntry != NULL)
                    break;

            }
            if (pEntry != NULL)
            {
                pEntryRealAddress = pEntry->pSiblingEntry;
            }
        }

        if (pEntryRealAddress)
        {
            if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
            {
                dprintf("ERROR: Unable to read process memory on domain entry 0x%08X\n",
                    pEntryRealAddress);
                pEntry = NULL;
                break;
            }
            pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;
        }
        else
        {
            pEntry = NULL;
        }
    }
    dprintf("===========================================================================\n");
}


//---[ DumpList ]--------------------------------------------------------------
//
//
//  Description:
//      Function to walk a set of LIST_ENTRY's and dump their contenxts
//  Parameters:
//      szArg - space separated list of the following
//          Address of head list entry
//          Offset of object address [optional]
//          Name of object to dump [optional]
//  Returns:
//      -
//  History:
//      9/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dumplist)
{
    const DWORD MAX_ARG_SIZE = 200;
    const DWORD MAX_ENTRIES = 3000;
    LIST_ENTRY  liCurrent;
    PLIST_ENTRY pliHead = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    DWORD_PTR   dwOffsetOfEntry = 0;
    CHAR        szAddress[MAX_ARG_SIZE];
    CHAR        szDumpArg[MAX_ARG_SIZE];
    LPSTR       szParsedArg = (LPSTR) szArg;
    LPSTR       szCurrentDest = NULL;
    DWORD       cEntries = 0;

    //Get Address of DomainNameTable
    szCurrentDest = szAddress;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szParsedArg-szArg <= MAX_ARG_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';


    //Eat white space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Get offset of data
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_ARG_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';
    dwOffsetOfEntry = GetExpression(szDumpArg);

    //Eat white more space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Copy name of struct to dump at each node
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_ARG_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '@';
    szCurrentDest++;  //szCurrentDest now points to place to copy address to

    pliHead = (PLIST_ENTRY) GetExpression(szAddress);
    if (!ReadMemory(pliHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("Error reading head entry at 0x%08X\n", pliHead);
        return;
    }

    pliCurrent = pliHead;
    dprintf("LIST ENTRY       DATA OFFSET\n");
    dprintf("==============================================\n");
    dprintf(" 0x%08X       0x%08X (HEAD)\n", pliCurrent, pliCurrent-dwOffsetOfEntry);
    dprintf("----------------------------------------------\n");
    //OK... start walking list using Flink
    pliCurrent = liCurrent.Flink;
    while(pliCurrent != NULL && pliHead != pliCurrent)
    {
        // There have been some problems with this.
#ifdef NEVER
        if (pliCurrent != liCurrent.Blink)
        {
            dprintf(" %p       %p (WARNING does Flink/Blink mismatch)\n", pliCurrent,
                ((DWORD_PTR) pliCurrent)-dwOffsetOfEntry);
        }
        else
#else
        if (TRUE)
#endif //NEVER
        {
            dprintf(" %p       %p\n", pliCurrent,
                ((DWORD_PTR) pliCurrent)-dwOffsetOfEntry);
        }

        if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("Error reading LIST_ENTRY at 0x%08X\n", pliCurrent);
            return;
        }

        //dump the struct if we were asked to
        if ('@' != *szDumpArg)
        {
            //Write address string
            wsprintf(szCurrentDest, "%p", ((DWORD_PTR) pliCurrent)-dwOffsetOfEntry);

            //Call ptdbgext dump function
            _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);
        }

        cEntries++;
        if (cEntries > MAX_ENTRIES)
        {
            dprintf("ERROR: Max number of entries exceeded\n");
            return;
        }
        pliCurrent = liCurrent.Flink;
    }
    dprintf("----------------------------------------------\n");
    dprintf(" %d Total Entries\n", cEntries);
    dprintf("==============================================\n");


}

//---[ linkstate ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps the current link state (including routing information) of a
//      virtual server.
//  Parameters:
//      Virtual Server Instance - virtual server ID of server to dump
//      Global Server list (optional) - Head of virtual server list
//  Returns:
//      -
//  History:
//      9/30/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(linkstate)
{
    DWORD       dwInstance = 0;
    PLIST_ENTRY pliHead = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    BYTE        pBuffer[sizeof(CAQSvrInst)] = {'\0'};
    CAQSvrInst  *paqinst = (CAQSvrInst *) pBuffer;
    DOMAIN_NAME_TABLE *pdnt = NULL;
    PVOID       pvAQueue = NULL;
    LIST_ENTRY liCurrent;
    BOOL        fFound = FALSE;
    CHAR        szArgBuffer[20];
    LPSTR       szCurrentArg = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntryRealAddress = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pPathEntry = NULL;
    BYTE        pbEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)];
    CHAR        szNextHop[MAX_DOM_PATH_SIZE];
    CHAR        szFinalDest[MAX_DOM_PATH_SIZE];
    BYTE        pbLMQ[sizeof(CLinkMsgQueue)];
    BYTE        pbDomainEntry[sizeof(CDomainEntry)];
    BYTE        pbDMQ[sizeof(CDestMsgQueue)];
    CLinkMsgQueue *plmq = (CLinkMsgQueue *) pbLMQ;
    CDomainEntry  *pdentry = (CDomainEntry *) pbDomainEntry;
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pbDMQ;
    DWORD         *pdwGuid = NULL;
    LPSTR       szLinkState = LINK_STATE_UP;
    CHAR        szError[100];
    HINSTANCE   hModule = GetModuleHandle("aqdbgext.dll");
    DWORD       dwMsgId = 0;
    DWORD       dwFacility = 0;

    CheckVersion(DebugArgs);

    if (!szArg || ('\0' == szArg[0]))
    {
        //Assume the first instance
        dwInstance = 1;
        pliHead = (PLIST_ENTRY) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwInstance = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pliHead = (PLIST_ENTRY) GetExpression(szCurrentArg);
            else
                pliHead = (PLIST_ENTRY) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
        }
    }


    if (!pliHead)
    {
        dprintf("ERROR: Unable to determine LIST_ENTRY for virtual servers\n");
        dprintf("  If you are using windbg, you should specify the value as the\n");
        dprintf("  2nd argument.  You can determine the address value by typeing:\n");
        dprintf("      x " AQUEUE_VIRTUAL_SERVER_SYMBOL "\n");
        return;
    }

    if (!ReadMemory(pliHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("ERROR: Unable to read entry @0x%08X\n", pliHead);
        return;
    }

    while (liCurrent.Flink != pliHead)
    {
        pvAQueue = CONTAINING_RECORD(liCurrent.Flink, CAQSvrInst, m_liVirtualServers);

        if (!ReadMemory(pvAQueue, paqinst, sizeof(CAQSvrInst), NULL))
        {
            dprintf("ERROR: Unable to CAQSvrInst @0x%08X", pvAQueue);
            return;
        }

        //Check the signature
        if (CATMSGQ_SIG != paqinst->m_dwSignature)
        {
            dprintf("@0x%08X INVALID SIGNATURE - list entry @0x%08X\n", pvAQueue, liCurrent.Flink);
            return;
        }
        else
        {
            if (paqinst->m_dwServerInstance == dwInstance)
            {
                fFound = TRUE;
                break;
            }
        }

        pliCurrent = liCurrent.Flink;

        if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("ERROR: Unable to read entry @0x%08X\n", pliCurrent);
            return;
        }

        if (pliCurrent == liCurrent.Flink)
        {
            dprintf("ERROR: Loop in LIST_ENTRY @0x%08X\n", pliCurrent);
            return;
        }
    }

    if (!fFound)
    {
        dprintf("Requested instance not found.\n");
        return;
    }

    dprintf("Using Server instance %d @0x%08X\n", dwInstance, pvAQueue);
    //Use our current instance to dump all of the interesting bits

    pdnt = &(paqinst->m_dmt.m_dnt);
    pEntry = &(pdnt->RootEntry);

    while(pEntry)
    {
        //We are not interested in wildcard data
        if (pEntry->pData)
        {
            //Display link state information
            if (!ReadMemory(pEntry->pData, pbDomainEntry, sizeof(CDomainEntry), NULL))
            {
                dprintf("ERROR: Unable to read domain entry from @0x%08X\n", pEntry->pData);
                return;
            }

            pliHead = (PLIST_ENTRY) (((BYTE *)pEntry->pData) + FIELD_OFFSET(CDomainEntry, m_liDestQueues));
            pliCurrent = pdentry->m_liDestQueues.Flink;

            //Get final destination string
            if (!ReadMemory(pdentry->m_szDomainName, szFinalDest, pdentry->m_cbDomainName, NULL))
            {
                dprintf("ERROR: Unable to read final destination name from @0x%08X\n",
                        pdentry->m_szDomainName);
                return;
            }

            szFinalDest[pdentry->m_cbDomainName] = '\0';

            //Loop and display each DMQ
            while (pliHead != pliCurrent)
            {
                if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read link LIST_ENTRY @0x%08X\n", pliCurrent);
                    return;
                }

                if (!ReadMemory(CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs),
                                pbDMQ, sizeof(CDestMsgQueue), NULL))
                {
                    dprintf("ERROR: Unable to read DMQ @0x%08X\n",
                            CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs));
                    return;
                }

                //Verify DMQ Signature
                if (DESTMSGQ_SIG != pdmq->m_dwSignature)
                {
                    dprintf("ERROR: Invalid DMQ signature for CDestMsgQueue@0x%08X (from LIST_ENTRY) @0x%08X\n",
                            CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs),
                            pliCurrent);
                    return;
                }

                //Read link
                if (!ReadMemory(pdmq->m_plmq, pbLMQ, sizeof(CLinkMsgQueue), NULL))
                {
                    dprintf("ERROR: Unable to read LMQ @0x%08X\n",
                            pdmq->m_plmq);
                    return;
                }

                //Now print off next hop info
                if (!ReadMemory(plmq->m_szSMTPDomain, szNextHop, plmq->m_cbSMTPDomain, NULL))
                {
                    dprintf("ERROR: Unable to read next hop name from @0x%08X\n",
                            plmq->m_szSMTPDomain);
                    return;
                }
                szNextHop[plmq->m_cbSMTPDomain] = '\0';

                pdwGuid = (DWORD *) &(plmq->m_aqsched.m_guidRouter);

                //Determine the state of the link
                if (plmq->m_dwLinkFlags & LINK_STATE_PRIV_GENERATING_DSNS)
                {
                    szLinkState = LINK_STATE_DSN;
                }
                if (CLinkMsgQueue::fFlagsAllowConnection(plmq->m_dwLinkStateFlags))
                {
                    //If we can connect... are we?
                    if (plmq->m_cConnections)
                        szLinkState = LINK_STATE_ACTIVE;
                    else
                        szLinkState = LINK_STATE_UP;
                }
                else
                {
                    //If we're down... why?
                    szLinkState = LINK_STATE_DOWN;
                    if (!(plmq->m_dwLinkStateFlags & LINK_STATE_RETRY_ENABLED))
                        szLinkState = LINK_STATE_RETRY;
                    else if (plmq->m_dwLinkStateFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
                        szLinkState = LINK_STATE_TURN;
                    else if (plmq->m_dwLinkStateFlags & LINK_STATE_PRIV_NO_CONNECTION)
                        szLinkState = LINK_STATE_SPECIAL;
                }

                //Print some interesting data
                dprintf("==============================================================================\n");
                dprintf("| Link State | Final Destination             | Next Hop                      |\n");
                dprintf("| %s | %-29s | %-29s |\n", szLinkState, szFinalDest, szNextHop);
                dprintf("------------------------------------------------------------------------------\n");
                dprintf("| Route Details:                                                             |\n");
                dprintf("|                 Router GUID: %08X-%08X-%08X-%08X           |\n",
                        pdwGuid[0], pdwGuid[1], pdwGuid[2], pdwGuid[3]);
                dprintf("|                 Message Type: %08X  Schedule ID:%08X               |\n",
                        pdmq->m_aqmt.m_dwMessageType, plmq->m_aqsched.m_dwScheduleID);
                dprintf("|                 Link State Flags 0x%08X                                |\n",
                        plmq->m_dwLinkStateFlags);
                dprintf("|                 Current # of connections: %-8d                         |\n",
                        plmq->m_cConnections);
                dprintf("|                 Current # of Msgs (on link): %-8d                      |\n",
                        plmq->m_aqstats.m_cMsgs);
                dprintf("|                 Current # of Msgs (on DMQ): %-8d                       |\n",
                        pdmq->m_aqstats.m_cMsgs);
                dprintf("|                 CLinkMsgQueue@0x%08X                                   |\n",
                        pdmq->m_plmq);
                dprintf("|                 CDestMsgQueue@0x%08X                                   |\n",
                       CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs));

                //print out the diagnostic information if in retry
                //or a failure has been recorded and there are no msgs.
                if ((LINK_STATE_RETRY == szLinkState) ||
                    (FAILED(plmq->m_hrDiagnosticError) && !plmq->m_aqstats.m_cMsgs))
                {
                    //Get and format the error message
                    szError[0] = '\0';
                    dwMsgId = plmq->m_hrDiagnosticError;
                    dwFacility = ((0x0FFF0000 & dwMsgId) >> 16);

                    //If it is not ours... then "un-HRESULT" it
                    if (dwFacility != FACILITY_ITF)
                        dwMsgId &= 0x0000FFFF;


                    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
                                  FORMAT_MESSAGE_IGNORE_INSERTS |
                                  FORMAT_MESSAGE_FROM_HMODULE,
                                  hModule,
                                  dwMsgId,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  szError,
                                  sizeof(szError),
                                  NULL );

                    dprintf("------------------------------------------------------------------------------\n");
                    dprintf("| Failure Details:                                                           |\n");
                    dprintf("|                 Diagnostic HRESULT 0x%08X                              |\n",
                                plmq->m_hrDiagnosticError);
                    if (szError && *szError)
                    {
                        dprintf("|                 Diagnostic string: %s\n",
                                    szError);
                    }
                    dprintf("|                 Protocol Verb: %-20.20s                        |\n",
                                plmq->m_szDiagnosticVerb);
                    dprintf("|                 Protocol Response: %s\n",
                                plmq->m_szDiagnosticResponse);
                }
                pliCurrent = liCurrent.Flink;
            }
        }

        //Now determine what the "next" entry is
        if (pEntry->pFirstChildEntry != NULL)
        {
            pEntryRealAddress = pEntry->pFirstChildEntry;
        }
        else if (pEntry->pSiblingEntry != NULL)
        {
            pEntryRealAddress = pEntry->pSiblingEntry;
        }
        else
        {
            for (pEntryRealAddress = pEntry->pParentEntry;
                    pEntryRealAddress != NULL;
                        pEntryRealAddress = pEntry->pParentEntry)
            {
                //must read parent entry into our buffer
                if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory of parent domain entry 0x%08X\n", pEntryRealAddress);
                    pEntry = NULL;
                    break;
                }
                pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;

                if (pEntry->pSiblingEntry != NULL)
                    break;

            }
            if (pEntry != NULL)
            {
                pEntryRealAddress = pEntry->pSiblingEntry;
            }
        }

        if (pEntryRealAddress)
        {
            if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
            {
                dprintf("ERROR: Unable to read process memory on domain entry 0x%08X\n",
                    pEntryRealAddress);
                pEntry = NULL;
                break;
            }
            pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;
        }
        else
        {
            pEntry = NULL;
        }
    }
    dprintf("==============================================================================\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\aqdbgext.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgext.h
//
//  Description: Header file for Advanced Queuing debugger extensions
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQDBGEXT_H__
#define __AQDBGEXT_H__

#include <dbgdumpx.h>

#define AQ_DEBUG_EXTENSION(function)  TRANS_DEBUG_EXTENSION(function)
#define AQ_DEBUG_EXTENSION_IMP(function) TRANS_DEBUG_EXTENSION(function)

#define AQUEUE_VIRTUAL_SERVER_SYMBOL "aqueue!g_liVirtualServers"

AQ_DEBUG_EXTENSION(DumpServers);
AQ_DEBUG_EXTENSION(Offsets);
AQ_DEBUG_EXTENSION(DumpDNT);
AQ_DEBUG_EXTENSION(dumplist);
AQ_DEBUG_EXTENSION(linkstate);
AQ_DEBUG_EXTENSION(hashthread);
AQ_DEBUG_EXTENSION(dumplock);
AQ_DEBUG_EXTENSION(dumpoffsets);
AQ_DEBUG_EXTENSION(walkcpool);
AQ_DEBUG_EXTENSION(workqueue);
AQ_DEBUG_EXTENSION(queueusage);
AQ_DEBUG_EXTENSION(dmqusage);
AQ_DEBUG_EXTENSION(dntusage);
AQ_DEBUG_EXTENSION(dumpqueue);
AQ_DEBUG_EXTENSION(displaytickcount);

//Export lower case versions of the functions because windbg forces all lower case
//This means that all *new* function names should be all lower case/
AQ_DEBUG_EXTENSION(dumpservers);
AQ_DEBUG_EXTENSION(dumpdnt);

#include "aqmem.h"

#endif __AQDBGEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\aqdumps.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdumps.cpp
//
//  Description:  Definitions of AQ structure dumps for use with ptdbgext.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_

//baseobj.h is inlcluded
#define _WINSOCKAPI_

#include <atq.h>
#include "aqdbgext.h"
#ifdef PLATINUM
#include <ptrwinst.h>
#else //not PLATINUM
#include <rwinst.h>
#endif PLATINUM
#include <aqinst.h>
#include <connmgr.h>
#include <msgref.h>
#include <fifoq.h>
#include <dcontext.h>
#include <smtpconn.h>
#include <destmsgq.h>
#include <linkmsgq.h>
#include <qwiklist.h>
#include <dsnbuff.h>
#include <time.h>
#include <qwiktime.h>
#include <asyncq.h>
#include <retryq.h>
#include <hashentr.h>
#include <aqstats.h>
#include <aqadmsvr.h>
#include <defdlvrq.h>
#include <aqsize.h>
#include <asncwrkq.h>
#include <rwinst.h>


PEXTLIB_INIT_ROUTINE g_pExtensionInitRoutine = NULL;

DEFINE_EXPORTED_FUNCTIONS

LPSTR ExtensionNames[] = {
    "Advanced Queuing debugger extensions",
    0
};

LPSTR Extensions[] = {
    "offsets - Lists LIST_ENTRY offsets",
    "   USAGE: offsets",
    "dumpservers - Dump pointers to the virtual server objects",
    "   USAGE: dumpservers [<virtual server id> [<virtual server list address>]]",
    "       <virtual server id> - specifies instance ID to dump in detail",
    "       <virtual server list address> - address of the head of the virtual",
    "                                       server LIST_ENTRY. No needed in CDB,",
    "                                       but can be found in windbg by typing:",
    "                         x " AQUEUE_VIRTUAL_SERVER_SYMBOL,
    "dumpdnt - Dump a given DOMAIN_NAME_TABLE (and it's entries)",
    "   USAGE: dumpdnt [<Struct Type Name>]",
    "       <Struct Type Name> - if specified, will dump all entries",
    "                            in the DNT as this type",
    "dumplist - Dump a given list of LIST_ENTRY structs",
    "   USAGE: dumplist <list head> [<entry offset> [<Struct Type Name>]]",
    "       <list head> - Address of head LIST_ENTRY",
    "       <entry offset> - The offset in each object of the LIST_ENTRY.",
    "                        This can be determined using the offses command.",
    "       <Struct Type Name> - Type of object list entries are in.",
    "dumpqueue - Dump the CMsgRefs and IMailMsgProperties for  a given queue",
    "   USAGE: dumpqueue <queue> [<search>]",
    "       <queue> -  Address of DMQ, LMQ, or FIFOQ",
    "       <search> - IMailMsgProperties ptr to search for",
    "walkcpool - Dump the currently allocted entries for a *DBG* CPool",
    "   USAGE: walkcpool <cpool> [<dumpoffset>]",
    "       <cpool> - Address of static CPool to dump",
    "       <dumpoffset> - Offset of additional information to dump",
    "   An example usages is to dump all the STMP_CONNOUT objects and",
    "   all the ISMTPConn interfaces they point to",
    "displaytickcount - Display the localized actual time of a given tick count",
    "   USAGE: displaytickcount <tickcount>",
    "       <tickcount> - DWORD tickcount to display",
    "workqueue - Display a summary of items in the async work queue",
    "   USAGE: workqueue <queue>",
    "       <queue> - Address of work queue (can be obtained from dumpservers)",
    "dumplock  - Dumps current state (included shared threads) of a CShareLockInst",
    "   USAGE: dumplock <lock>",
    "       <lock> - Address of CShareLockInst object",
    "linkstate - Dumps the current routing information and link state",
    "   USAGE: linkstate [<virtual server ID> [<virtual server list address>]]",
    "       <virtual server id> - specifies instance ID to get data for",
    "       <virtual server list address> - address of the head of the virtual",
    "                                       server LIST_ENTRY. No needed in CDB,",
    "                                       but can be found in windbg by typing:",
    "                         x " AQUEUE_VIRTUAL_SERVER_SYMBOL,
    "\n",
    "***NOTE***\n",
    "   You MUST have good aqueue.dll symbols to use dumpservers and linkstate",
    0
};


//Stuctures for dumping

//Dummy class for dumping a filetime
class CFileTime
{
  public:
    FILETIME    m_ft;
};

#define MEMBER_BIT_MASK_VALUE(MyClass, x) BIT_MASK_VALUE2(MyClass::x, #x)

BEGIN_FIELD_DESCRIPTOR(CFileTimeFields)
    FIELD3(FieldTypeLocalizedFiletime, CFileTime, m_ft)
    FIELD3(FieldTypeFiletime, CFileTime, m_ft)
END_FIELD_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(CmtInitMask)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_OK)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_DMT)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_DCT)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_MSGQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_LINKQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_CONMGR)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_DSN)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_PRECATQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_PRELOCQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_POSTDSNQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_ROUTER_RESET)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_WORKQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_MSGQ)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgRefBitMask)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_LOCAL_RETRY)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_COUNTED_AS_REMOTE)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_REMOTE_RETRY)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_SUPERSEDED)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_INIT)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_FROZEN)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_RETRY_ON_DELETE)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_ASYNC_BOUNCE_PENDING)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MAILMSG_RELEASED)
    BIT_MASK_VALUE(eEffPriNormalMinus)
    BIT_MASK_VALUE(eEffPriNormal)
    BIT_MASK_VALUE(eEffPriNormalPlus)
    BIT_MASK_VALUE(eEffPriHighMinus)
    BIT_MASK_VALUE(eEffPriHigh)
    BIT_MASK_VALUE(eEffPriHighPlus)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgAckBitMask)
    BIT_MASK_VALUE(MESSAGE_STATUS_ALL_DELIVERED)
    BIT_MASK_VALUE(MESSAGE_STATUS_RETRY)
    BIT_MASK_VALUE(MESSAGE_STATUS_CHECK_RECIPS)
    BIT_MASK_VALUE(MESSAGE_STATUS_NDR_ALL)
    BIT_MASK_VALUE(MESSAGE_STATUS_DSN_NOT_SUPPORTED)
    BIT_MASK_VALUE(MESSAGE_STATUS_EXTENDED_STATUS_CODES)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(LinkStateBitMask)
    BIT_MASK_VALUE(LINK_STATE_RETRY_ENABLED)
    BIT_MASK_VALUE(LINK_STATE_SCHED_ENABLED)
    BIT_MASK_VALUE(LINK_STATE_ADMIN_FORCE_CONN)
    BIT_MASK_VALUE(LINK_STATE_ADMIN_HALT)
    BIT_MASK_VALUE(LINK_STATE_CMD_ENABLED)
    BIT_MASK_VALUE2(LINK_STATE_PRIV_ETRN_ENABLED, "LINK_STATE_PRIV_ETRN_ENABLED")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_TURN_ENABLED, "LINK_STATE_PRIV_TURN_ENABLED")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_CONFIG_TURN_ETRN, "LINK_STATE_PRIV_CONFIG_TURN_ETRN")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_NO_NOTIFY, "LINK_STATE_PRIV_NO_NOTIFY")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_NO_CONNECTION, "LINK_STATE_PRIV_NO_CONNECTION")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_GENERATING_DSNS, "LINK_STATE_PRIV_GENERATING_DSNS")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY, "LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION, "LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED, "LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED")
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(LinkFlagsBitMask)
    BIT_MASK_VALUE(eLinkFlagsClear)
    BIT_MASK_VALUE(eLinkFlagsSentNewNotification)
    BIT_MASK_VALUE(eLinkFlagsRouteChangePending)
    BIT_MASK_VALUE(eLinkFlagsFileTimeSpinLock)
    BIT_MASK_VALUE(eLinkFlagsDiagnosticSpinLock)
    BIT_MASK_VALUE(eLinkFlagsConnectionVerifed)
    BIT_MASK_VALUE(eLinkFlagsGetInfoFailed)
    BIT_MASK_VALUE(eLinkFlagsAQSpecialLinkInfo)
    BIT_MASK_VALUE(eLinkFlagsInternalSMTPLinkInfo)
    BIT_MASK_VALUE(eLinkFlagsExternalSMTPLinkInfo)
    BIT_MASK_VALUE(eLinkFlagsMarkedAsEmpty)
    BIT_MASK_VALUE(eLinkFlagsInvalid)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DomainInfoBitMask)
    BIT_MASK_VALUE(DOMAIN_INFO_REMOTE)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_SSL)
    BIT_MASK_VALUE(DOMAIN_INFO_SEND_TURN)
    BIT_MASK_VALUE(DOMAIN_INFO_SEND_ETRN)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_NTLM)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_PLAINTEXT)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_DPA)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_KERBEROS)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_CHUNKING)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_HELO)
    BIT_MASK_VALUE(DOMAIN_INFO_TURN_ONLY)
    BIT_MASK_VALUE(DOMAIN_INFO_ETRN_ONLY)
    BIT_MASK_VALUE(DOMAIN_INFO_LOCAL_DROP)
    BIT_MASK_VALUE(DOMAIN_INFO_LOCAL_MAILBOX)
    BIT_MASK_VALUE(DOMAIN_INFO_REMOTE_SMARTHOST)
    BIT_MASK_VALUE(DOMAIN_INFO_IP_RELAY)
    BIT_MASK_VALUE(DOMAIN_INFO_AUTH_RELAY)
    BIT_MASK_VALUE(DOMAIN_INFO_DOMAIN_RELAY)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_CHUNKING)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_BMIME)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_DSN)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_PIPELINE)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DCTFlags)
    MEMBER_BIT_MASK_VALUE(CDomainConfigTable, DOMCFG_DOMAIN_NAME_TABLE_INIT)
    MEMBER_BIT_MASK_VALUE(CDomainConfigTable, DOMCFG_FINISH_UPDATE_PENDING)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(InternalDomainInfoFlags)
    BIT_MASK_VALUE(INT_DOMAIN_INFO_INVALID)
    BIT_MASK_VALUE(INT_DOMAIN_INFO_OK)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(ConnectionAckFlags)
    BIT_MASK_VALUE(CONNECTION_STATUS_OK)
    BIT_MASK_VALUE(CONNECTION_STATUS_FAILED)
    BIT_MASK_VALUE(CONNECTION_STATUS_DROPPED)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(AsyncQueueFlags)
    BIT_MASK_VALUE2(CAsyncQueueBase::ASYNC_QUEUE_STATUS_SHUTDOWN, "ASYNC_QUEUE_STATUS_SHUTDOWN")
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DMQBitmask)
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_INVALID, "DMQ_INVALID")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_IN_EMPTY_QUEUE_LIST, "DMQ_IN_EMPTY_QUEUE_LIST")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_SHUTDOWN_SIGNALED, "DMQ_SHUTDOWN_SIGNALED")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_EMPTY, "DMQ_EMPTY")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_EXPIRED, "DMQ_EXPIRED")
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DSNOptions)
    BIT_MASK_VALUE(DSN_OPTIONS_DEFAULT)
    BIT_MASK_VALUE(DSN_OPTIONS_DEFAULT_RET_HEADERS)
    BIT_MASK_VALUE(DSN_OPTIONS_DEFAULT_RET_FULL)
    BIT_MASK_VALUE(DSN_OPTIONS_IGNORE_MSG_RET)
    BIT_MASK_VALUE(DSN_OPTIONS_SEND_DELAY_DEFAULT)
    BIT_MASK_VALUE(DSN_OPTIONS_SEND_DELAY_UPON_REQUEST)
    BIT_MASK_VALUE(DSN_OPTIONS_SEND_DELAY_NEVER)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgEnumFilterFlags)
    BIT_MASK_VALUE(MEF_FIRST_N_MESSAGES)
    BIT_MASK_VALUE(MEF_N_LARGEST_MESSAGES)
    BIT_MASK_VALUE(MEF_N_OLDEST_MESSAGES)
    BIT_MASK_VALUE(MEF_OLDER_THAN)
    BIT_MASK_VALUE(MEF_LARGER_THAN)
    BIT_MASK_VALUE(MEF_INVERTSENSE)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgFilterFlags)
    BIT_MASK_VALUE(MF_MESSAGEID)
    BIT_MASK_VALUE(MF_SENDER)
    BIT_MASK_VALUE(MF_RECIPIENT)
    BIT_MASK_VALUE(MF_SIZE)
    BIT_MASK_VALUE(MF_TIME)
    BIT_MASK_VALUE(MF_FROZEN)
    BIT_MASK_VALUE(MF_INVERTSENSE)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(InternalMsgFilterFlags)
    BIT_MASK_VALUE(AQ_MSG_FILTER_MESSAGEID)
    BIT_MASK_VALUE(AQ_MSG_FILTER_SENDER)
    BIT_MASK_VALUE(AQ_MSG_FILTER_RECIPIENT)
    BIT_MASK_VALUE(AQ_MSG_FILTER_OLDER_THAN)
    BIT_MASK_VALUE(AQ_MSG_FILTER_LARGER_THAN)
    BIT_MASK_VALUE(AQ_MSG_FILTER_FROZEN)
    BIT_MASK_VALUE(AQ_MSG_FILTER_FIRST_N_MESSAGES)
    BIT_MASK_VALUE(AQ_MSG_FILTER_N_LARGEST_MESSAGES)
    BIT_MASK_VALUE(AQ_MSG_FILTER_N_OLDEST_MESSAGES)
    BIT_MASK_VALUE(AQ_MSG_FILTER_INVERTSENSE)
END_BIT_MASK_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DMTFields)
    FIELD3(FieldTypeClassSignature, CDomainMappingTable, m_dwSignature)
    FIELD3(FieldTypeDword, CDomainMappingTable, m_dwInternalVersion)
    FIELD3(FieldTypeDword, CDomainMappingTable, m_cThreadsForEmptyDMQList)
    FIELD3(FieldTypeDword, CDomainMappingTable, m_cOutstandingExternalShareLocks)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_paqinst)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_plmqLocal)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_plmqUnreachable)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_plmqCurrentlyUnreachable)
    FIELD3(FieldTypeListEntry, CDomainMappingTable, m_liEmptyDMQHead)
    FIELD3(FieldTypeStruct, CDomainMappingTable, m_dnt)
    FIELD3(FieldTypeStruct, CDomainMappingTable, m_slPrivateData)
END_FIELD_DESCRIPTOR

EMBEDDED_STRUCT(CDomainMappingTable, DMTFields, EmbeddedDMT)

BEGIN_FIELD_DESCRIPTOR(AQStatsFields)
    FIELD3(FieldTypeClassSignature, CAQStats, m_dwSignature)
    FIELD3(FieldTypeDword, CAQStats, m_dwNotifyType)
    FIELD3(FieldTypeDword, CAQStats, m_cMsgs)
    FIELD3(FieldTypeDword, CAQStats, m_dwHighestPri)
    FIELD3(FieldTypePointer, CAQStats, m_pvContext)
    FIELD3(FieldTypeDword, CAQStats, m_uliVolume.HighPart)
    FIELD3(FieldTypeDword, CAQStats, m_uliVolume.LowPart)
END_FIELD_DESCRIPTOR

EMBEDDED_STRUCT(CAQStats, AQStatsFields, EmbeddedAQStats)

BEGIN_FIELD_DESCRIPTOR(ConnMgrFields)
    FIELD3(FieldTypeDword, CConnMgr, m_lReferences)
    FIELD3(FieldTypeDword, CConnMgr, m_cConnections)
    FIELD3(FieldTypePointer, CConnMgr, m_paqinst)
    FIELD3(FieldTypePointer, CConnMgr, m_pqol)
    FIELD3(FieldTypePointer, CConnMgr, m_pDefaultRetryHandler)
    FIELD3(FieldTypeDword, CConnMgr, m_dwConfigVersion)
    FIELD3(FieldTypeDword, CConnMgr, m_cMinMessagesPerConnection)
    FIELD3(FieldTypeDword, CConnMgr, m_cMaxLinkConnections)
    FIELD3(FieldTypeDword, CConnMgr, m_cMaxMessagesPerConnection)
    FIELD3(FieldTypeDword, CConnMgr, m_cMaxConnections)
    FIELD3(FieldTypeDword, CConnMgr, m_cGetNextConnectionWaitTime)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RSTRFields)
    FIELD3(FieldTypeClassSignature, CRefCountedString, m_dwSignature)
    FIELD3(FieldTypeDword, CRefCountedString, m_cbStrlen)
    FIELD3(FieldTypePStr, CRefCountedString, m_szStr)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RetrySinkFields)
    FIELD3(FieldTypePointer, CSMTP_RETRY_HANDLER, m_pRetryHash)
    FIELD3(FieldTypePointer, CSMTP_RETRY_HANDLER, m_pRetryQueue)
    FIELD3(FieldTypeBool, CSMTP_RETRY_HANDLER, m_fHandlerShuttingDown)
    FIELD3(FieldTypeBool, CSMTP_RETRY_HANDLER, m_fConfigDataUpdated)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_ThreadsInRetry)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwRetryThreshold)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwGlitchRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwFirstRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwSecondRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwThirdRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwFourthRetrySeconds)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RetryQueueFields)
    FIELD3(FieldTypeListEntry, CRETRY_Q, m_QHead)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RetryHashFields)
    FIELD3(FieldTypeClassSignature, CRETRY_HASH_ENTRY, m_Signature)
    FIELD3(FieldTypeLong, CRETRY_HASH_ENTRY, m_RefCount)
    FIELD3(FieldTypeBool, CRETRY_HASH_ENTRY, m_InQ)
    FIELD3(FieldTypeBool, CRETRY_HASH_ENTRY, m_InTable)
    FIELD3(FieldTypeLocalizedFiletime, CRETRY_HASH_ENTRY, m_ftEntryInsertedTime)
    FIELD3(FieldTypeLocalizedFiletime, CRETRY_HASH_ENTRY, m_ftRetryTime)
    FIELD3(FieldTypeDword, CRETRY_HASH_ENTRY, m_cFailureCount)
    FIELD3(FieldTypeSymbol, CRETRY_HASH_ENTRY, m_pfnCallbackFn)
    FIELD3(FieldTypePointer, CRETRY_HASH_ENTRY, m_pvCallbackContext)
    FIELD3(FieldTypeStrBuffer, CRETRY_HASH_ENTRY, m_szDomainName)
    FIELD3(FieldTypeListEntry, CRETRY_HASH_ENTRY, m_QLEntry)
    FIELD3(FieldTypeListEntry, CRETRY_HASH_ENTRY, m_HLEntry)
#ifdef DEBUG
    FIELD3(FieldTypePointer, CRETRY_HASH_ENTRY, m_hTranscriptHandle)
    FIELD3(FieldTypeStrBuffer, CRETRY_HASH_ENTRY, m_szTranscriptFile)
#endif //DEBUG
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CMQFields)
    FIELD3(FieldTypeClassSignature, CAQSvrInst, m_dwSignature)
    FIELD3(FieldTypeDword, CAQSvrInst, m_lReferences)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwFirstTierRetrySeconds)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwDelayExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwNDRExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwLocalDelayExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwLocalNDRExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_cLocalRetriesPending)
    FIELD3(FieldTypeDword, CAQSvrInst, m_cCatRetriesPending)
    FIELD3(FieldTypeDword, CAQSvrInst, m_cRoutingRetriesPending)
    FIELD3(FieldTypePointer, CAQSvrInst, m_pConnMgr)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_dct)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_qtTime)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreCatQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreLocalDeliveryQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPostDSNQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreRoutingQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreSubmissionQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_aqwWorkQueue)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrDefaultDomain)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrServerFQDN)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrBadMailDir)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrCopyNDRTo)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_mglSupersedeIDs)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_defq)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_fmq)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_aqwWorkQueue)
//    FIELD3(FieldTypePointer, CAQSvrInst, m_pIStoreDriverValidateContext)
    FIELD4(FieldTypeEmbeddedStruct, CAQSvrInst, m_dmt, EmbeddedDMT)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwDSNLanguageID)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_slPrivateData)
    FIELD4(FieldTypeDWordBitMask, CAQSvrInst, m_dwDSNOptions, GET_BIT_MASK_DESCRIPTOR(DSNOptions))
    FIELD4(FieldTypeDWordBitMask, CAQSvrInst, m_dwInitMask, GET_BIT_MASK_DESCRIPTOR(CmtInitMask))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(AQCounterInfoFields)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalMsgsQueued)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsAcked)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsAckedRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsAckedRetryLocal)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsDeliveredLocal)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsSubmitted)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingSubmitEvent)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingCat)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingPostCatEvent)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingRouting)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingDelivery)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingLocal)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingLocalRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentQueueMsgInstances)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteDestQueues)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHops)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsEnabled)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsPendingRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsPendingSchedule)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsFrozenByAdmin)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalMsgsSubmitted)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalExternalMsgsSubmitted)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cNDRs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cDelayedDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cDeliveredDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cRelayedDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cExpandedDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cDMTRetries)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cSupersededMsgs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingDeferredDelivery)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentResourceFailedMsgsPendingRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalMsgsBadmailed)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalResetRoutes)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalDSNFailures)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCatMsgCalled)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCatCompletionCalled)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsInLocalDelivery)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentPendingResetRoutes)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingSubmit)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgGuidListFields)
    FIELD3(FieldTypeClassSignature, CAQMsgGuidList, m_dwSignature)
    FIELD3(FieldTypeListEntry, CAQMsgGuidList, m_liMsgGuidListHead)
    FIELD3(FieldTypeStruct, CAQMsgGuidList, m_slPrivateData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgGuidListEntryFields)
    FIELD3(FieldTypeClassSignature, CAQMsgGuidListEntry, m_dwSignature)
    FIELD3(FieldTypeDword, CAQMsgGuidListEntry, m_lReferences)
    FIELD3(FieldTypePointer, CAQMsgGuidListEntry, m_pmsgref)
    FIELD3(FieldTypePointer, CAQMsgGuidListEntry, m_pmgl)
    FIELD3(FieldTypeStruct, CAQMsgGuidListEntry, m_liMsgGuidList)
    FIELD3(FieldTypeGuid, CAQMsgGuidListEntry, m_guidMsgID)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainInfoFields)
    FIELD3(FieldTypeDword, DomainInfo, cbVersion)
    FIELD3(FieldTypeDword, DomainInfo, dwDomainInfoFlags)
    FIELD3(FieldTypeDword, DomainInfo, cbDomainNameLength)
    FIELD3(FieldTypePStr, DomainInfo, szDomainName)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgRefFields)
    FIELD3(FieldTypeClassSignature, CMsgRef, m_dwSignature)
    FIELD3(FieldTypeDword, CMsgRef, m_lReferences)
    FIELD3(FieldTypePointer, CMsgRef, m_paqinst)
    FIELD3(FieldTypePointer, CMsgRef, m_pIMailMsgProperties)
    FIELD4(FieldTypeDWordBitMask, CMsgRef, m_dwDataFlags, GET_BIT_MASK_DESCRIPTOR(MsgRefBitMask))
    FIELD3(FieldTypeDword, CMsgRef, m_cbMsgSize)
    FIELD3(FieldTypeDword, CMsgRef, m_cDomains)
    FIELD3(FieldTypeDword, CMsgRef, m_cTimesRetried)
    FIELD3(FieldTypeStruct, CMsgRef, m_rgpdmqDomains)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftQueueEntry)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftLocalExpireDelay)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftLocalExpireNDR)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftRemoteExpireDelay)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftRemoteExpireNDR)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgAckFields)
    FIELD3(FieldTypePointer, MessageAck, pIMailMsgProperties)
    FIELD3(FieldTypePointer, MessageAck, pvMsgContext)
    FIELD4(FieldTypeDWordBitMask, MessageAck, dwMsgStatus, GET_BIT_MASK_DESCRIPTOR(MsgAckBitMask))
    FIELD3(FieldTypeDword, MessageAck, cbExtendedStatus)
    FIELD3(FieldTypePStr, MessageAck, szExtendedStatus)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DeliveryContextFields)
    FIELD3(FieldTypeClassSignature, CDeliveryContext, m_dwSignature)
    FIELD3(FieldTypePointer, CDeliveryContext, m_pmsgref)
    FIELD3(FieldTypePointer, CDeliveryContext, m_pmbmap)
    FIELD3(FieldTypeDword, CDeliveryContext, m_cRecips)
    FIELD3(FieldTypePointer, CDeliveryContext, m_rgdwRecips)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainEntryFields)
    FIELD3(FieldTypeClassSignature, CDomainEntry, m_dwSignature)
    FIELD3(FieldTypeDword, CDomainEntry, m_lReferences)
    FIELD3(FieldTypePStr, CDomainEntry, m_szDomainName)
    FIELD3(FieldTypeStruct, CDomainEntry, m_dmap)
    FIELD3(FieldTypeDword, CDomainEntry, m_cQueues)
    FIELD3(FieldTypeDword, CDomainEntry, m_cLinks)
    FIELD3(FieldTypeListEntry, CDomainEntry, m_liDestQueues)
    FIELD3(FieldTypeListEntry, CDomainEntry, m_liLinks)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainNameTableEntryFields)
    FIELD3(FieldTypeClassSignature, DOMAIN_NAME_TABLE_ENTRY, dwEntrySig)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pParentEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pNextEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pPrevEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pFirstChildEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pSiblingEntry)
    FIELD3(FieldTypeULong, DOMAIN_NAME_TABLE_ENTRY, NoOfChildren)
    FIELD3(FieldTypeAnsiString, DOMAIN_NAME_TABLE_ENTRY, PathSegment)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pData)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pWildCardData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainConfigTableFields)
    FIELD3(FieldTypeClassSignature, CDomainConfigTable, m_dwSignature)
    FIELD3(FieldTypeDword, CDomainConfigTable, m_dwCurrentConfigVersion)
    FIELD3(FieldTypeStruct, CDomainConfigTable, m_dnt)
    FIELD3(FieldTypePointer, CDomainConfigTable, m_pDefaultDomainConfig)
    FIELD3(FieldTypeStruct, CDomainConfigTable, m_slPrivateData)
    FIELD4(FieldTypeDWordBitMask, CDomainConfigTable, m_dwFlags, GET_BIT_MASK_DESCRIPTOR(DCTFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(IntDomainInfoFields)
    FIELD3(FieldTypeClassSignature, CInternalDomainInfo, m_dwSignature)
    FIELD3(FieldTypeDword, CInternalDomainInfo, m_lReferences)
    FIELD3(FieldTypeDword, CInternalDomainInfo, m_dwVersion)
    FIELD4(FieldTypeDWordBitMask, CInternalDomainInfo, m_dwIntDomainInfoFlags, GET_BIT_MASK_DESCRIPTOR(InternalDomainInfoFlags))
    FIELD3(FieldTypeDword, CInternalDomainInfo, m_DomainInfo.cbVersion)
    FIELD3(FieldTypePStr, CInternalDomainInfo, m_DomainInfo.szDomainName)
    FIELD3(FieldTypePStr, CInternalDomainInfo, m_DomainInfo.szDropDirectory)
    FIELD3(FieldTypePStr, CInternalDomainInfo, m_DomainInfo.szSmartHostDomainName)
    FIELD4(FieldTypeDWordBitMask, CInternalDomainInfo, m_DomainInfo.dwDomainInfoFlags, GET_BIT_MASK_DESCRIPTOR(DomainInfoBitMask))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(SMTPConnFields)
    FIELD3(FieldTypeClassSignature, CSMTPConn, m_dwSignature)
    FIELD3(FieldTypeDword, CSMTPConn, m_lReferences)
    FIELD3(FieldTypePointer, CSMTPConn, m_plmq)
    FIELD3(FieldTypePointer, CSMTPConn, m_pConnMgr)
    FIELD3(FieldTypePointer, CSMTPConn, m_pIntDomainInfo)
    FIELD3(FieldTypeDword, CSMTPConn, m_cFailedMsgs)
    FIELD3(FieldTypeDword, CSMTPConn, m_cTriedMsgs)
    FIELD3(FieldTypeDword, CSMTPConn, m_cAcks)
    FIELD3(FieldTypeDWordBitMask, CSMTPConn, m_dwTickCountOfLastAck)
    FIELD3(FieldTypePStr, CSMTPConn, m_szDomainName)
    FIELD4(FieldTypeDWordBitMask, CSMTPConn, m_dwConnectionStatus, GET_BIT_MASK_DESCRIPTOR(ConnectionAckFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DestMsgQueueFields)
    FIELD3(FieldTypeClassSignature, CDestMsgQueue, m_dwSignature)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_lReferences)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_plmq)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_pvLinkContext)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_paqinst)
    FIELD3(FieldTypeListEntry, CDestMsgQueue, m_liDomainEntryDMQs)
    FIELD3(FieldTypeStruct, CDestMsgQueue, m_aqmt)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_cMessageTypeRefs)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_pIMessageRouter)
    FIELD3(FieldTypeListEntry, CDestMsgQueue, m_liEmptyDMQs)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_cRemovedFromEmptyList)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[0])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[1])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[2])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[3])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[4])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[5])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[6])
    FIELD3(FieldTypeStruct, CDestMsgQueue, m_fqRetryQueue)
    FIELD3(FieldTypeStruct, CDestMsgQueue, m_dmap)
    FIELD3(FieldTypeLocalizedFiletime, CDestMsgQueue, m_ftOldest)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_cCurrentThreadsEnqueuing)
    FIELD4(FieldTypeEmbeddedStruct, CDestMsgQueue, m_aqstats, EmbeddedAQStats)
    FIELD4(FieldTypeDWordBitMask, CDestMsgQueue, m_dwFlags,  GET_BIT_MASK_DESCRIPTOR(DMQBitmask))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(LinkMsgQueueFields)
    FIELD3(FieldTypeClassSignature, CLinkMsgQueue, m_dwSignature)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lReferences)
    FIELD4(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwLinkFlags, GET_BIT_MASK_DESCRIPTOR(LinkFlagsBitMask))
    FIELD3(FieldTypePointer, CLinkMsgQueue, m_paqinst)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_cQueues)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_qlstQueues)
    FIELD3(FieldTypePointer, CLinkMsgQueue, m_pdentryLink)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_cConnections)
    FIELD3(FieldTypePStr, CLinkMsgQueue, m_szSMTPDomain)
    FIELD3(FieldTypePStr, CLinkMsgQueue, m_szConnectorName)
    FIELD3(FieldTypePointer, CLinkMsgQueue, m_pIntDomainInfo)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lConnMgrCount)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lConsecutiveConnectionFailureCount)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lConsecutiveMessageFailureCount)
    FIELD3(FieldTypeDWordBitMask, CLinkMsgQueue, m_hrDiagnosticError)
    FIELD3(FieldTypeStrBuffer, CLinkMsgQueue, m_szDiagnosticVerb)
    FIELD3(FieldTypeStrBuffer, CLinkMsgQueue, m_szDiagnosticResponse)
    FIELD4(FieldTypeEmbeddedStruct, CLinkMsgQueue, m_aqstats, EmbeddedAQStats)
    FIELD4(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwLinkStateFlags, GET_BIT_MASK_DESCRIPTOR(LinkStateBitMask))
    FIELD3(FieldTypeLocalizedFiletime, CLinkMsgQueue, m_ftNextScheduledCallback)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_ftNextScheduledCallback)
    FIELD3(FieldTypeLocalizedFiletime, CLinkMsgQueue, m_ftNextRetry)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_ftNextRetry)
    FIELD3(FieldTypeLocalizedFiletime, CLinkMsgQueue, m_ftEmptyExpireTime)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_ftEmptyExpireTime)
    FIELD3(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwSupportedActions)
    FIELD3(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwLinkType)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(QuickListFields)
    FIELD3(FieldTypeClassSignature, CQuickList, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CQuickList, m_dwCurrentIndexStart)
    FIELD3(FieldTypePointer, CQuickList, m_liListPages.Flink)
    FIELD3(FieldTypePointer, CQuickList, m_liListPages.Blink)
    FIELD3(FieldTypeDWordBitMask, CQuickList, m_cItems)
    FIELD3(FieldTypeStruct, CQuickList, m_rgpvData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DSNBufferFields)
    FIELD3(FieldTypeClassSignature, CDSNBuffer, m_dwSignature)
    FIELD3(FieldTypeDword, CDSNBuffer, m_overlapped.Offset)
    FIELD3(FieldTypeDword, CDSNBuffer, m_overlapped.OffsetHigh)
    FIELD3(FieldTypePointer, CDSNBuffer, m_overlapped.hEvent)
    FIELD3(FieldTypeDword, CDSNBuffer, m_cbOffset)
    FIELD3(FieldTypeDword, CDSNBuffer, m_cbFileSize)
    FIELD3(FieldTypeDword, CDSNBuffer, m_cFileWrites)
    FIELD3(FieldTypePointer, CDSNBuffer, m_pDestFile)
    FIELD3(FieldTypeStruct, CDSNBuffer, m_pbFileBuffer)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(AQQuickTimeFields)
    FIELD3(FieldTypeClassSignature, CAQQuickTime, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CAQQuickTime, m_dwLastInternalTime)
    FIELD3(FieldTypeDWordBitMask, CAQQuickTime, m_ftSystemStart.dwHighDateTime)
    FIELD3(FieldTypeDWordBitMask, CAQQuickTime, m_ftSystemStart.dwLowDateTime)
    FIELD3(FieldTypeLocalizedFiletime, CAQQuickTime, m_ftSystemStart)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(AsyncQueueBaseFields)
    FIELD3(FieldTypeClassSignature, CAsyncQueueBase, m_dwSignature)
    FIELD3(FieldTypeClassSignature, CAsyncQueueBase, m_dwTemplateSignature)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cMaxSyncThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cMaxAsyncThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCurrentSyncThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCurrentAsyncThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cItemsPending)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cItemsPerATQThread)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cItemsPerSyncThread)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_lUnscheduledWorkItems)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCurrentCompletionThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cTotalAsyncCompletionThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cTotalSyncCompletionThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cTotalShortCircuitThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCompletionThreadsRequested)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cPendingAsyncCompletions)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cMaxPendingAsyncCompletions)
    FIELD3(FieldTypePointer, CAsyncQueueBase, m_pvContext)
    FIELD3(FieldTypePointer, CAsyncQueueBase, m_pAtqContext)
    FIELD3(FieldTypePointer, CAsyncQueueBase, m_hAtqHandle)
    FIELD4(FieldTypeDWordBitMask, CAsyncQueueBase, m_dwQueueFlags, GET_BIT_MASK_DESCRIPTOR(AsyncQueueFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CPoolFields)
    FIELD3(FieldTypeClassSignature, CPool, m_dwSignature)
    FIELD3(FieldTypeDword, CPool, m_cMaxInstances)
    FIELD3(FieldTypeDword, CPool, m_cInstanceSize)
    FIELD3(FieldTypeDword, CPool, m_cNumberCommitted)
    FIELD3(FieldTypeDword, CPool, m_cNumberInUse)
    FIELD3(FieldTypeDword, CPool, m_cNumberAvail)
    FIELD3(FieldTypeStruct, CPool, m_PoolCriticalSection)
    FIELD3(FieldTypePointer, CPool, m_pFreeList)
    FIELD3(FieldTypePointer, CPool, m_pExtraFreeLink)
    FIELD3(FieldTypeDword, CPool, m_cIncrementInstances)
    FIELD3(FieldTypeDword, CPool, m_cTotalAllocs)
    FIELD3(FieldTypeDword, CPool, m_cTotalFrees)
    FIELD3(FieldTypeDword, CPool, m_cTotalExtraAllocs)
    FIELD3(FieldTypePointer, CPool, m_pLastAlloc)
    FIELD3(FieldTypePointer, CPool, m_pLastExtraAlloc)
    FIELD3(FieldTypeDword, CPool, m_cFragmentInstances)
    FIELD3(FieldTypeDword, CPool, m_cMaxInstances)
    FIELD3(FieldTypeDword, CPool, m_cFragments)
    FIELD3(FieldTypeStruct, CPool, m_pFragments)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CShareLockNHFields)
    FIELD3(FieldTypeDword, CShareLockNH, m_lock.m_lock)
    FIELD3(FieldTypeStruct, CShareLockNH, m_lock.m_queue)
    FIELD3(FieldTypeDword, CShareLockNH, m_cReadLock)
    FIELD3(FieldTypeDword, CShareLockNH, m_cOutReaders)
    FIELD3(FieldTypeDword, CShareLockNH, m_cOutAcquiringReaders)
    FIELD3(FieldTypeDword, CShareLockNH, m_cExclusiveRefs)
    FIELD3(FieldTypePointer, CShareLockNH, m_hWaitingReaders)
    FIELD3(FieldTypePointer, CShareLockNH, m_hWaitingWriters)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgEnumFilterFields)
    FIELD3(FieldTypeDword, MESSAGE_ENUM_FILTER, dwVersion)
    FIELD3(FieldTypeDword, MESSAGE_ENUM_FILTER, cMessages)
    FIELD3(FieldTypeDword, MESSAGE_ENUM_FILTER, cbSize)
    FIELD3(FieldTypeStruct, MESSAGE_ENUM_FILTER, stDate)
    FIELD4(FieldTypeDWordBitMask, MESSAGE_ENUM_FILTER, mefType, GET_BIT_MASK_DESCRIPTOR(MsgEnumFilterFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgFilterFields)
    FIELD3(FieldTypeDword, MESSAGE_FILTER, dwVersion)
    FIELD3(FieldTypeDword, MESSAGE_FILTER, dwLargerThanSize)
    FIELD3(FieldTypePStr, MESSAGE_FILTER, szMessageId)
    FIELD3(FieldTypePStr, MESSAGE_FILTER, szMessageSender)
    FIELD3(FieldTypePStr, MESSAGE_FILTER, szMessageRecipient)
    FIELD3(FieldTypeStruct, MESSAGE_FILTER, stOlderThan)
    FIELD4(FieldTypeDWordBitMask, MESSAGE_FILTER, fFlags, GET_BIT_MASK_DESCRIPTOR(MsgFilterFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(InternalMsgFilterFields)
    FIELD3(FieldTypeClassSignature, CAQAdminMessageFilter, m_dwSignature)
    FIELD3(FieldTypeDword, CAQAdminMessageFilter, m_cMessagesToFind)
    FIELD3(FieldTypeDword, CAQAdminMessageFilter, m_cMessagesFound)
    FIELD3(FieldTypeDword, CAQAdminMessageFilter, m_dwThresholdSize)
    FIELD3(FieldTypePStr, CAQAdminMessageFilter, m_szMessageId)
    FIELD3(FieldTypePStr, CAQAdminMessageFilter, m_szMessageSender)
    FIELD3(FieldTypePStr, CAQAdminMessageFilter, m_szMessageRecipient)
    FIELD3(FieldTypeLocalizedFiletime, CAQAdminMessageFilter, m_ftThresholdTime)
    FIELD3(FieldTypePointer, CAQAdminMessageFilter, m_rgMsgInfo)
    FIELD3(FieldTypePointer, CAQAdminMessageFilter, m_pCurrentMsgInfo)
    FIELD4(FieldTypeDWordBitMask, CAQAdminMessageFilter, m_dwFilterFlags, GET_BIT_MASK_DESCRIPTOR(InternalMsgFilterFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAQDeferredDeliveryQueueFields)
    FIELD3(FieldTypeClassSignature, CAQDeferredDeliveryQueue, m_dwSignature)
    FIELD3(FieldTypeListEntry, CAQDeferredDeliveryQueue, m_liQueueHead)
    FIELD3(FieldTypeStruct, CAQDeferredDeliveryQueue, m_slPrivateData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAQDeferredDeliveryQueueEntryFields)
    FIELD3(FieldTypeClassSignature, CAQDeferredDeliveryQueueEntry, m_dwSignature)
    FIELD3(FieldTypeListEntry, CAQDeferredDeliveryQueueEntry, m_liQueueEntry)
    FIELD3(FieldTypePointer, CAQDeferredDeliveryQueueEntry, m_pIMailMsgProperties)
    FIELD3(FieldTypeLocalizedFiletime, CAQDeferredDeliveryQueueEntry, m_ftDeferredDeilveryTime)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(LinkInfoFields)
    FIELD3(FieldTypeDword, LINK_INFO, dwVersion)
    FIELD3(FieldTypePStr, LINK_INFO, szLinkName)
    FIELD3(FieldTypeDword, LINK_INFO, cMessages)
    FIELD3(FieldTypeStruct, LINK_INFO, stOldestMessage)
    FIELD3(FieldTypeStruct, LINK_INFO, stNextScheduledConnection)
    //FIELD4(FieldTypeDWordBitMask, CAQAdminMessageFilter, fStateFlags, GET_BIT_MASK_DESCRIPTOR(LinkInfoFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAsyncWorkQueueItemFields)
    FIELD3(FieldTypeClassSignature, CAsyncWorkQueueItem, m_dwSignature)
    FIELD3(FieldTypeDword, CAsyncWorkQueueItem, m_lReferences)
    FIELD3(FieldTypePointer, CAsyncWorkQueueItem, m_pvData)
    FIELD3(FieldTypeSymbol, CAsyncWorkQueueItem, m_pfnCompletion)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAsyncWorkQueueFields)
    FIELD3(FieldTypeClassSignature, CAsyncWorkQueue, m_dwSignature)
    FIELD3(FieldTypeDword, CAsyncWorkQueue, m_cWorkQueueItems)
    FIELD3(FieldTypeStruct, CAsyncWorkQueue, m_asyncq)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CShareLockInstFields)
    FIELD3(FieldTypeClassSignature, CShareLockInst, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CShareLockInst, m_dwFlags)
    FIELD3(FieldTypeListEntry, CShareLockInst, m_liLocks)
    FIELD3(FieldTypeDword, CShareLockInst, m_cShareAttempts)
    FIELD3(FieldTypeDword, CShareLockInst, m_cShareAttemptsBlocked)
    FIELD3(FieldTypeDword, CShareLockInst, m_cExclusiveAttempts)
    FIELD3(FieldTypeDword, CShareLockInst, m_cExclusiveAttemptsBlocked)
    FIELD3(FieldTypePStr, CShareLockInst, m_szDescription)
    FIELD3(FieldTypeDWordBitMask, CShareLockInst, m_dwExclusiveThread)
    FIELD3(FieldTypePointer, CShareLockInst, m_rgtblkSharedThreadIDs)
    FIELD3(FieldTypeDword, CShareLockInst, m_cMaxTrackedSharedThreadIDs)
    FIELD3(FieldTypeDword, CShareLockInst, m_cCurrentSharedThreads)
    FIELD3(FieldTypeDword, CShareLockInst, m_cMaxConcurrentSharedThreads)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CSyncShutdownFields)
    FIELD3(FieldTypeClassSignature, CSyncShutdown, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CSyncShutdown, m_cReadLocks)
    FIELD3(FieldTypeStruct, CSyncShutdown, m_slShutdownLock)
END_FIELD_DESCRIPTOR

BEGIN_STRUCT_DESCRIPTOR
    {"PerfCounters", sizeof(CAQSvrInst), AQCounterInfoFields},
    {"ft", sizeof(FILETIME), CFileTimeFields},

    //CAQSvrInst used to be called CCatMsgQueue
    {"CCatMsgQueue", sizeof(CAQSvrInst), CMQFields},

    STRUCT(CAQSvrInst, CMQFields)
    STRUCT(CConnMgr, ConnMgrFields)
    STRUCT(CDomainMappingTable, DMTFields)
    STRUCT(CDomainEntry, DomainEntryFields)
    STRUCT(CDomainConfigTable, DomainConfigTableFields)
    STRUCT(CInternalDomainInfo, IntDomainInfoFields)
    STRUCT(DomainInfo, DomainInfoFields)
    STRUCT(CMsgRef, MsgRefFields)
    STRUCT(MessageAck, MsgAckFields)
    STRUCT(CDeliveryContext, DeliveryContextFields)
    STRUCT(CSMTPConn, SMTPConnFields)
    STRUCT(DOMAIN_NAME_TABLE_ENTRY, DomainNameTableEntryFields)
    STRUCT(CDestMsgQueue, DestMsgQueueFields)
    STRUCT(CLinkMsgQueue, LinkMsgQueueFields)
    STRUCT(CQuickList, QuickListFields)
    STRUCT(CDSNBuffer, DSNBufferFields)
    STRUCT(CAQQuickTime, AQQuickTimeFields)
    STRUCT(CAsyncQueueBase, AsyncQueueBaseFields)
    STRUCT(CPool, CPoolFields)
    STRUCT(CShareLockNH, CShareLockNHFields)
    STRUCT(CRefCountedString, RSTRFields)
    STRUCT(CAQMsgGuidList, MsgGuidListFields)
    STRUCT(CAQMsgGuidListEntry, MsgGuidListEntryFields)
    STRUCT(CSMTP_RETRY_HANDLER, RetrySinkFields)
    STRUCT(CRETRY_Q, RetryQueueFields)
    STRUCT(CRETRY_HASH_ENTRY, RetryHashFields)
    STRUCT(CAQStats, AQStatsFields)
    STRUCT(CAQAdminMessageFilter, InternalMsgFilterFields)
    STRUCT(MESSAGE_FILTER, MsgFilterFields)
    STRUCT(MESSAGE_ENUM_FILTER, MsgEnumFilterFields)
    STRUCT(LINK_INFO, LinkInfoFields)
    STRUCT(CAQDeferredDeliveryQueue, CAQDeferredDeliveryQueueFields)
    STRUCT(CAQDeferredDeliveryQueueEntry, CAQDeferredDeliveryQueueEntryFields)
    STRUCT(CAsyncWorkQueueItem, CAsyncWorkQueueItemFields)
    STRUCT(CAsyncWorkQueue, CAsyncWorkQueueFields)
    STRUCT(CShareLockInst, CShareLockInstFields)
    STRUCT(CSyncShutdown, CSyncShutdownFields)
END_STRUCT_DESCRIPTOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\fifoqdbg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: fifqdbg.cpp
//
//  Description:  Implementation for CFifoQueueDbgIterator class.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      9/13/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_
#include "aqincs.h"
#ifdef PLATINUM
#include "ptrwinst.h"
#else //PLATINUM
#include "rwinst.h"
#endif //PLATINUM
#include <fifoqdbg.h>
#include <fifoqimp.h>
#include <smtpconn.h>

#define MIN(x, y) ((x) > (y) ? (y) : (x))

//---[ GetQueueType ]----------------------------------------------------------
//
//
//  Description:
//      Determines the queue type for a given ptr
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//      AQ_QUEUE_TYPE_UNKNOWN     Queue type cannot be determined
//      AQ_QUEUE_TYPE_FIFOQ       Queue is a CFifoQ
//      AQ_QUEUE_TYPE_DMQ         Queue is a CDestMsgQueue
//      AQ_QUEUE_TYPE_LMQ         Queue is a CLinkMsgQueue
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_QUEUE_TYPE GetQueueType(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    BYTE    pbQueueBuffer[100];

    ZeroMemory(pbQueueBuffer, sizeof(pbQueueBuffer));

    if (!ReadProcessMemory(hCurrentProcess, pvAddressOtherProc, pbQueueBuffer,
         sizeof(pbQueueBuffer), NULL))
        return AQ_QUEUE_TYPE_UNKNOWN;

    if (FIFOQ_SIG == ((CFifoQueue<PVOID *> *)pbQueueBuffer)->m_dwSignature)
        return AQ_QUEUE_TYPE_FIFOQ;

    if (DESTMSGQ_SIG == ((CDestMsgQueue *)pbQueueBuffer)->m_dwSignature)
        return AQ_QUEUE_TYPE_DMQ;

    if (LINK_MSGQ_SIG == ((CLinkMsgQueue *)pbQueueBuffer)->m_dwSignature)
        return AQ_QUEUE_TYPE_LMQ;

    return AQ_QUEUE_TYPE_UNKNOWN;
}



#define pvGetNextPage(pvCurrent) ((PVOID) ((CFifoQueuePage<PVOID> *)pvCurrent)->m_pfqpNext)

CFifoQueueDbgIterator::CFifoQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    m_iCurrentPage = 0;
    m_iCurrentIndexInPage = 0;
    m_cPagesLoaded = 0;
    m_iHeadIndex = 0;
    m_iTailIndex = 0;
    pExtensionApis  = pApis;
    ZeroMemory(m_pbQueueBuffer, sizeof(m_pbQueueBuffer));
};

CFifoQueueDbgIterator::~CFifoQueueDbgIterator()
{
    PVOID pvCurrent = NULL;
    PVOID pvNext = NULL;

    pvCurrent = ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead;
    while (pvCurrent)
    {
        pvNext = pvGetNextPage(pvCurrent);
        free(pvCurrent);
        pvCurrent = pvNext;
    }
}

BOOL CFifoQueueDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    DWORD cbBytes = 0;
    PVOID pvPageOtherProc = NULL;
    PVOID pvPageThisProc = NULL;
    PVOID pvPreviousPageThisProc = NULL;

    //Read the entire queue structure in memory
    if (!ReadProcessMemory(hCurrentProcess, pvAddressOtherProc, m_pbQueueBuffer,
            sizeof(m_pbQueueBuffer), NULL))
        return FALSE;

    //Iterate over the previous pointers from the head page
    pvPageOtherProc = ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead;

    ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead = NULL;
    while (pvPageOtherProc)
    {
        pvPageThisProc = malloc(sizeof(CFifoQueuePage<PVOID>));
        if (!pvPageThisProc)
            return FALSE;

        if (pvPreviousPageThisProc)
        {
            ((CFifoQueuePage<PVOID> *)pvPreviousPageThisProc)->m_pfqpNext =
                (CFifoQueuePage<PVOID> *) pvPageThisProc;
        }
        else
        {
            ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead =
                (CFifoQueuePage<PVOID> *) pvPageThisProc;
        }


        if (!ReadProcessMemory(hCurrentProcess, pvPageOtherProc,
                pvPageThisProc, sizeof(CFifoQueuePage<PVOID>), NULL))
        {
            if (pvPreviousPageThisProc)
                ((CFifoQueuePage<PVOID> *)pvPreviousPageThisProc)->m_pfqpNext = NULL;
            else
                ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead = NULL;

            free(pvPageThisProc);
            return FALSE;
        }

        if (!pvPreviousPageThisProc)
        {
            //This is the head page. save index
            m_iHeadIndex = (DWORD) ((DWORD_PTR)
                    (((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_ppqdataHead -
                    ((CFifoQueuePage<PVOID> *)pvPageOtherProc)->m_rgpqdata));

            m_iCurrentIndexInPage = m_iHeadIndex;
        }

        //save tail index... in case this is the last page
        m_iTailIndex = (DWORD) ((DWORD_PTR)
                (((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_ppqdataTail -
                ((CFifoQueuePage<PVOID> *)pvPageOtherProc)->m_rgpqdata));

        pvPreviousPageThisProc = pvPageThisProc;

        pvPageOtherProc = pvGetNextPage(pvPageThisProc);
        ((CFifoQueuePage<PVOID> *)pvPreviousPageThisProc)->m_pfqpNext = NULL;
        m_cPagesLoaded++;
    }

    return TRUE;
}

DWORD CFifoQueueDbgIterator::cGetCount()
{
    return ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_cQueueEntries;
}

PVOID CFifoQueueDbgIterator::pvGetNext()
{
    PVOID pvCurrentPage = ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead;
    PVOID pvData = NULL;
    DWORD i = 0;

    if (!pvCurrentPage)
        return NULL;

    //Loop over empty entries (left by DSN generation) or until
    //we reach the end of the queue
    do
    {
        //Figure out if we are on a page boundary
        if (FIFOQ_QUEUE_PAGE_SIZE == m_iCurrentIndexInPage)
        {
            m_iCurrentIndexInPage = 0;
            m_iCurrentPage++;
        }

        //Get current page
        for (i = 0; i < m_iCurrentPage; i++)
        {
            pvCurrentPage = pvGetNextPage(pvCurrentPage);
            if (!pvCurrentPage)
                return NULL;
        }

        if (!((CFifoQueuePage<PVOID> *)pvCurrentPage)->m_rgpqdata)
            return NULL;

        //Get data from current page
        pvData = ((CFifoQueuePage<PVOID> *)pvCurrentPage)->m_rgpqdata[m_iCurrentIndexInPage];

        if ((m_iCurrentIndexInPage > m_iTailIndex) && !pvGetNextPage(pvCurrentPage))
        {
            //We at the end of data
            return NULL;
        }
        m_iCurrentIndexInPage++;
    } while (!pvData);

    return pvData;
}


//---[ CDMQDbgIterator ]-------------------------------------------------------
//
//
//  Description:
//      Constructor for CDMQDbgIterator
//  Parameters:
//      pApis       A ptr to the PWINDBG_EXTENSION_APIS struct passed in by
//                  the debugger.
//  Returns:
//      -
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDMQDbgIterator::CDMQDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    ZeroMemory(m_pbDMQBuffer, sizeof(m_pbDMQBuffer));
    ZeroMemory(m_pvFifoQOtherProc, sizeof(m_pvFifoQOtherProc));
    ZeroMemory(m_szName, sizeof(m_szName));
    m_pdmq = (CDestMsgQueue *)m_pbDMQBuffer;
    m_iCurrentFifoQ = 0;
    m_cCount = 0;
    pExtensionApis = pApis;
    m_cItemsReturnedThisQueue = 0;
}

//---[ CDMQDbgIterator::fInit ]------------------------------------------------
//
//
//  Description:
//      Initializes the iterator (and the iterators for all its queues
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//      TRUE on success
//      FALSE otherwise
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CDMQDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    DWORD   i = 0;
    PVOID   pvQueue = NULL;
    BOOL    fVerbose = TRUE && pExtensionApis;
    BYTE    pbDomainEntry[sizeof(CDomainEntry)];
    CDomainEntry *pdentry = (CDomainEntry *)pbDomainEntry;

    if (!ReadProcessMemory(hCurrentProcess, pvAddressOtherProc, m_pbDMQBuffer,
         sizeof(m_pbDMQBuffer), NULL))
    {
        if (fVerbose) dprintf("ReadProcessMemory failex 0x%X\n", GetLastError());
        return FALSE;
    }

    if (DESTMSGQ_SIG != m_pdmq->m_dwSignature)
    {
        if (fVerbose) dprintf("Bad signature\n");
        return FALSE;
    }

    //Get domain if possible
    if (ReadProcessMemory(hCurrentProcess, m_pdmq->m_dmap.m_pdentryDomainID,
        pbDomainEntry, sizeof(pbDomainEntry), NULL))
    {

        ReadProcessMemory(hCurrentProcess, pdentry->m_szDomainName, m_szName,
            MIN((sizeof(m_szName)-1), (pdentry->m_cbDomainName+1)), NULL);
    }

    for (i = 0; i < NUM_PRIORITIES; i++)
    {
        m_rgfifoqdbg[i].SetApis(pExtensionApis);
        pvQueue = m_pdmq->m_rgpfqQueues[i];
        m_pvFifoQOtherProc[i] = pvQueue;

        if (pvQueue)
        {
            if (!m_rgfifoqdbg[i].fInit(hCurrentProcess, pvQueue))
            {
                if (fVerbose) dprintf("Cannot init queue %d at 0x%X\n", i, pvQueue);
                return FALSE;
            }
            m_cCount += m_rgfifoqdbg[i].cGetCount();
        }
    }

    //Init retry queue
    m_rgfifoqdbg[NUM_PRIORITIES].SetApis(pExtensionApis);
    pvQueue = (((PBYTE)pvAddressOtherProc) + FIELD_OFFSET(CDestMsgQueue, m_fqRetryQueue));
    m_pvFifoQOtherProc[NUM_PRIORITIES] = pvQueue;

    if (pvQueue)
    {
        if (!m_rgfifoqdbg[NUM_PRIORITIES].fInit(hCurrentProcess, pvQueue))
        {
            if (fVerbose) dprintf("Cannon init retry queue at 0x%X\n", pvQueue);
            return FALSE;
        }

        m_cCount += m_rgfifoqdbg[NUM_PRIORITIES].cGetCount();
    }

    return TRUE;
}

//---[ CDMQDbgIterator::pvGetNext ]--------------------------------------------
//
//
//  Description:
//      Gets the next item from the DMQ
//  Parameters:
//      -
//  Returns:
//      An ptr to the item in the debuggee process on success
//      NULL when there are no more items
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDMQDbgIterator::pvGetNext()
{
    PVOID pvItem = NULL;

    while (m_iCurrentFifoQ <= NUM_PRIORITIES)
    {
        if (m_pvFifoQOtherProc[m_iCurrentFifoQ])
        {
            if (m_rgfifoqdbg[m_iCurrentFifoQ].cGetCount())
            {
                pvItem = m_rgfifoqdbg[m_iCurrentFifoQ].pvGetNext();

                //If we found an item we are done
                if (pvItem)
                {
                    //If it is the first item annouce this queue
                    if (!m_cItemsReturnedThisQueue && pExtensionApis)
                    {
                        dprintf("Dumping FifoQueue at address 0x%08X:\n",
                                m_pvFifoQOtherProc[m_iCurrentFifoQ]);
                    }

                    m_cItemsReturnedThisQueue++;
                    break;
                }
            }
        }
        m_iCurrentFifoQ++;
        m_cItemsReturnedThisQueue = 0;
    }

    return pvItem;
}


//---[ CQueueDbgIterator ]-----------------------------------------------------
//
//
//  Description:
//      Constructor for CQueueDbgIterator
//  Parameters:
//      pApis       A ptr to the PWINDBG_EXTENSION_APIS struct passed in by
//                  the debugger.
//  Returns:
//      -
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQueueDbgIterator::CQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    pExtensionApis = pApis;
    m_pqdbgi = NULL;
    m_QueueType = AQ_QUEUE_TYPE_UNKNOWN;
}

//---[ CQueueDbgIterator::fInit ]----------------------------------------------
//
//
//  Description:
//      Initialized generic queue iterator.  Will determine the type
//      of queue and initialize the correct type-specific iterator.
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//      TRUE on success
//      FALSE otherwise
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CQueueDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    LPSTR   szQueueType = "unknown";
    m_QueueType = GetQueueType(hCurrentProcess, pvAddressOtherProc);

    switch (m_QueueType)
    {
      case AQ_QUEUE_TYPE_DMQ:
        m_pqdbgi = (IQueueDbgIterator *) &m_dmqdbg;
        szQueueType = "DMQ";
        break;
      case AQ_QUEUE_TYPE_FIFOQ:
        m_pqdbgi = (IQueueDbgIterator *) &m_fifoqdbg;
        szQueueType = "CFifoQueue";
        break;
      case AQ_QUEUE_TYPE_LMQ:
        m_pqdbgi = (IQueueDbgIterator *) &m_lmqdbg;
        szQueueType = "LMQ";
        break;
      default:
        return FALSE;
    }

    if (!m_pqdbgi)
        return FALSE;

    m_pqdbgi->SetApis(pExtensionApis);
    if (!m_pqdbgi->fInit(hCurrentProcess, pvAddressOtherProc))
        return FALSE;

    if (pExtensionApis)
    {
        dprintf("Dumping %s (%s) at address 0x%08X:\n",
            szQueueType, m_pqdbgi->szGetName(), pvAddressOtherProc);
    }

    return TRUE;
}

//---[ CQueueDbgIterator::cGetCount ]------------------------------------------
//
//
//  Description:
//      Returns count of items in queue
//  Parameters:
//      -
//  Returns:
//      count of items in queue
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CQueueDbgIterator::cGetCount()
{
    if (!m_pqdbgi)
        return 0;
    else
        return m_pqdbgi->cGetCount();
}

//---[ CQueueDbgIterator::pvGetNext ]------------------------------------------
//
//
//  Description:
//      Returns the next item pointed to by the iterator
//  Parameters:
//      -
//  Returns:
//      Pointer to next item in debugee process on success
//      NULL if no more items or failure
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CQueueDbgIterator::pvGetNext()
{
    if (!m_pqdbgi)
        return NULL;
    else
        return m_pqdbgi->pvGetNext();
}

//---[ CQueueDbgIterator::szGetName ]------------------------------------------
//
//
//  Description:
//      Returns the name of the iterator
//  Parameters:
//      -
//  Returns:
//      Pointer to string for iterator
//      NULL if no name
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
LPSTR CQueueDbgIterator::szGetName()
{
    if (!m_pqdbgi)
        return NULL;
    else
        return m_pqdbgi->szGetName();
}

//---[ CLMQDbgIterator::CLMQDbgIterator ]--------------------------------------
//
//
//  Description:
//
//  Parameters:
//
//  Returns:
//
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLMQDbgIterator::CLMQDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    ZeroMemory(m_pbLMQBuffer, sizeof(m_pbLMQBuffer));
    ZeroMemory(m_rgpvDMQOtherProc, sizeof(m_rgpvDMQOtherProc));
    ZeroMemory(m_szName, sizeof(m_szName));
    ZeroMemory(m_rgpvItemsPendingDelivery, sizeof(m_rgpvItemsPendingDelivery));
    ZeroMemory(m_rgpvConnectionsOtherProc, sizeof(m_rgpvConnectionsOtherProc));
    m_plmq = (CLinkMsgQueue *)m_pbLMQBuffer;
    m_iCurrentDMQ = 0;
    m_cCount = 0;
    m_cItemsThisDMQ = 0;
    m_cPending = 0;
    pExtensionApis = pApis;
}

//---[ CLMQDbgIterator::fInit ]------------------------------------------------
//
//
//  Description:
//      Initializes iterator for CLinkMsgQueue
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLMQDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    DWORD   i = 0;
    PLIST_ENTRY pliCurrent = NULL;
    PLIST_ENTRY pliHead = NULL;
    BYTE    pbConnection[sizeof(CSMTPConn)];
    CSMTPConn *pConn = (CSMTPConn *)pbConnection;
    PVOID   pvPending = NULL;
    PVOID   pvConnOtherProc = NULL;
    BOOL    fVerbose = TRUE && pExtensionApis;

    if (!ReadProcessMemory(hCurrentProcess, pvAddressOtherProc, m_pbLMQBuffer,
         sizeof(m_pbLMQBuffer), NULL))
    {
        if (fVerbose) dprintf("ReadProcessMemory failex 0x%X\n", GetLastError());
        return FALSE;
    }

    if (LINK_MSGQ_SIG != m_plmq->m_dwSignature)
    {
        if (fVerbose) dprintf("Signature does not match\n");
        return FALSE;
    }

    //Read in address of all the queues for this link
    //$$TODO - Support more than 1 quick list
    memcpy(m_rgpvDMQOtherProc, m_plmq->m_qlstQueues.m_rgpvData,
           sizeof(m_rgpvDMQOtherProc));

    //Read in name of link
    ReadProcessMemory(hCurrentProcess, m_plmq->m_szSMTPDomain, m_szName,
        MIN((sizeof(m_szName)-1), (m_plmq->m_cbSMTPDomain+1)), NULL);

    for (i = 0; i < MAX_QUEUES_PER_LMQ; i++)
    {
        if (m_rgpvDMQOtherProc[i])
        {
            m_rgdmqdbg[i].SetApis(pExtensionApis);
            if (!m_rgdmqdbg[i].fInit(hCurrentProcess, m_rgpvDMQOtherProc[i]))
            {
                if (fVerbose)
                    dprintf("Unable to init DMQ at 0x%X\n", m_rgpvDMQOtherProc[i]);
                return FALSE;
            }
            m_cCount += m_rgdmqdbg[i].cGetCount();
        }
    }

    //Get the messages pending on a connection

    pliCurrent = m_plmq->m_liConnections.Flink;

    //Loop through connections and save those with pending messages.
    while (pliHead != pliCurrent)
    {
        pvConnOtherProc = ((PBYTE) pliCurrent)-FIELD_OFFSET(CSMTPConn, m_liConnections);
        if (!ReadProcessMemory(hCurrentProcess, pvConnOtherProc, pbConnection,
            sizeof(pbConnection), NULL))
        {
            break;
        }
        pliCurrent = pConn->m_liConnections.Flink;
        if (!pliHead)
            pliHead = pConn->m_liConnections.Blink;

        pvPending = pConn->m_dcntxtCurrentDeliveryContext.m_pmsgref;
        if (pvPending)
        {
            m_rgpvConnectionsOtherProc[m_cPending] = pvConnOtherProc;
            m_rgpvItemsPendingDelivery[m_cPending] = pvPending;
            m_cPending++;
            m_cCount++;
        }
        if (m_cPending >= MAX_CONNECTIONS_PER_LMQ)
            break;
    }
    return TRUE;
}

//---[ CLMQDbgIterator::pvGetNext ]--------------------------------------------
//
//
//  Description:
//      Gets the next item in the current DMQ.  Moves to next DMQ when that
//      is emtpy
//  Parameters:
//      -
//  Returns:
//      Next item on success
//      NULL when empty or failure
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CLMQDbgIterator::pvGetNext()
{
    PVOID   pvItem = NULL;

    while (m_iCurrentDMQ < MAX_QUEUES_PER_LMQ)
    {
        if (m_rgpvDMQOtherProc[m_iCurrentDMQ])
        {
            if (!m_cItemsThisDMQ && m_rgdmqdbg[m_iCurrentDMQ].cGetCount())
            {
               if (pExtensionApis)
               {
                   dprintf("Dumping DMQ (%s) at address 0x%08X:\n",
                            m_rgdmqdbg[m_iCurrentDMQ].szGetName(),
                            m_rgpvDMQOtherProc[m_iCurrentDMQ]);
               }
            }
            pvItem = m_rgdmqdbg[m_iCurrentDMQ].pvGetNext();
            if (pvItem)
            {
                //Check if this is the first item for this DMQ
                m_cItemsThisDMQ++;
                break;
            }
        }
        m_iCurrentDMQ++;
        m_cItemsThisDMQ = 0;
    }

    //If the queues are empty, dump the connections
    if (!pvItem && m_cPending)
    {
        m_cPending--;
        if (pExtensionApis)
        {
            dprintf("Dumping Connection at address 0x%08X:\n",
                        m_rgpvConnectionsOtherProc[m_cPending]);
        }
        pvItem = m_rgpvItemsPendingDelivery[m_cPending];
    }
    return pvItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**


$(O)\intrnlqa.h $(O)\intrnlqa_i.c : $(STAXAQUEUE)\advqueue\intrnlqa.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\intrnlqa_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\intrnlqa_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
    
$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc + /a $(STAXINC)\export\caterr.mc + /a ..\..\server\smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00002.bin: ..\..\server\smtpmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a ..\..\server\smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catdefs.h ===
//+---------------------------------------------------------------
//
//  File:   Catdefs.h
//
//  Synopsis:   Includes common definitions and datatypes for categorizer code
//
//  Copyright (C) 1998 Microsoft Corporation
//          All rights reserved.
//
//  History: // jstamerj 980305 14:32:17: Created
//
//----------------------------------------------------------------



#ifndef  __CATDEFS_H__
#define  __CATDEFS_H__

#include <iiscnfg.h>
#include "mailmsg.h"

#define CAT_MAX_DOMAIN   (250)
#define CAT_MAX_LOGIN    (64)
#define CAT_MAX_PASSWORD CAT_MAX_LOGIN
#define CAT_MAX_INTERNAL_FULL_EMAIL  (CAT_MAX_LOGIN + CAT_MAX_DOMAIN + 1 + 1)
#define CAT_MAX_CONFIG   (512)
#define CAT_MAX_LDAP_DN  (CAT_MAX_INTERNAL_FULL_EMAIL)
#define CAT_MAX_REGVALUE_SIZE (1024)

// jstamerj 980305 16:07:47: $$TODO check these values
#define CAT_MAX_ADDRESS_TYPE_STRING (64)

// jstamerj 980319 19:55:15: SMTP/X500/X400/Custom
#define CAT_MAX_ADDRESS_TYPES 4

#define MAX_SEARCH_FILTER_SIZE  (CAT_MAX_INTERNAL_FULL_EMAIL + sizeof("(mail=)"))


// jstamerj 980504 19:05:10: Define this to whatever IMsg is returning today.
#define CAT_IMSG_E_PROPNOTFOUND     MAILMSG_E_PROPNOTFOUND
#define CAT_IMSG_E_DUPLICATE        MAILMSG_E_DUPLICATE

// Metabase values
// Formerly MD_ROUTE_USER_NAME
#define CAT_MD_USERNAME             (SMTP_MD_ID_BEGIN_RESERVED+84)
// Formerly MD_ROUTE_PASSWORD
#define CAT_MD_PASSWORD             (SMTP_MD_ID_BEGIN_RESERVED+85)
// Formerly MD_SMTP_DS_HOST
#define CAT_MD_DOMAIN               (SMTP_MD_ID_BEGIN_RESERVED+91)

class CCatAddr;
class CCategorizer;
class CICategorizerListResolveIMP;

#endif //__CATDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catglobals.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catglobals.h
//
// Contents: Global varialbles and utility functions
//
// Functions: CatInitGlobals
//            CatDeinitGlobals
//
// History:
// jstamerj 1999/03/03 12:51:30: Created.
//
//-------------------------------------------------------------
#ifndef __CATGLOBALS_H__
#define __CATGLOBALS_H__

#include <windows.h>
#include <rwex.h>
#include <tran_evntlog.h>

//
// Global variables:
//
extern CExShareLock     g_InitShareLock;
extern DWORD            g_InitRefCount;
 
//
// Functions:
//
HRESULT CatInitGlobals();
VOID    CatDeinitGlobals();
 
//
// Store layer init/deinit functions
//
HRESULT CatStoreInitGlobals();
VOID    CatStoreDeinitGlobals();

    
#endif //__CATGLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catconfig.h ===
/************************************************************
 * FILE: catconfig.h
 * PURPOSE: Store categorization config options
 * HISTORY:
 *  // jstamerj 980211 15:55:01: Created
 ************************************************************/

#ifndef _CATCONFIG_H
#define _CATCONFIG_H

#include "aqueue.h"

#define CAT_AQ_CONFIG_INFO_CAT_FLAGS ( \
    AQ_CONFIG_INFO_MSGCAT_DOMAIN | \
    AQ_CONFIG_INFO_MSGCAT_USER | \
    AQ_CONFIG_INFO_MSGCAT_PASSWORD | \
    AQ_CONFIG_INFO_MSGCAT_BINDTYPE | \
    AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE | \
    AQ_CONFIG_INFO_MSGCAT_HOST | \
    AQ_CONFIG_INFO_MSGCAT_FLAGS | \
    AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT | \
    AQ_CONFIG_INFO_MSGCAT_TYPE | \
    AQ_CONFIG_INFO_DEFAULT_DOMAIN | \
    AQ_CONFIG_INFO_MSGCAT_PORT | \
    AQ_CONFIG_INFO_MSGCAT_ENABLE \
)
                                      

#define RP_ERROR_STRING_UNKNOWN_USER "The user does not exist."
#define RP_ERROR_STRING_UNKNOWN_USER_W L"The user does not exist."

#endif //_CATCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catdebug.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catdebug.h
//
// Contents: Data/definitions used only for debugging
//
// Classes: None
//
// Functions:
//
// History:
// jstamerj 1999/07/29 17:32:34: Created.
//
//-------------------------------------------------------------
#ifndef __CATDEBUG_H__
#define __CATDEBUG_H__

//
// This #define controls wether or not the debug list checking is enabled
// Currently, enable it in RTL and DBG builds
//
#define CATDEBUGLIST

//
// A handy macro for declaring classes that use the debug list
//
#define CatDebugClass(ClassName)     class ClassName : public CCatDLO<ClassName##_didx>


//
// An alternative to calling DbgBreakPoint (since DbgBreakPoint breaks
// DogFood into the kernel debugger)
//
VOID CatDebugBreakPoint();

//
// Debug data types
//
typedef struct _tagDebugObjectList {
    DWORD      dwCount;
    LIST_ENTRY listhead;
    SPIN_LOCK  spinlock;
} DEBUGOBJECTLIST, *PDEBUGOBJECTLIST;


//
// Enumeation of all the class types that use the debug list
//
typedef enum _tagDebugObjectId {

    CABContext_didx = 0,
    CSMTPCategorizer_didx,

    CCategorizer_didx,
    CCatSender_didx,
    CCatRecip_didx,
    CCatDLRecip_didx,
    CMembersInsertionRequest_didx,
    CSinkInsertionRequest_didx,
    CTopLevelInsertionRequest_didx,
    CICategorizerListResolveIMP_didx,
    CICategorizerDLListResolveIMP_didx,
    CICategorizerParametersIMP_didx,
    CICategorizerRequestedAttributesIMP_didx,
    //
    // asyncctx
    //
    CSearchRequestBlock_didx,
    CStoreListResolveContext_didx,
    //
    // cnfgmgr
    //
    CLdapCfgMgr_didx,
    CLdapCfg_didx,
    CLdapServerCfg_didx,
    //
    // icatasync
    //
    CICategorizerAsyncContextIMP_didx,
    //
    // icatitemattr
    //
    CLdapResultWrap_didx,
    CICategorizerItemAttributesIMP_didx,
    //
    // icatqueries
    //
    CICategorizerQueriesIMP_didx,
    //
    // ldapconn
    //
    CLdapConnection_didx,
    //
    // ldapstor
    //
    CMembershipPageInsertionRequest_didx,
    CEmailIDLdapStore_didx,
    //
    // pldapwrap
    //
    CPLDAPWrap_didx,

    //
    // The number of debug objects to support
    //
    NUM_DEBUG_LIST_OBJECTS

} DEBUGOBJECTID, *PDEBUGOBJECTID;

//
// Global array of lists
//
extern DEBUGOBJECTLIST g_rgDebugObjectList[NUM_DEBUG_LIST_OBJECTS];

//
// Debug Global init/deinit
//
VOID    CatInitDebugObjectList();
VOID    CatVrfyEmptyDebugObjectList();


//
// Class CCatDLO (Debug List Object): an object that adds and removes
// itself from a global list in its constructor/destructor (in debug
// builds) 
//
template <DEBUGOBJECTID didx> class CCatDLO
{
#ifdef CATDEBUGLIST

  public:
    CCatDLO()
    {
        _ASSERT(didx < NUM_DEBUG_LIST_OBJECTS);
        AcquireSpinLock(&(g_rgDebugObjectList[didx].spinlock));
        g_rgDebugObjectList[didx].dwCount++;
        InsertTailList(&(g_rgDebugObjectList[didx].listhead),
                       &m_le);
        ReleaseSpinLock(&(g_rgDebugObjectList[didx].spinlock));
    }
    virtual ~CCatDLO()
    {
        AcquireSpinLock(&(g_rgDebugObjectList[didx].spinlock));
        g_rgDebugObjectList[didx].dwCount--;
        RemoveEntryList(&m_le);
        ReleaseSpinLock(&(g_rgDebugObjectList[didx].spinlock));
    }        

  private:
    LIST_ENTRY m_le;
#endif // CATDEBUGLIST
};


#endif //__CATDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\cattype.h ===
#ifndef __CATTYPE_H__
#define __CATTYPE_H__

class CCategorizer;
class CBifurcationMgr;
class CABWrapper;
class CLDWrapper;
class CCatAddr;
class CICategorizerListResolveIMP;

#include <cat.h>
#include <winldap.h>
#include "cbifmgr.h"
#include "spinlock.h"

// Context used by CatMsg (top categorizer layer)
typedef struct _CATMSG_CONTEXT {
    CCategorizer *pCCat;
    LPVOID      pUserContext;
    PFNCAT_COMPLETION pfnCatCompletion;
#ifdef DEBUG
    LONG        lCompletionRoutineCalls;
#endif
} CATMSG_CONTEXT, *PCATMSG_CONTEXT;


// Context used by CatDLMsg
typedef struct _CATDLMSG_CONTEXT {
    CCategorizer *pCCat;
    LPVOID       pUserContext;
    PFNCAT_DLCOMPLETION pfnCatCompletion;
    BOOL         fMatch;
} CATDLMSG_CONTEXT, *PCATDLMSG_CONTEXT;
        

//
// RESOLVE_LIST_CONTEXT is a context associated with a list of names being
// resolved asynchronously. pUserContext points to a user provided context.
// pStoreContext is an opaque pointer used to hold async context needed by the
// underlying store (ie, FlatFile or LDAP store).
//
typedef struct {
    PVOID pUserContext;
    PVOID pStoreContext;
} RESOLVE_LIST_CONTEXT, *LPRESOLVE_LIST_CONTEXT;

#define CCAT_CONFIG_DEFAULT_VSID                   0
#define CCAT_CONFIG_DEFAULT_ENABLE                 0x00000000 //Disabled
#define CCAT_CONFIG_DEFAULT_FLAGS                  0xFFFFFFFF //Enable everything
#define CCAT_CONFIG_DEFAULT_ROUTINGTYPE            TEXT("Ldap")
#define CCAT_CONFIG_DEFAULT_BINDDOMAIN             TEXT("")
#define CCAT_CONFIG_DEFAULT_USER                   TEXT("")
#define CCAT_CONFIG_DEFAULT_PASSWORD               TEXT("")
#define CCAT_CONFIG_DEFAULT_BINDTYPE               TEXT("CurrentUser")
#define CCAT_CONFIG_DEFAULT_SCHEMATYPE             TEXT("NT5")
#define CCAT_CONFIG_DEFAULT_HOST                   TEXT("")
#define CCAT_CONFIG_DEFAULT_NAMINGCONTEXT          TEXT("")
#define CCAT_CONFIG_DEFAULT_DEFAULTDOMAIN          TEXT("")
#define CCAT_CONFIG_DEFAULT_PORT                   0


#endif //__CATTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\fifoqdbg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: fifoqdbg.h
//
//  Description:    Debugger extension for base AQ queue classes
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      9/13/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __FIFOQDBG_H__
#define __FIFOQDBG_H__

#include <aqdbgext.h>
#include <fifoq.h>
#include <destmsgq.h>
#include <linkmsgq.h>

enum AQ_QUEUE_TYPE {
    AQ_QUEUE_TYPE_UNKNOWN,
    AQ_QUEUE_TYPE_FIFOQ,
    AQ_QUEUE_TYPE_DMQ,
    AQ_QUEUE_TYPE_LMQ,
};

AQ_QUEUE_TYPE GetQueueType(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);

//---[ IQueueDbgIterator ]-----------------------------------------------------
//
//
//  Description:
//      Generic queue iterator for the debug extensions.  Users should
//      use CQueueDbgIterator directly
//  Hungarian:
//      qdbgi, pqdbgi
//
//-----------------------------------------------------------------------------
class IQueueDbgIterator
{
  public:
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc) = 0;
    virtual DWORD   cGetCount() = 0;
    virtual PVOID   pvGetNext() = 0;
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) = 0;
    virtual LPSTR   szGetName() = 0;
};

//---[ CFifoQueueDbgIterator ]-------------------------------------------------
//
//
//  Description:
//      Iterator class that will iterate over all the elements of a fifoq
//  Hungarian:
//      fifoqdbg, pfifoqdbg
//
//-----------------------------------------------------------------------------
class CFifoQueueDbgIterator :
    public IQueueDbgIterator
{
  protected:
    BYTE    m_pbQueueBuffer[sizeof(CFifoQueue<PVOID>)];
    DWORD   m_iCurrentPage;
    DWORD   m_iCurrentIndexInPage;
    DWORD   m_cPagesLoaded;
    DWORD   m_iHeadIndex;
    DWORD   m_iTailIndex;
    PWINDBG_EXTENSION_APIS pExtensionApis;
  public:
    CFifoQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis = NULL);
    ~CFifoQueueDbgIterator();
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount();
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName() {return NULL;};
};

//---[ CDMQDbgIterator ]-------------------------------------------------------
//
//
//  Description:
//      Iterartor class for DMQ... will dump every item on all its fifo queues
//  Hungarian:
//      dmqdbg, pdmqdbg
//
//-----------------------------------------------------------------------------
class CDMQDbgIterator :
    public IQueueDbgIterator
{
  protected:
    BYTE                    m_pbDMQBuffer[sizeof(CDestMsgQueue)];
    CDestMsgQueue          *m_pdmq;
    DWORD                   m_iCurrentFifoQ;
    DWORD                   m_cCount;
    DWORD                   m_cItemsReturnedThisQueue;
    PWINDBG_EXTENSION_APIS  pExtensionApis;
    PVOID                   m_pvFifoQOtherProc[NUM_PRIORITIES+1];
    CFifoQueueDbgIterator   m_rgfifoqdbg[NUM_PRIORITIES+1];
    CHAR                    m_szName[MAX_PATH];
  public:
    CDMQDbgIterator(PWINDBG_EXTENSION_APIS pApis = NULL);
    ~CDMQDbgIterator() {};
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount() {return m_cCount;};
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName() {return m_szName;};
};

//---[ CLMQDbgIterator ]-------------------------------------------------------
//
//
//  Description:
//      Debug iterator for CLinkMsgQueue
//  Hungarian:
//      lmqdbg, plmqdbg
//
//-----------------------------------------------------------------------------
const   DWORD   MAX_QUEUES_PER_LMQ  = QUICK_LIST_PAGE_SIZE;
const   DWORD   MAX_CONNECTIONS_PER_LMQ  = QUICK_LIST_PAGE_SIZE;
class CLMQDbgIterator :
  public IQueueDbgIterator
{
  protected:
    BYTE                    m_pbLMQBuffer[sizeof(CLinkMsgQueue)];
    CLinkMsgQueue          *m_plmq;
    DWORD                   m_iCurrentDMQ;
    PVOID                   m_rgpvDMQOtherProc[MAX_QUEUES_PER_LMQ];
    CDMQDbgIterator         m_rgdmqdbg[MAX_QUEUES_PER_LMQ];
    PVOID                   m_rgpvItemsPendingDelivery[MAX_CONNECTIONS_PER_LMQ];
    PVOID                   m_rgpvConnectionsOtherProc[MAX_CONNECTIONS_PER_LMQ];
    DWORD                   m_cPending;
    DWORD                   m_cCount;
    DWORD                   m_cItemsThisDMQ;
    PWINDBG_EXTENSION_APIS  pExtensionApis;
    CHAR                    m_szName[MAX_PATH];
  public:
    CLMQDbgIterator(PWINDBG_EXTENSION_APIS pApis = NULL);
    ~CLMQDbgIterator() {};
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount() {return m_cCount;};
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName() {return m_szName;};
};

//---[ CQueueDbgIterator ]-----------------------------------------------------
//
//
//  Description:
//      "Smart" iterator that will figure out what kind of queue it is being
//      called on, and will use the correct kind of iterator for it.
//  Hungarian:
//      qdbg, pqdbg
//
//-----------------------------------------------------------------------------
class CQueueDbgIterator :
    public  IQueueDbgIterator
{
  protected:
    AQ_QUEUE_TYPE           m_QueueType;
    IQueueDbgIterator      *m_pqdbgi;
    CFifoQueueDbgIterator   m_fifoqdbg;
    CDMQDbgIterator         m_dmqdbg;
    CLMQDbgIterator         m_lmqdbg;
    PWINDBG_EXTENSION_APIS  pExtensionApis;
  public:
    CQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis);
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount();
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName();
};

#endif //__FIFOQDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catperf.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catperf.h
//
// Contents: Categorizer perf counter block
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1999/02/23 17:55:10: Created.
//
//-------------------------------------------------------------
#ifndef __CATPERF_H__
#define __CATPERF_H__


//
// One global perf structure for the LDAP stuff
//
extern CATLDAPPERFBLOCK g_LDAPPerfBlock;


//
// Handy macros
//
#define INCREMENT_BLOCK_COUNTER_AMOUNT(PBlock, CounterName, Amount) \
    InterlockedExchangeAdd((PLONG) (& ((PBlock)->CounterName)), (Amount))

#define INCREMENT_BLOCK_COUNTER(PBlock, CounterName) \
    InterlockedIncrement((PLONG) (& ((PBlock)->CounterName)))

#define INCREMENT_COUNTER_AMOUNT(CounterName, Amount) \
    INCREMENT_BLOCK_COUNTER_AMOUNT(GetPerfBlock(), CounterName, Amount)

#define INCREMENT_COUNTER(CounterName) \
    INCREMENT_BLOCK_COUNTER(GetPerfBlock(), CounterName)

#define DECREMENT_BLOCK_COUNTER(PBlock, CounterName) \
    InterlockedDecrement((PLONG) (& ((PBlock)->CounterName)))
    
#define DECREMENT_COUNTER(CounterName) \
    DECREMENT_BLOCK_COUNTER(GetPerfBlock(), CounterName)

#define INCREMENT_LDAP_COUNTER(CounterName) \
    INCREMENT_BLOCK_COUNTER(&g_LDAPPerfBlock, CounterName)

#define DECREMENT_LDAP_COUNTER(CounterName) \
    DECREMENT_BLOCK_COUNTER(&g_LDAPPerfBlock, CounterName)


#endif //__CATPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatitem.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitem.h
//
// Contents: Implementation of ICategorizerItem
//
// Classes: CCategorizerItemIMP
//
// Functions:
//
// History:
// jstamerj 980515 12:46:36: Created.
//
//-------------------------------------------------------------
#ifndef __ICATITEM_H__
#define __ICATITEM_H__

#include <windows.h>
#include <dbgtrace.h>
#include <smtpevent.h>
#include "icatprops.h"
#include <baseobj.h>

#define CICATEGORIZERITEMIMP_SIGNATURE (DWORD)'ICIM'
#define CICATEGORIZERITEMIMP_SIGNATURE_FREE (DWORD)'XCIM'


class CICategorizerItemIMP : 
    public CICategorizerPropertiesIMP,
    public CBaseObject,
    public ICategorizerItem
{
  public:
    STDMETHOD (QueryInterface) (
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD_(ULONG, AddRef) ()
    { 
        return CBaseObject::AddRef();
    }
    STDMETHOD_(ULONG, Release) () 
    {
        return CBaseObject::Release();
    }

    //
    // We have multiple inheritence of GetStringA/etc happening -- the
    // pure virtual inheritence from ICategorizerItem and the
    // implemented inheritence from CICategorizerPropertiesIMP.  Solve
    // this problem by defining wrappers here
    //
  public:
    //ICategorizerItem
    STDMETHOD (GetStringA) (
        DWORD dwPropId, 
        DWORD cch, 
        LPSTR pszValue)
    {
        return CICategorizerPropertiesIMP::GetStringA(
            dwPropId,
            cch,
            pszValue);
    }

    STDMETHOD (PutStringA) (
        DWORD dwPropId,
        LPSTR pszValue)
    {
        return CICategorizerPropertiesIMP::PutStringA(
            dwPropId,
            pszValue);
    }

    STDMETHOD (GetDWORD) (
        DWORD dwPropId,
        DWORD *pdwValue)
    {
        return CICategorizerPropertiesIMP::GetDWORD(
            dwPropId,
            pdwValue);
    }

    STDMETHOD (PutDWORD) (
        DWORD dwPropId,
        DWORD dwValue)
    {
        return CICategorizerPropertiesIMP::PutDWORD(
            dwPropId,
            dwValue);
    }

    STDMETHOD (GetHRESULT) (
        DWORD dwPropId,
        HRESULT *phrValue)
    {
        return CICategorizerPropertiesIMP::GetHRESULT(
            dwPropId,
            phrValue);
    }

    STDMETHOD (PutHRESULT) (
        DWORD dwPropId,
        HRESULT hrValue)
    {
        return CICategorizerPropertiesIMP::PutHRESULT(
            dwPropId,
            hrValue);
    }

    STDMETHOD (GetBool) (
        DWORD dwPropId,
        BOOL  *pfValue)
    {
        return CICategorizerPropertiesIMP::GetBool(
            dwPropId,
            pfValue);
    }

    STDMETHOD (PutBool) (
        DWORD dwPropId,
        BOOL  fValue)
    {
        return CICategorizerPropertiesIMP::PutBool(
            dwPropId,
            fValue);
    }

    STDMETHOD (GetPVoid) (
        DWORD dwPropId,
        PVOID *ppv)
    {
        return CICategorizerPropertiesIMP::GetPVoid(
            dwPropId,
            ppv);
    }

    STDMETHOD (PutPVoid) (
        DWORD dwPropId,
        PVOID pvValue)
    {
        return CICategorizerPropertiesIMP::PutPVoid(
            dwPropId,
            pvValue);
    }

    STDMETHOD (GetIUnknown) (
        DWORD dwPropId,
        IUnknown **ppUnknown)
    {
        return CICategorizerPropertiesIMP::GetIUnknown(
            dwPropId,
            ppUnknown);
    }

    STDMETHOD (PutIUnknown) (
        DWORD dwPropId,
        IUnknown *pUnknown)
    {
        return CICategorizerPropertiesIMP::PutIUnknown(
            dwPropId,
            pUnknown);
    }

    STDMETHOD (GetIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties **ppIMailMsgProperties)
    {
        return CICategorizerPropertiesIMP::GetIMailMsgProperties(
            dwPropId,
            ppIMailMsgProperties);
    }

    STDMETHOD (PutIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties *ppIMailMsgProperties)
    {
        return CICategorizerPropertiesIMP::PutIMailMsgProperties(
            dwPropId,
            ppIMailMsgProperties);
    }

    STDMETHOD (GetIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd **ppIMsgRecipientsAdd)
    {
        return CICategorizerPropertiesIMP::GetIMailMsgRecipientsAdd(
            dwPropId,
            ppIMsgRecipientsAdd);
    }

    STDMETHOD (PutIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd *pIMsgRecipientsAdd)
    {
        return CICategorizerPropertiesIMP::PutIMailMsgRecipientsAdd(
            dwPropId,
            pIMsgRecipientsAdd);
    }

    STDMETHOD (GetICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes **ppICategorizerItemAttributes)
    {
        return CICategorizerPropertiesIMP::GetICategorizerItemAttributes(
            dwPropId,
            ppICategorizerItemAttributes);
    }

    STDMETHOD (PutICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes *pICategorizerItemAttributes)
    {
        return CICategorizerPropertiesIMP::PutICategorizerItemAttributes(
            dwPropId,
            pICategorizerItemAttributes);
    }

    STDMETHOD (GetICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve **ppICategorizerListResolve)
    {
        return CICategorizerPropertiesIMP::GetICategorizerListResolve(
            dwPropId,
            ppICategorizerListResolve);
    }

    STDMETHOD (PutICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve *pICategorizerListResolve)
    {
        return CICategorizerPropertiesIMP::PutICategorizerListResolve(
            dwPropId,
            pICategorizerListResolve);
    }

    STDMETHOD (GetICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs **ppICategorizerMailMsgs)
    {
        return CICategorizerPropertiesIMP::GetICategorizerMailMsgs(
            dwPropId,
            ppICategorizerMailMsgs);
    }

    STDMETHOD (PutICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs *pICategorizerMailMsgs)
    {
        return CICategorizerPropertiesIMP::PutICategorizerMailMsgs(
            dwPropId,
            pICategorizerMailMsgs);
    }
    
    STDMETHOD (GetICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem **ppICategorizerItem)
    {
        return CICategorizerPropertiesIMP::GetICategorizerItem(
            dwPropId,
            ppICategorizerItem);
    }
    
    STDMETHOD (PutICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem *pICategorizerItem)
    {
        return CICategorizerPropertiesIMP::PutICategorizerItem(
            dwPropId,
            pICategorizerItem);
    }

    STDMETHOD (UnSetPropId) (
        DWORD dwPropId)
    {
        return CICategorizerPropertiesIMP::UnSetPropId(
            dwPropId);
    }

  private:
    CICategorizerItemIMP();
    virtual ~CICategorizerItemIMP();

    DWORD m_dwSignature;

    friend class CCatAddr;
    friend class CIMsgRecipListAddr;
    friend class CICategorizerListResolveIMP;
    friend class CICategorizerDLListResolveIMP;
};

#endif //__ICATITEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccataddr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccataddr.h
//
// Contents: Definition of the CCatAddr class
//
// Classes: CCatAddr
//
// Functions:
//
// History:
// jstamerj 980324 19:08:13: Created.
//
//-------------------------------------------------------------

#ifndef __CCATADDR_H__
#define __CCATADDR_H__

#include <transmem.h>
#include <smtpinet.h>
#include "smtpevent.h"
#include "idstore.h"
#include "mailmsg.h"
#include "mailmsgprops.h"
#include "cbifmgr.h"
#include "cattype.h"
#include "spinlock.h"
#include "ccat.h"
#include "icatitem.h"
#include "icatlistresolve.h"

typedef VOID (*PFN_EXPANDITEMCOMPLETION)(PVOID pContext);

// CCatAddr: abstract base class
//   The basic idea is this object which will contain the address,
//   address type, properties on this address, and the completion
//   routine to call when all properties have been looked up.  It is
//   the object that will be created by CAddressBook and passed to the
//   store for resolution.
//
class CCatAddr : 
    public CICategorizerItemIMP
{
  public:
    typedef enum _ADDROBJTYPE {
        OBJT_UNKNOWN,
        OBJT_USER,
        OBJT_DL
    } ADDROBJTYPE, *PADDROBJTYPE;

    //
    // Flags describing the locality of the orig address
    //
    #define LOCF_UNKNOWN            0x0000 // We haven't checked the locality yet
    #define LOCF_LOCALMAILBOX       0x0001 // The orig address is a local mailbox domain
    #define LOCF_LOCALDROP          0x0002 // The orig address is a local drop domain
    #define LOCF_REMOTE             0x0004 // The orig address is not local
    #define LOCF_ALIAS              0x0008 // The orig address is a local alias domain
    #define LOCF_UNKNOWNTYPE        0x0010 // Unknown due to the address type

    //
    // Flags that indicate the address should generally be treated as local
    //
    #define LOCFS_LOCAL             (LOCF_LOCALMAILBOX | LOCF_LOCALDROP | \
                                     LOCF_UNKNOWNTYPE)

    CCatAddr(CICategorizerListResolveIMP *pCICatListResolveIMP);
    virtual ~CCatAddr();

    // Send our query to the store
    virtual HRESULT HrDispatchQuery();

    // Lookup routine called by the EmailIDStore
    virtual VOID LookupCompletion();

    // ProcessItem routines
    virtual HRESULT HrProcessItem();
    virtual HRESULT HrProcessItem_Default();

    // ExpandItem routines
    virtual HRESULT HrExpandItem();
    virtual HRESULT HrExpandItem_Default(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext) = 0;

    // CompleteItem routines
    virtual HRESULT HrCompleteItem();
    virtual HRESULT HrCompleteItem_Default() = 0;

    //
    // Storage and retreival procedures
    //
    virtual HRESULT HrGetOrigAddress(LPTSTR psz, DWORD dwcc, CAT_ADDRESS_TYPE *pType);
    virtual HRESULT GetSpecificOrigAddress(CAT_ADDRESS_TYPE CAType, LPTSTR psz, DWORD dwcc) = 0;
    virtual HRESULT HrGetLookupAddress(LPTSTR psz, DWORD dwcc, CAT_ADDRESS_TYPE *pType);
    virtual HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz) = 0;

    //
    // Property setting routines to be called before completion routine
    //
    virtual HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress) = 0;
    virtual HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress)   = 0;
    virtual HRESULT AddDynamicDLMember(
        ICategorizerItemAttributes *pICatItemAttr) = 0;

    //
    // We will not know that a particular CCatAddr is the first in a
    // loop until after ProcessItem/ExpandItem/CompleteItem have all
    // finished -- so this function may be called after everything
    // has happened to this CCatAddr
    //
    virtual HRESULT HandleLoopHead()
    {
        return E_NOTIMPL;
    }

    //
    // The default implementation of AddNewAddress will call this if
    // HrValidateAddress fails
    //
    virtual HRESULT HrHandleInvalidAddress()
    {
        return S_OK;
    }
    
    //
    // For store assisted DL expansion (paged or dynamic), it will
    // call this function to indicate a particular attribute should be
    // expanded in an ICatItemAttributes
    //
    virtual HRESULT HrExpandAttribute(
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttributeName,
        PDWORD pdwNumberMembers) 
    {
        return E_NOTIMPL;
    }
    //
    // Check and see if this object needs to be resolved or not (based
    // on DsUseCat flags)
    // Returns S_OK if the address should be resolved
    // Returns S_FALSE if the address should NOT be resolved
    //
    virtual HRESULT HrNeedsResolveing() = 0;
    //
    // Resolve this object if necessary (based on DsUseCat flags)
    //
    virtual HRESULT HrResolveIfNecessary();

    //
    // Build a query for this object
    //
    virtual HRESULT HrTriggerBuildQuery();

  protected:
    HRESULT HrValidateAddress(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);
    HRESULT HrGetAddressLocFlags(LPTSTR szAddress, 
                                CAT_ADDRESS_TYPE CAType, 
                                DWORD *pdwlocflags,
                                DWORD *pdwDomainOffset);
    DWORD   DwGetOrigAddressLocFlags();
    HRESULT HrIsOrigAddressLocal(BOOL *pfLocal);
    HRESULT HrIsOrigAddressLocalMailbox(BOOL *pfLocal);
    HRESULT HrGetSMTPDomainLocFlags(LPTSTR pszDomain, 
                                    DWORD *pdwlocflags);
    HRESULT HrGetSMTPDomainFlags(LPTSTR pszDomain, PDWORD pdwFlags);
    HRESULT HrSwitchToAliasedDomain(CAT_ADDRESS_TYPE CAType, 
                                    LPTSTR szSMTPAddress, 
                                    DWORD dwcch);
    LPTSTR  GetNewAddress(CAT_ADDRESS_TYPE CAType);

    HRESULT CheckAncestorsForDuplicate(
        CAT_ADDRESS_TYPE  CAType,
        LPTSTR            pszAddress,
        BOOL              fCheckSelf,
        CCatAddr          **ppCCatAddrDup);

    HRESULT CheckAncestorsForDuplicate(
        DWORD dwNumAddresses,
        CAT_ADDRESS_TYPE *rgCAType,
        LPTSTR *rgpsz,
        BOOL fCheckSelf,
        CCatAddr **ppCCatAddrDup);

    HRESULT CheckForDuplicateCCatAddr(
        DWORD dwNumAddresses,
        CAT_ADDRESS_TYPE *rgCAType,
        LPTSTR *rgpsz);

    HRESULT HrAddNewAddressesFromICatItemAttr();

    static HRESULT HrBuildQueryDefault(
        HRESULT HrStatus,
        PVOID   pContext);

    HRESULT HrComposeLdapFilter();

    HRESULT HrComposeLdapFilterForType(
        DWORD     dwSearchAttribute,
        DWORD     dwSearchFilter,
        LPTSTR    pszAddress,
        BOOL      fSetDistinguishing = TRUE);

    static HRESULT HrConvertDNtoRDN(
        LPTSTR    pszDN,
        LPTSTR    pszRDN);

    HRESULT HrEscapeFilterString(
        LPSTR     pszSrc,
        DWORD     dwcchDest,
        LPSTR     pszDest);

    //
    // Get the parent CCatAddr (if any)
    //
    HRESULT GetParentAddr(
        CCatAddr **ppParent)
    {
        HRESULT hr;
        ICategorizerItem *pItem;

        //
        // Get the parent ICatItem
        //
        hr = GetICategorizerItem(
            ICATEGORIZERITEM_PARENT,
            &pItem);

        if(FAILED(hr))
            return hr;

        //
        // Get CCatAddr from ICatItem
        //
        hr = pItem->GetPVoid(
            m_pCICatListResolve->GetCCategorizer()->GetICatItemCCatAddrPropId(),
            (PVOID *) ppParent);

        //
        // Addref this CCatAddr for our caller and release the ICatItem parent
        // interface
        //
        if(SUCCEEDED(hr)) {
            (*ppParent)->AddRef();
        }
        pItem->Release();

        return hr;
    }

    HRESULT SetMailMsgCatStatus(
        IMailMsgProperties *pIMailMsgProps,
        HRESULT hrStatus)
    {
        return m_pCICatListResolve->SetMailMsgCatStatus(
            pIMailMsgProps,
            hrStatus);
    }

    HRESULT SetListResolveStatus(
        HRESULT hrStatus)
    {
        return m_pCICatListResolve->SetListResolveStatus(
            hrStatus);
    }

    HRESULT GetListResolveStatus()
    {
        return m_pCICatListResolve->GetListResolveStatus();
    }

    //
    // Inline methods to retrieve ICategorizerItem Props
    //
    HRESULT GetItemStatus()
    {
        HRESULT hr;
        _VERIFY(SUCCEEDED(GetHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            &hr)));
        return hr;
    }

    HRESULT SetRecipientStatus(HRESULT hr)
    {
        return PutHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            hr);
    }

    HRESULT SetRecipientNDRCode(HRESULT hr)
    {
        return PutHRESULT(
            ICATEGORIZERITEM_HRNDRREASON,
            hr);
    }

    
    CCategorizer *GetCCategorizer()
    {
        return m_pCICatListResolve->GetCCategorizer();
    }

    ICategorizerParameters *GetICatParams()
    {
        return GetCCategorizer()->GetICatParams();
    }

    ISMTPServer *GetISMTPServer()
    {   
        return m_pCICatListResolve->GetISMTPServer();
    }

    LPRESOLVE_LIST_CONTEXT GetResolveListContext()
    {
        return m_pCICatListResolve->GetResolveListContext();
    }

    DWORD GetCatFlags()
    {
        return GetCCategorizer()->GetCatFlags();
    }
    VOID SetSenderResolved(BOOL fResolved)
    {
        m_pCICatListResolve->SetSenderResolved(fResolved);
    }
    VOID SetResolvingSender(BOOL fResolving)
    {
        m_pCICatListResolve->SetResolvingSender(fResolving);
    }
    BOOL IsSenderResolveFinished()
    {
        return m_pCICatListResolve->IsSenderResolveFinished();
    }
    PCATPERFBLOCK GetPerfBlock()
    {
        return m_pCICatListResolve->GetPerfBlock();
    }
    VOID IncPendingLookups()
    {
        m_pCICatListResolve->IncPendingLookups();
    }
    VOID DecrPendingLookups()
    {
        m_pCICatListResolve->DecrPendingLookups();
    }
    VOID GetStoreInsertionContext()
    {
        m_pCICatListResolve->GetStoreInsertionContext();
    }
    VOID ReleaseStoreInsertionContext()
    {
        m_pCICatListResolve->ReleaseStoreInsertionContext();
    }
    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest)
    {
        return m_pCICatListResolve->HrInsertInsertionRequest(
            pCInsertionRequest);
    }


    // Member data
    CICategorizerListResolveIMP        *m_pCICatListResolve;
    DWORD                               m_dwlocFlags;
    DWORD                               m_dwDomainOffset;
    LIST_ENTRY                          m_listentry;

    //
    // Any of these flags set indicates that the domain is local and
    // addresses in this domain should be found in the DS
    // (these are flags returned form IAdvQueueDomainType)
    //
    #define DOMAIN_LOCAL_FLAGS (DOMAIN_INFO_LOCAL_MAILBOX)

    friend HRESULT MailTransport_Default_ProcessItem(
        HRESULT hrStatus,
        PVOID pContext);
    friend HRESULT MailTransport_Default_ExpandItem(
        HRESULT hrStatus,
        PVOID pContext);
    friend VOID    MailTransport_DefaultCompletion_ExpandItem(
        PVOID pContext);
    friend HRESULT MailTransport_Completion_ExpandItem(
        HRESULT hrStatus,
        PVOID pContext);
    friend HRESULT MailTransport_Default_CompleteItem(
        HRESULT hrStatus,
        PVOID pContext);

    friend class CSinkInsertionRequest;
};


#endif // __CCATADDDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccatrecip.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatrecip.h
//
// Contents: Class definitions for CIMsgRecipListAddr/CCatRecip
//
// Classes:
//   CIMsgRecipListAddr
//   CCatRecip
//   CCatExpandableRecip
//   CCatDLRecip
//
// Functions:
//
// History:
// jstamerj 980324 19:17:48: Created.
//
//-------------------------------------------------------------

#ifndef __CCATRECIP_H__
#define __CCATRECIP_H__

#include "ccataddr.h"
#include "icatlistresolve.h"
#include <caterr.h>


//
// CIMsgRecipListAddr, abstract class
//   class to define methods for user property storage and retreival
//
class CIMsgRecipListAddr : public CCatAddr
{
  public:
    CIMsgRecipListAddr(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CIMsgRecipListAddr();

    //
    // Storage and retreival procedures
    //
    HRESULT GetSpecificOrigAddress(CAT_ADDRESS_TYPE CAType, LPTSTR psz, DWORD dwcc);
    virtual HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz);
    HRESULT GetICategorizerItem(ICategorizerItem **ppICatItem);
    HRESULT GetICategorizerMailMsgs(ICategorizerMailMsgs *ppICatMsgs);

  protected:
    HRESULT CreateNewCatAddr(
        CAT_ADDRESS_TYPE CAType,
        LPTSTR pszAddress,
        CCatAddr **ppCCatAddr,
        BOOL   fPrimary = FALSE);
    HRESULT SetUnresolved(HRESULT hrReason);
    HRESULT SetDontDeliver(BOOL fDontDeliver);
    HRESULT RemoveFromDuplicateRejectionScheme(BOOL fRemove);

    // Helper routines for checking loops
    HRESULT CheckForLoop(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPSTR *rgpsz, BOOL fCheckSelf);
    HRESULT CheckForLoop(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress, BOOL fCheckSelf);


    HRESULT PutICategorizerItemParent(ICategorizerItem *pItemParent,
                                      ICategorizerItem *pItem)
    {
        return pItem->PutICategorizerItem(
            ICATEGORIZERITEM_PARENT,
            pItemParent);
    }

  protected:
    HRESULT GetIMailMsgProperties(IMailMsgProperties **ppIMailMsgProps)
    {
        return CICategorizerItemIMP::GetIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            ppIMailMsgProps);
    }
    HRESULT GetIMailMsgRecipientsAdd(IMailMsgRecipientsAdd **ppRecipientsAdd)
    {
        return CICategorizerItemIMP::GetIMailMsgRecipientsAdd(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADD,
            ppRecipientsAdd);
    }
    HRESULT GetIMailMsgRecipientsAddIndex(DWORD *pdwIndex)
    {
        return GetDWORD(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADDINDEX,
            pdwIndex);
    }
    HRESULT GetFPrimary(BOOL *pfPrimary)
    {
        return GetBool(
            ICATEGORIZERITEM_FPRIMARY,
            pfPrimary);
    }
    HRESULT PutIMailMsgProperties(IMailMsgProperties *pIMailMsgProps,
                                  ICategorizerItem *pItem)
    {
        return pItem->PutIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            pIMailMsgProps);
    }
    HRESULT PutIMailMsgRecipientsAdd(IMailMsgRecipientsAdd *pRecipientsAdd,
                                     ICategorizerItem *pItem)
    {
        return pItem->PutIMailMsgRecipientsAdd(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADD,
            pRecipientsAdd);
    }
    HRESULT PutIMailMsgRecipientsAddIndex(DWORD dwIndex, ICategorizerItem *pItem)
    {
        return pItem->PutDWORD(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADDINDEX,
            dwIndex);
    }
    HRESULT PutDWLevel(DWORD dwLevel, ICategorizerItem *pItem)
    {
        return pItem->PutDWORD(
            ICATEGORIZERITEM_DWLEVEL,
            dwLevel);
    }
    HRESULT PutFPrimary(BOOL fPrimary, ICategorizerItem *pItem)
    {
        return pItem->PutBool(
            ICATEGORIZERITEM_FPRIMARY,
            fPrimary);
    }
    //
    // Return the recipent level or -1 if not set
    //
    DWORD DWLevel()
    {
        HRESULT hr;
        DWORD dwLevel;
        hr = GetDWORD(
            ICATEGORIZERITEM_DWLEVEL,
            &dwLevel);

        return SUCCEEDED(hr) ? dwLevel : (DWORD)-1;
    }

    HRESULT GetIMsgRecipInfo(
        IMailMsgRecipientsAdd **ppRecipientsAdd,
        DWORD *pdwIndex,
        BOOL *pfPrimary,
        IMailMsgProperties **ppIMailMsgProps)
    {
        HRESULT hr = S_OK;

        //
        // Initialize interface pointers to NULL
        //
        if(ppRecipientsAdd)
            *ppRecipientsAdd = NULL;
        if(ppIMailMsgProps)
            *ppIMailMsgProps = NULL;

        if(pfPrimary) {
            hr = GetFPrimary(pfPrimary);
            if(FAILED(hr))
                goto CLEANUP;
        }
        if(pdwIndex) {
            hr = GetIMailMsgRecipientsAddIndex(pdwIndex);
            if(FAILED(hr))
                goto CLEANUP;
        }

        if(ppRecipientsAdd) {
            hr = GetIMailMsgRecipientsAdd(ppRecipientsAdd);
            if(FAILED(hr))
                goto CLEANUP;
        }

        if(ppIMailMsgProps) {
            hr = GetIMailMsgProperties(ppIMailMsgProps);
            if(FAILED(hr))
                goto CLEANUP;
        }

     CLEANUP:
        if(FAILED(hr)) {
            if(ppRecipientsAdd && (*ppRecipientsAdd)) {
                (*ppRecipientsAdd)->Release();
                *ppRecipientsAdd = NULL;
            }
            if(ppIMailMsgProps && (*ppIMailMsgProps)) {
                (*ppIMailMsgProps)->Release();
                *ppIMailMsgProps = NULL;
            }
        }
        return hr;
    }

    HRESULT PutIMsgRecipInfo(
        IMailMsgRecipientsAdd **ppRecipientsAdd,
        DWORD *pdwIndex,
        BOOL *pfPrimary,
        IMailMsgProperties **ppIMailMsgProps,
        DWORD *pdwLevel,
        ICategorizerItem *pItem)
    {
        HRESULT hr = S_OK;
        if(pdwIndex)
            hr = PutIMailMsgRecipientsAddIndex(*pdwIndex, pItem);
        if(SUCCEEDED(hr) && pfPrimary)
            hr = PutFPrimary(*pfPrimary, pItem);
        if(SUCCEEDED(hr) && ppRecipientsAdd)
            hr = PutIMailMsgRecipientsAdd(*ppRecipientsAdd, pItem);
        if(SUCCEEDED(hr) && ppIMailMsgProps)
            hr = PutIMailMsgProperties(*ppIMailMsgProps, pItem);
        if(SUCCEEDED(hr) && pdwLevel)
            hr = PutDWLevel(*pdwLevel, pItem);

        return hr;
    }

    DWORD PropIdFromCAType(CAT_ADDRESS_TYPE CAType)
    {
        switch(CAType) {
         case CAT_SMTP:
             return IMMPID_RP_ADDRESS_SMTP;
         case CAT_X500:
         case CAT_DN:
             return IMMPID_RP_ADDRESS_X500;
         case CAT_X400:
             return IMMPID_RP_ADDRESS_X400;
         case CAT_LEGACYEXDN:
             return IMMPID_RP_LEGACY_EX_DN;
         case CAT_CUSTOMTYPE:
             return IMMPID_RP_ADDRESS_OTHER;
             break;
         default:
             _ASSERT(0 && "Unknown address type");
             break;
        }
        return 0;
    }
};

//
// CCatExpandableRecip
//  purpose: Provide DL expansion functionality
//
class CCatExpandableRecip :
    public CIMsgRecipListAddr
{
  public:
    typedef enum _DLOBJTYPE {
        DLT_NONE,
        DLT_X500,
        DLT_SMTP,
        DLT_DYNAMIC,
    } DLOBJTYPE, *PDLOBJTYPE;

    CCatExpandableRecip(CICategorizerListResolveIMP
                        *pCICatListResolve) :
        CIMsgRecipListAddr(pCICatListResolve) {}

    // Helper routing to expand DLs and forwarding addresses
    HRESULT HrAddDlMembersAndForwardingAddresses(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);

    HRESULT HrAddDlMembers(
        DLOBJTYPE dlt,
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);

    static VOID DlExpansionCompletion(
        HRESULT hrStatus,
        PVOID pContext);

    HRESULT HrExpandAttribute(
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttributeName,
        PDWORD pdwNumberMembers);

    HRESULT HrAddForwardingAddresses();

  private:
    typedef struct _tagDlCompletionContext {
        CCatExpandableRecip *pCCatAddr;
        PFN_EXPANDITEMCOMPLETION pfnCompletion;
        PVOID pContext;
    } DLCOMPLETIONCONTEXT, *PDLCOMPLETIONCONTEXT;

    PDLCOMPLETIONCONTEXT AllocDlCompletionContext(
        CCatExpandableRecip *pCCatAddr,
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext)
    {
        PDLCOMPLETIONCONTEXT pDLContext;

        pDLContext = new DLCOMPLETIONCONTEXT;
        if(pDLContext) {
            pDLContext->pCCatAddr = pCCatAddr;
            pDLContext->pfnCompletion = pfnCompletion;
            pDLContext->pContext = pContext;
        }
        return pDLContext;
    }
    friend class CMembersInsertionRequest;
};

//
// CCatRecip
//
class CCatRecip :
    public CCatExpandableRecip,
    public CCatDLO<CCatRecip_didx>
{
  public:
    //
    // Flags that indicate a recipient should be NDR'd if not found in the DS
    //
    #define LOCFS_NDR               ( LOCF_LOCALMAILBOX )

    CCatRecip(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CCatRecip();

    //
    // lookup completion
    //
    VOID LookupCompletion();
    //
    // lookup completion only called after sender's completion
    //
    VOID RecipLookupCompletion();

    //
    // Default event sinks
    //
    HRESULT HrProcessItem_Default();
    HRESULT HrExpandItem_Default(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);
    HRESULT HrCompleteItem_Default();

    // Property setting routines
    HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress);
    HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);
    HRESULT AddDynamicDLMember(
        ICategorizerItemAttributes *pICatItemAttr);

    // Forward loop head notification
    HRESULT HandleLoopHead();

    // Catch invalid addresses
    HRESULT HrHandleInvalidAddress();

  private:
    // Helper routine of HrCompletion
    HRESULT HandleFailure(HRESULT HrFailure);

    HRESULT HrNeedsResolveing();

    HRESULT HrNdrUnresolvedRecip(
        BOOL *pfNDR)
    {
        DWORD dw;

        dw = DwGetOrigAddressLocFlags();
        if(dw == LOCF_UNKNOWN) {
            //
            // Assume we couldn't get locality flags because of an
            // illegal address
            //
            return CAT_E_ILLEGAL_ADDRESS;
        }
        *pfNDR = (dw & LOCFS_NDR) ? TRUE : FALSE;
        return S_OK;
    }
  private:
    //
    // List entry used for deferring recip completion processing until
    // the sender is resolved
    //
    LIST_ENTRY m_le;

    static DWORD m_dwRecips;

    friend class CICategorizerListResolveIMP;
};

//
// CCatDLRecip -- the recip used to expand DLs only (no forwarding/alt recip/events/etc)
//
class CCatDLRecip :
    public CCatRecip,
    public CCatDLO<CCatDLRecip_didx>
{
  public:
    #define EXPANDOPT_MATCHONLY     1

    CCatDLRecip(CICategorizerDLListResolveIMP *pIListResolve);
    virtual ~CCatDLRecip();

    //
    // lookup completion
    //
    VOID LookupCompletion();

    //
    // Catch adding addresses so we can notify ICatDLListResolve
    //
    HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz);

    // Property setting routines
    HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR pszForwardingAddress);
    HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);

    // Forward loop head notification
    HRESULT HandleLoopHead()
    {
        // Who cares about loops, we're just doing DL expansion
        return S_OK;
    }

    // Catch invalid addresses
    HRESULT HrHandleInvalidAddress()
    {
        // Who cares if we forward to an invalid address?
        return S_OK;
    }

  private:
    static VOID ExpansionCompletion(PVOID pContext);

    CICategorizerDLListResolveIMP *m_pIListResolve;
};

//
// CMembersInsertionRequest
//  -- The throttled insertion reuqest for the DL members
//
CatDebugClass(CMembersInsertionRequest),
    public CInsertionRequest
{
  public:
    HRESULT HrInsertSearches(
        DWORD dwcSearches,
        DWORD *pdwcSearches);

    VOID NotifyDeQueue(
        HRESULT hr);

  private:
    #define SIGNATURE_CMEMBERSINSERTIONREQUEST          (DWORD)'qRIM'
    #define SIGNATURE_CMEMBERSINSERTIONREQUEST_INVALID  (DWORD)'XRIM'

    CMembersInsertionRequest(
        CCatExpandableRecip *pDLRecipAddr,
        ICategorizerUTF8Attributes *pItemAttributes,
        PATTRIBUTE_ENUMERATOR penumerator,
        CAT_ADDRESS_TYPE CAType)
    {
        m_dwSignature = SIGNATURE_CMEMBERSINSERTIONREQUEST;
        m_pDLRecipAddr = pDLRecipAddr;
        m_pDLRecipAddr->AddRef();
        m_pDLRecipAddr->IncPendingLookups();
        CopyMemory(&m_enumerator, penumerator, sizeof(ATTRIBUTE_ENUMERATOR));
        m_CAType = CAType;
        m_hr = S_OK;
        m_pUTF8Attributes = pItemAttributes;
        m_pUTF8Attributes->AddRef();

    }
    ~CMembersInsertionRequest()
    {
        m_pUTF8Attributes->EndUTF8AttributeEnumeration(
            &m_enumerator);
        m_pUTF8Attributes->Release();

        m_pDLRecipAddr->DecrPendingLookups();
        m_pDLRecipAddr->Release();

        _ASSERT(m_dwSignature == SIGNATURE_CMEMBERSINSERTIONREQUEST);
        m_dwSignature = SIGNATURE_CMEMBERSINSERTIONREQUEST_INVALID;
    }

  private:
    DWORD m_dwSignature;
    CCatExpandableRecip *m_pDLRecipAddr;
    ICategorizerUTF8Attributes *m_pUTF8Attributes;
    ATTRIBUTE_ENUMERATOR m_enumerator;
    CAT_ADDRESS_TYPE m_CAType;
    HRESULT m_hr;

    friend class CCatExpandableRecip;
};

#endif // __CCATRECIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\cbifmgr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: cbifmgr.h
//
// Contents: Implementation of CBifurcationMgr
//
// Classes:
//   CBifurcationMgr
//
// Functions:
//
// History:
// jstamerj 980325 15:29:51: Created.
//
//-------------------------------------------------------------

#ifndef __CBIFMGR_H__
#define __CBIFMGR_H__

#include "mailmsg.h"

#define NUM_ENCODING_PROPS 3

class CBifurcationMgr
{
  public:
    CBifurcationMgr();
    ~CBifurcationMgr();
    HRESULT Initialize(IUnknown *pIMsg);

    IUnknown * GetDefaultIMsg() {
        return m_rgpIMsg[0];
    }

    HRESULT GetDefaultIMailMsgProperties(IMailMsgProperties **ppIProps);
    typedef enum ENCODINGPROPERTY
    { // Encoding properties requireing bifurcation
      //$$TODO: determine real properties required
        DEFAULT = 0,
        UUENCODE = 1,
        MIME = 2
    };
    HRESULT GetIMsgCatList(ENCODINGPROPERTY encprop, IMailMsgRecipientsAdd **ppRecipList);
    DWORD   GetNumIMsgs() { return m_dwNumIMsgs; }

    HRESULT CommitAll();
    HRESULT RevertAll();
    HRESULT GetAllIMsgs(IUnknown **rgpIMsg, DWORD cPtrs);
    
  private:
    IUnknown *m_rgpIMsg[NUM_ENCODING_PROPS];
    IMailMsgRecipientsAdd *m_rgpIRecipsAdd[NUM_ENCODING_PROPS];
    DWORD m_dwNumIMsgs;
};

#endif // __CBIFMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catutil.h ===
#ifndef _CATUTIL_H
#define _CATUTIL_H

/************************************************************
 * FILE: catutil.h
 * PURPOSE: Handy utility stuff used by categorizer code
 * HISTORY:
 *  // jstamerj 980211 15:50:26: Created
 ************************************************************/

#include <abtype.h>
#include "aqueue.h"
#include "catconfig.h"
#include "cattype.h"

/************************************************************
 * MACROS
 ************************************************************/
#define ISHRESULT(hr) (((hr) == S_OK) || ((hr) & 0xFFFF0000))

/************************************************************
 * FUNCTION PROTOTYPES
 ************************************************************/
HRESULT CatMsgCompletion(HRESULT hr, PVOID pContext, IUnknown *pIMsg, IUnknown **rgpIMsg);
HRESULT CatDLMsgCompletion(HRESULT hr, PVOID pContext, IUnknown *pIMsg, IUnknown **rgpIMsg);
HRESULT CheckMessageStatus(IUnknown *pIMsg);

HRESULT GenerateCCatConfigInfo(
    PCCATCONFIGINFO pCatConfig, 
    AQConfigInfo *pAQConfig, 
    ISMTPServer *pISMTPServer,
    IAdvQueueDomainType *pIDomainInfo,
    DWORD *pdwVSID);


#endif //_CATUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccatfn.h ===
//
// inline functions for CCategorizer and related classes
//

#ifndef __CCATFN_H__
#define __CCATFN_H__

#include <transmem.h>
#include "caterr.h"
#include "ccat.h"
#include "cpool.h"
#include "listmacr.h"

#include "icatlistresolve.h"

//
// CCategorizer inline functions
//
inline
CCategorizer::CCategorizer()
{
    m_dwSignature = SIGNATURE_CCAT;
    m_pStore = NULL;
    m_pICatParams = NULL;
    m_cICatParamProps = 0L;
    m_cICatListResolveProps = 0L;
    m_dwICatParamSystemProp_CCatAddr = 0L;
    m_hShutdownEvent = INVALID_HANDLE_VALUE;
    m_lRefCount = 0;
    m_lDestructionWaiters = 0;
    m_ConfigInfo.dwCCatConfigInfoFlags = 0;
    m_hrDelayedInit = CAT_S_NOT_INITIALIZED;
    m_pCCatNext = NULL;
    m_dwInitFlags = 0;
    m_fPrepareForShutdown = FALSE;

    InitializeCriticalSection(&m_csInit);

    InitializeSpinLock(&m_PendingResolveListLock);
    InitializeListHead(&m_ListHeadPendingResolves);

    ZeroMemory(&m_PerfBlock, sizeof(m_PerfBlock));

}

inline
CCategorizer::~CCategorizer()
{
    _ASSERT(m_dwSignature == SIGNATURE_CCAT);
    m_dwSignature = SIGNATURE_CCAT_INVALID;

    if (m_pStore != NULL)
        ReleaseEmailIDStore( m_pStore );
    if (m_pICatParams)
        m_pICatParams->Release();
    if (m_hShutdownEvent != INVALID_HANDLE_VALUE)
        CloseHandle(m_hShutdownEvent);
    if (m_pCCatNext)
        m_pCCatNext->Release();

    ReleaseConfigInfo(&m_ConfigInfo);

    DeleteCriticalSection(&m_csInit);
}

//
// set the cancel flag to cancel any ongoing resolves
//
inline void CCategorizer::Cancel() 
{
    TraceFunctEnter("CCategorizer::Cancel");

    CancelAllPendingListResolves();

    if(m_pStore)
        m_pStore->CancelAllLookups();

    TraceFunctLeave();
}

//
// Call delayed initialize if it hasn't succeeded yet
//
inline HRESULT CCategorizer::DelayedInitializeIfNecessary()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CCategorizer::DelayedInitializeIfNecessary");

    switch(m_hrDelayedInit) {
        
     case S_OK:
         
         hr = S_FALSE;
         break;

     case CAT_E_INIT_FAILED:
     case CAT_S_NOT_INITIALIZED:

        EnterCriticalSection(&m_csInit);
        //
        // Check again, maybe we've been initialized
        //
        if((m_hrDelayedInit == CAT_S_NOT_INITIALIZED) ||
           (m_hrDelayedInit == CAT_E_INIT_FAILED)) {

            hr = DelayedInitialize();

            if(SUCCEEDED(hr))
                m_hrDelayedInit = S_OK;
            else
                m_hrDelayedInit = CAT_E_INIT_FAILED;

        } else {
            //
            // We've were initialized after we checked hr but before entering the CS
            //
            hr = (m_hrDelayedInit == S_OK) ? S_FALSE : CAT_E_INIT_FAILED;
        }

        LeaveCriticalSection(&m_csInit);
        break;

     default:
         
         _ASSERT(0 && "developer bozo error");
         hr = E_FAIL;
         break;
    }

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// Add a pending list resolve
//
inline VOID CCategorizer::AddPendingListResolve(
    CICategorizerListResolveIMP *pListResolve)
{
    AcquireSpinLock(&m_PendingResolveListLock);
    InsertTailList(&m_ListHeadPendingResolves, &(pListResolve->m_li));
    ReleaseSpinLock(&m_PendingResolveListLock);
}        
//
// Remove a pending list resolve
//
inline VOID CCategorizer::RemovePendingListResolve(
    CICategorizerListResolveIMP *pListResolve)
{
    AcquireSpinLock(&m_PendingResolveListLock);
    RemoveEntryList(&(pListResolve->m_li));
    ReleaseSpinLock(&m_PendingResolveListLock);
}


#endif //__CCATFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccat.h ===
//
// ccat.h -- This file contains the class definations for:
//  CCategorizer
//  CAttributes
//  CCIRCULAR_DETECT
//
// Created:
//   Sep 3, 1996 -- Alex Wetmore (awetmore)
// Changes:
//// jstamerj 980227 14:13:42: Modified for Platinum categorizer


#ifndef __CCAT_H__
#define __CCAT_H__

#include <windows.h>
#include <transmem.h>
#include <listmacr.h>
#include "cat.h"
#include "cattype.h"
#include "cbifmgr.h"
#include "idstore.h"
#include "catdefs.h"
#include "spinlock.h"
#include "catperf.h"

#define DEFAULT_VIRTUAL_SERVER_INSTANCES        10

#define MAX_FULL_EMAIL CAT_MAX_INTERNAL_FULL_EMAIL
#define MAX_ENUM_RESULT 100

// maximum number of times to resolve forwarding addresses on a given address
// before giving up and realizing that its a loop
#define MAX_FORWARD_ITERATIONS 25

#define AB_HASHFILENAME "route.hsh"

VOID AsyncResolveCompletion(LPVOID pContext);
VOID AsyncIMsgCatCompletion(LPVOID pContext);

#define NUM_SYSTEM_CCATADDR_PROPIDS 2


//
// the address book
//
CatDebugClass(CCategorizer)
{
  public:
    CCategorizer();
    ~CCategorizer();

    //
    // Lifetime refcounting functions
    //
    LONG AddRef();
    LONG Release();
    VOID ReleaseAndWaitForDestruction();

    //
    // Initialize
    //
    HRESULT Initialize(
        PCCATCONFIGINFO pConfigInfo,
        DWORD dwICatItemPropIDs,
        DWORD dwICatListResolvePropIDs);

    //
    // Simple method to make sure the string terminates before
    // the max length, and the string points to readable memory.
    //
    BOOL VerifyStringLength(LPSTR szString, DWORD dwMaxLength);

    HRESULT AsyncResolveIMsg(IUnknown         *pImsg,
                             PFNCAT_COMPLETION pfnCatCompletion,
                             LPVOID            pContext);

    HRESULT AsyncResolveDLs( IUnknown         *pImsg,
                             PFNCAT_COMPLETION pfnCatCompletion,
                             LPVOID            pContext,
                             BOOL              fMatchOnly,
                             PBOOL             pfMatch,
                             CAT_ADDRESS_TYPE  CAType,
                             LPSTR             pszAddress);

    //
    // cancel all outstanding long running calls on other threads
    //
    void Cancel();

    //
    // Shutdown the address book
    //
    HRESULT Shutdown(void);

    //
    // Method to access EmailIDStore
    //
    CEmailIDStore<CCatAddr> *GetEmailIDStore() {
        return m_pStore;
    }

    //
    // Method to access our default SMTP domain
    //
    LPSTR GetDefaultSMTPDomain() {
        return m_ConfigInfo.pszDefaultDomain;
    }

    VOID CatCompletion(
        PFNCAT_COMPLETION pfnCatCOmpletion,
        HRESULT hr,
        LPVOID  pContext,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);

    VOID GetPerfCounters(
        PCATPERFBLOCK pCatPerfBlock)
    {
        //
        // Fill in the global LDAP perf counters on demand
        //
        CopyMemory(&(GetPerfBlock()->LDAPPerfBlock), &g_LDAPPerfBlock, sizeof(CATLDAPPERFBLOCK));
        CopyMemory(pCatPerfBlock, GetPerfBlock(), sizeof(CATPERFBLOCK));
    }

    VOID SetNextCCategorizer(
        CCategorizer *pCCat)
    {
        _ASSERT(m_pCCatNext == NULL);
        m_pCCatNext = pCCat;
        m_pCCatNext->AddRef();
    }

    VOID PrepareForShutdown()
    {
        m_fPrepareForShutdown = TRUE;
        Cancel();
    }

  private:

    //
    // make sure that an email address is valid
    //
    BOOL VerifyEmailAddress(LPSTR szEmail);
    BOOL VerifyDomainName(LPSTR szDomain);

    //
    // Do the default processing of OnCatRegister
    //
    HRESULT Register();

    //
    // Helper routine to parse above pszSourceLine and set appropriate
    // ICatParams
    //
    HRESULT ParseSourceLineAndSetICatParams(LPCSTR pszSourceLine);

    //
    // Helper routine to set all schema parameters in ICatParams based
    // on a particular schema type
    //
    HRESULT RegisterSchemaParameters(LPSTR pszSchema);

    //
    // Routine to retrieve the ICatItem propID reserved for ptr to a
    // CCatAddr
    //
    DWORD GetICatItemCCatAddrPropId()
    {
        return m_dwICatParamSystemProp_CCatAddr;
    }

    //
    // PropId we use to build a list of CCatAddr prior to the first
    // resolution (we can't resolve as we go because asyncctx needs to
    // be pre-initialized with the number of top level resolves
    //
    DWORD GetICatItemChainPropId()
    {
        return m_dwICatParamSystemProp_CCatAddr + 1;
    }

    //
    // Routine to retrieve ISMTPServer for this virtual server
    //
    ISMTPServer *GetISMTPServer()
    {
        return m_ConfigInfo.pISMTPServer;
    }

    //
    // Routing to retrieve the domain config interface for this virtual server
    //
    ICategorizerDomainInfo *GetIDomainInfo()
    {
        return m_ConfigInfo.pIDomainInfo;
    }

    //
    // Retrieve the cat flags for this virtual server
    //
    DWORD GetCatFlags()
    {
        return m_ConfigInfo.dwCatFlags;
    }

public:
    //
    // A special DWORD that enables/disables cat for this VS
    //
    BOOL IsCatEnabled()
    {
        //
        // Check the enable/disable DWORD (DsUseCat) as well as
        // dwCatFlags (at least one flag must be set or we're still
        // disabled)
        //
        return ((m_ConfigInfo.dwEnable != 0) &&
                (m_ConfigInfo.dwCatFlags != 0));
    }

private:
    //
    // Copy in a config structure during initialization
    //
    HRESULT CopyCCatConfigInfo(PCCATCONFIGINFO pConfigInfo);

    //
    // Releae all memory and interfaces held by the ConfigInfo struct
    //
    VOID ReleaseConfigInfo(PCCATCONFIGINFO pConfigInfo);

    //
    // Helper routine to copy paramters
    //
    HRESULT SetICatParamsFromConfigInfo();

    //
    // Access to our config struct
    //
    PCCATCONFIGINFO GetCCatConfigInfo()
    {
        return &m_ConfigInfo;
    }

    ICategorizerParametersEx *GetICatParams()
    {
        return m_pICatParams;
    }

    DWORD GetNumCatItemProps()
    {
        return m_cICatParamProps;
    }
    DWORD GetNumCatListResolveProps()
    {
        return m_cICatListResolveProps;
    }

    //
    // Delayed initialize function
    //
    HRESULT DelayedInitialize();

    //
    // Do delayed initialize if not already done
    //
    HRESULT DelayedInitializeIfNecessary();

    PCATPERFBLOCK GetPerfBlock()
    {
        return &m_PerfBlock;
    }

    #define SIGNATURE_CCAT          ((DWORD)'tacC')
    #define SIGNATURE_CCAT_INVALID  ((DWORD)'XacC')
    DWORD m_dwSignature;
    //
    // Increment completion counters based on the list resolve status
    //
    HRESULT HrAdjustCompletionCounters(
        HRESULT hrListResolveStatus,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);


    BOOL fIsShuttingDown()
    {
        return m_fPrepareForShutdown;
    }

    //
    // ref count
    //
    LONG m_lRefCount;
    LONG m_lDestructionWaiters;
    BOOL m_fPrepareForShutdown;
    HANDLE m_hShutdownEvent;

    //
    // this is the pointer to the underlying EmailID store object.
    //
    CEmailIDStore<CCatAddr> *m_pStore;

    //
    // ICategorizerParametersEx -- configuration information for this
    // virtual server
    //
    ICategorizerParametersEx *m_pICatParams;

    //
    // Number of properties we need to allocate in each ICatParams
    //
    DWORD m_cICatParamProps;

    //
    // Number of properties we need to allocate in each ICatListResolve
    //
    DWORD m_cICatListResolveProps;

    //
    // The property ID in an ICategorizerItem used for CCatAddr *
    //
    DWORD m_dwICatParamSystemProp_CCatAddr;

    //
    // Configuration parameters passed in
    //
    CCATCONFIGINFO m_ConfigInfo;

    //
    // One of the following values:
    //   CAT_S_NOT_INITIALIED: Delayed initialize has not yet been done
    //   CAT_E_INIT_FAILED: Delayed initialize failed
    //   S_OK: Initialized okay
    //
    HRESULT m_hrDelayedInit;

    //
    // Keep track of what we have initialized
    //
    DWORD m_dwInitFlags;
    #define INITFLAG_REGISTER               0x0001
    #define INITFLAG_REGISTEREVENT          0x0002
    #define INITFLAG_STORE                  0x0004


    CRITICAL_SECTION m_csInit;

    //
    // A list to keep track of all outstanding list resolves
    //
    SPIN_LOCK m_PendingResolveListLock;
    LIST_ENTRY m_ListHeadPendingResolves;

    //
    // Refcounted pointer to a CCategorizer with a newer config
    //
    CCategorizer *m_pCCatNext;

    //
    // Performance counters
    //
    CATPERFBLOCK m_PerfBlock;

    VOID RemovePendingListResolve(
        CICategorizerListResolveIMP *pListResolve);

    VOID AddPendingListResolve(
        CICategorizerListResolveIMP *pListResolve);

    VOID CancelAllPendingListResolves(
        HRESULT hrReason = HRESULT_FROM_WIN32(ERROR_CANCELLED));

    friend VOID AsyncIMsgCatCompletion(LPVOID pContext);
    friend HRESULT MailTransport_Default_CatRegister(
        HRESULT hrStatus,
        PVOID   pvContext);
    friend class CICategorizerListResolveIMP;
    friend class CICategorizerDLListResolveIMP;
    friend class CCatAddr;
    friend class CABContext;
};

#endif //__CCAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccatsender.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatsender.h
//
// Contents: Class definitions for CIMsgSenderAddr/CCatSender
//
// Classes:
//   CIMsgSenderAddr
//   CCatSender
//
// Functions:
//
// History:
// jstamerj 980324 19:24:06: Created.
//
//-------------------------------------------------------------

#ifndef __CCATSENDER_H__
#define __CCATSENDER_H__

#include "ccataddr.h"

#define CAT_NULL_SENDER_ADDRESS_SMTP  "<>"

//
// CIMsgSenderAddr, abstract class
//   class to define how a user's properties are stored and retreived
//
class CIMsgSenderAddr : public CCatAddr
{
  public:
    CIMsgSenderAddr(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CIMsgSenderAddr() {}

    //
    // Storage and retreival procedures
    //
    HRESULT HrGetOrigAddress(LPTSTR psz, DWORD dwcc, CAT_ADDRESS_TYPE *pType);
    HRESULT GetSpecificOrigAddress(CAT_ADDRESS_TYPE CAType, LPTSTR psz, DWORD dwcc);
    HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz);

  private:
    //
    // Inline methods to retrieve ICategorizerItem Props
    //
    HRESULT GetIMailMsgProperties(IMailMsgProperties **ppIMailMsgProperties)
    {
        return CICategorizerItemIMP::GetIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            ppIMailMsgProperties);
    }

    DWORD PropIdFromCAType(CAT_ADDRESS_TYPE CAType)
    {
        switch(CAType) {
         case CAT_SMTP:
             return IMMPID_MP_SENDER_ADDRESS_SMTP;
         case CAT_X500:
         case CAT_DN:
             return IMMPID_MP_SENDER_ADDRESS_X500;
         case CAT_X400:
             return IMMPID_MP_SENDER_ADDRESS_X400;
         case CAT_LEGACYEXDN:
             return IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN;
         case CAT_CUSTOMTYPE:
             return IMMPID_MP_SENDER_ADDRESS_OTHER;
             break;
         default:
             _ASSERT(0 && "Unknown address type");
             break;
        }
        return 0;
    }
};

//
// CCatSender : public CIMsgSenderAddr
//
class CCatSender :
    public CIMsgSenderAddr,
    public CCatDLO<CCatSender_didx>
{
 public:
    CCatSender(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CCatSender() {}

    //
    // Catch the call to dispatch query to the store
    //
    HRESULT HrDispatchQuery();

    //
    // Completion routines
    //
    VOID LookupCompletion();

    HRESULT HrExpandItem_Default(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);

    HRESULT HrCompleteItem_Default();

    //
    // Property setting routines
    //
    HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress);
    HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);
    HRESULT AddDynamicDLMember(
        ICategorizerItemAttributes *pICatItemAttr);

    HRESULT HrNeedsResolveing();

};
    


#endif // __CCATSENDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatprops.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatprops.h
//
// Contents: Implementation of ICategorizerProperties
//
// Classes: CCategorizerItemIMP
//
// Functions:
//
// History:
// jstamerj 1998/11/11 18:50:28: Created
//
//-------------------------------------------------------------
#ifndef __ICATPROPS_H__
#define __ICATPROPS_H__

#include <windows.h>
#include <dbgtrace.h>
#include <smtpevent.h>

#define CICATEGORIZERPROPSIMP_SIGNATURE (DWORD)'ICPR'
#define CICATEGORIZERPROPSIMP_SIGNATURE_FREE (DWORD)'XCPR'


class CICategorizerPropertiesIMP : 
    public ICategorizerProperties
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) {
        return m_pIUnknown->QueryInterface(iid, ppv);
    }
    STDMETHOD_(ULONG, AddRef) () { return m_pIUnknown->AddRef(); }
    STDMETHOD_(ULONG, Release) () { return m_pIUnknown->Release(); }

  public:
    //ICategorizerProperties
    STDMETHOD (GetStringA) (
        DWORD dwPropId, 
        DWORD cch, 
        LPSTR pszValue);
    STDMETHOD (PutStringA) (
        DWORD dwPropId,
        LPSTR pszValue);
    STDMETHOD (GetDWORD) (
        DWORD dwPropId,
        DWORD *pdwValue);
    STDMETHOD (PutDWORD) (
        DWORD dwPropId,
        DWORD dwValue);
    STDMETHOD (GetHRESULT) (
        DWORD dwPropId,
        HRESULT *phrValue);
    STDMETHOD (PutHRESULT) (
        DWORD dwPropId,
        HRESULT hrValue);
    STDMETHOD (GetBool) (
        DWORD dwPropId,
        BOOL  *pfValue);
    STDMETHOD (PutBool) (
        DWORD dwPropId,
        BOOL  fValue);
    STDMETHOD (GetPVoid) (
        DWORD dwPropId,
        PVOID *ppv);
    STDMETHOD (PutPVoid) (
        DWORD dwPropId,
        PVOID pvValue);
    STDMETHOD (GetIUnknown) (
        DWORD dwPropId,
        IUnknown **ppUnknown);
    STDMETHOD (PutIUnknown) (
        DWORD dwPropId,
        IUnknown *pUnknown);
    STDMETHOD (GetIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties **ppIMailMsgProperties);
    STDMETHOD (PutIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties *ppIMailMsgProperties);
    STDMETHOD (GetIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd **ppIMsgRecipientsAdd);
    STDMETHOD (PutIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd *pIMsgRecipientsAdd);
    STDMETHOD (GetICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes **ppICategorizerItemAttributes);
    STDMETHOD (PutICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes *pICategorizerItemAttributes);
    STDMETHOD (GetICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve **ppICategorizerListResolve);
    STDMETHOD (PutICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve *pICategorizerListResolve);
    STDMETHOD (GetICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs **ppICategorizerMailMsgs);
    STDMETHOD (PutICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs *pICategorizerMailMsgs);
    STDMETHOD (GetICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem **ppICategorizerItem);
    STDMETHOD (PutICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem *pICategorizerItem);
    STDMETHOD (UnSetPropId) (
        DWORD dwPropId);

  public:
    DWORD NumProps() {return m_dwNumPropIds;}
    HRESULT GetStringAPtr(
        DWORD dwPropId,
        LPSTR *ppsz);

  private:
    CICategorizerPropertiesIMP(IUnknown *pIUnknown);
    virtual ~CICategorizerPropertiesIMP();

    void * operator new(size_t size, DWORD dwNumProps);

    HRESULT Initialize();
    LPSTR m_strdup(LPSTR psz);

    typede