opied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.2 $
** $Date: 1992/10/06 16:22:36 $
*/
#include "types.h"

typedef struct {
    /*
    ** The user specified result array overflows, this bit is set.
    */
    GLboolean overFlowed;

    /*
    ** User specified result array.  As primitives are processed feedback
    ** data will be entered into this array.
    */
    GLfloat *resultBase;

    /*
    ** Current pointer into the result array.
    */
    GLfloat *result;

    /*
    ** The number of GLfloat's that the array can hold.
    */
    GLint resultLength;

    /*
    ** Type of vertices wanted
    */
    GLenum type;
} __GLfeedbackMachine;

extern void FASTCALL __glFeedbackBitmap(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glFeedbackDrawPixels(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glFeedbackCopyPixels(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glFeedbackPoint(__GLcontext *gc, __GLvertex *v);
#ifdef NT
extern void FASTCALL __glFeedbackLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, GLuint flags);
#else
extern void FASTCALL __glFeedbackLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif
extern void FASTCALL __glFeedbackTriangle(__GLcontext *gc, __GLvertex *a, 
                                          __GLvertex *b, __GLvertex *c);

extern void __glFeedbackTag(__GLcontext *gc, GLfloat tag);

#endif /* __glfeedback_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\devlock.h ===
/******************************Module*Header*******************************\
* Module Name: devlock.h
*
* Created: 12-Apr-1994 19:45:42
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

// Engine helper functions to grab/release display semaphore and to
// teardown/restore the cursor.

extern BOOL APIENTRY glsrvGrabLock(__GLGENcontext *gengc);
extern VOID APIENTRY glsrvReleaseLock(__GLGENcontext *gengc);

extern BOOL APIENTRY glsrvGrabSurfaces(__GLGENcontext *gengc,
                                       GLGENwindow *pwnd,
                                       FSHORT surfBits);
extern VOID APIENTRY glsrvReleaseSurfaces(__GLGENcontext *gengc,
                                          GLGENwindow *pwnd,
                                          FSHORT surfBits);
extern void APIENTRY glsrvSynchronizeWithGdi(__GLGENcontext *gengc,
                                             GLGENwindow *pwnd,
                                             FSHORT surfBits);
extern void APIENTRY glsrvDecoupleFromGdi(__GLGENcontext *gengc,
                                          GLGENwindow *pwnd,
                                          FSHORT surfBits);

/******************************Public*Routine******************************\
*
* glsrvLazyGrabSurfaces
*
* Indicates a need for all surfaces whose bits are set in the flags
* word.  If the locking code determined that a lock was needed for
* that surface and the lock isn't currently held, the lock is taken.
*
* History:
*  Fri May 30 18:17:27 1997	-by-	Gilman Wong [gilmanw]
*   Created
*
\**************************************************************************/

__inline BOOL glsrvLazyGrabSurfaces(__GLGENcontext *gengc,
                                    FSHORT surfBits)
{
    BOOL bRet = TRUE;

    if (((gengc->fsGenLocks ^ gengc->fsLocks) & surfBits) != 0)
    {
        bRet = glsrvGrabSurfaces(gengc, gengc->pwndLocked, surfBits);
    }

    return bRet;
}

//
// Provide wrappers for DirectDraw surface locking and unlocking so
// that lock tracking can be done on debug builds.
//
// #define VERBOSE_DDSLOCK

#if !defined(DBG) || !defined(VERBOSE_DDSLOCK)
#define DDSLOCK(pdds, pddsd, flags, prect) \
    ((pdds)->lpVtbl->Lock((pdds), (prect), (pddsd), (flags), NULL))
#define DDSUNLOCK(pdds, ptr) \
    ((pdds)->lpVtbl->Unlock((pdds), (ptr)))
#else
HRESULT dbgDdsLock(LPDIRECTDRAWSURFACE pdds, DDSURFACEDESC *pddsd,
                   DWORD flags, char *file, int line);
HRESULT dbgDdsUnlock(LPDIRECTDRAWSURFACE pdds, void *ptr,
                     char *file, int line);
#define DDSLOCK(pdds, pddsd, flags, prect) \
    dbgDdsLock(pdds, pddsd, flags, __FILE__, __LINE__)
#define DDSUNLOCK(pdds, ptr) \
    dbgDdsUnlock(pdds, ptr, __FILE__, __LINE__)
#endif

extern DWORD gcmsOpenGLTimer;

//#define BATCH_LOCK_TICKMAX  99
//#define TICK_RANGE_LO       60
//#define TICK_RANGE_HI       100
extern DWORD BATCH_LOCK_TICKMAX;
extern DWORD TICK_RANGE_LO;
extern DWORD TICK_RANGE_HI;

#define GENERIC_BACKBUFFER_ONLY(gc) \
      ( ((gc)->state.raster.drawBuffer == GL_BACK ) &&\
        ((gc)->state.pixel.readBuffer == GL_BACK ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\eval.h ===
#ifndef	__glevaluator_h_
#define	__glevaluator_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.5 $
** $Date: 1993/11/23 21:33:10 $
*/
#include "types.h"

/* XXX Can this be changed? */
#define __GL_MAX_ORDER		40

/* Number of maps */
#define __GL_MAP_RANGE_COUNT	9

#define __GL_EVAL1D_INDEX(old)		((old) - GL_MAP1_COLOR_4)
#define __GL_EVAL2D_INDEX(old)		((old) - GL_MAP2_COLOR_4)

/* Evaluator Flag Macros */
#define GET_EVALSTATE(gc)                                        \
    ((gc)->eval.evalStateFlags)

#define GET_EVALSTATE_PTR(gc)                                    \
    (&((gc)->eval.evalStateFlags))

#define SET_EVALSTATE(gc,Flag)                                   \
    ((gc)->eval.evalStateFlags = (DWORD)(Flag))

/* Evaluator Stack State Macros */
#define GET_EVALSTACKSTATE(gc)                                    \
    ((gc)->eval.evalStackState)

#define GET_EVALSTACKSTATE_PTR(gc)                                \
    (&((gc)->eval.evalStackState))

#define SET_EVALSTACKSTATE(gc,Flag)                               \
    ((gc)->eval.evalStackState= (DWORD)(Flag))

// Flags set by various API for indicating the Evaluator State.
#define __EVALS_AFFECTS_1D_EVAL              0x00000001
#define __EVALS_AFFECTS_2D_EVAL              0x00000002
#define __EVALS_AFFECTS_ALL_EVAL             0x00000004
#define __EVALS_PUSH_EVAL_ATTRIB             0x00000008
#define __EVALS_POP_EVAL_ATTRIB              0x00000010


/* Largest Grid Size */
#define __GL_MAX_EVAL_WIDTH		1024

/* internal form of map range indexes */
#define __GL_C4		__GL_EVAL1D_INDEX(GL_MAP1_COLOR_4)
#define __GL_I		__GL_EVAL1D_INDEX(GL_MAP1_INDEX)
#define __GL_N3		__GL_EVAL1D_INDEX(GL_MAP1_NORMAL)
#define __GL_T1		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_1)
#define __GL_T2		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_2)
#define __GL_T3		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_3)
#define __GL_T4		__GL_EVAL1D_INDEX(GL_MAP1_TEXTURE_COORD_4)
#define __GL_V3		__GL_EVAL1D_INDEX(GL_MAP1_VERTEX_3)
#define __GL_V4		__GL_EVAL1D_INDEX(GL_MAP1_VERTEX_4)

#define EVAL_COLOR_VALID              0x00000001
#define EVAL_NORMAL_VALID             0x00000002
#define EVAL_TEXTURE_VALID            0x00000004

typedef struct {
    /*
    ** not strictly necessary since it can be inferred from the index,
    ** but it makes the code simpler.
    */
    GLint k;		

    /*
    ** Order of the polynomial + 1
    */
    GLint order;

    __GLfloat u1, u2;
} __GLevaluator1;

typedef struct {
    GLint k;
    GLint majorOrder, minorOrder;
    __GLfloat u1, u2;
    __GLfloat v1, v2;
} __GLevaluator2;

typedef struct {
    __GLfloat start;
    __GLfloat finish;
    __GLfloat step;
    GLint n;
} __GLevaluatorGrid;

typedef struct {
    __GLevaluatorGrid u1, u2, v2;
} __GLevaluatorState;

typedef struct {
    __GLevaluator1 eval1[__GL_MAP_RANGE_COUNT];
    __GLevaluator2 eval2[__GL_MAP_RANGE_COUNT];

    __GLfloat *eval1Data[__GL_MAP_RANGE_COUNT];
    __GLfloat *eval2Data[__GL_MAP_RANGE_COUNT];

    __GLfloat uvalue;
    __GLfloat vvalue;
    __GLfloat ucoeff[__GL_MAX_ORDER];
    __GLfloat vcoeff[__GL_MAX_ORDER];
    __GLfloat ucoeffDeriv[__GL_MAX_ORDER];
    __GLfloat vcoeffDeriv[__GL_MAX_ORDER];
    GLint uorder;
    GLint vorder;
    GLint utype;
    GLint vtype;

    // Currently 16 bits long because that is the 
    // maximum attribute stack depth.
    // The right-end is the stack-top
    // This field is used to keep track of PushAttrib/PopAttrib calls
    // that affect the Evaluator state.

    DWORD evalStackState;

    // This field is used to keep track of calls that can potentially
    // that affect the Evaluator state. If any of the flags are set, 
    // a glsbAttention() call is made in the affected Evaluator client
    // side functions.

    DWORD evalStateFlags;
  
    // These are used to store the respective state values in POLYDATA 
    // if they have been set by a not evaluator call (glcltColor, 
    // glcltNormal etc.)

    DWORD accFlags;
    __GLcolor color;
    __GLcoord normal;
    __GLcoord texture;
} __GLevaluatorMachine;

extern void __glCopyEvaluatorState(__GLcontext *gc, __GLattribute *dst,
				   const __GLattribute *src);

extern GLint FASTCALL __glEvalComputeK(GLenum target);

extern void APIPRIVATE __glFillMap1f(GLint k, GLint order, GLint stride,
			  const GLfloat *points, __GLfloat *data);
extern void APIPRIVATE __glFillMap1d(GLint k, GLint order, GLint stride,
			  const GLdouble *points, __GLfloat *data);
extern void APIPRIVATE __glFillMap2f(GLint k, GLint majorOrder, GLint minorOrder,
			  GLint majorStride, GLint minorStride,
			  const GLfloat *points, __GLfloat *data);
extern void APIPRIVATE __glFillMap2d(GLint k, GLint majorOrder, GLint minorOrder,
			  GLint majorStride, GLint minorStride,
			  const GLdouble *points, __GLfloat *data);

#ifdef NT
#define __glMap1_size(k,order)	((k)*(order))
#define __glMap2_size(k,majorOrder,minorOrder)	((k)*(majorOrder)*(minorOrder))
#else
extern GLint FASTCALL __glMap1_size(GLint k, GLint order);
extern GLint FASTCALL __glMap2_size(GLint k, GLint majorOrder, GLint minorOrder);
#endif


extern __GLevaluator1 *__glSetUpMap1(__GLcontext *gc, GLenum type,
				     GLint order, __GLfloat u1, __GLfloat u2);
extern __GLevaluator2 *__glSetUpMap2(__GLcontext *gc, GLenum type,
				     GLint majorOrder, GLint minorOrder,
				     __GLfloat u1, __GLfloat u2,
				     __GLfloat v1, __GLfloat v2);

extern void __glDoEvalCoord1(__GLcontext *gc, __GLfloat u);
extern void __glDoEvalCoord2(__GLcontext *gc, __GLfloat u, __GLfloat v);

extern void FASTCALL __glEvalMesh1Line(__GLcontext *gc, GLint low, GLint high);
extern void FASTCALL __glEvalMesh1Point(__GLcontext *gc, GLint low, GLint high);
extern void __glEvalMesh2Fill(__GLcontext *gc, GLint lowU, GLint lowV,
			      GLint highU, GLint highV);
extern void __glEvalMesh2Line(__GLcontext *gc, GLint lowU, GLint lowV,
			      GLint highU, GLint highV);
extern void __glEvalMesh2Point(__GLcontext *gc, GLint lowU, GLint lowV,
			       GLint highU, GLint highV);

#endif /* __glevaluator_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\fixed.h ===
#ifndef __glfixed_h_
#define __glfixed_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "cpu.h"

/*
** These constants in this file must be valid for all adapters using
** these macros and code which uses these macros.
**
** These should be equal
*/
#define __GL_MAX_WINDOW_SIZE_LOG2       14
#define __GL_MAX_WINDOW_WIDTH	        (1 << __GL_MAX_WINDOW_SIZE_LOG2)
#define __GL_MAX_WINDOW_HEIGHT	        __GL_MAX_WINDOW_WIDTH

/*
** Bias numbers for moving window coordinates into a positive space.
** These values are used during viewport computations.
**
** In our existing code this is only used to provide some buffer room
** in the vertex coordinate space to avoid any errors caused by
** small under- or overflows around the edge of the viewport caused
** by clip inaccuracy.
**
** It must be less than the max window size so that the case of
** a point exactly at the max window value doesn't overflow
** the fixing range
*/
#define __GL_VERTEX_X_BIAS	(1 << (__GL_MAX_WINDOW_SIZE_LOG2-1))
#define __GL_VERTEX_Y_BIAS	__GL_VERTEX_X_BIAS

/* 
** Fixing numbers.  These are used to move the biased window coordinates
** into a range where the number of fraction bits are constant from the
** minimal value in the range to the largest value in the range.
**
** This value should be twice as large as the highest possible window
** coordinate value.  Both values should be the same.
**
** Having the bias in addition to this is important because in
** extreme cases the clipper can generate values slightly outside
** the clip range, due to FP inaccuracy.  A slop bias in addition
** to the real fixing bias makes it impossible to underflow.
*/
#define __GL_VERTEX_FIX_POINT   (__GL_MAX_WINDOW_SIZE_LOG2+1)
#define __GL_VERTEX_X_FIX	(1 << __GL_VERTEX_FIX_POINT)
#define __GL_VERTEX_Y_FIX	__GL_VERTEX_X_FIX

// The addition of the FIX bias to raw window coordinates forces the
// MSB of the window coordinate to always be the same since the FIX
// value is chosen to be the largest power of two greater than any
// possibly window coordinate value.  With the MSB pinned down, the
// floating-point representation of a window coordinates degenerates to
// a fixed-point number since the MSB doesn't change.
//
// We take advantage of this in conversions.

#define __GL_VERTEX_FRAC_BITS \
    (__GL_FLOAT_MANTISSA_BITS-__GL_VERTEX_FIX_POINT)
#define __GL_VERTEX_FRAC_HALF \
    (1 << (__GL_VERTEX_FRAC_BITS-1))
#define __GL_VERTEX_FRAC_ONE \
    (1 << __GL_VERTEX_FRAC_BITS)

// Converts a floating-point window coordinate to integer
#define __GL_VERTEX_FLOAT_TO_INT(windowCoord) \
    __GL_FIXED_FLOAT_TO_INT(windowCoord, __GL_VERTEX_FRAC_BITS)
// To fixed point
#define __GL_VERTEX_FLOAT_TO_FIXED(windowCoord) \
    __GL_FIXED_FLOAT_TO_FIXED(windowCoord)
// And back
#define __GL_VERTEX_FIXED_TO_FLOAT(fxWindowCoord) \
    __GL_FIXED_TO_FIXED_FLOAT(fxWindowCoord, __GL_VERTEX_FRAC_BITS)
// Fixed-point to integer
#define __GL_VERTEX_FIXED_TO_INT(fxWindowCoord) \
    ((fxWindowCoord) >> __GL_VERTEX_FRAC_BITS)

// Returns the fraction from a FP window coordinate as an N
// bit integer, where N depends on the FP mantissa size and the
// FIX size
#define __GL_VERTEX_FLOAT_FRACTION(windowCoord) \
    __GL_FIXED_FLOAT_FRACTION(windowCoord, __GL_VERTEX_FRAC_BITS)

// Scale the fraction to 2^31 for step values
#define __GL_VERTEX_PROMOTE_FRACTION(frac) \
    ((frac) << (31-__GL_VERTEX_FRAC_BITS))
#define __GL_VERTEX_PROMOTED_FRACTION(windowCoord) \
    __GL_VERTEX_PROMOTE_FRACTION(__GL_VERTEX_FLOAT_FRACTION(windowCoord))

// Compare two window coordinates.  Since window coordinates
// are fixed-point numbers, they can be compared directly as
// integers
#define __GL_VERTEX_COMPARE(a, op, b) \
    ((*(LONG *)&(a)) op (*(LONG *)&(b)))

#endif /* __glfixed_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\gencx.h ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#ifndef __GLGENCONTXT_H__
#define __GLGENCONTXT_H__

#include "context.h"
#ifdef _MCD_
#include <winddi.h>
#include "mcdrv.h"
#include "mcd2hack.h"
#include "mcd.h"
#endif

// Re-enable long to float conversion warning.  see also context.h
#pragma warning (default:4244)

#ifdef _CLIENTSIDE_
#include "glscreen.h"
#include "glgenwin.h"
#endif

#ifdef _MCD_
#include "mcdcx.h"
#endif

/*
 * Define maximum color-index table size
 */

#define MAXPALENTRIES   4096

/*
 *  Machine dependent implementation limits
 *  (stolen from gfx/lib/opengl/LIGHT/rexcx.h)
 */

#define __GL_WGL_SUBPIXEL_BITS                  3

#define __GL_WGL_NUMBER_OF_CLIP_PLANES          6
#define __GL_WGL_NUMBER_OF_LIGHTS               8
#define __GL_WGL_NUMBER_OF_TEXTURES             1
#define __GL_WGL_NUMBER_OF_TEXTURE_ENVS         1

#define __GL_WGL_MAX_MODELVIEW_STACK_DEPTH      32
#define __GL_WGL_MAX_PROJECTION_STACK_DEPTH     10
#define __GL_WGL_MAX_TEXTURE_STACK_DEPTH        10
#define __GL_WGL_MAX_ATTRIB_STACK_DEPTH         16
#define __GL_WGL_MAX_CLIENT_ATTRIB_STACK_DEPTH  16
#define __GL_WGL_MAX_NAME_STACK_DEPTH           128
#define __GL_WGL_MAX_EVAL_ORDER                 30
#define __GL_WGL_MAX_MIPMAP_LEVEL               11
#define __GL_WGL_MAX_PIXEL_MAP_TABLE            65536
#define __GL_WGL_MAX_LIST_NESTING               64

#define __GL_WGL_POINT_SIZE_MINIMUM             ((__GLfloat) 0.5)
#define __GL_WGL_POINT_SIZE_MAXIMUM             ((__GLfloat) 10.0)
#define __GL_WGL_POINT_SIZE_GRANULARITY         ((__GLfloat) 0.125)

#define __GL_WGL_LINE_WIDTH_MINIMUM             ((__GLfloat) 0.5)
#define __GL_WGL_LINE_WIDTH_MAXIMUM             ((__GLfloat) 10.0)
#define __GL_WGL_LINE_WIDTH_GRANULARITY         ((__GLfloat) 0.125)

// Constants for fast accelerated texture code...

#define TEX_SCALEFACT	        ((float)65536.0)
#define TEX_SCALESHIFT          16
#define TEX_SHIFTPER4BPPTEXEL   2
#define TEX_SHIFTPER2BPPTEXEL   1
#define TEX_SHIFTPER1BPPTEXEL   0
#define TEX_T_FRAC_BITS         6
#define TEX_SUBDIV              8
#define TEX_SUBDIV_LOG2         3

// This is the largest size we support in the software-accelerated
// perspective-corrected texture code.  This allows 8.6 representation for
// s and t, which permits shifting by constant values in the inner loop.
// Note that the maximum size for paletted textures is greater than for
// RGBA textures, since the number of address bits is smaller (1 byte vs
// 4 bytes).

#define TEX_MAX_SIZE_LOG2      10

#define __GL_MAX_INV_TABLE     31

#define __GL_UNBIAS_AND_INVERT_Y(gc, y) \
        ((gc)->constants.height - __GL_UNBIAS_Y((gc), (y)))

// XXX do we need to add .5?
#define __GL_COLOR_TO_COLORREF(color) \
        RGB( (BYTE)((color)->r), (BYTE)((color)->g), (BYTE)((color)->b))

typedef struct __RenderStateRec {

    GLuint *SrvSelectBuffer;            // Server side address of
                                        // the selection buffer.
    GLuint *CltSelectBuffer;            // Client address of the
                                        // Selection buffer
    GLuint SelectBufferSize;            // Size of select buffer in bytes
    GLfloat *SrvFeedbackBuffer;         // Server side address of the
                                        // feedback buffer
    GLfloat *CltFeedbackBuffer;         // Client side address of the
                                        // Feedback buffer.
    GLuint FeedbackBufferSize;          // Size of the feedback buffer
    GLenum FeedbackType;                // Type of elements for feedback


} __RenderState;

typedef BOOL (APIENTRY *PIXVISPROC)(LONG, LONG);
typedef void (*PIXCOPYPROC)(struct __GLGENcontextRec *, __GLcolorBuffer *, 
                            GLint, GLint, GLint, BOOL);

/****************************************************************************/


typedef struct _SPANREC {
    LONG r;
    LONG g;
    LONG b;
    LONG a;
    ULONG z;
    LONG s;
    LONG t;
} SPANREC;

typedef struct __GLGENcontextRec __GLGENcontext;

typedef void (FASTCALL *__genSpanFunc)(__GLGENcontext *gc);

typedef ULONG (FASTCALL *__computeColorFunc)(__GLcontext *gc,
                                             __GLcolor *color);

typedef struct _GENTEXCACHE {
    __GLcontext *gc;
    ULONG paletteTimeStamp;
    UCHAR *texImageReplace;
    GLenum internalFormat;
    LONG height;
    LONG width;
} GENTEXCACHE;

typedef GLboolean (FASTCALL *fastGenLineProc)(__GLcontext *gc);

typedef struct _GENACCEL {
    //
    // stuff below here is used in the rendering inner loops
    //

    ULONG constantR;        // These are used for scaling texture color values
    ULONG constantG;
    ULONG constantB;
    ULONG constantA;
    SPANREC spanValue;
    SPANREC spanDelta;
    ULONG rAccum;
    ULONG gAccum;
    ULONG bAccum;
    ULONG aAccum;
    ULONG sAccum;
    ULONG tAccum;
    ULONG sResult[2];
    ULONG tResult[2];
    ULONG sResultNew[2];
    ULONG tResultNew[2];
    ULONG sStepX;
    ULONG tStepX;
    ULONG subDs;
    ULONG subDt;
    ULONG pixAccum;
    ULONG ditherAccum;
    __GLfloat qwStepX;
    __GLfloat qwAccum;
    ULONG zAccum;
    PBYTE pPix;
    BYTE displayColor[4];
    __genSpanFunc __fastSpanFuncPtr;

    //
    // stuff below here is used in the FillTriangle routine
    //

    SPANREC spanDeltaY;
    int xMultiplier;
    __genSpanFunc __fastFlatSpanFuncPtr;
    __genSpanFunc __fastSmoothSpanFuncPtr;
    __genSpanFunc __fastTexSpanFuncPtr;
    __GLspanFunc __fastZSpanFuncPtr;
    __GLspanFunc __fastStippleDepthTestSpan;
    __GLfloat rAccelScale;          // Span scale values
    __GLfloat gAccelScale;
    __GLfloat bAccelScale;
    __GLfloat aAccelScale;
    __GLfloat zScale;

    void (FASTCALL *__fastFillSubTrianglePtr)(__GLcontext *, GLint, GLint);
    void (FASTCALL *__fastCalcDeltaPtr)(__GLcontext *gc, __GLvertex *a,
                                        __GLvertex *b, __GLvertex *c);
    void (*__fastSetInitParamPtr)(__GLcontext *gc,
                                  const __GLvertex *a,
                                 __GLfloat dx,
                                 __GLfloat dy);
    //
    // these things are used in the generic rendering or texture path
    //
    int bpp;
    ULONG flags;
    ULONG tShift;
    ULONG sMask, tMask;
    ULONG *texImage;
    ULONG *texPalette;
    ULONG tMaskSubDiv;
    ULONG tShiftSubDiv;
    __GLfloat texXScale;
    __GLfloat texYScale;

    UCHAR *texImageReplace;
    __GLtexture *tex;
    GLboolean (FASTCALL *__fastGenZStore)(__GLzValue z, __GLzValue *fp);
    fastGenLineProc __fastGenLineProc;
    BOOL (FASTCALL *__fastGenInitLineData)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);

    //
    // stuff below here is not used in drawing triangles
    //

    char *buffer;
    FLONG flLineAccelModes;
    BOOL bFastLineDispAccel;
    BOOL bFastLineDIBAccel;
    __computeColorFunc fastLineComputeColor;
    BYTE *pFastLineBuffer;
    POINT *pFastLinePoint;
    DWORD *pFastLineCount;
    DWORD fastLineCounts;
    __GLfloat fastLineOffsetX;
    __GLfloat fastLineOffsetY;

    double zDevScale;     // z scaling for MCD

} GENACCEL;

/*
** Secondary dispatch tables for GENENERIC implementation  (eg CPU specific)
*/


// Define the Rendering context used by the Generic implementation
// One of these structures is allocated for each wglCreateContext().  The
// TEB will contain a pointer to this structure after a wglMakeCurrent()
// NOTE: the TEB will also have a pointer to DispatchTables, if we need
// another entry on the server side, reuse that one.  Could generate code to
// offset into contextRec to get a tables.
typedef struct __GLGENcontextRec
{
    // Must be first entry
    struct __GLcontextRec gc;

    HGLRC hrc;                          // handle from gdi code
    GLWINDOWID gwidCurrent;             // Surface made current
    DWORD dwCurrentFlags;               // GLSURF flags for current surface
    GLDDSURF *pgddsFront;               // Current DirectDraw surface for
                                        // front buffer

    GLuint flags;                       // misc. state flags

    // Window that this context was made current to.  Set in MakeCurrent and
    // kept to validate that attentions are taking place on the same
    // window as was made current.
    GLGENwindow *pwndMakeCur;
    
    // Window that this context current is holding a lock on.  While
    // locked, this must always match pwndMakeCur.  When outside the
    // lock it will be NULL.  Any context-derived window access must
    // use this field rather than pwndMakeCur to ensure that access
    // only takes place while the window lock is held.
    GLGENwindow *pwndLocked;
    
    GLint WndUniq;
    GLint WndSizeUniq;
    ULONG PaletteTimestamp;
    GLint errorcode;

                                        // info for render DC, surface
    GLSURF gsurf;
    int ipfdCurrent;

    BYTE *pajTranslateVector;		// Used for Logical <--> System xlate
    BYTE *pajInvTranslateVector;
    HBITMAP ColorsBitmap;		// GDI dibs for device managed surfs
    PVOID ColorsBits;
    HBITMAP StippleBitmap;
    PVOID StippleBits;
#ifdef _CLIENTSIDE_
    HDC ColorsMemDC;
    HDC ColorsDdbDc;
    HBITMAP ColorsDdb;
#endif

    // Cached GDI objects for rectangle filling and line drawing
    HBRUSH hbrFill;
    COLORREF crFill;
    HDC hdcFill;
    HPEN hpenStroke;
    __GLcolor cStroke;
    COLORREF crStroke;
    HDC hdcStroke;
    BOOL fStrokeInvalid;
    
    // A COLORREF value which isn't a legal COLORREF, used for marking
    // the caches as empty
#define COLORREF_UNUSED 0xffffffff

    __RenderState RenderState;

    VOID *pPrivateArea;                 // Pointer to implementation-specific
                                        // memory area.

    GENACCEL genAccel;                  // Always have this handy...
    BYTE xlatPalette[256];              // goes here to save indirection

    GLint visibleWidth;
    GLint visibleHeight;

    // Information so that OpenGL can adaptively change the amount of
    // time the lock is held.

    DWORD dwLockTick;                   // tick count when lock was acquired

    DWORD dwCalls;                      // tracks number of calls for this tick
    DWORD dwCallsPerTick;               // number of calls per tick allowed
    DWORD dwLastTick;                   // last recorded tick count

    // Locks held by OpenGL while drawing to this context (see values
    // below).

    FSHORT fsGenLocks;                  // locks needed for generic code
    FSHORT fsLocks;                     // locks actually held

    HANDLE hTexture;                    // current texture handle

    PIXCOPYPROC pfnCopyPixels;
    PIXVISPROC pfnPixelVisible;

#ifdef _CLIENTSIDE_
    // Pointers to LOGPALETTE buffers.  The pointer ppalBuf is storage for
    // for two maximally sized (MAXPALENTRIES) LOGPALETTEs.  One, pointed
    // to by ppalSave, is a copy of the last LOGPALETTE used.  The other,
    // pointed to by ppalTmp, is used for temporary storage of the current
    // LOGPALETTE.  To keep the saved copy current, rather than copy the
    // contents of the temp buffer, the two pointers are swapped.
    //
    // We need to do this comparison to detect LOGPALETTE changes to maintain
    // the window ulPaletteUniq when doing >= 16bpp color index-mode drawing
    // (WM_PALETTECHANGED messages are not sent for this case).
    //
    // The LOGPALETTE pointers are NULL if pixelformat is RGBA or < 16bpp.

    LOGPALETTE *ppalBuf;                // Room for both save and tmp buffers.
    LOGPALETTE *ppalSave;               // Saved copy of LOGPALETTE
    LOGPALETTE *ppalTemp;               // Temp storage for current LOGPALETTE

    // In addition, if we are rendering to a 4bpp or 8bpp DIB, we need to
    // track changes in the DIB color table.  In this case, the ppalBuf
    // buffer also includes room for two 256-entry RGBQUAD tables.

    ULONG   crgbSave;                   // Num of valid entries in color table
    RGBQUAD *prgbSave;                  // Saved copy of color table
    ULONG   crgbTemp;
    RGBQUAD *prgbTemp;                  // Temp storage for color table

#endif

#ifdef _MCD_
    // MCD state

    GENMCDSTATE   *_pMcdState;      // pointer to MCD context/state

    GENMCDSTATE   *pMcdState;       // pointer to bound MCD context/state
                                    // (implies both _pMcdState and pMcdSurf
                                    // valid; i.e., valid MCD context is
                                    // bound to a valid MCD surface)

    LONG iLayerPlane;
#endif
    // Add other rc info here

} __GLGENcontext;

/*
 * Mark the gc as dirty so that pick procs will be executed when
 * __glGenericPickAllProcs is called (probably via gc->proc.pickAllProcs).
 */
#define __GL_INVALIDATE(gc)                 \
    (gc)->dirtyMask |= __GL_DIRTY_GENERIC

/*
 * __GLGENcontext flags
 *
 *  GLGEN_MCD_CONVERTED_TO_GENERIC      context used to be MCD, but now
 *                                      converted to generic
 *
 *  GENGC_MCD_BGR_INTO_RGB              fake 233BGR format to appear internally
 *                                      as 332RGB (more 332RGB fast path code)
 *
 *  GENGC_GENERIC_COMPATIBLE_FORMAT     pixel format is compatible with
 *                                      generic code (see in pixelfmt.c
 *                                      GenMcdGenericCompatibleFormat)
 */
#define GLGEN_MCD_CONVERTED_TO_GENERIC      0x0001
#define GENGC_MCD_BGR_INTO_RGB              0x0002
#define GENGC_GENERIC_COMPATIBLE_FORMAT     0x0004

/*
 * Error codes
 */
#define GLGEN_NO_ERROR          0
#define GLGEN_OUT_OF_MEMORY     1
#define GLGEN_GRE_FAILURE       2
#define GLGEN_DEVLOCK_FAILED    3

/*
 * Locks that can be held during operation.
 *
 *      Value               Description
 *      ------------------------------------------------------------------
 *      LOCKFLAG_WINDOW         Window information semaphore.
 *      LOCKFLAG_MCD            MCD lock.
 *      LOCKFLAG_FRONT_BUFFER   Primary surface lock.
 *      LOCKFLAG_DD_DEPTH       DirectDraw depth buffer surface lock.
 *      LOCKFLAG_DD_TEXTURE     DirectDraw texture mipmap surface locks.
 *
 * __GLGENcontext.fsLocks indicates the locks currently held by the context.
 * __GLGENcontext.fsGenLocks indicates the locks that need to be held
 * if generic code is going to be executed.  The two fields allow
 * lazy acquisition of locks by deferring actual locking until just
 * before generic code is executed.
 *
 */
#define LOCKFLAG_WINDOW         0x0001
#define LOCKFLAG_MCD            0x0002
#define LOCKFLAG_FRONT_BUFFER   0x0004
#define LOCKFLAG_DD_DEPTH       0x0008
#define LOCKFLAG_DD_TEXTURE     0x0010

// All lock flags that can be lazily acquired.
#define LAZY_LOCK_FLAGS \
    (LOCKFLAG_MCD | LOCKFLAG_FRONT_BUFFER | LOCKFLAG_DD_DEPTH | \
     LOCKFLAG_DD_TEXTURE)

// All lock flags for surfaces.
#define SURFACE_LOCK_FLAGS \
    (LOCKFLAG_FRONT_BUFFER | LOCKFLAG_DD_DEPTH | LOCKFLAG_DD_TEXTURE)

// All lock flags for color buffer access.
#define COLOR_LOCK_FLAGS        (LOCKFLAG_MCD | LOCKFLAG_FRONT_BUFFER)

// All lock flags for depth buffer access.
#define DEPTH_LOCK_FLAGS        (LOCKFLAG_MCD | LOCKFLAG_DD_DEPTH)

// All lock flags for texture access.
#define TEXTURE_LOCK_FLAGS      LOCKFLAG_DD_TEXTURE

// Accesses required for fragment rendering.
#define RENDER_LOCK_FLAGS       (COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS | \
                                 TEXTURE_LOCK_FLAGS)

/*
 * Screen lock testing functions.  GDI drawing calls should not be made
 * when the screen lock is held.  These are for
 * use on a checked (debug system) to assert the state of the lock.
 */
#if DBG
#define GENGC_LOCK \
    (((__GLGENcontext *)GLTEB_SRVCONTEXT())->fsLocks)
#define PWNDFLAGS \
    ((((__GLGENcontext *)GLTEB_SRVCONTEXT())->pwndLocked)->ulFlags)
#define CHECKSCREENLOCKOUT() \
    ASSERTOPENGL(GLTEB_SRVCONTEXT() == NULL || \
                 !(GENGC_LOCK & LOCKFLAG_FRONT_BUFFER) || \
                 !(PWNDFLAGS & GLGENWIN_DIRECTSCREEN), \
                 "Screen lock held\n")

#define CHECKSCREENLOCKIN() \
    ASSERTOPENGL(GLTEB_SRVCONTEXT() != NULL && \
                 (GENGC_LOCK & LOCKFLAG_FRONT_BUFFER) && \
                 (PWNDFLAGS & GLGENWIN_DIRECTSCREEN), \
                 "Screen lock not held\n")
#else
#define CHECKSCREENLOCKOUT()
#define CHECKSCREENLOCKIN()
#endif

/*
 * Structure to keep track of ancillary buffers for a window/drawable
 * All RCs/threads must share the ancillary buffers, including fake back buffer
 */

typedef struct __GLGENbitmapRec {
    GLGENwindow *pwnd; // This must be the first member in this structure
    GLGENwindow wnd;
    HBITMAP hbm;
    HDC hdc;
    PVOID pvBits;
} __GLGENbitmap;

#define CURRENT_DC_CFB(cfb)     ((cfb)->bitmap->hdc)
#define CURRENT_DC              CURRENT_DC_CFB(cfb)
#define CURRENT_DC_GC(gc)       CURRENT_DC_CFB(gc->drawBuffer)
#define CURRENT_DC_FRONT_GC(gc) CURRENT_DC_CFB(gc->front)

/*
 * Structure used to cache clip rectangles enumerated from window clip region.
 */

typedef struct __GLGENclipCacheRec {
    GLint WndUniq;
    GLint crcl;
    RECTL *prcl;
} __GLGENclipCache;

/****************************************************************************/

// Make sure this header file is loaded, it contains the rectlist definition.

#include "srvp.h"

/****************************************************************************/

// Comment it out if the __glDoPolygonClip stack allocation fix is not
// wanted
#define __CLIP_FIX

#ifdef __CLIP_FIX
#define __GL_TOTAL_CLIP_PLANES 20   /*XXX*/
#define __GL_MAX_CLIP_VERTEX (__GL_TOTAL_CLIP_PLANES + __GL_MAX_POLYGON_CLIP_SIZE)
#endif

/*
 * This structure contains the buffers shared by all gc's using the
 * same window.
 */

struct __GLGENbuffersRec {

// Global (within this structure) state.

    GLint WndUniq;
    GLint WndSizeUniq;
    GLint flags;
    GLint width, height;

// Ancillary buffers and state.

// The ancillary buffers are lazily created.  The createdXBuffer flags
// indicate one of two states: FALSE means that the lazy allocation
// function has never been called, TRUE means that it has.  What this
// allows us to do, in the event of an ancillary buffer allocation
// failure, is temporarily disable the ancillary buffer and continue to
// render.  At some later time, the createdXBuffer flag serves as an
// indication that the buffer SHOULD exist and that we may need to try
// and retry the allocation.
//
// The stencil, depth, accum, and color bits must match the corresponding
// bits in the context.  Otherwise, glsrvMakeCurrent should not succeed.

    GLboolean  createdStencilBuffer;
    GLboolean  createdDepthBuffer;
    GLboolean  createdAccumBuffer;
    GLint      stencilBits;
    GLint      depthBits;
    GLint      accumBits;
    GLint      colorBits;
    __GLbuffer stencilBuffer;
    __GLbuffer depthBuffer;
    __GLbuffer accumBuffer;
    GLint      alphaBits;
    __GLbuffer alphaBuffer0;
    __GLbuffer alphaBuffer1;
    __GLbuffer *alphaFrontBuffer;
    __GLbuffer *alphaBackBuffer;

// Back buffer.

    __GLbuffer backBuffer;
    __GLGENbitmap backBitmap;

// Ancillary buffer resize functions.

    GLboolean (*resize)(__GLGENbuffers *, __GLbuffer *,  GLint, GLint);
    GLboolean (*resizeDepth)(__GLGENbuffers *, __GLbuffer *,  GLint, GLint);

// Clip rectangle cache.

    __GLGENclipCache clip;

    // dirty regions data

    PXLIST pxlist;                      // free lists
    PYLIST pylist;

    RECTLIST rl;                        // SwapBuffers Hint Region
    BOOL fMax;                          // should we blt the entire window?

#ifdef _MCD_
// MCD surface.

    GENMCDSURFACE *pMcdSurf;            // pointer MCD surface
    GENMCDSTATE *pMcdState;             // pointer to current MCD state
                                        // holding McdSurf for rendering
                                        // (i.e., holds the window lock)
#endif

#ifdef __CLIP_FIX 
    __GLvertex *clip_verts[__GL_TOTAL_CLIP_PLANES][__GL_MAX_CLIP_VERTEX];
#endif
};

/* flags */
#define GLGENBUF_HAS_BACK_BUF       0x0001
#define GLGENBUF_MCD_LOST           0x0002

/****************************************************************************/

void RECTLISTAddRect(PRECTLIST prl, int xs, int ys, int xe, int ye);
void RECTLISTSetEmpty(PRECTLIST prl);
BOOL RECTLISTIsEmpty(PRECTLIST prl);
void YLISTFree(__GLGENbuffers *buffers, PYLIST pylist);
void XLISTFree(__GLGENbuffers *buffers, PXLIST pxlist);

/****************************************************************************/

/* colorbuffer flags */
#define COLORMASK_ON    0x0001          // glColorMask() not all true for r,g,b
#define INDEXMASK_ON    0x0001          // glIndexMask() not all 1's
#define DIB_FORMAT      0x0002          // surface is DIB format
#define NEED_FETCH   	0x0004          // fetch required
#define MEMORY_DC       0x0008          // set if DIB in memory (ie !display)
#define NO_CLIP         0x0010          // Set if surface never requires clip
#define ALPHA_ON        0x0020          // have alphaBits, alphaMask is true
#define ALPHA_IN_PIXEL_BIT  0x0040      // alpha is part of the pixel

#define ALPHA_WRITE_ENABLED( cfb ) \
    ( (cfb)->buf.flags & ALPHA_ON ) 

// These next macros take into account the fact that alpha values can either be
// part of the pixel (e.g. MCD color buffer), or are kept in a separate software
// buffer (generic software implementation).  They are mostly used by the span
// routines in genrgb.c to determine where to store/fetch alpha values.

#define ALPHA_IN_PIXEL( cfb ) \
    ( (cfb)->buf.flags & ALPHA_IN_PIXEL_BIT ) 

#define ALPHA_BUFFER_WRITE( cfb ) \
    (((cfb)->buf.flags & (ALPHA_ON | ALPHA_IN_PIXEL_BIT)) == ALPHA_ON)
     
#define ALPHA_PIXEL_WRITE( cfb ) \
    (((cfb)->buf.flags & (ALPHA_ON | ALPHA_IN_PIXEL_BIT)) == \
     (ALPHA_ON | ALPHA_IN_PIXEL_BIT))


/*
 * Structures and flags for accelerated span and line functions.
 */

#define SURFACE_TYPE_DIB     0x001
#define HAVE_STIPPLE         0x002

#define GEN_TEXTURE_ORTHO    0x008
#define GEN_TEXTURE          0x010
#define GEN_RGBMODE          0x020
#define GEN_DITHER           0x040
#define GEN_SHADE            0x080
#define GEN_FASTZBUFFER      0x100
#define GEN_LESS             0x200

#define ACCEL_FIX_SCALE         65536.0
#define ACCEL_COLOR_SCALE       ((GLfloat)(255.0))
#define ACCEL_COLOR_SCALE_FIX   ((GLfloat)(65536.0 * 255.0))

// Overall size of fast line buffer
#define __FAST_LINE_BUFFER_SIZE 65536
// Number of polyline counts reserved in the fast line buffer
// This is computed to roughly handle lines with eight vertices
#define __FAST_LINE_BUFFER_COUNTS (__FAST_LINE_BUFFER_SIZE/64)

#define GENACCEL(gc)	(((__GLGENcontext *)gc)->genAccel)

BOOL FASTCALL __glGenCreateAccelContext(__GLcontext *gc);
void FASTCALL __glGenDestroyAccelContext(__GLcontext *gc);

#define Copy3Bytes( dst, src ) \
{ \
    GLubyte *ps = (GLubyte *)src, *pd = (GLubyte *)dst;	\
    *pd++ = *ps++;	\
    *pd++ = *ps++;	\
    *pd   = *ps  ;      \
}
    
#define NeedLogicOpFetch( op ) \
    !( (op == GL_CLEAR) || (op == GL_COPY) || (op == GL_COPY_INVERTED) || \
       (op == GL_SET) )

GLuint FASTCALL DoLogicOp( GLenum logicOp, GLuint SrcColor, GLuint DstColor );

/*
 * Function Prototypes for Generic calls
 */
void FASTCALL __fastGenPickSpanProcs(__GLcontext *gc);
void FASTCALL __fastGenPickZStoreProc(__GLcontext *gc);
void FASTCALL __fastGenPickTriangleProcs(__GLcontext *gc);
void FASTCALL __fastGenPickLineProcs(__GLcontext *gc);
void FASTCALL __fastGenFillSubTriangle(__GLcontext *, GLint, GLint);
void FASTCALL __fastGenFillSubTriangleTexRGBA(__GLcontext *, GLint, GLint);
void FASTCALL __glGenPickStoreProcs(__GLcontext *gc);
__GLcontext *__glGenCreateContext( HDC hdc, ULONG handle);
void ResizeBitmapBuffer(__GLGENbuffers *, __GLcolorBuffer *, GLint, GLint);
void FASTCALL ClearBitmapBuffer(__GLcolorBuffer *);
void UpdateSharedBuffer(__GLbuffer *to, __GLbuffer *from);
void FASTCALL LazyAllocateDepth(__GLcontext *gc);
void FASTCALL LazyAllocateAccum(__GLcontext *gc);
void FASTCALL LazyAllocateStencil(__GLcontext *gc);
void FASTCALL glGenInitCommon(__GLGENcontext *gengc, __GLcolorBuffer *cfb, GLenum type);
BOOL FASTCALL wglCreateScanlineBuffers(__GLGENcontext *gengc);
VOID FASTCALL wglDeleteScanlineBuffers(__GLGENcontext *gengc);
VOID FASTCALL wglInitializeColorBuffers(__GLGENcontext *gengc);
VOID FASTCALL wglInitializeDepthBuffer(__GLGENcontext *gengc);
VOID FASTCALL wglInitializePixelCopyFuncs(__GLGENcontext *gengc);
GLboolean ResizeAncillaryBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);
GLboolean ResizeUnownedDepthBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);
VOID wglResizeBuffers(__GLGENcontext *gengc, GLint width, GLint height);
BOOL wglUpdateBuffers(__GLGENcontext *gengc, __GLGENbuffers *buffers);

extern void APIPRIVATE glsrvFlushDrawPolyArray(struct _POLYARRAY *, BOOL);

MCDHANDLE FASTCALL __glGenLoadTexture(__GLcontext *gc, __GLtexture *tex, ULONG flags);
BOOL FASTCALL __glGenUpdateTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey);
void FASTCALL __glGenFreeTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey);
BOOL FASTCALL __glGenMakeTextureCurrent(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey);
void FASTCALL __glGenUpdateTexturePalette(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey,
                                          ULONG start, ULONG count);
#ifdef GL_EXT_flat_paletted_lighting
void FASTCALL __glGenSetPaletteOffset(__GLcontext *gc, __GLtexture *tex,
                                      GLint offset);
#endif

/*
 * Function Prototypes and Externs for accelerated generic calls
 */

extern __genSpanFunc __fastGenRGBFlatFuncs[];
extern __genSpanFunc __fastGenCIFlatFuncs[];
extern __genSpanFunc __fastGenRGBFuncs[];
extern __genSpanFunc __fastGenCIFuncs[];
extern __genSpanFunc __fastGenTexDecalFuncs[];
extern __genSpanFunc __fastGenTexFuncs[];
extern __genSpanFunc __fastGenWTexDecalFuncs[];
extern __genSpanFunc __fastGenWTexFuncs[];
extern __genSpanFunc __fastPerspTexReplaceFuncs[];
extern __genSpanFunc __fastPerspTexPalReplaceFuncs[];
extern __genSpanFunc __fastPerspTexFlatFuncs[];
extern __genSpanFunc __fastPerspTexSmoothFuncs[];

extern __GLspanFunc __fastDepthFuncs[];
extern __GLspanFunc __fastDepth16Funcs[];

extern void FASTCALL __fastGenDeltaSpan(__GLcontext *gc, SPANREC *spanDelta);
extern void FASTCALL __fastGenFillTriangle(__GLcontext *gc, __GLvertex *a, 
                                  __GLvertex *b, __GLvertex *c, GLboolean ccw);

extern void FASTCALL __fastLineComputeOffsets(__GLGENcontext *gengc);

extern void FASTCALL __fastGenRenderLineDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
extern void FASTCALL __fastGenRenderLineWideDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);

extern void gdiCopyPixels(__GLGENcontext *, __GLcolorBuffer *, GLint, GLint,
                          GLint, BOOL);

extern void dibCopyPixels(__GLGENcontext *, __GLcolorBuffer *, GLint, GLint,
                          GLint, BOOL);

typedef void (FASTCALL *PFNZIPPYSUB)(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTRGBTex(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTTex(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTRGB(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTCI(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTZ(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __ZippyFSTCI8Flat(__GLcontext *gc, GLint iyBottom, GLint iyTop);
void FASTCALL __fastGenSpan(__GLGENcontext *gengc);

GLboolean FASTCALL __fastGenStippleLt32Span(__GLcontext *gc);
GLboolean FASTCALL __fastGenStippleLt16Span(__GLcontext *gc);
GLboolean FASTCALL __fastGenStippleAnyDepthTestSpan(__GLcontext *gc);

extern BYTE gbMulTable[];
extern BYTE gbSatTable[];
extern DWORD ditherShade[];
extern DWORD ditherTexture[];
extern __GLfloat invTable[];

extern __GLfloat fDitherIncTable[]; // defined in genrgb.c

void FASTCALL __glGenFreeBuffers( __GLGENbuffers *buffers );

#endif /* __GLGENCONTXT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\glmath.h ===
#ifndef __glmath_h_
#define __glmath_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1993/01/06 19:02:47 $
*/
#include "types.h"

__GLfloat __glLog2(__GLfloat x);
GLint FASTCALL __glIntLog2(__GLfloat f);
GLfloat FASTCALL __glClampf(GLfloat fval, __GLfloat zero, __GLfloat one);
void FASTCALL __glVecSub4(__GLcoord *r,
                          const __GLcoord *p1, const __GLcoord *p2);

#endif /* __glmath_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\imports.h ===
#ifndef __glimports_h_
#define __glimports_h_

/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Imports from outside libraries.
**
** $Revision: 1.8 $
** $Date: 1993/12/09 01:57:59 $
*/
#include <memory.h>
#include <math.h>

#if defined(NT)
/*
** MEMMOVE handles overlapping memory (slower)
** MEMCOPY does not handle overlapping memory (faster)
*/

#define __GL_MEMCOPY(to,from,count)	RtlCopyMemory(to,from,(size_t)(count))
#define __GL_MEMMOVE(to,from,count)	RtlMoveMemory(to,from,(size_t)(count))
#define __GL_MEMZERO(to,count)		RtlZeroMemory(to,(size_t)(count))

#else

#define __GL_MEMCOPY(to,from,count)	memcpy(to,from,(size_t)(count))
#define __GL_MEMMOVE(to,from,count)	memmove(to,from,(size_t)(count))
#define __GL_MEMZERO(to,count)		memset(to,0,(size_t)(count))

#endif

#ifdef _ALPHA_
extern float fpow(float, float);
#define __GL_POWF(a,b)			((__GLfloat)fpow((__GLfloat)(a), (__GLfloat)(b)))
#else
#define __GL_POWF(a,b)			((__GLfloat)pow((double)(a),(double)(b)))
#endif
 
#define __GL_CEILF(f)			((__GLfloat)ceil((double) (f)))
#define __GL_SQRTF(f)			((__GLfloat)sqrt((double) (f)))	
#define __GL_ABSF(f)			((__GLfloat)fabs((double) (f)))
#define __GL_FLOORF(f)			((__GLfloat)floor((double) (f)))
#define __GL_FLOORD(f)			floor(f)
#define __GL_SINF(f)			((__GLfloat)sin((double) (f)))
#define __GL_COSF(f)			((__GLfloat)cos((double) (f)))
#define __GL_ATANF(f)			((__GLfloat)atan((double) (f)))
#define __GL_ATAN2F(x, y)		((__GLfloat)atan2((double) (x), (double) (y)))
#define __GL_LOGF(f)			((__GLfloat)log((double) (f)))

#endif /* __glimports_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\glarray.h ===
/******************************Module*Header*******************************\
* Module Name: glarray.h
*
* Vertex array states.
*
* Created: 2-04-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __glarray_h_
#define __glarray_h_

extern GLuint vaEnable[];

typedef struct
{
    GLuint   iIn;
    GLushort next;
} VAMAP;

// Vertex array structures.

typedef void (FASTCALL *PFNVAELEMENTBATCH)
    (__GLcontext *gc, GLint firstIndex, GLint  nVertices);

typedef void (FASTCALL *PFNVAELEMENTBATCHINDIRECT)
    (__GLcontext *gc, GLint  nVertices, VAMAP* indices);

typedef void (FASTCALL *PFNVAELEMENT)(__GLcontext *gc, GLint i);

typedef void (APIENTRY *PFNGLVECTOR)(IN const GLvoid *v);

typedef struct __GLarrayEdgeFlagRec {
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayEdgeFlag;

typedef struct __GLarrayTexCoordRec {
    GLint         size;
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayTexCoord;

typedef struct __GLarrayIndexRec {
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayIndex;

typedef struct __GLarrayColorRec {
    GLint         size;
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayColor;

typedef struct __GLarrayNormalRec {
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayNormal;

typedef struct __GLarrayVertexRec {
    GLint         size;
    GLenum        type;
    GLuint        ibytes;
    GLsizei       stride;
    const GLbyte *pointer;
    PFNGLVECTOR   pfn;
    PFNGLVECTOR   pfnCompile;
} __GLarrayVertex;

// Vertex array states.
typedef struct __GLvertexArrayRec {
    GLuint            flags;
    GLuint            mask;
    PFNVAELEMENT      pfnArrayElement;
    PFNVAELEMENTBATCH pfnArrayElementBatch;
    PFNVAELEMENTBATCHINDIRECT pfnArrayElementBatchIndirect;
    __GLarrayEdgeFlag edgeFlag;
    __GLarrayTexCoord texCoord;
    __GLarrayIndex    index;
    __GLarrayColor    color;
    __GLarrayNormal   normal;
    __GLarrayVertex   vertex;
} __GLvertexArray;

// Vertex array flags.
#define __GL_VERTEX_ARRAY_DIRTY      0x0001

// Mask that encapsulates the current vertex array settings.
// It is maintained in the mask field in __GLvertexArray.
// The mask is given in the following binary form in 24 bits:
//
//    VeVsVsVtVtNeNtNtNtCeCsCtCtCtIeItItItTeTsTsTtTtEe
//    232221201918171615141312111009080706050403020100
//
// where V:vertex pointer,
//       N:normal pointer,
//       C:color pointer,
//       I:index pointer,
//       T:texture coord pointer,
//       E:edge flag pointer,
//       e:enable flag,
//       s:size field,
//       t:type field.

#define VAMASK_EDGEFLAG_ENABLE_SHIFT	0
#define VAMASK_TEXCOORD_TYPE_SHIFT	1
#define VAMASK_TEXCOORD_SIZE_SHIFT	3
#define VAMASK_TEXCOORD_ENABLE_SHIFT	5
#define VAMASK_INDEX_TYPE_SHIFT		6
#define VAMASK_INDEX_ENABLE_SHIFT	9
#define VAMASK_COLOR_TYPE_SHIFT		10
#define VAMASK_COLOR_SIZE_SHIFT		13
#define VAMASK_COLOR_ENABLE_SHIFT	14
#define VAMASK_NORMAL_TYPE_SHIFT	15
#define VAMASK_NORMAL_ENABLE_SHIFT	18
#define VAMASK_VERTEX_TYPE_SHIFT	19
#define VAMASK_VERTEX_SIZE_SHIFT	21
#define VAMASK_VERTEX_ENABLE_SHIFT	23

#define VAMASK_EDGEFLAG_ENABLE_MASK	(1 << VAMASK_EDGEFLAG_ENABLE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_MASK	(3 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_MASK	(3 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_ENABLE_MASK	(1 << VAMASK_TEXCOORD_ENABLE_SHIFT)
#define VAMASK_INDEX_TYPE_MASK		(7 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_ENABLE_MASK	(1 << VAMASK_INDEX_ENABLE_SHIFT)
#define VAMASK_COLOR_TYPE_MASK		(7 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_SIZE_MASK		(1 << VAMASK_COLOR_SIZE_SHIFT)
#define VAMASK_COLOR_ENABLE_MASK	(1 << VAMASK_COLOR_ENABLE_SHIFT)
#define VAMASK_NORMAL_TYPE_MASK		(7 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_ENABLE_MASK	(1 << VAMASK_NORMAL_ENABLE_SHIFT)
#define VAMASK_VERTEX_TYPE_MASK		(3 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_SIZE_MASK		(3 << VAMASK_VERTEX_SIZE_SHIFT)
#define VAMASK_VERTEX_ENABLE_MASK	(1 << VAMASK_VERTEX_ENABLE_SHIFT)

#define VAMASK_EDGEFLAG_TYPE_SIZE_MASK \
    (0)
#define VAMASK_TEXCOORD_TYPE_SIZE_MASK \
    (VAMASK_TEXCOORD_TYPE_MASK | VAMASK_TEXCOORD_SIZE_MASK)
#define VAMASK_INDEX_TYPE_SIZE_MASK \
    (VAMASK_INDEX_TYPE_MASK)
#define VAMASK_COLOR_TYPE_SIZE_MASK \
    (VAMASK_COLOR_TYPE_MASK | VAMASK_COLOR_SIZE_MASK)
#define VAMASK_NORMAL_TYPE_SIZE_MASK \
    (VAMASK_NORMAL_TYPE_MASK)
#define VAMASK_VERTEX_TYPE_SIZE_MASK \
    (VAMASK_VERTEX_TYPE_MASK | VAMASK_VERTEX_SIZE_MASK)

#define VAMASK_TEXCOORD_TYPE_SHORT	(0 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_INT	(1 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_FLOAT	(2 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_TYPE_DOUBLE	(3 << VAMASK_TEXCOORD_TYPE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_1		(0 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_2		(1 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_3		(2 << VAMASK_TEXCOORD_SIZE_SHIFT)
#define VAMASK_TEXCOORD_SIZE_4		(3 << VAMASK_TEXCOORD_SIZE_SHIFT)

#define VAMASK_INDEX_TYPE_UBYTE		(0 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_SHORT		(1 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_INT		(2 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_FLOAT		(3 << VAMASK_INDEX_TYPE_SHIFT)
#define VAMASK_INDEX_TYPE_DOUBLE	(4 << VAMASK_INDEX_TYPE_SHIFT)

#define VAMASK_COLOR_TYPE_BYTE		(0 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_UBYTE		(1 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_SHORT		(2 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_USHORT	(3 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_INT		(4 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_UINT		(5 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_FLOAT		(6 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_TYPE_DOUBLE	(7 << VAMASK_COLOR_TYPE_SHIFT)
#define VAMASK_COLOR_SIZE_3		(0 << VAMASK_COLOR_SIZE_SHIFT)
#define VAMASK_COLOR_SIZE_4		(1 << VAMASK_COLOR_SIZE_SHIFT)

#define VAMASK_NORMAL_TYPE_BYTE		(0 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_SHORT	(1 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_INT		(2 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_FLOAT	(3 << VAMASK_NORMAL_TYPE_SHIFT)
#define VAMASK_NORMAL_TYPE_DOUBLE	(4 << VAMASK_NORMAL_TYPE_SHIFT)

#define VAMASK_VERTEX_TYPE_SHORT	(0 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_TYPE_INT		(1 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_TYPE_FLOAT	(2 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_TYPE_DOUBLE	(3 << VAMASK_VERTEX_TYPE_SHIFT)
#define VAMASK_VERTEX_SIZE_2		(0 << VAMASK_VERTEX_SIZE_SHIFT)
#define VAMASK_VERTEX_SIZE_3		(1 << VAMASK_VERTEX_SIZE_SHIFT)
#define VAMASK_VERTEX_SIZE_4		(2 << VAMASK_VERTEX_SIZE_SHIFT)

// Constants used by DrawElements.  Do not modify them because
// glcltDrawElements assumes they have these values!
#define VA_DRAWELEM_MAP_SIZE     	256
#define VA_DRAWELEM_INDEX_SIZE	        (8*VA_DRAWELEM_MAP_SIZE)

// Constants used by DrawRangeElementsEXT : currently these map identically
// with DrawElements constants.
#define VA_DRAWRANGEELEM_MAX_VERTICES    VA_DRAWELEM_MAP_SIZE
#define VA_DRAWRANGEELEM_MAX_INDICES     VA_DRAWELEM_INDEX_SIZE

void FASTCALL __glInitVertexArray(__GLcontext *gc);
void FASTCALL VA_ValidateArrayPointers(__GLcontext *gc);
void FASTCALL VA_DrawElementsBegin(POLYARRAY *pa, GLenum mode, GLsizei count);
void FASTCALL VA_DrawElementsEnd(POLYARRAY *pa);
void FASTCALL VA_DrawElementsFlushPartialPrimitive(POLYARRAY *pa, GLenum mode);

extern GLint nReservedIndicesPartialBegin[];

typedef void (FASTCALL *pfnReducedElementsHandler)
    (__GLcontext *gc, GLenum mode,
     GLsizei iVertexCount, GLsizei iVertexBase, VAMAP *pvmVertices,
     GLsizei iElementCount, GLubyte *pbElements,
     GLboolean fPartial);

void FASTCALL glcltReducedElementsHandler(__GLcontext *gc,
                                          GLenum mode,
                                          GLsizei iVertexCount,
                                          GLsizei iVertexBase,
                                          VAMAP *pvmVertices,
                                          GLsizei iElementCount,
                                          GLubyte *pbElements,
                                          GLboolean fPartial);
void FASTCALL ReduceDrawElements(__GLcontext *gc,
                                 GLenum mode, GLsizei count, GLenum type,
                                 const GLvoid *pIn,
                                 pfnReducedElementsHandler pfnHandler);

#endif // __glarray_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\image.h ===
#ifndef _image_h_
#define _image_h_

/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.2 $
** $Date: 1992/10/06 16:22:55 $
*/

extern GLint APIPRIVATE __glImageSize(GLsizei width, GLsizei height, GLenum format, 
			   GLenum type);

extern void APIPRIVATE __glFillImage(__GLcontext *gc, GLsizei width, GLsizei height, 
			  GLenum format, GLenum type, const GLvoid *userdata, 
			  GLubyte *newimage);

extern void __glEmptyImage(__GLcontext *gc, GLsizei width, GLsizei height, 
			   GLenum format, GLenum type, const GLubyte *oldimage, 
			   GLvoid *userdata);

extern GLubyte __glMsbToLsbTable[256];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\global.h ===
#ifndef __glglobal_h_
#define __glglobal_h_

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "context.h"

/*
** Some misc constants
*/
#ifdef NT
// These constants can either be static memory constants or
// real constants.  This #if should be modified for each
// platform to optimize the constant type for the platform
// For example, the x86 FPU can only load from memory so having
// these constants as memory locations rather than values is
// a clear win
#if defined(_X86_) || defined(_ALPHA_) || defined(_MIPS_) || defined(_PPC_)

extern const double    __glDoubleTwo;
extern const double    __glDoubleMinusTwo;

#ifdef _ALPHA_
// On Alpha, register f31 always reads as zero.
#define __glZero		((__GLfloat) 0.0)
#else
extern const __GLfloat __glZero;
#endif

extern const __GLfloat __glOne;
extern const __GLfloat __glMinusOne;
extern const __GLfloat __glHalf;
extern const __GLfloat __glDegreesToRadians;
extern const __GLfloat __glPi;
extern const __GLfloat __glSqrt2;
extern const __GLfloat __glE;
extern const __GLfloat __glVal128;
extern const __GLfloat __glVal255;
extern const __GLfloat __glOneOver255;
extern const __GLfloat __glVal256;
extern const __GLfloat __glOneOver512;
extern const __GLfloat __glVal768;
extern const __GLfloat __glVal65535;
extern const __GLfloat __glVal65536;
extern const __GLfloat __glOneOver65535;
extern const __GLfloat __glTexSubDiv;
extern const __GLfloat __glVal2147483648;
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
extern const __GLfloat __glVal4294965000;
extern const __GLfloat __glOneOver4294965000;

#else // Real values

#define __glDoubleTwo		((double) 2.0)
#define __glDoubleMinusTwo	((double) -2.0)

#define __glZero		((__GLfloat) 0.0)
#define __glOne			((__GLfloat) 1.0)
#define __glMinusOne		((__GLfloat) -1.0)
#define __glHalf		((__GLfloat) 0.5)
#define __glDegreesToRadians	(__glPi / (__GLfloat) 180.0)
#define __glPi			((__GLfloat) 3.14159265358979323846)
#define __glSqrt2		((__GLfloat) 1.41421356237309504880)
#define __glE			((__GLfloat) 2.7182818284590452354)
#define __glVal128              ((__GLfloat) 128.0)
#define __glVal255		((__GLfloat) 255.0)
#define __glOneOver255		((__GLfloat) (1.0 / 255.0))
#define __glVal256              ((__GLfloat) 256.0)
#define __glOneOver512          ((__GLfloat) (1.0 / 512.0))
#define __glVal768              ((__GLfloat) 768.0)
#define __glVal65535		((__GLfloat) 65535.0)
#define __glVal65536	        ((__GLfloat) 65536.0)
#define __glOneOver65535	((__GLfloat) (1.0 / 65535.0))
#define __glVal2147483648       ((__GLfloat) 2147483648.0)
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#define __glVal4294965000	((__GLfloat) (4294965000.0))
#define __glOneOver4294965000	((__GLfloat) (1.0 / 4294965000.0))
#endif // Real values

#else

#define __glZero		((__GLfloat) 0.0)
#define __glOne			(gc->constants.one)
#define __glMinusOne		((__GLfloat) -1.0)
#define __glHalf		(gc->constants.half)
#define __glTwo			((__GLfloat) 2.0)
#define __glDegreesToRadians	(__glPi / (__GLfloat) 180.0)
#define __glPi			((__GLfloat) 3.14159265358979323846)
#define __glSqrt2		((__GLfloat) 1.41421356237309504880)
#define __glE			((__GLfloat) 2.7182818284590452354)
#define __glVal255		((__GLfloat) 255.0)
#define __glOneOver255		((__GLfloat) (1.0 / 255.0))
#define __glVal65535		((__GLfloat) 65535.0)
#define __glOneOver65535	((__GLfloat) (1.0 / 65535.0))
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#define __glVal4294965000	((__GLfloat) (4294965000.0))
#define __glOneOver4294965000	((__GLfloat) (1.0 / 4294965000.0))

#endif // NT

// This is used by the macro __GL_UB_TO_FLOAT which converts
// unsigned bytes to floats in the range [0,1].
extern GLfloat __glUByteToFloat[256];

// This is used by the macro __GL_B_TO_FLOAT for byte to float component
// conversion.
extern GLfloat __glByteToFloat[256];

// This is used by frustum clipping to determine which plane coordinate
// to use
extern GLuint __glFrustumOffsets[];

/************************************************************************/

#define __GL_SETUP() \
    __GLcontext *gc = GLTEB_SRVCONTEXT()

#define __GL_IN_BEGIN() \
    (gc->beginMode == __GL_IN_BEGIN)

#define __GL_SETUP_NOT_IN_BEGIN()	    \
    __GL_SETUP();			    \
    if (__GL_IN_BEGIN()) {		    \
	__glSetError(GL_INVALID_OPERATION); \
	return;				    \
    }

#define __GL_SETUP_NOT_IN_BEGIN_VALIDATE()	\
    __GL_SETUP();				\
    __GLbeginMode beginMode = gc->beginMode;	\
    if (beginMode != __GL_NOT_IN_BEGIN) {	\
	if (beginMode == __GL_NEED_VALIDATE) {	\
	    (*gc->procs.validate)(gc);		\
	    gc->beginMode = __GL_NOT_IN_BEGIN;	\
	} else {				\
	    __glSetError(GL_INVALID_OPERATION);	\
	    return;				\
	}					\
    }

#define __GL_SETUP_NOT_IN_BEGIN2()	    \
    __GL_SETUP();			    \
    if (__GL_IN_BEGIN()) {		    \
	__glSetError(GL_INVALID_OPERATION); \
	return 0;			    \
    }

#endif /* __glglobal_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\lighting.h ===
#ifndef __gllighting_h_
#define __gllighting_h_

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "xform.h"

/*
** Light state.  Contains all the user controllable lighting state.
** Most of the colors kept in user state are scaled to match the
** drawing surfaces color resolution.
**
** Exposed to the MCD as MCDMATERIAL.
*/

struct __GLmaterialStateRec {
    __GLcolor ambient;			/* unscaled */
    __GLcolor diffuse;			/* unscaled */
    __GLcolor specular;			/* unscaled */
    __GLcolor emissive;			/* scaled */
    __GLfloat specularExponent; 
#ifdef NT
// SGIBUG align it properly, otherwise GetMateriali returns wrong result!
    __GLfloat cmapa, cmapd, cmaps;
#else
    __GLfloat cmapa, cmaps, cmapd;
#endif
};

/*
** Exposed to the MCD as MCDLIGHTMODEL
*/
    
struct __GLlightModelStateRec {
    __GLcolor ambient;			/* scaled */
    GLboolean localViewer;
    GLboolean twoSided;
};

/*
** Partially exposed to the MCD as MCDLIGHT
*/

typedef struct {
    __GLcolor ambient;			/* scaled */
    __GLcolor diffuse;			/* scaled */
    __GLcolor specular;			/* scaled */
    __GLcoord position;
    __GLcoord positionEye;
    __GLcoord direction;
    __GLcoord directionEyeNorm;
    __GLfloat spotLightExponent;
    __GLfloat spotLightCutOffAngle;
    __GLfloat constantAttenuation;
    __GLfloat linearAttenuation;
    __GLfloat quadraticAttenuation;

    /* MCDLIGHT ends */

    /* Need both directionEyeNorm and directionEye because MCD 2.0 wants
       a normalized direction but glGetLightfv specifies that the value
       returned for spot direction is the pre-normalized eye coordinate
       direction */
    __GLcoord directionEye;
    struct __GLmatrixRec lightMatrix;
} __GLlightSourceState;

typedef struct {
    GLenum colorMaterialFace;
    GLenum colorMaterialParam;
    GLenum shadingModel;
    __GLlightModelState model;
    __GLmaterialState front;
    __GLmaterialState back;
    GLuint dirtyLights;
    __GLlightSourceState *source;
} __GLlightState;

/************************************************************************/

/*
** What bits are affected by color index anti-aliasing.  This isn't a
** really a changeable parameter (it is defined by the spec), but it
** is useful for documentation instead of a mysterious 4 or 16 sitting
** around in the code.
*/
#define __GL_CI_ANTI_ALIAS_BITS		4
#define __GL_CI_ANTI_ALIAS_DIVISOR	(1 << __GL_CI_ANTI_ALIAS_BITS)

/************************************************************************/

/*
** These macros are used to convert incoming color values into the
** abstract color range from 0.0 to 1.0
*/
#ifdef NT
#define __GL_B_TO_FLOAT(b)	(__glByteToFloat[(GLubyte)(b)])
#define __GL_UB_TO_FLOAT(ub)	(__glUByteToFloat[ub])
#define __GL_S_TO_FLOAT(s)	((((s)<<1) + 1) * __glOneOver65535)
#define __GL_US_TO_FLOAT(us)	((us) * __glOneOver65535)
#else
#define __GL_B_TO_FLOAT(b)	((((b)<<1) + 1) * gc->constants.oneOver255)
#define __GL_UB_TO_FLOAT(ub)	(gc->constants.uByteToFloat[ub])
#define __GL_S_TO_FLOAT(s)	((((s)<<1) + 1) * gc->constants.oneOver65535)
#define __GL_US_TO_FLOAT(us)	((us) * gc->constants.oneOver65535)
#endif

/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#ifdef NT
#define __GL_I_TO_FLOAT(i) \
	((((__GLfloat)(i) * (__GLfloat) 2.0) + 1) * \
	    __glOneOver4294965000)
#define __GL_UI_TO_FLOAT(ui) \
	((__GLfloat)(ui) * __glOneOver4294965000)
#else
#define __GL_I_TO_FLOAT(i) \
	((((__GLfloat)(i) * (__GLfloat) 2.0) + 1) * \
	    gc->constants.oneOver4294965000)
#define __GL_UI_TO_FLOAT(ui) \
	((__GLfloat)(ui) * gc->constants.oneOver4294965000)
#endif

/*
** Bloody "round towards 0" convention.  We could avoid these floor() calls
** were it not for that!
*/
#ifdef NT
#define __GL_FLOAT_TO_B(f) \
	((GLbyte) __GL_FLOORF(((f) * __glVal255) * __glHalf))
#define __GL_FLOAT_TO_UB(f) \
	((GLubyte) ((f) * __glVal255 + __glHalf))
#define __GL_FLOAT_TO_S(f) \
	((GLshort) __GL_FLOORF(((f) * __glVal65535) * __glHalf))
#define __GL_FLOAT_TO_US(f) \
	((GLushort) ((f) * __glVal65535 + __glHalf))
#else
#define __GL_FLOAT_TO_B(f) \
	((GLbyte) __GL_FLOORF(((f) * gc->constants.val255) * __glHalf))
#define __GL_FLOAT_TO_UB(f) \
	((GLubyte) ((f) * gc->constants.val255 + __glHalf))
#define __GL_FLOAT_TO_S(f) \
	((GLshort) __GL_FLOORF(((f) * gc->constants.val65535) * __glHalf))
#define __GL_FLOAT_TO_US(f) \
	((GLushort) ((f) * gc->constants.val65535 + __glHalf))
#endif

/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
#ifdef NT
#define __GL_FLOAT_TO_I(f) \
    ((GLint) __GL_FLOORF(((f) * __glVal4294965000) * __glHalf))
#define __GL_FLOAT_TO_UI(f) \
    ((GLuint) ((f) * __glVal4294965000 + __glHalf))
#else
#define __GL_FLOAT_TO_I(f) \
    ((GLint) __GL_FLOORF(((f) * gc->constants.val4294965000) * __glHalf))
#define __GL_FLOAT_TO_UI(f) \
    ((GLuint) ((f) * gc->constants.val4294965000 + __glHalf))
#endif

/*
** Mask the incoming color index (in floating point) against the
** maximum color index value for the color buffers.  Keep 4 bits
** of fractional precision.
*/
#define __GL_MASK_INDEXF(gc, val)			       \
    (((__GLfloat) (((GLint) ((val) * 16))		       \
		   & (((gc)->frontBuffer.redMax << 4) | 0xf))) \
     / (__GLfloat)16.0)

#define __GL_MASK_INDEXI(gc, val)			       \
    ((val) & (gc)->frontBuffer.redMax)

/************************************************************************/

/* 
** These two must be the same size, because they cache their tables in the
** same arena.
*/
#define __GL_SPEC_LOOKUP_TABLE_SIZE	256
#define __GL_SPOT_LOOKUP_TABLE_SIZE	__GL_SPEC_LOOKUP_TABLE_SIZE

typedef struct {
    GLint refcount;
    __GLfloat threshold, scale, exp;
    __GLfloat table[__GL_SPEC_LOOKUP_TABLE_SIZE];
} __GLspecLUTEntry;

__GLspecLUTEntry *__glCreateSpecLUT(__GLcontext *gc, __GLfloat exp);
void FASTCALL __glFreeSpecLUT(__GLcontext *gc, __GLspecLUTEntry *lut);
void FASTCALL __glInitLUTCache(__GLcontext *gc);
void FASTCALL __glFreeLUTCache(__GLcontext *gc);

#define __GL_LIGHT_UPDATE_FRONT_MATERIAL_AMBIENT

/*
** Per light source per material computed state.
*/
typedef struct __GLlightSourcePerMaterialMachineRec {
    __GLcolor ambient;		/* light ambient times material ambient */
    __GLcolor diffuse;		/* light diffuse times material diffuse */
    __GLcolor specular;		/* light specular times material specular */
} __GLlightSourcePerMaterialMachine;

/*
** Per light source computed state.
*/
struct __GLlightSourceMachineRec {
    /*
    ** ambient, diffuse and specular are each pre-multiplied by the
    ** material ambient, material diffuse and material specular.
    ** We use the face being lit to pick between the two sets.
    */
    __GLlightSourcePerMaterialMachine front, back;

    __GLlightSourceState *state;

    __GLfloat constantAttenuation;
    __GLfloat linearAttenuation;
    __GLfloat quadraticAttenuation;
    __GLfloat spotLightExponent;

    /* Position of the light source in eye coordinates */
    __GLcoord position;

    /* Direction of the light source in eye coordinates, normalize */
    __GLcoord direction;

    /* Cosine of the spot light cutoff angle */
    __GLfloat cosCutOffAngle;

    /* Precomputed attenuation, only when k1 and k2 are zero */
    __GLfloat attenuation;

    /* This will be set when the cut off angle != 180 */
    GLboolean isSpot;

    /* When possible, the normalized "h" value from the spec is pre-computed */
    __GLcoord hHat;

    /* Unit vector VPpli pre-computed (only when light is at infinity) */
    __GLcoord unitVPpli;

    /* sli and dli values pre-computed (color index mode only) */
    __GLfloat sli, dli;

    /* Link to next active light */
    __GLlightSourceMachine *next;

    /* Spot light exponent lookup table */
    __GLfloat *spotTable;

    /* Values used to avoid pow function during spot computations */
    __GLfloat threshold, scale;

    /* cache entry where this data came from */
    __GLspecLUTEntry *cache;

    /* Set to GL_TRUE if slow processing path is needed */
    GLboolean slowPath;

    /* temporary storage for hHat when original hHat is transformed into *
    /* normal space */
    __GLcoord tmpHHat;

    /* temporary storage for unitVPpli when original is transformed into *
    /* normal space */
    __GLcoord tmpUnitVPpli;
};

/*
** Per material computed state.
*/
struct __GLmaterialMachineRec {
#ifdef NT
    /*
    ** Sum of:
    **	invariant material emissive color (with respect to color material)
    **  invariant material ambient color * scene ambient color (with
    **    respect to color material)
    **
    ** This sum is carefully kept scaled.
    */
    __GLcolor paSceneColor;

    /*
    ** Cached values for the total emissive+ambient for a material, and
    ** the clamped version of this value which can be directly applied
    ** to backface vertices with no effective specular or diffuse components.
    */

    __GLcolor cachedEmissiveAmbient;
    __GLcolor cachedNonLit;
#else
    /*
    ** Sum of:
    **	material emissive color
    **  material ambient color * scene ambient color
    **
    ** This sum is carefully kept scaled.
    */
    __GLcolor sceneColor;
#endif

    /* Specular exponent */
    __GLfloat specularExponent;

    /* Specular exponent lookup table */
    __GLfloat *specTable;

    /* Values used to avoid pow function during specular computations */
    __GLfloat threshold, scale;

    /* cache entry where this data came from */
    __GLspecLUTEntry *cache;

    /* Scaled and clamped form of material diffuse alpha */
    __GLfloat alpha;

#ifdef NT
    /* color material change bits */
    GLuint    colorMaterialChange;
#endif
};

typedef struct {
    __GLlightSourceMachine *source;
    __GLmaterialMachine front, back;

    /* List of enabled light sources */
    __GLlightSourceMachine *sources;

    /* Current material color material (iff one material is being updated) */
    __GLmaterialState *cm;
    __GLmaterialMachine *cmm;

    /* Cache of lookup tables for spot lights and specular highlights */
    struct __GLspecLUTCache_Rec *lutCache;
} __GLlightMachine;

/* Values for cmParam */
#define __GL_EMISSION			0
#define __GL_AMBIENT			1
#define __GL_SPECULAR			2
#define __GL_AMBIENT_AND_DIFFUSE	3
#define __GL_DIFFUSE			4

extern void FASTCALL __glCopyCIColor(__GLcontext *gc, GLuint faceBit, __GLvertex *v);
extern void FASTCALL __glCopyRGBColor(__GLcontext *gc, GLuint faceBit, __GLvertex *v);

extern void FASTCALL __glClampRGBColor(__GLcontext *gc, __GLcolor *dst,
			      const __GLcolor *src);
extern void FASTCALL __glClampAndScaleColor(__GLcontext *gc);


/* Stuff for converting float colors */
extern void FASTCALL __glClampAndScaleColorf(__GLcontext *gc, __GLcolor *dst,
				    const GLfloat src[4]);
extern void FASTCALL __glClampColorf(__GLcontext *gc, __GLcolor *dst,
			    const GLfloat src[4]);
extern void FASTCALL __glScaleColorf(__GLcontext *gc, __GLcolor *dst,
			    const GLfloat src[4]);
extern void FASTCALL __glUnScaleColorf(__GLcontext *gc, GLfloat dst[4],
			      const __GLcolor *src);

/* Stuff for converting integer colors */
extern void FASTCALL __glClampAndScaleColori(__GLcontext *gc, __GLcolor *dst,
				    const GLint src[4]);
extern void FASTCALL __glClampColori(__GLcontext *gc, __GLcolor *dst,
			    const GLint src[4]);
extern void FASTCALL __glScaleColori(__GLcontext *gc, __GLcolor *dst,
			    const GLint src[4]);
extern void FASTCALL __glUnScaleColori(__GLcontext *gc, GLint dst[4],
			      const __GLcolor *src);

extern void FASTCALL __glTransformLightDirection(__GLcontext *gc,
					__GLlightSourceState *ls);

extern void FASTCALL __glValidateLighting(__GLcontext *gc);
extern void FASTCALL __glValidateMaterial(__GLcontext *gc, GLint front, GLint back);

/* Procs for handling color material changes */
extern void FASTCALL __glChangeOneMaterialColor(__GLcontext *gc);
extern void FASTCALL __glChangeBothMaterialColors(__GLcontext *gc);

/* Lighting procs */
extern void FASTCALL __glCalcRGBColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL __glFastCalcRGBColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL __glCalcCIColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL __glFastCalcCIColor(__GLcontext *gc, GLint face, __GLvertex *vx);
extern void FASTCALL ComputeColorMaterialChange(__GLcontext *gc);

#endif /* __gllighting_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\imfuncs.h ===
#ifndef __glimfuncs_h_
#define __glimfuncs_h_

/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"

extern void APIPRIVATE __glim_NewList(GLuint, GLenum);
extern void APIPRIVATE __glim_EndList(void);
extern void APIPRIVATE __glim_CallList(GLuint);
extern void APIPRIVATE __glim_CallLists(GLsizei, GLenum, const GLvoid *);
extern void APIPRIVATE __glim_DeleteLists(GLuint, GLsizei);
extern GLuint APIPRIVATE __glim_GenLists(GLsizei);
extern void APIPRIVATE __glim_ListBase(GLuint);
extern void APIPRIVATE __glim_DrawPolyArray(void *);
#ifdef NT
extern void APIPRIVATE __glim_Bitmap(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *, GLboolean);
#else
extern void APIPRIVATE __glim_Bitmap(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
#endif
extern void APIPRIVATE __glim_Color3b(GLbyte, GLbyte, GLbyte);
extern void APIPRIVATE __glim_Color3bv(const GLbyte *);
extern void APIPRIVATE __glim_Color3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Color3dv(const GLdouble *);
extern void APIPRIVATE __glim_Color3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Color3fv(const GLfloat *);
extern void APIPRIVATE __glim_Color3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_Color3iv(const GLint *);
extern void APIPRIVATE __glim_Color3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Color3sv(const GLshort *);
extern void APIPRIVATE __glim_Color3ub(GLubyte, GLubyte, GLubyte);
extern void APIPRIVATE __glim_Color3ubv(const GLubyte *);
extern void APIPRIVATE __glim_Color3ui(GLuint, GLuint, GLuint);
extern void APIPRIVATE __glim_Color3uiv(const GLuint *);
extern void APIPRIVATE __glim_Color3us(GLushort, GLushort, GLushort);
extern void APIPRIVATE __glim_Color3usv(const GLushort *);
extern void APIPRIVATE __glim_Color4b(GLbyte, GLbyte, GLbyte, GLbyte);
extern void APIPRIVATE __glim_Color4bv(const GLbyte *);
extern void APIPRIVATE __glim_Color4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Color4dv(const GLdouble *);
extern void APIPRIVATE __glim_Color4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Color4fv(const GLfloat *);
extern void APIPRIVATE __glim_Color4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_Color4iv(const GLint *);
extern void APIPRIVATE __glim_Color4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Color4sv(const GLshort *);
extern void APIPRIVATE __glim_Color4ub(GLubyte, GLubyte, GLubyte, GLubyte);
extern void APIPRIVATE __glim_Color4ubv(const GLubyte *);
extern void APIPRIVATE __glim_Color4ui(GLuint, GLuint, GLuint, GLuint);
extern void APIPRIVATE __glim_Color4uiv(const GLuint *);
extern void APIPRIVATE __glim_Color4us(GLushort, GLushort, GLushort, GLushort);
extern void APIPRIVATE __glim_Color4usv(const GLushort *);
extern void APIPRIVATE __glim_EdgeFlag(GLboolean);
extern void APIPRIVATE __glim_EdgeFlagv(const GLboolean *);
extern void APIPRIVATE __glim_End(void);
extern void APIPRIVATE __glim_Indexd(GLdouble);
extern void APIPRIVATE __glim_Indexdv(const GLdouble *);
extern void APIPRIVATE __glim_Indexf(GLfloat);
extern void APIPRIVATE __glim_Indexfv(const GLfloat *);
extern void APIPRIVATE __glim_Indexi(GLint);
extern void APIPRIVATE __glim_Indexiv(const GLint *);
extern void APIPRIVATE __glim_Indexs(GLshort);
extern void APIPRIVATE __glim_Indexsv(const GLshort *);
extern void APIPRIVATE __glim_Normal3b(GLbyte, GLbyte, GLbyte);
extern void APIPRIVATE __glim_Normal3bv(const GLbyte *);
extern void APIPRIVATE __glim_Normal3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Normal3dv(const GLdouble *);
extern void APIPRIVATE __glim_Normal3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Normal3fv(const GLfloat *);
extern void APIPRIVATE __glim_Normal3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_Normal3iv(const GLint *);
extern void APIPRIVATE __glim_Normal3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Normal3sv(const GLshort *);
extern void APIPRIVATE __glim_RasterPos2d(GLdouble, GLdouble);
extern void APIPRIVATE __glim_RasterPos2dv(const GLdouble *);
extern void APIPRIVATE __glim_RasterPos2f(GLfloat, GLfloat);
extern void APIPRIVATE __glim_RasterPos2fv(const GLfloat *);
extern void APIPRIVATE __glim_RasterPos2i(GLint, GLint);
extern void APIPRIVATE __glim_RasterPos2iv(const GLint *);
extern void APIPRIVATE __glim_RasterPos2s(GLshort, GLshort);
extern void APIPRIVATE __glim_RasterPos2sv(const GLshort *);
extern void APIPRIVATE __glim_RasterPos3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_RasterPos3dv(const GLdouble *);
extern void APIPRIVATE __glim_RasterPos3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_RasterPos3fv(const GLfloat *);
extern void APIPRIVATE __glim_RasterPos3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_RasterPos3iv(const GLint *);
extern void APIPRIVATE __glim_RasterPos3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_RasterPos3sv(const GLshort *);
extern void APIPRIVATE __glim_RasterPos4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_RasterPos4dv(const GLdouble *);
extern void APIPRIVATE __glim_RasterPos4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_RasterPos4fv(const GLfloat *);
extern void APIPRIVATE __glim_RasterPos4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_RasterPos4iv(const GLint *);
extern void APIPRIVATE __glim_RasterPos4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_RasterPos4sv(const GLshort *);
extern void APIPRIVATE __glim_Rectd(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Rectdv(const GLdouble *, const GLdouble *);
extern void APIPRIVATE __glim_Rectf(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Rectfv(const GLfloat *, const GLfloat *);
extern void APIPRIVATE __glim_Recti(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_Rectiv(const GLint *, const GLint *);
extern void APIPRIVATE __glim_Rects(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Rectsv(const GLshort *, const GLshort *);
extern void APIPRIVATE __glim_TexCoord1d(GLdouble);
extern void APIPRIVATE __glim_TexCoord1dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord1f(GLfloat);
extern void APIPRIVATE __glim_TexCoord1fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord1i(GLint);
extern void APIPRIVATE __glim_TexCoord1iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord1s(GLshort);
extern void APIPRIVATE __glim_TexCoord1sv(const GLshort *);
extern void APIPRIVATE __glim_TexCoord2d(GLdouble, GLdouble);
extern void APIPRIVATE __glim_TexCoord2dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord2f(GLfloat, GLfloat);
extern void APIPRIVATE __glim_TexCoord2fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord2i(GLint, GLint);
extern void APIPRIVATE __glim_TexCoord2iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord2s(GLshort, GLshort);
extern void APIPRIVATE __glim_TexCoord2sv(const GLshort *);
extern void APIPRIVATE __glim_TexCoord3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_TexCoord3dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_TexCoord3fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_TexCoord3iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_TexCoord3sv(const GLshort *);
extern void APIPRIVATE __glim_TexCoord4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_TexCoord4dv(const GLdouble *);
extern void APIPRIVATE __glim_TexCoord4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_TexCoord4fv(const GLfloat *);
extern void APIPRIVATE __glim_TexCoord4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_TexCoord4iv(const GLint *);
extern void APIPRIVATE __glim_TexCoord4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_TexCoord4sv(const GLshort *);
extern void APIPRIVATE __glim_Vertex2d(GLdouble, GLdouble);
extern void APIPRIVATE __glim_Vertex2dv(const GLdouble *);
extern void APIPRIVATE __glim_Vertex2f(GLfloat, GLfloat);
extern void APIPRIVATE __glim_Vertex2fv(const GLfloat *);
extern void APIPRIVATE __glim_Vertex2i(GLint, GLint);
extern void APIPRIVATE __glim_Vertex2iv(const GLint *);
extern void APIPRIVATE __glim_Vertex2s(GLshort, GLshort);
extern void APIPRIVATE __glim_Vertex2sv(const GLshort *);
extern void APIPRIVATE __glim_Vertex3d(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Vertex3dv(const GLdouble *);
extern void APIPRIVATE __glim_Vertex3f(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Vertex3fv(const GLfloat *);
extern void APIPRIVATE __glim_Vertex3i(GLint, GLint, GLint);
extern void APIPRIVATE __glim_Vertex3iv(const GLint *);
extern void APIPRIVATE __glim_Vertex3s(GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Vertex3sv(const GLshort *);
extern void APIPRIVATE __glim_Vertex4d(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Vertex4dv(const GLdouble *);
extern void APIPRIVATE __glim_Vertex4f(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Vertex4fv(const GLfloat *);
extern void APIPRIVATE __glim_Vertex4i(GLint, GLint, GLint, GLint);
extern void APIPRIVATE __glim_Vertex4iv(const GLint *);
extern void APIPRIVATE __glim_Vertex4s(GLshort, GLshort, GLshort, GLshort);
extern void APIPRIVATE __glim_Vertex4sv(const GLshort *);
extern void APIPRIVATE __glim_ClipPlane(GLenum, const GLdouble *);
extern void APIPRIVATE __glim_ColorMaterial(GLenum, GLenum);
extern void APIPRIVATE __glim_CullFace(GLenum);
extern void APIPRIVATE __glim_Fogf(GLenum, GLfloat);
extern void APIPRIVATE __glim_Fogfv(GLenum, const GLfloat *);
extern void APIPRIVATE __glim_Fogi(GLenum, GLint);
extern void APIPRIVATE __glim_Fogiv(GLenum, const GLint *);
extern void APIPRIVATE __glim_FrontFace(GLenum);
extern void APIPRIVATE __glim_Hint(GLenum, GLenum);
extern void APIPRIVATE __glim_Lightf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_Lightfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_Lighti(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_Lightiv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_LightModelf(GLenum, GLfloat);
extern void APIPRIVATE __glim_LightModelfv(GLenum, const GLfloat *);
extern void APIPRIVATE __glim_LightModeli(GLenum, GLint);
extern void APIPRIVATE __glim_LightModeliv(GLenum, const GLint *);
extern void APIPRIVATE __glim_LineStipple(GLint, GLushort);
extern void APIPRIVATE __glim_LineWidth(GLfloat);
extern void APIPRIVATE __glim_Materialf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_Materialfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_Materiali(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_Materialiv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_PointSize(GLfloat);
extern void APIPRIVATE __glim_PolygonMode(GLenum, GLenum);
#ifdef NT
extern void APIPRIVATE __glim_PolygonStipple(const GLubyte *, GLboolean);
#else
extern void APIPRIVATE __glim_PolygonStipple(const GLubyte *);
#endif
extern void APIPRIVATE __glim_Scissor(GLint, GLint, GLsizei, GLsizei);
extern void APIPRIVATE __glim_ShadeModel(GLenum);
extern void APIPRIVATE __glim_TexParameterf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_TexParameterfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_TexParameteri(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_TexParameteriv(GLenum, GLenum, const GLint *);
#ifdef NT
extern void APIPRIVATE __glim_TexImage1D(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *, GLboolean);
extern void APIPRIVATE __glim_TexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *, GLboolean);
#else
extern void APIPRIVATE __glim_TexImage1D(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
extern void APIPRIVATE __glim_TexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
#endif
extern void APIPRIVATE __glim_TexEnvf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_TexEnvfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_TexEnvi(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_TexEnviv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_TexGend(GLenum, GLenum, GLdouble);
extern void APIPRIVATE __glim_TexGendv(GLenum, GLenum, const GLdouble *);
extern void APIPRIVATE __glim_TexGenf(GLenum, GLenum, GLfloat);
extern void APIPRIVATE __glim_TexGenfv(GLenum, GLenum, const GLfloat *);
extern void APIPRIVATE __glim_TexGeni(GLenum, GLenum, GLint);
extern void APIPRIVATE __glim_TexGeniv(GLenum, GLenum, const GLint *);
extern void APIPRIVATE __glim_FeedbackBuffer(GLsizei, GLenum, GLfloat *);
extern void APIPRIVATE __glim_SelectBuffer(GLsizei, GLuint *);
extern GLint APIPRIVATE __glim_RenderMode(GLenum);
extern void APIPRIVATE __glim_InitNames(void);
extern void APIPRIVATE __glim_LoadName(GLuint);
extern void APIPRIVATE __glim_PassThrough(GLfloat);
extern void APIPRIVATE __glim_PopName(void);
extern void APIPRIVATE __glim_PushName(GLuint);
extern void APIPRIVATE __glim_DrawBuffer(GLenum);
extern void APIPRIVATE __glim_Clear(GLbitfield);
extern void APIPRIVATE __glim_ClearAccum(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_ClearIndex(GLfloat);
extern void APIPRIVATE __glim_ClearColor(GLclampf, GLclampf, GLclampf, GLclampf);
extern void APIPRIVATE __glim_ClearStencil(GLint);
extern void APIPRIVATE __glim_ClearDepth(GLclampd);
extern void APIPRIVATE __glim_StencilMask(GLuint);
extern void APIPRIVATE __glim_ColorMask(GLboolean, GLboolean, GLboolean, GLboolean);
extern void APIPRIVATE __glim_DepthMask(GLboolean);
extern void APIPRIVATE __glim_IndexMask(GLuint);
extern void APIPRIVATE __glim_Accum(GLenum, GLfloat);
extern void APIPRIVATE __glim_Disable(GLenum);
extern void APIPRIVATE __glim_Enable(GLenum);
extern void APIPRIVATE __glim_Finish(void);
extern void APIPRIVATE __glim_Flush(void);
extern void APIPRIVATE __glim_PopAttrib(void);
extern void APIPRIVATE __glim_PushAttrib(GLbitfield);
extern void APIPRIVATE __glim_AlphaFunc(GLenum, GLclampf);
extern void APIPRIVATE __glim_BlendFunc(GLenum, GLenum);
extern void APIPRIVATE __glim_LogicOp(GLenum);
extern void APIPRIVATE __glim_StencilFunc(GLenum, GLint, GLuint);
extern void APIPRIVATE __glim_StencilOp(GLenum, GLenum, GLenum);
extern void APIPRIVATE __glim_DepthFunc(GLenum);
extern void APIPRIVATE __glim_PixelZoom(GLfloat, GLfloat);
extern void APIPRIVATE __glim_PixelTransferf(GLenum, GLfloat);
extern void APIPRIVATE __glim_PixelTransferi(GLenum, GLint);
extern void APIPRIVATE __glim_PixelStoref(GLenum, GLfloat);
extern void APIPRIVATE __glim_PixelStorei(GLenum, GLint);
extern void APIPRIVATE __glim_PixelMapfv(GLenum, GLint, const GLfloat *);
extern void APIPRIVATE __glim_PixelMapuiv(GLenum, GLint, const GLuint *);
extern void APIPRIVATE __glim_PixelMapusv(GLenum, GLint, const GLushort *);
extern void APIPRIVATE __glim_ReadBuffer(GLenum);
extern void APIPRIVATE __glim_CopyPixels(GLint, GLint, GLsizei, GLsizei, GLenum);
extern void APIPRIVATE __glim_ReadPixels(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
#ifdef NT
extern void APIPRIVATE __glim_DrawPixels(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, GLboolean);
#else
extern void APIPRIVATE __glim_DrawPixels(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#endif
extern void APIPRIVATE __glim_GetBooleanv(GLenum, GLboolean *);
extern void APIPRIVATE __glim_GetClipPlane(GLenum, GLdouble *);
extern void APIPRIVATE __glim_GetDoublev(GLenum, GLdouble *);
extern GLenum APIPRIVATE __glim_GetError(void);
extern void APIPRIVATE __glim_GetFloatv(GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetIntegerv(GLenum, GLint *);
extern void APIPRIVATE __glim_GetLightfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetLightiv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetMapdv(GLenum, GLenum, GLdouble *);
extern void APIPRIVATE __glim_GetMapfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetMapiv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetMaterialfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetMaterialiv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetPixelMapfv(GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetPixelMapuiv(GLenum, GLuint *);
extern void APIPRIVATE __glim_GetPixelMapusv(GLenum, GLushort *);
extern void APIPRIVATE __glim_GetPolygonStipple(GLubyte *);
extern const GLubyte * APIPRIVATE __glim_GetString(GLenum);
extern void APIPRIVATE __glim_GetTexEnvfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexEnviv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetTexGendv(GLenum, GLenum, GLdouble *);
extern void APIPRIVATE __glim_GetTexGenfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexGeniv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetTexImage(GLenum, GLint, GLenum, GLenum, GLvoid *);
extern void APIPRIVATE __glim_GetTexParameterfv(GLenum, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexParameteriv(GLenum, GLenum, GLint *);
extern void APIPRIVATE __glim_GetTexLevelParameterfv(GLenum, GLint, GLenum, GLfloat *);
extern void APIPRIVATE __glim_GetTexLevelParameteriv(GLenum, GLint, GLenum, GLint *);
extern GLboolean APIPRIVATE __glim_IsEnabled(GLenum);
extern GLboolean APIPRIVATE __glim_IsList(GLuint);
extern void APIPRIVATE __glim_DepthRange(GLclampd, GLclampd);
extern void APIPRIVATE __glim_Frustum(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_LoadIdentity(void);
extern void APIPRIVATE __glim_LoadMatrixf(const GLfloat *);
extern void APIPRIVATE __glim_LoadMatrixd(const GLdouble *);
extern void APIPRIVATE __glim_MatrixMode(GLenum);
extern void APIPRIVATE __glim_MultMatrixf(const GLfloat *);
extern void APIPRIVATE __glim_MultMatrixd(const GLdouble *);
extern void APIPRIVATE __glim_Ortho(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_PopMatrix(void);
extern void APIPRIVATE __glim_PushMatrix(void);
extern void APIPRIVATE __glim_Rotated(GLdouble, GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Rotatef(GLfloat, GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Scaled(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Scalef(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Translated(GLdouble, GLdouble, GLdouble);
extern void APIPRIVATE __glim_Translatef(GLfloat, GLfloat, GLfloat);
extern void APIPRIVATE __glim_Viewport(GLint, GLint, GLsizei, GLsizei);
extern void APIPRIVATE __glim_AddSwapHintRectWIN(GLint, GLint, GLint, GLint);
extern GLboolean APIPRIVATE __glim_AreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences);
extern void APIPRIVATE __glim_BindTexture(GLenum target, GLuint texture);
extern void APIPRIVATE __glim_CopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border);
extern void APIPRIVATE __glim_CopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border);
extern void APIPRIVATE __glim_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width);
extern void APIPRIVATE __glim_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height);
extern void APIPRIVATE __glim_DeleteTextures(GLsizei n, const GLuint *textures);
extern void APIPRIVATE __glim_GenTextures(GLsizei n, GLuint *textures);
extern GLboolean APIPRIVATE __glim_IsTexture(GLuint texture);
extern void APIPRIVATE __glim_PrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities);
#ifdef NT
extern void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels, GLboolean _IsDlist);
extern void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels, GLboolean _IsDlist);
#else
extern void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels);
extern void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);
#endif

extern void APIPRIVATE __glim_PolygonOffset(GLfloat factor, GLfloat units);

#ifdef NT
extern void APIPRIVATE __glim_ColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data, GLboolean _IsDlist);
extern void APIPRIVATE __glim_ColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data, GLboolean _IsDlist);
extern void APIPRIVATE __glim_GetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data);
extern void APIPRIVATE __glim_GetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params);
extern void APIPRIVATE __glim_GetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params);
#endif

#ifdef GL_WIN_multiple_textures
extern void APIPRIVATE __glim_CurrentTextureIndexWIN(GLuint index);
extern void APIPRIVATE __glim_BindNthTextureWIN(GLuint index, GLenum target, GLuint texture);
extern void APIPRIVATE __glim_NthTexCombineFuncWIN(GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

extern void APIPRIVATE __glim_MipsVertex2fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex3fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex4fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex2fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex3fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex4fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex2fvFastest(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex3fvFastest(const GLfloat *);
extern void APIPRIVATE __glim_MipsVertex4fvFastest(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex2fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex3fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex4fv(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex2fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex3fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex4fvFast(const GLfloat *);
extern void APIPRIVATE __glim_MipsNoXFVertex2fvFast2D(const GLfloat *);

extern void APIPRIVATE __glim_FastColor3ub(GLubyte, GLubyte, GLubyte);
extern void APIPRIVATE __glim_FastColor3ubv(const GLubyte *);

#endif /* __glimfuncs_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\mcdcx.h ===
/******************************Module*Header*******************************\
* Module Name: mcdcx.h
*
* MCD support: structures, variables, constants, and functions.
*
* Created: 26-Feb-1996 12:30:41
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCDCX_H_
#define _MCDCX_H_

//
// Handy forward declaration.
//

typedef struct __GLGENbuffersRec __GLGENbuffers;
typedef struct __GLGENcontextRec __GLGENcontext;

//
// Macros to maintain MCD dirty state:
//
//  MCD_STATE_DIRTY     set specified dirty flag
//  MCD_STATE_CLEAR     clear specified dirty flag
//  MCD_STATE_RESET     clear all dirty flags
//  MCD_STATE_DIRTYTEST check state flag (TRUE if dirty)
//

#define MCD_STATE_DIRTY(gc, stateName)\
{\
    if (((__GLGENcontext *) (gc))->pMcdState)\
        ((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState |= MCD_DIRTY_##stateName;\
}
#define MCD_STATE_CLEAR(gc, stateName)\
{\
    if (((__GLGENcontext *) (gc))->pMcdState)\
        ((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState &= ~MCD_DIRTY_##stateName;\
}
#define MCD_STATE_RESET(gc)\
{\
    if (((__GLGENcontext *) (gc))->pMcdState)\
        ((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState = 0;\
}
#define MCD_STATE_DIRTYTEST(gc, stateName)\
(\
    (((__GLGENcontext *) (gc))->pMcdState) &&\
    (((__GLGENcontext *) (gc))->pMcdState->mcdDirtyState & MCD_DIRTY_##stateName)\
)

//
// MCD interface functions.  These functions call the MCD client interface.
// The function implementations are found in generic\mcdcx.c.
//

BOOL FASTCALL bInitMcd(HDC hdc);
BOOL FASTCALL bInitMcdContext(__GLGENcontext *, GLGENwindow *);
BOOL FASTCALL bInitMcdSurface(__GLGENcontext *, GLGENwindow *, __GLGENbuffers *);
void FASTCALL GenMcdDeleteContext(GENMCDSTATE *);
void FASTCALL GenMcdDeleteSurface(GENMCDSURFACE *);
BOOL FASTCALL GenMcdMakeCurrent(__GLGENcontext *gengc, GLGENwindow *pwnd);
void FASTCALL GenMcdInitDepth(__GLcontext *, __GLdepthBuffer *);
void FASTCALL GenMcdClear(__GLGENcontext *, ULONG *);
void FASTCALL GenMcdClearDepth16(__GLdepthBuffer *);
void FASTCALL GenMcdClearDepth32(__GLdepthBuffer *);
void FASTCALL GenMcdUpdateRenderState(__GLGENcontext *);
void FASTCALL GenMcdViewport(__GLGENcontext *);
void FASTCALL GenMcdScissor(__GLGENcontext *);
void FASTCALL GenMcdUpdateScissorState(__GLGENcontext *);
void FASTCALL GenMcdUpdateTexEnvState(__GLGENcontext *);
POLYARRAY * FASTCALL GenMcdDrawPrim(__GLGENcontext *, POLYARRAY *);
void FASTCALL GenMcdSwapBatch(__GLGENcontext *);
BOOL FASTCALL GenMcdSwapBuffers(HDC, GLGENwindow *pwnd);
BOOL FASTCALL GenMcdResizeBuffers(__GLGENcontext *);
BOOL FASTCALL GenMcdUpdateBufferInfo(__GLGENcontext *);
void GenMcdCopyPixels(__GLGENcontext *, __GLcolorBuffer *, GLint, GLint, GLint, BOOL);
void FASTCALL GenMcdSynchronize(__GLGENcontext *);
BOOL FASTCALL GenMcdConvertContext(__GLGENcontext *, __GLGENbuffers *);
PVOID FASTCALL GenMcdReadZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx);
void  FASTCALL GenMcdWriteZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx);
MCDHANDLE FASTCALL GenMcdCreateTexture(__GLGENcontext *gengc, __GLtexture *tex,
                                       ULONG flags);
BOOL FASTCALL GenMcdDeleteTexture(__GLGENcontext *gengc, MCDHANDLE texHandle);
BOOL FASTCALL GenMcdUpdateSubTexture(__GLGENcontext *ggenc, __GLtexture *tex,
                                     MCDHANDLE texHandle, GLint lod, 
                                     GLint xoffset, GLint yoffset, 
                                     GLsizei w, GLsizei h);
BOOL FASTCALL GenMcdUpdateTexturePalette(__GLGENcontext *gengc, __GLtexture *tex,
                                         MCDHANDLE texHandle, GLsizei start,
                                         GLsizei count);
BOOL FASTCALL GenMcdUpdateTexturePriority(__GLGENcontext *gengc, __GLtexture *tex,
                                          MCDHANDLE texHandle);
BOOL FASTCALL GenMcdUpdateTextureState(__GLGENcontext *gengc, __GLtexture *tex,
                                       MCDHANDLE texHandle);
void FASTCALL GenMcdUpdateFineState(__GLGENcontext *gengc);
DWORD FASTCALL GenMcdTextureStatus(__GLGENcontext *gengc, MCDHANDLE texHandle);
DWORD FASTCALL GenMcdTextureKey(__GLGENcontext *gengc, MCDHANDLE texHandle);
VOID FASTCALL GenMcdSetScaling(__GLGENcontext *gengc);
typedef enum { VP_FIXBIAS, VP_NOBIAS } VP_BIAS_TYPE;
BOOL FASTCALL GenMcdResetViewportAdj(__GLcontext *, VP_BIAS_TYPE);
BOOL FASTCALL GenMcdDescribeLayerPlane(HDC hdc, int iPixelFormat,
                                       int iLayerPlane, UINT nBytes,
                                       LPLAYERPLANEDESCRIPTOR plpd);
int  FASTCALL GenMcdSetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                           int iStart, int cEntries,
                                           CONST COLORREF *pcr);
int  FASTCALL GenMcdGetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                           int iStart, int cEntries,
                                           COLORREF *pcr);
int  FASTCALL GenMcdRealizeLayerPalette(HDC hdc, int iLayerPlane,
                                        BOOL bRealize);
BOOL FASTCALL GenMcdSwapLayerBuffers(HDC hdc, UINT fuFlags);
void FASTCALL GenMcdUpdatePixelState(__GLGENcontext *gengc);
ULONG FASTCALL GenMcdDrawPix(__GLGENcontext *gengc, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels, BOOL packed);
ULONG FASTCALL GenMcdReadPix(__GLGENcontext *gengc, LONG x, LONG y, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels);
ULONG FASTCALL GenMcdCopyPix(__GLGENcontext *gengc, LONG x, LONG y, ULONG width,
                             ULONG height, ULONG type);
ULONG FASTCALL GenMcdPixelMap(__GLGENcontext *gengc, ULONG mapType,
                              ULONG mapSize, VOID *pMap);
void FASTCALL GenMcdDestroyWindow(GLGENwindow *pwnd);
int FASTCALL GenMcdGetTextureFormats(__GLGENcontext *gengc, int nFmts,
                                     struct _DDSURFACEDESC *pddsd);
DWORD FASTCALL GenMcdSwapMultiple(UINT cBuffers, GENMCDSWAP *pgms);

// Note:
// GenMcdGenericCompatibleFormat is implemented in pixelfmt.c
BOOL FASTCALL GenMcdGenericCompatibleFormat(__GLGENcontext *gengc);

//
// Depth test drawing functions that utilize an intermediate scanline
// depth buffer to access the MCD depth buffer.
//

GLboolean FASTCALL GenMcdDepthTestLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStippledLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilStippledLine(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestSpan(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStippledSpan(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilSpan(__GLcontext *);
GLboolean FASTCALL GenMcdDepthTestStencilStippledSpan(__GLcontext *);
GLboolean FASTCALL GenMcdStippleAnyDepthTestSpan(__GLcontext *);

// 2.0 Front-end processing call
POLYARRAY * FASTCALL GenMcdProcessPrim(__GLGENcontext *gengc, POLYARRAY *pa,
                                       ULONG cmdFlagsAll, ULONG primFlags,
                                       MCDTRANSFORM *pMCDTransform,
                                       MCDMATERIALCHANGES *pMCDMatChanges);

//
// "Safe" version of __fastGenFillTriangle that does not allow floating
// point divides to straddle an MCD function call.
//

extern void FASTCALL __fastGenMcdFillTriangle(__GLcontext *, __GLvertex *,
                                     __GLvertex *, __GLvertex *, GLboolean);

//
// MCD32.DLL entry points.
//
// Rather than link directly to MCD32.DLL (thereby requiring its existence
// to run OPENGL32.DLL), we load it and hook its entry points as needed.
// This table stores the function pointers we hook.
//

typedef BOOL     (APIENTRY *MCDGETDRIVERINFOFUNC)(HDC hdc, struct _MCDDRIVERINFOI *pMCDDriverInfo);
typedef LONG     (APIENTRY *MCDDESCRIBEMCDPIXELFORMATFUNC)(HDC hdc, LONG iPixelFormat,
                                                           MCDPIXELFORMAT *pMcdPixelFmt);
typedef LONG     (APIENTRY *MCDDESCRIBEPIXELFORMATFUNC)(HDC hdc, LONG iPixelFormat,
                                                        LPPIXELFORMATDESCRIPTOR ppfd);
typedef BOOL     (APIENTRY *MCDCREATECONTEXTFUNC)(MCDCONTEXT *pMCDContext,
                                                  MCDRCINFOPRIV *pMcdRcInfo,
                                                  struct _GLSURF *pgsurf,
                                                  int ipfd,
                                                  ULONG flags);
typedef BOOL      (APIENTRY *MCDDELETECONTEXTFUNC)(MCDCONTEXT *pMCDContext);
typedef UCHAR *   (APIENTRY *MCDALLOCFUNC)(MCDCONTEXT *pMCDContext, ULONG numBytes, MCDHANDLE *pMCDHandle,
                                           ULONG flags);
typedef BOOL      (APIENTRY *MCDFREEFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
typedef VOID      (APIENTRY *MCDBEGINSTATEFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
typedef BOOL      (APIENTRY *MCDFLUSHSTATEFUNC)(VOID *pMCDMem);
typedef BOOL      (APIENTRY *MCDADDSTATEFUNC)(VOID *pMCDMem, ULONG stateToChange,
                                              ULONG stateValue);
typedef BOOL      (APIENTRY *MCDADDSTATESTRUCTFUNC)(VOID *pMCDMem, ULONG stateToChange,
                                                    VOID *pStateValue, ULONG stateValueSize);
typedef BOOL      (APIENTRY *MCDSETVIEWPORTFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                                 MCDVIEWPORT *pMCDViewport);
typedef BOOL      (APIENTRY *MCDSETSCISSORRECTFUNC)(MCDCONTEXT *pMCDContext, RECTL *pRect,
                                                    BOOL bEnabled);
typedef ULONG     (APIENTRY *MCDQUERYMEMSTATUSFUNC)(VOID *pMCDMem);
typedef PVOID     (APIENTRY *MCDPROCESSBATCHFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                                  ULONG batchSize, VOID *pMCDFirstCmd,
                                                  int cExtraSurfaces,
                                                  struct IDirectDrawSurface **pdds);
typedef BOOL      (APIENTRY *MCDREADSPANFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                              ULONG x, ULONG y, ULONG numPixels, ULONG type);
typedef BOOL      (APIENTRY *MCDWRITESPANFUNC)(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                                               ULONG x, ULONG y, ULONG numPixels, ULONG type);
typedef BOOL      (APIENTRY *MCDCLEARFUNC)(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers);
typedef BOOL      (APIENTRY *MCDSWAPFUNC)(MCDCONTEXT *pMCDContext, ULONG flags);
typedef BOOL      (APIENTRY *MCDGETBUFFERSFUNC)(MCDCONTEXT *pMCDContext, MCDRECTBUFFERS *pMCDBuffers);
typedef BOOL      (APIENTRY *MCDALLOCBUFFERSFUNC)(MCDCONTEXT *pMCDContext, RECTL *pWndRect);
typedef ULONG     (APIENTRY *MCDLOCKFUNC)(MCDCONTEXT *pMCDContext);
typedef VOID      (APIENTRY *MCDUNLOCKFUNC)(MCDCONTEXT *pMCDContext);
typedef BOOL      (APIENTRY *MCDBINDCONTEXT)(MCDCONTEXT *pMCDContext, HDC hdc,
                                             struct GLGENwindowRec *pwnd);
typedef BOOL      (APIENTRY *MCDSYNCFUNC)(MCDCONTEXT *pMCDContext);
typedef MCDHANDLE (APIENTRY *MCDCREATETEXTUREFUNC)(MCDCONTEXT *pMCDContext, 
                                MCDTEXTUREDATA *pTexData,
                                ULONG flags, VOID *pSurface);
typedef BOOL      (APIENTRY *MCDDELETETEXTUREFUNC)(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
typedef BOOL      (APIENTRY *MCDUPDATESUBTEXTUREFUNC)(MCDCONTEXT *pMCDContext,
                                MCDTEXTUREDATA *pTexData, MCDHANDLE hTex, 
                                ULONG lod, RECTL *pRect);
typedef BOOL      (APIENTRY *MCDUPDATETEXTUREPALETTEFUNC)(MCDCONTEXT *pMCDContext, 
                                MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                ULONG start, ULONG numEntries);
typedef BOOL      (APIENTRY *MCDUPDATETEXTUREPRIORITYFUNC)(MCDCONTEXT *pMCDContext, 
                                MCDTEXTUREDATA *pTexData,
                                MCDHANDLE hTex);
typedef ULONG     (APIENTRY *MCDTEXTURESTATUSFUNC)(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
typedef ULONG     (APIENTRY *MCDTEXTUREKEYFUNC)(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
typedef BOOL      (APIENTRY *MCDDESCRIBEMCDLAYERPLANEFUNC)(HDC hdc,
                                LONG iPixelFormat, LONG iLayerPlane,
                                MCDLAYERPLANE *pMcdLayer);
typedef BOOL      (APIENTRY *MCDDESCRIBELAYERPLANEFUNC)(HDC hdc,
                                LONG iPixelFormat, LONG iLayerPlane,
                                LPLAYERPLANEDESCRIPTOR plpd);
typedef LONG      (APIENTRY *MCDSETLAYERPALETTEFUNC)(HDC hdc, LONG iLayerPlane,
                                BOOL bRealize, LONG cEntries, COLORREF *pcr);
typedef ULONG     (APIENTRY *MCDDRAWPIXELS)(MCDCONTEXT *pMCDContext, ULONG width,
                                ULONG height, ULONG format, ULONG type,
                                VOID *pPixels, BOOL packed);
typedef ULONG     (APIENTRY *MCDREADPIXELS)(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width,
                                ULONG height, ULONG format, ULONG type,
                                VOID *pPixels);
typedef ULONG     (APIENTRY *MCDCOPYPIXELS)(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width,
                                ULONG height, ULONG type);
typedef ULONG     (APIENTRY *MCDPIXELMAP)(MCDCONTEXT *pMCDContext, ULONG mapType,
                                ULONG mapSize, VOID *pMap);
typedef void      (APIENTRY *MCDDESTROYWINDOW)(HDC hdc, ULONG_PTR dwMcdWindow);
typedef int       (APIENTRY *MCDGETTEXTUREFORMATS)(MCDCONTEXT *pMCDContext,
                                                   int nFmts,
                                                   struct _DDSURFACEDESC *pddsd);
typedef DWORD     (APIENTRY *MCDSWAPMULTIPLE)(HDC hdc,
                                              UINT cBuffers,
                                              GENMCDSWAP *pgms);

typedef PVOID     (APIENTRY *MCDPROCESSBATCH2FUNC)(MCDCONTEXT *pMCDContext,
                                                   VOID *pMCDCmdMem,
                                                   VOID *pMCDPrimMem,
                                                   MCDCOMMAND *pMCDFirstCmd,
                                                   int cExtraSurfaces,
                                                   struct
                                                   IDirectDrawSurface **pdds,
                                                   ULONG cmdFlagsAll,
                                                   ULONG primFlags,
                                                   MCDTRANSFORM *pMCDTransform,
                                                   MCDMATERIALCHANGES
                                                   *pMCDMatChanges);

typedef struct _MCDTABLE_ {
    MCDGETDRIVERINFOFUNC            pMCDGetDriverInfo;
    MCDDESCRIBEMCDPIXELFORMATFUNC   pMCDDescribeMcdPixelFormat;
    MCDDESCRIBEPIXELFORMATFUNC      pMCDDescribePixelFormat;
    MCDCREATECONTEXTFUNC            pMCDCreateContext;
    MCDDELETECONTEXTFUNC            pMCDDeleteContext;
    MCDALLOCFUNC                    pMCDAlloc;
    MCDFREEFUNC                     pMCDFree;
    MCDBEGINSTATEFUNC               pMCDBeginState;
    MCDFLUSHSTATEFUNC               pMCDFlushState;
    MCDADDSTATEFUNC                 pMCDAddState;
    MCDADDSTATESTRUCTFUNC           pMCDAddStateStruct;
    MCDSETVIEWPORTFUNC              pMCDSetViewport;
    MCDSETSCISSORRECTFUNC           pMCDSetScissorRect;
    MCDQUERYMEMSTATUSFUNC           pMCDQueryMemStatus;
    MCDPROCESSBATCHFUNC             pMCDProcessBatch;
    MCDREADSPANFUNC                 pMCDReadSpan;
    MCDWRITESPANFUNC                pMCDWriteSpan;
    MCDCLEARFUNC                    pMCDClear;
    MCDSWAPFUNC                     pMCDSwap;
    MCDGETBUFFERSFUNC               pMCDGetBuffers;
    MCDALLOCBUFFERSFUNC             pMCDAllocBuffers;
    MCDLOCKFUNC                     pMCDLock;
    MCDUNLOCKFUNC                   pMCDUnlock;
    MCDBINDCONTEXT                  pMCDBindContext;
    MCDSYNCFUNC                     pMCDSync;
    MCDCREATETEXTUREFUNC            pMCDCreateTexture;
    MCDDELETETEXTUREFUNC            pMCDDeleteTexture;
    MCDUPDATESUBTEXTUREFUNC         pMCDUpdateSubTexture;
    MCDUPDATETEXTUREPALETTEFUNC     pMCDUpdateTexturePalette;
    MCDUPDATETEXTUREPRIORITYFUNC    pMCDUpdateTexturePriority;
    MCDUPDATETEXTUREPRIORITYFUNC    pMCDUpdateTextureState;
    MCDTEXTURESTATUSFUNC            pMCDTextureStatus;
    MCDTEXTUREKEYFUNC               pMCDTextureKey;
    MCDDESCRIBEMCDLAYERPLANEFUNC    pMCDDescribeMcdLayerPlane;
    MCDDESCRIBELAYERPLANEFUNC       pMCDDescribeLayerPlane;
    MCDSETLAYERPALETTEFUNC          pMCDSetLayerPalette;
    MCDDRAWPIXELS                   pMCDDrawPixels;
    MCDREADPIXELS                   pMCDReadPixels;
    MCDCOPYPIXELS                   pMCDCopyPixels;
    MCDPIXELMAP                     pMCDPixelMap;
    MCDDESTROYWINDOW                pMCDDestroyWindow;
    MCDGETTEXTUREFORMATS            pMCDGetTextureFormats;
    MCDSWAPMULTIPLE                 pMCDSwapMultiple;
    MCDPROCESSBATCH2FUNC            pMCDProcessBatch2;
} MCDTABLE;

extern MCDTABLE *gpMcdTable;
extern MCDDRIVERINFOI McdDriverInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\listcomp.h ===
#ifndef __gl_g_lcomp_h
#define __gl_g_lcomp_h

/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define __GL_PAD(x) ((((x) + 3) >> 2) << 2)


struct __gllc_CallList_Rec {
	GLuint	list;
};

extern const GLubyte * FASTCALL __glle_CallList(__GLcontext *, const GLubyte *);

struct __gllc_CallLists_Rec {
	GLsizei	n;
	GLenum	type;
	/*	lists	*/
};

extern const GLubyte * FASTCALL __glle_CallLists(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glCallLists_size(GLsizei n, GLenum type);

struct __gllc_ListBase_Rec {
	GLuint	base;
};

extern const GLubyte * FASTCALL __glle_ListBase(__GLcontext *, const GLubyte *);

struct __gllc_Begin_Rec {
	GLenum	mode;
#ifdef NT
	GLuint	flags;
	GLint	nVertices;
	__GLcolor otherColor;
#endif
};

extern const GLubyte * FASTCALL __glle_Begin(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_Bitmap(__GLcontext *, const GLubyte *);

struct __gllc_Color3b_Rec {
	GLbyte	red;
	GLbyte	green;
	GLbyte	blue;
	GLubyte	pad1;
};


struct __gllc_Color3bv_Rec {
	GLbyte	v[3];
	GLubyte	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3bv(__GLcontext *, const GLubyte *);

struct __gllc_Color3d_Rec {
	GLdouble	red;
	GLdouble	green;
	GLdouble	blue;
};


struct __gllc_Color3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3dv(__GLcontext *, const GLubyte *);

struct __gllc_Color3f_Rec {
	GLfloat	red;
	GLfloat	green;
	GLfloat	blue;
};


struct __gllc_Color3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3fv(__GLcontext *, const GLubyte *);

struct __gllc_Color3i_Rec {
	GLint	red;
	GLint	green;
	GLint	blue;
};


struct __gllc_Color3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3iv(__GLcontext *, const GLubyte *);

struct __gllc_Color3s_Rec {
	GLshort	red;
	GLshort	green;
	GLshort	blue;
	GLushort	pad1;
};


struct __gllc_Color3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3sv(__GLcontext *, const GLubyte *);

struct __gllc_Color3ub_Rec {
	GLubyte	red;
	GLubyte	green;
	GLubyte	blue;
	GLubyte	pad1;
};


struct __gllc_Color3ubv_Rec {
	GLubyte	v[3];
	GLubyte	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3ubv(__GLcontext *, const GLubyte *);

struct __gllc_Color3ui_Rec {
	GLuint	red;
	GLuint	green;
	GLuint	blue;
};


struct __gllc_Color3uiv_Rec {
	GLuint	v[3];
};

extern const GLubyte * FASTCALL __glle_Color3uiv(__GLcontext *, const GLubyte *);

struct __gllc_Color3us_Rec {
	GLushort	red;
	GLushort	green;
	GLushort	blue;
	GLushort	pad1;
};


struct __gllc_Color3usv_Rec {
	GLushort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Color3usv(__GLcontext *, const GLubyte *);

struct __gllc_Color4b_Rec {
	GLbyte	red;
	GLbyte	green;
	GLbyte	blue;
	GLbyte	alpha;
};


struct __gllc_Color4bv_Rec {
	GLbyte	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4bv(__GLcontext *, const GLubyte *);

struct __gllc_Color4d_Rec {
	GLdouble	red;
	GLdouble	green;
	GLdouble	blue;
	GLdouble	alpha;
};


struct __gllc_Color4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4dv(__GLcontext *, const GLubyte *);

struct __gllc_Color4f_Rec {
	GLfloat	red;
	GLfloat	green;
	GLfloat	blue;
	GLfloat	alpha;
};


struct __gllc_Color4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4fv(__GLcontext *, const GLubyte *);

struct __gllc_Color4i_Rec {
	GLint	red;
	GLint	green;
	GLint	blue;
	GLint	alpha;
};


struct __gllc_Color4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4iv(__GLcontext *, const GLubyte *);

struct __gllc_Color4s_Rec {
	GLshort	red;
	GLshort	green;
	GLshort	blue;
	GLshort	alpha;
};


struct __gllc_Color4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4sv(__GLcontext *, const GLubyte *);

struct __gllc_Color4ub_Rec {
	GLubyte	red;
	GLubyte	green;
	GLubyte	blue;
	GLubyte	alpha;
};


struct __gllc_Color4ubv_Rec {
	GLubyte	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4ubv(__GLcontext *, const GLubyte *);

struct __gllc_Color4ui_Rec {
	GLuint	red;
	GLuint	green;
	GLuint	blue;
	GLuint	alpha;
};


struct __gllc_Color4uiv_Rec {
	GLuint	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4uiv(__GLcontext *, const GLubyte *);

struct __gllc_Color4us_Rec {
	GLushort	red;
	GLushort	green;
	GLushort	blue;
	GLushort	alpha;
};


struct __gllc_Color4usv_Rec {
	GLushort	v[4];
};

extern const GLubyte * FASTCALL __glle_Color4usv(__GLcontext *, const GLubyte *);

struct __gllc_EdgeFlag_Rec {
	GLboolean	flag;
	GLubyte	pad1;
	GLubyte	pad2;
	GLubyte	pad3;
};


struct __gllc_EdgeFlagv_Rec {
	GLboolean	flag[1];
	GLubyte	pad1;
	GLubyte	pad2;
	GLubyte	pad3;
};

extern const GLubyte * FASTCALL __glle_EdgeFlag(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_End(__GLcontext *, const GLubyte *);

struct __gllc_Indexd_Rec {
	GLdouble	c;
};


struct __gllc_Indexdv_Rec {
	GLdouble	c[1];
};

extern const GLubyte * FASTCALL __glle_Indexdv(__GLcontext *, const GLubyte *);

struct __gllc_Indexf_Rec {
	GLfloat	c;
};


struct __gllc_Indexfv_Rec {
	GLfloat	c[1];
};

extern const GLubyte * FASTCALL __glle_Indexf(__GLcontext *, const GLubyte *);

struct __gllc_Indexi_Rec {
	GLint	c;
};


struct __gllc_Indexiv_Rec {
	GLint	c[1];
};

extern const GLubyte * FASTCALL __glle_Indexiv(__GLcontext *, const GLubyte *);

struct __gllc_Indexs_Rec {
	GLshort	c;
	GLushort	pad1;
};


struct __gllc_Indexsv_Rec {
	GLshort	c[1];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Indexsv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3b_Rec {
	GLbyte	nx;
	GLbyte	ny;
	GLbyte	nz;
	GLubyte	pad1;
};


struct __gllc_Normal3bv_Rec {
	GLbyte	v[3];
	GLubyte	pad1;
};

extern const GLubyte * FASTCALL __glle_Normal3bv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3d_Rec {
	GLdouble	nx;
	GLdouble	ny;
	GLdouble	nz;
};


struct __gllc_Normal3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_Normal3dv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3f_Rec {
	GLfloat	nx;
	GLfloat	ny;
	GLfloat	nz;
};


struct __gllc_Normal3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_Normal3fv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3i_Rec {
	GLint	nx;
	GLint	ny;
	GLint	nz;
};


struct __gllc_Normal3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_Normal3iv(__GLcontext *, const GLubyte *);

struct __gllc_Normal3s_Rec {
	GLshort	nx;
	GLshort	ny;
	GLshort	nz;
	GLushort	pad1;
};


struct __gllc_Normal3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Normal3sv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2d_Rec {
	GLdouble	x;
	GLdouble	y;
};


struct __gllc_RasterPos2dv_Rec {
	GLdouble	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2dv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2f_Rec {
	GLfloat	x;
	GLfloat	y;
};


struct __gllc_RasterPos2fv_Rec {
	GLfloat	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2f(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2i_Rec {
	GLint	x;
	GLint	y;
};


struct __gllc_RasterPos2iv_Rec {
	GLint	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2iv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos2s_Rec {
	GLshort	x;
	GLshort	y;
};


struct __gllc_RasterPos2sv_Rec {
	GLshort	v[2];
};

extern const GLubyte * FASTCALL __glle_RasterPos2sv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};


struct __gllc_RasterPos3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_RasterPos3dv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};


struct __gllc_RasterPos3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_RasterPos3fv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
};


struct __gllc_RasterPos3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_RasterPos3iv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos3s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLushort	pad1;
};


struct __gllc_RasterPos3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_RasterPos3sv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
	GLdouble	w;
};


struct __gllc_RasterPos4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4dv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
	GLfloat	w;
};


struct __gllc_RasterPos4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4fv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
	GLint	w;
};


struct __gllc_RasterPos4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4iv(__GLcontext *, const GLubyte *);

struct __gllc_RasterPos4s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLshort	w;
};


struct __gllc_RasterPos4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_RasterPos4sv(__GLcontext *, const GLubyte *);

struct __gllc_Rectd_Rec {
	GLdouble	x1;
	GLdouble	y1;
	GLdouble	x2;
	GLdouble	y2;
};


struct __gllc_Rectdv_Rec {
	GLdouble	v1[2];
	GLdouble	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectdv(__GLcontext *, const GLubyte *);

struct __gllc_Rectf_Rec {
	GLfloat	x1;
	GLfloat	y1;
	GLfloat	x2;
	GLfloat	y2;
};


struct __gllc_Rectfv_Rec {
	GLfloat	v1[2];
	GLfloat	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectf(__GLcontext *, const GLubyte *);

struct __gllc_Recti_Rec {
	GLint	x1;
	GLint	y1;
	GLint	x2;
	GLint	y2;
};


struct __gllc_Rectiv_Rec {
	GLint	v1[2];
	GLint	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectiv(__GLcontext *, const GLubyte *);

struct __gllc_Rects_Rec {
	GLshort	x1;
	GLshort	y1;
	GLshort	x2;
	GLshort	y2;
};


struct __gllc_Rectsv_Rec {
	GLshort	v1[2];
	GLshort	v2[2];
};

extern const GLubyte * FASTCALL __glle_Rectsv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1d_Rec {
	GLdouble	s;
};


struct __gllc_TexCoord1dv_Rec {
	GLdouble	v[1];
};

extern const GLubyte * FASTCALL __glle_TexCoord1dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1f_Rec {
	GLfloat	s;
};


struct __gllc_TexCoord1fv_Rec {
	GLfloat	v[1];
};

extern const GLubyte * FASTCALL __glle_TexCoord1f(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1i_Rec {
	GLint	s;
};


struct __gllc_TexCoord1iv_Rec {
	GLint	v[1];
};

extern const GLubyte * FASTCALL __glle_TexCoord1iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord1s_Rec {
	GLshort	s;
	GLushort	pad1;
};


struct __gllc_TexCoord1sv_Rec {
	GLshort	v[1];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_TexCoord1sv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2d_Rec {
	GLdouble	s;
	GLdouble	t;
};


struct __gllc_TexCoord2dv_Rec {
	GLdouble	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2f_Rec {
	GLfloat	s;
	GLfloat	t;
};


struct __gllc_TexCoord2fv_Rec {
	GLfloat	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2f(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2i_Rec {
	GLint	s;
	GLint	t;
};


struct __gllc_TexCoord2iv_Rec {
	GLint	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord2s_Rec {
	GLshort	s;
	GLshort	t;
};


struct __gllc_TexCoord2sv_Rec {
	GLshort	v[2];
};

extern const GLubyte * FASTCALL __glle_TexCoord2sv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3d_Rec {
	GLdouble	s;
	GLdouble	t;
	GLdouble	r;
};


struct __gllc_TexCoord3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_TexCoord3dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3f_Rec {
	GLfloat	s;
	GLfloat	t;
	GLfloat	r;
};


struct __gllc_TexCoord3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_TexCoord3fv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3i_Rec {
	GLint	s;
	GLint	t;
	GLint	r;
};


struct __gllc_TexCoord3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_TexCoord3iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord3s_Rec {
	GLshort	s;
	GLshort	t;
	GLshort	r;
	GLushort	pad1;
};


struct __gllc_TexCoord3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_TexCoord3sv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4d_Rec {
	GLdouble	s;
	GLdouble	t;
	GLdouble	r;
	GLdouble	q;
};


struct __gllc_TexCoord4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4dv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4f_Rec {
	GLfloat	s;
	GLfloat	t;
	GLfloat	r;
	GLfloat	q;
};


struct __gllc_TexCoord4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4fv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4i_Rec {
	GLint	s;
	GLint	t;
	GLint	r;
	GLint	q;
};


struct __gllc_TexCoord4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4iv(__GLcontext *, const GLubyte *);

struct __gllc_TexCoord4s_Rec {
	GLshort	s;
	GLshort	t;
	GLshort	r;
	GLshort	q;
};


struct __gllc_TexCoord4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_TexCoord4sv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2d_Rec {
	GLdouble	x;
	GLdouble	y;
};


struct __gllc_Vertex2dv_Rec {
	GLdouble	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2dv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2f_Rec {
	GLfloat	x;
	GLfloat	y;
};


struct __gllc_Vertex2fv_Rec {
	GLfloat	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2f(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2i_Rec {
	GLint	x;
	GLint	y;
};


struct __gllc_Vertex2iv_Rec {
	GLint	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2iv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex2s_Rec {
	GLshort	x;
	GLshort	y;
};


struct __gllc_Vertex2sv_Rec {
	GLshort	v[2];
};

extern const GLubyte * FASTCALL __glle_Vertex2sv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};


struct __gllc_Vertex3dv_Rec {
	GLdouble	v[3];
};

extern const GLubyte * FASTCALL __glle_Vertex3dv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};


struct __gllc_Vertex3fv_Rec {
	GLfloat	v[3];
};

extern const GLubyte * FASTCALL __glle_Vertex3fv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
};


struct __gllc_Vertex3iv_Rec {
	GLint	v[3];
};

extern const GLubyte * FASTCALL __glle_Vertex3iv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex3s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLushort	pad1;
};


struct __gllc_Vertex3sv_Rec {
	GLshort	v[3];
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_Vertex3sv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4d_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
	GLdouble	w;
};


struct __gllc_Vertex4dv_Rec {
	GLdouble	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4dv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4f_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
	GLfloat	w;
};


struct __gllc_Vertex4fv_Rec {
	GLfloat	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4fv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4i_Rec {
	GLint	x;
	GLint	y;
	GLint	z;
	GLint	w;
};


struct __gllc_Vertex4iv_Rec {
	GLint	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4iv(__GLcontext *, const GLubyte *);

struct __gllc_Vertex4s_Rec {
	GLshort	x;
	GLshort	y;
	GLshort	z;
	GLshort	w;
};


struct __gllc_Vertex4sv_Rec {
	GLshort	v[4];
};

extern const GLubyte * FASTCALL __glle_Vertex4sv(__GLcontext *, const GLubyte *);

struct __gllc_ClipPlane_Rec {
	GLdouble	equation[4];
	GLenum	plane;
};

extern const GLubyte * FASTCALL __glle_ClipPlane(__GLcontext *, const GLubyte *);

struct __gllc_ColorMaterial_Rec {
	GLenum	face;
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_ColorMaterial(__GLcontext *, const GLubyte *);

struct __gllc_CullFace_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_CullFace(__GLcontext *, const GLubyte *);

struct __gllc_Fogf_Rec {
	GLenum	pname;
	GLfloat	param;
};

extern const GLubyte * FASTCALL __glle_Fogf(__GLcontext *, const GLubyte *);

struct __gllc_Fogfv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Fogfv(__GLcontext *, const GLubyte *);
#ifdef NT
// FOG_ASSERT
#define __glFogfv_size(pname)					\
    ((pname) == GL_FOG_COLOR					\
	? 4							\
	: (RANGE((pname),GL_FOG_INDEX,GL_FOG_MODE)		\
	    ? 1							\
	    : -1))
#else
extern GLint FASTCALL __glFogfv_size(GLenum pname);
#endif

struct __gllc_Fogi_Rec {
	GLenum	pname;
	GLint	param;
};

extern const GLubyte * FASTCALL __glle_Fogi(__GLcontext *, const GLubyte *);

struct __gllc_Fogiv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Fogiv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glFogiv_size(GLenum pname);

struct __gllc_FrontFace_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_FrontFace(__GLcontext *, const GLubyte *);

struct __gllc_Hint_Rec {
	GLenum	target;
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_Hint(__GLcontext *, const GLubyte *);

struct __gllc_Lightfv_Rec {
	GLenum	light;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Lightfv(__GLcontext *, const GLubyte *);
#ifdef NT
// LIGHT_SOURCE_ASSERT
#define __glLightfv_size(pname)						\
    ((pname) == GL_SPOT_DIRECTION					\
	? 3								\
	: (RANGE((pname),GL_AMBIENT,GL_POSITION)			\
	    ? 4								\
	    : (RANGE((pname),GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION)	\
		? 1							\
		: -1)))
#else
extern GLint FASTCALL __glLightfv_size(GLenum pname);
#endif

struct __gllc_Lightiv_Rec {
	GLenum	light;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Lightiv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glLightiv_size(GLenum pname);

struct __gllc_LightModelfv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_LightModelfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glLightModelfv_size(pname)					\
    (((pname) == GL_LIGHT_MODEL_LOCAL_VIEWER ||				\
      (pname) == GL_LIGHT_MODEL_TWO_SIDE)				\
	? 1								\
	: ((pname) == GL_LIGHT_MODEL_AMBIENT				\
	    ? 4								\
	    : -1))
#else
extern GLint FASTCALL __glLightModelfv_size(GLenum pname);
#endif

struct __gllc_LightModeliv_Rec {
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_LightModeliv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glLightModeliv_size(GLenum pname);

struct __gllc_LineStipple_Rec {
	GLint	factor;
	GLushort	pattern;
	GLushort	pad1;
};

extern const GLubyte * FASTCALL __glle_LineStipple(__GLcontext *, const GLubyte *);

struct __gllc_LineWidth_Rec {
	GLfloat	width;
};

extern const GLubyte * FASTCALL __glle_LineWidth(__GLcontext *, const GLubyte *);

struct __gllc_Materialfv_Rec {
	GLenum	face;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Materialfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glMaterialfv_size(pname)					\
    ((pname) == GL_SHININESS						\
	? 1								\
	: ((pname) == GL_COLOR_INDEXES					\
	    ? 3								\
	    : (((pname) == GL_AMBIENT ||				\
	        (pname) == GL_DIFFUSE ||				\
	        (pname) == GL_SPECULAR ||				\
	        (pname) == GL_EMISSION ||				\
	        (pname) == GL_AMBIENT_AND_DIFFUSE) 			\
		? 4							\
		: -1)))
#else
extern GLint FASTCALL __glMaterialfv_size(GLenum pname);
#endif

struct __gllc_Materialiv_Rec {
	GLenum	face;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_Materialiv(__GLcontext *, const GLubyte *);
extern GLint FASTCALL __glMaterialiv_size(GLenum pname);

struct __gllc_PointSize_Rec {
	GLfloat	size;
};

extern const GLubyte * FASTCALL __glle_PointSize(__GLcontext *, const GLubyte *);

struct __gllc_PolygonMode_Rec {
	GLenum	face;
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_PolygonMode(__GLcontext *, const GLubyte *);

struct __gllc_PolygonStipple_Rec {
	GLubyte	mask[128];
};

extern const GLubyte * FASTCALL __glle_PolygonStipple(__GLcontext *, const GLubyte *);

struct __gllc_Scissor_Rec {
	GLint	x;
	GLint	y;
	GLsizei	width;
	GLsizei	height;
};

extern const GLubyte * FASTCALL __glle_Scissor(__GLcontext *, const GLubyte *);

struct __gllc_ShadeModel_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_ShadeModel(__GLcontext *, const GLubyte *);

struct __gllc_TexParameterfv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexParameterfv(__GLcontext *, const GLubyte *);
#ifdef NT
// TEX_PARAMETER_ASSERT
#define __glTexParameterfv_size(pname)					\
    ((RANGE((pname),GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) ||		\
      (pname) == GL_TEXTURE_PRIORITY)				        \
	? 1								\
	: ((pname) == GL_TEXTURE_BORDER_COLOR				\
	    ? 4								\
	    : -1))
#else
extern GLint FASTCALL __glTexParameterfv_size(GLenum pname);
#endif

struct __gllc_TexParameteriv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexParameteriv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexParameteriv_size(pname)	__glTexParameterfv_size(pname)
#else
extern GLint FASTCALL __glTexParameteriv_size(GLenum pname);
#endif

typedef struct __GLtexImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage1D;

extern const GLubyte * FASTCALL __glle_TexImage1D(__GLcontext *, const GLubyte *);

typedef struct __GLtexImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLsizei height;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage2D;

extern const GLubyte * FASTCALL __glle_TexImage2D(__GLcontext *, const GLubyte *);

struct __gllc_TexEnvfv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexEnvfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexEnvfv_size(pname)					\
    ((pname) == GL_TEXTURE_ENV_MODE					\
	? 1								\
	: ((pname) == GL_TEXTURE_ENV_COLOR				\
	    ? 4								\
	    : -1))
#else
extern GLint FASTCALL __glTexEnvfv_size(GLenum pname);
#endif

struct __gllc_TexEnviv_Rec {
	GLenum	target;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexEnviv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexEnviv_size(pname)	__glTexEnvfv_size(pname)
#else
extern GLint FASTCALL __glTexEnviv_size(GLenum pname);
#endif

struct __gllc_TexGendv_Rec {
	GLenum	coord;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexGendv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexGendv_size(pname)					\
    (((pname) == GL_OBJECT_PLANE || (pname) == GL_EYE_PLANE)		\
	? 4								\
	: ((pname) == GL_TEXTURE_GEN_MODE				\
	    ? 1								\
	    : -1))
#else
extern GLint FASTCALL __glTexGendv_size(GLenum pname);
#endif

struct __gllc_TexGenfv_Rec {
	GLenum	coord;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexGenfv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexGenfv_size(pname)	__glTexGendv_size(pname)
#else
extern GLint FASTCALL __glTexGenfv_size(GLenum pname);
#endif

struct __gllc_TexGeniv_Rec {
	GLenum	coord;
	GLenum	pname;
	/*	params	*/
};

extern const GLubyte * FASTCALL __glle_TexGeniv(__GLcontext *, const GLubyte *);
#ifdef NT
#define __glTexGeniv_size(pname)	__glTexGendv_size(pname)
#else
extern GLint FASTCALL __glTexGeniv_size(GLenum pname);
#endif


extern const GLubyte * FASTCALL __glle_InitNames(__GLcontext *, const GLubyte *);

struct __gllc_LoadName_Rec {
	GLuint	name;
};

extern const GLubyte * FASTCALL __glle_LoadName(__GLcontext *, const GLubyte *);

struct __gllc_PassThrough_Rec {
	GLfloat	token;
};

extern const GLubyte * FASTCALL __glle_PassThrough(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PopName(__GLcontext *, const GLubyte *);

struct __gllc_PushName_Rec {
	GLuint	name;
};

extern const GLubyte * FASTCALL __glle_PushName(__GLcontext *, const GLubyte *);

struct __gllc_DrawBuffer_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_DrawBuffer(__GLcontext *, const GLubyte *);

struct __gllc_Clear_Rec {
	GLbitfield	mask;
};

extern const GLubyte * FASTCALL __glle_Clear(__GLcontext *, const GLubyte *);

struct __gllc_ClearAccum_Rec {
	GLfloat	red;
	GLfloat	green;
	GLfloat	blue;
	GLfloat	alpha;
};

extern const GLubyte * FASTCALL __glle_ClearAccum(__GLcontext *, const GLubyte *);

struct __gllc_ClearIndex_Rec {
	GLfloat	c;
};

extern const GLubyte * FASTCALL __glle_ClearIndex(__GLcontext *, const GLubyte *);

struct __gllc_ClearColor_Rec {
	GLclampf	red;
	GLclampf	green;
	GLclampf	blue;
	GLclampf	alpha;
};

extern const GLubyte * FASTCALL __glle_ClearColor(__GLcontext *, const GLubyte *);

struct __gllc_ClearStencil_Rec {
	GLint	s;
};

extern const GLubyte * FASTCALL __glle_ClearStencil(__GLcontext *, const GLubyte *);

struct __gllc_ClearDepth_Rec {
	GLclampd	depth;
};

extern const GLubyte * FASTCALL __glle_ClearDepth(__GLcontext *, const GLubyte *);

struct __gllc_StencilMask_Rec {
	GLuint	mask;
};

extern const GLubyte * FASTCALL __glle_StencilMask(__GLcontext *, const GLubyte *);

struct __gllc_ColorMask_Rec {
	GLboolean	red;
	GLboolean	green;
	GLboolean	blue;
	GLboolean	alpha;
};

extern const GLubyte * FASTCALL __glle_ColorMask(__GLcontext *, const GLubyte *);

struct __gllc_DepthMask_Rec {
	GLboolean	flag;
	GLubyte	pad1;
	GLubyte	pad2;
	GLubyte	pad3;
};

extern const GLubyte * FASTCALL __glle_DepthMask(__GLcontext *, const GLubyte *);

struct __gllc_IndexMask_Rec {
	GLuint	mask;
};

extern const GLubyte * FASTCALL __glle_IndexMask(__GLcontext *, const GLubyte *);

struct __gllc_Accum_Rec {
	GLenum	op;
	GLfloat	value;
};

extern const GLubyte * FASTCALL __glle_Accum(__GLcontext *, const GLubyte *);

struct __gllc_Disable_Rec {
	GLenum	cap;
};

extern const GLubyte * FASTCALL __glle_Disable(__GLcontext *, const GLubyte *);

struct __gllc_Enable_Rec {
	GLenum	cap;
};

extern const GLubyte * FASTCALL __glle_Enable(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PopAttrib(__GLcontext *, const GLubyte *);

struct __gllc_PushAttrib_Rec {
	GLbitfield	mask;
};

extern const GLubyte * FASTCALL __glle_PushAttrib(__GLcontext *, const GLubyte *);

typedef struct __GLmap1_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     order;
        /*        points  */
} __GLmap1;



extern const GLubyte * FASTCALL __glle_Map1(__GLcontext *, const GLubyte *);

typedef struct __GLmap2_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     uorder;
        __GLfloat v1;
        __GLfloat v2;
        GLint     vorder;
        /*        points  */
} __GLmap2;



extern const GLubyte * FASTCALL __glle_Map2(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid1d_Rec {
	GLdouble	u1;
	GLdouble	u2;
	GLint	un;
};

extern const GLubyte * FASTCALL __glle_MapGrid1d(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid1f_Rec {
	GLint	un;
	GLfloat	u1;
	GLfloat	u2;
};

extern const GLubyte * FASTCALL __glle_MapGrid1f(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid2d_Rec {
	GLdouble	u1;
	GLdouble	u2;
	GLdouble	v1;
	GLdouble	v2;
	GLint	un;
	GLint	vn;
};

extern const GLubyte * FASTCALL __glle_MapGrid2d(__GLcontext *, const GLubyte *);

struct __gllc_MapGrid2f_Rec {
	GLint	un;
	GLfloat	u1;
	GLfloat	u2;
	GLint	vn;
	GLfloat	v1;
	GLfloat	v2;
};

extern const GLubyte * FASTCALL __glle_MapGrid2f(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord1d_Rec {
	GLdouble	u;
};


struct __gllc_EvalCoord1dv_Rec {
	GLdouble	u[1];
};

extern const GLubyte * FASTCALL __glle_EvalCoord1dv(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord1f_Rec {
	GLfloat	u;
};


struct __gllc_EvalCoord1fv_Rec {
	GLfloat	u[1];
};

extern const GLubyte * FASTCALL __glle_EvalCoord1f(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord2d_Rec {
	GLdouble	u;
	GLdouble	v;
};


struct __gllc_EvalCoord2dv_Rec {
	GLdouble	u[2];
};

extern const GLubyte * FASTCALL __glle_EvalCoord2dv(__GLcontext *, const GLubyte *);

struct __gllc_EvalCoord2f_Rec {
	GLfloat	u;
	GLfloat	v;
};


struct __gllc_EvalCoord2fv_Rec {
	GLfloat	u[2];
};

extern const GLubyte * FASTCALL __glle_EvalCoord2f(__GLcontext *, const GLubyte *);

struct __gllc_EvalMesh1_Rec {
	GLenum	mode;
	GLint	i1;
	GLint	i2;
};

extern const GLubyte * FASTCALL __glle_EvalMesh1(__GLcontext *, const GLubyte *);

struct __gllc_EvalPoint1_Rec {
	GLint	i;
};

extern const GLubyte * FASTCALL __glle_EvalPoint1(__GLcontext *, const GLubyte *);

struct __gllc_EvalMesh2_Rec {
	GLenum	mode;
	GLint	i1;
	GLint	i2;
	GLint	j1;
	GLint	j2;
};

extern const GLubyte * FASTCALL __glle_EvalMesh2(__GLcontext *, const GLubyte *);

struct __gllc_EvalPoint2_Rec {
	GLint	i;
	GLint	j;
};

extern const GLubyte * FASTCALL __glle_EvalPoint2(__GLcontext *, const GLubyte *);

struct __gllc_AlphaFunc_Rec {
	GLenum	func;
	GLclampf	ref;
};

extern const GLubyte * FASTCALL __glle_AlphaFunc(__GLcontext *, const GLubyte *);

struct __gllc_BlendFunc_Rec {
	GLenum	sfactor;
	GLenum	dfactor;
};

extern const GLubyte * FASTCALL __glle_BlendFunc(__GLcontext *, const GLubyte *);

struct __gllc_LogicOp_Rec {
	GLenum	opcode;
};

extern const GLubyte * FASTCALL __glle_LogicOp(__GLcontext *, const GLubyte *);

struct __gllc_StencilFunc_Rec {
	GLenum	func;
	GLint	ref;
	GLuint	mask;
};

extern const GLubyte * FASTCALL __glle_StencilFunc(__GLcontext *, const GLubyte *);

struct __gllc_StencilOp_Rec {
	GLenum	fail;
	GLenum	zfail;
	GLenum	zpass;
};

extern const GLubyte * FASTCALL __glle_StencilOp(__GLcontext *, const GLubyte *);

struct __gllc_DepthFunc_Rec {
	GLenum	func;
};

extern const GLubyte * FASTCALL __glle_DepthFunc(__GLcontext *, const GLubyte *);

struct __gllc_PixelZoom_Rec {
	GLfloat	xfactor;
	GLfloat	yfactor;
};

extern const GLubyte * FASTCALL __glle_PixelZoom(__GLcontext *, const GLubyte *);

struct __gllc_PixelTransferf_Rec {
	GLenum	pname;
	GLfloat	param;
};

extern const GLubyte * FASTCALL __glle_PixelTransferf(__GLcontext *, const GLubyte *);

struct __gllc_PixelTransferi_Rec {
	GLenum	pname;
	GLint	param;
};

extern const GLubyte * FASTCALL __glle_PixelTransferi(__GLcontext *, const GLubyte *);

struct __gllc_PixelMapfv_Rec {
	GLenum	map;
	GLint	mapsize;
	/*	values	*/
};

extern const GLubyte * FASTCALL __glle_PixelMapfv(__GLcontext *, const GLubyte *);

struct __gllc_PixelMapuiv_Rec {
	GLenum	map;
	GLint	mapsize;
	/*	values	*/
};

extern const GLubyte * FASTCALL __glle_PixelMapuiv(__GLcontext *, const GLubyte *);

struct __gllc_PixelMapusv_Rec {
	GLenum	map;
	GLint	mapsize;
	/*	values	*/
};

extern const GLubyte * FASTCALL __glle_PixelMapusv(__GLcontext *, const GLubyte *);

struct __gllc_ReadBuffer_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_ReadBuffer(__GLcontext *, const GLubyte *);

struct __gllc_CopyPixels_Rec {
	GLint	x;
	GLint	y;
	GLsizei	width;
	GLsizei	height;
	GLenum	type;
};

extern const GLubyte * FASTCALL __glle_CopyPixels(__GLcontext *, const GLubyte *);

typedef struct __GLdrawPixels_Rec {
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        /*      pixels  */
} __GLdrawPixels;

extern const GLubyte * FASTCALL __glle_DrawPixels(__GLcontext *, const GLubyte *);

struct __gllc_DepthRange_Rec {
	GLclampd	zNear;
	GLclampd	zFar;
};

extern const GLubyte * FASTCALL __glle_DepthRange(__GLcontext *, const GLubyte *);

struct __gllc_Frustum_Rec {
	GLdouble	left;
	GLdouble	right;
	GLdouble	bottom;
	GLdouble	top;
	GLdouble	zNear;
	GLdouble	zFar;
};

extern const GLubyte * FASTCALL __glle_Frustum(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_LoadIdentity(__GLcontext *, const GLubyte *);

struct __gllc_LoadMatrixf_Rec {
	GLfloat	m[16];
};

extern const GLubyte * FASTCALL __glle_LoadMatrixf(__GLcontext *, const GLubyte *);

struct __gllc_LoadMatrixd_Rec {
	GLdouble	m[16];
};

extern const GLubyte * FASTCALL __glle_LoadMatrixd(__GLcontext *, const GLubyte *);

struct __gllc_MatrixMode_Rec {
	GLenum	mode;
};

extern const GLubyte * FASTCALL __glle_MatrixMode(__GLcontext *, const GLubyte *);

struct __gllc_MultMatrixf_Rec {
	GLfloat	m[16];
};

extern const GLubyte * FASTCALL __glle_MultMatrixf(__GLcontext *, const GLubyte *);

struct __gllc_MultMatrixd_Rec {
	GLdouble	m[16];
};

extern const GLubyte * FASTCALL __glle_MultMatrixd(__GLcontext *, const GLubyte *);

struct __gllc_Ortho_Rec {
	GLdouble	left;
	GLdouble	right;
	GLdouble	bottom;
	GLdouble	top;
	GLdouble	zNear;
	GLdouble	zFar;
};

extern const GLubyte * FASTCALL __glle_Ortho(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PopMatrix(__GLcontext *, const GLubyte *);


extern const GLubyte * FASTCALL __glle_PushMatrix(__GLcontext *, const GLubyte *);

struct __gllc_Rotated_Rec {
	GLdouble	angle;
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};

extern const GLubyte * FASTCALL __glle_Rotated(__GLcontext *, const GLubyte *);

struct __gllc_Rotatef_Rec {
	GLfloat	angle;
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};

extern const GLubyte * FASTCALL __glle_Rotatef(__GLcontext *, const GLubyte *);

struct __gllc_Scaled_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};

extern const GLubyte * FASTCALL __glle_Scaled(__GLcontext *, const GLubyte *);

struct __gllc_Scalef_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};

extern const GLubyte * FASTCALL __glle_Scalef(__GLcontext *, const GLubyte *);

struct __gllc_Translated_Rec {
	GLdouble	x;
	GLdouble	y;
	GLdouble	z;
};

extern const GLubyte * FASTCALL __glle_Translated(__GLcontext *, const GLubyte *);

struct __gllc_Translatef_Rec {
	GLfloat	x;
	GLfloat	y;
	GLfloat	z;
};

extern const GLubyte * FASTCALL __glle_Translatef(__GLcontext *, const GLubyte *);

struct __gllc_Viewport_Rec {
	GLint	x;
	GLint	y;
	GLsizei	width;
	GLsizei	height;
};

extern const GLubyte * FASTCALL __glle_Viewport(__GLcontext *, const GLubyte *);


typedef struct __GLtexSubImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLsizei width;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage1D;

extern const GLubyte * FASTCALL __glle_TexSubImage1D(__GLcontext *, const GLubyte *);

typedef struct __GLtexSubImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLint   yoffset;
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage2D;

extern const GLubyte * FASTCALL __glle_TexSubImage2D(__GLcontext *, const GLubyte *);

struct __gllc_BindTexture_Rec {
      GLenum target;
      GLuint texture;
};

extern const GLubyte * FASTCALL __glle_BindTexture(__GLcontext *, const GLubyte *);

struct __gllc_PrioritizeTextures_Rec {
      GLsizei n;
      /*    textures    */
      /*    priorities    */
};

extern const GLubyte * FASTCALL __glle_PrioritizeTextures(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexImage1D_Rec {
      GLenum target;
      GLint level;
      GLenum internalformat;
      GLint x;
      GLint y;
      GLsizei width;
      GLint border;
};

extern const GLubyte * FASTCALL __glle_CopyTexImage1D(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexImage2D_Rec {
      GLenum target;
      GLint level;
      GLenum internalformat;
      GLint x;
      GLint y;
      GLsizei width;
      GLsizei height;
      GLint border;
};

extern const GLubyte * FASTCALL __glle_CopyTexImage2D(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexSubImage1D_Rec {
      GLenum target;
      GLint level;
      GLint xoffset;
      GLint x;
      GLint y;
      GLsizei width;
};

extern const GLubyte * FASTCALL __glle_CopyTexSubImage1D(__GLcontext *, const GLubyte *);

struct __gllc_CopyTexSubImage2D_Rec {
      GLenum target;
      GLint level;
      GLint xoffset;
      GLint yoffset;
      GLint x;
      GLint y;
      GLsizei width;
      GLsizei height;
};

extern const GLubyte * FASTCALL __glle_CopyTexSubImage2D(__GLcontext *, const GLubyte *);

typedef struct __gllc_ColorTableEXT_Rec
{
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint imageSize;
    /* Data */
} __GLcolorTableEXT;

extern const GLubyte * FASTCALL __glle_ColorTableEXT(__GLcontext *, const GLubyte *);

typedef struct __gllc_ColorSubTableEXT_Rec
{
    GLenum target;
    GLuint start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLint imageSize;
    /* Data */
} __GLcolorSubTableEXT;

extern const GLubyte * FASTCALL __glle_ColorSubTableEXT(__GLcontext *, const GLubyte *);

struct __gllc_PolygonOffset_Rec
{
    GLfloat factor;
    GLfloat units;
};

extern const GLubyte * FASTCALL __glle_PolygonOffset(__GLcontext *, const GLubyte *);

struct __gllc_DrawElementsBegin_Rec
{
    GLenum  mode;
    GLsizei count;
    GLuint  vaMask;
};

extern const GLubyte * FASTCALL __glle_DrawElementsBegin(__GLcontext *, const GLubyte *);

struct __gllc_DrawElements_Rec
{
    GLenum  mode;
    GLsizei iElementCount;
    GLsizei iVertexCount;
    GLuint  vaMask;
    GLboolean partial;
    GLuint  recSize;
    GLuint  edgeFlagOff;
    GLuint  texCoordOff;
    GLint   texCoordSize;
    GLenum  texCoordType;
    GLuint  indexOff;
    GLenum  indexType;
    GLuint  colorOff;
    GLint   colorSize;
    GLenum  colorType;
    GLuint  normalOff;
    GLenum  normalType;
    GLuint  vertexOff;
    GLint   vertexSize;
    GLenum  vertexType;
    GLuint  mapOff;
};

extern const GLubyte * FASTCALL __glle_DrawElements(__GLcontext *, const GLubyte *);

#ifdef GL_WIN_multiple_textures
struct __gllc_CurrentTextureIndexWIN_Rec
{
    GLuint index;
};

extern const GLubyte * FASTCALL __glle_CurrentTextureIndexWIN(__GLcontext *, const GLubyte *);

struct __gllc_BindNthTextureWIN_Rec
{
    GLuint index;
    GLenum target;
    GLuint texture;
};

extern const GLubyte * FASTCALL __glle_BindNthTextureWIN(__GLcontext *, const GLubyte *);

struct __gllc_NthTexCombineFuncWIN_Rec
{
    GLuint index;
    GLenum leftColorFactor;
    GLenum colorOp;
    GLenum rightColorFactor;
    GLenum leftAlphaFactor;
    GLenum alphaOp;
    GLenum rightAlphaFactor;
};

extern const GLubyte * FASTCALL __glle_NthTexCombineFuncWIN(__GLcontext *, const GLubyte *);
#endif // GL_WIN_multiple_textures

#endif /* __gl_g_lcomp_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\phong.h ===
#ifndef __glphong_h_
#define __glphong_h_

#include "types.h"


#ifdef GL_WIN_phong_shading

//Definitions for the phong-flag
#define __GL_PHONG_INV_COLOR_VALID              0x00000001
#define __GL_PHONG_NEED_EYE_XPOLATE             0x00000002
#define __GL_PHONG_NEED_COLOR_XPOLATE           0x00000004

#define __GL_PHONG_ALREADY_SORTED               0x00000010
#define __GL_PHONG_USE_FAST_COLOR               0x00000020
#define __GL_PHONG_USE_SLOW_COLOR               0x00000040


/*
** Shader record for iterated objects (lines/triangles).  This keeps
** track of all the various deltas needed to rasterize a triangle.
*/

/* NOTES:
 * -----
 * After expanding the shading equation using Taylor's series
 * /=======================================\
 * |            2     2                    |
 * | S(x,y) = ax  + by + cxy + dx + ey + f |
 * \=======================================/
 *
 * f = S (0, 0)          ,        e = S (0, 0 )
 *                                     y  
 *
 * d = S (0, 0)          ,        c = S  (0, 0)
 *      x                              xy
 *
 * b = 0.5 * S  (0 , 0)  ,        a = 0.5 * S  (0, 0)
 *            yy                             xx  
 *
 * Compute these in SetInitialPhongParameters
 */

/* NOTES on Forward differencing:
 * -----------------------------
 * 
 * Along the edge interpolation: delta_x = X (dxdy), delta_y = 1
 * -------------------------------------------------------------
 * Initial S: S (0, 0) = f (compute in SetInitialPhongParameters, for vert A)
 * (Sinit_edge)        
 *                2
 * Initial dS : aX + b + cX + dX + e (compute in FillSubTriangle)
 * (dS_edge)                   
 *                             2
 * Initial ddS (constant) : 2aX + 2cX + 2b (compute in FillSubTriangle)
 * (ddS_edge)
 *
 * Every iteration compute Sinit_span (in FillSubTriangle).
 *
 *
 *
 * Along the span interpolation: delta_x = 1, delta_y = 0
 * -------------------------------------------------------------
 * Initial S: sEdge (compute in FillSubTriangle)
 * (Sinit_span)
 *
 * Initial dS: a(2x+1) + cy + d (compute once in SpanProc)
 * (dS_span)
 *
 * Initial ddS (constant): 2a (compute in SetInitialPhongParameters)
 * (ddS_span)
 *
 * Every iteration compute Color (in SpanProc).
 *
 */ 

typedef struct __GLphongPerLightDataRec {

  /****** Diffuse Part *****/
    GLfloat Dcurr;    //current dot-product
    GLfloat Ddel;    
    GLfloat Ddel2;
                         
  /****** Specular Part *****/
    GLfloat Scurr;    //current dot-product
    GLfloat Sdel;    
    GLfloat Sdel2;

#ifdef __JUNKED_CODE                         
    /* Along the edge */
    GLfloat DdelEdgeLittle;
    GLfloat Ddel2EdgeLittle;
    GLfloat DdelEdgeBig;
    GLfloat Ddel2EdgeBig;

    /* Along the span */
    GLfloat DdelSpan;
    GLfloat DdelSpanEdgeBig, DdelSpanEdgeLittle;
    GLfloat Ddel2Span;

    /* Temporary storages during span-generation */
    GLfloat D_tmp;     
    GLfloat Ddel_tmp;     

    /* Polynomial coefficients */
    GLfloat D[6];

  /****** Specular Part *****/
    GLfloat S_curr;    //current dot-product
                         
    /* Along the edge */
    GLfloat SdelEdgeLittle;
    GLfloat Sdel2EdgeLittle;
    GLfloat SdelEdgeBig;
    GLfloat Sdel2EdgeBig;

    /* Along the span */
    GLfloat SdelSpan;
    GLfloat SdelSpanEdgeBig, SdelSpanEdgeLittle;
    GLfloat Sdel2Span;

    /* Temporary storages during span-generation */
    GLfloat S_tmp;     
    GLfloat Sdel_tmp;     

    /* Polynomial coefficients */
    GLfloat S[6];

  /****** Attenuation Part *****/
  /****** Spotlight Part *****/
#endif //__JUNKED_CODE
} __GLphongPerLightData;


typedef struct __GLphongShadeRec {

    GLuint flags;

    GLint numLights;
  
    /* Normals */
    __GLcoord dndx, dndy;
    __GLcoord nBig, nLittle;
    __GLcoord nCur, nTmp;
  
    /* Eye */
    __GLcoord dedx, dedy;
    __GLcoord eBig, eLittle;
    __GLcoord eCur, eTmp;
  
    /* Face: Whether to use the FRONT or the BACK material */
    GLint face;
  
    /* Store the invarient color */
    __GLcolor invColor;      

    /* Temporary storage during span-interpolation of color */
    __GLcolor tmpColor;      

#ifdef __JUNKED_CODE
    /* Tracks the current position wrt to the starting vertex */
    __GLcoord cur_pos;     
    __GLcoord tmp_pos;     
#endif //__JUNKED_CODE

    /* Per-light data array */
    __GLphongPerLightData perLight[8]; //update this to WGL_MAX_NUM_LIGHTS
} __GLphongShader;

  
extern void FASTCALL __glGenericPickPhongProcs(__GLcontext *gc);
extern void ComputePhongInvarientRGBColor (__GLcontext *gc);              
#ifdef GL_WIN_specular_fog
extern __GLfloat ComputeSpecValue (__GLcontext *gc, __GLvertex *vx);
#endif //GL_WIN_specular_fog


#endif //GL_WIN_phong_shading


#endif /* __glphong_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\pixel.h ===
#ifndef _pixel_h_
#define _pixel_h_

/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "vertex.h"
#include "constant.h"

/* Not much for elegance, but it works. */
#define __GL_N_PIXEL_MAPS       (GL_PIXEL_MAP_A_TO_A - GL_PIXEL_MAP_I_TO_I + 1)
#define __GL_REMAP_PM(x)        ((x) - GL_PIXEL_MAP_I_TO_I)
#define __GL_PIXEL_MAP_I_TO_I   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_I)
#define __GL_PIXEL_MAP_S_TO_S   __GL_REMAP_PM(GL_PIXEL_MAP_S_TO_S)
#define __GL_PIXEL_MAP_I_TO_R   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_R)
#define __GL_PIXEL_MAP_I_TO_G   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_G)
#define __GL_PIXEL_MAP_I_TO_B   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_B)
#define __GL_PIXEL_MAP_I_TO_A   __GL_REMAP_PM(GL_PIXEL_MAP_I_TO_A)
#define __GL_PIXEL_MAP_R_TO_R   __GL_REMAP_PM(GL_PIXEL_MAP_R_TO_R)
#define __GL_PIXEL_MAP_G_TO_G   __GL_REMAP_PM(GL_PIXEL_MAP_G_TO_G)
#define __GL_PIXEL_MAP_B_TO_B   __GL_REMAP_PM(GL_PIXEL_MAP_B_TO_B)
#define __GL_PIXEL_MAP_A_TO_A   __GL_REMAP_PM(GL_PIXEL_MAP_A_TO_A)

/*
** Pixel type not exlicitly defined by the spec, but implictly suggested.
*/
#define __GL_RED_ALPHA		1

#ifdef GL_EXT_paletted_texture
// Pixel type needed to distinguish paletted texture data from
// normal color index
#define __GL_PALETTE_INDEX      2
#endif

typedef struct __GLpixelMapHeadRec {
    GLint size;
    GLint tableId;
    union {
        GLint *mapI;		/* access index (integral) entries */
        __GLfloat *mapF;	/* access component (float) entries */
    } base;
} __GLpixelMapHead;

//!!! Don't change this structure without changing MCDPIXELTRANSFER !!!

typedef struct __GLpixelTransferModeRec {
    __GLfloat r_scale, g_scale, b_scale, a_scale, d_scale;
    __GLfloat r_bias, g_bias, b_bias, a_bias, d_bias;
    __GLfloat zoomX;
    __GLfloat zoomY;

    GLint indexShift;
    GLint indexOffset;

    GLboolean mapColor;
    GLboolean mapStencil;
} __GLpixelTransferMode;

//!!! Don't change this structure without changing MCDPIXELPACK !!!

typedef struct __GLpixelPackModeRec {
    GLboolean swapEndian;
    GLboolean lsbFirst;

    GLuint lineLength;
    GLuint skipLines;
    GLuint skipPixels;
    GLuint alignment;
} __GLpixelPackMode;

//!!! Don't change this structure without changing MCDPIXELUNPACK !!!

typedef struct __GLpixelUnpackModeRec {
    GLboolean swapEndian;
    GLboolean lsbFirst;

    GLuint lineLength;
    GLuint skipLines;
    GLuint skipPixels;
    GLuint alignment;
} __GLpixelUnpackMode;

typedef struct __GLpixelStateRec {
    __GLpixelTransferMode transferMode;
    __GLpixelMapHead pixelMap[__GL_N_PIXEL_MAPS];
    __GLpixelPackMode packModes;
    __GLpixelUnpackMode unpackModes;
    GLuint pixelMapTableId;

    /*
    ** Read buffer.  Where pixel reads come from.
    */
    GLenum readBuffer;

    /*
    ** Read buffer specified by user.  May be different from readBuffer
    ** above.  If the user specifies GL_FRONT_LEFT, for example, then 
    ** readBuffer is set to GL_FRONT, and readBufferReturn to 
    ** GL_FRONT_LEFT.
    */
    GLenum readBufferReturn;
} __GLpixelState;

typedef struct __GLpixelMachineRec {
    GLboolean modifyRGBA;	/* Is the RGBA path being modified? */
    GLboolean modifyCI;
    GLboolean modifyDepth;
    GLboolean modifyStencil;
    /* scaled values indicating what a red of 0 maps to, an alpha of 1 ... */
    GLfloat red0Mod, green0Mod, blue0Mod, alpha1Mod;
    GLfloat *redMap;		/* Lookup tables with no modification */
    GLfloat *greenMap;
    GLfloat *blueMap;
    GLfloat *alphaMap;
    GLfloat *iMap;
    GLvoid *iCurMap, *redCurMap, *greenCurMap, *blueCurMap, *alphaCurMap;
    GLboolean rgbaCurrent;	
    GLfloat *redModMap;		/* Lookup tables for modification path */
    GLfloat *greenModMap;
    GLfloat *blueModMap;
    GLfloat *alphaModMap;
    GLboolean iToICurrent;	/* Lookup table for modification of CI */
    GLfloat *iToIMap;
    GLboolean iToRGBACurrent;	/* Lookup tables from CI to RGBA */
    GLfloat *iToRMap;
    GLfloat *iToGMap;
    GLfloat *iToBMap;
    GLfloat *iToAMap;
} __GLpixelMachine;

extern void FASTCALL __glInitDefaultPixelMap(__GLcontext *gc, GLenum map);

/************************************************************************/

#define __GL_MAX_SPAN_SIZE	(__GL_MAX_MAX_VIEWPORT * 4 * sizeof(GLfloat))

struct __GLpixelSpanInfoRec {
    GLenum srcFormat, srcType;	/* Form of source image */
    const GLvoid *srcImage;	/* The source image */
    GLvoid *srcCurrent;		/* The current pointer into the source data */
    GLint srcRowIncrement;	/* Add this much to get to the next row */
    GLint srcGroupIncrement;	/* Add this much to get to the next group */
    GLint srcComponents;	/* (4 for RGBA, 1 for ALPHA, etc.) */
    GLint srcElementSize;	/* Size of one element (1 for BYTE) */
    GLint srcSwapBytes;		
    GLint srcLsbFirst;
    GLint srcSkipPixels, srcSkipLines;
    GLint srcLineLength;
    GLint srcAlignment;
    GLboolean srcPackedData;	/* True if source data is packed */
    GLint srcStartBit;		/* After applying skipPixels */

    GLenum dstFormat, dstType;	/* Form of destination image */
    const GLvoid *dstImage;	/* The destination image */
    GLvoid *dstCurrent;		/* The current pointer into the dest data */
    GLint dstRowIncrement;	/* Add this much to get to the next row */
    GLint dstGroupIncrement;	/* Add this much to get to the next group */
    GLint dstComponents;	/* (4 for RGBA, 1 for ALPHA, etc.) */
    GLint dstElementSize;	/* Size of one element (1 for BYTE) */
    GLint dstSwapBytes;		
    GLint dstLsbFirst;
    GLint dstSkipPixels, dstSkipLines;
    GLint dstLineLength;
    GLint dstAlignment;
    GLboolean dstPackedData;	/* True if destination data is packed */
    GLint dstStartBit;		/* After applying skipPixels */

    __GLfloat zoomx, zoomy;
    GLint width, height;	/* Size of image */
    GLint realWidth;		/* Width of actual span (after xZoom) */
    __GLfloat readX, readY;	/* Reading coords (CopyPixels, ReadPixels) */
    __GLfloat x, y;		/* Effective raster coordinates */
    GLint startCol, startRow;	/* First actual pixel goes here */
    GLint endCol;		/* Last column rendered (minus coladd) */
    GLint columns, rows;	/* Taking zoomx, zoomy into account */
    GLboolean overlap;		/* Do CopyPixels src/dest regions overlap? */
    GLint rowsUp, rowsDown;	/* Stuff for overlapping CopyPixels regions */
    GLint rowadd, coladd;	/* Adders for incrementing the col or row */
    __GLfloat rendZoomx;	/* effective zoomx for render span */
    __GLzValue fragz;		/* save this computation in the span walker */
    __GLfloat rpyUp, rpyDown;
    GLint startUp, startDown;
    GLint readUp, readDown;
    GLvoid *redMap, *greenMap, *blueMap, *alphaMap;
    GLvoid *indexMap;
    GLshort *pixelArray;	/* Array of pixel relication counts (if    */
				/* zoomx < -1 or zoomx > 1) or pixels to   */
				/* skip (if zoomx < 1 and zoomx > -1).     */

#ifdef GL_EXT_paletted_texture
    // Used when the source or destination has a palette
    // These fields are only used for expanding palette index
    // data into RGBA so only source fields are needed
    RGBQUAD *srcPalette;
    GLint srcPaletteSize;
#endif
    
    /*
    ** A pile of span routines used by the DrawPixels, ReadPixels, and 
    ** CopyPixels functions.
    */
    void (FASTCALL *spanReader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *outspan);
    void (*(spanModifier[7]))(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *spanRender)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan);
};

/* px_api.c */
extern GLboolean __glCheckDrawPixelArgs(__GLcontext *gc, GLsizei width, 
					GLsizei height, GLenum format, 
					GLenum type);
void FASTCALL __glPixelSetColorScales(__GLcontext *);

/* px_paths.c */
GLboolean FASTCALL __glClipDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glComputeSpanPixelArray(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glLoadUnpackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLboolean packed);
void __glInitDrawPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLint width, GLint height, GLenum format, 
                            GLenum type, const GLvoid *pixels);
void FASTCALL __glDrawPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glDrawPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSlowPickDrawPixels(__GLcontext *gc, GLint width, GLint height,
                            GLenum format, GLenum type, const GLvoid *pixels,
			    GLboolean packed);
void FASTCALL __glGenericPickDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean FASTCALL __glClipReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glLoadPackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glInitReadPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLint x, GLint y, GLint width, GLint height, 
                            GLenum format, GLenum type, const GLvoid *pixels);
void FASTCALL __glReadPixels5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glReadPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSlowPickReadPixels(__GLcontext *gc, GLint x, GLint y,
                            GLsizei width, GLsizei height,
                            GLenum format, GLenum type, const GLvoid *pixels);
void FASTCALL __glGenericPickReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean FASTCALL __glClipCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glInitCopyPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                            GLint x, GLint y, GLint width, GLint height, 
                            GLenum format);
void FASTCALL __glCopyPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyPixelsOverlapping(__GLcontext *gc,
                               __GLpixelSpanInfo *spanInfo, GLint modifiers);
void __glSlowPickCopyPixels(__GLcontext *gc, GLint x, GLint y, GLint width,
                            GLint height, GLenum type);
void FASTCALL __glGenericPickCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage6(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glCopyImage7(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void FASTCALL __glGenericPickCopyImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLboolean applyPixelTransfer);

/* px_modify.c */
void FASTCALL __glBuildRGBAModifyTables(__GLcontext *gc, __GLpixelMachine *pm);
void FASTCALL __glBuildItoIModifyTables(__GLcontext *gc, __GLpixelMachine *pm);
void FASTCALL __glBuildItoRGBAModifyTables(__GLcontext *gc,
				  __GLpixelMachine *pm);
void __glSpanModifyRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		        GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		       GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		        GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			 GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			 GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanModifyCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *inspan, GLvoid *outspan);

/* px_pack.c */
void FASTCALL __glInitPacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSpanReduceRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#ifdef GL_EXT_bgra
void __glSpanReduceBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#endif
void __glSpanReduceLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *inspan, GLvoid *outspan);
void __glSpanReduceRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanPackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanPackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                     GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanPackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanPackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanPackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanPackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanCopy(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
void __glSpanPackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan);

/* px_read.c */
void FASTCALL __glSpanReadRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *span);
void FASTCALL __glSpanReadRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *span);
void FASTCALL __glSpanReadCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                    GLvoid *span);
void FASTCALL __glSpanReadCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                     GLvoid *span);
void FASTCALL __glSpanReadDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *span);
void FASTCALL __glSpanReadDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *span);
void FASTCALL __glSpanReadStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *span);
void FASTCALL __glSpanReadStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *span);

/* px_render.c */
void FASTCALL __glSlowDrawPixelsStore(__GLcolorBuffer *cfb, const __GLfragment *frag);
void FASTCALL __glSpanRenderRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderRGBubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderRGBAubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLvoid *span);
void FASTCALL __glSpanRenderDepthUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderDepthUint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLvoid *span);
void FASTCALL __glSpanRenderDepth2Uint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                              GLvoid *span);
void FASTCALL __glSpanRenderDepth2Uint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                               GLvoid *span);
void FASTCALL __glSpanRenderStencilUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                 GLvoid *span);
void FASTCALL __glSpanRenderStencilUshort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *span);
void FASTCALL __glSpanRenderStencilUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                GLvoid *span);
void FASTCALL __glSpanRenderStencilUbyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                 GLvoid *span);
void FASTCALL __glSpanRenderCIushort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderCIushort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *span);
void FASTCALL __glSpanRenderCIubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *span);
void FASTCALL __glSpanRenderCIubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderCIubyte3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderCIubyte4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);
void FASTCALL __glSpanRenderRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *span);
void FASTCALL __glSpanRenderRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *span);
void FASTCALL __glSpanRenderDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *span);
void FASTCALL __glSpanRenderDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *span);
void FASTCALL __glSpanRenderCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *span);
void FASTCALL __glSpanRenderCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *span);
void FASTCALL __glSpanRenderStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *span);
void FASTCALL __glSpanRenderStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *span);

/* px_unpack.c */
GLint FASTCALL __glElementsPerGroup(GLenum format);
__GLfloat FASTCALL __glBytesPerElement(GLenum type);
void FASTCALL __glInitUnpacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
void __glSpanUnpackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackBitmap2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackIndexUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                              GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapAndSkipBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                               GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapBytes4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanSwapAndSkipBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                               GLvoid *inspan, GLvoid *outspan);
void __glSpanSkipPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanSlowSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanSlowSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanAlignPixels4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                           GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                          GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanUnpackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanClampFloat(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanClampSigned(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                        GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
#ifdef GL_EXT_bgra
void __glSpanExpandBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
#endif
void __glSpanExpandLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                             GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                                  GLvoid *inspan, GLvoid *outspan);
void __glSpanExpandRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                            GLvoid *inspan, GLvoid *outspan);
void __glSpanScaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanUnscaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#ifdef GL_EXT_bgra
void __glSpanScaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                       GLvoid *inspan, GLvoid *outspan);
void __glSpanUnscaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                         GLvoid *inspan, GLvoid *outspan);
#endif
#ifdef GL_EXT_paletted_texture
void __glSpanModifyPI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *inspan, GLvoid *outspan);
void __glSpanScalePI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                     GLvoid *inspan, GLvoid *outspan);
#endif

#endif /* _pixel_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\namesint.h ===
#ifndef __glnamesint_h
#define __glnamesint_h

/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list internal structure description.
**
** $Revision: 1.2 $
** $Date: 1995/01/25 18:05:43 $
*/


/************************************************************************/
/*
** Names Manager Interface
**
** This file contains the Name Space Management types and structures.
**
** The Name Space Management code is used to store and retreive named
** data structures.  The data being stored is referred to with void 
** pointers to allow for the storage of any type of structure.
**
** The Name Space is implemented as a 2-3 tree.  For a detailed
** description of its implementation, see lib/opengl/soft/so_names.c.
**
** __GLnamesArray is declared in types.h.
*/
/************************************************************************/


/*
** A tree can be used to hold different types of data,
** e.g. display lists or texture objects.  This is the structure 
** that contains information needed for each tree type.  For
** example, this structure contains a pointer to a dummy empty
** structure and a callback for freeing memory associated with
** the structure.
*/
struct __GLnamesArrayTypeInfoRec {
    void *empty;		/* ptr to empty info structure */
    GLuint dataSize;		/* sizeof data structure in bytes */
    void (WINAPIV *free)(__GLcontext *gc, void *memory);	
				/* callback for freeing data */
    GLboolean (WINAPIV *alloc)(__GLcontext *gc, size_t size);
				/* callback for allocating data */
};
typedef struct __GLnamesArrayTypeInfoRec __GLnamesArrayTypeInfo;

/*
** The number of spare branches and leaves that we keep about in case
** we run out of memory.  At that point, we complete the current operation
** by using the extra leaves and branches, and we report an OUT_OF_MEMORY
** error when a new operation is requested (unless we can fill our extras
** again!)
**
** These constants were not chosen terribly carefully.  As best as I can
** figure, we only need one spare branch per level in the tree (so 16
** supports a tree with 65536 leaves).  And even then, the user would have
** to be extremely devious to actually force 16 new branches to appear in
** the tree at just the same moment that the system runs out of memory.
**
** The number of spare leaves required, I believe, is one.  Three is chosen
** to allow for some slop.
*/
#define __GL_DL_EXTRA_BRANCHES          16
#define __GL_DL_EXTRA_LEAVES            3

/*
** This is the structure that contains information that is needed
** for each instance of a names tree.  It needs to be public
** so the refcount can be managed.
*/

typedef struct __GLnamesArrayTypeInfoRec __GLnamesArrayTypeInfo;
typedef struct __GLnamesBranchRec __GLnamesBranch;
typedef struct __GLnamesLeafRec __GLnamesLeaf;

struct __GLnamesArrayRec {
    __GLnamesBranch *tree;      /* points to the top of the names tree */
    GLuint depth;               /* depth of tree */
    GLint refcount; /*# ctxs using this array: create with 1, delete at 0*/
    __GLnamesArrayTypeInfo *dataInfo;   /* ptr to data type info */
    GLuint nbranches, nleaves;  /* should basically always be at max */
    __GLnamesBranch *branches[__GL_DL_EXTRA_BRANCHES];
    __GLnamesLeaf *leaves[__GL_DL_EXTRA_LEAVES];
#ifdef NT
    CRITICAL_SECTION critsec;
#endif
};

#ifdef NT
// Locking macros to enable or disable locking
#define __GL_NAMES_LOCK(array)   EnterCriticalSection(&(array)->critsec)
#define __GL_NAMES_UNLOCK(array) LeaveCriticalSection(&(array)->critsec)

#if DBG
typedef struct _RTL_CRITICAL_SECTION *LPCRITICAL_SECTION;
extern void APIENTRY CheckCritSectionIn(LPCRITICAL_SECTION pcs);
#define __GL_NAMES_ASSERT_LOCKED(array) CheckCritSectionIn(&(array)->critsec)
#else
#define __GL_NAMES_ASSERT_LOCKED(array)
#endif
#endif

/*
** Clean up an item whose refcount has fallen to zero due to unlocking
*/
typedef void (FASTCALL *__GLnamesCleanupFunc)(__GLcontext *gc, void *data);

/*
** Allocate and initialize a new array structure.
*/
extern __GLnamesArray * FASTCALL __glNamesNewArray(__GLcontext *gc, 
					 __GLnamesArrayTypeInfo *dataInfo);

/*
** Free the array structure.
*/
extern void FASTCALL __glNamesFreeArray(__GLcontext *gc, __GLnamesArray *array);

/*
** Save a new display list in the array.  A return value of GL_FALSE
** indicates and OUT_OF_MEMORY error, indicating that the list was 
** not stored.
*/
extern GLboolean FASTCALL __glNamesNewData(__GLcontext *gc, __GLnamesArray *array,
				  GLuint name, void *data);

/*
** Find and lock the list specified with "listnum".  A return value of NULL
** indicates that there was no such list.  __glNamesUnlockList() needs to
** be called to unlock the list otherwise.
*/
extern void * FASTCALL __glNamesLockData(__GLcontext *gc, __GLnamesArray *array,
			       GLuint name);

/*
** Unlock a list locked with __glNamesLockList().  If this is not called, then
** any memory associated with the list will never be freed when the list
** is deleted.
*/
extern void FASTCALL __glNamesUnlockData(__GLcontext *gc, void *data,
                                         __GLnamesCleanupFunc cleanup);

/*
** Same as __glNamesLockList() except that a bunch of lists are locked and
** returned simultaneously.  Any listbase previously specified is used as 
** an offset to the entries in the array.
*/
extern void FASTCALL __glNamesLockDataList(__GLcontext *gc, __GLnamesArray *array,
				  GLsizei n, GLenum type, GLuint base,
			          const GLvoid *names, void *dataList[]);

/*
** Same as __glNamesUnlockList() except that the entire array of names
** is unlocked at once.
*/
extern void FASTCALL __glNamesUnlockDataList(__GLcontext *gc, GLsizei n,
                                             void *dataList[],
                                             __GLnamesCleanupFunc cleanup);

#ifdef NT
/*
** Locks entire array
*/
#define __glNamesLockArray(gc, array) __GL_NAMES_LOCK(array)

/*
** Unlocks array
*/
#define __glNamesUnlockArray(gc, array) __GL_NAMES_UNLOCK(array)
#endif

/*
** Generates a list of names.
*/
extern GLuint FASTCALL __glNamesGenRange(__GLcontext *gc, __GLnamesArray *array, 
				GLsizei range);

/*
** Returns GL_TRUE if name has been generated for this array.
*/
extern GLboolean FASTCALL __glNamesIsName(__GLcontext *gc, __GLnamesArray *array, 
				 GLuint name);

/*
** Deletes a range of names.
*/
extern void FASTCALL __glNamesDeleteRange(__GLcontext *gc, __GLnamesArray *array, 
				 GLuint name, GLsizei range);

/*
** Generates a list of (not necessarily contiguous) names.
*/
extern void FASTCALL __glNamesGenNames(__GLcontext *gc, __GLnamesArray *array, 
			      GLsizei n, GLuint* names);

/*
** Deletes a list of (not necessarily contiguous) names.
*/
extern void FASTCALL __glNamesDeleteNames(__GLcontext *gc, __GLnamesArray *array, 
				 GLsizei n, const GLuint* names);

#endif /* __glnamesint_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\os.h ===
#ifndef __glos_h_
#define __glos_h_

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <nt.h>
#include <stdlib.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>

#include "glscreen.h"
#include "types.h"

// Indicator of which platform we're running on,
// uses the VER_PLATFORM defines
extern DWORD dwPlatformId;

//
// LocalRtlFillMemoryUlong
//
// Inline implementation of RtlFillMemoryUlong.  Destination has DWORD
// alignment.
//
// Parameters:
//
//  Destination     pointer to DWORD aligned destination
//  Length          number of bytes to fill
//  Pattern         fill pattern
//
_inline VOID LocalRtlFillMemoryUlong(PVOID Destination, ULONG Length,
             ULONG Pattern)
{
    if ((Pattern == 0) || (Pattern == 0xffffffff))
        memset(Destination, Pattern, Length);
    else {
        register ULONG *pDest = (ULONG *)Destination;
        LONG unroll;

        Length >>= 2;

        for (unroll = Length >> 5; unroll; unroll--) {
            pDest[0] = Pattern; pDest[1] = Pattern;
            pDest[2] = Pattern; pDest[3] = Pattern;
            pDest[4] = Pattern; pDest[5] = Pattern;
            pDest[6] = Pattern; pDest[7] = Pattern;
            pDest[8] = Pattern; pDest[9] = Pattern;
            pDest[10] = Pattern; pDest[11] = Pattern;
            pDest[12] = Pattern; pDest[13] = Pattern;
            pDest[14] = Pattern; pDest[15] = Pattern;
            pDest[16] = Pattern; pDest[17] = Pattern;
            pDest[18] = Pattern; pDest[19] = Pattern;
            pDest[20] = Pattern; pDest[21] = Pattern;
            pDest[22] = Pattern; pDest[23] = Pattern;
            pDest[24] = Pattern; pDest[25] = Pattern;
            pDest[26] = Pattern; pDest[27] = Pattern;
            pDest[28] = Pattern; pDest[29] = Pattern;
            pDest[30] = Pattern; pDest[31] = Pattern;
            pDest += 32;
        }

        for (unroll = (Length & 0x1f) >> 2; unroll; unroll--) {
            pDest[0] = Pattern; pDest[1] = Pattern;
            pDest[2] = Pattern; pDest[3] = Pattern;
            pDest += 4;
        }

        for (unroll = (Length & 0x3) - 1; unroll >= 0; unroll--)
            pDest[unroll] = Pattern;
    }
}

//
// LocalCompareUlongMemory
//
// Inline implementation of RtlCompareUlongMemory.  Both pointers
// must have DWORD alignment.
//
// Returns TRUE if the two source arrays are equal.  FALSE otherwise.
//
// Parameters:
//
//  Source1     pointer to DWORD aligned array to check
//  Source1     pointer to DWORD aligned array to compare with
//  Length      number of bytes to fill
//
_inline BOOL LocalCompareUlongMemory(PVOID Source1, PVOID Source2,
             ULONG Length)
{
    register ULONG *pSrc1 = (ULONG *) Source1;
    register ULONG *pSrc2 = (ULONG *) Source2;
    LONG unroll;
    BOOL bRet = FALSE;

    Length >>= 2;

    for (unroll = Length >> 5; unroll; unroll--) {
        if ( (pSrc1[0]  != pSrc2[0])  || (pSrc1[1]  != pSrc2[1])  ||
             (pSrc1[2]  != pSrc2[2])  || (pSrc1[3]  != pSrc2[3])  ||
             (pSrc1[4]  != pSrc2[4])  || (pSrc1[5]  != pSrc2[5])  ||
             (pSrc1[6]  != pSrc2[6])  || (pSrc1[7]  != pSrc2[7])  ||
             (pSrc1[8]  != pSrc2[8])  || (pSrc1[9]  != pSrc2[9])  ||
             (pSrc1[10] != pSrc2[10]) || (pSrc1[11] != pSrc2[11]) ||
             (pSrc1[12] != pSrc2[12]) || (pSrc1[13] != pSrc2[13]) ||
             (pSrc1[14] != pSrc2[14]) || (pSrc1[15] != pSrc2[15]) ||
             (pSrc1[16] != pSrc2[16]) || (pSrc1[17] != pSrc2[17]) ||
             (pSrc1[18] != pSrc2[18]) || (pSrc1[19] != pSrc2[19]) ||
             (pSrc1[20] != pSrc2[20]) || (pSrc1[21] != pSrc2[21]) ||
             (pSrc1[22] != pSrc2[22]) || (pSrc1[23] != pSrc2[23]) ||
             (pSrc1[24] != pSrc2[24]) || (pSrc1[25] != pSrc2[25]) ||
             (pSrc1[26] != pSrc2[26]) || (pSrc1[27] != pSrc2[27]) ||
             (pSrc1[28] != pSrc2[28]) || (pSrc1[29] != pSrc2[29]) ||
             (pSrc1[30] != pSrc2[30]) || (pSrc1[31] != pSrc2[31]) )
            goto LocalRtlCompareUlongMemory_exit;

        pSrc1 += 32;
        pSrc2 += 32;
    }

    for (unroll = (Length & 0x1f) >> 2; unroll; unroll--) {
        if ( (pSrc1[0] != pSrc2[0]) || (pSrc1[1] != pSrc2[1]) ||
             (pSrc1[2] != pSrc2[2]) || (pSrc1[3] != pSrc2[3]) )
            goto LocalRtlCompareUlongMemory_exit;

        pSrc1 += 4;
        pSrc2 += 4;
    }

    for (unroll = (Length & 0x3) - 1; unroll >= 0; unroll--)
        if ( pSrc1[unroll] != pSrc2[unroll] )
            goto LocalRtlCompareUlongMemory_exit;

    bRet = TRUE;    // return TRUE if memory is identical

LocalRtlCompareUlongMemory_exit:

    return bRet;
}

//
// LocalRtlFillMemoryUshort
//
// Inline implementation of USHORT equivalent to RtlFillMemoryUlong,
// RtlFillMemoryUshort (does not currently exist in NT).  WORD alignment
// assumed for Destination.
//
// Parameters:
//
//  Destination     pointer to USHORT aligned destination
//  Length          number of bytes to fill
//  Pattern         fill pattern
//
_inline VOID LocalRtlFillMemoryUshort(PVOID Destination, ULONG Length,
             USHORT Pattern)
{
    if ( Length == 0 )
        return;

// If odd WORD, make it DWORD aligned by writing a WORD up front.

    if ( ((ULONG_PTR) Destination) & 0x2 )
    {
        *((USHORT *) Destination)++ = Pattern;
        Length -= sizeof(USHORT);

        if ( Length == 0 )
            return;
    }

// Now the Destination start is DWORD aligned.  If the remaining length
// is an odd number of WORDs, we will need to pick up an extra WORD write
// at the end.

    if ((Pattern == 0x0000) || (Pattern == 0xffff))
        memset(Destination, Pattern, Length);
    else {
        ULONG ulPattern = Pattern | (Pattern << 16);
        ULONG cjDwords;

    // Do what we can with DWORD writes.

        if ( cjDwords = (Length & (~3)) )
        {
            LocalRtlFillMemoryUlong((PVOID) Destination, cjDwords, ulPattern);
            ((BYTE *) Destination) += cjDwords;
        }

    // Pick up the last WORD.

        if ( Length & 3 )
            *((USHORT *) Destination) = Pattern;
    }
}

//
// LocalRtlFillMemory24
//
// Inline implementation of 24bit equivalent to RtlFillMemoryUlong,
// No assumptions made about alignment.
// Parameters:
//
//  Destination         pointer to destination
//  Length              number of bytes to fill
//  col0, col1, col2    Colors
//
_inline VOID LocalRtlFillMemory24(PVOID Destination, ULONG Length,
             BYTE col0, BYTE col1, BYTE col2)
{
    BYTE col[3];

    if ( Length == 0 )
        return;


    // Check for special cases, same valued components
    if ((col0 == col1) && (col0 == col2)) {

        memset(Destination, col0, Length);

    } else { //Other colors
    	ULONG ulPat1, ulPat2, ulPat3;
    	int rem;
    	int i, tmp;
        register ULONG *pDest;
        register BYTE *pByte = (BYTE *)Destination;
        LONG unroll;
    	
        // If not DWORD aligned, make it DWORD aligned.
    	tmp = (int)((ULONG_PTR) Destination & 0x3);
        switch ( 4 - tmp ) {
    	  case 1:
    		*pByte++ = col0;
    		Length--;
    		ulPat1 = (col1 << 24) | (col0 << 16) | (col2 << 8) | col1;
    		ulPat2 = (col2 << 24) | (col1 << 16) | (col0 << 8) | col2;
    		ulPat3 = (col0 << 24) | (col2 << 16) | (col1 << 8) | col0;
    		break;
    	  case 2:
    		*pByte++ = col0;
    		*pByte++ = col1;
    		Length -= 2;
    		ulPat1 = (col2 << 24) | (col1 << 16) | (col0 << 8) | col2;
    		ulPat2 = (col0 << 24) | (col2 << 16) | (col1 << 8) | col0;
    		ulPat3 = (col1 << 24) | (col0 << 16) | (col2 << 8) | col1;
    		break;
    	  case 3:
    		*pByte++ = col0;
    		*pByte++ = col1;
    		*pByte++ = col2;
    		Length -= 3;
    	  case 4:   // fall thru, 'cause the pattern is the same
    	  default:
    		ulPat1 = (col0 << 24) | (col2 << 16) | (col1 << 8) | col0;
    		ulPat2 = (col1 << 24) | (col0 << 16) | (col2 << 8) | col1;
    		ulPat3 = (col2 << 24) | (col1 << 16) | (col0 << 8) | col2;
    	}
    	
    	pDest = (ULONG *)pByte;
    	rem = Length % 48;
        Length >>= 2;
        for (unroll = Length/12; unroll; unroll--) {
            pDest[0] = ulPat1; pDest[1] = ulPat2;
            pDest[2] = ulPat3; pDest[3] = ulPat1;
            pDest[4] = ulPat2; pDest[5] = ulPat3;
            pDest[6] = ulPat1; pDest[7] = ulPat2;
            pDest[8] = ulPat3; pDest[9] = ulPat1;
            pDest[10] = ulPat2; pDest[11] = ulPat3;
            pDest += 12;
        }

        col[0] = (BYTE) (ulPat1 & 0x000000ff);
        col[1] = (BYTE) ((ulPat1 & 0x0000ff00) >> 8);
        col[2] = (BYTE) ((ulPat1 & 0x00ff0000) >> 16);

        pByte = (BYTE *)pDest;
    	for (i=0; i<rem; i++) *pByte++ = col [i%3];
    }
}

//
// LocalWriteMemoryAlign
//
// Inline implementation of RtlCopyMemory that ensures that the copy
// operation will write to the destination with DWORD alignment.
//
_inline VOID LocalWriteMemoryAlign(PBYTE pjDst, PBYTE pjSrc, ULONG cj)
{
    ULONG cjExtraBytes;
    ULONG cjDwords;

// If cj < sizeof(DWORD), then set cjExtraBytes to cj.  That's all we will
// need to do.
//
// Otherwise, compute the number of leading bytes to the next DWORD boundary.

    if ( cj < 4 )
        cjExtraBytes = cj;
    else
        cjExtraBytes = (ULONG)(4 - (((ULONG_PTR) pjDst) & 3)) & 3;

// Make dst array DWORD aligned by copying the leading non-DWORD aligned bytes.

    if ( cjExtraBytes )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }

        if ( (cj -= cjExtraBytes) == 0 )
            return;
    }

// Now the beginning of dst array is DWORD aligned.  If the remaining length
// is an odd number of BYTEs, we will need to pick up the extra BYTE writes
// at the end.

// Do what we can with DWORD copy.

    if ( cjDwords = (cj & (~3)) )
    {
        memcpy(pjDst, pjSrc, cjDwords);
        pjDst += cjDwords;
        pjSrc += cjDwords;
    }

// Pick up the remaining BYTES.

    if ( cjExtraBytes = (cj & 3) )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }
    }
}

//
// LocalReadMemoryAlign
//
// Inline implementation of RtlCopyMemory that ensures that the copy
// operation will read from the source with DWORD alignment.
//
_inline VOID LocalReadMemoryAlign(PBYTE pjDst, PBYTE pjSrc, ULONG cj)
{
    ULONG cjExtraBytes;
    ULONG cjDwords;

// If cj < sizeof(DWORD), then set cjExtraBytes to cj.  That's all we will
// need to do.
//
// Otherwise, compute the number of leading bytes to the next DWORD boundary.

    if ( cj < 4 )
        cjExtraBytes = cj;
    else
        cjExtraBytes = (ULONG) (4 - (((ULONG_PTR) pjSrc) & 3)) & 3;

// Take care of the leading BYTES.

    if ( cjExtraBytes )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }

        if ( (cj -= cjExtraBytes) == 0 )
            return;
    }

// Now the beginning of src array is DWORD aligned.  If the remaining length
// is an odd number of BYTEs, we will need to pick up the extra BYTE writes
// at the end.

// Do what we can with DWORD copy.

    if ( cjDwords = (cj & (~3)) )
    {
        memcpy(pjDst, pjSrc, cjDwords);
        pjDst += cjDwords;
        pjSrc += cjDwords;
    }

// Pick up the remaining BYTES.

    if ( cjExtraBytes = (cj & 3) )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = *pjSrc++;
            case 2: *pjDst++ = *pjSrc++;
            case 1: *pjDst++ = *pjSrc++;
        }
    }
}

//
// LocalFillMemory
//
// Inline implementation of RtlFillMemory.  Assume that pjDst has only BYTE
// alignment.
//
_inline VOID LocalFillMemory(PBYTE pjDst, ULONG cj, BYTE j)
{
    ULONG cjExtraBytes;
    ULONG cjDwords;

// If cj < sizeof(DWORD), then set cjExtraBytes to cj.  That's all we will
// need to do.
//
// Otherwise, compute the number of leading bytes to the next DWORD boundary.

    if ( cj < 4 )
        cjExtraBytes = cj;
    else
        cjExtraBytes = (ULONG)(4 - (((ULONG_PTR) pjDst) & 3)) & 3;

// Take care of the leading BYTES.

    if ( cjExtraBytes )
    {
        switch ( cjExtraBytes )
        {
            case 3: *pjDst++ = j;
            case 2: *pjDst++ = j;
            case 1: *pjDst++ = j;
        }

        if ( (cj -= cjExtraBytes) == 0 )
            return;
    }

// Now both arrays start is DWORD aligned.  If the remaining length
// is an odd number of BYTEs, we will need to pick up the extra BYTE writes
// at the end.

// Do what we can with DWORD copy.

    if ( cjDwords = (cj & (~3)) )
    {
        ULONG ul = j | (j<<8) | (j<<16) | (j<<24);

        LocalRtlFillMemoryUlong((PVOID) pjDst, cjDwords, ul);
        pjDst += cjDwords;
    }

// Pick up the remaining BYTES.

    if ( cjExtraBytes = (cj & 3) )
    {
        switch (cjExtraBytes)
        {
            case 3: *pjDst++ = j;
            case 2: *pjDst++ = j;
            case 1: *pjDst++ = j;
        }
    }
}

//
// LocalZeroMemory
//
// Inline implementation of RtlFillMemory.  Assume that pjDst has only BYTE
// alignment.
//
_inline VOID LocalZeroMemory(PBYTE pjDst, ULONG cj)
{
    LocalFillMemory(pjDst, cj, 0);
}

#undef RtlMoveMemory
#undef RtlCopyMemory
#undef RtlFillMemory
#undef RtlZeroMemory
#undef RtlFillMemoryUlong
#undef RtlFillMemory24

#define RtlMoveMemory(d, s, l)          memmove((d),(s),(l))
#define RtlCopyMemory(d, s, l)          memcpy((d),(s),(l))
#define RtlFillMemoryUlong(d, cj, ul)   LocalRtlFillMemoryUlong((PVOID)(d),(ULONG)(cj),(ULONG)(ul))
#define RtlFillMemoryUshort(d, cj, us)  LocalRtlFillMemoryUshort((PVOID)(d),(ULONG)(cj),(USHORT)(us))
#define RtlFillMemory24(d, cj, c0, c1, c2)  LocalRtlFillMemory24((PVOID)(d),(ULONG)(cj),(BYTE)c0,(BYTE)c1,(BYTE)c2)

// RtlCopyMemory_UnalignedDst should be used if the src is guaranteed to have
// DWORD alignment, but the dst does not.
//
// RtlCopyMemory_UnalignedSrc should be used if the dst is guaranteed to have
// DWORD alignment, but the src does not.

#if defined(i386)
#define RtlFillMemory(d, cj, j)             LocalFillMemory((PBYTE)(d),(ULONG)(cj),(BYTE)(j))
#define RtlZeroMemory(d, cj)                LocalZeroMemory((PBYTE)(d),(ULONG)(cj))
#define RtlCopyMemory_UnalignedDst(d, s, l) LocalWriteMemoryAlign((PBYTE)(d),(PBYTE)(s),(ULONG)(l))
#define RtlCopyMemory_UnalignedSrc(d, s, l) LocalReadMemoryAlign((PBYTE)(d),(PBYTE)(s),(ULONG)(l))
#else
#define RtlFillMemory(d, cj, j)             memset((d),(j),(cj))
#define RtlZeroMemory(d, cj)                memset((d),0,(cj))
#define RtlCopyMemory_UnalignedDst(d, s, l) memcpy((d),(s),(l))
#define RtlCopyMemory_UnalignedSrc(d, s, l) memcpy((d),(s),(l))
#endif

#include "oleauto.h"
#include "batchinf.h"
#include "glteb.h"
#include "debug.h"
#include "asm.h"

#endif /* __glos_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\render.h ===
#ifndef __glrender_h_
#define __glrender_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"
#include "constant.h"
#include "cpu.h"
#ifdef GL_WIN_phong_shading
#include "phong.h"
#endif //GL_WIN_phong_shading

/* 
** used to approximate zero (and avoid divide by zero errors)
** when doing polygon offset with dzdx = 0.
*/
#define __GL_PGON_OFFSET_NEAR_ZERO .00001

/* 
** Epsilon value for detecting non-scaling transformation matrices:
*/

#define __GL_MATRIX_UNITY_SCALE_EPSILON ((__GLfloat)0.0001)


typedef GLuint __GLstippleWord;

/*
** A fragment is a collection of all the data needed after rasterization
** of a primitive has occured, but before the data is entered into various
** framebuffers.  The data contained in the fragment has been normalized
** into a form for immediate storage into the framebuffer.
*/
struct __GLfragmentRec {
    /* Screen x, y */
    GLint x, y;

    /* Z coordinate in form used by depth buffer */
    __GLzValue z;

    /*
    ** Color of the fragment.  When in colorIndexMode only the r component
    ** is valid.
    */
    __GLcolor color;

    /* Texture information for the fragment */
    __GLfloat s, t, qw;

    /* Fog information for the fragment */
    __GLfloat f;
};

/************************************************************************/

/*
** Shader record for iterated objects (lines/triangles).  This keeps
** track of all the various deltas needed to rasterize a triangle.
*/
struct __GLshadeRec {
    GLint dxLeftLittle, dxLeftBig;
    GLint dxLeftFrac;
    GLint ixLeft, ixLeftFrac;

    GLint dxRightLittle, dxRightBig;
    GLint dxRightFrac;
    GLint ixRight, ixRightFrac;

    __GLfloat area;
    __GLfloat dxAC, dxBC, dyAC, dyBC;

    __GLfragment frag;
    GLint length;

    /* Color */
    __GLfloat rLittle, gLittle, bLittle, aLittle;
    __GLfloat rBig, gBig, bBig, aBig;
    __GLfloat drdx, dgdx, dbdx, dadx;
    __GLfloat drdy, dgdy, dbdy, dady;

    /* Depth */
    GLint zLittle, zBig;
    GLint dzdx;
    __GLfloat dzdyf, dzdxf;

    /* Texture */
    __GLfloat sLittle, tLittle, qwLittle;
  __GLfloat sBig, tBig, qwBig;
    __GLfloat dsdx, dtdx, dqwdx;
    __GLfloat dsdy, dtdy, dqwdy;

    __GLfloat fLittle, fBig;
    __GLfloat dfdy, dfdx;

    GLuint modeFlags;

    __GLzValue *zbuf;
    GLint zbufBig, zbufLittle;

    __GLstencilCell *sbuf;
    GLint sbufBig, sbufLittle;

    __GLcolor *colors;
    __GLcolor *fbcolors;
    __GLstippleWord *stipplePat;
    GLboolean done;

    __GLcolorBuffer *cfb;

#ifdef GL_WIN_phong_shading
    __GLphongShade phong;
#endif //GL_WIN_phong_shading
};


/*
** The distinction between __GL_SHADE_SMOOTH and __GL_SHADE_SMOOTH_LIGHT is
** simple.  __GL_SHADE_SMOOTH indicates if the polygon will be smoothly 
** shaded, and __GL_SHADE_SMOOTH_LIGHT indicates if the polygon will be 
** lit at each vertex.  Note that __GL_SHADE_SMOOTH might be set while
** __GL_SHADE_SMOOTH_LIGHT is not set if the lighting model is GL_FLAT, but
** the polygons are fogged.
*/
#define __GL_SHADE_RGB		0x0001
#define __GL_SHADE_SMOOTH	0x0002 /* smooth shaded polygons */
#define __GL_SHADE_DEPTH_TEST	0x0004
#define __GL_SHADE_TEXTURE	0x0008
#define __GL_SHADE_STIPPLE	0x0010 /* polygon stipple */
#define __GL_SHADE_STENCIL_TEST	0x0020
#define __GL_SHADE_DITHER	0x0040
#define __GL_SHADE_LOGICOP	0x0080
#define __GL_SHADE_BLEND	0x0100
#define __GL_SHADE_ALPHA_TEST	0x0200
#define __GL_SHADE_TWOSIDED	0x0400
#define __GL_SHADE_MASK		0x0800

/* Two kinds of fog... */
#define __GL_SHADE_SLOW_FOG	0x1000
#define __GL_SHADE_CHEAP_FOG	0x2000

/* do we iterate depth values in software */
#define __GL_SHADE_DEPTH_ITER	0x4000

#define __GL_SHADE_LINE_STIPPLE	0x8000

#define __GL_SHADE_CULL_FACE	0x00010000
#define __GL_SHADE_SMOOTH_LIGHT	0x00020000 /* smoothly lit polygons */

// Set when the texture mode makes polygon color irrelevant
#define __GL_SHADE_FULL_REPLACE_TEXTURE 0x00040000

#ifdef GL_WIN_phong_shading
/* 
** This is set when shade-model is GL_PHONG_EXT and Lighting is ON
** otherwise use smooth shading.
** Used in place of __GL_SHADE_SMOOTH_LIGHT when ShadeModel is 
** GL_PHONG_EXT.
*/
#define __GL_SHADE_PHONG    0x00100000
#endif //GL_WIN_phong_shading
// Set when the current sub-triangle is the last (or only) subtriangle
#define __GL_SHADE_LAST_SUBTRI		0x00080000
#ifdef GL_WIN_specular_fog
// Set when the specularly-lit textures are needed using fog.
#define __GL_SHADE_SPEC_FOG		0x00200000
#endif //GL_WIN_specular_fog
#define __GL_SHADE_COMPUTE_FOG	0x00400000
#define __GL_SHADE_INTERP_FOG	0x00800000

/************************************************************************/

/*
** __GL_STIPPLE_COUNT_BITS is the number of bits needed to represent a 
** stipple count (5 bits).
**
** __GL_STIPPLE_BITS is the number of bits in a stipple word (32 bits).
*/
#define __GL_STIPPLE_COUNT_BITS 5
#define __GL_STIPPLE_BITS (1 << __GL_STIPPLE_COUNT_BITS)

#ifdef __GL_STIPPLE_MSB
#define __GL_STIPPLE_SHIFT(i) (1 << (__GL_STIPPLE_BITS - 1 - (i)))
#else
#define __GL_STIPPLE_SHIFT(i) (1 << (i))
#endif

#define __GL_MAX_STIPPLE_WORDS \
    ((__GL_MAX_MAX_VIEWPORT + __GL_STIPPLE_BITS - 1) / __GL_STIPPLE_BITS)

#ifdef NT
// Allow 256 bytes of stipple on the stack.  This may seem small but
// stipples are consumed a bit at a time so this is good enough for
// 2048 stipple bits
#define __GL_MAX_STACK_STIPPLE_BITS \
    2048
#define __GL_MAX_STACK_STIPPLE_WORDS \
    ((__GL_MAX_STACK_STIPPLE_BITS+__GL_STIPPLE_BITS-1)/__GL_STIPPLE_BITS)
#endif

/************************************************************************/

/*
** Accumulation buffer cells for each color component.  Note that these
** items needs to be at least 2 bits bigger than the color components
** that drive them, with 2 times being ideal.  This declaration assumes
** that the underlying color components are no more than 14 bits and
** hopefully 8.
*/
typedef struct __GLaccumCellRec {
    __GLaccumCellElement r, g, b, a;
} __GLaccumCell;

/************************************************************************/

struct __GLbitmapRec {
        GLsizei width;
        GLsizei height;
        GLfloat xorig;
        GLfloat yorig;
        GLfloat xmove;
        GLfloat ymove;
	GLint imageSize;		/* An optimization */
        /*      bitmap  */
};

extern void __glDrawBitmap(__GLcontext *gc, GLsizei width, GLsizei height,
			   GLfloat xOrig, GLfloat yOrig,
			   GLfloat xMove, GLfloat yMove,
			   const GLubyte bits[]);

extern __GLbitmap *__glAllocBitmap(__GLcontext *gc,
				   GLsizei width, GLsizei height,
				   GLfloat xOrig, GLfloat yOrig,
				   GLfloat xMove, GLfloat yMove);
				
extern void FASTCALL __glRenderBitmap(__GLcontext *gc, const __GLbitmap *bitmap,
			     const GLubyte *bits);

/************************************************************************/

/* New AA line algorithm supports widths one or more.  Until that changes,
** don't change this minimum!
*/
#define __GL_POINT_SIZE_MINIMUM		 ((__GLfloat) 1.0)
#define __GL_POINT_SIZE_MAXIMUM		((__GLfloat) 10.0)
#define __GL_POINT_SIZE_GRANULARITY	 ((__GLfloat) 0.125)

extern void FASTCALL __glBeginPoints(__GLcontext *gc);
extern void FASTCALL __glEndPoints(__GLcontext *gc);

extern void FASTCALL __glPoint(__GLcontext *gc, __GLvertex *vx);
extern void FASTCALL __glPointFast(__GLcontext *gc, __GLvertex *vx);

/* Various point rendering implementations */
void FASTCALL __glRenderAliasedPointN(__GLcontext *gc, __GLvertex *v);
void FASTCALL __glRenderAliasedPoint1(__GLcontext *gc, __GLvertex *v);
void FASTCALL __glRenderAliasedPoint1_NoTex(__GLcontext *gc, __GLvertex *v);
#ifdef __BUGGY_RENDER_POINT
void FASTCALL __glRenderFlatFogPoint(__GLcontext *gc, __GLvertex *v);
#ifdef NT
void FASTCALL __glRenderFlatFogPointSlow(__GLcontext *gc, __GLvertex *v);
#endif
#endif //__BUGGY_RENDER_POINT

void FASTCALL __glRenderAntiAliasedRGBPoint(__GLcontext *gc, __GLvertex *v);
void FASTCALL __glRenderAntiAliasedCIPoint(__GLcontext *gc, __GLvertex *v);

/************************************************************************/

#define __GL_LINE_WIDTH_MINIMUM		 ((__GLfloat) 0.5)
#define __GL_LINE_WIDTH_MAXIMUM		((__GLfloat) 10.0)
#define __GL_LINE_WIDTH_GRANULARITY	 ((__GLfloat) 0.125)

/*
** Don't change these constants without fixing LIGHT/rex_linespan.ma which
** currently assumes that __GL_X_MAJOR is 0.
*/
#define __GL_X_MAJOR    0
#define __GL_Y_MAJOR    1

/*
** Use a fixed point notation of 15.17
**
** This should support screen sizes up to 4K x 4K, with 5 subpixel bits
** for 4K x 4K screens.
*/
#define __GL_LINE_FRACBITS              17
#define __GL_LINE_INT_TO_FIXED(x)       ((x) << __GL_LINE_FRACBITS)
#define __GL_LINE_FLOAT_TO_FIXED(x)     ((x) * (1 << __GL_LINE_FRACBITS))
#define __GL_LINE_FIXED_ONE             (1 << __GL_LINE_FRACBITS)
#define __GL_LINE_FIXED_HALF            (1 << (__GL_LINE_FRACBITS-1))
#define __GL_LINE_FIXED_TO_FLOAT(x) 	(((GLfloat) (x)) / __GL_LINE_FIXED_ONE)
#define __GL_LINE_FIXED_TO_INT(x)       (((unsigned int) (x)) >> __GL_LINE_FRACBITS)

/*
** Contains variables needed to draw all line options.
*/
struct __GLlineOptionsRec {
    GLint axis, numPixels;
    __GLfloat offset, length, oneOverLength;
    GLint xStart, yStart;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    __GLfloat curF, curR, curG, curB, curA, curS, curT, curQW;
    __GLzValue curZ;
    __GLfloat antiAliasPercent;
    __GLfloat f0;
    GLint width;
    const __GLvertex *v0, *v1;

    /* Anti-aliased line only info */
    __GLfloat realLength;
    __GLfloat dldx, dldy;
    __GLfloat dddx, dddy;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLfloat plength, pwidth;

    /* Anti-aliased stippled lines only */
    __GLfloat stippleOffset;
    __GLfloat oneOverStippleRepeat;
};

/*
** Line state.  Contains all the line specific state, as well as
** procedure pointers used during rendering operations.
*/
typedef struct {
    /*
    ** stipplePosition indicates which bit in mask is being examined
    ** for the next pixel in the line to be rendered.  It is also used
    ** by feedback lines to determine if they are the first of a connected
    ** loop.
    */
    GLint stipplePosition;

    /*
    ** Repeat factor.  After repeat is reduced to zero the
    ** stipplePosition is updated.
    */
    GLint repeat;

    /*
    ** Set to FALSE when the stipple needs to be reset.
    */
    GLboolean notResetStipple;

    __GLlineOptions options;
} __GLlineMachine;

#ifdef NT
// renderLine flags
#define __GL_LVERT_FIRST        0x0001
#endif

void FASTCALL __glBeginLStrip(__GLcontext *gc);
void FASTCALL __glEndLStrip(__GLcontext *gc);
void FASTCALL __glBeginLLoop(__GLcontext *gc);
void FASTCALL __glEndLLoop(__GLcontext *gc);
void FASTCALL __glBeginLines(__GLcontext *gc);
void FASTCALL __glEndLines(__GLcontext *gc);

#ifdef NT
void FASTCALL __glClipLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                           GLuint flags);
void FASTCALL __glNopLineBegin(__GLcontext *gc);
void FASTCALL __glNopLineEnd(__GLcontext *gc);
#else
void FASTCALL __glClipLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif

#ifdef NT
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0,
                                  __GLvertex *v1, GLuint flags);
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
                                    __GLvertex *v1, GLuint flags);
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0,
                                      __GLvertex *v1, GLuint flags);
BOOL FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#else
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
			   __GLvertex *v1);
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
void FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif

/*
** Line procs
*/
GLboolean FASTCALL __glProcessLine(__GLcontext *);
GLboolean FASTCALL __glProcessLine3NW(__GLcontext *);
GLboolean FASTCALL __glWideLineRep(__GLcontext *);
GLboolean FASTCALL __glDrawBothLine(__GLcontext *);
GLboolean FASTCALL __glScissorLine(__GLcontext *);
GLboolean FASTCALL __glStippleLine(__GLcontext *);
GLboolean FASTCALL __glStencilTestLine(__GLcontext *);
#ifdef NT
GLboolean FASTCALL __glDepth16TestStencilLine(__GLcontext *);
#endif
GLboolean FASTCALL __glDepthTestStencilLine(__GLcontext *);
GLboolean FASTCALL __glDepthPassLine(__GLcontext *);
GLboolean FASTCALL __glDitherCILine(__GLcontext *);
GLboolean FASTCALL __glDitherRGBALine(__GLcontext *);
GLboolean FASTCALL __glStoreLine(__GLcontext *);
GLboolean FASTCALL __glAntiAliasLine(__GLcontext *);

#ifdef __GL_USEASMCODE
GLboolean FASTCALL __glDepthTestLine_asm(__GLcontext *gc);

/*
** A LEQUAL specific line depth tester because LEQUAL is the method of
** choice.  :)
*/
GLboolean FASTCALL __glDepthTestLine_LEQ_asm(__GLcontext *gc);

/* Assembly routines */
void __glDTP_LEQUAL(void);
void __glDTP_EQUAL(void);
void __glDTP_GREATER(void);
void __glDTP_NOTEQUAL(void);
void __glDTP_GEQUAL(void);
void __glDTP_ALWAYS(void);
void __glDTP_LESS(void);
void __glDTP_LEQUAL_M(void);
void __glDTP_EQUAL_M(void);
void __glDTP_GREATER_M(void);
void __glDTP_NOTEQUAL_M(void);
void __glDTP_GEQUAL_M(void);
void __glDTP_ALWAYS_M(void);
void __glDTP_LESS_M(void);
#else
#ifdef NT
GLboolean FASTCALL __glDepth16TestLine(__GLcontext *);
#endif
GLboolean FASTCALL __glDepthTestLine(__GLcontext *);
#endif

/*
** Line stippled procs
*/
GLboolean FASTCALL __glScissorStippledLine(__GLcontext *);
GLboolean FASTCALL __glWideStippleLineRep(__GLcontext *);
GLboolean FASTCALL __glDrawBothStippledLine(__GLcontext *);
GLboolean FASTCALL __glStencilTestStippledLine(__GLcontext *);
#ifdef NT
GLboolean FASTCALL __glDepth16TestStippledLine(__GLcontext *);
GLboolean FASTCALL __glDepth16TestStencilStippledLine(__GLcontext *);
#endif
GLboolean FASTCALL __glDepthTestStippledLine(__GLcontext *);
GLboolean FASTCALL __glDepthTestStencilStippledLine(__GLcontext *);
GLboolean FASTCALL __glDepthPassStippledLine(__GLcontext *);
GLboolean FASTCALL __glDitherCIStippledLine(__GLcontext *);
GLboolean FASTCALL __glDitherRGBAStippledLine(__GLcontext *);
GLboolean FASTCALL __glStoreStippledLine(__GLcontext *);
GLboolean FASTCALL __glAntiAliasStippledLine(__GLcontext *);


/* 
** C depth-test routines
*/
GLboolean FASTCALL __glDT_NEVER( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_LEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_LESS( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_EQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GREATER( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_NOTEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_ALWAYS( __GLzValue, __GLzValue * );

GLboolean FASTCALL __glDT_LEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_LESS_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_EQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GREATER_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_NOTEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_GEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT_ALWAYS_M( __GLzValue, __GLzValue * );

GLboolean FASTCALL __glDT16_LEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_LESS( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_EQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GREATER( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_NOTEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GEQUAL( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_ALWAYS( __GLzValue, __GLzValue * );

GLboolean FASTCALL __glDT16_LEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_LESS_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_EQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GREATER_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_NOTEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_GEQUAL_M( __GLzValue, __GLzValue * );
GLboolean FASTCALL __glDT16_ALWAYS_M( __GLzValue, __GLzValue * );

extern GLboolean (FASTCALL *__glCDTPixel[32])(__GLzValue, __GLzValue * );

/************************************************************************/

/*
** Polygon machine state.  Contains all the polygon specific state,
** as well as procedure pointers used during rendering operations.
*/
typedef struct __GLpolygonMachineRec {
    /*
    ** Internal form of users stipple.  Users stipple is always
    ** normalized to stippleWord sized with the LSB of each word mapping
    ** to the left x coordinate.
    */
    __GLstippleWord stipple[32];

    /*
    ** Polygon (triangle really) shading state.  Used by polygon fillers
    ** and span routines.
    */
    __GLshade shader;

    /*
    ** Lookup table that returns the face (0=front, 1=back) when indexed
    ** by a flag which is zero for CW and 1 for CCW.  If FrontFace is CW:
    ** 	face[0] = 0
    ** 	face[1] = 1
    ** else
    ** 	face[0] = 1
    ** 	face[1] = 0
    */
    GLubyte face[2];

    /*
    ** Internal form of polygon mode for each face
    */
    GLubyte mode[2];

    /*
    ** Culling flag.  0 when culling the front face, 1 when culling the
    ** back face and 2 when not culling.
    */
    GLubyte cullFace;
} __GLpolygonMachine;

/* defines for above cullFlag */
#define __GL_CULL_FLAG_FRONT	__GL_FRONTFACE
#define __GL_CULL_FLAG_BACK	__GL_BACKFACE
#define __GL_CULL_FLAG_DONT	2

/* Indicies for face[] array in polygonMachine above */
#define __GL_CW		0
#define __GL_CCW	1

/* Internal numbering for polymode values */
#define __GL_POLYGON_MODE_FILL	(GL_FILL & 0xf)
#define __GL_POLYGON_MODE_LINE	(GL_LINE & 0xf)
#define __GL_POLYGON_MODE_POINT	(GL_POINT & 0xf)

extern void FASTCALL __glBeginPolygon(__GLcontext *gc);
extern void FASTCALL __glBeginQStrip(__GLcontext *gc);
extern void FASTCALL __glBeginQuads(__GLcontext *gc);
extern void FASTCALL __glBeginTFan(__GLcontext *gc);
extern void FASTCALL __glBeginTriangles(__GLcontext *gc);
extern void FASTCALL __glBeginTStrip(__GLcontext *gc);

extern void FASTCALL __glClipTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			     __GLvertex *c, GLuint orClipCodes);
extern void FASTCALL __glClipPolygon(__GLcontext *gc, __GLvertex *v0, GLint nv);
extern void __glDoPolygonClip(__GLcontext *gc, __GLvertex **vp, GLint nv,
			      GLuint orClipCodes);
extern void FASTCALL __glFrustumClipPolygon(__GLcontext *gc, __GLvertex *v0, GLint nv);

extern void FASTCALL __glConvertStipple(__GLcontext *gc);

/* Rectangle processing proc */
extern void __glRect(__GLcontext *gc, __GLfloat x0, __GLfloat y0, 
	             __GLfloat x1, __GLfloat y1);

/*
** Triangle render proc that handles culling, twosided lighting and
** polygon mode.
*/
extern void FASTCALL __glRenderTriangle(__GLcontext *gc, __GLvertex *a,
			       __GLvertex *b, __GLvertex *c);
extern void FASTCALL __glRenderFlatTriangle(__GLcontext *gc, __GLvertex *a,
				   __GLvertex *b, __GLvertex *c);
extern void FASTCALL __glRenderSmoothTriangle(__GLcontext *gc, __GLvertex *a,
				     __GLvertex *b, __GLvertex *c);

#ifdef GL_WIN_phong_shading
extern void FASTCALL __glRenderPhongTriangle(__GLcontext *gc, __GLvertex *a,
				     __GLvertex *b, __GLvertex *c);
#endif //GL_WIN_phong_shading

extern void FASTCALL __glDontRenderTriangle(__GLcontext *gc, __GLvertex *a,
				   __GLvertex *b, __GLvertex *c);

/*
** Triangle filling procs for each polygon smooth mode
*/
void FASTCALL __glFillTriangle(__GLcontext *gc, __GLvertex *a,
		      __GLvertex *b, __GLvertex *c, GLboolean ccw);

#ifdef GL_WIN_phong_shading
extern void FASTCALL __glFillPhongTriangle(__GLcontext *gc, __GLvertex *a,
		      __GLvertex *b, __GLvertex *c, GLboolean ccw);
extern void FASTCALL __glFillAntiAliasedPhongTriangle(__GLcontext *gc, 
                                                      __GLvertex *a,
                                                      __GLvertex *b, 
                                                      __GLvertex *c,
                                                      GLboolean ccw);
#endif //GL_WIN_phong_shading

void FASTCALL __glFillFlatFogTriangle(__GLcontext *gc, __GLvertex *a,
			     __GLvertex *b, __GLvertex *c, 
			     GLboolean ccw);
void FASTCALL __glFillAntiAliasedTriangle(__GLcontext *gc, __GLvertex *a,
				 __GLvertex *b, __GLvertex *c,
				 GLboolean ccw);

#ifdef GL_WIN_specular_fog
void FASTCALL __glFillFlatSpecFogTriangle(__GLcontext *gc, __GLvertex *a,
                                          __GLvertex *b, __GLvertex *c, 
                                          GLboolean ccw);
#endif //GL_WIN_specular_fog


/*
** Polygon offset calc
*/
extern __GLfloat __glPolygonOffsetZ(__GLcontext *gc );

/*
** Span procs
*/
extern GLboolean FASTCALL __glProcessSpan(__GLcontext *);
extern GLboolean FASTCALL __glProcessReplicateSpan(__GLcontext *);
extern GLboolean FASTCALL __glClipSpan(__GLcontext *);
extern GLboolean FASTCALL __glStippleSpan(__GLcontext *);
extern GLboolean FASTCALL __glAlphaTestSpan(__GLcontext *);

#ifdef __GL_USEASMCODE
/* Assembly routines */
void FASTCALL __glDTS_LEQUAL(void);
void FASTCALL __glDTS_EQUAL(void);
void FASTCALL __glDTS_GREATER(void);
void FASTCALL __glDTS_NOTEQUAL(void);
void FASTCALL __glDTS_GEQUAL(void);
void FASTCALL __glDTS_ALWAYS(void);
void FASTCALL __glDTS_LESS(void);
void FASTCALL __glDTS_LEQUAL_M(void);
void FASTCALL __glDTS_EQUAL_M(void);
void FASTCALL __glDTS_GREATER_M(void);
void FASTCALL __glDTS_NOTEQUAL_M(void);
void FASTCALL __glDTS_GEQUAL_M(void);
void FASTCALL __glDTS_ALWAYS_M(void);
void FASTCALL __glDTS_LESS_M(void);
extern GLboolean FASTCALL __glStencilTestSpan_asm(__GLcontext *);
extern GLboolean FASTCALL __glDepthTestSpan_asm(__GLcontext *);
extern void (*__glSDepthTestPixel[16])(void);
#else
extern GLboolean FASTCALL __glStencilTestSpan(__GLcontext *);
#ifdef NT
extern GLboolean FASTCALL __glDepth16TestSpan(__GLcontext *);
#endif
extern GLboolean FASTCALL __glDepthTestSpan(__GLcontext *);
#endif

#ifdef NT
extern GLboolean FASTCALL __glDepth16TestStencilSpan(__GLcontext *);
#endif
extern GLboolean FASTCALL __glDepthTestStencilSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepthPassSpan(__GLcontext *);
extern GLboolean FASTCALL __glColorSpan1(__GLcontext *);
extern GLboolean FASTCALL __glColorSpan2(__GLcontext *);
extern GLboolean FASTCALL __glColorSpan3(__GLcontext *);
extern GLboolean FASTCALL __glFlatRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glShadeRGBASpan(__GLcontext *);

#ifdef GL_WIN_phong_shading
extern GLboolean FASTCALL __glPhongRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glPhongCISpan(__GLcontext *);
extern GLboolean FASTCALL __glPhongRGBALineSpan(__GLcontext *);
extern GLboolean FASTCALL __glPhongCILineSpan(__GLcontext *);
#endif //GL_WIN_phong_shading

extern GLboolean FASTCALL __glFlatCISpan(__GLcontext *);
extern GLboolean FASTCALL __glShadeCISpan(__GLcontext *);
extern GLboolean FASTCALL __glTextureSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogSpanSlow(__GLcontext *);
extern GLboolean FASTCALL __glDrawBothSpan(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan1(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan2(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan3(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateSpan4(__GLcontext *);
extern GLboolean FASTCALL __glDitherRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glDitherCISpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundCISpan(__GLcontext*);
extern GLboolean FASTCALL __glLogicOpSpan(__GLcontext *);
extern GLboolean FASTCALL __glMaskRGBASpan(__GLcontext *);
extern GLboolean FASTCALL __glMaskCISpan(__GLcontext *);

/*
** Stippled span procs
*/
extern GLboolean FASTCALL __glStippleStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glAlphaTestStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glStencilTestStippledSpan(__GLcontext *);
#ifdef NT
extern GLboolean FASTCALL __glDepth16TestStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepth16TestStencilStippledSpan(__GLcontext *);
#endif
extern GLboolean FASTCALL __glDepthTestStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepthTestStencilStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDepthPassStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glColorStippledSpan1(__GLcontext *);
extern GLboolean FASTCALL __glColorStippledSpan2(__GLcontext *);
extern GLboolean FASTCALL __glColorStippledSpan3(__GLcontext *);
extern GLboolean FASTCALL __glTextureStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glFogStippledSpanSlow(__GLcontext *);
extern GLboolean FASTCALL __glDrawBothStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan1(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan2(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan3(__GLcontext *);
extern GLboolean FASTCALL __glIntegrateStippledSpan4(__GLcontext *);
extern GLboolean FASTCALL __glBlendStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDitherRGBAStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glDitherCIStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundRGBAStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glRoundCIStippledSpan(__GLcontext *);
extern GLboolean FASTCALL __glLogicOpStippledSpan(__GLcontext *);

/************************************************************************/

extern void FASTCALL __glValidateAlphaTest(__GLcontext *gc);

/************************************************************************/

extern void FASTCALL __glValidateStencil(__GLcontext *gc, __GLstencilBuffer *sfb);

#define __GL_STENCIL_RANGE	(1 << (sizeof(__GLstencilCell) * 8))/*XXX*/
#define __GL_MAX_STENCIL_VALUE	(__GL_STENCIL_RANGE - 1)

/************************************************************************/

void __glFogFragmentSlow(__GLcontext *gc, __GLfragment *fr, __GLfloat f);
__GLfloat FASTCALL __glFogVertex(__GLcontext *gc, __GLvertex *fr);
__GLfloat FASTCALL __glFogVertexLinear(__GLcontext *gc, __GLvertex *fr);
void __glFogColorSlow(__GLcontext *gc, __GLcolor *out, __GLcolor *in,
		      __GLfloat fog);

/************************************************************************/

/* color index anti-alias support function */
extern __GLfloat __glBuildAntiAliasIndex(__GLfloat idx,
				         __GLfloat antiAliasPercent);

/************************************************************************/

/*
** Dithering implementation stuff.
*/
#define	__GL_DITHER_BITS 4
#define	__GL_DITHER_PRECISION (1 << __GL_DITHER_BITS)
#define	__GL_DITHER_INDEX(x,y) (((x) & 3) + (((y) & 3) << 2))

extern GLbyte __glDitherTable[16];

#endif /* __glrender_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\select.h ===
#ifndef _select_h_
#define _select_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.3 $
** $Date: 1992/10/13 14:13:28 $
*/
#include "types.h"

typedef struct __GLselectMachineRec {
    /*
    ** This is true when the last primitive to execute hit (intersected)
    ** the selection box.  Whenever the name stack is manipulated this
    ** bit is cleared.
    */
    GLboolean hit;

    /*
    ** Name stack.
    */
    GLuint *stack;
    GLuint *sp;

    /*
    ** The user specified result array overflows, this bit is set.
    */
    GLboolean overFlowed;

    /*
    ** User specified result array.  As primitives are processed names
    ** will be entered into this array.
    */
    GLuint *resultBase;

    /*
    ** Current pointer into the result array.
    */
    GLuint *result;

    /*
    ** The number of GLint's that the array can hold.
    */
    GLint resultLength;

    /*
    ** Number of hits
    */
    GLint hits;

    /*
    ** Pointer to z values for last hit.
    */
    GLuint *z;
} __GLselectMachine;

extern void __glSelectHit(__GLcontext *gc, __GLfloat z);

#ifdef NT
extern void FASTCALL __glSelectLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b, GLuint flags);
#else
extern void FASTCALL __glSelectLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b);
#endif
extern void FASTCALL __glSelectPoint(__GLcontext *gc, __GLvertex *v);
extern void FASTCALL __glSelectTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                                        __GLvertex *c);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\span.h ===
/******************************Module*Header*******************************\
* Module Name: span.h
*
* This include file is used to generate various flavors of textured and
* shaded spans, or scanlines.
*
* 14-Oct-1994   mikeke  Combined span_t.h and span_s.h to share common
*                       code.  Speeded things up a little.  Had a little
*                       fun with the C preprocessor.
* 11-April-1994 Otto Berkes [ottob] Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#undef STRING1
#undef STRING2
#undef STRING3
#undef STRING4

#if GENERIC
    void FASTCALL __fastGenSpan
#else
    #if ZBUFFER
        #define STRING1 __fastGenMask
    #else
        #define STRING1 __fastGen
    #endif

    #if TEXTURE
        #if SHADE
            #define STRING2 Tex
        #else
            #define STRING2 TexDecal
        #endif
    #elif RGBMODE
        #define STRING2 RGB
    #else
        #define STRING2 CI
    #endif

    #if DITHER
        #define STRING3 STRCAT2(COLORFORMAT, Dith)
    #else
        #define STRING3 COLORFORMAT
    #endif

    #define STRING4 Span

    void FASTCALL STRCAT4(STRING1, STRING2, STRING3, STRING4)
#endif
(__GLGENcontext *gengc)
{
    #if (SHADE) || !(RGBMODE) || (TEXTURE && DITHER)
        ULONG rAccum;
        LONG rDelta;

        #if RGBMODE
            ULONG gAccum;
            ULONG bAccum;
            LONG gDelta;
            LONG bDelta;
        #endif
    #endif

    #if TEXTURE
        LONG sAccum;
        LONG tAccum;
        LONG sDelta;
        LONG tDelta;
        ULONG tShift;
        ULONG sMask, tMask;
    #endif

    ULONG rShift;
    ULONG rBits;
    #if RGBMODE
        ULONG gShift;
        ULONG gBits;
        ULONG bShift;
        ULONG bBits;
    #endif

    BYTE *pPix;
    BYTE *texAddr;
    BYTE *texBits;
    LONG count;
    LONG totalCount;

    #if DITHER
        PDWORD pdither;
        #if (BPP == 24) || (GENERIC)
            DWORD iDither;
        #endif
    #endif

    #if (BPP == 8) || (GENERIC)
        BYTE *pXlat;
    #elif (!RGBMODE)
        ULONG *pXlat;
    #endif

    #if GENERIC
        DWORD flags = GENACCEL(gengc).flags;
        DWORD bpp = GENACCEL(gengc).bpp;
    #endif

    #if GENERIC
        if (flags & GEN_TEXTURE)
    #endif
    #if TEXTURE
        {
            __GLtexture *tex = ((__GLcontext *)gengc)->texture.currentTexture;

            sMask = GENACCEL(gengc).sMask;
            tMask = GENACCEL(gengc).tMask;
            tShift = GENACCEL(gengc).tShift;
            sDelta = GENACCEL(gengc).spanDelta.s;
            tDelta = GENACCEL(gengc).spanDelta.t;
            sAccum = GENACCEL(gengc).spanValue.s;
            tAccum = GENACCEL(gengc).spanValue.t;
            #if !(SHADE) && !(DITHER) && ((BPP == 8) || (BPP == 16))
                texAddr = (BYTE *)GENACCEL(gengc).texImageReplace;
            #else
                texAddr = (BYTE *)GENACCEL(gengc).texImage;
            #endif
        }
    #endif

    // get color deltas and accumulators

    #ifndef RSHIFT
        rShift = gengc->gsurf.pfd.cRedShift;
	rBits = gengc->gsurf.pfd.cRedBits;
        #if RGBMODE
            gShift = gengc->gsurf.pfd.cGreenShift;
	    gBits = gengc->gsurf.pfd.cGreenBits;
            bShift = gengc->gsurf.pfd.cBlueShift;
	    bBits = gengc->gsurf.pfd.cBlueBits;
        #endif
    #endif

    #if (GENERIC)
        if (!(flags & GEN_SHADE) && 
            (flags & (GEN_TEXTURE | GEN_DITHER)) == (GEN_TEXTURE | GEN_DITHER)) {
            rAccum = (GENACCEL(gengc).spanValue.r >> rBits) & 0xff00;
            gAccum = (GENACCEL(gengc).spanValue.g >> gBits) & 0xff00;
            bAccum = (GENACCEL(gengc).spanValue.b >> bBits) & 0xff00;
            rDelta = 0;
            gDelta = 0;
            bDelta = 0;
        } else {
            rAccum = GENACCEL(gengc).spanValue.r;
            gAccum = GENACCEL(gengc).spanValue.g;
            bAccum = GENACCEL(gengc).spanValue.b;
            rDelta = GENACCEL(gengc).spanDelta.r;
            gDelta = GENACCEL(gengc).spanDelta.g;
            bDelta = GENACCEL(gengc).spanDelta.b;
        }
    #else

        #if !(SHADE) && (TEXTURE) && (DITHER)
            #ifndef RSHIFT
                rAccum = (GENACCEL(gengc).spanValue.r >> rBits) & 0xff00;
                gAccum = (GENACCEL(gengc).spanValue.g >> gBits) & 0xff00;
                bAccum = (GENACCEL(gengc).spanValue.b >> bBits) & 0xff00;
            #else
                rAccum = (GENACCEL(gengc).spanValue.r >> RBITS) & 0xff00;
                gAccum = (GENACCEL(gengc).spanValue.g >> GBITS) & 0xff00;
                bAccum = (GENACCEL(gengc).spanValue.b >> BBITS) & 0xff00;
            #endif
        #else
            #if (SHADE) || !(RGBMODE)
                rAccum = GENACCEL(gengc).spanValue.r;
                #if RGBMODE
                    gAccum = GENACCEL(gengc).spanValue.g;
                    bAccum = GENACCEL(gengc).spanValue.b;
                #endif
            #endif
        #endif

        #if (SHADE) || !(RGBMODE)
            rDelta = GENACCEL(gengc).spanDelta.r;
            #if RGBMODE
                gDelta = GENACCEL(gengc).spanDelta.g;
                bDelta = GENACCEL(gengc).spanDelta.b;
            #endif
        #endif
    #endif

    // get address of destination

    if (GENACCEL(gengc).flags & SURFACE_TYPE_DIB) {
        pPix = GENACCEL(gengc).pPix +
            gengc->gc.polygon.shader.frag.x * (BPP / 8);
    } else {
        pPix = gengc->ColorsBits;
    }

    // set up pointer to translation table as needed

    #if GENERIC
        if ((bpp != 8) && (!(flags & GEN_RGBMODE))) {
            pXlat = gengc->pajTranslateVector + sizeof(DWORD);
        }
    #else
        #if (BPP == 8)
            // No need to set up xlat vector
        #elif (!RGBMODE)
            pXlat = (ULONG *)(gengc->pajTranslateVector + sizeof(DWORD));
        #endif
    #endif

    #if GENERIC
        if (GENACCEL(gengc).flags & GEN_DITHER) {
            // LATER !!! mikeke
            // fix this so the destination is always aligned with the x value
            // !!! make sure this is correct in generic case
            // look at flat it assumes alignment
            //

            if (GENACCEL(gengc).flags & GEN_TEXTURE)
                pdither = ditherTexture;
            else
                pdither = ditherShade;

            pdither += (gengc->gc.polygon.shader.frag.y & 0x3) * 8;
            iDither = gengc->gc.polygon.shader.frag.x & 0x3;
        } else {
            // LATER !!! mikeke
            // add these outside of the loop

            if (!(GENACCEL(gengc).flags & GEN_TEXTURE)) {
                rAccum += 0x0800;
                gAccum += 0x0800;
                bAccum += 0x0800;
            }
            //pdither = 0;
        }
    #else
        #if DITHER
            // LATER !!! mikeke
            // fix this so the destination is always aligned with the x value
            // !!! make sure this is correct in generic case
            // look at flat it assumes alignment
            //

            #if (BPP == 24)
                pdither = (gengc->gc.polygon.shader.frag.y & 0x3) * 8
                    #if (TEXTURE)
                        + ditherTexture
                    #else
                        + ditherShade
                    #endif
                    ;
                iDither = gengc->gc.polygon.shader.frag.x & 0x3;
            #else
                pdither = (gengc->gc.polygon.shader.frag.y & 0x3) * 8
                    #if (TEXTURE)
                        + ditherTexture
                    #else
                        + ditherShade
                    #endif

                    + ((
                          (gengc->gc.polygon.shader.frag.x & 0x3)
                        - (((ULONG_PTR)pPix / (BPP / 8)) & 0x3)
                      ) & 0x3 );
            #endif
        #else
            // LATER !!! mikeke
            // add these outside of the loop
            #if !(RGBMODE)
                rAccum += 0x0800;
            #else //RGBMODE
                #if (TEXTURE) && !(GENERIC)
                #else //!TEXTURE
                    rAccum += 0x0800;
                    gAccum += 0x0800;
                    bAccum += 0x0800;
                #endif //TEXTURE
            #endif //RGBMODE
        #endif
    #endif

    #if GENERIC
        {
            ULONG *pMask;

            pMask = gengc->gc.polygon.shader.stipplePat;

            for (totalCount = gengc->gc.polygon.shader.length;
                    totalCount > 0; totalCount -= 32
                ) {
                ULONG maskTest;
                ULONG mask = *pMask++;

                if (mask == 0) {
                    #if (SHADE) || !(RGBMODE)
                        rAccum += (rDelta << 5);
                        #if RGBMODE
                            gAccum += (gDelta << 5);
                            bAccum += (bDelta << 5);
                        #endif
                    #endif

                    #if TEXTURE
                        sAccum += (sDelta << 5);
                        tAccum += (tDelta << 5);
                    #endif

                    //iDither = (iDither + 32) & 0x3;
                    pPix += (32 * (BPP / 8));
                } else {
                    maskTest = 0x80000000;

                    if ((count = totalCount) > 32)
                        count = 32;

                    for (; count; count--, maskTest >>= 1) {
                        if (mask & maskTest) {
                            #include "spangen.h"
                        }
                        #include "span3.h"
                    }
                }
            }
        }
    #elif ZBUFFER
        {
            GLuint zAccum = gengc->gc.polygon.shader.frag.z;
            GLint  zDelta = gengc->gc.polygon.shader.dzdx;
            PBYTE zbuf = (PBYTE)gengc->gc.polygon.shader.zbuf;

            if (GENACCEL(gengc).flags & GEN_LESS) {
                if (gengc->gc.modes.depthBits == 16) {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) < *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 2;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                } else {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( zAccum < *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 4;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                }
            } else {
                if (gengc->gc.modes.depthBits == 16) {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 2;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                } else {
                    for (count = gengc->gc.polygon.shader.length;;) {
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;
                            #include "span2.h"
                        }
                        if (--count == 0)
                            return;
                        zbuf += 4;
                        zAccum += zDelta;
                        #include "span3.h"
                    }
                }
            }
        }
    #else
        for (count = gengc->gc.polygon.shader.length;;) {
            #include "span2.h"
            if (--count == 0)
                return;
            #include "span3.h"
        }
    #endif
}

#undef ditherVal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\span3.h ===
/******************************Module*Header*******************************\
* Module Name: span3.h
*
* This code advances all the values for the next pixel
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

    #if (SHADE) || !(RGBMODE)
        rAccum += rDelta;
        #if RGBMODE
            gAccum += gDelta;
            bAccum += bDelta;
        #endif
    #endif

    #if TEXTURE
        sAccum += sDelta;
        tAccum += tDelta;
    #endif

    #if GENERIC || ((DITHER) && (BPP == 24))
        iDither = (iDither + 1) & 0x3;
    #endif

    pPix += (BPP / 8);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\span2.h ===
/******************************Module*Header*******************************\
* Module Name: span2.h
*
* This code figures out the color for pixel and stores it
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

{
    DWORD r, g, b;
    DWORD color;
    #if DITHER
        #if (BPP == 8)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix) & 0x3];
        #elif (BPP == 16)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix & 0x6) >> 1];
        #elif (BPP == 24)
            ULONG ditherVal = pdither[iDither];
        #else
            ULONG ditherVal = pdither[((ULONG_PTR)pPix & 0xc) >> 2];
        #endif
    #else
        #if (RGBMODE) && (TEXTURE) && (SHADE)
            #define ditherVal 0x0008
        #else
            #define ditherVal 0x0000
        #endif
    #endif

    #if TEXTURE
        #if !(SHADE) && !(DITHER) && (BPP == 8)
            texBits = (BYTE *)(texAddr + ((sAccum & GENACCEL(gengc).sMask) >> 16) +
                                          ((tAccum & GENACCEL(gengc).tMask) >> GENACCEL(gengc).tShift));
        #elif !(SHADE) && !(DITHER) && (BPP == 16)
            texBits = (BYTE *)(texAddr + ((sAccum & GENACCEL(gengc).sMask) >> 15) +
                                          ((tAccum & GENACCEL(gengc).tMask) >> GENACCEL(gengc).tShift));
        #else
            texBits = (BYTE *)(texAddr + ((sAccum & GENACCEL(gengc).sMask) >> 14) +
                                          ((tAccum & GENACCEL(gengc).tMask) >> GENACCEL(gengc).tShift));
        #endif
    #endif

    #if !(RGBMODE)
        // !!! probably don't need to mask values
        #if (BPP == 8)
            color = ((rAccum + ditherVal) >> 16) & 0xff;
        #else
            color = ((PULONG)pXlat)[(((rAccum + ditherVal) >> 16) & 0xfff)];
        #endif
    #else //RGBMODE
        #if TEXTURE
            #if SHADE
                 #define BIGSHIFT 8
                 #ifdef RSHIFT
                 r = ((ULONG)gbMulTable[(((rAccum >> RBITS) & 0xff00) | texBits[2])] << RBITS) + ditherVal;
                 g = ((ULONG)gbMulTable[(((gAccum >> GBITS) & 0xff00) | texBits[1])] << GBITS) + ditherVal;
                 b = ((ULONG)gbMulTable[(((bAccum >> BBITS) & 0xff00) | texBits[0])] << BBITS) + ditherVal;
                 #else
                 r = ((ULONG)gbMulTable[(((rAccum >> rBits) & 0xff00) | texBits[2])] << rBits) + ditherVal;
                 g = ((ULONG)gbMulTable[(((gAccum >> gBits) & 0xff00) | texBits[1])] << gBits) + ditherVal;
                 b = ((ULONG)gbMulTable[(((bAccum >> bBits) & 0xff00) | texBits[0])] << bBits) + ditherVal;
                 #endif
            #else //!SHADE
                #define BIGSHIFT 8
                #if DITHER
                    #ifdef RSHIFT
                    r = ((ULONG)gbMulTable[(rAccum | texBits[2])] << RBITS) + ditherVal;
                    g = ((ULONG)gbMulTable[(gAccum | texBits[1])] << GBITS) + ditherVal;
                    b = ((ULONG)gbMulTable[(bAccum | texBits[0])] << BBITS) + ditherVal;
                    #else
                    r = ((ULONG)gbMulTable[(rAccum | texBits[2])] << rBits) + ditherVal;
                    g = ((ULONG)gbMulTable[(gAccum | texBits[1])] << gBits) + ditherVal;
                    b = ((ULONG)gbMulTable[(bAccum | texBits[0])] << bBits) + ditherVal;
                    #endif
                #else //!DITHER
                    #if (!((BPP == 8) || (BPP == 16)))
                        #ifdef RSHIFT
                        r = (texBits[2] << RBITS);
                        g = (texBits[1] << GBITS);
                        b = (texBits[0] << BBITS);
                        #else
                        r = (texBits[2] << rBits);
                        g = (texBits[1] << gBits);
                        b = (texBits[0] << bBits);
                        #endif
                    #endif
                #endif  //DITHER
            #endif //SHADE
        #else //!TEXTURE
            #define BIGSHIFT 16
            r = rAccum + ditherVal;
            g = gAccum + ditherVal;
            b = bAccum + ditherVal;
        #endif //TEXTURE

        #if !((TEXTURE) && !(SHADE) && !(DITHER) && ((BPP == 8) || (BPP == 16)))

            #ifdef RSHIFT
                color = ((r >> BIGSHIFT) << RSHIFT) |
                        ((g >> BIGSHIFT) << GSHIFT) |
                        ((b >> BIGSHIFT) << BSHIFT);
            #else
                color = ((r >> BIGSHIFT) << rShift) |
                        ((g >> BIGSHIFT) << gShift) |
                        ((b >> BIGSHIFT) << bShift);
            #endif

        #endif

        #undef BIGSHIFT
    #endif //RGBMODE

    #if (TEXTURE) && !(SHADE) && !(DITHER) && ((BPP == 8) || (BPP == 16))
        #if (BPP == 8)
            *pPix = texBits[0];
        #else
            *((WORD *)pPix) = *((WORD *)texBits);
        #endif
    #else
        #if (BPP == 8)
            *pPix = gengc->xlatPalette[color & 0xff];
        #elif (BPP == 16)
            *((WORD *)pPix) = (USHORT)color;
        #elif (BPP == 24)
            *pPix = (BYTE)color;
            *(pPix + 1) = (BYTE)(color >> 8);
            *(pPix + 2) = (BYTE)(color >> 16);
        #else
            *((DWORD *)pPix) = color;
        #endif // BPP
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\spangen.h ===
/******************************Module*Header*******************************\
* Module Name: spangen.h
*
* This code figures out the color for pixel and stores it
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

{
    DWORD r, g, b;
    DWORD color;
    ULONG ditherVal;

    if (flags & GEN_DITHER) {
        ditherVal = pdither[iDither];
    } else {
        if ((flags & (GEN_SHADE | GEN_TEXTURE | GEN_RGBMODE)) ==
            (GEN_SHADE | GEN_TEXTURE | GEN_RGBMODE)) {
            ditherVal = 0x08;
        } else {
            ditherVal = 0x0000;
        }
    }

    if (!(flags & GEN_RGBMODE)) {
        if (BPP == 8) {
            color = ((rAccum + ditherVal) >> 16) & 0xff;
        } else {
            color = ((PULONG)pXlat)[(((rAccum + ditherVal) >> 16) & 0xfff)];
        }
    } else {
        if (flags & GEN_TEXTURE) {
            texBits = (texAddr + ((sAccum & sMask) >> 14) +
                                  ((tAccum & tMask) >> tShift));

            if (flags & GEN_SHADE) {
                r = ((ULONG)(gbMulTable[(((rAccum >> rBits) & 0xff00) | texBits[2])] << rBits) + ditherVal) >> 8;
                g = ((ULONG)(gbMulTable[(((gAccum >> gBits) & 0xff00) | texBits[1])] << gBits) + ditherVal) >> 8;
                b = ((ULONG)(gbMulTable[(((bAccum >> bBits) & 0xff00) | texBits[0])] << bBits) + ditherVal) >> 8;
            } else {
                if (flags & GEN_DITHER) {
                    r = ((ULONG)(gbMulTable[(rAccum | texBits[2])] << rBits) + ditherVal) >> 8;
                    g = ((ULONG)(gbMulTable[(gAccum | texBits[1])] << gBits) + ditherVal) >> 8;
                    b = ((ULONG)(gbMulTable[(bAccum | texBits[0])] << bBits) + ditherVal) >> 8;
                } else {
                    r = (texBits[2] << rBits) >> 8;
                    g = (texBits[1] << gBits) >> 8;
                    b = (texBits[0] << bBits) >> 8;
                }
            }
        } else {
            r = (rAccum + ditherVal) >> 16;
            g = (gAccum + ditherVal) >> 16;
            b = (bAccum + ditherVal) >> 16;
        }
        color = (r << rShift) |
                (g << gShift) |
                (b << bShift);
    }

    if (BPP == 8) {
        *pPix = gengc->xlatPalette[color & 0xff];
#ifdef OLDWAY
        if ((flags & (GEN_TEXTURE | GEN_SHADE | GEN_DITHER)) ==
             GEN_TEXTURE) {
            *pPix = (BYTE)color;
        } else {
            *pPix = (BYTE)pXlat[color & 0xff];
        }
#endif
    } else if (BPP == 16) {
        *((WORD *)pPix) = (USHORT)color;
    } else if (BPP == 24) {
        *pPix = (BYTE)color;
        *(pPix + 1) = (BYTE)(color >> 8);
        *(pPix + 2) = (BYTE)(color >> 16);
    } else {
        *((DWORD *)pPix) = color;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\procs.h ===
#ifndef __glprocs_h_
#define __glprocs_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "types.h"

/*
** These typedefs are used to normalize the calling conventions
** for the span procs.  Some of the arguments are not used by
** many of the span procs, but the arguments are present so that
** the function pointers in the spanProcsRec can be interchanged.
** The idea is to move up in the calling sequence as high as possible
** the final "store" span proc.
**
** The type __GLspanFunc returns GL_TRUE if it stippled the span while
** processing it.  If it also stippled the span all black, it sets
** gc->polygon.shader.done to GL_TRUE.
**
** The type __GLstippledSpanFunc return GL_TRUE if it stippled the span
** to all black, and GL_FALSE otherwise.
*/
typedef GLboolean (FASTCALL *__GLspanFunc)(__GLcontext *gc);
typedef GLboolean (FASTCALL *__GLstippledSpanFunc)(__GLcontext *gc);

#define __GL_MAX_SPAN_FUNCS	15
#define __GL_MAX_LINE_FUNCS	16

typedef struct __GLspanProcsRec {
    /*
    ** First phase of span processing.  Clip the span so that it won't
    ** render outside of the intersection of the window box and the
    ** scissor box.  Then call the stipple proc to replicate the stipple
    ** (and rotate it) sufficient for rendering w pixels.  If there is no
    ** active polygon stipple then the stipple proc is skipped, and the
    ** unstippled form of the next phase of procs is used until stippling
    ** becomes necessary.
    **
    ** Second phase of span processing.  Apply the various test functions 
    ** producing at the end a final stipple for the span.  
    ** Each test procedure outputs a new stipple as
    ** needed, calling the stippled form of the next proc only if the
    ** test failed somewhere in the span.
    **
    ** Next phase of span processing.  This phase is responsible for
    ** generating the final colors to be stored.  The operations are
    ** applied in order as shown below, producing at the end the final
    ** color values.  draw is used to replicate the span so that it
    ** properly renders to the correct number of destination buffers
    ** (e.g., when drawBuffer is FRONT_AND_BACK).
    **
    ** Final phase of span rendering.  Apply blend function, dither
    ** operation, logic-op and writemask before calling the store
    ** proc.  When blending, logic-oping, or writemasking is being done,
    ** the fetch proc will be used to read in the span (from the draw
    ** buffer) before proceeding furthur.
    */

    /*
    ** The 15 layers of the span procs are:
    **
    ** scissor, poly stipple, alpha test, stencil test, depth test, shading,
    ** texturing, fogging, FRONT_AND_BACK drawing, fetching, blending, 
    ** dithering, logic op, masking, storing.
    */
    __GLspanFunc spanFuncs[__GL_MAX_SPAN_FUNCS];
    __GLstippledSpanFunc stippledSpanFuncs[__GL_MAX_SPAN_FUNCS];

    /* 
    ** The number of procs stored in the span function arrays.  n is 
    ** the number applied prior to span replication (for drawing to both
    ** FRONT_AND_BACK buffers), and m is the total number applied.
    */
    GLint n, m;

    /*
    ** This is the root span function.  It is called when a span needs 
    ** processing.
    */
    __GLspanFunc processSpan;

    /*
    ** Assembly routine to depth test a single pixel.  There is no prototype,
    ** since variables are passed in registers.
    */
    void (*depthTestPixel)(void);
} __GLspanProcs;

typedef struct __GLlineProcsRec {
    /*
    ** The line procs are very similar to the span procs.  The biggest 
    ** difference is that they iterate along a line instead of a span.
    **
    ** The prototypes for the line procs are identical to the prototypes 
    ** to the poly span paths so that some of the leaves can be shared.
    **
    ** The layers of the line procs are as follows:
    **
    ** scissor, line stipple, alpha test, stencil test, depth test, shading,
    ** texturing, fogging, wide line duplication, FRONT_AND_BACK drawing, 
    ** fetching, blending, dithering, logic op, masking, storing.
    */
    __GLspanFunc lineFuncs[__GL_MAX_LINE_FUNCS];
    __GLstippledSpanFunc stippledLineFuncs[__GL_MAX_LINE_FUNCS];

    /* 
    ** The number of procs stored in the line function arrays.  n is 
    ** the number applied prior to wide line replication (for lines of 
    ** width greater than 1), m is the total number applied prior to 
    ** FRONT_AND_BACK line replication, and l is the total number applied
    ** altogether (l > m > n).
    */
    GLint n, m, l;

    /*
    ** This is the root line function.  It is called when a line needs 
    ** processing.
    */
    __GLspanFunc processLine;

    /*
    ** One of these procs is called after the first n procs have been
    ** completed.  This proc is responsible for replicating a wide line
    ** numerous times.
    */
    __GLspanFunc wideLineRep;
    __GLstippledSpanFunc wideStippledLineRep;

    /*
    ** One of these procs is called after the first m procs have been
    ** completed.  This proc is responsible for replication a line to 
    ** be drawn to both the FRONT and BACK buffers.
    */
    __GLspanFunc drawLine;
    __GLstippledSpanFunc drawStippledLine;

    /*
    ** Assembly routine to depth test a single pixel.  There is no prototype,
    ** since variables are passed in registers.
    **
    ** depthTestPixel is for unstippled lines,
    ** depthTestSPixel is for stippled lines,
    ** depthTestPixelSF is for unstippled lines with stenciling enabled
    ** depthTestSPixelSF is for stippled lines with stenciling enabled.
    */
    void (*depthTestPixel)(void);
    void (*depthTestSPixel)(void);
    void (*depthTestPixelSF)(void);
    void (*depthTestSPixelSF)(void);
} __GLlineProcs;

typedef struct __GLpixelSpanProcsRec {
    /*
    ** Pixel span reading routines.  For examples of each, see pixel/px_read.c.
    **
    ** These routines read pixel spans for CI, RGBA, Stencil and Depth.  The
    ** base versions perform pixel skipping, and the '2' versions simply read
    ** the span straight.  The RGBA routines should produce outgoing scaled
    ** colors.
    */
    void (FASTCALL *spanReadCI)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span);
    void (FASTCALL *spanReadCI2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			GLvoid *span);
    void (FASTCALL *spanReadRGBA)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLvoid *span);
    void (FASTCALL *spanReadRGBA2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *span);
    void (FASTCALL *spanReadDepth)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *span);
    void (FASTCALL *spanReadDepth2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			   GLvoid *span);
    void (FASTCALL *spanReadStencil)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span);
    void (FASTCALL *spanReadStencil2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *span);

    /*
    ** Pixel span rendering routines.  For examples of each, see 
    ** pixel/px_render.c.
    **
    ** These routines render pixel spans for CI, RGBA, Stencil and Depth.  The
    ** base versions perform pixel replication, and the '2' versions simply
    ** render the span straight.  The RGBA routines should take incoming 
    ** scaled colors.
    */
    void (FASTCALL *spanRenderCI)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLvoid *span);
    void (FASTCALL *spanRenderCI2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *span);
    void (FASTCALL *spanRenderRGBA)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			   GLvoid *span);
    void (FASTCALL *spanRenderRGBA2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span);
    void (FASTCALL *spanRenderDepth)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span);
    void (FASTCALL *spanRenderDepth2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *span);
    void (FASTCALL *spanRenderStencil)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			      GLvoid *span);
    void (FASTCALL *spanRenderStencil2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			       GLvoid *span);
} __GLpixelSpanProcs;

/************************************************************************/

/*
** Procedures required for phong shading.
*/

#ifdef GL_WIN_phong_shading
typedef struct __GLphongProcsRec {
    void (*InitSpanInterpolation) (__GLcontext *gc);
    void (*UpdateAlongSpan) (__GLcontext *gc);
    void (*ComputeRGBColor) (__GLcontext *gc, __GLcolor *outColor);
    void (*ComputeCIColor) (__GLcontext *gc, __GLcolor *outColor);
    void (*InitLineParams) (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                            __GLfloat invDelta);
#ifdef __JUNKED_CODE
    void (*InitInterpolation) (__GLcontext *gc, __GLvertex *v);
    void (*SetInitParams) (__GLcontext *gc, __GLvertex *a, 
                                     __GLcoord *an, __GLfloat dx, 
                                     __GLfloat dy);
    void (*UpdateAlongEdge) (__GLcontext *gc, __GLfloat dxLeft, 
                                       GLboolean useBigStep);
#endif //__JUNKED_CODE
} __GLphongProcs;

#endif //GL_WIN_phong_shading
/************************************************************************/

#ifdef unix
typedef struct _XDisplay __GLdisplay;
typedef unsigned long __GLdrawable;
typedef unsigned long __GLfont;
#endif

#ifdef NT
typedef void (FASTCALL *PFN_RENDER_LINE)(__GLcontext *gc, __GLvertex *v0,
                                         __GLvertex *v1, GLuint flags);
typedef void (FASTCALL *PFN_VERTEX_CLIP_PROC)(__GLvertex*, const __GLvertex*,
                                              const __GLvertex*, __GLfloat);
typedef void (FASTCALL *PFN_RENDER_TRIANGLE)(__GLcontext *gc, __GLvertex *v0,
                                             __GLvertex *v1, __GLvertex *v2);
typedef void (FASTCALL *PFN_FILL_TRIANGLE)(__GLcontext *gc, __GLvertex *v0,
                                           __GLvertex *v1,
                                           __GLvertex *v2, GLboolean ccw);
#endif

typedef struct __GLprocsRec __GLprocs;
struct __GLprocsRec {
    /**************************************************************/

    /*
    ** Context function pointer management procs.
    */

    /* Validate the context derived state */
    void (FASTCALL *validate)(__GLcontext *gc);

    /*
    ** Pick procs to choose the other procs in this structure.  These
    ** default to procedures in pick.c (and elsewhere) but can be
    ** overriden by the machine dependent context code.
    */
    void (FASTCALL *pickBlendProcs)(__GLcontext *gc);
    void (FASTCALL *pickColorMaterialProcs)(__GLcontext *gc);
    void (FASTCALL *pickTextureProcs)(__GLcontext *gc);
    void (FASTCALL *pickFogProcs)(__GLcontext *gc);

    void (FASTCALL *pickPointProcs)(__GLcontext *gc);
    void (FASTCALL *pickLineProcs)(__GLcontext *gc);
    void (FASTCALL *pickTriangleProcs)(__GLcontext *gc);
    void (FASTCALL *pickRenderBitmapProcs)(__GLcontext *gc);
    void (FASTCALL *pickPixelProcs)(__GLcontext *gc);

    void (FASTCALL *pickClipProcs)(__GLcontext *gc);
    void (FASTCALL *pickParameterClipProcs)(__GLcontext *gc);

    void (FASTCALL *pickBufferProcs)(__GLcontext *gc);
    void (FASTCALL *pickStoreProcs)(__GLcontext *gc);
    void (FASTCALL *pickSpanProcs)(__GLcontext *gc);
    void (FASTCALL *pickVertexProcs)(__GLcontext *gc);

    int  (FASTCALL *pickDepthProcs)(__GLcontext *gc);
    void (FASTCALL *pickAllProcs)(__GLcontext *gc);

    /**************************************************************/

    /*
    ** Function pointers used for transformation, viewport and normal
    ** processing.
    */

    /* Called when the viewport changes */
    void (FASTCALL *applyViewport)(__GLcontext *gc);

    /**************************************************************/

#ifdef NT
    GLuint (FASTCALL *paClipCheck)(__GLcontext *gc, POLYARRAY *pa, 
                                   POLYDATA *pdLast);
#endif

#ifdef NT
    void (FASTCALL *paCalcTexture)(__GLcontext *gc, POLYARRAY *pa);
#endif

    /**************************************************************/

    /*
    ** Function pointers used for coloring
    */

    /*
    ** applyColor processes a color from the user that has been loaded
    ** into the gc->state.current.color.  If color material is enabled
    ** then the color will be applied the appropriate material(s).
    ** Otherwise, the color will be either scaled or scaled and clamped.
    */
    void (FASTCALL *applyColor)(__GLcontext *gc);

#ifdef NT
    PFN_POLYARRAYCALCCOLORSKIP paCalcColorSkip;
    PFN_POLYARRAYCALCCOLOR     paCalcColor;
    PFN_POLYARRAYAPPLYCHEAPFOG paApplyCheapFog;
#endif

    /*
    ** Apply a color change to a material.
    */
    void (FASTCALL *changeMaterial)(__GLcontext *gc, __GLmaterialState *ms,
			   __GLmaterialMachine *msm);

    /**************************************************************/

    /*
    ** Z buffer test procs
    */

    /*
    ** assembly routines to depth test a single pixel.  These are 
    ** highly optimized C-callable routines...
    */
    GLboolean (FASTCALL *DTPixel)( __GLzValue z, __GLzValue *zfb );

    /**************************************************************/

    /*
    ** Function pointers used for polygon, triangle, quad and rect
    ** rendering.
    */

    /* Rendering */
    PFN_RENDER_TRIANGLE renderTriangle;
    PFN_FILL_TRIANGLE fillTriangle;
    PFN_FILL_TRIANGLE fillTriangle2;

    /* Clipping */
    void (FASTCALL *clipTriangle)(__GLcontext *gc, __GLvertex *v0,
                                  __GLvertex *v1,
                                  __GLvertex *v2, GLuint orCodes);
    void (FASTCALL *clipPolygon)(__GLcontext *gc, __GLvertex *v0, GLint nv);
    PFN_VERTEX_CLIP_PROC polyClipParam;

    /* Function pointers specific to span level rendering */
    __GLspanProcs span;

    /* Function pointers specific to line level rendering */
    __GLlineProcs line;

    /* Function pointers specific to pixel routines (DrawPixels, CopyPixels,
    ** ReadPixels).
    */
    __GLpixelSpanProcs pixel;

    /**************************************************************/

    /*
    ** Function pointers used for lines.
    */
#ifdef NT
    void (FASTCALL *lineBegin)(__GLcontext *gc);
    void (FASTCALL *lineEnd)(__GLcontext *gc);
    PFN_RENDER_LINE renderLine;
    PFN_RENDER_LINE renderLine2;
#else
    void (FASTCALL *renderLine)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
    void (FASTCALL *renderLine2)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1);
#endif

    /* Line specific parameter clip proc */
    PFN_VERTEX_CLIP_PROC lineClipParam;

    /*
    ** The default slow path renderLine proc simply initializes some line
    ** data, and then calls this proc.
    */
    void (FASTCALL *rasterizeLine)(__GLcontext *gc);

    /**************************************************************/

    /*
    ** Point procs.
    */
    void (FASTCALL *renderPoint)(__GLcontext *gc, __GLvertex *v);
#ifdef __BUGGY_RENDER_POINT
    void (FASTCALL *renderPoint2)(__GLcontext *gc, __GLvertex *v);
#endif //__BUGGY_RENDER_POINT

    /**************************************************************/

    /*
    ** Bitmap procs.
    */
    void (*bitmap)(__GLcontext *gc, GLint width, GLint height,
		   GLfloat xOrig, GLfloat yOrig,
		   GLfloat xMove, GLfloat yMove, const GLubyte bits[]);
    void (FASTCALL *renderBitmap)(__GLcontext *gc, const __GLbitmap *bitmap,
			 const GLubyte *bits);

    /**************************************************************/

    /*
    ** Texturing procs.  The rho procs compute the next rho value
    ** for mipmap selection.  They might be simple procedures if
    ** mipmapping is not being done.
    */
    __GLfloat (*calcLineRho)(__GLcontext *gc, __GLfloat s,
			     __GLfloat t, __GLfloat winv);
    __GLfloat (*calcPolygonRho)(__GLcontext *gc, const __GLshade *sh,
				__GLfloat s, __GLfloat t, __GLfloat winv);
    void (*texture)(__GLcontext *gc, __GLcolor *color, __GLfloat s,
		    __GLfloat t, __GLfloat rho);

    /**************************************************************/

    /*
    ** Fogging procs.  Vertex fogging computes the fog factor at the
    ** vertex and then interpolates that.  High quality fogging
    ** (GL_FOG_HINT set to GL_NICEST) interpolates the eyeZ at then
    ** evaluates the fog function for each fragment.
    */
    void (*fogPoint)(__GLcontext *gc, __GLfragment *frag, __GLfloat eyeZ);
    void (*fogColor)(__GLcontext *gc, __GLcolor *out, __GLcolor *in, 
	    	     __GLfloat eyeZ);
    __GLfloat (FASTCALL *fogVertex)(__GLcontext *gc, __GLvertex *vx);

    /**************************************************************/

    /*
    ** Blend an incoming fragment according to the current blending
    ** mode and return a pointer to the new fragment which contains
    ** the updated colors.
    */
    void (*blend)(__GLcontext *gc, __GLcolorBuffer *cfb,
		  const __GLfragment *frag, __GLcolor *result);
    void (*blendColor)(__GLcontext *gc, const __GLcolor *source,
		       const __GLcolor *dest, __GLcolor *result);
    void (*blendSrc)(__GLcontext *gc, const __GLcolor *source,
		     const __GLcolor *dest, __GLcolor *result);
    void (*blendDst)(__GLcontext *gc, const __GLcolor *frag,
		     const __GLcolor *dest, __GLcolor *result);
    void (FASTCALL *blendSpan)(__GLcontext *gc);

    /**************************************************************/

    /* Pixel proc pointers */
    void (*drawPixels)(__GLcontext *gc, GLint width, GLint height,
		       GLenum format, GLenum type, const GLvoid *pixels,
		       GLboolean packed);
    void (*copyPixels)(__GLcontext *gc, GLint x, GLint y,
		       GLsizei width, GLsizei height, GLenum type);
    void (*readPixels)(__GLcontext *gc, GLint x, GLint y,
		       GLsizei width, GLsizei height,
		       GLenum format, GLenum type, const GLvoid *pixels);
    void (FASTCALL *copyImage)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLboolean applyPixelTransfer);
    void (FASTCALL *pxStore)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /**************************************************************/

    /*
    ** Store a fragment into the given frame buffer, applying any
    ** currently active rasterization modes properly.
    */
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /*
    ** Store a fragment into the given frame buffer.
    */
    void (FASTCALL *cfbStore)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /**************************************************************/

    /*
    ** Function pointers used for attribute processing.
    */

    /* called when the polygon stipple changes */
    void (FASTCALL *convertPolygonStipple)(__GLcontext *gc);

#ifdef GL_WIN_phong_shading
    /**************************************************************/

    /*
    ** Function pointers used for Phong shading.
    */
    __GLphongProcs phong;

    /**************************************************************/
#endif //GL_WIN_phong_shading
};

extern void FASTCALL __glGenericValidate(__GLcontext *gc);

/* Generic (portable) implementations of the pick procs */
extern void FASTCALL __glGenericPickBlendProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickColorMaterialProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickTextureProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickFogProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickParameterClipProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickPointProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickTriangleProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickLineProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickRenderBitmapProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickClipProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickBufferProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickStoreProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickSpanProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickVertexProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickPixelProcs(__GLcontext *gc);
extern int  FASTCALL __glGenericPickDepthProcs(__GLcontext *gc);
extern void FASTCALL __glGenericPickAllProcs(__GLcontext *gc);

/* some useful store procs */
extern void FASTCALL __glDoStore_ASD(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_AS(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_AD(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_SD(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_A(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_S(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore_D(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoStore(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoNullStore(__GLcolorBuffer *, const __GLfragment *);
extern void FASTCALL __glDoDoubleStore(__GLcolorBuffer *, const __GLfragment *);

/* Some predicates for pick procs to use */
extern GLboolean FASTCALL __glFastRGBA(__GLcontext *gc);
extern GLboolean FASTCALL __glNeedAlpha(__GLcontext *gc);

/* Save routines */
void FASTCALL FASTCALL __glSaveN(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveC(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCI(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveT(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCT(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveNT(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCAll(__GLcontext *gc, __GLvertex *vx);
void FASTCALL FASTCALL __glSaveCIAll(__GLcontext *gc, __GLvertex *vx);

#ifdef NT
void FASTCALL PolyArrayCalcTexture(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcObjectLinearSameST(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcObjectLinear(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcEyeLinearSameST(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcEyeLinear(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcSphereMap(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcMixedTexture(__GLcontext *gc, POLYARRAY *pa);
#endif

#ifdef _X86_

void initClipCodesTable();       // Defined in so_prim.c
void initInvSqrtTable();         // Defined in so_prim.c

#endif // _X86_

#endif /* __glprocs_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\spanci.h ===
/******************************Module*Header*******************************\
* Module Name: spansgen.h
*
* This file is included to generate a set of span functions for a certain
* pixel format and zbuffer format
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#undef  ZBUFFER
#define ZBUFFER 0

    #undef RGBMODE
    #define RGBMODE 1

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"

    #undef RGBMODE
    #define RGBMODE 0

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"
            #include "span.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"
            #include "span.h"

#undef  ZBUFFER
#define ZBUFFER 1

    #undef RGBMODE
    #define RGBMODE 1

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"

    #undef RGBMODE
    #define RGBMODE 0

        #undef DITHER
        #define DITHER 1

            #include "span_f.h"
            #include "span.h"

        #undef DITHER
        #define DITHER 0

            #include "span_f.h"
            #include "span.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\spanset.h ===
/******************************Module*Header*******************************\
* Module Name: spanset.h
*
* This file is included to generate a set of span functions for a certain
* pixel format
*
* 14-Oct-1994   mikeke  Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#undef RGBMODE
#define RGBMODE 1

#undef  ZBUFFER
#define ZBUFFER 0

    #undef TEXTURE
    #define TEXTURE 0
        #undef SHADE
        #define SHADE 1
        #include "span.h"

    #undef TEXTURE
    #define TEXTURE 1
            #undef SHADE
            #define SHADE 1
            #include "span.h"

            #undef SHADE
            #define SHADE 0
            #include "span.h"

#undef  ZBUFFER
#define ZBUFFER 1

    #undef TEXTURE
    #define TEXTURE 0
        #undef SHADE
        #define SHADE 1
        #include "span.h"

    #undef TEXTURE
    #define TEXTURE 1
            #undef SHADE
            #define SHADE 1
            #include "span.h"

            #undef SHADE
            #define SHADE 0
            #include "span.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\span_f.h ===
/******************************Module*Header*******************************\
* Module Name: span_f.h                                                    *
*                                                                          *
* This include file is used to generate various flavors of flat-shaded     *
* spans, or scanlines.  The variations cover RGB/Color-indexed operation,  *
* dithering, and pixel-depth.  Not your typical include file.              *
*                                                                          *
* Created: 24-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#undef STRING1
#undef STRING2
#undef STRING3
#undef STRING4

#if ZBUFFER
    #define STRING1 __fastGenMask
#else
    #define STRING1 __fastGen
#endif

#if RGBMODE
    #define STRING2 RGB
#else
    #define STRING2 CI
#endif

#if DITHER
    #define STRING3 STRCAT2(BPP, Dith)
#else
    #define STRING3 BPP
#endif

#define STRING4 FlatSpan

#undef OLDTEXTURE
#define OLDTEXTURE 0

void FASTCALL STRCAT4(STRING1, STRING2, STRING3, STRING4)
(__GLGENcontext *gengc)
{
    ULONG rAccum;
    ULONG rShift;
    #if RGBMODE
        ULONG gAccum;
        ULONG bAccum;
        ULONG gShift;
        ULONG bShift;
    #endif

    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;

    #if (BPP == 8)
        BYTE *pXlat;
    #elif (!RGBMODE)
        ULONG *pXlat;
    #endif

    #if DITHER
        ULONG ditherShift;
        ULONG ditherRow;
        ULONG ditherVal;
    #endif

    LONG count, cDith;
    ULONG color1;

    #if DITHER
        #if (RGBMODE) || (BPP > 8)
            ULONG color2;
            ULONG color3;
            ULONG color4;
        #endif
    #elif (BPP == 24)
        ULONG color2;
        ULONG color3;
    #endif

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);
    cfb = gengc->gc.polygon.shader.cfb;

    // get color deltas and accumulators

    rAccum = pGenAccel->spanValue.r;
    rShift = cfb->redShift;
    #if RGBMODE
        gAccum = pGenAccel->spanValue.g;
        bAccum = pGenAccel->spanValue.b;
        gShift = cfb->greenShift;
        bShift = cfb->blueShift;
    #endif

    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        pPix = pGenAccel->pPix +
            gengc->gc.polygon.shader.frag.x * (BPP / 8);
    } else {
        pPix = gengc->ColorsBits;
    }

    // set up pointer to translation table as needed

    #if (BPP == 8)
        pXlat = gengc->pajTranslateVector;
    #elif (!RGBMODE)
        pXlat = (ULONG *)(gengc->pajTranslateVector + sizeof(DWORD));
    #endif

    cDith = (
         gengc->gc.polygon.shader.length >= 4
       ? 4
       : gengc->gc.polygon.shader.length);

    #if DITHER
        ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
        ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;

        #if RGBMODE
            ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
            color1 = (((rAccum + ditherVal) >> 16) << rShift) |
                     (((gAccum + ditherVal) >> 16) << gShift) |
                     (((bAccum + ditherVal) >> 16) << bShift);

            #if (BPP == 8)
                color1 = *(pXlat + (color1 & 0xff));
            #endif

            if (--cDith) {
                ditherShift = (ditherShift + 8) & 0x18;
                ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
                color2 = (((rAccum + ditherVal) >> 16) << rShift) |
                         (((gAccum + ditherVal) >> 16) << gShift) |
                         (((bAccum + ditherVal) >> 16) << bShift);

                #if (BPP == 8)
                    color1 |= (*(pXlat + (color2 & 0xff))) << 8;
                #endif

                if (--cDith) {
                    ditherShift = (ditherShift + 8) & 0x18;
                    ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
                    color3 = (((rAccum + ditherVal) >> 16) << rShift) |
                             (((gAccum + ditherVal) >> 16) << gShift) |
                             (((bAccum + ditherVal) >> 16) << bShift);

                    #if (BPP == 8)
                        color1 |= (*(pXlat + (color3 & 0xff))) << 16;
                    #endif

                    if (--cDith) {
                        ditherShift = (ditherShift + 8) & 0x18;
                        ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;
                        color4 = (((rAccum + ditherVal) >> 16) << rShift) |
                                 (((gAccum + ditherVal) >> 16) << gShift) |
                                 (((bAccum + ditherVal) >> 16) << bShift);
                        #if (BPP == 8)
                            color1 |= (*(pXlat + (color4 & 0xff))) << 24;
                        #endif
                    }
                }
            }
        #else //!RGBMODE
            ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

            #if (BPP == 8)
                color1 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xff));
            #else
                color1 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
            #endif

            if (--cDith) {
                ditherShift = (ditherShift + 8) & 0x18;
                ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                #if (BPP == 8)
                    color1 |= (*(pXlat + (((rAccum + ditherVal) >> 16) & 0xff)) << 8);
                #else
                    color2 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
                #endif

                if (--cDith) {
                    ditherShift = (ditherShift + 8) & 0x18;
                    ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                    #if (BPP == 8)
                        color1 |= (*(pXlat + (((rAccum + ditherVal) >> 16) & 0xff)) << 16);
                    #else
                        color3= *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
                    #endif

                    if (--cDith) {
                        ditherShift = (ditherShift + 8) & 0x18;
                        ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                        #if (BPP == 8)
                            color1 |= (*(pXlat + (((rAccum + ditherVal) >> 16) & 0xff)) << 24);
                        #else
                            color4 = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
                        #endif
                    }
                }
            }
        #endif //!RGBMODE
    #else //!DITHER
        #if RGBMODE
            color1 = (((rAccum + 0x0800) >> 16) << rShift) |
                     (((gAccum + 0x0800) >> 16) << gShift) |
                     (((bAccum + 0x0800) >> 16) << bShift);

            #if (BPP == 8)
                color1 = *(pXlat + (color1 & 0xff));
            #endif

            #if (BPP == 16)
                color1 = color1 | (color1 << 16);
            #elif (BPP == 24)
                color2 = color1 >> 8;
                color3 = color1 >> 16;
            #endif
        #else //!RGBMODE
            #if (BPP == 8)
                color1 = *(pXlat + (((rAccum + 0x0800) >> 16) & 0xff));
            #else
                color1 = *(pXlat + (((rAccum + 0x0800) >> 16) & 0xfff));
            #endif

            #if (BPP == 16)
                color1 = color1 | (color1 << 16);
            #elif (BPP == 24)
                color2 = color1 >> 8;
                color3 = color1 >> 16;
            #endif
        #endif //!RGBMODE
    #endif //!DITHER

    #if (ZBUFFER)
        if (pGenAccel->flags & GEN_FASTZBUFFER) {
            GLuint zAccum = gengc->gc.polygon.shader.frag.z;
            GLint  zDelta = gengc->gc.polygon.shader.dzdx;
            PBYTE zbuf = (PBYTE)gengc->gc.polygon.shader.zbuf;
            count = gengc->gc.polygon.shader.length;

            if (gengc->gc.modes.depthBits == 16) {
                #if DITHER
                    for (;;) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color1;
                                            *(pPix + 1) = (BYTE)(color1 >> 8);
                                            *(pPix + 2) = (BYTE)(color1 >> 16);
                            #else
                                            *((DWORD *)pPix) = color1;
                            #endif
                        }

                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 8);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color2;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color2;
                                            *(pPix + 1) = (BYTE)(color2 >> 8);
                                            *(pPix + 2) = (BYTE)(color2 >> 16);
                            #else
                                            *((DWORD *)pPix) = color2;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 16);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color3;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color3;
                                            *(pPix + 1) = (BYTE)(color3 >> 8);
                                            *(pPix + 2) = (BYTE)(color3 >> 16);
                            #else
                                            *((DWORD *)pPix) = color3;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 24);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color4;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color4;
                                            *(pPix + 1) = (BYTE)(color4 >> 8);
                                            *(pPix + 2) = (BYTE)(color4 >> 16);
                            #else
                                            *((DWORD *)pPix) = color4;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zAccum += zDelta;
                        zbuf += 2;
                    }
                #else //!DITHER
                    for (; count; count--) {
                        if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                            *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));

                            #if (BPP == 8)
                                *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            #else
                                 *((DWORD *)pPix) = color1;
                            #endif //BPP
                        }
                        zAccum += zDelta;
                        zbuf +=2 ;
                        pPix += (BPP / 8);
                    }
                #endif //!DITHER
            } else {
                #if DITHER
                    for (;;) {
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color1;
                                            *(pPix + 1) = (BYTE)(color1 >> 8);
                                            *(pPix + 2) = (BYTE)(color1 >> 16);
                            #else
                                            *((DWORD *)pPix) = color1;
                            #endif
                        }

                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zbuf+=4;
                        zAccum += zDelta;
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 8);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color2;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color2;
                                            *(pPix + 1) = (BYTE)(color2 >> 8);
                                            *(pPix + 2) = (BYTE)(color2 >> 16);
                            #else
                                            *((DWORD *)pPix) = color2;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zbuf+=4;
                        zAccum += zDelta;
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 16);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color3;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color3;
                                            *(pPix + 1) = (BYTE)(color3 >> 8);
                                            *(pPix + 2) = (BYTE)(color3 >> 16);
                            #else
                                            *((DWORD *)pPix) = color3;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        zbuf+=4;
                        zAccum += zDelta;
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 24);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color4;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color4;
                                            *(pPix + 1) = (BYTE)(color4 >> 8);
                                            *(pPix + 2) = (BYTE)(color4 >> 16);
                            #else
                                            *((DWORD *)pPix) = color4;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;
                        zAccum += zDelta;
                        zbuf+=4;
                    }
                #else //!DITHER
                    for (; count; count--) {
                        if ( zAccum <= *((GLuint*)zbuf) ) {
                            *((GLuint*)zbuf) = zAccum;

                            #if (BPP == 8)
                                *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            #else
                                 *((DWORD *)pPix) = color1;
                            #endif //BPP
                        }
                        zbuf+=4;
                        zAccum += zDelta;
                        pPix += (BPP / 8);
                    }
                #endif //!DITHER
            }
        } else { // !FASTZBUFFER
            LONG totalCount;
            ULONG *pMask = gengc->gc.polygon.shader.stipplePat;

            for (totalCount = gengc->gc.polygon.shader.length; totalCount > 0; totalCount -= 32) {
                ULONG mask;
                ULONG maskTest;

                if ((mask = *pMask++) == 0) {
                    pPix += (32 * (BPP / 8));
                    continue;
                }

                maskTest = 0x80000000;

                if ((count = totalCount) > 32)
                    count = 32;

                #if DITHER
                    for (;;) {
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color1;
                                            *(pPix + 1) = (BYTE)(color1 >> 8);
                                            *(pPix + 2) = (BYTE)(color1 >> 16);
                            #else
                                            *((DWORD *)pPix) = color1;
                            #endif
                        }

                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        maskTest >>= 1;
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 8);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color2;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color2;
                                            *(pPix + 1) = (BYTE)(color2 >> 8);
                                            *(pPix + 2) = (BYTE)(color2 >> 16);
                            #else
                                            *((DWORD *)pPix) = color2;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        maskTest >>= 1;
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 16);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color3;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color3;
                                            *(pPix + 1) = (BYTE)(color3 >> 8);
                                            *(pPix + 2) = (BYTE)(color3 >> 16);
                            #else
                                            *((DWORD *)pPix) = color3;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;

                        maskTest >>= 1;
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                            *pPix = (BYTE)(color1 >> 24);
                            #elif (BPP == 16)
                                            *((WORD *)pPix) = (WORD)color4;
                            #elif (BPP == 24)
                                            *pPix = (BYTE)color4;
                                            *(pPix + 1) = (BYTE)(color4 >> 8);
                                            *(pPix + 2) = (BYTE)(color4 >> 16);
                            #else
                                            *((DWORD *)pPix) = color4;
                            #endif
                        }
                        pPix += (BPP / 8);
                        if (--count <= 0)
                            break;
                        #if ZBUFFER
                            maskTest >>= 1;
                        #else
                            zAccum += zDelta;
                            zbuf++;
                        #endif
                    }
                #else //!DITHER
                    #if (BPP == 8)
                        if (mask == 0xffffffff) {
                            RtlFillMemory(pPix, count, color1);
                            pPix += (32 * (BPP / 8));
                            continue;
                        }
                    #elif (BPP == 16)
                        if (mask == 0xffffffff) {
                            LONG ddCount;

                            if ((ULONG_PTR)pPix & 0x2) {                 // get odd-start pixel
                                *((WORD *)pPix)++ = (WORD)color1;
                                if (--count <= 0)
                                    return;
                            }

                            if (ddCount = (count & (~1)) << 1) {    // fill DWORDs
                                RtlFillMemoryUlong(pPix, ddCount, color1);
                                pPix += ddCount;
                            }

                            if (count & 1)                          // get odd-end pixel
                                *((WORD *)pPix)++ = (WORD)color1;

                            continue;
                        }
                    #elif (BPP == 24)
                        if (mask == 0xffffffff) {
                            ULONG colorShr = color1 >> 8;
                            LONG i;

                            for (i = 0; i < count; i++, pPix += 3) {
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            }
                            continue;
                        }
                    #elif (BPP == 32)
                        if (mask == 0xffffffff) {
                            RtlFillMemoryUlong(pPix, count << 2, color1);
                            pPix += (32 * (BPP / 8));
                            continue;
                        }
                    #endif //BPP

                    for (; count; count--) {
                        if (mask & maskTest) {
                            #if (BPP == 8)
                                *pPix = (BYTE)color1;
                            #elif (BPP == 16)
                                *((WORD *)pPix) = (WORD)color1;
                            #elif (BPP == 24)
                                *pPix = (BYTE)color1;
                                *(pPix + 1) = (BYTE)color2;
                                *(pPix + 2) = (BYTE)color3;
                            #else
                                 *((DWORD *)pPix) = color1;
                            #endif //BPP
                        }
                        maskTest >>= 1;
                        pPix += (BPP / 8);
                    }
                #endif //!DITHER
            }
        }
    #else // !ZBUFFER
        {
            LONG totalCount = gengc->gc.polygon.shader.length;
            #if DITHER
                #if (BPP == 8)
                    LONG i;

                    if (totalCount < 7) {
                        *pPix++ = (BYTE)color1;
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)(color1 >> 8);
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)(color1 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)(color1 >> 24);
                        if (--totalCount <= 0)
                            return;
                        *pPix++ = (BYTE)color1;
                        if (--totalCount <= 0)
                            return;
                        *pPix = (BYTE)(color1 >> 8);
                        return;
                    }

                    if (i = (LONG)((ULONG_PTR)pPix & 0x3)) {
                        i = ditherShift = (4 - i);

                        totalCount -= i;

                        if (i--) {
                            *pPix++ = (BYTE)color1;
                            if (i--) {
                                *pPix++ = (BYTE)(color1 >> 8);
                                if (i--) {
                                    *pPix++ = (BYTE)(color1 >> 16);
                                }
                            }
                        }

                        // re-align the dither colors for DWORD boundaries

                        ditherShift <<= 3;

                        color1 = (color1 >> ditherShift) |
                                 (color1 << (32 - ditherShift));
                    }

                    RtlFillMemoryUlong(pPix, totalCount, color1);
                    pPix += (totalCount & 0xfffffffc);

                    i = totalCount & 0x3;

                    if (i--) {
                        *pPix++ = (BYTE)color1;
                        if (i--) {
                            *pPix++ = (BYTE)(color1 >> 8);
                            if (i--) {
                                *pPix++ = (BYTE)(color1 >> 16);
                            }
                        }
                    }

                    return;

                #elif (BPP == 16)
                    ULONG colorA, colorB;
                    LONG i;

                    if (totalCount < 3) {
                        *((WORD *)pPix)++ = (WORD)color1;
                        if (--totalCount <= 0)
                            return;
                        *((WORD *)pPix)++ = (WORD)color2;
                        return;
                    }

                    if ((ULONG_PTR)pPix & 0x2) {
                        totalCount--;

                        *((WORD *)pPix)++ = (WORD)color1;

                        colorA = color2 | (color3 << 16);
                        colorB = color4 | (color1 << 16);
                    } else {
                        colorA = color1 | (color2 << 16);
                        colorB = color3 | (color4 << 16);
                    }

                    for (i = (totalCount >> 1);;) {
                        *((DWORD *)pPix)++ = colorA;
                        if (--i <= 0) {
                            if (totalCount & 1)
                                *((WORD *)pPix) = (WORD)colorB;
                            return;
                        }
                        *((DWORD *)pPix)++ = colorB;
                        if (--i <= 0) {
                            if (totalCount & 1)
                                *((WORD *)pPix) = (WORD)colorA;
                            return;
                        }
                    }

                #elif (BPP == 24)
                    for (;;pPix += 12) {
                        *pPix = (BYTE)color1;
                        *(pPix + 1) = (BYTE)(color1 >> 8);
                        *(pPix + 2) = (BYTE)(color1 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *(pPix + 3) = (BYTE)color2;
                        *(pPix + 4) = (BYTE)(color2 >> 8);
                        *(pPix + 5) = (BYTE)(color2 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *(pPix + 6) = (BYTE)color3;
                        *(pPix + 7) = (BYTE)(color3 >> 8);
                        *(pPix + 8) = (BYTE)(color3 >> 16);
                        if (--totalCount <= 0)
                            return;
                        *(pPix + 9) = (BYTE)color4;
                        *(pPix + 10) = (BYTE)(color4 >> 8);
                        *(pPix + 11) = (BYTE)(color4 >> 16);
                        if (--totalCount <= 0)
                            return;
                    }
                #elif (BPP == 32)
                    for (;;pPix += 16) {
                        *((DWORD *)pPix) = color1;
                        if (--totalCount <= 0)
                            return;
                        *((DWORD *)(pPix + 4)) = color2;
                        if (--totalCount <= 0)
                            return;
                        *((DWORD *)(pPix + 8)) = color3;
                        if (--totalCount <= 0)
                            return;
                        *((DWORD *)(pPix + 12)) = color4;
                        if (--totalCount <= 0)
                            return;
                    }
                #endif //BPP
            #else //!DITHER
                #if (BPP == 8)
                    RtlFillMemory(pPix, totalCount, color1);
                    return;
                #elif (BPP == 16)
                    if ((ULONG_PTR)pPix & 0x2) {                    // get odd-start pixel
                        *((WORD *)pPix)++ = (WORD)color1;
                        if (--totalCount <= 0)
                            return;
                    }
            	    if (count = (totalCount & (~1)) << 1)
                        RtlFillMemoryUlong(pPix, count, color1);
                    if (totalCount & 1)                         // get odd-end pixel
                        *((WORD *)(pPix + count)) = (WORD)color1;
                    return;
                #elif (BPP == 24)
                    LONG i;

                    for (i = 0; i < totalCount; i++, pPix += 3) {
                        *pPix = (BYTE)color1;
                        *(pPix + 1) = (BYTE)(color2);
                        *(pPix + 2) = (BYTE)(color3);
                    }
                    return;
                #elif (BPP == 32)
                    RtlFillMemoryUlong(pPix, totalCount << 2, color1);
                    return;
                #endif //BPP
            #endif //!DITHER
        }
    #endif // !ZBUFFER
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\span_t.h ===
/******************************Module*Header*******************************\
* Module Name: span_t.h                                                    *
*                                                                          *
* This include file is used to generate various flavors of textured        *
* spans, or scanlines.  The variations cover only RGB operation,           *
* dithering, and pixel-depth.  Not your typical include file.              *
*                                                                          *
* Created: 11-April-1994                                                   *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/


void

#if DITHER

#if (BPP == 8)
__fastGenTex8DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24DithSmoothSpan(__GLGENcontext *gengc)
#else
__fastGenTex32DithSmoothSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenTex8SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24SmoothSpan(__GLGENcontext *gengc)
#else
__fastGenTex32SmoothSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

{
    ULONG rAccum;
    ULONG gAccum;
    ULONG bAccum;
    ULONG sAccum;
    ULONG tAccum;
    LONG rDelta;
    LONG gDelta;
    LONG bDelta;
    LONG sDelta;
    LONG tDelta;
    ULONG rShift;
    ULONG gShift;
    ULONG bShift;
    ULONG rtShift;
    ULONG gtShift;
    ULONG btShift;
    ULONG tShift;
    ULONG sMask, tMask;
    ULONG wLog2;
    ULONG hLog2;
    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;
    UCHAR *texAddr;
    USHORT *texBits;
#if DITHER
    ULONG ditherVal;
#endif
#if (BPP == 8)
    BYTE *pXlat;
#endif
    ULONG *pMask;
#if DITHER
    ULONG ditherShift;
    ULONG ditherRow;
#endif
    LONG count;
    LONG totalCount;
    __GLtexture *tex = ((__GLcontext *)gengc)->texture.currentTexture;

    wLog2 = tex->level[0].widthLog2;
    hLog2 = tex->level[0].heightLog2;
    sMask = (~(~0 << wLog2)) << 16;
    tMask = (~(~0 << hLog2)) << 16;
    tShift = 13 - wLog2;
    
    // get color deltas and accumulators

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);

    texAddr = (UCHAR *)pGenAccel->texImage;

    rDelta = pGenAccel->spanDelta.r;
    gDelta = pGenAccel->spanDelta.g;
    bDelta = pGenAccel->spanDelta.b;
    sDelta = pGenAccel->spanDelta.s;
    tDelta = pGenAccel->spanDelta.t;

    rAccum = pGenAccel->spanValue.r;
    gAccum = pGenAccel->spanValue.g;
    bAccum = pGenAccel->spanValue.b;
    sAccum = pGenAccel->spanValue.s;
    tAccum = pGenAccel->spanValue.t;


    cfb = gengc->gc.polygon.shader.cfb;

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;
#if DITHER
    rtShift = 8 + ((__GLcontext *)gengc)->modes.redBits;
    gtShift = 8 + ((__GLcontext *)gengc)->modes.greenBits;
    btShift = 8 + ((__GLcontext *)gengc)->modes.blueBits;
#else
    rtShift = 16 + ((__GLcontext *)gengc)->modes.redBits;
    gtShift = 16 + ((__GLcontext *)gengc)->modes.greenBits;
    btShift = 16 + ((__GLcontext *)gengc)->modes.blueBits;
#endif


    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        int xScr;
        int yScr;

        xScr = gengc->gc.polygon.shader.frag.x - 
               gengc->gc.constants.viewportXAdjust +
               cfb->buf.xOrigin;
        
        yScr = gengc->gc.polygon.shader.frag.y - 
               gengc->gc.constants.viewportYAdjust +
               cfb->buf.yOrigin;

        pPix = (BYTE *)cfb->buf.base + (yScr * cfb->buf.outerWidth) +
#if (BPP == 8)
               xScr;
#elif (BPP == 16)
               (xScr << 1);
#elif (BPP == 24)
               xScr + (xScr << 1);
#else
               (xScr << 2);
#endif //BPP
    } else
        pPix = gengc->ColorsBits;

    // set up pointer to translation table as needed

#if (BPP == 8)
    pXlat = gengc->pajTranslateVector;
#endif

#if DITHER
    ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
    ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;
#endif

    pMask = gengc->gc.polygon.shader.stipplePat;
    if ((totalCount = count = gengc->gc.polygon.shader.length) > 32)
        count = 32;

    for (; totalCount > 0; totalCount -= 32) {
        ULONG mask;
        ULONG maskTest;
    
        if ((mask = *pMask++) == 0) {
            rAccum += (rDelta << 5);
            gAccum += (gDelta << 5);
            bAccum += (bDelta << 5);
            sAccum += (sDelta << 5);
            tAccum += (tDelta << 5);

            pPix += (32 * (BPP / 8));
            continue;
        }

        maskTest = 0x80000000;

        if ((count = totalCount) > 32)
            count = 32;

        for (; count; count--, maskTest >>= 1) {
            if (mask & maskTest) {
                DWORD color;

                texBits = (USHORT *)(texAddr + ((sAccum & sMask) >> 13) + 
                                               ((tAccum & tMask) >> tShift));

#if DITHER
                ditherVal = (ditherRow >> ditherShift) & 0xff;

                ditherShift = (ditherShift + 8) & 0x18;

                color = 
                    ((((((ULONG)texBits[0] * (rAccum >> 8)) >> rtShift) + ditherVal) >> 8) << rShift) |
                    ((((((ULONG)texBits[1] * (gAccum >> 8)) >> gtShift) + ditherVal) >> 8) << gShift) |
                    ((((((ULONG)texBits[2] * (bAccum >> 8)) >> btShift) + ditherVal) >> 8) << bShift);
#else
                color = 
                    ((((ULONG)texBits[0] * (rAccum >> 8)) >> rtShift) << rShift) |
                    ((((ULONG)texBits[1] * (gAccum >> 8)) >> gtShift) << gShift) |
                    ((((ULONG)texBits[2] * (bAccum >> 8)) >> btShift) << bShift);
#endif


#if (BPP == 8)
// XXX the color value should *not* have to be masked!
                color = *(pXlat + (color & 0xff));
#endif

#if (BPP == 8)
                *pPix = (BYTE)color;
#elif (BPP == 16)
                *((WORD *)pPix) = (USHORT)color;
#elif (BPP == 24)
                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                *((DWORD *)pPix) = color;
#endif //BPP

            }
            rAccum += rDelta;
            gAccum += gDelta;
            bAccum += bDelta;
            sAccum += sDelta;
            tAccum += tDelta;

            pPix += (BPP / 8);
        }
    }
}



void

#if DITHER

#if (BPP == 8)
__fastGenTex8DithDecalSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16DithDecalSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24DithDecalSpan(__GLGENcontext *gengc)
#else
__fastGenTex32DithDecalSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenTex8DecalSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenTex16DecalSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenTex24DecalSpan(__GLGENcontext *gengc)
#else
__fastGenTex32DecalSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

{
    register ULONG sAccum;
    register ULONG tAccum;
    LONG sDelta;
    LONG tDelta;
    ULONG rShift;
    ULONG gShift;
    ULONG bShift;
    ULONG tShift;
    ULONG sMask, tMask;
    ULONG wLog2;
    ULONG hLog2;
    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;
    UCHAR *texAddr;
    USHORT *texBits;
#if DITHER
    ULONG ditherVal;
#endif
#if (BPP == 8)
    BYTE *pXlat;
#endif
    ULONG *pMask;
#if DITHER
    ULONG ditherShift;
    ULONG ditherRow;
#endif
    LONG count;
    LONG totalCount;
    __GLtexture *tex = ((__GLcontext *)gengc)->texture.currentTexture;

    wLog2 = tex->level[0].widthLog2;
    hLog2 = tex->level[0].heightLog2;
    sMask = (~(~0 << wLog2)) << 16;
    tMask = (~(~0 << hLog2)) << 16;
    tShift = 13 - wLog2;

    // get color deltas and accumulators

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);

    sDelta = pGenAccel->spanDelta.s;
    tDelta = pGenAccel->spanDelta.t;

    sAccum = pGenAccel->spanValue.s;
    tAccum = pGenAccel->spanValue.t;

    texAddr = (UCHAR *)pGenAccel->texImage;

    cfb = gengc->gc.polygon.shader.cfb;

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;

    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        int xScr;
        int yScr;

        xScr = gengc->gc.polygon.shader.frag.x - 
               gengc->gc.constants.viewportXAdjust +
               cfb->buf.xOrigin;
        
        yScr = gengc->gc.polygon.shader.frag.y - 
               gengc->gc.constants.viewportYAdjust +
               cfb->buf.yOrigin;

        pPix = (BYTE *)cfb->buf.base + (yScr * cfb->buf.outerWidth) +
#if (BPP == 8)
               xScr;
#elif (BPP == 16)
               (xScr << 1);
#elif (BPP == 24)
               xScr + (xScr << 1);
#else
               (xScr << 2);
#endif //BPP
    } else
        pPix = gengc->ColorsBits;

    // set up pointer to translation table as needed

#if (BPP == 8)
    pXlat = gengc->pajTranslateVector;
#endif

#if DITHER
    ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
    ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;
#endif

    pMask = gengc->gc.polygon.shader.stipplePat;
    if ((totalCount = count = gengc->gc.polygon.shader.length) > 32)
        count = 32;

    for (; totalCount > 0; totalCount -= 32) {
        ULONG mask;
        ULONG maskTest;
    
        if ((mask = *pMask++) == 0) {
            sAccum += (sDelta << 5);
            tAccum += (tDelta << 5);

            pPix += (32 * (BPP / 8));
            continue;
        }

        maskTest = 0x80000000;

        if ((count = totalCount) > 32)
            count = 32;

        for (; count; count--, maskTest >>= 1) {
            if (mask & maskTest) {
#if (DITHER) || (BPP >= 24)
                DWORD color;
#endif

                texBits = (USHORT *)(texAddr + ((sAccum & sMask) >> 13) + 
                                               ((tAccum & tMask) >> tShift));

#if DITHER
                ditherVal = ((ditherRow >> ditherShift) & 0xff);

                ditherShift = (ditherShift + 8) & 0x18;

                color = 
                    (((texBits[0] + ditherVal) >> 8) << rShift) |
                    (((texBits[1] + ditherVal) >> 8) << gShift) |
                    (((texBits[2] + ditherVal) >> 8) << bShift);

#if (BPP == 8)
// XXX the color value should *not* have to be masked!
                color = *(pXlat + (color & 0xff));
                *pPix = (BYTE)color;
#elif (BPP == 16)
                *((WORD *)pPix) = (USHORT)color;
#elif (BPP == 24)
                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                *((DWORD *)pPix) = color;
#endif //BPP

#else //!DITHER

#if (BPP == 8)
                *pPix = *((BYTE *)&texBits[3]);
#elif (BPP == 16)
                *((WORD *)pPix) = *((WORD *)&texBits[3]);
#elif (BPP == 24)
                color = 
                    ((texBits[0] >> 8) << rShift) |
                    ((texBits[1] >> 8) << gShift) |
                    ((texBits[2] >> 8) << bShift);

                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                color = 
                    ((texBits[0] >> 8) << rShift) |
                    ((texBits[1] >> 8) << gShift) |
                    ((texBits[2] >> 8) << bShift);

                *((DWORD *)pPix) = color;
#endif //BPP


#endif  //DITHER
            }
            sAccum += sDelta;
            tAccum += tDelta;

            pPix += (BPP / 8);
        }
    }
}


#if !DITHER
#undef ditherVal
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\srvp.h ===
/******************************Module*Header*******************************\
* Module Name: srvp.h
*
* System routines shared through the back end
*
* Created: 28-Jun-1995 17:36:00
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _srvp_
#define _srvp_

typedef struct _XLIST *PXLIST;
typedef struct _XLIST {
    PXLIST pnext;
    int s, e;
} XLIST;

typedef struct _YLIST *PYLIST;
typedef struct _YLIST {
    PYLIST pnext;
    PXLIST pxlist;
    int s, e;
} YLIST;

typedef struct _RECTLIST *PRECTLIST;
typedef struct _RECTLIST {
    PYLIST pylist;
    PVOID buffers;
} RECTLIST;

BOOL  APIENTRY wglPixelVisible(LONG, LONG);
ULONG APIENTRY wglSpanVisible(LONG, LONG, ULONG, LONG *, LONG **);

VOID  APIENTRY wglCopyBits(__GLGENcontext *, GLGENwindow *, HBITMAP, LONG, LONG, ULONG, BOOL);
VOID  APIENTRY wglCopyBits2(HDC, GLGENwindow *, __GLGENcontext *, LONG, LONG, ULONG, BOOL);
VOID  APIENTRY wglCopyBuf(HDC, HDC, LONG, LONG, ULONG, ULONG);
VOID  APIENTRY wglCopyBufRECTLIST(HDC, HDC, LONG, LONG, ULONG, ULONG, PRECTLIST);
VOID  APIENTRY wglFillRect(__GLGENcontext *, GLGENwindow *, PRECTL, ULONG);
VOID  APIENTRY wglCopyBuf2(HDC, GLGENwindow *, HBITMAP, LONG, LONG, ULONG, ULONG);

ULONG APIENTRY wglGetClipRects(GLGENwindow *, RECTL *);
#ifdef _CLIENTSIDE_
BOOL APIENTRY wglGetClipList(GLGENwindow *);
#endif

COLORREF wglTranslateColor(COLORREF crColor,
                           HDC hdc,
                           __GLGENcontext *gengc,
                           PIXELFORMATDESCRIPTOR *ppfd);

VOID  APIENTRY wglCleanupWindow(GLGENwindow *);

BOOL  APIENTRY wglCopyTranslateVector(__GLGENcontext *gengc, BYTE *, ULONG);

ULONG APIENTRY wglPaletteChanged(__GLGENcontext *gengc,
                                 GLGENwindow *pwnd);
ULONG APIENTRY wglPaletteSize(__GLGENcontext *gengc);
BOOL  APIENTRY wglComputeIndexedColors(__GLGENcontext *gengc, ULONG *, ULONG);
BOOL  APIENTRY wglValidPixelFormat(HDC, int, DWORD,
                                   LPDIRECTDRAWSURFACE, DDSURFACEDESC *);

/* Returned by wglSpanVisible */
#define WGL_SPAN_NONE       0
#define WGL_SPAN_ALL        1
#define WGL_SPAN_PARTIAL    2

int  WINAPI wglGetPixelFormat(HDC hdc);
BOOL WINAPI wglSetPixelFormat(HDC hdc, int ipfd,
                              CONST PIXELFORMATDESCRIPTOR *ppfd);
int  WINAPI wglChoosePixelFormat(HDC hdc, CONST PIXELFORMATDESCRIPTOR *ppfd);
int  WINAPI wglDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                   LPPIXELFORMATDESCRIPTOR ppfd);
BOOL WINAPI wglSwapBuffers(HDC hdc);

void UpdateWindowInfo(__GLGENcontext *gengc);
void HandlePaletteChanges( __GLGENcontext *gengc, GLGENwindow *pwnd );

UINT APIENTRY wglGetSystemPaletteEntries(HDC hdc, UINT iStartIndex,
                                         UINT nEntries, LPPALETTEENTRY lppe);

#endif // _srvp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\span_s.h ===
/******************************Module*Header*******************************\
* Module Name: span_s.h                                                    *
*                                                                          *
* This include file is used to generate various flavors of smooth-shaded   *
* spans, or scanlines.  The variations cover RGB/Color-indexed operation,  *
* dithering, and pixel-depth.  Not your typical include file.              *
*                                                                          *
* Created: 24-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

void

#if RGBMODE

#if DITHER

#if (BPP == 8)
__fastGenRGB8DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenRGB16DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenRGB24DithSmoothSpan(__GLGENcontext *gengc)
#else
__fastGenRGB32DithSmoothSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenRGB8SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenRGB16SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenRGB24SmoothSpan(__GLGENcontext *gengc)
#else
__fastGenRGB32SmoothSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

#else //!RGBMODE

#if DITHER

#if (BPP == 8)
__fastGenCI8DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenCI16DithSmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenCI24DithSmoothSpan(__GLGENcontext *gengc)
#else
__fastGenCI32DithSmoothSpan(__GLGENcontext *gengc)
#endif

#else //!DITHER

#if (BPP == 8)
__fastGenCI8SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 16)
__fastGenCI16SmoothSpan(__GLGENcontext *gengc)
#elif (BPP == 24)
__fastGenCI24SmoothSpan(__GLGENcontext *gengc)
#else
__fastGenCI32SmoothSpan(__GLGENcontext *gengc)
#endif

#endif //!DITHER

#endif //!RGBMODE

{
    ULONG rAccum;
#if RGBMODE
    ULONG gAccum;
    ULONG bAccum;
#endif
    LONG rDelta;
#if RGBMODE
    LONG gDelta;
    LONG bDelta;
#endif
    ULONG rShift;
#if RGBMODE
    ULONG gShift;
    ULONG bShift;
#endif
    GENACCEL *pGenAccel;
    __GLcolorBuffer *cfb;
    BYTE *pPix;
#if (BPP == 8)
    BYTE *pXlat;
#elif (!RGBMODE)
    ULONG *pXlat;
#endif
    ULONG *pMask;
#if DITHER
    ULONG ditherShift;
    ULONG ditherRow;
#endif
    LONG count;
    LONG totalCount;
    
    // get color deltas and accumulators

    pGenAccel = (GENACCEL *)(gengc->pPrivateArea);

    rDelta = pGenAccel->spanDelta.r;
#if RGBMODE
    gDelta = pGenAccel->spanDelta.g;
    bDelta = pGenAccel->spanDelta.b;
#endif

    // Try to accelerate color-invariant spans

    if (!(pGenAccel->flags & HAVE_STIPPLE) && 
        (gengc->gc.polygon.shader.length > 3)) {
        if (gengc->gc.polygon.shader.length < 16) {
#if RGBMODE
            if ((((rDelta & 0xffffff80) == 0) || ((-rDelta & 0xffffff80) == 0)) &&
                (((gDelta & 0xffffff80) == 0) || ((-gDelta & 0xffffff80) == 0)) &&
                (((bDelta & 0xffffff80) == 0) || ((-bDelta & 0xffffff80) == 0))) {
#else
            if (((rDelta & 0xffffff80) == 0) || ((-rDelta & 0xffffff80) == 0)) {
#endif
                (*pGenAccel->__fastFlatSpanFuncPtr)(gengc);
                return;
            }
        } else if (gengc->gc.polygon.shader.length < 32) {
#if RGBMODE
            if ((((rDelta & 0xffffffc0) == 0) || ((-rDelta & 0xffffffc0) == 0)) &&
                (((gDelta & 0xffffffc0) == 0) || ((-gDelta & 0xffffffc0) == 0)) &&
                (((bDelta & 0xffffffc0) == 0) || ((-bDelta & 0xffffffc0) == 0))) {
#else
            if (((rDelta & 0xffffffc0) == 0) || ((-rDelta & 0xffffffc0) == 0)) {
#endif
                (*pGenAccel->__fastFlatSpanFuncPtr)(gengc);
                return;
            }
        } else if (gengc->gc.polygon.shader.length < 64) {
#if RGBMODE
            if ((((rDelta & 0xffffffe0) == 0) || ((-rDelta & 0xffffffe0) == 0)) &&
                (((gDelta & 0xffffffe0) == 0) || ((-gDelta & 0xffffffe0) == 0)) &&
                (((bDelta & 0xffffffe0) == 0) || ((-bDelta & 0xffffffe0) == 0))) {
#else
            if (((rDelta & 0xffffffe0) == 0) || ((-rDelta & 0xffffffe0) == 0)) {
#endif
                (*pGenAccel->__fastFlatSpanFuncPtr)(gengc);
                return;
            }
        }
    }
    
    rAccum = pGenAccel->spanValue.r;
#if RGBMODE
    gAccum = pGenAccel->spanValue.g;
    bAccum = pGenAccel->spanValue.b;
#endif

    cfb = gengc->gc.polygon.shader.cfb;

    rShift = cfb->redShift;
#if RGBMODE
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;
#endif

    // get address of destination

    if (pGenAccel->flags & SURFACE_TYPE_DIB) {
        int xScr;
        int yScr;

        xScr = gengc->gc.polygon.shader.frag.x - 
               gengc->gc.constants.viewportXAdjust +
               cfb->buf.xOrigin;
        
        yScr = gengc->gc.polygon.shader.frag.y - 
               gengc->gc.constants.viewportYAdjust +
               cfb->buf.yOrigin;

        pPix = (BYTE *)cfb->buf.base + (yScr * cfb->buf.outerWidth) +
#if (BPP == 8)
               xScr;
#elif (BPP == 16)
               (xScr << 1);
#elif (BPP == 24)
               xScr + (xScr << 1);
#else
               (xScr << 2);
#endif //BPP
    } else
        pPix = gengc->ColorsBits;

    // set up pointer to translation table as needed

#if (BPP == 8)
    pXlat = gengc->pajTranslateVector;
#elif (!RGBMODE)
    pXlat = (ULONG *)(gengc->pajTranslateVector + sizeof(DWORD));
#endif

#if DITHER
    ditherRow = Dither_4x4[gengc->gc.polygon.shader.frag.y & 0x3];
    ditherShift = (gengc->gc.polygon.shader.frag.x & 0x3) << 3;
#endif

    pMask = gengc->gc.polygon.shader.stipplePat;
    if ((totalCount = count = gengc->gc.polygon.shader.length) > 32)
        count = 32;

    for (; totalCount > 0; totalCount -= 32) {
        ULONG mask;
        ULONG maskTest;
    
        if ((mask = *pMask++) == 0) {
#if RGBMODE
            rAccum += (rDelta << 5);
            gAccum += (gDelta << 5);
            bAccum += (bDelta << 5);
#else
            rAccum += (rDelta << 5);
#endif
            pPix += (32 * (BPP / 8));
            continue;
        }

        maskTest = 0x80000000;

        if ((count = totalCount) > 32)
            count = 32;

        for (; count; count--, maskTest >>= 1) {
            if (mask & maskTest) {
                DWORD color;
#if DITHER
                ULONG ditherVal = ((ditherRow >> ditherShift) & 0xff) << 8;

                ditherShift = (ditherShift + 8) & 0x18;
#else
#define ditherVal 0x0800
#endif

#if RGBMODE
                color = (((rAccum + ditherVal) >> 16) << rShift) |
                        (((gAccum + ditherVal) >> 16) << gShift) |
                        (((bAccum + ditherVal) >> 16) << bShift);
#if (BPP == 8)
// XXX the color value should *not* have to be masked!
                color = *(pXlat + (color & 0xff));
#endif

#else //!RGBMODE

// XXX nor should color-index values!

#if (BPP == 8)
		color = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xff));
#else
		color = *(pXlat + (((rAccum + ditherVal) >> 16) & 0xfff));
#endif

#endif //!RGBMODE

#if (BPP == 8)
                *pPix = (BYTE)color;
#elif (BPP == 16)
                *((WORD *)pPix) = (USHORT)color;
#elif (BPP == 24)
                *pPix = (BYTE)color;
                *(pPix + 1) = (BYTE)(color >> 8);
                *(pPix + 2) = (BYTE)(color >> 16);
#else
                *((DWORD *)pPix) = color;
#endif //BPP

            }
#if RGBMODE
            rAccum += rDelta;
            gAccum += gDelta;
            bAccum += bDelta;
#else
            rAccum += rDelta;
#endif
            pPix += (BPP / 8);
        }
    }
}


#if !DITHER
#undef ditherVal
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\texspan2.h ===
/******************************Module*Header*******************************\
* Module Name: texspan2.h
*
* Calculate the textured pixel, and write the value to the framebuffer.
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

{
    DWORD r, g, b;

    #if (FLAT_SHADING || SMOOTH_SHADING)
        #if (BPP == 8)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix) & 0x3];
        #elif (BPP == 16)
            ULONG ditherVal = pdither[((ULONG_PTR)pPix & 0x6) >> 1];
        #endif
    #endif

    #if PALETTE_ENABLED

        if (bPalette) {
            texBits = ((BYTE *)TEX_IMAGE + 
                       ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT_PAL) +
                       ((tResult & TMASK_SUBDIV) >> T_SHIFT_PAL));

            texBits = (BYTE *)((ULONG *)TEX_PALETTE + *texBits);

        } else {
            texBits = ((BYTE *)TEX_IMAGE + 
                       ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT) +
                       ((tResult & TMASK_SUBDIV) >> T_SHIFT));
        }

    #elif PALETTE_ONLY

        texBits = ((BYTE *)TEX_IMAGE + 
                   ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT_PAL) +
                   ((tResult & TMASK_SUBDIV) >> T_SHIFT_PAL));

        texBits = (BYTE *)((ULONG *)TEX_PALETTE + *texBits);

    #else
        texBits = ((BYTE *)TEX_IMAGE + 
                   ((sResult & GENACCEL(gengc).sMask) >> S_SHIFT) +
                   ((tResult & TMASK_SUBDIV) >> T_SHIFT));
    #endif

    sResult += subDs;
    tResult += subDt;


    #if (FAST_REPLACE)
    {
        #if (ALPHA)
            if (texBits[3] != 0) {
                if (texBits[3] != 0xff) {

                    texBits = (texBits - GENACCEL(gengc).texImageReplace +
                               (BYTE *)GENACCEL(gengc).texPalette);

                    ALPHA_NOMODULATE	
                    ALPHA_READ

                    #if (BPP == 32)
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) << -RRIGHTSHIFTADJ) & RMASK;
                    #else
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) >> RRIGHTSHIFTADJ) & RMASK;
                    #endif
                    g = (((gbMulTable[aDisplay | texBits[1]] + gDisplay) << 8) >> GRIGHTSHIFTADJ) & GMASK;
                    b = (((gbMulTable[aDisplay | texBits[0]] + bDisplay) << 8) >> BRIGHTSHIFTADJ) & BMASK;

                    #if (BPP == 8)
                       *pPix = gengc->xlatPalette[r | g | b];
                    #elif (BPP == 16)
                       *((USHORT *)pPix) = (USHORT)(r | g | b);
                    #else
                        *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                        pPix[2] = (BYTE)(r >> 16);
                    #endif

                } else {
                    #if (BPP > 16)
                        ULONG texel = *((ULONG *)texBits);
                    #endif

                    #if (BPP == 8)
                        *pPix = *texBits;
                    #elif (BPP == 16)
                        *((USHORT *)pPix) = *((USHORT *)texBits);
                    #else
                        *((USHORT UNALIGNED *)pPix) = (USHORT)texel;
                        pPix[2] = (BYTE)(texel >> 16);
                    #endif      
                }
            }
        #else
            {
                #if (BPP > 16)
                    ULONG texel = *((ULONG *)texBits);
                #endif

                #if (BPP == 8)
                    *pPix = *texBits;
                #elif (BPP == 16)
                    *((USHORT *)pPix) = *((USHORT *)texBits);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)texel;
                    pPix[2] = (BYTE)(texel >> 16);
                #endif      
            }
        #endif
    }

    #elif (REPLACE)
    {
        #if (ALPHA)
            if (texBits[3] != 0) {
                if (texBits[3] != 0xff) {

                    ALPHA_NOMODULATE	
                    ALPHA_READ

                    #if (BPP == 32)
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) << -RRIGHTSHIFTADJ) & RMASK;
                    #else
                        r = (((gbMulTable[aDisplay | texBits[2]] + rDisplay) << 8) >> RRIGHTSHIFTADJ) & RMASK;
                    #endif
                    g = (((gbMulTable[aDisplay | texBits[1]] + gDisplay) << 8) >> GRIGHTSHIFTADJ) & GMASK;
                    b = (((gbMulTable[aDisplay | texBits[0]] + bDisplay) << 8) >> BRIGHTSHIFTADJ) & BMASK;
                } else {
                    #if (BPP == 32)
                        r = ((texBits[2] << 8) << -RRIGHTSHIFTADJ) & RMASK;
                    #else
                        r = ((texBits[2] << 8) >> RRIGHTSHIFTADJ) & RMASK;
                    #endif
                    g = ((texBits[1] << 8) >> GRIGHTSHIFTADJ) & GMASK;
                    b = ((texBits[0] << 8) >> BRIGHTSHIFTADJ) & BMASK;
                }

                #if (BPP == 8)
                   *pPix = gengc->xlatPalette[r | g | b];
                #elif (BPP == 16)
                   *((USHORT *)pPix) = (USHORT)(r | g | b);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                    pPix[2] = (BYTE)(r >> 16);
                #endif

            }
        #else

            #if (BPP != 32)
                r = ((texBits[2] << 8) >> RRIGHTSHIFTADJ) & RMASK;
                g = ((texBits[1] << 8) >> GRIGHTSHIFTADJ) & GMASK;
                b = ((texBits[0] << 8) >> BRIGHTSHIFTADJ) & BMASK;
            #endif

            #if (BPP == 8)
               *pPix = gengc->xlatPalette[r | g | b];
            #elif (BPP == 16)
               *((USHORT *)pPix) = (USHORT)(r | g | b);
            #else
                *((USHORT UNALIGNED *)pPix) = *((USHORT *)texBits);
                pPix[2] = (BYTE)texBits[2];
            #endif

        #endif
    }

    #elif (FLAT_SHADING)
    {
        #if (ALPHA)
            if (texBits[3] != 0) {

                ALPHA_MODULATE;
                ALPHA_READ;

                #if (BPP == 32)
                    r = ((((gbMulTable[aDisplay | gbMulTable[rAccum | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
                #else
                    r = ((((gbMulTable[aDisplay | gbMulTable[rAccum | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
                #endif
                g = ((((gbMulTable[aDisplay | gbMulTable[gAccum | texBits[1]]] + gDisplay) << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
                b = ((((gbMulTable[aDisplay | gbMulTable[bAccum | texBits[0]]] + bDisplay) << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

                #if (BPP == 8)
                    *pPix = gengc->xlatPalette[r | g | b];
                #elif (BPP == 16)
                    *((USHORT *)pPix) = (USHORT)(r | g | b);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                    pPix[2] = (BYTE)(r >> 16);
                #endif
            }

        #else

            #if (BPP == 32)
                r = (((gbMulTable[rAccum | texBits[2]] << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
            #else
                r = (((gbMulTable[rAccum | texBits[2]] << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
            #endif
            g = (((gbMulTable[gAccum | texBits[1]] << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
            b = (((gbMulTable[bAccum | texBits[0]] << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

            #if (BPP == 8)
                *pPix = gengc->xlatPalette[r | g | b];
            #elif (BPP == 16)
                *((USHORT *)pPix) = (USHORT)(r | g | b);
            #else
                *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                pPix[2] = (BYTE)(r >> 16);
            #endif

        #endif

    }

    #else       // SMOOTH_SHADING
    {
        #if (ALPHA)
            if (texBits[3] != 0) {

                ALPHA_MODULATE;
                ALPHA_READ;

                #if (BPP == 32)
                    r = ((((gbMulTable[aDisplay | gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
                #else
                    r = ((((gbMulTable[aDisplay | gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]]] + rDisplay) << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
                #endif
                g = ((((gbMulTable[aDisplay | gbMulTable[((gAccum >> GBITS) & 0xff00) | texBits[1]]] + gDisplay) << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
                b = ((((gbMulTable[aDisplay | gbMulTable[((bAccum >> BBITS) & 0xff00) | texBits[0]]] + bDisplay) << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

                #if (BPP == 8)
                    *pPix = gengc->xlatPalette[r | g | b];
                #elif (BPP == 16)
                    *((USHORT *)pPix) = (USHORT)(r | g | b);
                #else
                    *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                    pPix[2] = (BYTE)(r >> 16);
                #endif
            }
    
        #else

            #if (BPP == 32)
                r = (((gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]] << (8+RBITS)) + ditherVal) << -RRIGHTSHIFTADJ) & RMASK;
            #else
                r = (((gbMulTable[((rAccum >> RBITS) & 0xff00) | texBits[2]] << (8+RBITS)) + ditherVal) >> RRIGHTSHIFTADJ) & RMASK;
            #endif
            g = (((gbMulTable[((gAccum >> GBITS) & 0xff00) | texBits[1]] << (8+GBITS)) + ditherVal) >> GRIGHTSHIFTADJ) & GMASK;
            b = (((gbMulTable[((bAccum >> BBITS) & 0xff00) | texBits[0]] << (8+BBITS)) + ditherVal) >> BRIGHTSHIFTADJ) & BMASK;

            #if (BPP == 8)
                *pPix = gengc->xlatPalette[r | g | b];
            #elif (BPP == 16)
                *((USHORT *)pPix) = (USHORT)(r | g | b);
            #else
                *((USHORT UNALIGNED *)pPix) = (USHORT)(g | b);
                pPix[2] = (BYTE)(r >> 16);
            #endif
        #endif
    }
    #endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\texspan.h ===
/******************************Module*Header*******************************\
* Module Name: texspan.h
*
* Main header file for textured spans.
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

typedef LONG FIXED16;


#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)

#if (REPLACE || FAST_REPLACE)

    #define RRIGHTSHIFTADJ  (16 - (RSHIFT + RBITS))
    #define GRIGHTSHIFTADJ  (16 - (GSHIFT + GBITS))
    #define BRIGHTSHIFTADJ  (16 - (BSHIFT + BBITS))

#else

    #define RRIGHTSHIFTADJ  (16 - (RSHIFT))
    #define GRIGHTSHIFTADJ  (16 - (GSHIFT))
    #define BRIGHTSHIFTADJ  (16 - (BSHIFT))

#endif

#define S_SHIFT_PAL	16
#define T_SHIFT_PAL	6
#define TMASK_SUBDIV    GENACCEL(gengc).tMaskSubDiv
#define TSHIFT_SUBDIV   GENACCEL(gengc).tShiftSubDiv


#if (FAST_REPLACE)
    #define TEX_PALETTE         GENACCEL(gengc).texImageReplace
    #if (PALETTE_ONLY)
        #define TEX_IMAGE       GENACCEL(gengc).texImage
    #else
        #define TEX_IMAGE       GENACCEL(gengc).texImageReplace
    #endif
    #if (PALETTE_ONLY)
        #define S_SHIFT S_SHIFT_PAL
        #define T_SHIFT 6
    #elif (BPP == 8)
        #define S_SHIFT 16
        #define T_SHIFT 6
    #else
        #define S_SHIFT 15
        #define T_SHIFT 5
    #endif
#else
    #if (PALETTE_ONLY)
        #define S_SHIFT S_SHIFT_PAL
        #define T_SHIFT 6
    #else
        #define S_SHIFT 14
        #define T_SHIFT 4
    #endif

    #define TEX_IMAGE       GENACCEL(gengc).texImage
    #define TEX_PALETTE     GENACCEL(gengc).texPalette
#endif


#define ALPHA_MODULATE  \
    aDisplay = (ULONG)(gbMulTable[((aAccum >> 8) & 0xff00) | texBits[3]]) << 8;

#define ALPHA_NOMODULATE  \
    aDisplay = ((ULONG)texBits[3] << 8);

#define ALPHA_READ_8 \
{\
    ULONG pix = (ULONG)gengc->pajInvTranslateVector[*pPix];\
    ULONG alphaVal = (0xff00 - aDisplay);\
\
    rDisplay = gbMulTable[((pix & RMASK) << (GBITS + BBITS)) | alphaVal];\
    gDisplay = gbMulTable[((pix & GMASK) << (BBITS)) | alphaVal];\
    bDisplay = gbMulTable[(pix & BMASK) | alphaVal];\
}


#define ALPHA_READ_16 \
{\
    ULONG pix = *((USHORT *)pPix);\
    ULONG alphaVal = (0xff00 - aDisplay);\
\
    rDisplay = gbMulTable[((pix & RMASK) >> (RSHIFT - (8 - RBITS))) | alphaVal];\
    gDisplay = gbMulTable[((pix & GMASK) >> (GSHIFT - (8 - GBITS))) | alphaVal];\
    bDisplay = gbMulTable[((pix & BMASK) << (8 - BBITS)) | alphaVal];\
}


#define ALPHA_READ_32 \
{\
    ULONG alphaVal = (0xff00 - aDisplay);\
\
    rDisplay = gbMulTable[pPix[2] | alphaVal];\
    gDisplay = gbMulTable[pPix[1] | alphaVal];\
    bDisplay = gbMulTable[pPix[0] | alphaVal];\
}

#if (BPP == 8)
    #define ALPHA_READ  ALPHA_READ_8
#elif (BPP == 16)
    #define ALPHA_READ  ALPHA_READ_16
#else
    #define ALPHA_READ  ALPHA_READ_32
#endif

#undef STRING1
#undef STRING2
#undef STRING3
#undef STRING4

#if FAST_REPLACE
    #if PALETTE_ONLY
        #define STRING1 __fastFastPerspPalReplace
    #else
        #define STRING1 __fastFastPerspReplace
    #endif
#elif REPLACE
    #if (PALETTE_ONLY)
        #define STRING1 __fastPerspPalReplace
    #else
        #define STRING1 __fastPerspReplace
    #endif
#elif FLAT_SHADING
    #define STRING1 __fastPerspFlat
#else
    #define STRING1 __fastPerspSmooth
#endif

#if ALPHA
    #define STRING2 Alpha
#endif


#if ZBUFFER
    #if (ZCMP_L)
        #define STRING3 Zlt
    #else
        #define STRING3 Zle
    #endif
#endif

#if (BPP == 8)
    #define STRING4 332
#elif (BPP == 16)
    #if (GBITS == 5)
        #define STRING4 555
    #else
        #define STRING4 565
    #endif
#else
    #define STRING4 888
#endif

#ifdef STRING2

    #ifdef STRING3
        void FASTCALL STRCAT4(STRING1, STRING2, STRING3, STRING4)
    #else
        void FASTCALL STRCAT3(STRING1, STRING2, STRING4)
    #endif

#else

    #ifdef STRING3
        void FASTCALL STRCAT3(STRING1, STRING3, STRING4)
    #else
        void FASTCALL STRCAT2(STRING1, STRING4)
    #endif

#endif


(__GLGENcontext *gengc)
{
    __GLfloat qwInv;
    ULONG count;
    LONG subDivCount;
    FIXED16 sAccum;
    FIXED16 tAccum;
    __GLfloat qwAccum;
    FIXED16 subDs, subDt;
    FIXED16 sResult, tResult;
    FIXED16 sResultNew, tResultNew;
    BYTE *pPix;
    BYTE *texAddr;
    BYTE *texBits;
#if ALPHA
    ULONG rDisplay, gDisplay, bDisplay, aDisplay;
#endif
#if (FLAT_SHADING || SMOOTH_SHADING)
    PDWORD pdither;
    FIXED16 rAccum, gAccum, bAccum;
    #if (ALPHA)
        FIXED16 aAccum;
    #endif
#endif

#if (BPP == 32)
    ULONG pixAdj;
    #if (FLAT_SHADING || SMOOTH_SHADING)
        ULONG ditherVal;
    #endif
#endif

#if PALETTE_ENABLED
    BOOL bPalette = (GENACCEL(gengc).texPalette != NULL);
#endif
    BOOL bOrtho = (GENACCEL(gengc).flags & GEN_TEXTURE_ORTHO);

    if (!bOrtho) {
        if (CASTINT(gengc->gc.polygon.shader.frag.qw) <= 0)
            gengc->gc.polygon.shader.frag.qw = (__GLfloat)1.0;
        __GL_FLOAT_BEGIN_DIVIDE(__glOne, gengc->gc.polygon.shader.frag.qw,
                                &qwInv);
    }

    subDivCount = 7;
    sAccum = GENACCEL(gengc).spanValue.s;
    tAccum = GENACCEL(gengc).spanValue.t;
    qwAccum = gengc->gc.polygon.shader.frag.qw;
#if (FLAT_SHADING)
    rAccum = ((GENACCEL(gengc).spanValue.r >> RBITS) & 0xff00);
    gAccum = ((GENACCEL(gengc).spanValue.g >> GBITS) & 0xff00);
    bAccum = ((GENACCEL(gengc).spanValue.b >> BBITS) & 0xff00);
    #if (ALPHA)
        aAccum = GENACCEL(gengc).spanValue.a;
    #endif
#elif (SMOOTH_SHADING)
    rAccum = GENACCEL(gengc).spanValue.r;
    gAccum = GENACCEL(gengc).spanValue.g;
    bAccum = GENACCEL(gengc).spanValue.b;
    #if ALPHA
        aAccum = GENACCEL(gengc).spanValue.a;
    #endif
#endif
#if ((BPP == 32) && (FLAT_SHADING || SMOOTH_SHADING))
    ditherVal = ditherShade[0];
#endif

    if (!bOrtho) {
        __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
        sResult = FTOL((__GLfloat)sAccum * qwInv);
        tResult = ((FTOL((__GLfloat)tAccum * qwInv)) >> TSHIFT_SUBDIV) & ~7;
        qwAccum += GENACCEL(gengc).qwStepX;
        if (CASTINT(qwAccum) <= 0)
            qwAccum = (__GLfloat)1.0;
        __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, qwAccum, qwInv);
    } else {
        sResult = sAccum;
        tResult = (tAccum >> TSHIFT_SUBDIV) & ~7;
    }
    sAccum += GENACCEL(gengc).sStepX;
    tAccum += GENACCEL(gengc).tStepX;

    if (GENACCEL(gengc).flags & SURFACE_TYPE_DIB) {
        #if (BPP != 32)
            pPix = GENACCEL(gengc).pPix +
                gengc->gc.polygon.shader.frag.x * (BPP / 8);
        #else
            if (GENACCEL(gengc).bpp == 32) {
                pPix = GENACCEL(gengc).pPix +
                    gengc->gc.polygon.shader.frag.x * 4;
                pixAdj = 4;
            } else {
                pPix = GENACCEL(gengc).pPix +
                    gengc->gc.polygon.shader.frag.x * 3;
                pixAdj = 3;
            }
        #endif
    } else {
        pPix = gengc->ColorsBits;    
        #if (BPP == 32)
            pixAdj = GENACCEL(gengc).xMultiplier;
        #endif
    }

#if (FLAT_SHADING || SMOOTH_SHADING)
    #if (BPP != 32)
        pdither = (gengc->gc.polygon.shader.frag.y & 0x3) * 8 + ditherShade +
                  (((gengc->gc.polygon.shader.frag.x & 0x3) -
                   (((ULONG_PTR)pPix / (BPP / 8)) & 0x3)) & 0x3);
    #endif
#endif

    if (!bOrtho) {
        __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
        sResultNew = FTOL((__GLfloat)sAccum * qwInv);
        tResultNew = ((FTOL((__GLfloat)tAccum * qwInv)) >> TSHIFT_SUBDIV) & ~7;
        qwAccum += GENACCEL(gengc).qwStepX;
        if (CASTINT(qwAccum) <= 0)
            qwAccum = (__GLfloat)1.0;
        __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, qwAccum, qwInv);
    } else {
        sResultNew = sAccum;
        tResultNew = (tAccum >> TSHIFT_SUBDIV) & ~7;
    }

    sAccum += GENACCEL(gengc).sStepX;
    tAccum += GENACCEL(gengc).tStepX;

    subDs = (sResultNew - sResult) >> 3;
    subDt = (tResultNew - tResult) >> 3;

#if ZBUFFER
    {
        GLuint zAccum = gengc->gc.polygon.shader.frag.z;
        GLint  zDelta = gengc->gc.polygon.shader.dzdx;
        PBYTE zbuf = (PBYTE)gengc->gc.polygon.shader.zbuf;

        if (GENACCEL(gengc).flags & GEN_LESS) {
            for (count = gengc->gc.polygon.shader.length;;) {
                if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) < *((__GLz16Value*)zbuf) ) {
                    *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    #include "texspan2.h"
                }
                if (--count == 0)
                    goto exit;
                zbuf += 2;
                zAccum += zDelta;
                #include "texspan3.h"
            }
        } else {
            for (count = gengc->gc.polygon.shader.length;;) {
                if ( ((__GLz16Value)(zAccum >> Z16_SHIFT)) <= *((__GLz16Value*)zbuf) ) {
                    *((__GLz16Value*)zbuf) = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    #include "texspan2.h"
                }
                if (--count == 0)
                    goto exit;
                zbuf += 2;
                zAccum += zDelta;
                #include "texspan3.h"
            }
        }
    }
#else
    for (count = gengc->gc.polygon.shader.length;;) {
        #include "texspan2.h"
        if (--count == 0)
            goto exit;
        #include "texspan3.h"
    }
#endif

exit:
    if (!bOrtho) {
        __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
    }
}

#undef RMASK
#undef GMASK
#undef BMASK
#undef RRIGHTSHIFTADJ
#undef GRIGHTSHIFTADJ
#undef BRIGHTSHIFTADJ
#undef ALPHA_MODULATE
#undef ALPHA_NOMODULATE
#undef ALPHA_READ_8
#undef ALPHA_READ_16
#undef ALPHA_READ_32
#undef ALPHA_READ

#undef S_SHIFT
#undef T_SHIFT
#undef TMASK_SUBDIV
#undef TSHIFT_SUBDIV
#undef TEX_IMAGE
#undef TEX_PALETTE
#undef S_SHIFT_PAL
#undef T_SHIFT_PAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\texspan3.h ===
/******************************Module*Header*******************************\
* Module Name: texspan3.h
*
* Advance the required interpolants, and do the subdivision if needed.
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

    #if (SMOOTH_SHADING)
        rAccum += GENACCEL(gengc).spanDelta.r;
        gAccum += GENACCEL(gengc).spanDelta.g;
        bAccum += GENACCEL(gengc).spanDelta.b;
        #if (ALPHA)
            aAccum += GENACCEL(gengc).spanDelta.a;
        #endif
    #endif

    #if (BPP != 32)
        pPix += (BPP / 8);
    #else
        pPix += pixAdj;
    #endif

    if (--subDivCount < 0) {
        if (!bOrtho) {
            __GL_FLOAT_SIMPLE_END_DIVIDE(qwInv);
            sResult = sResultNew;
            tResult = tResultNew;
            sResultNew = FTOL((__GLfloat)sAccum * qwInv);
            tResultNew = ((FTOL((__GLfloat)tAccum * qwInv)) >> TSHIFT_SUBDIV) & ~7;
            qwAccum += GENACCEL(gengc).qwStepX;
            if (CASTINT(qwAccum) <= 0)
                qwAccum -= GENACCEL(gengc).qwStepX;
            __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, qwAccum, qwInv);
        } else {
            sResult = sResultNew;
            tResult = tResultNew;
            sResultNew = sAccum;
            tResultNew = (tAccum >> TSHIFT_SUBDIV) & ~7;
        }
        sAccum += GENACCEL(gengc).sStepX;
        tAccum += GENACCEL(gengc).tStepX;

        subDs = (sResultNew - sResult) >> 3;
        subDt = (tResultNew - tResult) >> 3;

        subDivCount = 7;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\texspans.h ===
/******************************Module*Header*******************************\
* Module Name: texspans.h
*
* This file is included to generate the set of perspective-corrected
* span functions with combinations of pixel formats and other attributes
*
* 22-Nov-1995   ottob  Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#undef  ZBUFFER
#define ZBUFFER 0
#undef ZCMP_L
#define ZCMP_L 0
#undef ALPHA
#define ALPHA 0

#if (!SKIP_FAST_REPLACE)

#include "texspan.h"


#undef  ZBUFFER
#define ZBUFFER 1

#include "texspan.h"

#undef ZCMP_L
#define ZCMP_L 1

#include "texspan.h"

#endif // SKIP_FAST_REPLACE

#if !(FAST_REPLACE && !PALETTE_ONLY)

#undef  ZBUFFER
#define ZBUFFER 0
#undef ZCMP_L
#define ZCMP_L 0
#undef ALPHA
#define ALPHA 1

#include "texspan.h"

#undef  ZBUFFER
#define ZBUFFER 1

#include "texspan.h"

#undef ZCMP_L
#define ZCMP_L 1

#include "texspan.h"

#endif	// FAST_REPLACE and not PALETTE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\types.h ===
#ifndef __gltypes_h_
#define __gltypes_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Low level data types.
*/

#ifdef NT
#include <nt.h>
#include <windef.h>
#include <wingdi.h>

#include <ddraw.h>
#include <mcdesc.h>

#endif

#include <GL/gl.h>

/*
** Typedefs.  These are forward declarations to internal data structures.
** This eases the burden of dealing with circular references among
** the header files.
*/
typedef GLshort __GLaccumCellElement;
typedef GLubyte __GLstencilCell;
typedef struct __GLaccumBufferRec __GLaccumBuffer;
typedef struct __GLalphaBufferRec __GLalphaBuffer;
typedef struct __GLattributeRec __GLattribute;
typedef struct __GLbitmapRec __GLbitmap;
typedef struct __GLbufferRec __GLbuffer;
typedef struct __GLcolorBufferRec __GLcolorBuffer;
typedef struct __GLcontextRec __GLcontext;
typedef struct __GLdepthBufferRec __GLdepthBuffer;
typedef struct __GLfogMachineRec __GLfogMachine;
typedef struct __GLfragmentRec __GLfragment;
typedef struct __GLlightModelStateRec __GLlightModelState;
typedef struct __GLlightSourceMachineRec __GLlightSourceMachine;
typedef struct __GLlineOptionsRec __GLlineOptions;
typedef struct __GLmaterialMachineRec __GLmaterialMachine;
typedef struct __GLmaterialStateRec __GLmaterialState;
typedef struct __GLmatrixRec __GLmatrix;
typedef struct __GLpixelSpanInfoRec __GLpixelSpanInfo;
typedef struct __GLprocTableRec __GLprocTable;
typedef struct __GLscreenRec __GLscreen;
typedef struct __GLshadeRec __GLshade;
typedef struct __GLphongShadeRec __GLphongShade;
typedef struct __GLstencilBufferRec __GLstencilBuffer;
typedef struct __GLstippleRec __GLstipple;
typedef struct __GLtransformRec __GLtransform;
typedef struct __GLvertexRec __GLvertex;
typedef struct __GLtexelRec __GLtexel;
typedef struct __GLdlistOpRec __GLdlistOp;

typedef struct __GLcontextModesRec __GLcontextModes;
typedef struct __GLnamesArrayRec __GLnamesArray;

typedef struct __GLGENbuffersRec __GLGENbuffers;

/*
** Type of z value used by the software z buffering code.
** NOTE: must be unsigned
*/
#ifdef NT
#define FIX_SCALEFACT           __glVal65536
#define FIX_SHIFT               16

typedef unsigned short __GLz16Value;
#define Z16_SCALE	        FIX_SCALEFACT
#define Z16_SHIFT	        FIX_SHIFT
#endif
typedef unsigned int __GLzValue;

/************************************************************************/

/*
** Implementation data types.  The implementation is designed to run in
** single precision or double precision mode, all of which is controlled
** by an ifdef and the following typedef's.
*/
#ifdef	__GL_DOUBLE
typedef double __GLfloat;
#else
typedef float __GLfloat;
#endif

/************************************************************************/

/*
** Coordinate structure.  Coordinates contain x, y, z and w.
*/
typedef struct __GLcoordRec {
    __GLfloat x, y, z, w;
} __GLcoord;

/*
** Color structure.  Colors are composed of red, green, blue and alpha.
*/
typedef struct __GLcolorRec {
    __GLfloat r, g, b, a;
} __GLcolor;

typedef struct __GLicolorRec {
    GLint r, g, b, a;
} __GLicolor;

typedef struct __GLuicolorRec {
    GLuint r, g, b, a;
} __GLuicolor;

/*
** Generic no-operation procedure.  Used when function pointers need to
** be stubbed out when an operation is disabled.
*/
extern void FASTCALL __glNop(void);
extern void FASTCALL __glNopGC(__GLcontext*);
extern GLboolean FASTCALL __glNopGCBOOL(__GLcontext*);
extern void FASTCALL __glNopGCFRAG(__GLcontext*, __GLfragment *, __GLtexel *);
extern void FASTCALL __glNopGCCOLOR(__GLcontext*, __GLcolor *, __GLtexel *);
extern void FASTCALL __glNopLight(__GLcontext*, GLint, __GLvertex*);
extern void FASTCALL __glNopGCListOp(__GLcontext *, __GLdlistOp*);
extern void FASTCALL __glNopExtract(struct __GLmipMapLevelRec *level, struct __GLtextureRec *tex,
                                    GLint row, GLint col, __GLtexel *result);

#endif /* __gltypes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\texture.h ===
#ifndef _texture_h_
#define _texture_h_

/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.11 $
** $Date: 1995/01/25 18:07:23 $
*/
#include "types.h"

#define __GL_TEX_TARGET_INDEX_1D 2
#define __GL_TEX_TARGET_INDEX_2D 3

// This doesn't correspond to an actual default texture, it's just a special
// name for the static DDraw texobj.
#define __GL_TEX_TARGET_INDEX_DDRAW 4

// Texobj name for the DDraw texobj.  This can't be zero because it
// must be distinct from a default texture name.  Technically that's
// all that matters, but in reality it's nice to use a number that's
// uncommon as a normal texture name because it makes it easy to
// identify the DDraw texture object vs. a normal texture object.
// This difference can never be guaranteed, though, so no code should
// ever be written that assumes name matching is good enough to
// identify the DDraw texture object.
#define __GL_TEX_DDRAW 0xdddddddd

/*
** Client state set with glTexGen.
**
** This structure is shared with MCD as MCDTEXTURECOORDGENERATION.
*/
typedef struct __GLtextureCoordStateRec {
    /* How coordinates are being generated */
    GLenum mode;

    /* eye plane set via API, stored for MCD */
    __GLcoord eyePlaneSet;
    
    /* eye plane equation (used iff mode == GL_EYE_LINEAR) */
    __GLcoord eyePlaneEquation;

    /* object plane equation (used iff mode == GL_OBJECT_LINEAR) */
    __GLcoord objectPlaneEquation;
} __GLtextureCoordState;

/*
** Client state set with glTexEnv
*/
typedef struct __GLtextureEnvStateRec {
    /* environment "blend" function */
    GLenum mode;

    /* environment color */
    __GLcolor color;
} __GLtextureEnvState;

//!!! Don't change this structure without changing MCDTEXTURESTATE !!!

/*
** Client state set with glTexParameter
*/
typedef struct __GLtextureParamStateRec {
    /* S & T wrap modes */
    GLenum sWrapMode;
    GLenum tWrapMode;

    /* min and mag filter */
    GLenum minFilter;
    GLenum magFilter;

    /* border color */
    __GLcolor borderColor;	/* Unscaled! */
} __GLtextureParamState;

/*
** Stackable texture object state.
*/
typedef struct __GLtextureObjectStateRec {
    GLuint name;	/* name of the texture */
    GLfloat priority;	/* priority of the texture object */
} __GLtextureObjectState;

/*
** Client state per texture map per dimension.
*/
typedef struct __GLperTextureStateRec {
    /*
    ** Texture parameter state (set with glTexParameter).
    */
    __GLtextureParamState params;

    /*
    ** Texture object bindings and priorities.
    */
    __GLtextureObjectState texobjs;
} __GLperTextureState;

/*
** Stackable client texture state. This does not include
** the mipmaps, or level dependent state.  Only state which is
** stackable via glPushAttrib/glPopAttrib is here.  The rest of the
** state is in the machine structure below.
*/
typedef struct __GLtextureStateRec {
    /* Per coordinate texture state (set with glTexGen) */
    __GLtextureCoordState s;
    __GLtextureCoordState t;
    __GLtextureCoordState r;
    __GLtextureCoordState q;

    /* Per texture state */
    __GLperTextureState *texture;

    /* Per texture environment state */
    __GLtextureEnvState *env;
} __GLtextureState;

/************************************************************************/

typedef __GLfloat __GLtextureBuffer;

typedef struct __GLtexelRec {
    __GLfloat r, g, b;
    __GLfloat luminance;
    __GLfloat alpha;
    __GLfloat intensity;
} __GLtexel;

/************************************************************************/

typedef struct __GLmipMapLevelRec __GLmipMapLevel;
typedef struct __GLtextureRec __GLtexture;

//!!! Don't change this structure without changing MCDMIPMAPLEVEL !!!

struct __GLmipMapLevelRec {
    __GLtextureBuffer *buffer;
    /* Image dimensions, including border */
    GLint width, height;

    /* Image dimensions, doesn't include border */
    GLint width2, height2;
    __GLfloat width2f, height2f;

    /* log2 of width2 & height2 */
    GLint widthLog2, heightLog2;

    /* Border size */
    GLint border;

    /* Requested internal format */
    GLint requestedFormat;

    /* Base internal format */
    GLint baseFormat;

    /* Actual internal format */
    GLint internalFormat;

    /* Component resolution */
    GLint redSize;
    GLint greenSize;
    GLint blueSize;
    GLint alphaSize;
    GLint luminanceSize;
    GLint intensitySize;

    /* Extract function for this mipmap level */
    void (FASTCALL *extract)(__GLmipMapLevel *level, __GLtexture *tex,
                             GLint row, GLint col, __GLtexel *result);
};

//!!! Don't change this structure without changing MCDTEXTUREDATA !!!

struct __GLtextureRec {
    /* Back pointer to context */
    __GLcontext *gc;

    /* Copy of parameter state */
    // This is the start of MCDTEXTUREDATA:
    __GLtextureParamState params;

    /* Copy of texure object stackable state */
    __GLtextureObjectState texobjs;

    /* Level information */
    __GLmipMapLevel *level;

    /* Dimension of this texture (1 or 2) */
    GLint dim;

#ifdef GL_EXT_paletted_texture
    // The palette is the same for all mipmap levels so it
    // is a texture field rather than a mipmap field
    GLsizei paletteSize;
    RGBQUAD *paletteData;

    // Type of palette data, determined by glColorTableEXT
    // and applied to all mipmap levels
    GLenum paletteBaseFormat;
    // internalFormat given in glColorTableEXT call, for
    // GL_COLOR_TABLE_FORMAT requests
    GLenum paletteRequestedFormat;
#endif

    /* maximum( log2(level[0].width2), log2(level[0].height2) ) */
    GLint p;

    /* Min/Mag switchover point */
    __GLfloat c;

    /* Create a new mipmap level for this texture */
    __GLtextureBuffer * (FASTCALL *createLevel)(__GLcontext *gc, __GLtexture *tex,
				       GLint lod, GLint components,
				       GLsizei w, GLsizei h, GLint border,
				       GLint dim);

    /* Texturing function for this texture */
    void (*textureFunc)(__GLcontext *gc, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLfloat rho);

    /* Apply current environment function to fragment */
    void (FASTCALL *env)(__GLcontext *gc, __GLcolor *color, __GLtexel *texel);

    /* Magnification routine for this texture */
    void (FASTCALL *magnify)(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		    __GLcolor *color, __GLfloat s, __GLfloat t,
		    __GLtexel *result);

    /* Minification routine for this texture */
    void (FASTCALL *minnify)(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		    __GLcolor *color, __GLfloat s, __GLfloat t,
		    __GLtexel *result);

    /* Linear filter for this texture */
    void (FASTCALL *linear)(__GLcontext *gc, __GLtexture *tex,
		   __GLmipMapLevel *lp, __GLcolor *color,
		   __GLfloat s, __GLfloat t, __GLtexel *result);

    /* Nearest filter for this texture */
    void (FASTCALL *nearest)(__GLcontext *gc, __GLtexture *tex,
		    __GLmipMapLevel *lp, __GLcolor *color,
		    __GLfloat s, __GLfloat t, __GLtexel *result);

    void *pvUser;   // user-defined expansion for caching, etc.
    DWORD textureKey;  // driver-private key for MCD-accelerated textures

    // The palette can be subdivided into multiple sections.  paletteSize
    // and paletteData point to a single section, while the Total versions
    // contain information about the entire palette.
    GLsizei paletteTotalSize;
    RGBQUAD *paletteTotalData;

    // Number of subdivisions in total palette minus one
    GLsizei paletteDivision;

    // Shift to go from subdivision number to palette entry
    GLsizei paletteDivShift;
};

typedef struct __GLperTextureMachineRec {
    __GLtexture map;
} __GLperTextureMachine;


/*
** Texture object structure.
** refcount field MUST be first in the structure.
*/
typedef struct __GLtextureObjectRec {
    GLint refcount;   	/* reference count: create with 1; delete when 0 */
			/* refcount MUST be first in this structure */
    GLenum targetIndex;	/* index of the target it's bound to */
    GLboolean resident; /* residence status of the texture object */
    __GLperTextureMachine texture;	/* actual texture data */
    struct __GLtextureObjectRec *lowerPriority; /* Priority list link */
    struct __GLtextureObjectRec *higherPriority; /* Priority list link */
    HANDLE loadKey;     /* Texture memory load key for unloading */
} __GLtextureObject;

typedef struct __GLsharedTextureStateRec {
    /* Stores pointers to texture objects, retrieved by name */
    __GLnamesArray *namesArray;

    /* List of all texture objects sorted by priority */
    __GLtextureObject *priorityListHighest;
    __GLtextureObject *priorityListLowest;
} __GLsharedTextureState;

/*
** DDraw texture flags.
*/

/* Whether the texture's format is supported by generic or not */
#define DDTEX_GENERIC_FORMAT    0x00000001

/* Whether all texture surfaces are in video memory or not */
#define DDTEX_VIDEO_MEMORY      0x00000002

typedef struct ___GLddrawTexture {
    /* If levels is greater than zero, a DirectDraw texture is current */
    GLint levels;
    
    /* Level-zero surface with cached description */
    GLDDSURF gdds;

    /* Storage space for DirectDraw texture definitions */
    __GLtextureObject texobj;

    /* levels surface pointers */
    LPDIRECTDRAWSURFACE *pdds;
    
    GLuint flags;
} __GLddrawTexture;
    
typedef struct __GLtextureMachineRec {
    __GLperTextureMachine **texture;

    /* Array of ptrs to the currently bound texture objects. */
    __GLtextureObject **boundTextures;

    /* Array of dummy texture objects for the default textures */
    __GLtextureObject *defaultTextures;

#ifdef GL_WIN_multiple_textures
    /* Current texture index */
    GLuint texIndex;
#endif // GL_WIN_multiple_textures
    
    /* Current enabled texture */
    __GLtexture *currentTexture;

    /* Current DirectDraw texture */
    __GLddrawTexture ddtex;
    
    /* The OR of all texture enable bits */
    GLboolean textureEnabled;

    /* State that can be shared between contexts */
    __GLsharedTextureState *shared;
} __GLtextureMachine;

/************************************************************************/

/* Check for texture consistency before enabling texturing */
extern GLboolean FASTCALL __glIsTextureConsistent(__GLcontext *gc, GLenum texture);

/* Fragment texturing routines */
extern void __glFastTextureFragment(__GLcontext *gc, __GLcolor *color,
				    __GLfloat s, __GLfloat t, __GLfloat rho);
extern void __glTextureFragment(__GLcontext *gc, __GLcolor *color,
				__GLfloat s, __GLfloat t, __GLfloat rho);
extern void __glMipMapFragment(__GLcontext *gc, __GLcolor *color,
			       __GLfloat s, __GLfloat t, __GLfloat rho);

/* Texturing routines */
extern void FASTCALL __glLinearFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			     __GLcolor *color, __GLfloat s, __GLfloat t,
			     __GLtexel *result);
extern void FASTCALL __glNearestFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			      __GLcolor *color, __GLfloat s, __GLfloat t,
			      __GLtexel *result);
extern void FASTCALL __glNMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);
extern void FASTCALL __glLMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);
extern void FASTCALL __glNMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);
extern void FASTCALL __glLMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
			  __GLcolor *color, __GLfloat s, __GLfloat t,
			  __GLtexel *result);

/* Filter routines */
extern void FASTCALL __glLinearFilter1(__GLcontext *gc, __GLtexture *tex,
			      __GLmipMapLevel *lp, __GLcolor *color,
			      __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glLinearFilter2(__GLcontext *gc, __GLtexture *tex,
			      __GLmipMapLevel *lp, __GLcolor *color,
			      __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glNearestFilter1(__GLcontext *gc, __GLtexture *tex,
			       __GLmipMapLevel *lp, __GLcolor *color,
			       __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glNearestFilter2(__GLcontext *gc, __GLtexture *tex,
			       __GLmipMapLevel *lp, __GLcolor *color,
			       __GLfloat s, __GLfloat t, __GLtexel *result);

extern void FASTCALL __glLinearFilter2_BGR8Repeat(__GLcontext *gc, 
                       __GLtexture *tex, __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result);
extern void FASTCALL __glLinearFilter2_BGRA8Repeat(__GLcontext *gc, 
                       __GLtexture *tex, __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result);

/* Texture environment functions */
extern void FASTCALL __glTextureModulateL(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateLA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateRGB(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateRGBA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureModulateI(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);

extern void FASTCALL __glTextureDecalRGB(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureDecalRGBA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);

extern void FASTCALL __glTextureBlendL(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendLA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendRGB(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendRGBA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendA(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);
extern void FASTCALL __glTextureBlendI(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);

extern void FASTCALL __glTextureReplaceL(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceLA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceRGB(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceRGBA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceA(__GLcontext *gc, __GLcolor *color,
				 __GLtexel *tx);
extern void FASTCALL __glTextureReplaceI(__GLcontext *gc, __GLcolor *color,
			      __GLtexel *tx);

/* Extract a texel from a texture level (no border) */
extern void FASTCALL __glExtractTexelL(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelLA(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelA(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelI(__GLmipMapLevel *level, __GLtexture *tex,
			      GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelBGR8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelBGRA8(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);

/* Extract a texel from a texture level (the texture has a border) */
extern void FASTCALL __glExtractTexelL_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelLA_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelA_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelI_B(__GLmipMapLevel *level, __GLtexture *tex,
			       GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGB8_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelRGBA8_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
#ifdef GL_EXT_paletted_texture
extern void FASTCALL __glExtractTexelPI8BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI8BGR(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGR(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI8BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI8BGRA(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
extern void FASTCALL __glExtractTexelPI16BGRA(__GLmipMapLevel *level, __GLtexture *tex,
				GLint row, GLint col, __GLtexel *res);
#endif

#ifdef GL_EXT_bgra
void FASTCALL __glExtractTexelBGR8_B(__GLmipMapLevel *level, __GLtexture *tex,
                                     GLint row, GLint col, __GLtexel *result);
void FASTCALL __glExtractTexelBGRA8_B(__GLmipMapLevel *level, __GLtexture *tex,
                                      GLint row, GLint col, __GLtexel *result);
#endif // GL_EXT_bgra

/* Texture init */
extern void FASTCALL __glInitTextureUnpack(__GLcontext *gc, __GLpixelSpanInfo *, GLint,
				  GLint, GLenum, GLenum, const GLvoid *,
				  GLenum, GLboolean);
extern void FASTCALL __glInitImagePack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
                                       GLint width, GLint height, GLenum format, GLenum type, 
                                       const GLvoid *buf);

/* List execution texture image code */
extern void __gllei_TexImage1D(__GLcontext *gc, GLenum target, GLint lod,
			       GLint components, GLint length, 
			       GLint border, GLenum format, GLenum type,
			       const GLubyte *image);
extern void __gllei_TexImage2D(__GLcontext *gc, GLenum target, GLint lod,
			       GLint components, GLint w, GLint h,
			       GLint border, GLenum format, GLenum type,
			       const GLubyte *image);

extern void __gllei_TexSubImage1D(__GLcontext *gc, GLenum target, GLint lod,
				     GLint xoffset, GLint length,
				     GLenum format, GLenum type,
				     const GLubyte *image);
extern void __gllei_TexSubImage2D(__GLcontext *gc, GLenum target, GLint lod, 
				     GLint xoffset, GLint yoffset,
				     GLsizei w, GLsizei h,
				     GLenum format, GLenum type,
				     const GLubyte *image);

/* Rho calculation routines */
extern __GLfloat __glComputeLineRho(__GLcontext *gc, 
				    __GLfloat s, __GLfloat t, __GLfloat wInv);
extern __GLfloat __glNopLineRho(__GLcontext *gc, 
				__GLfloat s, __GLfloat t, __GLfloat wInv);
extern __GLfloat __glComputePolygonRho(__GLcontext *gc, const __GLshade *sh,
				       __GLfloat s, __GLfloat t,
				       __GLfloat winv);
extern __GLfloat __glNopPolygonRho(__GLcontext *gc, const __GLshade *sh,
				   __GLfloat s, __GLfloat t, __GLfloat winv);

extern __GLtexture *FASTCALL __glCheckTexImage1DArgs(__GLcontext *gc, GLenum target,
					    GLint lod, GLint components,
					    GLsizei length, GLint border,
					    GLenum format, GLenum type);

extern __GLtexture *FASTCALL __glCheckTexImage2DArgs(__GLcontext *gc, GLenum target,
					    GLint lod, GLint components,
					    GLsizei w, GLsizei h, GLint border,
					    GLenum format, GLenum type);

/* Texture Lookup */
extern __GLtextureObjectState *FASTCALL __glLookUpTextureTexobjs(__GLcontext *gc,
						        GLenum target);
/* Texture Lookup */
extern __GLtextureParamState *FASTCALL __glLookUpTextureParams(__GLcontext *gc,
						      GLenum target);
extern __GLtexture *FASTCALL __glLookUpTexture(__GLcontext *gc, GLenum target);

extern __GLtextureObject *FASTCALL __glLookUpTextureObject(__GLcontext *gc,
						  GLenum target);

/* Texture Initialization */
extern void FASTCALL __glEarlyInitTextureState(__GLcontext *gc);

GLboolean FASTCALL __glInitTextureObject(__GLcontext *gc,
                                         __GLtextureObject *texobj, 
                                         GLuint name, GLuint targetIndex);
void FASTCALL __glInitTextureMachine(__GLcontext *gc, GLuint targetIndex, 
                                     __GLperTextureMachine *ptm,
                                     GLboolean allocLevels);

/* Bind Texture used by pop or entry point. */
extern void FASTCALL __glBindTexture(__GLcontext *gc, GLuint targetIndex, GLuint name, GLboolean callGen);

#ifdef NT
extern GLboolean FASTCALL __glCanShareTextures(__GLcontext *gc, __GLcontext *shareMe);
extern void FASTCALL __glShareTextures(__GLcontext *gc, __GLcontext *shareMe);
#endif

void FASTCALL __glSetPaletteSubdivision(__GLtexture *tex, GLsizei subdiv);

#ifdef GL_EXT_paletted_texture
// Attempt to set the extraction function.  If no palette is set,
// this can't be done
void __glSetPaletteLevelExtract8(__GLtexture *tex, __GLmipMapLevel *lp,
                                 GLint border);
void __glSetPaletteLevelExtract16(__GLtexture *tex, __GLmipMapLevel *lp,
                                  GLint border);
#endif // GL_EXT_palette_texture

void __glTexPriListRealize(__GLcontext *gc);
void __glTexPriListAddToList(__GLcontext *gc, __GLtextureObject *texobj);
void __glTexPriListAdd(__GLcontext *gc, __GLtextureObject *texobj,
                       GLboolean realize);
void __glTexPriListRemoveFromList(__GLcontext *gc, __GLtextureObject *texobj);
void __glTexPriListRemove(__GLcontext *gc, __GLtextureObject *texobj,
                          GLboolean realize);
void __glTexPriListChangePriority(__GLcontext *gc, __GLtextureObject *texobj,
                                  GLboolean realize);
void __glTexPriListLoadSubImage(__GLcontext *gc, GLenum target, GLint lod, 
                                GLint xoffset, GLint yoffset, 
                                GLsizei w, GLsizei h);
void __glTexPriListLoadImage(__GLcontext *gc, GLenum target);
void __glTexPriListUnloadAll(__GLcontext *gc);

__GLtextureBuffer * FASTCALL __glCreateProxyLevel(__GLcontext *gc,
                                                  __GLtexture *tex,
					   GLint lod, GLint components,
					   GLsizei w, GLsizei h, GLint border,
					   GLint dim);
__GLtextureBuffer * FASTCALL __glCreateLevel(__GLcontext *gc, __GLtexture *tex,
				      GLint lod, GLint components,
				      GLsizei w, GLsizei h, GLint border,
				      GLint dim);

GLvoid FASTCALL __glCleanupTexObj(__GLcontext *gc, void *pData);

void __glFreeSharedTextureState(__GLcontext *gc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <ddraw.h>

#include <math.h>

#include <glp.h>
#include <context.h>
#include <global.h>
#include <pixel.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\vertex.h ===
#ifndef __glvertex_h_
#define __glvertex_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.16 $
** $Date: 1993/12/08 06:29:30 $
*/
#include "types.h"
#include "parray.h"

/*
** Vertex structure.  Each vertex contains enough state to properly
** render the active primitive.  It is used by the front-end geometry
** and back-end rasterization pipelines.
**
** NOTE: Same as the POLYDATA structure!
**
** To minimize storage requirement, some front-end storage (e.g. obj and normal)
** is shared with back-end storage.
*/
struct __GLvertexRec {
    /*
    ** Keep this data structure aligned: have all vectors start on
    ** 4-word boundary, and sizeof this struct should be kept at
    ** a multiple of 4 words. Also helps to bunch together most
    ** frequently used items, helps cache.
    */

    /*
    ** Bits are set in this indicating which fields of the vertex are
    ** valid.  This field is shared with the front-end flags field!
    */
    GLuint has;

    /*
    ** Moved up here to keep GLcoords aligned.
    */
    __GLcolor *color;

    /*
    ** Clipping code mask.  One bit is set for each clipping plane that
    ** the vertex is out on.
    */
    GLuint clipCode;

    /*
    ** Fog value for the vertex.  This is only filled when doing cheap
    ** fogging.
    */
    __GLfloat fog;

    /*
    ** Projected eye coodinate.  This field is filled in when the users
    ** eye coordinate has been multiplied by the projection matrix.
    */

    __GLcoord clip;

    /*
    ** Window coordinate. This field is filled in when the eye coordinate
    ** is converted to a drawing surface relative "window" coordinate.
    ** NOTE: the window.w coordinate contains 1/clip.w.
    */
    __GLcoord window;

    __GLcoord texture;

    __GLcoord normal;

    /*
    ** Colors.  colors[0] is the "front" color, colors[1] is the "back" color.
    ** The color pointer points to which color is current for this
    ** vertex.  Verticies can have more than one color when two sided
    ** lighting is enabled. (note color pointer moved up top).
    */
    __GLcolor colors[2];

    /*
    ** Eye coordinate. This field is filled in when the object coordinate
    ** has been multiplied by the model-view matrix.  If no eye coordinate
    ** was needed then this field contains undefined values.
    */
    __GLfloat eyeX;
    __GLfloat eyeY;
    __GLfloat eyeZ;
    union
    {
        __GLfloat eyeW;         //Used by the phong-shader
        __GLcolor *lastColor;   // eyeW is not used in rasterization
    };

    /*
    ** On Win64 the POLYARRAY structure is larger than the __GLvertex
    ** structure since the former contains several pointers which are
    ** 8 bytes on the 64-bit system. Therefore, this structure must
    ** be padded to be the same size as the POLYARRAY structure.
    **
    ** N.B. Since the structure must be the same size as the POLYDATA
    **      structure that structure must also be padded.
    **
    */

#if defined(_WIN64)

    PVOID Filler[7];

#endif

};

/* Indicies for colors[] array in vertex */
#define __GL_FRONTFACE		0
#define __GL_BACKFACE		1


/* Bits for clipCode (NOTE: MAX of 26 user clip planes) */
#define __GL_CLIP_LEFT		    0x00000001
#define __GL_CLIP_RIGHT		    0x00000002
#define __GL_CLIP_BOTTOM	    0x00000004
#define __GL_CLIP_TOP		    0x00000008
#define __GL_CLIP_NEAR		    0x00000010
#define __GL_CLIP_FAR		    0x00000020
#define __GL_FRUSTUM_CLIP_MASK	0x0000003f
#define __GL_CLIP_USER0		    0x00000040

/* Bits for has */
#ifdef NT
// These has bits are shared with POLYDATA flags!
#define __GL_HAS_EDGEFLAG_BOUNDARY  0x00000001 // must be 1, same as
					       // POLYDATA_EDGEFLAG_BOUNDARY
#define __GL_HAS_FOG	            0x00004000 // same as POLYDATA_FOG_VALID
#define __GL_HAS_FIXEDPT            0x00008000
#else
#define	__GL_HAS_FRONT_COLOR	0x0001
#define __GL_HAS_BACK_COLOR	0x0002
	    /* for poly clipping */
#define __GL_HAS_BOTH		(__GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR)
#define	__GL_HAS_TEXTURE	0x0004
#define __GL_HAS_NORMAL		0x0008
#define __GL_HAS_EYE		0x0010
#define __GL_HAS_CLIP		0x0020
#define __GL_HAS_FOG		0x0040
#define __GL_HAS_LIGHTING	(__GL_HAS_EYE | __GL_HAS_NORMAL)
#endif /* NT */

#ifdef NT

/*
** Poly array needs
*/
// front/back color needs for lit polygons or unlit primitives
#define PANEEDS_FRONT_COLOR         0x0001
#define PANEEDS_BACK_COLOR          0x0002
// normal need
#define PANEEDS_NORMAL              0x0004

#define PANEEDS_NORMAL_FOR_TEXTURE              0x0100
#define PANEEDS_RASTERPOS_NORMAL_FOR_TEXTURE    0x0200

// normal need for RasterPos
#define PANEEDS_RASTERPOS_NORMAL    0x0008
// texture coord need, set by RasterPos too!
#define PANEEDS_TEXCOORD            0x0010
// edge flag need
#define PANEEDS_EDGEFLAG            0x0020
// set in selection mode but cleared by RasterPos!
#define PANEEDS_CLIP_ONLY           0x0040
// skip lighting calculation optimiztaion
#define PANEEDS_SKIP_LIGHTING       0x0080
#endif

/*
** NOTE: may need to change the raster pos handler if more bits are added
** to the above constants
*/

/************************************************************************/

/*
** Total number of clipping planes supported by this gl.  This includes
** the frustum's six clipping planes.
*/
/*#define	__GL_TOTAL_CLIP_PLANES	(6 + __GL_NUMBER_OF_CLIP_PLANES)*/

#ifndef NT
/*
** Number of static verticies in the context.  Polygon's larger than
** this number will be decomposed.
*/
#define __GL_NVBUF 100
#endif

#define NEW_PARTIAL_PRIM // New processing of partial primitives

#ifdef NEW_PARTIAL_PRIM

// Structure to save shared vertices of partial primitives
//
typedef struct _SAVEREGION
{
    POLYDATA        pd;
    __GLmatChange   front, back;
} SAVEREGION;

#endif // NEW_PARTIAL_PRIM

/*
** State for managing the vertex machinery.
*/
typedef struct __GLvertexMachineRec {
#ifdef NT
    /*
    ** Saved vertices of a decomposed polygon.
    */
#ifdef NEW_PARTIAL_PRIM
    SAVEREGION regSaved;        // Saved data for partial line loop
#else
    POLYDATA pdSaved[3];
#endif // NEW_PARTIAL_PRIM

    /*
    ** The polyarray vertex buffer.  The last vertex is reserved by the
    ** polyarray code.
    ** Note that pdBuf has (pdBufSize + 1) entries.  Only pdBufSize
    ** entries are available for use.  The last entry is reserved by
    ** polyarray code.
    */
    POLYDATA *pdBuf;
    GLuint   pdBufSize;
    GLuint   pdBufSizeBytes;
#else
    /*
    ** Vertex pointers. v0 always points to the next slot in vbuf to
    ** be filled in when a new vertex arrives.  v1, v2 and v3 are
    ** used by the per-primitive vertex handlers.
    */
    __GLvertex *v0;
    __GLvertex *v1;
    __GLvertex *v2;
    __GLvertex *v3;
    __GLvertex vbuf[__GL_NVBUF];
#endif

    /*
    ** Provoking vertex.  For flat shaded primitives the triangle
    ** renderer needs to know which vertex provoked the primitive to
    ** properly assign the color during scan conversion.  This is kept
    ** around as its a big pain to remember which vertex was provoking
    ** during clipping (and to keep its parameters right).
    */
    __GLvertex *provoking;

#ifdef NT
    /*
    ** Poly array needs
    */
    GLuint paNeeds;
#else
    /*
    ** needs is a bit field that keeps track of what kind of information
    ** is needed in the verticies.  See the vertex->has bits define for
    ** the definition of the bits used here.
    **
    ** frontNeeds is what the front faces need, and backNeeds is what
    ** the back faces need.
    */
    GLuint needs;

    /*
    ** frontNeeds and backNeeds are the needs
    */
    GLuint faceNeeds[2];

    /*
    ** materialNeeds is a bit field indicating what kind of information is
    ** needed in the vertices if the material is going to change.
    */
    GLuint materialNeeds;
#endif
} __GLvertexMachine;

/************************************************************************/

void APIPRIVATE __glim_NoXFVertex2fv(const GLfloat v[2]);
void APIPRIVATE __glim_NoXFVertex3fv(const GLfloat v[3]);
void APIPRIVATE __glim_NoXFVertex4fv(const GLfloat v[4]);

#endif /* __glvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\zippy.h ===
/******************************Module*Header*******************************\
* Module Name: zippy.h
*
* included by zippy.c
*
* 28-Oct-1994 mikeke    Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

void FASTCALL
#if ZBUFFER
    __ZippyFSTZ
#else
    #if TEXTURE
        #if SHADE
            __ZippyFSTRGBTex
        #else
            __ZippyFSTTex
        #endif
    #else
        #if SHADE
            __ZippyFSTRGB
        #else
            __ZippyFSTCI
        #endif
    #endif
#endif

(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    int scansize;

    //
    // this function assumes all this stuff
    //
    ASSERTOPENGL((gc->drawBuffer->buf.flags & DIB_FORMAT) != 0,
		 "Zippy target must have DIB format\n");
    ASSERTOPENGL((gc->drawBuffer->buf.flags & NO_CLIP) != 0,
                 "Zippy doesn't support per-pixel clipping\n");
    ASSERTOPENGL(gc->state.raster.drawBuffer != GL_FRONT_AND_BACK,
                 "Zippy only handles one draw buffer\n");
    ASSERTOPENGL(gc->transform.reasonableViewport,
                 "Zippy requires reasonableViewport\n");
    ASSERTOPENGL(gc->transform.clipY0 <= iyBottom,
                 "Zippy requires unclipped area\n");
    ASSERTOPENGL(iyTop <= gc->transform.clipY1,
                 "Zippy requires unclipped area\n");

    //
    // setup zbuffer
    //

    #if (ZBUFFER)
        if( gc->modes.depthBits == 32 ) {
            gc->polygon.shader.zbuf = (__GLzValue *)
                ((GLubyte *)gc->polygon.shader.zbuf+
                 (gc->polygon.shader.ixLeft << 2));
        } else {
            gc->polygon.shader.zbuf = (__GLzValue *)
                ((GLubyte *)gc->polygon.shader.zbuf+
                 (gc->polygon.shader.ixLeft << 1));
        }
    #endif

    //
    // render the spans
    //

    scansize = gc->polygon.shader.cfb->buf.outerWidth;
    gc->polygon.shader.frag.x = gc->polygon.shader.ixLeft;

    for (gc->polygon.shader.frag.y = iyBottom; 
	 gc->polygon.shader.frag.y != iyTop;) {

	GLint spanWidth = gc->polygon.shader.ixRight - gc->polygon.shader.frag.x;

	if (spanWidth > 0) {
            gc->polygon.shader.length = spanWidth;

            (GENACCEL(gc).__fastSpanFuncPtr)((__GLGENcontext *)gc);
	}

        if ((++gc->polygon.shader.frag.y == iyTop) && 
            (gc->polygon.shader.modeFlags & __GL_SHADE_LAST_SUBTRI))
            return;

        GENACCEL(gc).pPix += scansize;

	gc->polygon.shader.ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (gc->polygon.shader.ixRightFrac < 0) {
	    /*
             * Carry/Borrow'd. Use large step
             */
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightBig;
	    gc->polygon.shader.ixRightFrac &= ~0x80000000;
	} else {
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightLittle;
	}

	gc->polygon.shader.ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (gc->polygon.shader.ixLeftFrac < 0) {
	    /*
             * Carry/Borrow'd.  Use large step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftBig;
	    gc->polygon.shader.ixLeftFrac &= ~0x80000000;

            #if SHADE
		GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rBig);
		GENACCEL(gc).spanValue.g += *((GLint *)&gc->polygon.shader.gBig);
		GENACCEL(gc).spanValue.b += *((GLint *)&gc->polygon.shader.bBig);
            #endif
            #if TEXTURE
                #if SHADE
    		GENACCEL(gc).spanValue.a += *((GLint *)&gc->polygon.shader.aBig);
                #endif
	        GENACCEL(gc).spanValue.s += *((GLint *)&gc->polygon.shader.sBig);
	        GENACCEL(gc).spanValue.t += *((GLint *)&gc->polygon.shader.tBig);
	        gc->polygon.shader.frag.qw += gc->polygon.shader.qwBig;
            #endif
            #if !(SHADE) && !(TEXTURE)
		GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rBig);
            #endif
            #if ZBUFFER
		gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
		gc->polygon.shader.zbuf =
                    (__GLzValue*)((GLubyte*)gc->polygon.shader.zbuf +
                    gc->polygon.shader.zbufBig);
            #endif
	} else {
	    /*
             * Use small step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftLittle;

            #if SHADE
		GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rLittle);
		GENACCEL(gc).spanValue.g += *((GLint *)&gc->polygon.shader.gLittle);
		GENACCEL(gc).spanValue.b += *((GLint *)&gc->polygon.shader.bLittle);
            #endif
            #if TEXTURE
                #if SHADE
    		GENACCEL(gc).spanValue.a += *((GLint *)&gc->polygon.shader.aLittle);
                #endif
		GENACCEL(gc).spanValue.s += *((GLint *)&gc->polygon.shader.sLittle);
		GENACCEL(gc).spanValue.t += *((GLint *)&gc->polygon.shader.tLittle);
	        gc->polygon.shader.frag.qw += gc->polygon.shader.qwLittle;
            #endif
            #if !(SHADE) && !(TEXTURE)
	        GENACCEL(gc).spanValue.r += *((GLint *)&gc->polygon.shader.rLittle);
            #endif
            #if ZBUFFER
		gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
		gc->polygon.shader.zbuf =
                    (__GLzValue*)((GLubyte*)gc->polygon.shader.zbuf +
		    gc->polygon.shader.zbufLittle);
            #endif
	}
    }

    gc->polygon.shader.ixLeft = gc->polygon.shader.frag.x;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_fast.c ===
/******************************Module*Header*******************************\
* Module Name: px_fast.c                                                   *
*                                                                          *
* Fast special case code for the pixel routines                            *
*                                                                          *
* Created: 10-Oct-1995                                                     *
* Author: Drew Bliss [drewb]                                               *
*                                                                          *
* Copyright (c) 1995 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <gencx.h>
#include <devlock.h>

#include "px_fast.h"

#ifdef NT

// Color rescaling table for [0,255] -> [0,7]
// Generated by (i*14+255)/510, which matches the OpenGL conversion of
// i*7.0/255.0+0.5
static GLubyte ab255to7[256] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};

// Similar table for [0,255] -> [0,3]
static GLubyte ab255to3[256] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

// Color rescaling table for [0,7] -> [0,255]
// Computed as i*255/7
static GLubyte ab7to255[8] =
{
    0, 36, 72, 109, 145, 182, 218, 255
};

// Similar table for [0,3] -> [0,255]
static GLubyte ab3to255[4] =
{
    0, 85, 170, 255
};

/******************************Public*Routine******************************\
*
* DrawRgbPixels
*
* Special case of glDrawPixels for GL_RGB with straight data copy
*
* History:
*  Tue Oct 10 18:43:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean DrawRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;
    __GLcolorBuffer *cfb;
    BYTE abBitmapInfo[sizeof(BITMAPINFO)+2*sizeof(RGBQUAD)];
    BITMAPINFO *pbmi = NULL;
    BITMAPINFOHEADER *pbmih;
    BYTE *pbBits, *pbSrc, *pbDst;
    int x, y, xDst, yDst;
    GLboolean bFail = GL_TRUE;
    int cbSrcLine, cbSrcExtra, cbDstExtra, cbSrcElement, cbDstElement;
    int cbSrcWidth, cbDstWidth;
    int cBits;
    __GLGENcontext *gengc;
    HPALETTE hpal;

#if 0
    DbgPrint("DrawRgbPixels\n");
#endif

    gengc = (__GLGENcontext *)gc;
    cBits = gengc->gsurf.pfd.cColorBits;
    
    // Don't bother with 4bpp because of problems with color reduction
    // The same problems occur in 8bpp but there is special case code
    // to handle it.
    if (cBits < 8)
    {
        return GL_FALSE;
    }

    // If there is no lock, we must have failed to reacquire the lock
    // from some previous call.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("DrawRgbPixels: No lock\n");
	return GL_FALSE;
    }

    // We need to synchronize with GDI so that the surface state is
    // stable before we begin making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);

    cfb = gc->drawBuffer;

    // Determine buffer coordinates
    xDst = __GL_UNBIAS_X(gc, spanInfo->startCol);
    yDst = __GL_UNBIAS_Y(gc, spanInfo->startRow)-spanInfo->height+1;

    if (cBits == 8)
    {
        pbmi = (BITMAPINFO *)gcTempAlloc(gc, sizeof(BITMAPINFO)+
                                         255*sizeof(RGBQUAD));
        if (pbmi == NULL)
        {
            goto EH_Fail;
        }
    }
    else
    {
        pbmi = (BITMAPINFO *)abBitmapInfo;
    }
        
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    // Start out setting the width to the line length to describe
    // the actual data coming in
    pbmih->biWidth = spanInfo->srcLineLength;
    pbmih->biHeight = spanInfo->height;
    pbmih->biPlanes = 1;
    
    if (cBits == 8)
    {
        int i;
        RGBQUAD rqTmp;
        
        // If the destination is 8bpp then we do the color
        // reduction ourselves.  In this case we want to create
        // an 8bpp DIB whose color table matches the destination
        pbmih->biBitCount = 8;
        pbmih->biCompression = BI_RGB;

        hpal = GetCurrentObject(CURRENT_DC, OBJ_PAL);
        if (hpal == NULL)
        {
            goto EH_Fail;
        }

        if (GetPaletteEntries(hpal, 0, 256,
                              (LPPALETTEENTRY)pbmi->bmiColors) != 256)
        {
            goto EH_Fail;
        }

        for (i = 0; i < 256; i++)
        {
            rqTmp = pbmi->bmiColors[i];
            pbmi->bmiColors[i].rgbRed = rqTmp.rgbBlue;
            pbmi->bmiColors[i].rgbBlue = rqTmp.rgbRed;
            pbmi->bmiColors[i].rgbReserved = 0;
        }

        cbDstElement = 1;
    }
    else
    {
        if (spanInfo->srcFormat == GL_BGRA_EXT)
        {
            pbmih->biBitCount = 32;
            pbmih->biCompression = BI_BITFIELDS;
            *((DWORD *)pbmi->bmiColors+0) = 0xff0000;
            *((DWORD *)pbmi->bmiColors+1) = 0xff00;
            *((DWORD *)pbmi->bmiColors+2) = 0xff;
            cbDstElement = 4;
        }
        else
        {
            pbmih->biBitCount = 24;
            pbmih->biCompression = BI_RGB;
            cbDstElement = 3;
        }
    }
    
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;
    
    // For GL_BGR_EXT and GL_BGRA_EXT we can use the data directly if
    // it is laid out in memory like a DIB.  The key thing to check
    // is that scanlines are DWORD aligned.
    // If we can't use the data directly, fall back on the DIB section
    // method which works for anything
    if (cBits > 8 &&
        (spanInfo->srcFormat == GL_BGR_EXT ||
         spanInfo->srcFormat == GL_BGRA_EXT) &&
        spanInfo->srcAlignment == 4)
    {
        if (SetDIBitsToDevice(CURRENT_DC, xDst, yDst,
                              spanInfo->width, spanInfo->height,
                              spanInfo->srcSkipPixels, spanInfo->srcSkipLines,
                              0, spanInfo->height, spanInfo->srcImage,
                              pbmi, DIB_RGB_COLORS) == 0)
        {
            goto EH_Fail;
        }
        
        bFail = GL_FALSE;
        goto EH_Fail;
    }

    // Create a DIB section of the appropriate height and width
    // We originally set the BITMAPINFO width to the width of the
    // incoming data, but we only need to create a DIB section
    // as large as the data we're going to copy so reset the
    // width
    pbmih->biWidth = spanInfo->width;

    hdc = CreateCompatibleDC(CURRENT_DC);
    if (hdc == NULL)
    {
        goto EH_Fail;
    }

    hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS,
                           &pbBits, NULL, 0);
    if (hbm == NULL)
    {
        goto EH_Fail;
    }

    if (SelectObject(hdc, hbm) == NULL)
    {
        goto EH_Fail;
    }

    // Copy the input data to the DIB's contents, possibly swapping R and B,
    // plus skipping any appropriate data, fixing up alignment and
    // obeying the line length

    if (spanInfo->srcFormat == GL_BGRA_EXT)
    {
        cbSrcElement = 4;
    }
    else
    {
        cbSrcElement = 3;
    }
    
    cbSrcLine = spanInfo->srcLineLength*cbSrcElement;
    cbSrcExtra = cbSrcLine % spanInfo->srcAlignment;
    if (cbSrcExtra != 0)
    {
        cbSrcExtra = spanInfo->srcAlignment-cbSrcExtra;
        cbSrcLine += cbSrcExtra;
    }
    cbSrcWidth = spanInfo->width * cbSrcElement;
    cbSrcExtra = cbSrcLine - cbSrcWidth;

    cbDstWidth = spanInfo->width * cbDstElement;
    cbDstExtra = cbDstWidth & 3;
    if (cbDstExtra != 0)
    {
        cbDstExtra = 4-cbDstExtra;
    }
    
    pbSrc = (BYTE *)spanInfo->srcImage+
        spanInfo->srcSkipPixels*cbSrcElement+
        spanInfo->srcSkipLines*cbSrcLine;
    pbDst = pbBits;

    if (cBits == 8)
    {
        // For 8bpp destinations we need to perform the color reduction
        // ourselves because GDI's reduction doesn't match OpenGL's.
        // GDI does a closest-match-in-palette for each pixel, while
        // OpenGL does a rescaling of the color range plus rounding
        
        switch(spanInfo->srcFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ =
                        (ab255to3[*(pbSrc+2)] << cfb->blueShift) |
                        (ab255to7[*(pbSrc+1)] << cfb->greenShift) |
                        (ab255to7[*(pbSrc+0)] << cfb->redShift);
                    pbSrc += 3;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
        case GL_BGRA_EXT:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ =
                        (ab255to3[*(pbSrc+0)] << cfb->blueShift) |
                        (ab255to7[*(pbSrc+1)] << cfb->greenShift) |
                        (ab255to7[*(pbSrc+2)] << cfb->redShift);
                    pbSrc += cbSrcElement;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
        }
    }
    else
    {
        switch(spanInfo->srcFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ = *(pbSrc+2);
                    *pbDst++ = *(pbSrc+1);
                    *pbDst++ = *pbSrc;
                    pbSrc += 3;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
        case GL_BGRA_EXT:
            if (cbSrcExtra == 0 && cbDstExtra == 0)
            {
                CopyMemory(pbDst, pbSrc, cbSrcWidth*spanInfo->height);
            }
            else
            {
                cbDstWidth += cbDstExtra;
                for (y = 0; y < spanInfo->height; y++)
                {
                    CopyMemory(pbDst, pbSrc, cbSrcWidth);
                    pbSrc += cbSrcLine;
                    pbDst += cbDstWidth;
                }
            }
            break;
        }
    }

    // Copy the DIB to the buffer
    bFail = !BitBlt(CURRENT_DC, xDst, yDst, spanInfo->width, spanInfo->height,
                    hdc, 0, 0, SRCCOPY);

 EH_Fail:
    if (hdc != NULL)
    {
        DeleteDC(hdc);
    }
    if (hbm != NULL)
    {
        DeleteObject(hbm);
    }
    if (pbmi != NULL && pbmi != (BITMAPINFO *)abBitmapInfo)
    {
        gcTempFree(gc, pbmi);
    }

    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);
    
    return !bFail;
}

/******************************Public*Routine******************************\
*
* StoreZPixels
*
* Special case of glDrawPixels for GL_DEPTH_COMPONENTs going directly
* into the Z buffer with no color buffer modification.
*
* History:
*  Tue Oct 10 18:43:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean StoreZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLdepthBuffer *fb;
    BYTE *pbBits, *pbSrc, *pbDst;
    int x, y;
    int cbElement, cbSrcLine, cbSrcExtra, cbDstExtra;

#if 0
    DbgPrint("StoreZPixels\n");
#endif
    
    fb = &gc->depthBuffer;
    
    // Copy the input data to the depth buffer,
    // skipping any appropriate data, fixing up alignment and
    // obeying the line length

    switch(spanInfo->srcType)
    {
    case GL_UNSIGNED_SHORT:
        cbElement = 2;
        break;
    case GL_UNSIGNED_INT:
        cbElement = 4;
        break;
        
    default:
        ASSERTOPENGL(0, "StoreZPixels: Unknown srcType\n");
        break;
    }
    
    cbSrcLine = spanInfo->srcLineLength*cbElement;
    cbSrcExtra = cbSrcLine % spanInfo->srcAlignment;
    if (cbSrcExtra != 0)
    {
        cbSrcExtra = spanInfo->srcAlignment-cbSrcExtra;
        cbSrcLine += cbSrcExtra;
    }

    pbSrc = (BYTE *)spanInfo->srcImage+
        spanInfo->srcSkipPixels*cbElement+
        spanInfo->srcSkipLines*cbSrcLine;
    
    // Determine buffer coordinates
    x = spanInfo->startCol;
    y = spanInfo->startRow;

    if (fb->buf.elementSize == sizeof(__GLzValue))
    {
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
        cbDstExtra = -(fb->buf.outerWidth+spanInfo->width)*sizeof(__GLzValue);
    }
    else
    {
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
        cbDstExtra = -(fb->buf.outerWidth+spanInfo->width)*
            sizeof(__GLz16Value);
    }

    switch(spanInfo->srcType)
    {
    case GL_UNSIGNED_SHORT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLzValue *)pbDst =
                        (__GLzValue)(*(GLushort *)pbSrc) << (Z16_SHIFT-1);
                    pbDst += sizeof(__GLzValue);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLz16Value *)pbDst =
                        (*(GLushort *)pbSrc) >> 1;
                    pbDst += sizeof(__GLz16Value);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;

    case GL_UNSIGNED_INT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLzValue *)pbDst =
                        (*(GLuint *)pbSrc) >> 1;
                    pbDst += sizeof(__GLzValue);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(__GLz16Value *)pbDst =
                        (__GLz16Value)((*(GLuint *)pbSrc) >> (Z16_SHIFT+1));
                    pbDst += sizeof(__GLz16Value);
                    pbSrc += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* ReadRgbPixels
*
* Special case of glReadPixels for GL_RGB with straight data copy
*
* History:
*  Tue Oct 10 18:43:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean ReadRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;
    __GLcolorBuffer *cfb;
    BYTE abBitmapInfo[sizeof(BITMAPINFO)+2*sizeof(RGBQUAD)];
    BITMAPINFO *pbmi = NULL;
    BITMAPINFOHEADER *pbmih;
    BYTE *pbBits, *pbDst, *pbSrc;
    DWORD *pdwDst;
    int x, y;
    GLboolean bFail = GL_TRUE;
    int cbDstLine, cbDstExtra, cbSrcExtra, cbSrcElement, cbDstElement;
    int cbSrcWidth, cbDstWidth;
    int cBits;
    HPALETTE hpal;
    __GLGENcontext *gengc;

#if 0
    DbgPrint("ReadRgbPixels\n");
#endif

    gengc = (__GLGENcontext *)gc;
    cBits = gengc->gsurf.pfd.cColorBits;
    
    // Don't bother with 4bpp surfaces
    if (cBits < 8)
    {
        return GL_FALSE;
    }

    // If there is no lock, we must have failed to reacquire the lock
    // from some previous call.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("ReadRgbPixels: No lock\n");
	return GL_FALSE;
    }

    // We need to synchronize with GDI so that the surface state is
    // stable before we begin making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);

    cfb = gc->readBuffer;

    if (cBits == 8)
    {
        pbmi = (BITMAPINFO *)gcTempAlloc(gc, sizeof(BITMAPINFO)+
                                         255*sizeof(RGBQUAD));
        if (pbmi == NULL)
        {
            goto EH_Fail;
        }
    }
    else
    {
        pbmi = (BITMAPINFO *)abBitmapInfo;
    }
    
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    // Start out setting the width to the line length to describe
    // the actual data coming in
    pbmih->biWidth = spanInfo->width;
    pbmih->biHeight = spanInfo->height;
    pbmih->biPlanes = 1;
    
    if (cBits == 8)
    {
        int i;
        RGBQUAD rqTmp;
        
        // If the destination is 8bpp then we do the color
        // expansion ourselves.  In this case we want to create
        // an 8bpp DIB whose color table matches the source
        pbmih->biBitCount = 8;
        pbmih->biCompression = BI_RGB;

        hpal = GetCurrentObject(CURRENT_DC, OBJ_PAL);
        if (hpal == NULL)
        {
            goto EH_Fail;
        }

        if (GetPaletteEntries(hpal, 0, 256,
                              (LPPALETTEENTRY)pbmi->bmiColors) != 256)
        {
            goto EH_Fail;
        }

        for (i = 0; i < 256; i++)
        {
            rqTmp = pbmi->bmiColors[i];
            pbmi->bmiColors[i].rgbRed = rqTmp.rgbBlue;
            pbmi->bmiColors[i].rgbBlue = rqTmp.rgbRed;
            pbmi->bmiColors[i].rgbReserved = 0;
        }

        cbSrcElement = 1;
    }
    else
    {
        if (spanInfo->dstFormat == GL_BGRA_EXT)
        {
            pbmih->biBitCount = 32;
            pbmih->biCompression = BI_BITFIELDS;
            *((DWORD *)pbmi->bmiColors+0) = 0xff0000;
            *((DWORD *)pbmi->bmiColors+1) = 0xff00;
            *((DWORD *)pbmi->bmiColors+2) = 0xff;
            cbSrcElement = 4;
        }
        else
        {
            pbmih->biBitCount = 24;
            pbmih->biCompression = BI_RGB;
            cbSrcElement = 3;
        }
    }
    
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;

    // Create a DIB section of the appropriate height and width
    // We originally set the BITMAPINFO width to the width of the
    // incoming data, but we only need to create a DIB section
    // as large as the data we're going to copy so reset the
    // width
    pbmih->biWidth = spanInfo->width;

    hdc = CreateCompatibleDC(CURRENT_DC);
    if (hdc == NULL)
    {
        goto EH_Fail;
    }

    hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS,
                           &pbBits, NULL, 0);
    if (hbm == NULL)
    {
        goto EH_Fail;
    }

    if (SelectObject(hdc, hbm) == NULL)
    {
        goto EH_Fail;
    }

    if (cBits <= 8)
    {
        hpal = GetCurrentObject(CURRENT_DC, OBJ_PAL);
        if (hpal != NULL)
        {
            if (SelectPalette(hdc, hpal, FALSE) == NULL)
            {
                goto EH_Fail;
            }

            if (RealizePalette(hdc) == GDI_ERROR)
            {
                goto EH_Fail;
            }
        }
    }
    
    // Determine buffer coordinates
    x = __GL_UNBIAS_X(gc, (GLint)spanInfo->readX);
    y = __GL_UNBIAS_Y(gc, (GLint)spanInfo->readY)-spanInfo->height+1;

    // Copy the buffer's contents to the DIB
    if (!BitBlt(hdc, 0, 0, spanInfo->width, spanInfo->height,
                CURRENT_DC, x, y, SRCCOPY))
    {
        goto EH_Fail;
    }
    
    GdiFlush();

    // Copy the DIB's contents to the output buffer, swapping R and B,
    // plus skipping any appropriate data, fixing up alignment and
    // obeying the line length

    if (spanInfo->dstFormat == GL_BGRA_EXT)
    {
        cbDstElement = 4;
    }
    else
    {
        cbDstElement = 3;
    }
    
    cbDstLine = spanInfo->dstLineLength*cbDstElement;
    cbDstExtra = cbDstLine % spanInfo->dstAlignment;
    if (cbDstExtra != 0)
    {
        cbDstExtra = spanInfo->dstAlignment-cbDstExtra;
        cbDstLine += cbDstExtra;
    }
    cbDstWidth = spanInfo->width * cbDstElement;
    cbDstExtra = cbDstLine - cbDstWidth;

    cbSrcWidth = spanInfo->width * cbSrcElement;
    cbSrcExtra = cbSrcWidth & 3;
    if (cbSrcExtra != 0)
    {
        cbSrcExtra = 4-cbSrcExtra;
    }

    pbSrc = pbBits;
    pbDst = (BYTE *)spanInfo->dstImage+
        spanInfo->dstSkipPixels*cbDstElement+
        spanInfo->dstSkipLines*cbDstLine;

    if (cBits == 8)
    {
        BYTE b;
        
        // For 8bpp sources we need to do the color expansion ourselves
        // because the 8bpp palette is only an approximation of a 3-3-2
        // palette since the system colors are forced into it.  Also,
        // GL does a rescaling of the color range.
        
        switch(spanInfo->dstFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    b = *pbSrc++;

                    *pbDst++ =
                        ab7to255[(b & gc->modes.redMask) >> cfb->redShift];
                    *pbDst++ =
                        ab7to255[(b & gc->modes.greenMask) >> cfb->greenShift];
                    *pbDst++ =
                        ab3to255[(b & gc->modes.blueMask) >> cfb->blueShift];
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    b = *pbSrc++;

                    *pbDst++ =
                        ab3to255[(b & gc->modes.blueMask) >> cfb->blueShift];
                    *pbDst++ =
                        ab7to255[(b & gc->modes.greenMask) >> cfb->greenShift];
                    *pbDst++ =
                        ab7to255[(b & gc->modes.redMask) >> cfb->redShift];
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGRA_EXT:
            pdwDst = (DWORD *)pbDst;
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    b = *pbSrc++;

                    *pdwDst++ =
                        0xff000000 |
                        ((DWORD)ab7to255[(b & gc->modes.redMask) >>
                                         cfb->redShift] << 16) |
                        ((DWORD)ab7to255[(b & gc->modes.greenMask) >>
                                         cfb->greenShift] << 8) |
                        ((DWORD)ab3to255[(b & gc->modes.blueMask) >>
                                         cfb->blueShift]);
                }
                
                pbSrc += cbSrcExtra;
                pdwDst = (DWORD *)(((BYTE *)pdwDst) + cbDstExtra);
            }
            break;
        }
    }
    else
    {
        switch(spanInfo->dstFormat)
        {
        case GL_RGB:
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *pbDst++ = *(pbSrc+2);
                    *pbDst++ = *(pbSrc+1);
                    *pbDst++ = *pbSrc;
                    pbSrc += 3;
                }
                
                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
            break;
            
        case GL_BGR_EXT:
            if (cbSrcExtra == 0 && cbDstExtra == 0)
            {
                CopyMemory(pbDst, pbSrc, cbDstWidth*spanInfo->height);
            }
            else
            {
                cbSrcWidth += cbSrcExtra;
                for (y = 0; y < spanInfo->height; y++)
                {
                    CopyMemory(pbDst, pbSrc, cbDstWidth);
                    pbSrc += cbSrcWidth;
                    pbDst += cbDstLine;
                }
            }
            break;

        case GL_BGRA_EXT:
            {
                DWORD *pdwSrc = (DWORD *)pbSrc;

                pdwDst = (DWORD *)pbDst;

                for (y = 0; y < spanInfo->height; y++)
                {
                    for (x = 0; x < spanInfo->width; x++)
                    {
                        *pdwDst++ = 0xff000000 | (*pdwSrc++);
                    }

                    pdwSrc = (DWORD *)(((BYTE *)pdwSrc) + cbSrcExtra);
                    pdwDst = (DWORD *)(((BYTE *)pdwDst) + cbDstExtra);
                }
            }
        }
    }
    
    bFail = GL_FALSE;

 EH_Fail:
    if (hdc != NULL)
    {
        DeleteDC(hdc);
    }
    if (hbm != NULL)
    {
        DeleteObject(hbm);
    }
    if (pbmi != NULL && pbmi != (BITMAPINFO *)abBitmapInfo)
    {
        gcTempFree(gc, pbmi);
    }

    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);
    
    return !bFail;
}

/******************************Public*Routine******************************\
*
* ReadZPixels
*
* Special case of glReadPixels for GL_DEPTH_COMPONENTs with
* unsigned types that require minimal transformation
*
* History:
*  Tue Oct 10 18:43:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean ReadZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLdepthBuffer *fb;
    BYTE *pbBits, *pbSrc, *pbDst;
    int x, y;
    int cbElement, cbDstLine, cbSrcExtra, cbDstExtra;

#if 0
    DbgPrint("ReadZPixels\n");
#endif
    
    fb = &gc->depthBuffer;
    
    // Copy the depth buffer data to the output
    // skipping any appropriate data, fixing up alignment and
    // obeying the line length

    switch(spanInfo->dstType)
    {
    case GL_UNSIGNED_SHORT:
        cbElement = 2;
        break;
    case GL_UNSIGNED_INT:
        cbElement = 4;
        break;
        
    default:
        ASSERTOPENGL(0, "ReadZPixels: Unknown dstType\n");
        break;
    }
    
    cbDstLine = spanInfo->dstLineLength*cbElement;
    cbDstExtra = cbDstLine % spanInfo->dstAlignment;
    if (cbDstExtra != 0)
    {
        cbDstExtra = spanInfo->dstAlignment-cbDstExtra;
        cbDstLine += cbDstExtra;
    }

    pbDst = (BYTE *)spanInfo->dstImage+
        spanInfo->dstSkipPixels*cbElement+
        spanInfo->dstSkipLines*cbDstLine;
    
    // Determine buffer coordinates
    x = (GLint)spanInfo->readX;
    y = (GLint)spanInfo->readY;

    if (fb->buf.elementSize == sizeof(__GLzValue))
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
        cbSrcExtra = -(fb->buf.outerWidth+spanInfo->width)*sizeof(__GLzValue);
    }
    else
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
        cbSrcExtra = -(fb->buf.outerWidth+spanInfo->width)*
            sizeof(__GLz16Value);
    }

    switch(spanInfo->dstType)
    {
    case GL_UNSIGNED_SHORT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLushort *)pbDst =
                        (GLushort)(*(__GLzValue *)pbSrc) >> (Z16_SHIFT-1);
                    pbSrc += sizeof(__GLzValue);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLushort *)pbDst =
                        (*(__GLz16Value *)pbSrc) << 1;
                    pbSrc += sizeof(__GLz16Value);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;

    case GL_UNSIGNED_INT:
        if (fb->buf.elementSize == sizeof(__GLzValue))
        {
            ASSERTOPENGL(fb->scale == 0x7fffffff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLuint *)pbDst =
                        (*(__GLzValue *)pbSrc) << 1;
                    pbSrc += sizeof(__GLzValue);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        else
        {
            ASSERTOPENGL(fb->scale == 0x7fff,
                         "Depth buffer scale invalid\n");
            
            for (y = 0; y < spanInfo->height; y++)
            {
                for (x = 0; x < spanInfo->width; x++)
                {
                    *(GLuint *)pbDst =
                        (GLuint)((*(__GLz16Value *)pbSrc) << (Z16_SHIFT+1));
                    pbSrc += sizeof(__GLz16Value);
                    pbDst += cbElement;
                }

                pbSrc += cbSrcExtra;
                pbDst += cbDstExtra;
            }
        }
        break;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyRgbPixels
*
* Special case of glCopyPixels for straight data copy
*
* Currently we only have to deal with normal color buffers
* If we start supporting aux buffers it may no longer be possible
* to accelerate this function in all cases
*
* History:
*  Tue Oct 10 18:43:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLcolorBuffer *cfbSrc, *cfbDst;
    int xSrc, ySrc, xDst, yDst;
    GLboolean bFail;
    __GLGENcontext *gengc;

#if 0
    DbgPrint("CopyRgbPixels\n");
#endif

    gengc = (__GLGENcontext *)gc;
    
    // If there is no lock, we must have failed to reacquire the lock
    // from some previous call.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("CopyRgbPixels: No lock\n");
	return GL_FALSE;
    }

    // We need to synchronize with GDI so that the surface state is
    // stable before we begin making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);

    cfbSrc = gc->readBuffer;
    cfbDst = gc->drawBuffer;
    
    // Determine buffer coordinates
    xSrc = __GL_UNBIAS_X(gc, (GLint)spanInfo->readX);
    ySrc = __GL_UNBIAS_Y(gc, (GLint)spanInfo->readY)-spanInfo->height+1;
    xDst = __GL_UNBIAS_X(gc, (GLint)spanInfo->x);
    yDst = __GL_UNBIAS_Y(gc, (GLint)spanInfo->y)-spanInfo->height+1;

    // Copy the data between the buffers
    bFail = (GLboolean)BitBlt(CURRENT_DC_CFB(cfbDst), xDst, yDst,
                              spanInfo->width, spanInfo->height,
                              CURRENT_DC_CFB(cfbSrc), xSrc, ySrc, SRCCOPY);
    
    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked, COLOR_LOCK_FLAGS);
    
    return bFail;
}

/******************************Public*Routine******************************\
*
* CopyZPixels
*
* Special case of glCopyPixels for GL_DEPTH where there is no
* destination color buffer and the Z function is GL_ALWAYS
*
* History:
*  Tue Oct 10 18:43:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLdepthBuffer *fb;
    BYTE *pbSrc, *pbDst;
    int y, xSrc, ySrc, xDst, yDst;
    int cbLine, cbWidth;

#if 0
    DbgPrint("CopyZPixels\n");
#endif
    
    fb = &gc->depthBuffer;
    
    // Determine buffer coordinates
    xSrc = (GLint)spanInfo->readX;
    ySrc = (GLint)spanInfo->readY;
    xDst = (GLint)spanInfo->x;
    yDst = (GLint)spanInfo->y;

    if (fb->buf.elementSize == sizeof(__GLzValue))
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), xSrc, ySrc);
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLzValue*), xDst, yDst);
        cbLine = -fb->buf.outerWidth*sizeof(__GLzValue);
        cbWidth = spanInfo->width*sizeof(__GLzValue);
    }
    else
    {
        pbSrc = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), xSrc, ySrc);
        pbDst = (BYTE *)__GL_DEPTH_ADDR(fb, (__GLz16Value*), xDst, yDst);
        cbLine = -fb->buf.outerWidth*sizeof(__GLz16Value);
        cbWidth = spanInfo->width*sizeof(__GLz16Value);
    }

    if (cbLine == cbWidth)
    {
        MoveMemory(pbDst, pbSrc, cbWidth*spanInfo->height);
    }
    else
    {
        // Adjust copy direction to handle overlap cases
        if (ySrc > yDst)
        {
            pbSrc += cbLine*spanInfo->height;
            pbDst += cbLine*spanInfo->height;
            for (y = 0; y < spanInfo->height; y++)
            {
                pbSrc -= cbLine;
                pbDst -= cbLine;
                CopyMemory(pbDst, pbSrc, cbWidth);
            }
        }
        else if (ySrc < yDst)
        {
            for (y = 0; y < spanInfo->height; y++)
            {
                CopyMemory(pbDst, pbSrc, cbWidth);
                pbSrc += cbLine;
                pbDst += cbLine;
            }
        }
        else
        {
            for (y = 0; y < spanInfo->height; y++)
            {
                MoveMemory(pbDst, pbSrc, cbWidth);
                pbSrc += cbLine;
                pbDst += cbLine;
            }
        }
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyAlignedImage
*
* Copies data between memory images where straight data copy is applicable
*
* This routine doesn't handle overlap
* The old code doesn't seem to either, so perhaps this isn't a problem
*
* History:
*  Tue Nov 07 14:27:06 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyAlignedImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int cbLine;
    int y;
    GLubyte *src, *dst;

    ASSERTOPENGL(spanInfo->srcGroupIncrement == spanInfo->dstGroupIncrement,
                 "CopyAlignedImage: Group size mismatch\n");

    cbLine = spanInfo->width*spanInfo->dstGroupIncrement;
    if (spanInfo->srcRowIncrement == spanInfo->dstRowIncrement &&
        cbLine == spanInfo->srcRowIncrement)
    {
        // Source and destination rows are the same size and the copy
        // is copying all of the row so we can do everything with a
        // single copy
        CopyMemory(spanInfo->dstCurrent, spanInfo->srcCurrent,
                   cbLine*spanInfo->height);
    }
    else
    {
        // Either the rows aren't the same size or we're not copying
        // all of each row, so we have to go row by row
        src = spanInfo->srcCurrent;
        dst = spanInfo->dstCurrent;
        for (y = spanInfo->height; y > 0; y--)
        {
            CopyMemory(dst, src, cbLine);
            src += spanInfo->srcRowIncrement;
            dst += spanInfo->dstRowIncrement;
        }
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyRgbToBgraImage
*
* Special case for 24-bit RGB to 32-bit BGRA
*
* History:
*  Tue Nov 07 15:09:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyRgbToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int x, y;
    GLubyte *src;
    GLuint *dst;
    int srcStep, dstStep;

    src = spanInfo->srcCurrent;
    dst = spanInfo->dstCurrent;
    srcStep = spanInfo->srcRowIncrement-
        spanInfo->width*spanInfo->srcGroupIncrement;
    dstStep = spanInfo->dstRowIncrement-
        spanInfo->width*spanInfo->dstGroupIncrement;
    
    ASSERTOPENGL((dstStep & 3) == 0, "Non-dword step\n");
    dstStep >>= 2;
    
    for (y = spanInfo->height; y > 0; y--)
    {
        for (x = spanInfo->width; x > 0; x--)
        {
            *dst++ =
                0xff000000             |
                ((GLuint)src[0] << 16) |
                ((GLuint)src[1] <<  8) |
                ((GLuint)src[2] <<  0);
            src += 3;
        }
        src += srcStep;
        dst += dstStep;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyRgbaToBgraImage
*
* Special case for 32-bit RGBA to 32-bit BGRA
*
* History:
*  Tue Nov 07 15:09:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyRgbaToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int x, y;
    GLubyte *src;
    GLuint *dst;
    int srcStep, dstStep;

    src = spanInfo->srcCurrent;
    dst = spanInfo->dstCurrent;
    srcStep = spanInfo->srcRowIncrement-
        spanInfo->width*spanInfo->srcGroupIncrement;
    dstStep = spanInfo->dstRowIncrement-
        spanInfo->width*spanInfo->dstGroupIncrement;
    
    ASSERTOPENGL((dstStep & 3) == 0, "Non-dword step\n");
    dstStep >>= 2;
    
    for (y = spanInfo->height; y > 0; y--)
    {
        for (x = spanInfo->width; x > 0; x--)
        {
            *dst++ =
                ((GLuint)src[0] << 16) |
                ((GLuint)src[1] <<  8) |
                ((GLuint)src[2] <<  0) |
                ((GLuint)src[3] << 24);
            src += 4;
        }
        src += srcStep;
        dst += dstStep;
    }

    return GL_TRUE;
}

/******************************Public*Routine******************************\
*
* CopyBgrToBgraImage
*
* Special case for 24-bit BGR to 32-bit BGRA
*
* History:
*  Tue Nov 07 15:09:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLboolean CopyBgrToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int x, y;
    GLubyte *src;
    GLuint *dst;
    int srcStep, dstStep;

    src = spanInfo->srcCurrent;
    dst = spanInfo->dstCurrent;
    srcStep = spanInfo->srcRowIncrement-
        spanInfo->width*spanInfo->srcGroupIncrement;
    dstStep = spanInfo->dstRowIncrement-
        spanInfo->width*spanInfo->dstGroupIncrement;
    
    ASSERTOPENGL((dstStep & 3) == 0, "Non-dword step\n");
    dstStep >>= 2;
    
    for (y = spanInfo->height; y > 0; y--)
    {
        for (x = spanInfo->width; x > 0; x--)
        {
            *dst++ =
                0xff000000             |
                ((GLuint)src[0] <<  0) |
                ((GLuint)src[1] <<  8) |
                ((GLuint)src[2] << 16);
            src += 3;
        }
        src += srcStep;
        dst += dstStep;
    }

    return GL_TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_api.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "gencx.h"
#include "imfuncs.h"

/*
** Initialize pixel map with default size and value.
*/
void FASTCALL __glInitDefaultPixelMap(__GLcontext *gc, GLenum map)
{
    __GLpixelState *ps = &gc->state.pixel;
    __GLpixelMapHead *pMap = ps->pixelMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
#ifdef _MCD_
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
#endif

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        /*
        ** Allocate single-entry map for index type.
        */
        if (!(pMap[index].base.mapI = (GLint*)
              GCALLOC(gc, sizeof(GLint)))) {
            return;
        } else {
            pMap[index].base.mapI[0] = 0;
            pMap[index].size = 1;
#ifdef _MCD_
            if (gengc->pMcdState)
                GenMcdPixelMap(gengc, map, 1, (VOID *) pMap[index].base.mapI);
#endif
        }
        break;
      case GL_PIXEL_MAP_I_TO_R: case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B: case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R: case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B: case GL_PIXEL_MAP_A_TO_A:
        /*
        ** Allocate single-entry map for component type.
        */
        if (!(pMap[index].base.mapF = (__GLfloat*)
              GCALLOC(gc, sizeof(__GLfloat)))) {
            return;
        } else {
            pMap[index].base.mapF[0] = __glZero;
            pMap[index].size = 1;
#ifdef _MCD_
            if (gengc->pMcdState)
                GenMcdPixelMap(gengc, map, 1, (VOID *) pMap[index].base.mapF);
#endif
        }
        break;
    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void FASTCALL __glPixelSetColorScales(__GLcontext *gc)
{
    __GLpixelMachine *pm = &gc->pixel;
    GLfloat redScale, greenScale, blueScale, alphaScale;
    int i;
    GLint mask;

    if (pm->redMap == NULL) {
        /* First time allocation of these maps */

        /*
        ** These lookup tables are for type UNSIGNED_BYTE, so they are sized
        ** to 256 entries.  They map from UNSIGNED_BYTE to internal scaled
        ** floating point colors.
        */
#ifdef NT
        pm->redMap =
            (GLfloat*) GCALLOC(gc, 5 * 256 * sizeof(GLfloat));
        if (!pm->redMap)
            return;
        pm->greenMap = pm->redMap + 1 * 256;
        pm->blueMap  = pm->redMap + 2 * 256;
        pm->alphaMap = pm->redMap + 3 * 256;
        pm->iMap     = pm->redMap + 4 * 256;
#else
        pm->redMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->greenMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->blueMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->alphaMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
        pm->iMap =
            (GLfloat*) GCALLOC(gc, 256 * sizeof(GLfloat));
#endif
    }

    redScale = gc->frontBuffer.redScale / 255;
    greenScale = gc->frontBuffer.greenScale / 255;
    blueScale = gc->frontBuffer.blueScale / 255;
    alphaScale = gc->frontBuffer.alphaScale / 255;
    mask = gc->frontBuffer.redMax;
    for (i=0; i<256; i++) {
        pm->redMap[i] = i * redScale;
        pm->greenMap[i] = i * greenScale;
        pm->blueMap[i] = i * blueScale;
        pm->alphaMap[i] = i * alphaScale;
        pm->iMap[i] = (GLfloat) (i & mask);
    }

    /*
    ** Invalidate the RGBA modify tables so that they will be
    ** recomputed using the current color buffer scales.
    */
    pm->rgbaCurrent = GL_FALSE;
}

/************************************************************************/

void FASTCALL __glFreePixelState(__GLcontext *gc)
{
    __GLpixelState *ps = &gc->state.pixel;
    __GLpixelMapHead *pMap = ps->pixelMap;
    __GLpixelMachine *pm = &gc->pixel;
    GLenum m;
    GLint i;

    /*
    ** Free memory allocated to pixel maps.
    */
    for (m = GL_PIXEL_MAP_I_TO_I; m <= GL_PIXEL_MAP_A_TO_A; m++) {
        i = m - GL_PIXEL_MAP_I_TO_I;
        if (pMap[i].base.mapI) {
            GCFREE(gc, pMap[i].base.mapI);
            pMap[i].base.mapI = 0;
        }
    }

#ifdef NT
    // This includes red, green, blue, alpha and i maps.
    GCFREE(gc, pm->redMap);
#else
    GCFREE(gc, pm->redMap);
    GCFREE(gc, pm->greenMap);
    GCFREE(gc, pm->blueMap);
    GCFREE(gc, pm->alphaMap);
    GCFREE(gc, pm->iMap);
#endif
    if (pm->redModMap) {
#ifdef NT
        // This includes red, green, blue and alpha mod maps.
        GCFREE(gc, pm->redModMap);
#else
        GCFREE(gc, pm->redModMap);
        GCFREE(gc, pm->greenModMap);
        GCFREE(gc, pm->blueModMap);
        GCFREE(gc, pm->alphaModMap);
#endif
    }
    if (pm->iToRMap) {
#ifdef NT
        // This includes iToR, iToG, iToB and iToA maps.
        GCFREE(gc, pm->iToRMap);
#else
        GCFREE(gc, pm->iToRMap);
        GCFREE(gc, pm->iToGMap);
        GCFREE(gc, pm->iToBMap);
        GCFREE(gc, pm->iToAMap);
#endif
    }
    if (pm->iToIMap) {
        GCFREE(gc, pm->iToIMap);
    }
}

void FASTCALL __glInitPixelState(__GLcontext *gc)
{
    __GLpixelState *ps = &gc->state.pixel;
    __GLpixelMachine *pm = &gc->pixel;
    GLenum m;

    /*
    ** Initialize transfer mode.
    */
    ps->transferMode.r_scale = __glOne;
    ps->transferMode.g_scale = __glOne;
    ps->transferMode.b_scale = __glOne;
    ps->transferMode.a_scale = __glOne;
    ps->transferMode.d_scale = __glOne;
    ps->transferMode.zoomX = __glOne;
    ps->transferMode.zoomY = __glOne;

    /*
    ** Initialize pixel maps with default sizes and values.
    */
    for (m = GL_PIXEL_MAP_I_TO_I; m <= GL_PIXEL_MAP_A_TO_A; m++) {
        __glInitDefaultPixelMap(gc, m);
    }

    /*
    ** Initialize store mode.
    */
    ps->packModes.alignment = 4;
    ps->unpackModes.alignment = 4;

    /* Setup to use the correct read buffer */
    if (gc->modes.doubleBufferMode) {
        ps->readBuffer = GL_BACK;
    } else {
        ps->readBuffer = GL_FRONT;
    }
    ps->readBufferReturn = ps->readBuffer;

    /* Lookup tables used by some pixel routines */

    __glPixelSetColorScales(gc);

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/************************************************************************/

/*
** Specify modes that control the storage format of pixel arrays.
*/
void APIPRIVATE __glim_PixelStoref(GLenum mode, GLfloat value)
{
    switch (mode) {
      case GL_PACK_ROW_LENGTH:
      case GL_PACK_SKIP_ROWS:
      case GL_PACK_SKIP_PIXELS:
      case GL_PACK_ALIGNMENT:
      case GL_UNPACK_ROW_LENGTH:
      case GL_UNPACK_SKIP_ROWS:
      case GL_UNPACK_SKIP_PIXELS:
      case GL_UNPACK_ALIGNMENT:
        /* Round */
        if (value < 0) {
            __glim_PixelStorei(mode, (GLint) (value - (__GLfloat) 0.5));
        } else {
            __glim_PixelStorei(mode, (GLint) (value + (__GLfloat) 0.5));
        }
        break;
      case GL_PACK_SWAP_BYTES:
      case GL_PACK_LSB_FIRST:
      case GL_UNPACK_SWAP_BYTES:
      case GL_UNPACK_LSB_FIRST:
        if (value == __glZero) {
            __glim_PixelStorei(mode, GL_FALSE);
        } else {
            __glim_PixelStorei(mode, GL_TRUE);
        }
      default:
        __glim_PixelStorei(mode, (GLint) value);
        break;
    }
}

void APIPRIVATE __glim_PixelStorei(GLenum mode, GLint value)
{
    __GLpixelState *ps;
    __GL_SETUP_NOT_IN_BEGIN();

    ps = &gc->state.pixel;

    switch (mode) {
      case GL_PACK_ROW_LENGTH:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->packModes.lineLength == (GLuint) value) return;
        ps->packModes.lineLength = (GLuint) value;
        break;
      case GL_PACK_SKIP_ROWS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->packModes.skipLines == (GLuint) value) return;
        ps->packModes.skipLines = (GLuint) value;
        break;
      case GL_PACK_SKIP_PIXELS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->packModes.skipPixels == (GLuint) value) return;
        ps->packModes.skipPixels = (GLuint) value;
        break;
      case GL_PACK_ALIGNMENT:
        switch (value) {
          case 1: case 2: case 4: case 8:
            if (ps->packModes.alignment == (GLuint) value) return;
            ps->packModes.alignment = (GLuint) value;
            break;
          default:
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        break;
      case GL_PACK_SWAP_BYTES:
        if (ps->packModes.swapEndian == (value != 0)) return;
        ps->packModes.swapEndian = (value != 0);
        break;
      case GL_PACK_LSB_FIRST:
        if (ps->packModes.lsbFirst == (value != 0)) return;
        ps->packModes.lsbFirst = (value != 0);
        break;

      case GL_UNPACK_ROW_LENGTH:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->unpackModes.lineLength == (GLuint) value) return;
        ps->unpackModes.lineLength = (GLuint) value;
        break;
      case GL_UNPACK_SKIP_ROWS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->unpackModes.skipLines == (GLuint) value) return;
        ps->unpackModes.skipLines = (GLuint) value;
        break;
      case GL_UNPACK_SKIP_PIXELS:
        if (value < 0) {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (ps->unpackModes.skipPixels == (GLuint) value) return;
        ps->unpackModes.skipPixels = (GLuint) value;
        break;
      case GL_UNPACK_ALIGNMENT:
        switch (value) {
          case 1: case 2: case 4: case 8:
            if (ps->unpackModes.alignment == (GLuint) value) return;
            ps->unpackModes.alignment = (GLuint) value;
            break;
          default:
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        break;
      case GL_UNPACK_SWAP_BYTES:
        if (ps->unpackModes.swapEndian == (value != 0)) return;
        ps->unpackModes.swapEndian = (value != 0);
        break;
      case GL_UNPACK_LSB_FIRST:
        if (ps->unpackModes.lsbFirst == (value != 0)) return;
        ps->unpackModes.lsbFirst = (value != 0);
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/*
** Specify zoom factor that affects drawing and copying of pixel arrays
*/
void APIPRIVATE __glim_PixelZoom(GLfloat xfactor, GLfloat yfactor)
{
    __GLpixelState *ps;
    GLint xtemp, ytemp;
    __GL_SETUP_NOT_IN_BEGIN();

    ps = &gc->state.pixel;

    /* Round xfactor and yfactor to fixed point accuracy. */
    if (xfactor > 0) {
        xtemp = (GLint) ((xfactor / gc->constants.viewportEpsilon) + __glHalf);
    } else {
        xtemp = (GLint) ((xfactor / gc->constants.viewportEpsilon) - __glHalf);
    }
    if (yfactor > 0) {
        ytemp = (GLint) ((yfactor / gc->constants.viewportEpsilon) + __glHalf);
    } else {
        ytemp = (GLint) ((yfactor / gc->constants.viewportEpsilon) - __glHalf);
    }
    xfactor = xtemp * gc->constants.viewportEpsilon;
    yfactor = ytemp * gc->constants.viewportEpsilon;

    if ((ps->transferMode.zoomX == xfactor) && 
        (ps->transferMode.zoomY == yfactor)) 
        return;
    ps->transferMode.zoomX = xfactor;
    ps->transferMode.zoomY = yfactor;
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
	
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/*
** Specify modes that control the transfer of pixel arrays.
*/
void APIPRIVATE __glim_PixelTransferf(GLenum mode, GLfloat value)
{
    __GLpixelState *ps;
    __GL_SETUP_NOT_IN_BEGIN();

    ps = &gc->state.pixel;

    switch (mode) {
      case GL_RED_SCALE:
        if (ps->transferMode.r_scale == value) return;
        ps->transferMode.r_scale = value;
        break;
      case GL_GREEN_SCALE:
        if (ps->transferMode.g_scale == value) return;
        ps->transferMode.g_scale = value;
        break;
      case GL_BLUE_SCALE:
        if (ps->transferMode.b_scale == value) return;
        ps->transferMode.b_scale = value;
        break;
      case GL_ALPHA_SCALE:
        if (ps->transferMode.a_scale == value) return;
        ps->transferMode.a_scale = value;
        break;
      case GL_DEPTH_SCALE:
        if (ps->transferMode.d_scale == value) return;
        ps->transferMode.d_scale = value;
        break;
      case GL_RED_BIAS:
        if (ps->transferMode.r_bias == value) return;
        ps->transferMode.r_bias = value;
        break;
      case GL_GREEN_BIAS:
        if (ps->transferMode.g_bias == value) return;
        ps->transferMode.g_bias = value;
        break;
      case GL_BLUE_BIAS:
        if (ps->transferMode.b_bias == value) return;
        ps->transferMode.b_bias = value;
        break;
      case GL_ALPHA_BIAS:
        if (ps->transferMode.a_bias == value) return;
        ps->transferMode.a_bias = value;
        break;
      case GL_DEPTH_BIAS:
        if (ps->transferMode.d_bias == value) return;
        ps->transferMode.d_bias = value;
        break;
      case GL_INDEX_SHIFT:
      {
        GLint tmp;
        
        /* Round */
        if (value > 0) {
            tmp = (GLint) (value + __glHalf);
        } else {
            tmp = (GLint) (value - __glHalf);
        }
        if (ps->transferMode.indexShift == tmp) return;
        ps->transferMode.indexShift = tmp;
        break;
      }
      case GL_INDEX_OFFSET:
      {
        GLint tmp;
        
        /* Round */
        if (value > 0) {
            tmp = (GLint) (value - __glHalf);
        } else {
            tmp = (GLint) (value - __glHalf);
        }
        if (ps->transferMode.indexOffset == tmp) return;
        ps->transferMode.indexOffset = tmp;
        break;
      }
      case GL_MAP_COLOR:
        if (ps->transferMode.mapColor == (value != __glZero)) return;
        ps->transferMode.mapColor = (value != __glZero);
        break;
      case GL_MAP_STENCIL:
        if (ps->transferMode.mapStencil == (value != __glZero)) return;
        ps->transferMode.mapStencil = (value != __glZero);
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
    
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

void APIPRIVATE __glim_PixelTransferi( GLenum mode, GLint value)
{
    __glim_PixelTransferf(mode, (GLfloat) value);
}

/************************************************************************/

/*
** Functions to specify mapping of pixel colors and stencil values.
*/
void APIPRIVATE __glim_PixelMapfv(GLenum map, GLint mapSize,
                       const GLfloat values[])
{
    __GLpixelState *ps;
    __GLpixelMapHead *pMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
    GLfloat value;
#ifdef _MCD_
    __GLGENcontext *gengc;
#endif
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef _MCD_
    gengc = (__GLGENcontext *) gc;
#endif

    ps = &gc->state.pixel;
    pMap = ps->pixelMap;

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapI) {
            GCFREE(gc, pMap[index].base.mapI);
            pMap[index].base.mapI = 0;
        }
        pMap[index].base.mapI = (GLint*)
            GCALLOC(gc, (size_t) (mapSize * sizeof(GLint)));
        if (!pMap[index].base.mapI) {
            pMap[index].size = 0;
            return;
        }
        pMap[index].size = mapSize;
        while (--mapSize >= 0) {
            value = values[mapSize];
            if (value > 0) {            /* round! */
                pMap[index].base.mapI[mapSize] =
                    (GLint)(value + __glHalf);
            } else {
                pMap[index].base.mapI[mapSize] =
                    (GLint)(value - __glHalf);
            }
        }
#ifdef _MCD_
        if (gengc->pMcdState) {
            GenMcdPixelMap(gengc, map, mapSize,
                           (VOID *) pMap[index].base.mapI);
        }
#endif
        break;
      case GL_PIXEL_MAP_I_TO_R:
      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:
      case GL_PIXEL_MAP_I_TO_A:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
      case GL_PIXEL_MAP_R_TO_R:
      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:
      case GL_PIXEL_MAP_A_TO_A:
        if (mapSize < 0) {
            /*
            ** Maps indexed by color component must not have negative size.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapF) {
            GCFREE(gc, pMap[index].base.mapF);
            pMap[index].base.mapF = 0;
        }
        if (mapSize == 0) {
            __glInitDefaultPixelMap(gc, map);
        } else {
            pMap[index].base.mapF = (__GLfloat*)
                GCALLOC(gc,
                                      (size_t) (mapSize * sizeof(__GLfloat)));
            if (!pMap[index].base.mapF) {
                pMap[index].size = 0;
                return;
            }
            pMap[index].size = mapSize;
            while (--mapSize >= 0) {
                value = values[mapSize];
                if (value < __glZero) value = __glZero;
                else if (value > __glOne) value = __glOne;
                pMap[index].base.mapF[mapSize] = value;
            }
#ifdef _MCD_
            if (gengc->pMcdState) {
                GenMcdPixelMap(gengc, map, mapSize,
                               (VOID *) pMap[index].base.mapF);
            }
#endif
        }
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_PixelMapuiv(GLenum map, GLint mapSize,
                        const GLuint values[])
{
    __GLpixelState *ps;
    __GLpixelMapHead *pMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
#ifdef _MCD_
    __GLGENcontext *gengc;
#endif
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef _MCD_
    gengc = (__GLGENcontext *) gc;
#endif

    ps = &gc->state.pixel;
    pMap = ps->pixelMap;

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapI) {
            GCFREE(gc, pMap[index].base.mapI);
            pMap[index].base.mapI = 0;
        }
        pMap[index].base.mapI = (GLint*)
            GCALLOC(gc, (size_t) (mapSize * sizeof(GLint)));
        if (!pMap[index].base.mapI) {
            pMap[index].size = 0;
            return;
        }
        pMap[index].size = mapSize;
        while (--mapSize >= 0) {
            pMap[index].base.mapI[mapSize] = values[mapSize];
        }
#ifdef _MCD_
        if (gengc->pMcdState) {
            GenMcdPixelMap(gengc, map, mapSize,
                           (VOID *) pMap[index].base.mapI);
        }
#endif
        break;
      case GL_PIXEL_MAP_I_TO_R:
      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:
      case GL_PIXEL_MAP_I_TO_A:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
      case GL_PIXEL_MAP_R_TO_R:
      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:
      case GL_PIXEL_MAP_A_TO_A:
        if (mapSize < 0) {
            /*
            ** Maps indexed by color component must not have negative size.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapF) {
            GCFREE(gc, pMap[index].base.mapF);
            pMap[index].base.mapF = 0;
        }
        if (mapSize == 0) {
            __glInitDefaultPixelMap(gc, map);
        } else {
            pMap[index].base.mapF = (__GLfloat*)
                GCALLOC(gc, (size_t) (mapSize * sizeof(GLfloat)));
            if (!pMap[index].base.mapF) {
                pMap[index].size = 0;
                return;
            }
            pMap[index].size = mapSize;
            while (--mapSize >= 0) {
                pMap[index].base.mapF[mapSize] =
                        __GL_UI_TO_FLOAT(values[mapSize]);
            }
#ifdef _MCD_
            if (gengc->pMcdState) {
                GenMcdPixelMap(gengc, map, mapSize,
                               (VOID *) pMap[index].base.mapF);
            }
#endif
        }
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_PixelMapusv(GLenum map, GLint mapSize,
                        const GLushort values[])
{
    __GLpixelState *ps;
    __GLpixelMapHead *pMap;
    GLint index = map - GL_PIXEL_MAP_I_TO_I;
#ifdef _MCD_
    __GLGENcontext *gengc;
#endif
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef _MCD_
    gengc = (__GLGENcontext *) gc;
#endif

    ps = &gc->state.pixel;
    pMap = ps->pixelMap;

    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapI) {
            GCFREE(gc, pMap[index].base.mapI);
            pMap[index].base.mapI = 0;
        }
        pMap[index].base.mapI = (GLint*)
            GCALLOC(gc, (size_t) (mapSize * sizeof(GLint)));
        if (!pMap[index].base.mapI) {
            pMap[index].size = 0;
            return;
        }
        pMap[index].size = mapSize;
        while (--mapSize >= 0) {
            pMap[index].base.mapI[mapSize] = values[mapSize];
        }
#ifdef _MCD_
        if (gengc->pMcdState) {
            GenMcdPixelMap(gengc, map, mapSize,
                           (VOID *) pMap[index].base.mapI);
        }
#endif
        break;
      case GL_PIXEL_MAP_I_TO_R:
      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:
      case GL_PIXEL_MAP_I_TO_A:
        if (mapSize <= 0 || (mapSize & (mapSize - 1))) {
            /*
            ** Maps indexed by color or stencil index must be sized
            ** to a power of two.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
      case GL_PIXEL_MAP_R_TO_R:
      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:
      case GL_PIXEL_MAP_A_TO_A:
        if (mapSize < 0) {
            /*
            ** Maps indexed by color component must not have negative size.
            */
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        if (pMap[index].base.mapF) {
            GCFREE(gc, pMap[index].base.mapF);
            pMap[index].base.mapF = 0;
        }
        if (mapSize == 0) {
            __glInitDefaultPixelMap(gc, map);
        } else {
            pMap[index].base.mapF = (__GLfloat*)
                GCALLOC(gc, (size_t) (mapSize * sizeof(GLfloat)));
            if (!pMap[index].base.mapF) {
                pMap[index].size = 0;
                return;
            }
            pMap[index].size = mapSize;
            while (--mapSize >= 0) {
                pMap[index].base.mapF[mapSize] =
                        __GL_US_TO_FLOAT(values[mapSize]);
            }
#ifdef _MCD_
            if (gengc->pMcdState) {
                GenMcdPixelMap(gengc, map, mapSize,
                               (VOID *) pMap[index].base.mapF);
            }
#endif
        }
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

/*
** Specify buffer from which pixels are read (another transfer mode).
*/
void APIPRIVATE __glim_ReadBuffer(GLenum mode)
{
    GLint i;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_FRONT:
      case GL_LEFT:
      case GL_FRONT_LEFT:
        gc->state.pixel.readBuffer = GL_FRONT;
        break;
      case GL_BACK:
      case GL_BACK_LEFT:
        if (!gc->modes.doubleBufferMode) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        gc->state.pixel.readBuffer = GL_BACK;
        break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
        i = mode - GL_AUX0;
        if (i >= gc->modes.maxAuxBuffers) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        gc->state.pixel.readBuffer = mode;
        break;
      case GL_FRONT_RIGHT:
      case GL_BACK_RIGHT:
      case GL_RIGHT:
        __glSetError(GL_INVALID_OPERATION);
        return;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    if (gc->state.pixel.readBufferReturn == mode) return;
    gc->state.pixel.readBufferReturn = mode;
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_PIXEL);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_fast.h ===
/******************************Module*Header*******************************\
* Module Name: px_fast.h                                                   *
*                                                                          *
* Fast special case code for the pixel routines                            *
*                                                                          *
* Created: 10-Oct-1995                                                     *
* Author: Drew Bliss [drewb]                                               *
*                                                                          *
* Copyright (c) 1995 Microsoft Corporation                                 *
\**************************************************************************/

#ifndef __PX_FAST_H__
#define __PX_FAST_H__

GLboolean DrawRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean StoreZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean ReadRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean ReadZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyRgbPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyZPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyAlignedImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyRgbToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyRgbaToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
GLboolean CopyBgrToBgraImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);

#endif // __PX_FAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_modif.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains a bunch of routines that perform span modification.
** As a span of pixel data is being processed (for DrawPixels, ReadPixels
** or CopyPixels), it usually has to pass through one of these routines.
** Span modification consists of mapping colors through pixel maps provided 
** with glPixelMap*(), or scaling/biasing/shifting/offsetting colors with the
** values provided through glPixelTransfer*().
*/

/*
** Build lookup tables to perform automatic modification of RGBA when the
** type is UNSIGNED_BYTE.
*/
void FASTCALL __glBuildRGBAModifyTables(__GLcontext *gc, __GLpixelMachine *pm)
{
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    GLint rrsize, ggsize, bbsize, aasize;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLboolean mapColor;
    __GLfloat rbias, gbias, bbias, abias;
    GLint entry;
    __GLfloat rscale, gscale, bscale, ascale;
    GLint i;
    __GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;
    pm->rgbaCurrent = GL_TRUE;

    redMap = pm->redModMap;
    if (redMap == NULL) {
	/* First time allocation of these maps */
	redMap = pm->redModMap = (GLfloat*)
	    GCALLOC(gc, 4 * 256 * sizeof(GLfloat));
        if (!pm->redModMap)
            return;
	pm->greenModMap = pm->redModMap + 1 * 256;
	pm->blueModMap  = pm->redModMap + 2 * 256;
	pm->alphaModMap = pm->redModMap + 3 * 256;
    }
    greenMap = pm->greenModMap;
    blueMap = pm->blueModMap;
    alphaMap = pm->alphaModMap;

    rbias = gc->state.pixel.transferMode.r_bias;
    gbias = gc->state.pixel.transferMode.g_bias;
    bbias = gc->state.pixel.transferMode.b_bias;
    abias = gc->state.pixel.transferMode.a_bias;
    rscale = gc->state.pixel.transferMode.r_scale;
    gscale = gc->state.pixel.transferMode.g_scale;
    bscale = gc->state.pixel.transferMode.b_scale;
    ascale = gc->state.pixel.transferMode.a_scale;
    if (mapColor) {
	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    }

    for (i=0; i<256; i++) {
	alpha = red = green = blue = i / (__GLfloat) 255.0;

	red = red * rscale + rbias;
	green = green * gscale + gbias;
	blue = blue * bscale + bbias;
	alpha = alpha * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    red = rrmap->base.mapF[entry];

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    green = ggmap->base.mapF[entry];

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    blue = bbmap->base.mapF[entry];

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    alpha = aamap->base.mapF[entry];
	} else {
	    if (red > __glOne) red = __glOne;
	    else if (red < 0) red = 0;
	    if (green > __glOne) green = __glOne;
	    else if (green < 0) green = 0;
	    if (blue > __glOne) blue = __glOne;
	    else if (blue < 0) blue = 0;
	    if (alpha > __glOne) alpha = __glOne;
	    else if (alpha < 0) alpha = 0;
	}

	redMap[i] = red * gc->frontBuffer.redScale;
	greenMap[i] = green * gc->frontBuffer.greenScale;
	blueMap[i] = blue * gc->frontBuffer.blueScale;
	alphaMap[i] = alpha * gc->frontBuffer.alphaScale;
    }
}

/*
** Build lookup tables to perform automatic modification of color index to 
** color index when the type is UNSIGNED_BYTE.
*/
void FASTCALL __glBuildItoIModifyTables(__GLcontext *gc, __GLpixelMachine *pm)
{
    GLint indexOffset, indexShift;
    __GLfloat indexScale;
    __GLpixelMapHead *iimap;
    GLint iimask;
    GLboolean mapColor;
    GLfloat *indexMap;
    GLint i;
    GLint entry;
    __GLfloat index;
    GLint mask;

    mapColor = gc->state.pixel.transferMode.mapColor;
    mask = gc->frontBuffer.redMax;
    pm->iToICurrent = GL_TRUE;

    indexMap = pm->iToIMap;
    if (indexMap == NULL) {
	indexMap = pm->iToIMap = (GLfloat*)
	    GCALLOC(gc, 256 * sizeof(GLfloat));
#ifdef NT
        if (!indexMap)
            return;
#endif
    }

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }

    if (mapColor) {
	iimap = &gc->state.pixel.
	    pixelMap[__GL_PIXEL_MAP_I_TO_I];
	iimask = iimap->size - 1;
    }

    for (i=0; i<256; i++) {
	index = i * indexScale + indexOffset;

	if (mapColor) {
	    entry = (GLint) index;
	    index = iimap->base.mapI[entry & iimask];
	}

	indexMap[i] = ((GLint) index) & mask;
    }
}

/*
** Build lookup tables to perform automatic modification of color index to 
** RGBA when the type is UNSIGNED_BYTE.
*/
void FASTCALL __glBuildItoRGBAModifyTables(__GLcontext *gc, __GLpixelMachine *pm)
{
    GLint indexOffset, indexShift;
    __GLfloat indexScale;
    __GLpixelMapHead *irmap, *igmap, *ibmap, *iamap;
    GLint irmask, igmask, ibmask, iamask;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfloat index;
    GLint entry;
    GLint i;

    pm->iToRGBACurrent = GL_TRUE;

    redMap = pm->iToRMap;
    if (redMap == NULL) {
	/* First time allocation of these maps */
	redMap = pm->iToRMap =
	    (GLfloat*) GCALLOC(gc, 4 * 256 * sizeof(GLfloat));
        if (!pm->iToRMap)
            return;
	pm->iToGMap = pm->iToRMap + 1 * 256;
	pm->iToBMap = pm->iToRMap + 2 * 256;
	pm->iToAMap = pm->iToRMap + 3 * 256;
    }
    greenMap = pm->iToGMap;
    blueMap = pm->iToBMap;
    alphaMap = pm->iToAMap;

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }

    irmap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_R];
    irmask = irmap->size - 1;
    igmap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_G];
    igmask = igmap->size - 1;
    ibmap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_B];
    ibmask = ibmap->size - 1;
    iamap = 
	&gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_A];
    iamask = iamap->size - 1;

    for (i=0; i<256; i++) {
	index = i * indexScale + indexOffset;
	entry = (GLint) index;

	redMap[i] = irmap->base.mapF[entry & irmask] * 
		gc->frontBuffer.redScale;
	greenMap[i] = igmap->base.mapF[entry & igmask] *
		gc->frontBuffer.greenScale;
	blueMap[i] = ibmap->base.mapF[entry & ibmask] * 
		gc->frontBuffer.blueScale;
	alphaMap[i] = iamap->base.mapF[entry & iamask] *
		gc->frontBuffer.alphaScale;
    }
}

/*
** Modify a RGBA, FLOAT span.  On the way out, the RGBA span will have 
** been modified as needed, and also scaled by the color scaling factors.
*/
void __glSpanModifyRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat rbias, gbias, bbias, abias;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLint rrsize, ggsize, bbsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
#ifdef GL_EXT_bgra
        if (spanInfo->srcFormat == GL_RGBA)
        {
            red = *oldData++ * rscale + rbias;
            green = *oldData++ * gscale + gbias;
            blue = *oldData++ * bscale + bbias;
            alpha = *oldData++ * ascale + abias;
        }
        else
        {
            blue = *oldData++ * bscale + bbias;
            green = *oldData++ * gscale + gbias;
            red = *oldData++ * rscale + rbias;
            alpha = *oldData++ * ascale + abias;
        }
#else
	red = *oldData++ * rscale + rbias;
	green = *oldData++ * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
	alpha = *oldData++ * ascale + abias;
#endif
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}

/*
** Modify a palette index, FLOAT span. On the way out, the RGBA span will have 
** been modified as needed, and also scaled by the color scaling factors.
**
** Because the palette in the span info is a pointer to the internal palette,
** it's guaranteed to always be 32-bit BGRA
*/
#ifdef GL_EXT_paletted_texture
void __glSpanModifyPI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                      GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat rbias, gbias, bbias, abias;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLint rrsize, ggsize, bbsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;
    RGBQUAD *rgb;

    mapColor = gc->state.pixel.transferMode.mapColor;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }
    // Throw in an extra scaling of 1/255 because the palette
    // data is in ubyte format
    rscale *= __glOneOver255;
    gscale *= __glOneOver255;
    bscale *= __glOneOver255;
    ascale *= __glOneOver255;

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
        rgb = &spanInfo->srcPalette[(int)((*oldData++)*
                                          spanInfo->srcPaletteSize)];
	red = rgb->rgbRed * rscale + rbias;
	green = rgb->rgbGreen * gscale + gbias;
	blue = rgb->rgbBlue * bscale + bbias;
	alpha = rgb->rgbReserved * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}
#endif

/*
** Modify a RED, FLOAT span.  On the way out, the RED span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias;
    __GLfloat rscale;
    __GLpixelMapHead *rrmap;
    GLint rrsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    green = pm->green0Mod;
    blue = pm->blue0Mod;
    alpha = pm->alpha1Mod;
    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias *
		gc->frontBuffer.redScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData++ * rscale + rbias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;

	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    *newData++ = red;
	}

	*newData++ = green;
	*newData++ = blue;
	*newData++ = alpha;
    }
}

/*
** Modify a GREEN, FLOAT span.  On the way out, the GREEN span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat gbias;
    __GLfloat gscale;
    __GLpixelMapHead *ggmap;
    GLint ggsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    red = pm->red0Mod;
    blue = pm->blue0Mod;
    alpha = pm->alpha1Mod;
    if (mapColor) {
	gbias = gc->state.pixel.transferMode.g_bias;
	gscale = gc->state.pixel.transferMode.g_scale;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
    } else {
	gbias = gc->state.pixel.transferMode.g_bias *
		gc->frontBuffer.greenScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	green = *oldData++ * gscale + gbias;
	*newData++ = red;
	if (mapColor) {
	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;
	} else {
	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    *newData++ = green;
	}

	*newData++ = blue;
	*newData++ = alpha;
    }
}

/*
** Modify a BLUE, FLOAT span.  On the way out, the BLUE span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat bbias;
    __GLfloat bscale;
    __GLpixelMapHead *bbmap;
    GLint bbsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    red = pm->red0Mod;
    green = pm->green0Mod;
    alpha = pm->alpha1Mod;
    if (mapColor) {
	bbias = gc->state.pixel.transferMode.b_bias;
	bscale = gc->state.pixel.transferMode.b_scale;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
    } else {
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	blue = *oldData++ * bscale + bbias;
	*newData++ = red;
	*newData++ = green;
	if (mapColor) {
	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;
	} else {
	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    *newData++ = blue;
	}

	*newData++ = alpha;
    }
}

/*
** Modify an ALPHA, FLOAT span.  On the way out, the ALPHA span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat abias;
    __GLfloat ascale;
    __GLpixelMapHead *aamap;
    GLint aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);
    red = pm->red0Mod;
    green = pm->green0Mod;
    blue = pm->blue0Mod;
    if (mapColor) {
	abias = gc->state.pixel.transferMode.a_bias;
	ascale = gc->state.pixel.transferMode.a_scale;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	alpha = *oldData++ * ascale + abias;
	*newData++ = red;
	*newData++ = green;
	*newData++ = blue;
	if (mapColor) {
	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = alpha;
	}
    }
}

/*
** Modify a RGB, FLOAT span.  On the way out, the RGB span will have been
** converted into a RGBA span, modified as needed, and also scaled by the 
** color scaling factors.
*/
void __glSpanModifyRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias, gbias, bbias;
    __GLfloat rscale, gscale, bscale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap;
    GLint rrsize, ggsize, bbsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    pm = &(gc->pixel);
    mapColor = gc->state.pixel.transferMode.mapColor;

    alpha = pm->alpha1Mod;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
#ifdef GL_EXT_bgra
        if (spanInfo->srcFormat == GL_RGB)
        {
            red = *oldData++ * rscale + rbias;
            green = *oldData++ * gscale + gbias;
            blue = *oldData++ * bscale + bbias;
        }
        else
        {
            blue = *oldData++ * bscale + bbias;
            green = *oldData++ * gscale + gbias;
            red = *oldData++ * rscale + rbias;
        }
#else
	red = *oldData++ * rscale + rbias;
	green = *oldData++ * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
#endif
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	}

	*newData++ = alpha;
    }
}

/*
** Modify a LUMINANCE, FLOAT span.  On the way out, the LUMINANCE span will 
** have been converted into a RGBA span, modified as needed, and also scaled 
** by the color scaling factors.
*/
void __glSpanModifyLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias, gbias, bbias;
    __GLfloat rscale, gscale, bscale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap;
    GLint rrsize, ggsize, bbsize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    pm = &(gc->pixel);
    mapColor = gc->state.pixel.transferMode.mapColor;

    alpha = pm->alpha1Mod;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData * rscale + rbias;
	green = *oldData * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	}

	*newData++ = alpha;
    }
}

/*
** Modify a LUMINANCE_ALPHA, FLOAT span.  On the way out, the LUMINANCE_ALPHA 
** span will have been converted into a RGBA span, modified as needed, and 
** also scaled by the color scaling factors.
*/
void __glSpanModifyLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat rbias, gbias, bbias, abias;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLpixelMapHead *rrmap, *ggmap, *bbmap, *aamap;
    GLint rrsize, ggsize, bbsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	gbias = gc->state.pixel.transferMode.g_bias;
	bbias = gc->state.pixel.transferMode.b_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	gscale = gc->state.pixel.transferMode.g_scale;
	bscale = gc->state.pixel.transferMode.b_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	ggmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
	ggsize = ggmap->size;
	bbmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
	bbsize = bbmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	gbias = gc->state.pixel.transferMode.g_bias * 
		gc->frontBuffer.greenScale;
	bbias = gc->state.pixel.transferMode.b_bias *
		gc->frontBuffer.blueScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	gscale = gc->state.pixel.transferMode.g_scale *
		gc->frontBuffer.greenScale;
	bscale = gc->state.pixel.transferMode.b_scale *
		gc->frontBuffer.blueScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData * rscale + rbias;
	green = *oldData * gscale + gbias;
	blue = *oldData++ * bscale + bbias;
	alpha = *oldData++ * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    entry = green * ggsize;
	    if (entry < 0) entry = 0;
	    else if (entry > ggsize-1) entry = ggsize-1;
	    *newData++ = ggmap->base.mapF[entry] * gc->frontBuffer.greenScale;

	    entry = blue * bbsize;
	    if (entry < 0) entry = 0;
	    else if (entry > bbsize-1) entry = bbsize-1;
	    *newData++ = bbmap->base.mapF[entry] * gc->frontBuffer.blueScale;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (green > gc->frontBuffer.greenScale) {
		green = gc->frontBuffer.greenScale;
	    } else if (green < 0) green = 0;

	    if (blue > gc->frontBuffer.blueScale) {
		blue = gc->frontBuffer.blueScale;
	    } else if (blue < 0) blue = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}

/*
** Modify a RED_ALPHA, FLOAT span.  On the way out, the RED_ALPHA span will 
** have been converted into a RGBA span, modified as needed, and also scaled 
** by the color scaling factors.
**
** A RED_ALPHA span comes from a two component texture (where the spec 
** takes the first component from RED for some reason rather than the more
** typical recombination of r, g and b, as is done in ReadPixels).
*/
void __glSpanModifyRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMachine *pm;
    __GLfloat rbias, abias;
    __GLfloat rscale, ascale;
    __GLpixelMapHead *rrmap, *aamap;
    GLint rrsize, aasize;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat red, green, blue, alpha;

    mapColor = gc->state.pixel.transferMode.mapColor;

    pm = &(gc->pixel);

    green = pm->green0Mod;
    blue = pm->blue0Mod;
    if (mapColor) {
	rbias = gc->state.pixel.transferMode.r_bias;
	abias = gc->state.pixel.transferMode.a_bias;
	rscale = gc->state.pixel.transferMode.r_scale;
	ascale = gc->state.pixel.transferMode.a_scale;

	rrmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
	rrsize = rrmap->size;
	aamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
	aasize = aamap->size;
    } else {
	rbias = gc->state.pixel.transferMode.r_bias * 
		gc->frontBuffer.redScale;
	abias = gc->state.pixel.transferMode.a_bias *
		gc->frontBuffer.alphaScale;
	rscale = gc->state.pixel.transferMode.r_scale *
		gc->frontBuffer.redScale;
	ascale = gc->state.pixel.transferMode.a_scale *
		gc->frontBuffer.alphaScale;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	red = *oldData * rscale + rbias;
	alpha = *oldData++ * ascale + abias;
	if (mapColor) {
	    entry = red * rrsize;
	    if (entry < 0) entry = 0;
	    else if (entry > rrsize-1) entry = rrsize-1;
	    *newData++ = rrmap->base.mapF[entry] * gc->frontBuffer.redScale;

	    *newData++ = green;
	    *newData++ = blue;

	    entry = alpha * aasize;
	    if (entry < 0) entry = 0;
	    else if (entry > aasize-1) entry = aasize-1;
	    *newData++ = aamap->base.mapF[entry] * gc->frontBuffer.alphaScale;
	} else {
	    if (red > gc->frontBuffer.redScale) {
		red = gc->frontBuffer.redScale;
	    } else if (red < 0) red = 0;

	    if (alpha > gc->frontBuffer.alphaScale) {
		alpha = gc->frontBuffer.alphaScale;
	    } else if (alpha < 0) alpha = 0;

	    *newData++ = red;
	    *newData++ = green;
	    *newData++ = blue;
	    *newData++ = alpha;
	}
    }
}

/*
** Modify a DEPTH, FLOAT span.  On the way out, the DEPTH span will have been
** modified as needed.
*/
void __glSpanModifyDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat dbias;
    __GLfloat dscale;
    GLfloat *oldData;
    GLfloat *newData;
    GLfloat d;
    GLfloat one, zero;
    GLint i;
    GLint width;

    dbias = gc->state.pixel.transferMode.d_bias;
    dscale = gc->state.pixel.transferMode.d_scale;
    one = __glOne;
    zero = __glZero;

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	d = *oldData++ * dscale + dbias;
	if (d < zero) d = zero;
	else if (d > one) d = one;
	*newData++ = d;
    }
}

/*
** Modify a STENCIL_INDEX, FLOAT span.  On the way out, the STENCIL_INDEX span 
** will have been modified as needed.
*/
void __glSpanModifyStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *inspan, GLvoid *outspan)
{
    __GLpixelMapHead *ssmap;
    GLint ssmask;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLboolean mapStencil;
    __GLfloat indexScale;
    GLint indexOffset, indexShift;
    GLfloat index;

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }
    mapStencil = gc->state.pixel.transferMode.mapStencil;
    if (mapStencil) {
	ssmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_S_TO_S];
	ssmask = ssmap->size - 1;
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	index = *oldData++ * indexScale + indexOffset;
	if (mapStencil) {
	    entry = (int) index;
	    *newData++ = ssmap->base.mapI[entry & ssmask];
	} else {
	    *newData++ = index;
	}
    }
}

/*
** Modify a COLOR_INDEX, FLOAT span.  On the way out, the COLOR_INDEX span 
** will have been modified as needed.
*/
void __glSpanModifyCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLvoid *inspan, GLvoid *outspan)
{
    __GLfloat indexScale;
    GLint indexOffset, indexShift;
    __GLpixelMapHead *iimap, *irmap, *igmap, *ibmap, *iamap;
    GLint iimask, irmask, igmask, ibmask, iamask;
    GLboolean mapColor;
    GLfloat *oldData;
    GLfloat *newData;
    GLint i;
    GLint width;
    GLint entry;
    GLfloat index;

    mapColor = gc->state.pixel.transferMode.mapColor;

    indexOffset = gc->state.pixel.transferMode.indexOffset;
    indexShift = gc->state.pixel.transferMode.indexShift;
    if (indexShift >= 0) {
	indexScale = (GLuint) (1 << indexShift);
    } else {
	indexScale = __glOne/(GLuint) (1 << (-indexShift));
    }
    if (spanInfo->dstFormat != GL_COLOR_INDEX) {
	irmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_R];
	irmask = irmap->size - 1;
	igmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_G];
	igmask = igmap->size - 1;
	ibmap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_B];
	ibmask = ibmap->size - 1;
	iamap = 
	    &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_I_TO_A];
	iamask = iamap->size - 1;
    } else {
	if (mapColor) {
	    iimap = &gc->state.pixel.
		pixelMap[__GL_PIXEL_MAP_I_TO_I];
	    iimask = iimap->size - 1;
	}
    }

    oldData = (GLfloat*) inspan;
    newData = (GLfloat*) outspan;
    width = spanInfo->realWidth;
    for (i=0; i<width; i++) {
	index = *oldData++ * indexScale + indexOffset;
	entry = (int) index;
	if (spanInfo->dstFormat != GL_COLOR_INDEX) {
	    *newData++ = irmap->base.mapF[entry & irmask] * 
		    gc->frontBuffer.redScale;
	    *newData++ = igmap->base.mapF[entry & igmask] *
		    gc->frontBuffer.greenScale;
	    *newData++ = ibmap->base.mapF[entry & ibmask] * 
		    gc->frontBuffer.blueScale;
	    *newData++ = iamap->base.mapF[entry & iamask] *
		    gc->frontBuffer.alphaScale;
	} else if (mapColor) {
	    *newData++ = iimap->base.mapI[entry & iimask];
	} else {
	    *newData++ = index;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_pack.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "imports.h"

/*
** This file contains span packers.  A span packer takes a span of source
** data, and packs its contents into the user's data space.
**
** The packer is expected to aquire information about store modes from
** the __GLpixelSpanInfo structure.
*/

void FASTCALL __glInitPacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint alignment;
    GLint lsb_first;
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint group_size;
    GLint groups_per_line;
    GLint skip_pixels, skip_lines;
    GLint swap_bytes;
    GLenum format, type;
    const GLvoid *pixels;

    format = spanInfo->dstFormat;
    type = spanInfo->dstType;
    pixels = spanInfo->dstImage;
    skip_pixels = spanInfo->dstSkipPixels;
    skip_lines = spanInfo->dstSkipLines;
    alignment = spanInfo->dstAlignment;
    lsb_first = spanInfo->dstLsbFirst;
    swap_bytes = spanInfo->dstSwapBytes;

    components = __glElementsPerGroup(format);
    groups_per_line = spanInfo->dstLineLength;

    element_size = __glBytesPerElement(type);
    if (element_size == 1) swap_bytes = 0;
    group_size = element_size * components;

    rowsize = groups_per_line * group_size;
    if (type == GL_BITMAP) {
	rowsize = (groups_per_line + 7)/8;
    }
    padding = (rowsize % alignment);
    if (padding) {
	rowsize += alignment - padding;
    }
    if (((skip_pixels & 0x7) && type == GL_BITMAP) ||
	    (swap_bytes && element_size > 1)) {
	spanInfo->dstPackedData = GL_FALSE;
    } else {
	spanInfo->dstPackedData = GL_TRUE;
    }

    if (type == GL_BITMAP) {
	spanInfo->dstCurrent = (GLvoid *) (((const GLubyte*) pixels) +
		skip_lines * rowsize + skip_pixels / 8);
	spanInfo->dstStartBit = skip_pixels % 8;
    } else {
	spanInfo->dstCurrent = (GLvoid *) (((const GLubyte*) pixels) +
		skip_lines * rowsize + skip_pixels * group_size);
    }
    spanInfo->dstRowIncrement = rowsize;
    spanInfo->dstGroupIncrement = group_size;
    spanInfo->dstComponents = components;
    spanInfo->dstElementSize = element_size;
}

/*
** Reduces and unscales a RGBA, FLOAT span into a RED, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;

    for (i=0; i<width; i++) {
	*outData++ = *inData * rs;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a GREEN, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;

    inData++;	/* Skip first red */
    for (i=0; i<width; i++) {
	*outData++ = *inData * gs;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a BLUE, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;

    inData += 2;	/* Skip first red, green */
    for (i=0; i<width; i++) {
	*outData++ = *inData * bs;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a ALPHA, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat as = gc->frontBuffer.oneOverAlphaScale;

    inData += 3;	/* Skip first red, green, blue */
    for (i=0; i<width; i++) {
	*outData++ = *inData * as;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a RGB, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;
    GLfloat red, green, blue;

    for (i=0; i<width; i++) {
	red = *inData++ * rs;
	green = *inData++ * gs;
	blue = *inData++ * bs;
	*outData++ = red;
	*outData++ = green;
	*outData++ = blue;
	inData++;
    }
}

#ifdef GL_EXT_bgra
/*
** Reduces and unscales a RGBA, FLOAT span into a BGR, FLOAT span, unscaling
** as it goes.
*/
void __glSpanReduceBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;
    GLfloat red, green, blue;

    for (i=0; i<width; i++) {
	red = *inData++ * rs;
	green = *inData++ * gs;
	blue = *inData++ * bs;
	*outData++ = blue;
	*outData++ = green;
	*outData++ = red;
	inData++;
    }
}
#endif

/*
** Reduces and unscales a RGBA, FLOAT span into a LUMINANCE, FLOAT span,
** unscaling as it goes.
*/
void __glSpanReduceLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat l, one;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;

    one = __glOne;

    for (i=0; i<width; i++) {
	l = inData[0] * rs + inData[1] * gs + inData[2] * bs;
	if (l > one) l = one;
	*outData++ = l;
	inData += 4;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a LUMINANCE_ALPHA, FLOAT span,
** unscaling as it goes.
*/
void __glSpanReduceLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat l, one;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat bs = gc->frontBuffer.oneOverBlueScale;
    GLfloat gs = gc->frontBuffer.oneOverGreenScale;
    GLfloat as = gc->frontBuffer.oneOverAlphaScale;

    one = __glOne;

    for (i=0; i<width; i++) {
	l = inData[0] * rs + inData[1] * gs + inData[2] * bs;
	if (l > one) l = one;
	*outData++ = l;
	inData += 3;
	*outData++ = *inData++ * as;
    }
}

/*
** Reduces and unscales a RGBA, FLOAT span into a __GL_RED_ALPHA, FLOAT span,
** unscaling as it goes.
*/
void __glSpanReduceRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat r, one;
    GLfloat rs = gc->frontBuffer.oneOverRedScale;
    GLfloat as = gc->frontBuffer.oneOverAlphaScale;

    one = __glOne;

    for (i=0; i<width; i++) {
	*outData++ = *inData++ * rs;
	inData += 2;
	*outData++ = *inData++ * as;
    }
}

/*
** Packs to any component of type UNSIGNED_BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLubyte) UNSAFE_FTOL((*inData++) * __glVal255 + __glHalf);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any component of type BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	              GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLbyte *outData = (GLbyte *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_B(*inData++);
    }
}

/*
** Packs to any component of type UNSIGNED_SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLushort *outData = (GLushort *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLushort) UNSAFE_FTOL((*inData++) * __glVal65535 + __glHalf);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any component of type SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLshort *outData = (GLshort *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_S(*inData++);
    }
}

/*
** Packs to any component of type UNSIGNED_INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	              GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLuint *outData = (GLuint *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_UI(*inData++);
    }
}

/*
** Packs to any component of type INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	             GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLint *outData = (GLint *) outspan;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_FLOAT_TO_I(*inData++);
    }
}

/*
** Packs to any index of type UNSIGNED_BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLubyte *outData = (GLubyte *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLubyte) UNSAFE_FTOL(*inData++);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type BYTE from a span of the same
** format of type FLOAT.
*/
void __glSpanPackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLbyte *outData = (GLbyte *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = UNSAFE_FTOL(*inData++) & 0x7f;
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type UNSIGNED_SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLushort *outData = (GLushort *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = (GLushort) UNSAFE_FTOL(*inData++);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type SHORT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLshort *outData = (GLshort *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = UNSAFE_FTOL(*inData++) & 0x7fff;
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type UNSIGNED_INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLuint *outData = (GLuint *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = FTOL(*inData++);
    }

    FPU_RESTORE_MODE();
}

/*
** Packs to any index of type INT from a span of the same
** format of type FLOAT.
*/
void __glSpanPackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	              GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLfloat *inData = (GLfloat *) inspan;
    GLint *outData = (GLint *) outspan;

    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = FTOL(*inData++) & 0x7fffffff;
    }

    FPU_RESTORE_MODE();
}

void __glSpanCopy(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan)
{
    GLint totalSize = spanInfo->realWidth * spanInfo->srcComponents *
	spanInfo->srcElementSize;

    __GL_MEMCOPY(outspan, inspan, totalSize);
}

/*
** Packs to any index of type BITMAP from a span of the same
** format of type FLOAT.
*/
void __glSpanPackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width;
    GLvoid *userData;
    GLfloat *spanData;
    GLint lsbFirst;
    GLint startBit;
    GLint bit;
    GLubyte ubyte, mask;

#ifdef __GL_LINT
    gc = gc;
#endif

    width = spanInfo->width;
    userData = outspan;
    spanData = (GLfloat *) inspan;

    lsbFirst = spanInfo->dstLsbFirst;
    startBit = spanInfo->dstStartBit;

    i = width;
    bit = startBit;
    ubyte = *(GLubyte *) userData;

    if (lsbFirst) {
	if (bit) {
	    switch(bit) {
	      case 1:
		if (((GLint) *spanData++) & 1) ubyte |= 0x02;
		else ubyte &= ~0x02;
		if (--i == 0) break;
	      case 2:
		if (((GLint) *spanData++) & 1) ubyte |= 0x04;
		else ubyte &= ~0x04;
		if (--i == 0) break;
	      case 3:
		if (((GLint) *spanData++) & 1) ubyte |= 0x08;
		else ubyte &= ~0x08;
		if (--i == 0) break;
	      case 4:
		if (((GLint) *spanData++) & 1) ubyte |= 0x10;
		else ubyte &= ~0x10;
		if (--i == 0) break;
	      case 5:
		if (((GLint) *spanData++) & 1) ubyte |= 0x20;
		else ubyte &= ~0x20;
		if (--i == 0) break;
	      case 6:
		if (((GLint) *spanData++) & 1) ubyte |= 0x40;
		else ubyte &= ~0x40;
		if (--i == 0) break;
	      case 7:
		if (((GLint) *spanData++) & 1) ubyte |= 0x80;
		else ubyte &= ~0x80;
		i--;
	    }
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	while (i >= 8) {
	    ubyte = 0;
	    i -= 8;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x01;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x02;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x04;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x08;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x10;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x20;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x40;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x80;
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
            mask = 0x01;
            while (i-- > 0) {
		if (((GLint) *spanData++) & 1) ubyte |= mask;
		else ubyte &= ~mask;
                mask <<= 1;
	    }
	    *(GLubyte *) userData = ubyte;
	}
    } else {
	if (bit) {
	    switch(bit) {
	      case 1:
		if (((GLint) *spanData++) & 1) ubyte |= 0x40;
		else ubyte &= ~0x40;
		if (--i == 0) break;
	      case 2:
		if (((GLint) *spanData++) & 1) ubyte |= 0x20;
		else ubyte &= ~0x20;
		if (--i == 0) break;
	      case 3:
		if (((GLint) *spanData++) & 1) ubyte |= 0x10;
		else ubyte &= ~0x10;
		if (--i == 0) break;
	      case 4:
		if (((GLint) *spanData++) & 1) ubyte |= 0x08;
		else ubyte &= ~0x08;
		if (--i == 0) break;
	      case 5:
		if (((GLint) *spanData++) & 1) ubyte |= 0x04;
		else ubyte &= ~0x04;
		if (--i == 0) break;
	      case 6:
		if (((GLint) *spanData++) & 1) ubyte |= 0x02;
		else ubyte &= ~0x02;
		if (--i == 0) break;
	      case 7:
		if (((GLint) *spanData++) & 1) ubyte |= 0x01;
		else ubyte &= ~0x01;
		i--;
	    }
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	while (i >= 8) {
	    ubyte = 0;
	    i -= 8;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x80;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x40;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x20;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x10;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x08;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x04;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x02;
	    if (((GLint) *spanData++) & 1) ubyte |= 0x01;
	    *(GLubyte *) userData = ubyte;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
            mask = 0x80;
            while (i-- > 0) {
		if (((GLint) *spanData++) & 1) ubyte |= mask;
		else ubyte &= ~mask;
                mask >>= 1;
            }
	    *(GLubyte *) userData = ubyte;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\xform.h ===
#ifndef _transform_h_
#define _transform_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.18 $
** $Date: 1993/11/29 20:34:42 $
*/
#include "vertex.h"

extern __GLcoord __gl_frustumClipPlanes[6];

extern void FASTCALL __glComputeClipBox(__GLcontext *gc);
extern void FASTCALL __glUpdateDepthRange(__GLcontext *gc);
extern void FASTCALL __glUpdateViewport(__GLcontext *gc);
#ifdef NT
extern void FASTCALL __glUpdateViewportDependents(__GLcontext *gc);
#endif

/*
** Note: 
**
** Other code assumes that all types >= __GL_MT_IS2D are also 2D
** Other code assumes that all types >= __GL_MT_W0001 are also W0001
** Other code assumes that all types >= __GL_MT_IS2DNR are also 2DNR
**
** These enumerants are exposed to the MCD.
*/
#define __GL_MT_GENERAL		0	/* No information */
#define __GL_MT_W0001		1	/* W row looks like 0 0 0 1 */
#define __GL_MT_IS2D		2	/* 2D matrix */
#define __GL_MT_IS2DNR		3	/* 2D non-rotational matrix */
#define __GL_MT_IDENTITY	4	/* Identity */

/*
** Matrix struct.  This contains a 4x4 matrix as well as function
** pointers used to do a transformation with the matrix.  The function
** pointers are loaded based on the matrix contents attempting to
** avoid unneccesary computation.
*/

// Matrix structure.
typedef struct __GLmatrixBaseRec {
    __GLfloat matrix[4][4];
} __GLmatrixBase;

// Projection matrix structure.
typedef struct __GLmatrixPRec {
    __GLfloat matrix[4][4];
    GLenum matrixType;
} __GLmatrixP;

// Modelview and texture transform structures.
//
// This structure is exposed to the MCD as MCDMATRIX.
struct __GLmatrixRec {
    __GLfloat matrix[4][4];

    /* 
    ** matrixType set to general if nothing is known about this matrix.
    **
    ** matrixType set to __GL_MT_W0001 if it looks like this:
    ** | . . . 0 |
    ** | . . . 0 |
    ** | . . . 0 |
    ** | . . . 1 |
    **
    ** matrixType set to __GL_MT_IS2D if it looks like this:
    ** | . . 0 0 |
    ** | . . 0 0 |
    ** | 0 0 . 0 |
    ** | . . . 1 |
    **
    ** matrixType set to __GL_MT_IS2DNR if it looks like this:
    ** | . 0 0 0 |
    ** | 0 . 0 0 |
    ** | 0 0 . 0 |
    ** | . . . 1 |
    **
    */
    GLenum matrixType;

    void (FASTCALL *xf1)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf2)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf3)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf4)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xfNorm)(__GLcoord *res, const __GLfloat *v, const __GLmatrix *m);
    void (FASTCALL *xf1Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xf2Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xf3Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xf4Batch)(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
    void (FASTCALL *xfNormBatch) (POLYARRAY *pa, const __GLmatrix *m);
     // Transform and normalize
    void (FASTCALL *xfNormBatchN)(POLYARRAY *pa, const __GLmatrix *m);
    GLboolean nonScaling;    
};

extern void FASTCALL __glGenericPickMatrixProcs(__GLcontext *gc, __GLmatrix *m );
extern void FASTCALL __glGenericPickInvTransposeProcs(__GLcontext *gc, __GLmatrix *m );
extern void FASTCALL __glGenericPickMvpMatrixProcs(__GLcontext *gc, __GLmatrix *m );

/************************************************************************/

/*
** Transform struct.  This structure is what the matrix stacks are
** composed of.  inverseTranspose contains the inverse transpose of matrix.
** For the modelView stack, "mvp" will contain the concatenation of
** the modelView and current projection matrix (i.e. the multiplication of
** the two matricies).
**
** The beginning of this structure is exposed to the MCD as MCDTRANSFORM.
*/

// Transform flags

// Used for MCD
#define XFORM_CHANGED           0x00000001

// Internal
#define XFORM_UPDATE_INVERSE    0x00000002
    
// Modelview transform structure.
struct __GLtransformRec {
    __GLmatrix matrix;
    __GLmatrix mvp;

    GLuint flags;
    
    /* MCDTRANSFORM ends */
    
    /* Sequence number tag for mvp */
    GLuint sequence;
    
    __GLmatrix inverseTranspose;
};

// Texture transform structure.
typedef struct __GLtransformTRec {
    __GLmatrix matrix;
} __GLtransformT;

// Projection transform structure.
typedef struct __GLtransformPRec {
    __GLmatrixP matrix;
    /* Sequence number tag for mvp */
    GLuint sequence;
} __GLtransformP;

/************************************************************************/

/* Unbias an x,y coordinate */
#define __GL_UNBIAS_X(gc, x)	((x) - (gc)->constants.viewportXAdjust)
#define __GL_UNBIAS_Y(gc, y)	((y) - (gc)->constants.viewportYAdjust)

/*
** Transformation machinery state.  Contains the state needed to transform
** user coordinates into eye & window coordinates.
*/
typedef struct __GLtransformMachineRec {
    /*
    ** Transformation stack.  "modelView" points to the active element in
    ** the stack.
    */
    __GLtransform *modelViewStack;
    __GLtransform *modelView;

    /*
    ** Current projection matrix.  Used to transform eye coordinates into
    ** NTVP (or clip) coordinates.
    */
    __GLtransformP *projectionStack;
    __GLtransformP *projection;
    GLuint projectionSequence;

    /*
    ** Texture matrix stack.
    */
    __GLtransformT *textureStack;
    __GLtransformT *texture;

    /*
    ** Temporary verticies used during clipping.  These contain verticies
    ** that are the result of clipping a polygon edge against a clipping
    ** plane.  For a convex polygon at most one vertex can be added for 
    ** each clipping plane.
    */
    __GLvertex *clipTemp;
    __GLvertex *nextClipTemp;

    /*
    ** The smallest rectangle that is the intersection of the window clip
    ** and the scissor clip.  If the scissor box is disabled then this
    ** is just the window box. Note that the x0,y0 point is inside the
    ** box but that the x1,y1 point is just outside the box.
    */
    GLint clipX0;
    GLint clipY0;
    GLint clipX1;
    GLint clipY1;

    /*
    ** The viewport translated into offset window coordinates.  maxx and maxy
    ** are one past the edge (an x coord is in if minx <= x < maxx).
    */
    GLint minx, miny, maxx, maxy;

    /*
    ** The same thing expressed as floating point numbers.
    */
    __GLfloat fminx, fminy, fmaxx, fmaxy;

#ifdef SGI
// Not used.
    /* 
    ** Fast 2D transform state.  If the mvp matrix is >= __GL_MT_IS2D, then
    ** matrix2D contains the matrix to transform object coordinates directly
    ** to window coordinates.
    ** Even though this optimization is used on a per implementation basis,
    ** this matrix is maintained up to date by the soft code.
    */
    __GLmatrix matrix2D;
#endif // SGI
    
    /* A flag for fast path triangle rendering.
    ** If this flag is set, then the user has created a viewport that 
    ** fits within the window, and we can make it render fast.  If, however,
    ** the viewport extends outside the window, we have to be more careful
    ** about scissoring.
    */
    GLboolean reasonableViewport;
} __GLtransformMachine;

extern void __glDoClip(__GLcontext *gc, const __GLvertex *v0,
		       const __GLvertex *v1, __GLvertex *result, __GLfloat t);

extern void FASTCALL __glDoLoadMatrix(__GLcontext *gc, const __GLfloat m[4][4],
			BOOL bIsIdentity);
extern void FASTCALL __glDoMultMatrix(__GLcontext *gc, void *data, 
    void (FASTCALL *multiply)(__GLcontext *gc, __GLmatrix *m, void *data));
extern void __glDoRotate(__GLcontext *gc, __GLfloat angle, __GLfloat ax,
			 __GLfloat ay, __GLfloat az);
extern void __glDoScale(__GLcontext *gc, __GLfloat x, __GLfloat y, __GLfloat z);
extern void __glDoTranslate(__GLcontext *gc, __GLfloat x, __GLfloat y,
			    __GLfloat z);

extern void FASTCALL __glComputeInverseTranspose(__GLcontext *gc, __GLtransform *tr);

/*
** Matrix routines.
*/
extern void FASTCALL __glCopyMatrix(__GLmatrix *dst, const __GLmatrix *src);
extern void FASTCALL __glInvertTransposeMatrix(__GLmatrix *dst, const __GLmatrix *src);
extern void FASTCALL __glMakeIdentity(__GLmatrix *result);
extern void FASTCALL __glMultMatrix(__GLmatrix *result, const __GLmatrix *a,
			   const __GLmatrix *b);
extern void __glTranspose3x3(__GLmatrix *dst, __GLmatrix *src);

/*
** Miscellaneous routines.
*/
extern void FASTCALL __glNormalize(__GLfloat dst[3], const __GLfloat src[3]);
extern void FASTCALL __glNormalizeBatch(POLYARRAY* pa);

/************************************************************************/

extern void FASTCALL __glPushModelViewMatrix(__GLcontext *gc);
extern void FASTCALL __glPopModelViewMatrix(__GLcontext *gc);
extern void FASTCALL __glLoadIdentityModelViewMatrix(__GLcontext *gc);

extern void FASTCALL __glPushProjectionMatrix(__GLcontext *gc);
extern void FASTCALL __glPopProjectionMatrix(__GLcontext *gc);
extern void FASTCALL __glLoadIdentityProjectionMatrix(__GLcontext *gc);

extern void FASTCALL __glPushTextureMatrix(__GLcontext *gc);
extern void FASTCALL __glPopTextureMatrix(__GLcontext *gc);
extern void FASTCALL __glLoadIdentityTextureMatrix(__GLcontext *gc);

/*
** Xforming routines.
*/

void FASTCALL __glXForm4_2DNRW(__GLcoord *res, const __GLfloat v[4],
		      const __GLmatrix *m);
void FASTCALL __glXForm3_2DNRW(__GLcoord *res, const __GLfloat v[3],
		      const __GLmatrix *m);
void FASTCALL __glXForm4_2DW(__GLcoord *res, const __GLfloat v[4],
		    const __GLmatrix *m);
void FASTCALL __glXForm3_2DW(__GLcoord *res, const __GLfloat v[3],
		    const __GLmatrix *m);
#ifndef __GL_USEASMCODE
void FASTCALL __glXForm4_W(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m);
void FASTCALL __glXForm3x3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m);
void FASTCALL __glXForm3_W(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m);
void FASTCALL __glXForm2_W(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m);
void FASTCALL __glXForm4(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m);
void FASTCALL __glXForm3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m);
void FASTCALL __glXForm2(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m);
void FASTCALL __glXForm2_2DW(__GLcoord *res, const __GLfloat v[2],
		    const __GLmatrix *m);
void FASTCALL __glXForm2_2DNRW(__GLcoord *res, const __GLfloat v[2],
		      const __GLmatrix *m);
#endif /* !__GL_USEASMCODE */
void FASTCALL __glXForm1_W(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m);
void FASTCALL __glXForm1(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m);
void FASTCALL __glXForm1_2DW(__GLcoord *res, const __GLfloat v[1],
		    const __GLmatrix *m);
void FASTCALL __glXForm1_2DNRW(__GLcoord *res, const __GLfloat v[1],
		      const __GLmatrix *m);


/*
** Batched versions of the above routines.
*/

void FASTCALL __glXForm4_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm4_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
#ifndef __GL_USEASMCODE
void FASTCALL __glXForm4_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3x3Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm4Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm3Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm2_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
#endif /* !__GL_USEASMCODE */
void FASTCALL __glXForm1_WBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm1Batch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm1_2DWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);
void FASTCALL __glXForm1_2DNRWBatch(__GLcoord *start, __GLcoord *end, const __GLmatrix *m);

// Transformations for normals
//
void FASTCALL __glXForm3_2DNRWBatchNormal  (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3_2DNRWBatchNormalN (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3_2DWBatchNormal    (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3_2DWBatchNormalN   (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3x3BatchNormal      (POLYARRAY *pa, const __GLmatrix *m);
void FASTCALL __glXForm3x3BatchNormalN     (POLYARRAY *pa, const __GLmatrix *m);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_rende.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains routines to render a span of pixel data (from a 
** glDrawPixels or possibly a glCopyPixels request).
*/

/*
** This routine is used to store one fragment from a DrawPixels request.
** It should only be used if the user is either texturing or fogging.
*/
void FASTCALL __glSlowDrawPixelsStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLvertex *rp = &gc->state.current.rasterPos;
    __GLfragment newfrag;

    // The texturing code assumes that FPU truncation is enabled, so
    // we have to turn it on for this case:

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    newfrag = *frag;
    if (gc->texture.textureEnabled) {
	__GLfloat qInv = __glOne / rp->texture.w;
	(*gc->procs.texture)(gc, &newfrag.color, rp->texture.x * qInv,
			       rp->texture.y * qInv, __glOne);
    }
    if (gc->state.enables.general & __GL_FOG_ENABLE) {
	(*gc->procs.fogPoint)(gc, &newfrag, rp->eyeZ);
    }
    (*gc->procs.store)(cfb, &newfrag);

    FPU_RESTORE_MODE();
}

/*
** The only span format supported by this routine is GL_RGB, GL_UNSIGNED_BYTE.
** The store proc is assumed not to mess with the fragment color or alpha.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    frag.color.a = ((GLfloat *) (gc->pixel.alphaCurMap))[255];
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                do {
                    frag.x = column;

                    /* This procedure will do the rest */
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a RGB, UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
**
** The store proc is assumed not to mess with the fragment alpha.
*/
void FASTCALL __glSpanRenderRGBubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.color.a = ((GLfloat *) (gc->pixel.alphaCurMap))[255];
    frag.z = spanInfo->fragz;
    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                frag.x = i;

                /* This procedure will do the rest */
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                frag.color.a = alphaMap[*spanData++];
                do {
                    frag.x = column;

                    /* This procedure will do the rest */
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderRGBAubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.z = spanInfo->fragz;
    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.color.r = redMap[*spanData++];
                frag.color.g = greenMap[*spanData++];
                frag.color.b = blueMap[*spanData++];
                frag.color.a = alphaMap[*spanData++];
                frag.x = i;

                /* This procedure will do the rest */
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 32 bit depth buffers.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderDepthUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLuint*) span;
	frag.y = row;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.z = *spanData++;   /* Assumes 32 bit depth buffer */
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 32 bit depth buffers.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderDepthUint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLuint*) span;
	frag.y = row;
	i = startCol;
	do {
	    frag.z = *spanData++;   /* Assumes 32 bit depth buffer */
	    frag.x = i;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 31 bit depth buffers.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderDepth2Uint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		              GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint startCol;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLuint*) span;
	frag.y = row;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.z = (*spanData++) >> 1;   /* Assumes 31 bit depth buffer */
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_UNSIGNED_INT span.  This is for 
** implementations with 31 bit depth buffers.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderDepth2Uint2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		               GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLuint *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint endCol, startCol;
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
    store = gc->procs.pxStore;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLuint*) span;
	frag.y = row;
	i = startCol;
	do {
	    frag.z = (*spanData++) >> 1;   /* Assumes 31 bit depth buffer */
	    frag.x = i;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_SHORT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderStencilUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                 GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLushort *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint rows;
    GLint startCol;
    GLint value;
    GLshort *pixelArray;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = sb->store;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLushort*) span;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    value = *spanData++;
	    do {
		(*store)(sb, column, row, value);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_SHORT span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderStencilUshort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLushort *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint endCol, startCol;
    GLint rows;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    store = sb->store;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLushort*) span;
	i = startCol;
	do {
	    (*store)(sb, i, row, *spanData++);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderStencilUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint rows;
    GLint startCol;
    GLint value;
    GLshort *pixelArray;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = sb->store;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLubyte*) span;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    value = *spanData++;
	    do {
		(*store)(sb, column, row, value);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_UNSIGNED_BYTE span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderStencilUbyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                 GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y, GLint value);
    __GLstencilBuffer *sb = &gc->stencilBuffer;
    GLint endCol, startCol;
    GLint rows;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    store = sb->store;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLubyte*) span;
	i = startCol;
	do {
	    (*store)(sb, i, row, *spanData++);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_SHORT span.  gc->modes.rgbMode must 
** be GL_FALSE.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCIushort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLushort *spanData;
    GLint rows;
    GLint startCol;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLshort *pixelArray;
    GLint mask;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLushort*) span;
	frag.y = row;

	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.color.r = *spanData++ & mask;
	    do {
		frag.x = column;
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_SHORT.  gc->modes.rgbMode must 
** be GL_FALSE.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCIushort2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLushort *spanData;
    GLint endCol, startCol;
    GLint rows;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint mask;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	spanData = (GLushort*) span;
	frag.y = row;
	i = startCol;
	do {
	    frag.x = i;
	    frag.color.r = *spanData++ & mask;
	    (*store)(gc->drawBuffer, &frag);
	    i += coladd;
	} while (i != endCol);
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  gc->modes.rgbMode must 
** be GL_FALSE.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCIubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			   GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLint rows;
    GLint startCol;
    GLfloat *indexMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    indexMap = (GLfloat*) gc->pixel.iCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (indexMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                frag.color.r = indexMap[*spanData++];
                do {
                    frag.x = column;
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  Also, gc->modes.rgbMode 
** must be GL_FALSE.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCIubyte2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLint endCol, startCol;
    GLint rows;
    GLfloat *indexMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    indexMap = (GLfloat*) gc->pixel.iCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (indexMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.x = i;
                frag.color.r = indexMap[*spanData++];
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  Also, gc->modes.rgbMode 
** must be GL_TRUE.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCIubyte3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLubyte *spanData;
    GLint rows;
    GLint startCol;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    GLubyte value;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    startCol = spanInfo->startCol;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            column = startCol;
            pixelArray = spanInfo->pixelArray;
            spanData = (GLubyte*) span;
            frag.y = row;

            for (i=0; i<width; i++) {
                iright = column + *pixelArray++;
                value = *spanData++;
                frag.color.r = redMap[value];
                frag.color.g = greenMap[value];
                frag.color.b = blueMap[value];
                frag.color.a = alphaMap[value];
                do {
                    frag.x = column;
                    (*store)(gc->drawBuffer, &frag);
                    column += coladd;
                } while (column != iright);
            }
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_UNSIGNED_BYTE span.  Also, gc->modes.rgbMode 
** must be GL_TRUE.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCIubyte4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row;
    GLint i;
    GLint rowadd, coladd;
    GLubyte *spanData;
    GLint endCol, startCol;
    GLint rows;
    GLubyte value;
    GLfloat *redMap, *greenMap, *blueMap, *alphaMap;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;

    redMap = (GLfloat*) gc->pixel.redCurMap;
    greenMap = (GLfloat*) gc->pixel.greenCurMap;
    blueMap = (GLfloat*) gc->pixel.blueCurMap;
    alphaMap = (GLfloat*) gc->pixel.alphaCurMap;
    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;
    startCol = spanInfo->startCol;
    endCol = spanInfo->endCol;
    rows = spanInfo->rows;
#ifdef NT
    if (redMap)
#endif
        for (row = ibottom; row != itop; row += rowadd) {
            if (rows == 0) break;
            rows--;
            spanData = (GLubyte*) span;
            frag.y = row;
            i = startCol;
            do {
                frag.x = i;
                value = *spanData++;
                frag.color.r = redMap[value];
                frag.color.g = greenMap[value];
                frag.color.b = blueMap[value];
                frag.color.a = alphaMap[value];
                (*store)(gc->drawBuffer, &frag);
                i += coladd;
            } while (i != endCol);
        }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, scaled (by the implementation color scales) GL_FLOAT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;

    rows = spanInfo->rows;
    frag.z = spanInfo->fragz;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.color.r = *spanData++;
	    frag.color.g = *spanData++;
	    frag.color.b = *spanData++;
	    frag.color.a = *spanData++;
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_RGBA, scaled (by the implementation color scales) GL_FLOAT span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;

    frag.z = spanInfo->fragz;
    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    frag.color.r = *spanData++;
	    frag.color.g = *spanData++;
	    frag.color.b = *spanData++;
	    frag.color.a = *spanData++;
	    frag.x = column;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_FLOAT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLshort *pixelArray;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;
    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;

	    frag.z = *spanData++ * gc->depthBuffer.scale;

	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_DEPTH_COMPONENT, GL_FLOAT.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		          GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;

    FPU_SAVE_MODE();
    FPU_CHOP_ON();

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    store = gc->procs.pxStore;
    frag.color.r = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
    frag.color.g = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
    frag.color.b = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
    frag.color.a = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    frag.x = column;
	    frag.z = *spanData++ * gc->depthBuffer.scale;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;

    FPU_RESTORE_MODE();
}

/*
** Render a GL_COLOR_INDEX, GL_FLOAT span (gc->modes.rgbMode == GL_FALSE).
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLshort *pixelArray;
    GLint mask;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    frag.color.r = (GLint) (*spanData++) & mask;
	    do {
		frag.x = column;

		/* This procedure will do the rest */
		(*store)(gc->drawBuffer, &frag);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_COLOR_INDEX, GL_FLOAT span (gc->modes.rgbMode == GL_FALSE).
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    __GLfragment frag;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint rows;
    GLint mask;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;
    mask = gc->frontBuffer.redMax;

    store = gc->procs.pxStore;
    frag.z = spanInfo->fragz;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	frag.y = row;
	for (i=0; i<width; i++) {
	    frag.color.r = (GLint) (*spanData++) & mask;
	    frag.x = column;

	    /* This procedure will do the rest */
	    (*store)(gc->drawBuffer, &frag);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_FLOAT span.
**
** zoomx is assumed to be less than -1.0 or greater than 1.0.
*/
void FASTCALL __glSpanRenderStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom, iright;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    GLint index;
    __GLstencilBuffer *sb;
    GLint rows;
    GLshort *pixelArray;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    sb = &gc->stencilBuffer;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	pixelArray = spanInfo->pixelArray;
	spanData = (GLfloat*) span;
	for (i=0; i<width; i++) {
	    iright = column + *pixelArray++;
	    index = *spanData++;
	    do {
		(*sb->store)(sb, column, row, index);
		column += coladd;
	    } while (column != iright);
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}

/*
** Render a GL_STENCIL_INDEX, GL_FLOAT span.
**
** zoomx is assumed to be less than or equal to 1.0 and greater than or equal 
** to -1.0.
*/
void FASTCALL __glSpanRenderStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLvoid *span)
{
    __GLfloat zoomy;
    GLint itop, ibottom;
    GLint row, column;
    GLint i, width;
    GLint coladd, rowadd;
    GLfloat *spanData;
    GLint index;
    __GLstencilBuffer *sb;
    GLint rows;

    zoomy = spanInfo->zoomy;
    rowadd = spanInfo->rowadd;
    coladd = spanInfo->coladd;
    ibottom = spanInfo->startRow;
    itop = spanInfo->y + zoomy;
    width = spanInfo->realWidth;

    sb = &gc->stencilBuffer;

    rows = spanInfo->rows;
    for (row = ibottom; row != itop; row += rowadd) {
	if (rows == 0) break;
	rows--;
	column = spanInfo->startCol;
	spanData = (GLfloat*) span;
	for (i=0; i<width; i++) {
	    index = *spanData++;
	    (*sb->store)(sb, column, row, index);
	    column += coladd;
	}
    }
    spanInfo->rows = rows;
    spanInfo->startRow = itop;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_read.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains span reading routines.  These are routines which 
** read data from the depth buffer, stencil buffer, or frame buffer
** into internal software spans.  The type of internal span that it
** is read into varies from routine to routine.
*/

/*
** A reader that reads spans into scaled a RGBA, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		      GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
#ifdef NT
    	(*gc->readBuffer->readColor)(gc->readBuffer, readX, readY, 
	    	(__GLcolor *) spanData);
#else
	(*gc->frontBuffer.readColor)(gc->readBuffer, readX, readY, 
		(__GLcolor *) spanData);
#endif

	spanData += 4;
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a scaled RGBA, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadRGBA2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

#ifdef NT 
    (*gc->readBuffer->readSpan)(gc->readBuffer, readX, readY, 
	    (__GLcolor *) spanData, width);
#else
    (*gc->frontBuffer.readSpan)(gc->readBuffer, readX, readY, 
	    (__GLcolor *) spanData, width);
#endif
}

/*
** A reader that reads spans into a COLOR_INDEX, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadCI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		    GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLenum format;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
#ifdef NT
    	(*gc->readBuffer->readColor)(gc->readBuffer, readX, readY, 
	    	(__GLcolor *) spanData);
#else
	(*gc->frontBuffer.readColor)(gc->readBuffer, readX, readY, 
		(__GLcolor *) spanData);
#endif
	spanData++;
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a COLOR_INDEX, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadCI2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		     GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
#ifdef NT
    	(*gc->readBuffer->readColor)(gc->readBuffer, readX, readY, 
	    	(__GLcolor *) spanData);
#else
	(*gc->frontBuffer.readColor)(gc->readBuffer, readX, readY, 
		(__GLcolor *) spanData);
#endif
	spanData++;
	readX++;
    }
}

/*
** A reader that reads spans into a DEPTH_COMPONENT, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadDepth(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;
    __GLfloat oneOverScale;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;
    oneOverScale = __glOne / gc->depthBuffer.scale;

    for (i=0; i<width; i++) {
	*spanData++ = 
		(*gc->depthBuffer.fetch)(&(gc->depthBuffer), readX, readY) *
		oneOverScale;
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a DEPTH_COMPONENT, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadDepth2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    __GLfloat oneOverScale;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;
    oneOverScale = __glOne / gc->depthBuffer.scale;

    for (i=0; i<width; i++) {
	*spanData++ = 
		(*gc->depthBuffer.fetch)(&(gc->depthBuffer), readX, readY) *
		oneOverScale;
	readX++;
    }
}

/*
** A reader that reads spans into a STENCIL_INDEX, FLOAT span.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void FASTCALL __glSpanReadStencil(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;
    GLshort *pixelArray;
    GLint skipCount;

    width = spanInfo->realWidth;
    spanData = (GLfloat*) span;
    pixelArray = spanInfo->pixelArray;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
	*spanData++ = 
	    (*gc->stencilBuffer.fetch)(&(gc->stencilBuffer), readX, readY);
	skipCount = *pixelArray++;
	readX += skipCount;
    }
}

/*
** A reader that reads spans into a STENCIL_INDEX, FLOAT span.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void FASTCALL __glSpanReadStencil2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		          GLvoid *span)
{
    GLint i;
    GLint width;
    GLfloat *spanData;
    GLint readY, readX;

    width = spanInfo->width;
    spanData = (GLfloat*) span;

    readY = spanInfo->readY;
    readX = spanInfo->readX;

    for (i=0; i<width; i++) {
	*spanData++ = 
	    (*gc->stencilBuffer.fetch)(&(gc->stencilBuffer), readX, readY);
	readX++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_unpac.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** This file contains routines to unpack data from the user's data space
** into a span of pixels which can then be rendered.
*/

/*
** Return the number of elements per group of a specified format
*/
GLint FASTCALL __glElementsPerGroup(GLenum format)
{
    switch(format) {
      case GL_RGB:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
#endif
        return 3;
      case GL_LUMINANCE_ALPHA:
      case __GL_RED_ALPHA:
        return 2;
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
#endif
        return 4;
      default:
        return 1;
    }
}

/*
** Return the number of bytes per element, based on the element type
*/
__GLfloat FASTCALL __glBytesPerElement(GLenum type)
{
    switch(type) {
      case GL_BITMAP:
        return ((__GLfloat) 1.0 / (__GLfloat) 8.0);
      case GL_UNSIGNED_SHORT:
      case GL_SHORT:
        return 2;
      case GL_UNSIGNED_BYTE:
      case GL_BYTE:
        return 1;
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
      default:
        return 4;
    }
}

void FASTCALL __glInitUnpacker(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint alignment;
    GLint lsb_first;
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint group_size;
    GLint groups_per_line;
    GLint skip_pixels, skip_lines;
    GLint swap_bytes;
    GLenum format, type;
    const GLvoid *pixels;

    format = spanInfo->srcFormat;
    type = spanInfo->srcType;
    pixels = spanInfo->srcImage;
    skip_pixels = spanInfo->srcSkipPixels;
    skip_lines = spanInfo->srcSkipLines;
    alignment = spanInfo->srcAlignment;
    lsb_first = spanInfo->srcLsbFirst;
    swap_bytes = spanInfo->srcSwapBytes;

    components = __glElementsPerGroup(format);
    groups_per_line = spanInfo->srcLineLength;

    element_size = __glBytesPerElement(type);
    if (element_size == 1) swap_bytes = 0;
    group_size = element_size * components;

    rowsize = groups_per_line * group_size;
    if (type == GL_BITMAP) {
	rowsize = (groups_per_line + 7)/8;
    }
    padding = (rowsize % alignment);
    if (padding) {
	rowsize += alignment - padding;
    }
    if (((skip_pixels & 0x7) && type == GL_BITMAP) ||
	    (swap_bytes && element_size > 1)) {
	spanInfo->srcPackedData = GL_FALSE;
    } else {
	spanInfo->srcPackedData = GL_TRUE;
    }

    if (type == GL_BITMAP) {
	spanInfo->srcCurrent = (GLvoid *) (((const GLubyte *) pixels) + 
		skip_lines * rowsize + skip_pixels / 8);
	spanInfo->srcStartBit = skip_pixels % 8;
    } else {
	spanInfo->srcCurrent = (GLvoid *) (((const GLubyte *) pixels) + 
		skip_lines * rowsize + skip_pixels * group_size);
    }
    spanInfo->srcRowIncrement = rowsize;
    spanInfo->srcGroupIncrement = group_size;
    spanInfo->srcComponents = components;
    spanInfo->srcElementSize = element_size;
}

/*
** An unpacker that unpacks from BITMAP source data, into FLOAT spans.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackBitmap(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width;
    GLvoid *userData;
    GLfloat *spanData;
    GLint lsbFirst;
    GLint startBit;
    GLint bit;
    GLubyte ubyte;
    GLshort *pixelArray;
    GLint skipCount;
    __GLfloat zero, one;

    userData = inspan;
    spanData = (GLfloat *) outspan;
    pixelArray = spanInfo->pixelArray;

    width = spanInfo->width;
    lsbFirst = spanInfo->srcLsbFirst;
    startBit = spanInfo->srcStartBit;

    i = width;
    bit = startBit;
    ubyte = *(GLubyte *) userData;

    zero = __glZero;
    one = __glOne;

    skipCount = 1;
    if (lsbFirst) {
	switch(bit) {
	  case 1:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 2:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 3:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 4:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 5:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 6:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 7:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
    } else {
	switch(bit) {
	  case 1:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 2:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 3:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 4:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 5:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 6:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) break;
	  case 7:
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x01) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x80) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x40) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x20) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x10) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x08) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x04) *spanData++ = one;
		else *spanData++ = zero;
	    }
	    if (--i == 0) return;
	    if (--skipCount == 0) {
		skipCount = *pixelArray++;
		if (ubyte & 0x02) *spanData++ = one;
		else *spanData++ = zero;
	    }
	}
    }
}

/*
** An unpacker that unpacks from BITMAP source data, into FLOAT spans.
**
** zoomx is assumed to be less than or equal to -1.0 or greater than or
** equal to 1.0.
*/
void __glSpanUnpackBitmap2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                   GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width;
    GLvoid *userData;
    GLfloat *spanData;
    GLint lsbFirst;
    GLint startBit;
    GLint bit;
    GLubyte ubyte;

    width = spanInfo->realWidth;
    userData = inspan;
    spanData = (GLfloat *) outspan;

    lsbFirst = spanInfo->srcLsbFirst;
    startBit = spanInfo->srcStartBit;

    i = width;
    bit = startBit;
    ubyte = *(GLubyte *) userData;

    if (lsbFirst) {
	switch(bit) {
	  case 1:
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 2:
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 3:
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 4:
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 5:
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 6:
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 7:
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
    } else {
	switch(bit) {
	  case 1:
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 2:
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 3:
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 4:
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 5:
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 6:
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) break;
	  case 7:
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    i--;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	  case 0:
	    break;
	}
	while (i >= 8) {
	    ubyte = *(GLubyte *) userData;
	    userData = (GLvoid *) ((GLubyte *) userData + 1);
	    i -= 8;
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (ubyte & 0x01) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
	if (i) {
	    ubyte = *(GLubyte *) userData;
	    if (ubyte & 0x80) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x40) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x20) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x10) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x08) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x04) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	    if (--i == 0) return;
	    if (ubyte & 0x02) *spanData++ = __glOne;
	    else *spanData++ = __glZero;
	}
    }
}

/*
** An unpacker that unpacks from RGB, UNSIGNED_BYTE source data, into 
** RGB, UNSIGNED_BYTE spans.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackRGBubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                    GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLubyte *userData;
    GLubyte *spanData;
    GLint width, groupInc;
    GLshort *pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    width = spanInfo->realWidth;
    groupInc = spanInfo->srcGroupIncrement;
    userData = (GLubyte *) inspan;
    spanData = (GLubyte *) outspan;

    pixelArray = spanInfo->pixelArray;

    i = 0;
    do {
	spanData[0] = userData[0];
	spanData[1] = userData[1];
	spanData[2] = userData[2];
	spanData += 3;

	skipCount = *pixelArray++;
	userData = (GLubyte *) ((GLubyte *) userData + 3 * skipCount);
	i++;
    } while (i<width);
}

/*
** An unpacker that unpacks from either index, UNSIGNED_BYTE source data, 
** into UNSIGNED_BYTE spans.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackIndexUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                      GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLubyte *userData;
    GLubyte *spanData;
    GLint width, groupInc;
    GLshort *pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    width = spanInfo->realWidth;
    groupInc = spanInfo->srcGroupIncrement;
    userData = (GLubyte *) inspan;
    spanData = (GLubyte *) outspan;
    
    pixelArray = spanInfo->pixelArray;

    i = 0;
    do {
	*spanData = *userData;
	spanData++;

	skipCount = *pixelArray++;
	userData = (GLubyte *) ((GLubyte *) userData + skipCount);
	i++;
    } while (i<width);
}

/*
** An unpacker that unpacks from RGBA, UNSIGNED_BYTE source data, into 
** RGBA, UNSIGNED_BYTE spans.
**
** This could be faster if we could assume that the first ubyte (red)
** was aligned on a word boundary.  Then we could just use unsigned int
** pointers to copy the user's data.  This might be a reasonable future
** optimization.
**
** zoomx is assumed to be less than 1.0 and greater than -1.0.
*/
void __glSpanUnpackRGBAubyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                     GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLubyte *userData;
    GLubyte *spanData;
    GLint width, groupInc;
    GLshort *pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    width = spanInfo->realWidth;
    groupInc = spanInfo->srcGroupIncrement;
    userData = (GLubyte *) inspan;
    spanData = (GLubyte *) outspan;

    pixelArray = spanInfo->pixelArray;

    i = 0;
    do {
	spanData[0] = userData[0];
	spanData[1] = userData[1];
	spanData[2] = userData[2];
	spanData[3] = userData[3];
	spanData += 4;

	skipCount = *pixelArray++;
	userData = (GLubyte *) ((GLubyte *) userData + (skipCount << 2));
	i++;
    } while (i<width);
}

/*
** Swaps bytes from an incoming span of two byte objects to an outgoing span.
** No pixel skipping is performed.
*/
void __glSpanSwapBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = b;
	outData[1] = a;
	outData += 2;
	inData += 2;
    }
}

/*
** Swaps bytes from an incoming span of two byte objects to an outgoing span.
** No pixel skipping is performed.  This version is for swapping to the 
** desination image.
*/
void __glSpanSwapBytes2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = b;
	outData[1] = a;
	outData += 2;
	inData += 2;
    }
}

/*
** Swaps bytes from an incoming span of two byte objects to an outgoing span.
** Pixel skipping is performed.
*/
void __glSpanSwapAndSkipBytes2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		               GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    a = inData[0];
	    b = inData[1];
	    outData[0] = b;
	    outData[1] = a;
	    outData += 2;
	    inData += 2;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLubyte *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** Swaps bytes from an incoming span of four byte objects to an outgoing span.
** No pixel skipping is performed.
*/
void __glSpanSwapBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	c = inData[2];
	d = inData[3];
	a = inData[0];
	b = inData[1];
	outData[0] = d;
	outData[1] = c;
	outData[2] = b;
	outData[3] = a;
	outData += 4;
	inData += 4;
    }
}

/*
** Swaps bytes from an incoming span of four byte objects to an outgoing span.
** No pixel skipping is performed.  This version is for swapping to the 
** destination image.
*/
void __glSpanSwapBytes4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		           GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	c = inData[2];
	d = inData[3];
	a = inData[0];
	b = inData[1];
	outData[0] = d;
	outData[1] = c;
	outData[2] = b;
	outData[3] = a;
	outData += 4;
	inData += 4;
    }
}

/*
** Swaps bytes from an incoming span of four byte objects to an outgoing span.
** Pixel skipping is performed.
*/
void __glSpanSwapAndSkipBytes4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		               GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    c = inData[2];
	    d = inData[3];
	    outData[0] = d;
	    outData[1] = c;
	    a = inData[0];
	    b = inData[1];
	    outData[2] = b;
	    outData[3] = a;
	    outData += 4;
	    inData += 4;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLubyte *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 1 byte in size.
*/
void __glSpanSkipPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    *outData++ = *inData++;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLubyte *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 2 bytes in size, and aligned on a half
** word boundary.
*/
void __glSpanSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLushort *inData = (GLushort *) inspan;
    GLushort *outData = (GLushort *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    *outData++ = *inData++;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLushort *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 4 bytes in size, and aligned on a word
** boundary.
*/
void __glSpanSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLuint *inData = (GLuint *) inspan;
    GLuint *outData = (GLuint *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    *outData++ = *inData++;
	}

	skipCount = (*pixelArray++) - 1;
	inData = (GLuint *) ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 2 bytes in size.  No alignment is assumed,
** so misaligned data should use this path.
*/
void __glSpanSlowSkipPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    a = inData[0];
	    b = inData[1];
	    outData[0] = a;
	    outData[1] = b;
	    outData += 2;
	    inData += 2;
	}

	skipCount = (*pixelArray++) - 1;
	inData = ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that skips pixels according to the pixel skip array.
** Components are assumed to be 4 bytes in size.  No alignment is assumed,
** so misaligned data should use this path.
*/
void __glSpanSlowSkipPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i,j;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint groupInc = spanInfo->srcGroupIncrement;
    GLshort *pixelArray = spanInfo->pixelArray;
    GLint skipCount;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<width; i++) {
	for (j=0; j<components; j++) {
	    a = inData[0];
	    b = inData[1];
	    c = inData[2];
	    d = inData[3];
	    outData[0] = a;
	    outData[1] = b;
	    outData[2] = c;
	    outData[3] = d;
	    outData += 4;
	    inData += 4;
	}

	skipCount = (*pixelArray++) - 1;
	inData = ((GLubyte *) inData + (skipCount * groupInc));
    }
}

/*
** A span modifier that aligns pixels 2 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.
*/
void __glSpanAlignPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = a;
	outData[1] = b;
	outData += 2;
	inData += 2;
    }
}

/*
** A span modifier that aligns pixels 2 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.  This version is for
** aligning to the destination image.
*/
void __glSpanAlignPixels2Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	outData[0] = a;
	outData[1] = b;
	outData += 2;
	inData += 2;
    }
}

/*
** A span modifier that aligns pixels 4 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.
*/
void __glSpanAlignPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	c = inData[2];
	d = inData[3];
	outData[0] = a;
	outData[1] = b;
	outData[2] = c;
	outData[3] = d;
	outData += 4;
	inData += 4;
    }
}

/*
** A span modifier that aligns pixels 4 bytes in size.  No alignment is 
** assumed, so misaligned data should use this path.  This version is 
** for swapping to the destination image.
*/
void __glSpanAlignPixels4Dst(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			     GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLubyte *outData = (GLubyte *) outspan;
    GLubyte a,b,c,d;
    GLint components = spanInfo->dstComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif

    for (i=0; i<totalSize; i++) {
	a = inData[0];
	b = inData[1];
	c = inData[2];
	d = inData[3];
	outData[0] = a;
	outData[1] = b;
	outData[2] = c;
	outData[3] = d;
	outData += 4;
	inData += 4;
    }
}

/*
** Unpacks from any component of type UNSIGNED_BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUbyte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_UB_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackByte(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLbyte *inData = (GLbyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_B_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type UNSIGNED_SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUshort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLushort *inData = (GLushort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_US_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackShort(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLshort *inData = (GLshort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_S_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type UNSIGNED_INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUint(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLuint *inData = (GLuint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_UI_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any component of type INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackInt(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	               GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLint *inData = (GLint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = __GL_I_TO_FLOAT(*inData++);
    }
}

/*
** Unpacks from any index of type UNSIGNED_BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUbyteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLubyte *inData = (GLubyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type BYTE to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackByteI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLbyte *inData = (GLbyte *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type UNSIGNED_SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUshortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                   GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLushort *inData = (GLushort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type SHORT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackShortI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLshort *inData = (GLshort *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type UNSIGNED_INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackUintI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLuint *inData = (GLuint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Unpacks from any index of type INT to a span of the same
** format of type FLOAT.
*/
void __glSpanUnpackIntI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint totalSize = spanInfo->realWidth;
    GLint *inData = (GLint *) inspan;
    GLfloat *outData = (GLfloat *) outspan;

#ifdef __GL_LINT
    gc = gc;
#endif
    for (i=0; i<totalSize; i++) {
	*outData++ = *inData++;
    }
}

/*
** Clamps from any type FLOAT to a span of the same format of type FLOAT.
*/
void __glSpanClampFloat(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat r, one, zero;

    one = __glOne;
    zero = __glZero;
    for (i=0; i<totalSize; i++) {
	r = *inData++;
	if (r > one) r = one;
	else if (r < zero) r = zero;
	*outData++ = r;
    }
}

/*
** Clamps from a signed FLOAT [-1, 1] to a span of the same format of type 
** FLOAT.
*/
void __glSpanClampSigned(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
	                 GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLint components = spanInfo->srcComponents;
    GLint totalSize = width * components;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat r, zero;

    zero = __glZero;
    for (i=0; i<totalSize; i++) {
	r = *inData++;
	if (r < zero) r = zero;
	*outData++ = r;
    }
}

/*
** Expands and scales a RED, FLOAT span into a RGBA, FLOAT span.
*/
void __glSpanExpandRed(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat as = gc->frontBuffer.alphaScale;
    GLfloat rs = gc->frontBuffer.redScale;

    for (i=0; i<width; i++) {
	*outData++ = *inData++ * rs;	/* Red */
	*outData++ = zero;		/* Green */
	*outData++ = zero;		/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales a GREEN, FLOAT span into a RGBA, FLOAT span.
*/
void __glSpanExpandGreen(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat gs = gc->frontBuffer.greenScale;
    GLfloat as = gc->frontBuffer.alphaScale;

    for (i=0; i<width; i++) {
	*outData++ = zero;		/* Red */
	*outData++ = *inData++ * gs;	/* Green */
	*outData++ = zero;		/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales a BLUE, FLOAT span into a RGBA, FLOAT span.
*/
void __glSpanExpandBlue(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		        GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat bs = gc->frontBuffer.blueScale;
    GLfloat as = gc->frontBuffer.alphaScale;

    for (i=0; i<width; i++) {
	*outData++ = zero;		/* Red */
	*outData++ = zero;		/* Green */
	*outData++ = *inData++ * bs;	/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales an ALPHA, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat zero = __glZero;
    GLfloat as = gc->frontBuffer.alphaScale;

    for (i=0; i<width; i++) {
	*outData++ = zero;		/* Red */
	*outData++ = zero;		/* Green */
	*outData++ = zero;		/* Blue */
	*outData++ = *inData++ * as;	/* Alpha */
    }
}

/*
** Expands and scales an RGB, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandRGB(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat r,g,b;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	r = *inData++ * rs;
	g = *inData++ * gs;
	b = *inData++ * bs;
	*outData++ = r;
	*outData++ = g;
	*outData++ = b;
	*outData++ = as;		/* Alpha */
    }
}

#ifdef GL_EXT_bgra
/*
** Expands and scales a BGR, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandBGR(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat r,g,b;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	b = *inData++ * bs;
	g = *inData++ * gs;
	r = *inData++ * rs;
	*outData++ = r;
	*outData++ = g;
	*outData++ = b;
	*outData++ = as;		/* Alpha */
    }
}
#endif

/*
** Expands and scales a LUMINANCE, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandLuminance(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		             GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat comp;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	comp = *inData++;
	*outData++ = comp * rs;		/* Red */
	*outData++ = comp * gs;		/* Green */
	*outData++ = comp * bs;		/* Blue */
	*outData++ = as;		/* Alpha */
    }
}

/*
** Expands and scales a LUMINANCE_ALPHA, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandLuminanceAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		                  GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat comp;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;

    for (i=0; i<width; i++) {
	comp = *inData++;
	*outData++ = comp * rs;		/* Red */
	*outData++ = comp * gs;		/* Green */
	*outData++ = comp * bs;		/* Blue */
	*outData++ = *inData++ * as;	/* Alpha */
    }
}

/*
** Expands and scales a __GL_RED_ALPHA, FLOAT span into a RGBA, FLOAT span. 
*/
void __glSpanExpandRedAlpha(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			    GLvoid *inspan, GLvoid *outspan)
{
    GLint i;
    GLint width = spanInfo->realWidth;
    GLfloat *outData = (GLfloat *) outspan;
    GLfloat *inData = (GLfloat *) inspan;
    GLfloat comp;
    GLfloat zero;
    GLfloat rs,gs,bs;
    GLfloat as = gc->frontBuffer.alphaScale;

    rs = gc->frontBuffer.redScale;
    zero = __glZero;

    for (i=0; i<width; i++) {
	comp = *inData++;
	*outData++ = comp * rs;		/* Red */
	*outData++ = zero;
	*outData++ = zero;
	*outData++ = *inData++ * as;	/* Alpha */
    }
}

/*
** The only span format supported by this routine is GL_RGBA, GL_FLOAT.
** The span is simply scaled by the frame buffer scaling factors.
*/
void __glSpanScaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.redScale;
    gscale = gc->frontBuffer.greenScale;
    bscale = gc->frontBuffer.blueScale;
    ascale = gc->frontBuffer.alphaScale;
    for (i=0; i<width; i++) {
	red = *inData++ * rscale;
	green = *inData++ * gscale;
	*outData++ = red;
	*outData++ = green;
	blue = *inData++ * bscale;
	alpha = *inData++ * ascale;
	*outData++ = blue;
	*outData++ = alpha;
    }
}

/*
** The only span format supported by this routine is GL_RGBA, GL_FLOAT.
** The span is simply unscaled by the frame buffer scaling factors.
*/
void __glSpanUnscaleRGBA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.oneOverRedScale;
    gscale = gc->frontBuffer.oneOverGreenScale;
    bscale = gc->frontBuffer.oneOverBlueScale;
    ascale = gc->frontBuffer.oneOverAlphaScale;
    for (i=0; i<width; i++) {
	red = *inData++ * rscale;
	green = *inData++ * gscale;
	*outData++ = red;
	*outData++ = green;
	blue = *inData++ * bscale;
	alpha = *inData++ * ascale;
	*outData++ = blue;
	*outData++ = alpha;
    }
}

#ifdef GL_EXT_bgra
/*
** The only span format supported by this routine is GL_BGRA, GL_FLOAT.
** The span is scaled by the frame buffer scaling factors and swapped
** into RGBA order.
*/
void __glSpanScaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		       GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.redScale;
    gscale = gc->frontBuffer.greenScale;
    bscale = gc->frontBuffer.blueScale;
    ascale = gc->frontBuffer.alphaScale;
    for (i=0; i<width; i++) {
	blue = *inData++ * bscale;
	green = *inData++ * gscale;
	red = *inData++ * rscale;
	alpha = *inData++ * ascale;
	*outData++ = red;
	*outData++ = green;
	*outData++ = blue;
	*outData++ = alpha;
    }
}

/*
** The only input format supported by this routine is GL_RGBA, GL_FLOAT.
** The span is unscaled by the frame buffer scaling factors and swapped
** into BGRA order.
*/
void __glSpanUnscaleBGRA(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		         GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    rscale = gc->frontBuffer.oneOverRedScale;
    gscale = gc->frontBuffer.oneOverGreenScale;
    bscale = gc->frontBuffer.oneOverBlueScale;
    ascale = gc->frontBuffer.oneOverAlphaScale;
    for (i=0; i<width; i++) {
	red = *inData++ * rscale;
	green = *inData++ * gscale;
	blue = *inData++ * bscale;
	alpha = *inData++ * ascale;
	*outData++ = blue;
	*outData++ = green;
	*outData++ = red;
	*outData++ = alpha;
    }
}
#endif

/*
** The only span format supported by this routine is palette index, GL_FLOAT.
** The span is simply scaled by the frame buffer scaling factors.
*/
#ifdef GL_EXT_paletted_texture
void __glSpanScalePI(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
                     GLvoid *inspan, GLvoid *outspan)
{
    GLint i, width;
    GLfloat rscale, gscale, bscale, ascale;
    GLfloat red, green, blue, alpha;
    GLfloat *inData, *outData;
    RGBQUAD *rgb;

    width = spanInfo->realWidth;
    inData = (GLfloat *) inspan;
    outData = (GLfloat *) outspan;

    // Throw in an extra scaling of 1/255 because the palette
    // data is in ubyte format
    rscale = gc->frontBuffer.redScale*__glOneOver255;
    gscale = gc->frontBuffer.greenScale*__glOneOver255;
    bscale = gc->frontBuffer.blueScale*__glOneOver255;
    ascale = gc->frontBuffer.alphaScale*__glOneOver255;
    for (i=0; i<width; i++) {
        rgb = &spanInfo->srcPalette[(int)((*inData++)*
                                          spanInfo->srcPaletteSize)];
	red = rgb->rgbRed * rscale;
	green = rgb->rgbGreen * gscale;
	*outData++ = red;
	*outData++ = green;
	blue = rgb->rgbBlue * bscale;
	alpha = rgb->rgbReserved * ascale;
	*outData++ = blue;
	*outData++ = alpha;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>

#include <ddrawp.h>
#include <ddrawi.h>
#include <ddraw.h>

#include <math.h>
#include <string.h>

#include <glp.h>
#include <context.h>
#include <global.h>
#include <render.h>
#include <imfuncs.h>
#include <imports.h>
#include <pixel.h>
#include <image.h>
#ifdef GL_WIN_phong_shading
#include <phong.h>
#endif
#include <xform.h>

#include "gencx.h"
// redisable this

#pragma warning (disable:4244)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_accum.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

void Load(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, ow, skip;
    __GLfloat rval, gval, bval, aval;
    __GLaccumCell *ac;
    __GLcolorBuffer *cfb;
#ifdef NT
    __GLcolor *cbuf;

    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));

    if (NULL == cbuf)
        return;
#else
    __GLcolor cbuf[4096];/*XXX*/

    w = x1 - x0;
    assert(w < 4096);/*XXX*/
#endif

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    rval = val * afb->redScale;
    gval = val * afb->greenScale;
    bval = val * afb->blueScale;
    aval = val * afb->alphaScale;

    for (; y0 < y1; y0++) {
	__GLcolor *cp = &cbuf[0];
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], ow);

	w = w4;
	while (--w >= 0) {
	    ac[0].r = (__GLaccumCellElement) (cp[0].r * rval);
	    ac[0].g = (__GLaccumCellElement) (cp[0].g * gval);
	    ac[0].b = (__GLaccumCellElement) (cp[0].b * bval);
	    ac[0].a = (__GLaccumCellElement) (cp[0].a * aval);

	    ac[1].r = (__GLaccumCellElement) (cp[1].r * rval);
	    ac[1].g = (__GLaccumCellElement) (cp[1].g * gval);
	    ac[1].b = (__GLaccumCellElement) (cp[1].b * bval);
	    ac[1].a = (__GLaccumCellElement) (cp[1].a * aval);

	    ac[2].r = (__GLaccumCellElement) (cp[2].r * rval);
	    ac[2].g = (__GLaccumCellElement) (cp[2].g * gval);
	    ac[2].b = (__GLaccumCellElement) (cp[2].b * bval);
	    ac[2].a = (__GLaccumCellElement) (cp[2].a * aval);

	    ac[3].r = (__GLaccumCellElement) (cp[3].r * rval);
	    ac[3].g = (__GLaccumCellElement) (cp[3].g * gval);
	    ac[3].b = (__GLaccumCellElement) (cp[3].b * bval);
	    ac[3].a = (__GLaccumCellElement) (cp[3].a * aval);
	    ac += 4;
	    cp += 4;
	}

	w = w1;
	while (--w >= 0) {
	    ac->r = (__GLaccumCellElement) (cp->r * rval);
	    ac->g = (__GLaccumCellElement) (cp->g * gval);
	    ac->b = (__GLaccumCellElement) (cp->b * bval);
	    ac->a = (__GLaccumCellElement) (cp->a * aval);
	    ac++;
	    cp++;
	}
	ac += skip;
    }
#ifdef NT
    gcTempFree(gc, cbuf);
#endif
}

void Accumulate(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, ow, skip, w4, w1;
    __GLfloat rval, gval, bval, aval;
    __GLaccumCell *ac;
    __GLcolorBuffer *cfb;
#ifdef NT
    __GLcolor *cbuf;

    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));

    if (NULL == cbuf)
        return;
#else
    __GLcolor cbuf[4096];/*XXX*/

    w = x1 - x0;
    assert(w < 4096);/*XXX*/
#endif

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    rval = val * afb->redScale;
    gval = val * afb->greenScale;
    bval = val * afb->blueScale;
    aval = val * afb->alphaScale;

    for (; y0 < y1; y0++) {
	__GLcolor *cp = &cbuf[0];
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], ow);

	w = w4;
	while (--w >= 0) {
	    ac[0].r += (__GLaccumCellElement) (cp[0].r * rval);
	    ac[0].g += (__GLaccumCellElement) (cp[0].g * gval);
	    ac[0].b += (__GLaccumCellElement) (cp[0].b * bval);
	    ac[0].a += (__GLaccumCellElement) (cp[0].a * aval);

	    ac[1].r += (__GLaccumCellElement) (cp[1].r * rval);
	    ac[1].g += (__GLaccumCellElement) (cp[1].g * gval);
	    ac[1].b += (__GLaccumCellElement) (cp[1].b * bval);
	    ac[1].a += (__GLaccumCellElement) (cp[1].a * aval);

	    ac[2].r += (__GLaccumCellElement) (cp[2].r * rval);
	    ac[2].g += (__GLaccumCellElement) (cp[2].g * gval);
	    ac[2].b += (__GLaccumCellElement) (cp[2].b * bval);
	    ac[2].a += (__GLaccumCellElement) (cp[2].a * aval);

	    ac[3].r += (__GLaccumCellElement) (cp[3].r * rval);
	    ac[3].g += (__GLaccumCellElement) (cp[3].g * gval);
	    ac[3].b += (__GLaccumCellElement) (cp[3].b * bval);
	    ac[3].a += (__GLaccumCellElement) (cp[3].a * aval);
	    ac += 4;
	    cp += 4;
	}

	w = w1;
	while (--w >= 0) {
	    ac->r += (__GLaccumCellElement) (cp->r * rval);
	    ac->g += (__GLaccumCellElement) (cp->g * gval);
	    ac->b += (__GLaccumCellElement) (cp->b * bval);
	    ac->a += (__GLaccumCellElement) (cp->a * aval);
	    ac++;
	    cp++;
	}
	ac += skip;
    }
#ifdef NT
    gcTempFree(gc, cbuf);
#endif
}

void Mult(__GLaccumBuffer *afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    __GLaccumCell *ac;

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = x1 - x0;
    skip = afb->buf.outerWidth - w;

    if (val == __glZero) {
	/* Zero out the buffers contents */
	for (; y0 < y1; y0++) {
	    GLint ww = w;
	    while (ww > 0) {
		ac[0].r = 0; ac[0].g = 0; ac[0].b = 0; ac[0].a = 0;
		ac++;
		ww--;
	    }
	    ac += skip;
	}
	return;
    }

    w4 = w >> 2;
    w1 = w & 3;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0].r = (__GLaccumCellElement) (ac[0].r * val);
	    ac[0].g = (__GLaccumCellElement) (ac[0].g * val);
	    ac[0].b = (__GLaccumCellElement) (ac[0].b * val);
	    ac[0].a = (__GLaccumCellElement) (ac[0].a * val);
	    ac[1].r = (__GLaccumCellElement) (ac[1].r * val);
	    ac[1].g = (__GLaccumCellElement) (ac[1].g * val);
	    ac[1].b = (__GLaccumCellElement) (ac[1].b * val);
	    ac[1].a = (__GLaccumCellElement) (ac[1].a * val);
	    ac[2].r = (__GLaccumCellElement) (ac[2].r * val);
	    ac[2].g = (__GLaccumCellElement) (ac[2].g * val);
	    ac[2].b = (__GLaccumCellElement) (ac[2].b * val);
	    ac[2].a = (__GLaccumCellElement) (ac[2].a * val);
	    ac[3].r = (__GLaccumCellElement) (ac[3].r * val);
	    ac[3].g = (__GLaccumCellElement) (ac[3].g * val);
	    ac[3].b = (__GLaccumCellElement) (ac[3].b * val);
	    ac[3].a = (__GLaccumCellElement) (ac[3].a * val);
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    ac[0].r = (__GLaccumCellElement) (ac[0].r * val);
	    ac[0].g = (__GLaccumCellElement) (ac[0].g * val);
	    ac[0].b = (__GLaccumCellElement) (ac[0].b * val);
	    ac[0].a = (__GLaccumCellElement) (ac[0].a * val);
	    ac++;
	}
	ac += skip;
    }
}

void Add(__GLaccumBuffer *afb, __GLfloat value)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    __GLaccumCellElement rval, gval, bval, aval;
    __GLaccumCell *ac;

    rval = (__GLaccumCellElement)
	(value * gc->frontBuffer.redScale * afb->redScale + __glHalf);
    gval = (__GLaccumCellElement)
	(value * gc->frontBuffer.greenScale * afb->greenScale + __glHalf);
    bval = (__GLaccumCellElement)
	(value * gc->frontBuffer.blueScale * afb->blueScale + __glHalf);
    aval = (__GLaccumCellElement)
	(value * gc->frontBuffer.alphaScale * afb->alphaScale + __glHalf);

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = x1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0].r += rval; ac[0].g += gval; ac[0].b += bval; ac[0].a += aval;
	    ac[1].r += rval; ac[1].g += gval; ac[1].b += bval; ac[1].a += aval;
	    ac[2].r += rval; ac[2].g += gval; ac[2].b += bval; ac[2].a += aval;
	    ac[3].r += rval; ac[3].g += gval; ac[3].b += bval; ac[3].a += aval;
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    ac[0].r += rval; ac[0].g += gval; ac[0].b += bval; ac[0].a += aval;
	    ac++;
	}
	ac += skip;
    }
}

void Return(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, next;
    __GLaccumCell *ac;
    __GLcolorBuffer *cfb;
    __GLcolorBuffer *cfb2;
    __GLfragment frag;
    __GLcolor *pAccumCol;
    // The returnspan routines use FTOL 
    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = x1 - x0;
    next = afb->buf.outerWidth;
    frag.y = y0;

    // Preallocate a color buffer for the return span functions
    pAccumCol = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if( NULL == pAccumCol )
        return;
    afb->colors = pAccumCol;

    if (gc->buffers.doubleStore) {
	/* Store to both buffers */
	cfb = &gc->frontBuffer;
	cfb2 = &gc->backBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, ac, val, w);
	    (*cfb2->returnSpan)(cfb2, x0, y0, ac, val, w);
	    ac += next;
	}
    } else {
	cfb = gc->drawBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, ac, val, w);
	    ac += next;
	}
    }
    FPU_RESTORE_MODE();
    gcTempFree( gc, pAccumCol );
}

void FASTCALL Clear(__GLaccumBuffer* afb)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    __GLaccumCell *ac;
    __GLaccumCellElement r, g, b, a;
    __GLcolorBuffer *cfb = &gc->frontBuffer;
    __GLcolor *val = &gc->state.accum.clear;

    /*
    ** Convert abstract color into specific color value.
    */
    r = (__GLaccumCellElement) (val->r * cfb->redScale * afb->redScale);
    g = (__GLaccumCellElement) (val->g * cfb->greenScale * afb->greenScale);
    b = (__GLaccumCellElement) (val->b * cfb->blueScale * afb->blueScale);
    a = (__GLaccumCellElement) (val->a * cfb->alphaScale * afb->alphaScale);

    ac = __GL_ACCUM_ADDRESS(afb,(__GLaccumCell*),x0,y0);
    w = gc->transform.clipX1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0].r = r; ac[0].g = g; ac[0].b = b; ac[0].a = a;
	    ac[1].r = r; ac[1].g = g; ac[1].b = b; ac[1].a = a;
	    ac[2].r = r; ac[2].g = g; ac[2].b = b; ac[2].a = a;
	    ac[3].r = r; ac[3].g = g; ac[3].b = b; ac[3].a = a;
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    ac[0].r = r; ac[0].g = g; ac[0].b = b; ac[0].a = a;
	    ac++;
	}
	ac += skip;
    }
}

/************************************************************************/

void FASTCALL Pick(__GLcontext *gc, __GLaccumBuffer *afb)
{
#ifdef __GL_LINT
    gc = gc;
    afb = afb;
#endif
}

void FASTCALL __glInitAccum64(__GLcontext *gc, __GLaccumBuffer *afb)
{
    afb->buf.elementSize = sizeof(__GLaccumCell);
    afb->buf.gc = gc;
    if (gc->modes.rgbMode) {
	__GLcolorBuffer *cfb;
	__GLfloat scale;

	scale = (__GLfloat)((1 << (8 * sizeof(__GLaccumCellElement)))/2 - 1);

	cfb = &gc->frontBuffer;
	afb->redScale = scale / (cfb->redScale);
	afb->blueScale = scale / (cfb->blueScale);
	afb->greenScale = scale / (cfb->greenScale);
	afb->alphaScale = scale / (cfb->alphaScale);

	afb->oneOverRedScale = 1 / afb->redScale;
	afb->oneOverGreenScale = 1 / afb->greenScale;
	afb->oneOverBlueScale = 1 / afb->blueScale;
	afb->oneOverAlphaScale = 1 / afb->alphaScale;
    }
    afb->pick = Pick;
    afb->clear = Clear;
    afb->accumulate = Accumulate;
    afb->load = Load;
    afb->ret = Return;
    afb->mult = Mult;
    afb->add = Add;
}

void FASTCALL __glFreeAccum64(__GLcontext *gc, __GLaccumBuffer *afb)
{
#ifdef __GL_LINT
    gc = gc;
    afb = afb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\pixel\px_paths.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "imports.h"
#include "gencx.h"
#include "px_fast.h"

// Disable long to float conversion warning.  see also context.h
#pragma warning (disable:4244)

/*
** This routine clips a draw pixels box, and sets up a bunch of 
** variables required for drawing the box.  These are some of them:
**
** startCol   - The first column that will be drawn.
** x          - Effective raster position.  This will be set up so that 
**		every time zoomx is added, a change in the integer portion
**		of x indicates that a pixel should rendered (unpacked).
** columns    - The total number of columns that will be rendered.
**
** Others are startRow, y, rows.
**
** Yet other variables may be modified, such as width, height, skipPixels,
** skipLines.
**
** The clipping routine is written very carefully so that a fragment will
** be rasterized by a pixel if it's center falls within the range
** [x, x+zoomx) x [y, y+zoomy).
*/
GLboolean FASTCALL __glClipDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint skipPixels;
    GLint skipRows;
    GLint width, height;
    GLint tempint;
    GLint endCol, endRow;
    __GLfloat x,y,x2,y2;
    __GLfloat zoomx, zoomy;
    __GLfloat clipLeft, clipRight, clipBottom, clipTop;

    zoomx = spanInfo->zoomx;
    zoomy = spanInfo->zoomy;
    if (zoomx == __glZero || zoomy == __glZero) {
	return GL_FALSE;
    }

    skipPixels = skipRows = 0;
    width = spanInfo->width;
    height = spanInfo->height;
    clipLeft = gc->transform.clipX0 + __glHalf;
    clipBottom = gc->transform.clipY0 + __glHalf;
    clipRight = gc->transform.clipX1 - gc->constants.viewportAlmostHalf;
    clipTop = gc->transform.clipY1 - gc->constants.viewportAlmostHalf;

    x = spanInfo->x;
    y = spanInfo->y;
    x2 = x + zoomx * width;
    y2 = y + zoomy * height;

    if (zoomx > 0) {
	/* Zoomx is positive, clip the left edge */
	if (x > clipLeft) {
	    /* Clip to the first fragment that will be produced */
	    clipLeft = (GLint) (x + gc->constants.viewportAlmostHalf);
	    clipLeft += __glHalf;
	}
	skipPixels = (clipLeft-x) / zoomx;
	if (skipPixels >= width) return GL_FALSE;

	width -= skipPixels;
	spanInfo->startCol = clipLeft;
	x = x + skipPixels * zoomx;
	spanInfo->x = x + gc->constants.viewportAlmostHalf;
	spanInfo->srcSkipPixels += skipPixels;

	/* Zoomx is positive, clip the right edge */
	if (x2 < clipRight) {
	    /* Clip to the last fragment that will be produced */
	    clipRight = (GLint) (x2 + gc->constants.viewportAlmostHalf);
	    clipRight -= gc->constants.viewportAlmostHalf;
	}
	tempint = (x2-clipRight) / zoomx;
	if (tempint >= width) return GL_FALSE;

	width -= tempint;
	endCol = (GLint) clipRight + 1;
	spanInfo->endCol = endCol;
	spanInfo->columns = endCol - spanInfo->startCol;
    } else /* zoomx < 0 */ {
	/* Zoomx is negative, clip the right edge */
	if (x < clipRight) {
	    /* Clip to the first fragment that will be produced */
	    clipRight = (GLint) (x + gc->constants.viewportAlmostHalf);
	    clipRight -= gc->constants.viewportAlmostHalf;
	}
	skipPixels = (clipRight-x) / zoomx;
	if (skipPixels >= width) return GL_FALSE;

	width -= skipPixels;
	spanInfo->startCol = clipRight;
	x = x + skipPixels * zoomx;
	spanInfo->x = x + gc->constants.viewportAlmostHalf - __glOne;
	spanInfo->srcSkipPixels += skipPixels;

	/* Zoomx is negative, clip the left edge */
	if (x2 > clipLeft) {
	    clipLeft = (GLint) (x2 + gc->constants.viewportAlmostHalf);
	    clipLeft += __glHalf;
	}
	tempint = (x2-clipLeft) / zoomx;
	if (tempint >= width) return GL_FALSE;

	width -= tempint;
	endCol = (GLint) clipLeft - 1;
	spanInfo->endCol = endCol;
	spanInfo->columns = spanInfo->startCol - endCol;
    }

    if (zoomy > 0) {
	/* Zoomy is positive, clip the bottom edge */
	if (y > clipBottom) {
	    /* Clip to the first row that will be produced */
	    clipBottom = (GLint) (y + gc->constants.viewportAlmostHalf);
	    clipBottom += __glHalf;
	}
	skipRows = (clipBottom-y) / zoomy;
	if (skipRows >= height) return GL_FALSE;

	height -= skipRows;
	spanInfo->startRow = clipBottom;
	y = y + skipRows * zoomy;
	spanInfo->y = y + gc->constants.viewportAlmostHalf;
	spanInfo->srcSkipLines += skipRows;

	/* Zoomy is positive, clip the top edge */
	if (y2 < clipTop) {
	    /* Clip to the last row that will be produced */
	    clipTop = (GLint) (y2 + gc->constants.viewportAlmostHalf);
	    clipTop -= gc->constants.viewportAlmostHalf;
	}
	tempint = (y2-clipTop) / zoomy;
	if (tempint >= height) return GL_FALSE;

	height -= tempint;
	endRow = (GLint) clipTop + 1;
	spanInfo->rows = endRow - spanInfo->startRow;
    } else /* zoomy < 0 */ {
	/* Zoomy is negative, clip the top edge */
	if (y < clipTop) {
	    /* Clip to the first row that will be produced */
	    clipTop = (GLint) (y + gc->constants.viewportAlmostHalf);
	    clipTop -= gc->constants.viewportAlmostHalf;
	}
	skipRows = (clipTop-y) / zoomy;
	if (skipRows >= height) return GL_FALSE;

	height -= skipRows;
	spanInfo->startRow = clipTop;
	y = y + skipRows * zoomy;
	/* spanInfo->y = y - __glHalf; */
	spanInfo->y = y + gc->constants.viewportAlmostHalf - __glOne;
	spanInfo->srcSkipLines += skipRows;

	/* Zoomy is negative, clip the bottom edge */
	if (y2 > clipBottom) {
	    clipBottom = (GLint) (y2 + gc->constants.viewportAlmostHalf);
	    clipBottom += __glHalf;
	}
	tempint = (y2-clipBottom) / zoomy;
	if (tempint >= height) return GL_FALSE;

	height -= tempint;
	endRow = (GLint) clipBottom - 1;
	spanInfo->rows = spanInfo->startRow - endRow;
    }

    spanInfo->width = width;
    spanInfo->height = height;

    if (zoomx < 0) zoomx = -zoomx;
    if (zoomx >= 1) {
	spanInfo->realWidth = width;
    } else {
	spanInfo->realWidth = spanInfo->columns;
    }

    return GL_TRUE;
}

/*
** This routine computes spanInfo->pixelArray if needed.
**
** If |zoomx| > 1.0, this array contains counts for how many times to 
** replicate a given pixel.  For example, if zoomx is 2.0, this array will
** contain all 2's.  If zoomx is 1.5, then every other entry will contain 
** a 2, and every other entry will contain a 1.
**
** if |zoomx| < 1.0, this array contains counts for how many pixels to 
** skip.  For example, if zoomx is 0.5, every entry in the array will contain
** a 2 (indicating to skip forward two pixels [only past one]).  If zoomx is
** .666, then every other entry will be a 2, and every other entry will be 
** a 1.
*/
void FASTCALL __glComputeSpanPixelArray(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint width, intx;
    __GLfloat zoomx, oldx, newx;
    GLint i;
    GLshort *array;
    
    zoomx = spanInfo->zoomx;
    if (zoomx > (__GLfloat) -1.0 && zoomx < __glOne) {
	GLint lasti;

	/* Build pixel skip array */
	width = spanInfo->width;
	oldx = spanInfo->x;
	array = spanInfo->pixelArray;

	intx = (GLint) oldx;
	newx = oldx;

	lasti = 0;
	for (i=0; i<width; i++) {
	    /* Skip groups which will not be rasterized */
	    newx += zoomx;
	    while ((GLint) newx == intx && i<width) {
		newx += zoomx;
		i++;
	    }
	    ASSERTOPENGL(i != width, "Pixel skip array overflow\n");
	    if (i != 0) {
		*array++ = (GLshort) (i - lasti);
	    }
	    lasti = i;
	    intx = (GLint) newx;
	}
	*array++ = 1;
    } else if (zoomx < (__GLfloat) -1.0 || zoomx > __glOne) {
	__GLfloat right;
	GLint iright;
	GLint coladd, column;
	GLint startCol;

	/* Build pixel replication array */
	width = spanInfo->realWidth - 1;
	startCol = spanInfo->startCol;
	column = startCol;
	coladd = spanInfo->coladd;
	array = spanInfo->pixelArray;
	right = spanInfo->x;
	for (i=0; i<width; i++) {
	    right = right + zoomx;
	    iright = right;
	    *array++ = (GLshort) (iright - column);
	    column = iright;
	}
	if (coladd == 1) {
	    *array++ = (GLshort) (spanInfo->columns - (column - startCol));
	} else {
	    *array++ = (GLshort) ((startCol - column) - spanInfo->columns);
	}
    }
}

/*
** Initialize the spanInfo structure.  If "packed" is true, the structure
** is initialized for unpacking data from a display list.  If "packed" is 
** false, it is initialized for unpacking data from the user's data space.
*/
void FASTCALL __glLoadUnpackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			 GLboolean packed)
{

    if (packed) {
	/*
	** Data came from a display list.
	*/

	spanInfo->srcAlignment = 1;
	spanInfo->srcSkipPixels = 0;
	spanInfo->srcSkipLines = 0;
	spanInfo->srcLsbFirst = GL_FALSE;
	spanInfo->srcSwapBytes = GL_FALSE;
	spanInfo->srcLineLength = spanInfo->width;
    } else {
	GLint lineLength;

	/*
	** Data came straight from the application.
	*/

	lineLength = gc->state.pixel.unpackModes.lineLength;
	spanInfo->srcAlignment = gc->state.pixel.unpackModes.alignment;
	spanInfo->srcSkipPixels = gc->state.pixel.unpackModes.skipPixels;
	spanInfo->srcSkipLines = gc->state.pixel.unpackModes.skipLines;
	spanInfo->srcLsbFirst = gc->state.pixel.unpackModes.lsbFirst;
	spanInfo->srcSwapBytes = gc->state.pixel.unpackModes.swapEndian;
#ifdef NT
/* XXX! kluge? (mf) : Since the routines that unpack incoming data from
	  glTexImage commands use spanInfo->realWidth to determine how
	  much to unpack, set this approppriately when lineLength > 0
*/
	if (lineLength <= 0)
	    lineLength = spanInfo->width;
	else
	    spanInfo->realWidth = lineLength; /* otherwise, use value for
					realWidth already set */
#else
	if (lineLength <= 0) lineLength = spanInfo->width;
#endif
	spanInfo->srcLineLength = lineLength;
    }
}

void __glInitDrawPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLint width, GLint height, GLenum format, 
			    GLenum type, const GLvoid *pixels)
{
    __GLfloat x,y;
    __GLfloat zoomx, zoomy;

    x = gc->state.current.rasterPos.window.x;
    y = gc->state.current.rasterPos.window.y;

    spanInfo->x = x;
    spanInfo->y = y;
    spanInfo->fragz = gc->state.current.rasterPos.window.z;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx > __glZero) {
	if (zoomx < __glOne) {
	    spanInfo->rendZoomx = __glOne;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = 1;
    } else {
	if (zoomx > (GLfloat) -1.0) {
	    spanInfo->rendZoomx = (GLfloat) -1.0;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = -1;
    }
    spanInfo->zoomx = zoomx;
    zoomy = gc->state.pixel.transferMode.zoomY;
    if (gc->constants.yInverted) {
	zoomy = -zoomy;
    }
    if (zoomy > __glZero) {
	spanInfo->rowadd = 1;
    } else {
	spanInfo->rowadd = -1;
    }
    spanInfo->zoomy = zoomy;
    spanInfo->width = width;
    spanInfo->height = height;
    if (format == GL_COLOR_INDEX && gc->modes.rgbMode) {
	spanInfo->dstFormat = GL_RGBA;
    } else {
	spanInfo->dstFormat = format;
    }
    spanInfo->srcFormat = format;
    spanInfo->srcType = type;
    spanInfo->srcImage = pixels;
}

/*
** This is the generic DrawPixels routine.  It applies four span modification
** routines followed by a span rendering routine.
*/
void FASTCALL __glDrawPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height, width;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    width = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, width);
    spanData2 = gcTempAlloc(gc, width);
    width = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, width);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glDrawPixels4_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    width = spanInfo->width;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*render)(gc, spanInfo, spanData2);
    }
#ifdef NT
__glDrawPixels4_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/*
** This is the generic DrawPixels routine.  It applies three span modification
** routines followed by a span rendering routine.
*/
void FASTCALL __glDrawPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height, width;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT		   
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    width = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, width);
    spanData2 = gcTempAlloc(gc, width);
    width = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, width);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glDrawPixels3_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    width = spanInfo->width;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*render)(gc, spanInfo, spanData1);
    }
#ifdef NT
__glDrawPixels3_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/*
** This is the generic DrawPixels routine.  It applies two span modification
** routines followed by a span rendering routine.
*/
void FASTCALL __glDrawPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height, width;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    width = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, width);
    spanData2 = gcTempAlloc(gc, width);
    width = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, width);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glDrawPixels2_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    width = spanInfo->width;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*render)(gc, spanInfo, spanData2);
    }
#ifdef NT
__glDrawPixels2_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** Draw pixels with only one span modification routine.
*/
void FASTCALL __glDrawPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1;
    GLshort *pixelArray;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    pixelArray = gcTempAlloc(gc, spanInfo->width * sizeof(GLshort));
    if (!spanData1 || !pixelArray)
        goto __glDrawPixels1_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    span1 = spanInfo->spanModifier[0];
    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*render)(gc, spanInfo, spanData1);
    }
#ifdef NT
__glDrawPixels1_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** Draw pixels with no span modification routines.
*/
void FASTCALL __glDrawPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    int i;
    __GLfloat zoomy, newy;
    GLint inty, height;
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLshort *pixelArray;

    pixelArray = gcTempAlloc(gc, spanInfo->width * sizeof(GLshort));
    if (!pixelArray)
        return;
#else
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    render = spanInfo->spanRender;

    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->y = newy;
	    spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		    spanInfo->srcRowIncrement;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*render)(gc, spanInfo, spanInfo->srcCurrent);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
    }
#ifdef NT
    gcTempFree(gc, pixelArray);
#endif
}

/*
** Generic implementation of a DrawPixels picker.  Any machine specific
** implementation should provide their own.
*/
void __glSlowPickDrawPixels(__GLcontext *gc, GLint width, GLint height,
		            GLenum format, GLenum type, const GLvoid *pixels,
			    GLboolean packed)
{
    __GLpixelSpanInfo spanInfo;
    
    __glInitDrawPixelsInfo(gc, &spanInfo, width, height, format, type, pixels);
    __glLoadUnpackModes(gc, &spanInfo, packed);
    if (!__glClipDrawPixels(gc, &spanInfo)) return;

    __glInitUnpacker(gc, &spanInfo);

    __glGenericPickDrawPixels(gc, &spanInfo);
}

/*
** Generic picker for DrawPixels.  This should be called if no machine
** specific path is provided for this specific version of DrawPixels.
*/
void FASTCALL __glGenericPickDrawPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLpixelMachine *pm;
    void (FASTCALL *dpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
    GLint spanCount;
    GLboolean zoomx1;		/* -1 <= zoomx <= 1? */
    GLboolean zoomx2;		/* zoomx <= -1 || zoomx >= 1 */
    __GLfloat zoomx;
    GLboolean packedUserData;
    GLenum type, format;
    GLboolean skip;
    GLboolean swap;
    GLboolean align;
    GLboolean convert;
    GLboolean expand;
    GLboolean clamp;

    spanCount = 0;
    pm = &gc->pixel;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx >= (__GLfloat) -1.0 && zoomx <= __glOne) {
	zoomx1 = GL_TRUE;
    } else {
	zoomx1 = GL_FALSE;
    }
    if (zoomx <= (__GLfloat) -1.0 || zoomx >= __glOne) {
	zoomx2 = GL_TRUE;
    } else {
	zoomx2 = GL_FALSE;
    }

    packedUserData = spanInfo->srcPackedData && zoomx2;
    type = spanInfo->srcType;
    format = spanInfo->srcFormat;

    if (spanInfo->srcSwapBytes && spanInfo->srcElementSize > 1) {
	swap = GL_TRUE;
    } else {
	swap = GL_FALSE;
    }
    if (zoomx2 || type == GL_BITMAP) {
	skip = GL_FALSE;
    } else {
	skip = GL_TRUE;
    }
    if (type != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->srcImage)) & (spanInfo->srcElementSize - 1))) {
	align = GL_TRUE;
    } else {
	align = GL_FALSE;
    }
    if (type == GL_FLOAT || type == GL_BITMAP) {
	convert = GL_FALSE;
    } else {
	convert = GL_TRUE;
    }
    /*
    ** Clamp types only if index or not modifying (because converting
    ** float types means clamping, and that is only done if not modifying),
    ** and only if they might need clamping (UNSIGNED types never do).
    */
    if (type == GL_BITMAP || type == GL_UNSIGNED_BYTE || 
	    type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT ||
	    format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX ||
	    (format == GL_DEPTH_COMPONENT && pm->modifyDepth) ||
	    (format != GL_DEPTH_COMPONENT && pm->modifyRGBA)) {
	clamp = GL_FALSE;
    } else {
	clamp = GL_TRUE;
    }
	    
#ifdef NT
    // Special case RGB drawing to use a DIB
    // Also special case loading the Z buffer
    if (format == GL_RGB || format == GL_BGR_EXT || format == GL_BGRA_EXT)
    {
        GLuint enables = gc->state.enables.general;
    
        // If the input is unsigned bytes with DWORD aligned scanlines
        // and no unusual lengths, then it's almost compatible with
        // a 24-bit RGB DIB.  The only problem is that OpenGL sees
        // it as BGR so the bytes need to be swapped.  Since we need to
        // copy the data to swap the bytes, we adjust line lengths and
        // alignment then, allowing nearly any unsigned byte input format
        //
        // Other things that can't be allowed are depth testing,
        // fogging, blending or anything that prevents the input data
        // from going directly into the destination buffer

        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            type == GL_UNSIGNED_BYTE &&
            !pm->modifyRGBA &&
            (enables & (__GL_DITHER_ENABLE |
                        __GL_ALPHA_TEST_ENABLE |
                        __GL_STENCIL_TEST_ENABLE |
                        __GL_DEPTH_TEST_ENABLE |
                        __GL_BLEND_ENABLE |
                        __GL_INDEX_LOGIC_OP_ENABLE |
                        __GL_COLOR_LOGIC_OP_ENABLE |
                        __GL_FOG_ENABLE)) == 0 &&
            gc->state.raster.drawBuffer != GL_NONE &&
            gc->state.raster.drawBuffer != GL_FRONT_AND_BACK &&
            !gc->texture.textureEnabled &&
            (gc->drawBuffer->buf.flags & COLORMASK_ON) == 0
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (DrawRgbPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
    else if (format == GL_DEPTH_COMPONENT)
    {
        // If the Z test is GL_ALWAYS and there is no draw buffer
        // then the application is simply loading Z values into
        // the Z buffer.
        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            !swap &&
            (type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT) &&
            !pm->modifyDepth &&
            gc->state.raster.drawBuffer == GL_NONE &&
            (gc->state.enables.general & __GL_DEPTH_TEST_ENABLE) &&
            gc->state.depth.testFunc == GL_ALWAYS &&
            gc->modes.haveDepthBuffer
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (StoreZPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif
    
    /* 
    ** First step:  convert data into a packed readable format 
    ** (RED, BYTE), (LUMINANCE, UNSIGNED_INT), etc...  This stage
    ** simply packs the user's data, but performs no conversion on it.
    **
    ** Packing can consist of:
    **  - aligning the data
    **  - skipping pixels if |xzoom| is < 1
    **  - swapping bytes if necessary
    */
    if (swap) {
	if (skip) {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanSwapAndSkipBytes2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanSwapAndSkipBytes4;
	    }
	} else {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4;
	    }
	}
    } else if (align) {
	if (skip) {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = __glSpanSlowSkipPixels2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = __glSpanSlowSkipPixels4;
	    }
	} else {
	    if (spanInfo->srcElementSize == 2) {
		spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2;
	    } else /* spanInfo->srcElementSize == 4 */ {
		spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4;
	    }
	}
    } else if (skip) {
	if (spanInfo->srcElementSize == 1) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSkipPixels1;
	} else if (spanInfo->srcElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSkipPixels2;
	} else /* spanInfo->srcElementSize == 4 */ {
	    spanInfo->spanModifier[spanCount++] = __glSpanSkipPixels4;
	}
    }

    /* 
    ** Second step:  conversion to float
    ** All formats are converted into floating point (including GL_BITMAP).
    */
    if (convert) {
	if (format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX) {
	    /* Index conversion */
	    switch(type) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackByteI;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyteI;
		break;
	      case GL_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackShortI;
		break;
	      case GL_UNSIGNED_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshortI;
		break;
	      case GL_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackIntI;
		break;
	      case GL_UNSIGNED_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUintI;
		break;
	    }
	} else {
	    /* Component conversion */
	    switch(type) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackByte;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyte;
		break;
	      case GL_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackShort;
		break;
	      case GL_UNSIGNED_SHORT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshort;
		break;
	      case GL_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackInt;
		break;
	      case GL_UNSIGNED_INT:
	        spanInfo->spanModifier[spanCount++] = __glSpanUnpackUint;
		break;
	    }
	}
    }

    if (clamp) {
	switch(type) {
	  case GL_BYTE:
	  case GL_SHORT:
	  case GL_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanClampSigned;
	    break;
	  case GL_FLOAT:
	    spanInfo->spanModifier[spanCount++] = __glSpanClampFloat;
	    break;
	}
    }

    if (type == GL_BITMAP) {
	if (zoomx2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap2;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap;
	}
    }

    /* 
    ** Third step:  Modification and color scaling
    **
    ** Spans are modified if necessary (color biasing, maps, shift,
    ** scale), and RGBA colors are scaled.  Also, all RGBA derivative
    ** formats (RED, LUMINANCE, ALPHA, etc.) are converted to RGBA.
    ** The only four span formats that survive this stage are:
    **
    ** (COLOR_INDEX, FLOAT),
    ** (STENCIL_INDEX, FLOAT),
    ** (DEPTH_COMPONENT, FLOAT),
    ** (RGBA, FLOAT),
    */

    switch(format) {
      case GL_RED:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRed;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandRed;
	}
	break;
      case GL_GREEN:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyGreen;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandGreen;
	}
	break;
      case GL_BLUE:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyBlue;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandBlue;
	}
	break;
      case GL_ALPHA:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyAlpha;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandAlpha;
	}
	break;
      case GL_RGB:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandRGB;
	}
	break;
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
	if (pm->modifyRGBA) {
            // __glSpanModifyRGB handles both RGB and BGR
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandBGR;
	}
	break;
#endif
      case GL_LUMINANCE:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyLuminance;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandLuminance;
	}
	break;
      case GL_LUMINANCE_ALPHA:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyLuminanceAlpha;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanExpandLuminanceAlpha;
	}
	break;
      case GL_RGBA:
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanScaleRGBA;
	}
	break;
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
	if (pm->modifyRGBA) {
            // __glSpanModifyRGBA handles both RGBA and BGRA
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	} else {
	    spanInfo->spanModifier[spanCount++] = __glSpanScaleBGRA;
	}
	break;
#endif
      case GL_DEPTH_COMPONENT:
	if (pm->modifyDepth) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	} 
	break;
      case GL_STENCIL_INDEX:
	if (pm->modifyStencil) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	} 
	break;
      case GL_COLOR_INDEX:
	if (pm->modifyCI) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	} 
	break;
    }

    /*
    ** Fourth step:  Rendering
    **
    ** The spans are rendered.  If |xzoom| > 1, then the span renderer
    ** is responsible for pixel replication.
    */

    switch(spanInfo->dstFormat) {
      case GL_RGBA:
      case GL_RGB:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderRGBA2;
	} else {
	    render = gc->procs.pixel.spanRenderRGBA;
	}
	break;
      case GL_DEPTH_COMPONENT:
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderDepth2;
	} else {
	    render = gc->procs.pixel.spanRenderDepth;
	}
	break;
      case GL_COLOR_INDEX:
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderCI2;
	} else {
	    render = gc->procs.pixel.spanRenderCI;
	}
	break;
      case GL_STENCIL_INDEX:
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderStencil2;
	} else {
	    render = gc->procs.pixel.spanRenderStencil;
	}
	break;
    }

    /*
    ** Optimization attempt.
    **
    ** There are some format, type combinations that are expected to be 
    ** common.  This code optimizes a few of those cases.  Specifically,
    ** these modes include:  (GL_UNSIGNED_BYTE, GL_RGB), 
    ** (GL_UNSIGNED_BYTE, GL_RGBA), (GL_UNSIGNED_BYTE, GL_COLOR_INDEX),
    ** (GL_UNSIGNED_BYTE, GL_STENCIL_INDEX), 
    ** (GL_UNSIGNED_SHORT, GL_COLOR_INDEX), 
    ** (GL_UNSIGNED_SHORT, GL_STENCIL_INDEX),
    ** (GL_UNSIGNED_INT, GL_DEPTH_COMPONENT)
    */

    switch(type) {
      case GL_UNSIGNED_BYTE:
	switch(format) {
	  case GL_RGB:
	    spanCount = 0;
	    if (packedUserData) {
		/* no span unpacking is necessary! */
	    } else {
		/* zoomx2 must not be true, or packedUserData would be set 
		*/
		ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackRGBubyte;
	    }
	    if (!pm->modifyRGBA) {
		pm->redCurMap = pm->redMap;
		pm->greenCurMap = pm->greenMap;
		pm->blueCurMap = pm->blueMap;
		pm->alphaCurMap = pm->alphaMap;
		if (zoomx1) {
		    render = __glSpanRenderRGBubyte2;
		} else {
		    render = __glSpanRenderRGBubyte;
		}
	    } else {
		if (!pm->rgbaCurrent) {
		    __glBuildRGBAModifyTables(gc, pm);
		}
		pm->redCurMap = pm->redModMap;
		pm->greenCurMap = pm->greenModMap;
		pm->blueCurMap = pm->blueModMap;
		pm->alphaCurMap = pm->alphaModMap;
		if (zoomx1) {
		    render = __glSpanRenderRGBubyte2;
		} else {
		    render = __glSpanRenderRGBubyte;
		}
	    }
	    break;
	  case GL_RGBA:
	    spanCount = 0;
	    if (packedUserData) {
		/* no span unpacking is necessary! */
	    } else {
		/* zoomx2 must not be true, or packedUserData would be set 
		*/
		ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackRGBAubyte;
	    }
	    if (!pm->modifyRGBA) {
		pm->redCurMap = pm->redMap;
		pm->greenCurMap = pm->greenMap;
		pm->blueCurMap = pm->blueMap;
		pm->alphaCurMap = pm->alphaMap;
	    } else {
		if (!pm->rgbaCurrent) {
		    __glBuildRGBAModifyTables(gc, pm);
		}
		pm->redCurMap = pm->redModMap;
		pm->greenCurMap = pm->greenModMap;
		pm->blueCurMap = pm->blueModMap;
		pm->alphaCurMap = pm->alphaModMap;
	    }
	    if (zoomx1) {
		render = __glSpanRenderRGBAubyte2;
	    } else {
		render = __glSpanRenderRGBAubyte;
	    }
	    break;
	  case GL_STENCIL_INDEX:
	    if (!pm->modifyStencil) {
		spanCount = 0;
		if (packedUserData) {
		    /* no span unpacking is necessary! */
		} else {
		    /* zoomx2 must not be true, or packedUserData would be set 
		    */
                    ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		    spanInfo->spanModifier[spanCount++] = 
			    __glSpanUnpackIndexUbyte;
		}
		if (zoomx1) {
		    render = __glSpanRenderStencilUbyte2;
		} else {
		    render = __glSpanRenderStencilUbyte;
		}
	    }
	    break;
	  case GL_COLOR_INDEX:
	    spanCount = 0;
	    if (packedUserData) {
		/* no span unpacking is necessary! */
	    } else {
		/* zoomx2 must not be true, or packedUserData would be set 
		*/
		ASSERTOPENGL(!zoomx2, "zoomx2 is set\n");
		spanInfo->spanModifier[spanCount++] = 
			__glSpanUnpackIndexUbyte;
	    }
	    if (!pm->modifyCI) {
		pm->iCurMap = pm->iMap;
		if (zoomx1) {
		    render = __glSpanRenderCIubyte2;
		} else {
		    render = __glSpanRenderCIubyte;
		}
	    } else {
		if (gc->modes.rgbMode) {
		    if (!pm->iToRGBACurrent) {
			__glBuildItoRGBAModifyTables(gc, pm);
		    }
		    pm->redCurMap = pm->iToRMap;
		    pm->greenCurMap = pm->iToGMap;
		    pm->blueCurMap = pm->iToBMap;
		    pm->alphaCurMap = pm->iToAMap;
		    if (zoomx1) {
			render = __glSpanRenderCIubyte4;
		    } else {
			render = __glSpanRenderCIubyte3;
		    }
		} else {
		    if (!pm->iToICurrent) {
			__glBuildItoIModifyTables(gc, pm);
		    }
		    pm->iCurMap = pm->iToIMap;
		    if (zoomx1) {
			render = __glSpanRenderCIubyte2;
		    } else {
			render = __glSpanRenderCIubyte;
		    }
		}
	    }
	    break;
	  default:
	    break;
	}
	break;
      case GL_UNSIGNED_SHORT:
	switch(format) {
	  case GL_STENCIL_INDEX:
	    if (!pm->modifyStencil) {
		/* Back off conversion to float */
		ASSERTOPENGL(convert, "convert not set\n");
		spanCount--;
		if (zoomx1) {
		    render = __glSpanRenderStencilUshort2;
		} else {
		    render = __glSpanRenderStencilUshort;
		}
	    }
	    break;
	  case GL_COLOR_INDEX:
	    if (!pm->modifyCI) {
		/* Back off conversion to float */
		ASSERTOPENGL(convert, "convert not set\n");
		spanCount--;
		if (zoomx1) {
		    render = __glSpanRenderCIushort2;
		} else {
		    render = __glSpanRenderCIushort;
		}
	    }
	    break;
	  default:
	    break;
	}
	break;
      case GL_UNSIGNED_INT:
	switch(format) {
	  case GL_DEPTH_COMPONENT:
	    if (!pm->modifyDepth) {
		if (gc->depthBuffer.scale == 0xffffffff) {
                    // XXX we never set depthBuffer.scale to 0xffffffff in NT!
                    // XXX write optimize code for 16-bit z buffers?
		    /* Back off conversion to float */
                    ASSERTOPENGL(convert, "convert not set\n");
		    spanCount--;

		    if (zoomx1) {
			render = __glSpanRenderDepthUint2;
		    } else {
			render = __glSpanRenderDepthUint;
		    }
		} else if (gc->depthBuffer.scale == 0x7fffffff) {
		    /* Back off conversion to float */
                    ASSERTOPENGL(convert, "convert not set\n");
		    spanCount--;

		    if (zoomx1) {
			render = __glSpanRenderDepth2Uint2;
		    } else {
			render = __glSpanRenderDepth2Uint;
		    }
		}
	    }
	    break;
	  default:
	    break;
	}
	break;
      default:
	break;
    }

    /*
    ** Pick a DrawPixels function that applies the correct number of 
    ** span modifiers.
    */

    switch(spanCount) {
      case 0:
	dpfn = __glDrawPixels0;
	break;
      case 1:
	dpfn = __glDrawPixels1;
	break;
      case 2:
	dpfn = __glDrawPixels2;
	break;
      case 3:
	dpfn = __glDrawPixels3;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 4:
	dpfn = __glDrawPixels4;
	break;
    }
    spanInfo->spanRender = render;
    (*dpfn)(gc, spanInfo);
}

/*
** This routine clips ReadPixels calls so that only fragments which are
** owned by this context will be read and copied into the user's data.
** Parts of the ReadPixels rectangle lying outside of the window will
** be ignored.
*/
GLboolean FASTCALL __glClipReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint clipLeft, clipRight, clipTop, clipBottom;
    GLint x,y,x2,y2;
    GLint skipPixels, skipRows;
    GLint width, height;
    GLint tempint;
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GLGENwindow *pwnd = gengc->pwndLocked;

    width = spanInfo->width;
    height = spanInfo->height;
    x = spanInfo->readX;
    y = spanInfo->readY;
    x2 = x + spanInfo->width;
    if (gc->constants.yInverted) {
	y2 = y - spanInfo->height;
    } else {
	y2 = y + spanInfo->height;
    }
    if (pwnd &&
        (pwnd->rclBounds.left < pwnd->rclBounds.right) &&
        (pwnd->rclBounds.top < pwnd->rclBounds.bottom)) {

        clipLeft   = (pwnd->rclBounds.left - pwnd->rclClient.left)
                     + gc->constants.viewportXAdjust;
        clipRight  = (pwnd->rclBounds.right - pwnd->rclClient.left)
                     + gc->constants.viewportXAdjust;

        if (gc->constants.yInverted) {
            clipBottom = (pwnd->rclBounds.top - pwnd->rclClient.top)
                         + gc->constants.viewportYAdjust;
            clipTop    = (pwnd->rclBounds.bottom - pwnd->rclClient.top)
                         + gc->constants.viewportYAdjust;
        } else {
            clipBottom = (gc->constants.height -
                          (pwnd->rclBounds.bottom - pwnd->rclClient.top))
                         + gc->constants.viewportYAdjust;
            clipTop    = (gc->constants.height -
                          (pwnd->rclBounds.top - pwnd->rclClient.top))
                         + gc->constants.viewportYAdjust;
        }
    } else {
        clipLeft   = gc->constants.viewportXAdjust;
        clipRight  = gc->constants.viewportXAdjust;
        clipBottom = gc->constants.viewportYAdjust;
        clipTop    = gc->constants.viewportYAdjust;
    }
    skipPixels = 0;
    skipRows = 0;
    if (x < clipLeft) {
	skipPixels = clipLeft - x;
	if (skipPixels > width) return GL_FALSE;

	width -= skipPixels;
	x = clipLeft;
	spanInfo->dstSkipPixels += skipPixels;
	spanInfo->readX = x;
    }
    if (x2 > clipRight) {
	tempint = x2 - clipRight;
	if (tempint > width) return GL_FALSE;

	width -= tempint;
    }
    if (gc->constants.yInverted) {
	if (y >= clipTop) {
	    skipRows = y - clipTop + 1;
	    if (skipRows > height) return GL_FALSE;

	    height -= skipRows;
	    y = clipTop - 1;
	    spanInfo->dstSkipLines += skipRows;
	    spanInfo->readY = y;
	}
	if (y2 < clipBottom - 1) {
	    tempint = clipBottom - y2 - 1;
	    if (tempint > height) return GL_FALSE;

	    height -= tempint;
	}
    } else {
	if (y < clipBottom) {
	    skipRows = clipBottom - y;
	    if (skipRows > height) return GL_FALSE;

	    height -= skipRows;
	    y = clipBottom;
	    spanInfo->dstSkipLines += skipRows;
	    spanInfo->readY = y;
	}
	if (y2 > clipTop) {
	    tempint = y2 - clipTop;
	    if (tempint > height) return GL_FALSE;

	    height -= tempint;
	}
    }

    spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->realWidth = width;

    return GL_TRUE;
}

/*
** Initialize the spanInfo structure for packing data into the user's data
** space.
*/
void FASTCALL __glLoadPackModes(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint lineLength = gc->state.pixel.packModes.lineLength;

    spanInfo->dstAlignment = gc->state.pixel.packModes.alignment;
    spanInfo->dstSkipPixels = gc->state.pixel.packModes.skipPixels;
    spanInfo->dstSkipLines = gc->state.pixel.packModes.skipLines;
    spanInfo->dstLsbFirst = gc->state.pixel.packModes.lsbFirst;
    spanInfo->dstSwapBytes = gc->state.pixel.packModes.swapEndian;
    if (lineLength <= 0) lineLength = spanInfo->width;
    spanInfo->dstLineLength = lineLength;
}

void __glInitReadPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		            GLint x, GLint y, GLint width, GLint height, 
			    GLenum format, GLenum type, const GLvoid *pixels)
{
    spanInfo->readX = x + gc->constants.viewportXAdjust;
    if (gc->constants.yInverted) {
	spanInfo->readY = (gc->constants.height - y - 1) + 
		gc->constants.viewportYAdjust;
    } else {
	spanInfo->readY = y + gc->constants.viewportYAdjust;
    }
    spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->dstFormat = format;
    spanInfo->dstType = type;
    spanInfo->dstImage = pixels;
    spanInfo->zoomx = __glOne;
    spanInfo->x = __glZero;
    __glLoadPackModes(gc, spanInfo);
}

/*
** A simple generic ReadPixels routine with five span modifiers.
*/
void FASTCALL __glReadPixels5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels5_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*span3)(gc, spanInfo, spanData1, spanData2);
	(*span4)(gc, spanInfo, spanData2, spanData1);
	(*span5)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels5_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with three span modifiers.
*/
void FASTCALL __glReadPixels4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels4_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*span3)(gc, spanInfo, spanData1, spanData2);
	(*span4)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels4_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with four span modifiers.
*/
void FASTCALL __glReadPixels3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels3_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*span3)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels3_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with two span modifiers.
*/
void FASTCALL __glReadPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		  GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glReadPixels2_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glReadPixels2_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple generic ReadPixels routine with one span modifier.
*/
void FASTCALL __glReadPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    if (!spanData1)
        return;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
#endif

    span1 = spanInfo->spanModifier[0];
    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
#ifdef NT
    gcTempFree(gc, spanData1);
#endif
}

/*
** A simple generic ReadPixels routine with no span modifiers.
*/
void FASTCALL __glReadPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);

    reader = spanInfo->spanReader;

    ySign = gc->constants.ySign;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	(*reader)(gc, spanInfo, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLvoid *) ((GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement);
	spanInfo->readY += ySign;
    }
}

/*
** Generic implementation of a ReadPixels picker.  Any machine specific
** implementation should provide their own.
*/
void __glSlowPickReadPixels(__GLcontext *gc, GLint x, GLint y,
		            GLsizei width, GLsizei height,
		            GLenum format, GLenum type, const GLvoid *pixels)
{
    __GLpixelSpanInfo spanInfo;

    __glInitReadPixelsInfo(gc, &spanInfo, x, y, width, height, format, 
	    type, pixels);
    if (!__glClipReadPixels(gc, &spanInfo)) return;

    __glInitPacker(gc, &spanInfo);

    __glGenericPickReadPixels(gc, &spanInfo);
}

/*
** Generic picker for ReadPixels.  This should be called if no machine
** specific path is provided for this specific version of ReadPixels.
*/
void FASTCALL __glGenericPickReadPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLpixelMachine *pm;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *rpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
    GLint spanCount;
    GLenum type, format;
    GLboolean isIndex;

    spanCount = 0;

    type = spanInfo->dstType;
    format = spanInfo->dstFormat;
    pm = &gc->pixel;

#ifdef NT
    // Special case RGB reading to use a DIB
    // Also special case reading the Z buffer
    if (format == GL_RGB || format == GL_BGR_EXT || format == GL_BGRA_EXT)
    {
        GLuint enables = gc->state.enables.general;
    
        if (type == GL_UNSIGNED_BYTE &&
            !pm->modifyRGBA &&
            gc->state.pixel.transferMode.indexShift == 0 &&
            gc->state.pixel.transferMode.indexOffset == 0
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (ReadRgbPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
    else if (format == GL_DEPTH_COMPONENT)
    {
        if (!spanInfo->dstSwapBytes &&
            (type == GL_UNSIGNED_SHORT || type == GL_UNSIGNED_INT) &&
            !pm->modifyDepth &&
            gc->modes.haveDepthBuffer
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (ReadZPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif

    // The read functions always retrieve __GLcolors so the source
    // data format is always GL_RGBA.  It's important to set this
    // because some routines handle both RGB and BGR ordering and
    // look at the srcFormat to determine what to do.
    spanInfo->srcFormat = GL_RGBA;

    /*
    ** First step:  Read and modify a span.  RGBA spans are scaled when
    ** this step is finished.
    */

    switch(format) {
      case GL_RGB:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case GL_ALPHA:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	if (gc->modes.rgbMode) {
	    reader = gc->procs.pixel.spanReadRGBA2;
	    if (pm->modifyRGBA) {
		spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	    }
	} else {
	    reader = gc->procs.pixel.spanReadCI2;
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	}
	isIndex = GL_FALSE;
	break;
      case GL_DEPTH_COMPONENT:
	reader = gc->procs.pixel.spanReadDepth2;
	if (pm->modifyDepth) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	}
	isIndex = GL_FALSE;
	break;
      case GL_STENCIL_INDEX:
	reader = gc->procs.pixel.spanReadStencil2;
	if (pm->modifyStencil) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	}
	isIndex = GL_TRUE;
	break;
      case GL_COLOR_INDEX:
	reader = gc->procs.pixel.spanReadCI2;
	if (pm->modifyCI) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	} 
	isIndex = GL_TRUE;
	break;
    }

    /*
    ** Second step:  Reduce RGBA spans to appropriate derivative (RED, 
    ** LUMINANCE, ALPHA, etc.).
    */

    switch(format) {
      case GL_RGB:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceRGB;
	break;
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceBGR;
	break;
#endif
      case GL_RED:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceRed;
	break;
      case GL_GREEN:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceGreen;
	break;
      case GL_BLUE:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceBlue;
	break;
      case GL_LUMINANCE:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminance;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminanceAlpha;
	break;
      case GL_ALPHA:
	spanInfo->spanModifier[spanCount++] = __glSpanReduceAlpha;
	break;
      case GL_RGBA:
	spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
	break;
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
	spanInfo->spanModifier[spanCount++] = __glSpanUnscaleBGRA;
	break;
#endif
    }

    /*
    ** Third step:  Conversion from FLOAT to user requested type.
    */

    if (isIndex) {
	switch(type) {
	  case GL_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackByteI;
	    break;
	  case GL_UNSIGNED_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUbyteI;
	    break;
	  case GL_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackShortI;
	    break;
	  case GL_UNSIGNED_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUshortI;
	    break;
	  case GL_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackIntI;
	    break;
	  case GL_UNSIGNED_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUintI;
	    break;
	  case GL_BITMAP:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackBitmap;
	    break;
	}
    } else {
	switch(type) {
	  case GL_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackByte;
	    break;
	  case GL_UNSIGNED_BYTE:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUbyte;
	    break;
	  case GL_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackShort;
	    break;
	  case GL_UNSIGNED_SHORT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUshort;
	    break;
	  case GL_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackInt;
	    break;
	  case GL_UNSIGNED_INT:
	    spanInfo->spanModifier[spanCount++] = __glSpanPackUint;
	    break;
	}
    }

    /*
    ** Fourth step:  Mis-align data as needed, and perform byte swapping
    ** if requested by the user.
    */

    if (spanInfo->dstSwapBytes) {
	/* Byte swapping is necessary */
	if (spanInfo->dstElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2Dst;
	} else if (spanInfo->dstElementSize == 4) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4Dst;
	}
    } else if (type != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->dstImage)) & (spanInfo->dstElementSize - 1))) {
	/* Alignment is necessary */
	if (spanInfo->dstElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2Dst;
	} else if (spanInfo->dstElementSize == 4) {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4Dst;
	}
    }

    /*
    ** Pick a ReadPixels routine that uses the right number of span 
    ** modifiers.
    */

    spanInfo->spanReader = reader;
    switch(spanCount) {
      case 0:
	rpfn = __glReadPixels0;
	break;
      case 1:
	rpfn = __glReadPixels1;
	break;
      case 2:
	rpfn = __glReadPixels2;
	break;
      case 3:
	rpfn = __glReadPixels3;
	break;
      case 4:
	rpfn = __glReadPixels4;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 5:
	rpfn = __glReadPixels5;
	break;
    }
    (*rpfn)(gc, spanInfo);
}

/*
** This routine does two clips.  It clips like the DrawPixel clipper so 
** that if you try to copy to off window pixels, nothing will be done, and it 
** also clips like the ReadPixel clipper so that if you try to copy from
** off window pixels, nothing will be done.
*/
GLboolean FASTCALL __glClipCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat num, den;
    __GLfloat rpyUp, rpyDown;
    GLint rowsUp, rowsDown, startUp, startDown;
    __GLfloat midPoint;
    GLint intMidPoint, rowCount;
    GLint width, height;
    GLint readX, readY;
    __GLfloat zoomx, zoomy;
    __GLfloat rpx, rpy;
    __GLfloat rx1, rx2, ry1, ry2, wx1, wx2, wy1, wy2;
    __GLfloat abszoomy;
    GLint readUp, readDown;

    /*
    ** NOTE:
    ** A "nice" thing we could do for our application writers would be 
    ** to copy white when they try to copy from off window memory.  This
    ** would alert them to a bug in their program which they could then
    ** fix.
    **
    ** However, that seems like unnecessary code which would never be used
    ** anyway (no reason to bloat unnecessarily).
    */

    /*
    ** We take the easy approach, and just call the DrawPixels and ReadPixels
    ** clippers directly.
    */
    spanInfo->dstSkipLines = 0;
    spanInfo->dstSkipPixels = 0;
    if (!__glClipReadPixels(gc, spanInfo)) return GL_FALSE;
    spanInfo->x += spanInfo->dstSkipPixels * spanInfo->zoomx;
    spanInfo->y += spanInfo->dstSkipLines * spanInfo->zoomy;

    spanInfo->srcSkipLines = 0;
    spanInfo->srcSkipPixels = 0;
    if (!__glClipDrawPixels(gc, spanInfo)) return GL_FALSE;
    spanInfo->readX += spanInfo->srcSkipPixels;
    if (gc->constants.yInverted) {
	spanInfo->readY -= spanInfo->srcSkipLines;
    } else {
	spanInfo->readY += spanInfo->srcSkipLines;
    }

    /*
    ** Now for the incredibly tricky part!
    **
    ** This code attempts to deal with overlapping CopyPixels regions.
    ** It is a very difficult problem given that zoomy may be negative.
    ** The IrisGL used a cheap hack to solve this problem, which is 
    ** to read in the entire source image, and then write the destination
    ** image.  The problem with this approach, of course, is that it 
    ** requires a large amount of memory.
    **
    ** If zoomy can only be positive, then any image can be copied by
    ** copying a single span at a time, as long as you are careful about
    ** what order you process the spans.  However, since zoomy may be
    ** negative, the worst case images require copying two spans at 
    ** a time.  This means reading both spans, possibly modifying them,
    ** and then writing them back out. 
    **
    ** An example of this can be seen as follows:  Suppose an image
    ** covering 4 spans is copied onto itself with a zoomy of -1.  This
    ** means that the first row will be copied to the fourth row,
    ** and the fourth row will be copied to the first row.  In order 
    ** to accomplish both of these copies, they must be performed 
    ** simultaneously (after all, if you copy the first row to
    ** the fourth row first, then you have just destroyed the data 
    ** on the fourth row, and you can no longer copy it!).
    **
    ** In the most general case, any rectangular image can be copied
    ** by simultaneously iterating two spans over the source image
    ** and copying as you go.  Sometimes these spans will start at 
    ** the outside of the image and move their way inwards meeting 
    ** in the middle, and sometimes they will start in the middle 
    ** and work their way outward.
    **
    ** The middle point where the spans both start or end depends
    ** upon how the source and destination images overlap.  This point
    ** may be exactly in the middle, or at either end.  This means 
    ** that you may only end up with just a single span iterating over the 
    ** entire image (starting at one end and moving to the other).
    **
    ** The code that follows computes if the images overlap, and if they
    ** do, how two spans can be used to iterate over the source image
    ** so that it can be successfully copied to the destination image.
    **
    ** The following fields in the spanInfo record will be set in the 
    ** process of making these calculations:
    **
    ** overlap - set to GL_TRUE if the regions overlap at all.  Set to
    **		 GL_FALSE otherwise.
    **
    ** rowsUp, rowsDown - The number of rows of the source image that
    ** 			  need to be dealt with by the span that moves up
    **			  over the source image and the one that moves down
    **			  over the source image.  For example, if rowsUp is
    **			  equal to 10 and rowsDown is 0, then all 10 rows of 
    **			  the image should be copied by the up moving span
    **			  (the one that starts at readY and works it's way
    **			  up to readY+height).
    **
    ** startUp, startDown - At what relative points in time the spans should
    **			    start iterating.  For example, if startUp is 0
    **			    and startDown is 2, then the up moving span 
    **			    should be started first, and after it has 
    **			    iterated over 2 rows of the source image then
    **			    the down moving span should be started.
    **
    ** rpyUp, rpyDown - The starting raster positions for the two spans.
    **			These numbers are not exactly what they claim to
    **			be, but they are close.  They should be used by
    **			the span iterators in the following manner:  When
    **			the up moving span starts, it starts iterating 
    **			the float "rp_y" at rpyUp.  After reading and
    **			modifying a span, the span is written to rows
    **           	floor(rp_y) through floor(rp_y+zoomy) of the
    **			screen (not-inclusive of floor(rp_y+zoomy)).
    **			rp_y is then incremented by zoomy.  The same 
    **			algorithm is applied to the down moving span except
    **			that zoomy is subtracted from rp_y instead of
    **			being added.
    **
    ** readUp, readDown - The spans that are to be used for reading from
    **			  the source image.  The up moving span should start
    **			  reading at line "readUp", and the down moving span
    **			  should start at "readDown". 
    **
    ** Remember that the up moving and down moving spans must be iterated
    ** over the image simultaneously such that both spans are read before
    ** either one is written.
    **
    ** The actual algorithm applied here took many many hours of scratch 
    ** paper, and graph diagrams to derive.  It is very complicated, and
    ** hard to understand.  Do not attempt to change it without first
    ** understanding what it does completely.
    **
    ** In a nutshell, it first computes what span of the source image 
    ** will be copied onto itself (if any), and if |zoomy| < 1 it starts the
    ** up and down moving spans there and moves them outwards, or if 
    ** |zoomy| >= 1 it starts the spans at the outside of the image 
    ** and moves them inward so that they meet at the computed point.
    **
    ** Computing what span of the source image copies onto itself is 
    ** relatively easy.  For any span j of the source image from 0 through
    ** height, the span is read from row "readY + j" and written to
    ** any row centers falling within the range "rp_y + j * zoomy" through 
    ** "rp_y + (j+1) * zoomy".  If you set these equations equal to 
    ** each other (and subtract 0.5 from the raster position -- effectively
    ** moving the row centers from X.5 to X.0), you can determine that for 
    ** j = (readY - (rpy - 0.5)) / (zoomy-1) the source image concides with
    ** the destination image.  This is a floating point solution to a discrete
    ** problem, meaning that it is not a complete solution, but that is 
    ** the general idea.  Explaining this algorithm in any more detail would
    ** take another 1000 lines of comments, so I will leave it at that.
    */

    width = spanInfo->width;
    height = spanInfo->height;
    rpx = spanInfo->x;
    rpy = spanInfo->y;
    readX = spanInfo->readX;
    readY = spanInfo->readY;
    zoomx = spanInfo->zoomx;
    zoomy = spanInfo->zoomy;

    /* First check if the regions overlap at all */
    if (gc->constants.yInverted) {
	ry1 = readY - height + __glHalf;
	ry2 = readY - gc->constants.viewportAlmostHalf;
    } else {
	ry1 = readY + __glHalf;
	ry2 = readY + height - gc->constants.viewportAlmostHalf;
    }
    rx1 = readX + __glHalf;
    rx2 = readX + width - gc->constants.viewportAlmostHalf;
    if (zoomx > 0) {
	/* Undo some math done by ClipDrawPixels */
	rpx = rpx - gc->constants.viewportAlmostHalf;
	wx1 = rpx;
	wx2 = rpx + zoomx * width;
    } else {
	/* Undo some math done by ClipDrawPixels */
	rpx = rpx - gc->constants.viewportAlmostHalf + __glOne;
	wx1 = rpx + zoomx * width;
	wx2 = rpx;
    }
    if (zoomy > 0) {
	/* Undo some math done by ClipDrawPixels */
	rpy = rpy - gc->constants.viewportAlmostHalf;
	abszoomy = zoomy;
	wy1 = rpy;
	wy2 = rpy + zoomy * height;
    } else {
	/* Undo some math done by ClipDrawPixels */
	rpy = rpy - gc->constants.viewportAlmostHalf + __glOne;
	abszoomy = -zoomy;
	wy1 = rpy + zoomy * height;
	wy2 = rpy;
    }

    if (rx2 < wx1 || wx2 < rx1 || ry2 < wy1 || wy2 < ry1) {
	/* No overlap! */
	spanInfo->overlap = GL_FALSE;
	spanInfo->rowsUp = height;
	spanInfo->rowsDown = 0;
	spanInfo->startUp = 0;
	spanInfo->startDown = 0;
	spanInfo->rpyUp = rpy;
	spanInfo->rpyDown = rpy;
	return GL_TRUE;
    }

    spanInfo->overlap = GL_TRUE;

    /* Time to compute how we should set up our spans */
    if (gc->constants.yInverted) {
	num = (rpy - (__GLfloat) 0.5) - readY;
	den = -zoomy - 1;
    } else {
	num = readY - (rpy - (__GLfloat) 0.5);
	den = zoomy - 1;
    }
    startDown = startUp = 0;
    rowsUp = rowsDown = 0;
    rpyUp = rpy;
    rpyDown = rpy + zoomy*height;
    readUp = readY;
    if (gc->constants.yInverted) {
	readDown = readY - height + 1;
    } else {
	readDown = readY + height - 1;
    }

    if (den == __glZero) {
	/* Better not divide! */
	if (num > 0) {
	    midPoint = height;
	} else {
	    midPoint = 0;
	}
    } else {
	midPoint = num/den;
	if (midPoint < 0) {
	    midPoint = 0;
	} else if (midPoint > height) {
	    midPoint = height;
	}
    }
    if (midPoint == 0) {
	/* Only one span needed */
	if (abszoomy < __glOne) {
	    rowsUp = height;
	} else {
	    rowsDown = height;
	}
    } else if (midPoint == height) {
	/* Only one span needed */
	if (abszoomy < __glOne) {
	    rowsDown = height;
	} else {
	    rowsUp = height;
	}
    } else {
	/* Almost definitely need two spans to copy this image! */
	intMidPoint = __GL_CEILF(midPoint);

	rowCount = height - intMidPoint;
	if (intMidPoint > rowCount) {
	    rowCount = intMidPoint;
	}

	if (abszoomy > __glOne) {
	    GLint temp;

	    /* Move from outside of image inward */
	    startUp = rowCount - intMidPoint;
	    startDown = rowCount - (height - intMidPoint);
	    rowsUp = intMidPoint;
	    rowsDown = height - rowsUp;

	    if (gc->constants.yInverted) {
		temp = readY - intMidPoint + 1;
	    } else {
		temp = readY + intMidPoint - 1;
	    }

	    if (__GL_FLOORF( (temp - 
		    (rpy-__glHalf-gc->constants.viewportEpsilon)) 
		    / zoomy) == intMidPoint-1) {
		/* 
		** row "intMidPoint-1" copies exactly onto itself.  Let's 
		** make it the midpoint which we converge to.
		*/
		if (startDown) {
		    startDown--;
		} else {
		    startUp++;
		}
	    }
	} else {
	    /* Move from inside of image outward */
	    rowsDown = intMidPoint;
	    rowsUp = height - rowsDown;
	    rpyUp = rpyDown = rpy + zoomy * intMidPoint;
	    if (gc->constants.yInverted) {
		readUp = readY - intMidPoint;
		readDown = readY - intMidPoint + 1;
	    } else {
		readUp = readY + intMidPoint;
		readDown = readY + intMidPoint - 1;
	    }

	    if (__GL_FLOORF( (readDown - 
		    (rpy-__glHalf-gc->constants.viewportEpsilon))
		    / zoomy) == intMidPoint-1) {
		/* 
		** row "intMidPoint-1" copies exactly onto itself.  Let's
		** make it the midpoint which we diverge from.
		*/
		startUp = 1;
	    }
	}
    }

    /* 
    ** Adjust rpyUp and rpyDown so that they will change integer values 
    ** when fragments should be produced.  This basically takes the 0.5
    ** out of the inner loop when these spans are actually iterated.
    */
    if (zoomy > 0) {
	spanInfo->rpyUp = rpyUp + gc->constants.viewportAlmostHalf;
	spanInfo->rpyDown = rpyDown + gc->constants.viewportAlmostHalf - 
		__glOne;
    } else {
	spanInfo->rpyUp = rpyUp + gc->constants.viewportAlmostHalf - __glOne;
	spanInfo->rpyDown = rpyDown + gc->constants.viewportAlmostHalf;
    }
    spanInfo->startUp = startUp;
    spanInfo->startDown = startDown;
    spanInfo->rowsUp = rowsUp;
    spanInfo->rowsDown = rowsDown;
    spanInfo->readUp = readUp;
    spanInfo->readDown = readDown;

    return GL_TRUE;
}

void __glInitCopyPixelsInfo(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			    GLint x, GLint y, GLint width, GLint height, 
			    GLenum format)
{
    __GLfloat rpx, rpy;
    __GLfloat zoomx, zoomy;

    rpx = gc->state.current.rasterPos.window.x;
    rpy = gc->state.current.rasterPos.window.y;
    spanInfo->fragz = gc->state.current.rasterPos.window.z;

    spanInfo->x = rpx;
    spanInfo->y = rpy;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx > __glZero) {
	if (zoomx < __glOne) {
	    spanInfo->rendZoomx = __glOne;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = 1;
    } else {
	if (zoomx > (GLfloat) -1.0) {
	    spanInfo->rendZoomx = (GLfloat) -1.0;
	} else {
	    spanInfo->rendZoomx = zoomx;
	}
	spanInfo->coladd = -1;
    }
    spanInfo->zoomx = zoomx;
    zoomy = gc->state.pixel.transferMode.zoomY;
    if (gc->constants.yInverted) {
	zoomy = -zoomy;
    }
    if (zoomy > __glZero) {
	spanInfo->rowadd = 1;
    } else {
	spanInfo->rowadd = -1;
    }
    spanInfo->zoomy = zoomy;
    spanInfo->readX = x + gc->constants.viewportXAdjust;
    if (gc->constants.yInverted) {
	spanInfo->readY = (gc->constants.height - y - 1) + 
		gc->constants.viewportYAdjust;
    } else {
	spanInfo->readY = y + gc->constants.viewportYAdjust;
    }
    spanInfo->dstFormat = spanInfo->srcFormat = format;
    spanInfo->width = width;
    spanInfo->height = height;
}

/* 
** A CopyPixels with two span modifiers.
*/
void FASTCALL __glCopyPixels2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat newy;
    __GLfloat zoomy;
    GLint inty, i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    i = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glCopyPixels2_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    if (spanInfo->overlap) {
#ifdef NT
        gcTempFree(gc, spanData1);
        gcTempFree(gc, spanData2);
#endif
	__glCopyPixelsOverlapping(gc, spanInfo, 2);
#ifdef NT
        gcTempFree(gc, pixelArray);
#endif
	return;
    }

    reader = spanInfo->spanReader;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    render = spanInfo->spanRender;

    ySign = gc->constants.ySign;
    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->readY += ySign;
	    spanInfo->y = newy;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*span2)(gc, spanInfo, spanData2, spanData1);
	(*render)(gc, spanInfo, spanData1);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glCopyPixels2_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** A CopyPixels with one span modifier.
*/
void FASTCALL __glCopyPixels1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat newy;
    __GLfloat zoomy;
    GLint inty, i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;
    GLshort *pixelArray;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    i = spanInfo->width * sizeof(GLshort);
    pixelArray = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2 || !pixelArray)
        goto __glCopyPixels1_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    if (spanInfo->overlap) {
#ifdef NT
        gcTempFree(gc, spanData1);
        gcTempFree(gc, spanData2);
#endif
	__glCopyPixelsOverlapping(gc, spanInfo, 1);
#ifdef NT
        gcTempFree(gc, pixelArray);
#endif
	return;
    }

    reader = spanInfo->spanReader;
    span1 = spanInfo->spanModifier[0];
    render = spanInfo->spanRender;

    ySign = gc->constants.ySign;
    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->readY += ySign;
	    spanInfo->y = newy;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*reader)(gc, spanInfo, spanData1);
	(*span1)(gc, spanInfo, spanData1, spanData2);
	(*render)(gc, spanInfo, spanData2);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glCopyPixels1_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/* 
** Copy pixels with no span modifiers.
*/
void FASTCALL __glCopyPixels0(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLfloat newy;
    __GLfloat zoomy;
    GLint inty, i, ySign;
    GLint height;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1;
    GLshort *pixelArray;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    pixelArray = gcTempAlloc(gc, spanInfo->width * sizeof(GLshort));
    if (!spanData1 || !pixelArray)
        goto __glCopyPixels0_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLshort pixelArray[__GL_MAX_MAX_VIEWPORT];
#endif

    spanInfo->pixelArray = pixelArray;
    __glComputeSpanPixelArray(gc, spanInfo);

    if (spanInfo->overlap) {
#ifdef NT
        gcTempFree(gc, spanData1);
#endif
	__glCopyPixelsOverlapping(gc, spanInfo, 0);
#ifdef NT
        gcTempFree(gc, pixelArray);
#endif
	return;
    }

    reader = spanInfo->spanReader;
    render = spanInfo->spanRender;

    ySign = gc->constants.ySign;
    zoomy = spanInfo->zoomy;
    inty = (GLint) spanInfo->y;
    newy = spanInfo->y;
    height = spanInfo->height;
    for (i=0; i<height; i++) {
	spanInfo->y = newy;
	newy += zoomy;
	while ((GLint) newy == inty && i<height) {
	    spanInfo->readY += ySign;
	    spanInfo->y = newy;
	    newy += zoomy;
	    i++;
	    ASSERTOPENGL(i != height, "Zoomed off surface\n");
	}
	inty = (GLint) newy;
	(*reader)(gc, spanInfo, spanData1);
	(*render)(gc, spanInfo, spanData1);
	spanInfo->readY += ySign;
    }
#ifdef NT
__glCopyPixels0_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (pixelArray) gcTempFree(gc, pixelArray);
#endif
}

/*
** Yick!  
**
** This routine is provided to perform CopyPixels when the source and
** destination images overlap.  
**
** It is not designed to go particularly fast, but then overlapping
** copies is probably not too common, and this routine is not typically a 
** large part of the execution overhead anyway.
**
** For more information on copying an image which overlaps its destination,
** check out the hairy comment within the __glClipCopyPixels function.
*/
void FASTCALL __glCopyPixelsOverlapping(__GLcontext *gc,
			       __GLpixelSpanInfo *spanInfo, GLint modifiers)
{
    GLint i;
    __GLfloat zoomy, newy;
    GLint inty, ySign;
    GLubyte *outSpan1, *outSpan2;
    GLint rowsUp, rowsDown;
    GLint startUp, startDown;
    __GLfloat rpyUp, rpyDown;
    GLint readUp, readDown;
    GLint gotUp, gotDown;
    __GLpixelSpanInfo downSpanInfo;
    GLint clipLow, clipHigh;
    GLint startRow, endRow;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
#ifdef NT
    GLubyte *spanData1, *spanData2, *spanData3;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    spanData3 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2 || !spanData3)
        goto __glCopyPixelsOverlapping_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE], spanData2[__GL_MAX_SPAN_SIZE];
    GLubyte spanData3[__GL_MAX_SPAN_SIZE];
#endif

    reader = spanInfo->spanReader;
    render = spanInfo->spanRender;

    if (modifiers & 1) {
	outSpan1 = outSpan2 = spanData3;
    } else {
	outSpan1 = spanData1;
	outSpan2 = spanData2;
    }

    zoomy = spanInfo->zoomy;
    rowsUp = spanInfo->rowsUp;
    rowsDown = spanInfo->rowsDown;
    startUp = spanInfo->startUp;
    startDown = spanInfo->startDown;
    rpyUp = spanInfo->rpyUp;
    rpyDown = spanInfo->rpyDown;
    readUp = spanInfo->readUp;
    readDown = spanInfo->readDown;
    downSpanInfo = *spanInfo;
    downSpanInfo.rowadd = -spanInfo->rowadd;
    downSpanInfo.zoomy = -zoomy;
    spanInfo->y = rpyUp;
    downSpanInfo.y = rpyDown;
    spanInfo->readY = readUp;
    downSpanInfo.readY = readDown;
    gotUp = gotDown = 0;
    ySign = gc->constants.ySign;

    /* Clip upgoing and downgoing spans */
    if (zoomy > 0) {
	clipLow = spanInfo->startRow;
	clipHigh = spanInfo->startRow + spanInfo->rows - 1;

	/* Clip down span first */
	startRow = (GLint) rpyDown;
	endRow = (GLint) (rpyDown - zoomy*rowsDown) + 1;
	if (startRow > clipHigh) startRow = clipHigh;
	if (endRow < clipLow) endRow = clipLow;
	downSpanInfo.startRow = startRow;
	downSpanInfo.rows = startRow - endRow + 1;

	/* Now clip up span */
	startRow = (GLint) rpyUp;
	endRow = (GLint) (rpyUp + zoomy*rowsUp) - 1;
	if (startRow < clipLow) startRow = clipLow;
	if (endRow > clipHigh) endRow = clipHigh;
	spanInfo->startRow = startRow;
	spanInfo->rows = endRow - startRow + 1;
    } else /* zoomy < 0 */ {
	clipHigh = spanInfo->startRow;
	clipLow = spanInfo->startRow - spanInfo->rows + 1;

	/* Clip down span first */
	startRow = (GLint) rpyDown;
	endRow = (GLint) (rpyDown - zoomy*rowsDown) - 1;
	if (startRow < clipLow) startRow = clipLow;
	if (endRow > clipHigh) endRow = clipHigh;
	downSpanInfo.startRow = startRow;
	downSpanInfo.rows = endRow - startRow + 1;

	/* Now clip up span */
	startRow = (GLint) rpyUp;
	endRow = (GLint) (rpyUp + zoomy*rowsUp) + 1;
	if (startRow > clipHigh) startRow = clipHigh;
	if (endRow < clipLow) endRow = clipLow;
	spanInfo->startRow = startRow;
	spanInfo->rows = startRow - endRow + 1;
    }

    while (rowsUp && rowsDown) {
	if (startUp) {
	    startUp--;
	} else {
	    gotUp = 1;
	    rowsUp--;
	    spanInfo->y = rpyUp;
	    newy = rpyUp + zoomy;
	    inty = (GLint) rpyUp;
	    while (rowsUp && (GLint) newy == inty) {
		spanInfo->y = newy;
		newy += zoomy;
		rowsUp--;
		spanInfo->readY += ySign;
	    }
	    if (inty == (GLint) newy) break;
	    rpyUp = newy;
	    (*reader)(gc, spanInfo, spanData1);
	    spanInfo->readY += ySign;
	}
	if (startDown) {
	    startDown--;
	} else {
	    gotDown = 1;
	    rowsDown--;
	    downSpanInfo.y = rpyDown;
	    newy = rpyDown - zoomy;
	    inty = (GLint) rpyDown;
	    while (rowsDown && (GLint) newy == inty) {
		downSpanInfo.y = newy;
		newy -= zoomy;
		rowsDown--;
		downSpanInfo.readY -= ySign;
	    }
	    if (inty == (GLint) newy) {
		if (gotUp) {
		    for (i=0; i<modifiers; i++) {
			if (i & 1) {
			    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
				    spanData3, spanData1);
			} else {
			    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
				    spanData1, spanData3);
			}
		    }
		    (*render)(gc, spanInfo, outSpan1);
		}
		break;
	    }
	    rpyDown = newy;
	    (*reader)(gc, &downSpanInfo, spanData2);
	    downSpanInfo.readY -= ySign;
	}

	if (gotUp) {
	    for (i=0; i<modifiers; i++) {
		if (i & 1) {
		    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			    spanData3, spanData1);
		} else {
		    (*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			    spanData1, spanData3);
		}
	    }
	    (*render)(gc, spanInfo, outSpan1);
	}

	if (gotDown) {
	    for (i=0; i<modifiers; i++) {
		if (i & 1) {
		    (*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			    spanData3, spanData2);
		} else {
		    (*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			    spanData2, spanData3);
		}
	    }
	    (*render)(gc, &downSpanInfo, outSpan2);
	}
    }

    /*
    ** Only one of the spanners is left to iterate.
    */

    while (rowsUp) {
	/* Do what is left of up spans */
	rowsUp--;
	spanInfo->y = rpyUp;
	newy = rpyUp + zoomy;
	inty = (GLint) rpyUp;
	while (rowsUp && (GLint) newy == inty) {
	    spanInfo->y = newy;
	    newy += zoomy;
	    rowsUp--;
	    spanInfo->readY += ySign;
	}
	if (inty == (GLint) newy) break;
	rpyUp = newy;

	(*reader)(gc, spanInfo, spanData1);
	for (i=0; i<modifiers; i++) {
	    if (i & 1) {
		(*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			spanData3, spanData1);
	    } else {
		(*(spanInfo->spanModifier[i]))(gc, spanInfo, 
			spanData1, spanData3);
	    }
	}
	(*render)(gc, spanInfo, outSpan1);

	spanInfo->readY += ySign;
    }

    while (rowsDown) {
	/* Do what is left of down spans */
	rowsDown--;
	downSpanInfo.y = rpyDown;
	newy = rpyDown - zoomy;
	inty = (GLint) rpyDown;
	while (rowsDown && (GLint) newy == inty) {
	    downSpanInfo.y = newy;
	    newy -= zoomy;
	    rowsDown--;
	    downSpanInfo.readY -= ySign;
	}
	if (inty == (GLint) newy) break;
	rpyDown = newy;

	(*reader)(gc, &downSpanInfo, spanData2);
	for (i=0; i<modifiers; i++) {
	    if (i & 1) {
		(*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			spanData3, spanData2);
	    } else {
		(*(spanInfo->spanModifier[i]))(gc, &downSpanInfo, 
			spanData2, spanData3);
	    }
	}
	(*render)(gc, &downSpanInfo, outSpan2);

	downSpanInfo.readY -= ySign;
    }
#ifdef NT
__glCopyPixelsOverlapping_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
    if (spanData3)  gcTempFree(gc, spanData3);
#endif
}

/*
** Generic implementation of a CopyPixels picker.  Any machine specific
** implementation should provide their own.
*/
void __glSlowPickCopyPixels(__GLcontext *gc, GLint x, GLint y, GLint width,
		            GLint height, GLenum type)
{
    __GLpixelSpanInfo spanInfo;

    __glInitCopyPixelsInfo(gc, &spanInfo, x, y, width, height, type);
    if (!__glClipCopyPixels(gc, &spanInfo)) return;

    __glGenericPickCopyPixels(gc, &spanInfo);
}

/*
** Generic picker for CopyPixels.  This should be called if no machine
** specific path is provided for this specific version of CopyPixels.
*/
void FASTCALL __glGenericPickCopyPixels(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    __GLpixelMachine *pm;
    void (FASTCALL *reader)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *outspan);
    void (FASTCALL *render)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
		   GLvoid *inspan);
    void (FASTCALL *cpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);
    GLint spanCount;
    GLboolean zoomx1;		/* -1 <= zoomx <= 1? */
    GLboolean zoomx2;		/* zoomx <= -1 || zoomx >= 1 */
    __GLfloat zoomx;
    GLenum format;

    pm = &gc->pixel;
    spanCount = 0;
    zoomx = gc->state.pixel.transferMode.zoomX;
    if (zoomx >= (__GLfloat) -1.0 && zoomx <= __glOne) {
	zoomx1 = GL_TRUE;
    } else {
	zoomx1 = GL_FALSE;
    }
    if (zoomx <= (__GLfloat) -1.0 || zoomx >= __glOne) {
	zoomx2 = GL_TRUE;
    } else {
	zoomx2 = GL_FALSE;
    }
    format = spanInfo->dstFormat;

#ifdef NT
    // Special case RGB copying to use a DIB
    // Also special case copying the Z buffer
    if (format == GL_RGBA)
    {
        GLuint enables = gc->state.enables.general;

        // Look to see if we're doing direct buffer-to-buffer copying
        // Things that can't be allowed are depth testing,
        // fogging, blending or anything that prevents the input data
        // from going directly into the destination buffer

        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            !pm->modifyRGBA &&
            (enables & (__GL_DITHER_ENABLE |
                        __GL_ALPHA_TEST_ENABLE |
                        __GL_STENCIL_TEST_ENABLE |
                        __GL_DEPTH_TEST_ENABLE |
                        __GL_BLEND_ENABLE |
                        __GL_INDEX_LOGIC_OP_ENABLE |
                        __GL_COLOR_LOGIC_OP_ENABLE |
                        __GL_FOG_ENABLE)) == 0 &&
            gc->state.raster.drawBuffer != GL_NONE &&
            gc->state.raster.drawBuffer != GL_FRONT_AND_BACK &&
            !gc->texture.textureEnabled &&
            (gc->drawBuffer->buf.flags & COLORMASK_ON) == 0
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (CopyRgbPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
    else if (format == GL_DEPTH_COMPONENT)
    {
        // If the Z test is GL_ALWAYS and there is no draw buffer
        // then the application is simply copying Z values around
        // the Z buffer.
        if (zoomx == __glOne &&
            gc->state.pixel.transferMode.zoomY == __glOne &&
            !pm->modifyDepth &&
            gc->state.raster.drawBuffer == GL_NONE &&
            (gc->state.enables.general & __GL_DEPTH_TEST_ENABLE) &&
            gc->state.depth.testFunc == GL_ALWAYS &&
            gc->modes.haveDepthBuffer
#ifdef _MCD_
            && ((__GLGENcontext *)gc)->pMcdState == NULL
#endif
           )
        {
            if (CopyZPixels(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif

    switch(format) {
      case GL_RGBA:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadRGBA2;
	} else {
	    reader = gc->procs.pixel.spanReadRGBA;
	}
	if (pm->modifyRGBA) {
	    spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderRGBA2;
	} else {
	    render = gc->procs.pixel.spanRenderRGBA;
	}
	break;
      case GL_COLOR_INDEX:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadCI2;
	} else {
	    reader = gc->procs.pixel.spanReadCI;
	}
	if (pm->modifyCI) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderCI2;
	} else {
	    render = gc->procs.pixel.spanRenderCI;
	}
	break;
      case GL_STENCIL_INDEX:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadStencil2;
	} else {
	    reader = gc->procs.pixel.spanReadStencil;
	}
	if (pm->modifyStencil) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderStencil2;
	} else {
	    render = gc->procs.pixel.spanRenderStencil;
	}
	break;
      case GL_DEPTH_COMPONENT:
	if (zoomx2) {
	    reader = gc->procs.pixel.spanReadDepth2;
	} else {
	    reader = gc->procs.pixel.spanReadDepth;
	}
	if (pm->modifyDepth) {
	    spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	}
	if (zoomx1) {
	    render = gc->procs.pixel.spanRenderDepth2;
	} else {
	    render = gc->procs.pixel.spanRenderDepth;
	}
	break;
    }

    switch(spanCount) {
      case 0:
	cpfn = __glCopyPixels0;
	break;
      case 1:
	cpfn = __glCopyPixels1;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 2:
	cpfn = __glCopyPixels2;
	break;
    }

    spanInfo->spanReader = reader;
    spanInfo->spanRender = render;

    (*cpfn)(gc, spanInfo);
}

/*
** A simple image copying routine with one span modifier.
*/
void FASTCALL __glCopyImage1(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanInfo->dstCurrent);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
}

/*
** A simple image copying routine with two span modifiers.
*/
void FASTCALL __glCopyImage2(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1;

    spanData1 = gcTempAlloc(gc, spanInfo->width * 4 * sizeof(GLfloat));
    if (!spanData1)
        return;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
    gcTempFree(gc, spanData1);
#endif
}

/*
** A simple image copying routine with three span modifiers.
*/
void FASTCALL __glCopyImage3(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage3_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage3_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with four span modifiers.
*/
void FASTCALL __glCopyImage4(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage4_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage4_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with five span modifiers.
*/
void FASTCALL __glCopyImage5(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage5_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*span5)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage5_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with six span modifiers.
*/
void FASTCALL __glCopyImage6(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span6)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage6_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    span6 = spanInfo->spanModifier[5];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*span5)(gc, spanInfo, spanData2, spanData1);
	(*span6)(gc, spanInfo, spanData1, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage6_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** A simple image copying routine with seven span modifiers.
*/
void FASTCALL __glCopyImage7(__GLcontext *gc, __GLpixelSpanInfo *spanInfo)
{
    GLint i;
    GLint height;
    void (*span1)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span2)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span3)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span4)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span5)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span6)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
    void (*span7)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
	          GLvoid *inspan, GLvoid *outspan);
#ifdef NT
    GLubyte *spanData1, *spanData2;

    i = spanInfo->width * 4 * sizeof(GLfloat);
    spanData1 = gcTempAlloc(gc, i);
    spanData2 = gcTempAlloc(gc, i);
    if (!spanData1 || !spanData2)
        goto __glCopyImage7_exit;
#else
    GLubyte spanData1[__GL_MAX_SPAN_SIZE];
    GLubyte spanData2[__GL_MAX_SPAN_SIZE];
#endif

    height = spanInfo->height;
    span1 = spanInfo->spanModifier[0];
    span2 = spanInfo->spanModifier[1];
    span3 = spanInfo->spanModifier[2];
    span4 = spanInfo->spanModifier[3];
    span5 = spanInfo->spanModifier[4];
    span6 = spanInfo->spanModifier[5];
    span7 = spanInfo->spanModifier[6];
    for (i=0; i<height; i++) {
	(*span1)(gc, spanInfo, spanInfo->srcCurrent, spanData1);
	spanInfo->srcCurrent = (GLubyte *) spanInfo->srcCurrent + 
		spanInfo->srcRowIncrement;
	(*span2)(gc, spanInfo, spanData1, spanData2);
	(*span3)(gc, spanInfo, spanData2, spanData1);
	(*span4)(gc, spanInfo, spanData1, spanData2);
	(*span5)(gc, spanInfo, spanData2, spanData1);
	(*span6)(gc, spanInfo, spanData1, spanData2);
	(*span7)(gc, spanInfo, spanData2, spanInfo->dstCurrent);
	spanInfo->dstCurrent = (GLubyte *) spanInfo->dstCurrent +
		spanInfo->dstRowIncrement;
    }
#ifdef NT
__glCopyImage7_exit:
    if (spanData1)  gcTempFree(gc, spanData1);
    if (spanData2)  gcTempFree(gc, spanData2);
#endif
}

/*
** Internal image processing routine.  Used by GetTexImage to transfer from
** internal texture image to the user.  Used by TexImage[12]D to transfer
** from the user to internal texture.  Used for display list optimization of
** textures and DrawPixels.
**
** This routine also supports the pixel format mode __GL_RED_ALPHA which is
** basically a 2 component texture.
**
** If applyPixelTransfer is set to GL_TRUE, pixel transfer modes will be 
** applied as necessary.
*/
void FASTCALL __glGenericPickCopyImage(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			      GLboolean applyPixelTransfer)
{
    GLint spanCount;
    GLboolean srcPackedData;
    GLenum srcType, srcFormat;
    GLboolean srcSwap;
    GLboolean srcAlign;
    GLboolean srcConvert;
    GLboolean srcExpand;
    GLboolean srcClamp;
    GLenum dstType, dstFormat;
    GLboolean dstSwap;
    GLboolean dstAlign;
    GLboolean dstConvert;
    GLboolean dstReduce;
    GLboolean modify;
    __GLpixelMachine *pm;
    void (FASTCALL *cpfn)(__GLcontext *gc, __GLpixelSpanInfo *spanInfo);

    pm = &gc->pixel;
    spanCount = 0;
    srcPackedData = spanInfo->srcPackedData;
    srcType = spanInfo->srcType;
    srcFormat = spanInfo->srcFormat;
    dstType = spanInfo->dstType;
    dstFormat = spanInfo->dstFormat;

    switch(srcFormat) {
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case __GL_RED_ALPHA:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
#ifdef GL_EXT_paletted_texture
      case __GL_PALETTE_INDEX:
#endif
	modify = applyPixelTransfer && pm->modifyRGBA;
	break;
      case GL_DEPTH_COMPONENT:
	modify = applyPixelTransfer && pm->modifyDepth;
	break;
      case GL_STENCIL_INDEX:
	modify = applyPixelTransfer && pm->modifyStencil;
	break;
      case GL_COLOR_INDEX:
	modify = applyPixelTransfer && pm->modifyCI;
	break;
    }

    if ((srcFormat == dstFormat || 
	    (srcFormat == GL_LUMINANCE_ALPHA && dstFormat == __GL_RED_ALPHA) ||
	    (srcFormat == __GL_RED_ALPHA && dstFormat == GL_LUMINANCE_ALPHA) ||
	    (srcFormat == GL_LUMINANCE && dstFormat == GL_RED) ||
	    (srcFormat == GL_RED && dstFormat == GL_LUMINANCE)) && !modify) {
	srcExpand = GL_FALSE;
	dstReduce = GL_FALSE;
    } else {
	srcExpand = GL_TRUE;
	dstReduce = GL_TRUE;
    }

    if (srcType == GL_FLOAT) {
	srcConvert = GL_FALSE;
    } else {
	srcConvert = GL_TRUE;
    }
    if (dstType == GL_FLOAT) {
	dstConvert = GL_FALSE;
    } else {
	dstConvert = GL_TRUE;
    }

    if (spanInfo->srcSwapBytes && spanInfo->srcElementSize > 1) {
	srcSwap = GL_TRUE;
    } else {
	srcSwap = GL_FALSE;
    }
    if (spanInfo->dstSwapBytes && spanInfo->dstElementSize > 1) {
	dstSwap = GL_TRUE;
    } else {
	dstSwap = GL_FALSE;
    }

    if (srcType != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->srcImage)) & (spanInfo->srcElementSize - 1))) {
	srcAlign = GL_TRUE;
    } else {
	srcAlign = GL_FALSE;
    }
    if (dstType != GL_BITMAP &&
	    (((INT_PTR) (spanInfo->dstImage)) & (spanInfo->dstElementSize - 1))) {
	dstAlign = GL_TRUE;
    } else {
	dstAlign = GL_FALSE;
    }

    if (srcType == GL_BITMAP || srcType == GL_UNSIGNED_BYTE ||
            srcType == GL_UNSIGNED_SHORT || srcType == GL_UNSIGNED_INT ||
            srcFormat == GL_COLOR_INDEX || srcFormat == GL_STENCIL_INDEX ||
	    modify) {
        srcClamp = GL_FALSE;
    } else {
        srcClamp = GL_TRUE;
    }

    if (srcType == dstType && srcType != GL_BITMAP && !srcExpand && !srcClamp) {
	srcConvert = dstConvert = GL_FALSE;
    }

#ifdef NT
    // Special case copying where it's a straight data copy from
    // the source to the destination
    if (!srcSwap && !srcAlign && !srcConvert && !srcClamp && !srcExpand &&
        !dstReduce && !dstConvert && !dstSwap && !dstAlign)
    {
        if (CopyAlignedImage(gc, spanInfo))
        {
            return;
        }
    }
    else if (srcType == GL_UNSIGNED_BYTE && dstType == GL_UNSIGNED_BYTE &&
             !srcAlign && !dstAlign)
    {
        // Special case expanding a 24-bit RGB texture into 32-bit BGRA
        if (srcFormat == GL_RGB && dstFormat == GL_BGRA_EXT)
        {
            if (CopyRgbToBgraImage(gc, spanInfo))
            {
                return;
            }
        }
        // Special case flipping a 32-bit RGBA texture into 32-bit BGRA
        else if (srcFormat == GL_RGBA && dstFormat == GL_BGRA_EXT)
        {
            if (CopyRgbaToBgraImage(gc, spanInfo))
            {
                return;
            }
        }
        // Special case expanding a 24-bit BGR texture into 32-bit BGRA
        else if (srcFormat == GL_BGR_EXT && dstFormat == GL_BGRA_EXT)
        {
            if (CopyBgrToBgraImage(gc, spanInfo))
            {
                return;
            }
        }
    }
#endif
    
    /* 
    ** First step:  Swap, align the data, etc. 
    */
    if (srcSwap) {
	if (spanInfo->srcElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2;
	} else /* spanInfo->srcElementSize == 4 */ {
	    spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4;
	}
    } else if (srcAlign) {
	if (spanInfo->srcElementSize == 2) {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2;
	} else /* spanInfo->srcElementSize == 4 */ {
	    spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4;
	}
    }


    /* 
    ** Second step:  conversion to float
    */
    if (srcConvert) {
        if (srcFormat == GL_COLOR_INDEX || srcFormat == GL_STENCIL_INDEX) {
            /* Index conversion */
            switch(srcType) {
              case GL_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackByteI;
                break;
              case GL_UNSIGNED_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyteI;
                break;
              case GL_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackShortI;
                break;
              case GL_UNSIGNED_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshortI;
                break;
              case GL_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackIntI;
                break;
              case GL_UNSIGNED_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUintI;
                break;
	      case GL_BITMAP:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap2;
		break;
            }
        } else {
            /* Component conversion */
            switch(srcType) {
              case GL_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackByte;
                break;
              case GL_UNSIGNED_BYTE:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUbyte;
                break;
              case GL_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackShort;
                break;
              case GL_UNSIGNED_SHORT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUshort;
                break;
              case GL_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackInt;
                break;
              case GL_UNSIGNED_INT:
                spanInfo->spanModifier[spanCount++] = __glSpanUnpackUint;
                break;
	      case GL_BITMAP:
		spanInfo->spanModifier[spanCount++] = __glSpanUnpackBitmap2;
		break;
            }
        }
    }

    /*
    ** Third step:  Clamp if necessary.
    */
    if (srcClamp) {
        switch(srcType) {
          case GL_BYTE:
          case GL_SHORT:
          case GL_INT:
            spanInfo->spanModifier[spanCount++] = __glSpanClampSigned;
            break;
          case GL_FLOAT:
            spanInfo->spanModifier[spanCount++] = __glSpanClampFloat;
            break;
        }
    }

    /*
    ** Fourth step:  Expansion to RGBA, Modification and scale colors (sortof a
    **   side effect).
    */
    if (srcExpand) {
	switch(srcFormat) {
	  case GL_RED:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRed;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandRed;
	    }
	    break;
	  case GL_GREEN:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyGreen;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandGreen;
	    }
	    break;
	  case GL_BLUE:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyBlue;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandBlue;
	    }
	    break;
	  case GL_ALPHA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyAlpha;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandAlpha;
	    }
	    break;
	  case GL_RGB:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandRGB;
	    }
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGR_EXT:
	    if (modify) {
                // __glSpanModifyRGB handles both RGB and BGR
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGB;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandBGR;
	    }
	    break;
#endif
	  case GL_LUMINANCE:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyLuminance;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandLuminance;
	    }
	    break;
	  case GL_LUMINANCE_ALPHA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanModifyLuminanceAlpha;
	    } else {
		spanInfo->spanModifier[spanCount++] = 
			__glSpanExpandLuminanceAlpha;
	    }
	    break;
	  case __GL_RED_ALPHA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRedAlpha;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanExpandRedAlpha;
	    }
	    break;
	  case GL_RGBA:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanScaleRGBA;
	    }
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGRA_EXT:
	    if (modify) {
                // __glSpanModifyRGBA handles both RGBA and BGRA
		spanInfo->spanModifier[spanCount++] = __glSpanModifyRGBA;
	    } else {
		spanInfo->spanModifier[spanCount++] = __glSpanScaleBGRA;
	    }
	    break;
#endif
	  case GL_DEPTH_COMPONENT:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyDepth;
	    }
	    break;
	  case GL_STENCIL_INDEX:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyStencil;
	    }
	    break;
	  case GL_COLOR_INDEX:
	    if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyCI;
	    }
	    break;
#ifdef GL_EXT_paletted_texture
          case __GL_PALETTE_INDEX:
            if (modify) {
		spanInfo->spanModifier[spanCount++] = __glSpanModifyPI;
            } else {
		spanInfo->spanModifier[spanCount++] = __glSpanScalePI;
            }
            break;
#endif
	}
    }

    /*
    ** Fifth step:  Reduce RGBA spans to appropriate derivative (RED,
    **   LUMINANCE, ALPHA, etc.).
    */
    if (dstReduce) {
	switch(dstFormat) {
	  case GL_RGB:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceRGB;
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGR_EXT:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceBGR;
	    break;
#endif
	  case GL_RED:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceRed;
	    break;
	  case GL_GREEN:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceGreen;
	    break;
	  case GL_BLUE:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceBlue;
	    break;
	  case GL_LUMINANCE:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminance;
	    break;
	  case GL_LUMINANCE_ALPHA:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceLuminanceAlpha;
	    break;
	  case __GL_RED_ALPHA:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceRedAlpha;
	    break;
	  case GL_ALPHA:
	    spanInfo->spanModifier[spanCount++] = __glSpanReduceAlpha;
	    break;
	  case GL_RGBA:
	    spanInfo->spanModifier[spanCount++] = __glSpanUnscaleRGBA;
	    break;
#ifdef GL_EXT_bgra
	  case GL_BGRA_EXT:
	    spanInfo->spanModifier[spanCount++] = __glSpanUnscaleBGRA;
	    break;
#endif
#ifdef NT
          case GL_COLOR_INDEX:
            break;
          default:
            // We should never be asked to reduce to palette indices
            // so add this assert to catch such a request
            ASSERTOPENGL(FALSE, "Unhandled copy_image reduction\n");
            break;
#endif
	}
    }

    /*
    ** Sixth step:  Conversion from FLOAT to requested type.
    */
    if (dstConvert) {
        if (dstFormat == GL_COLOR_INDEX || dstFormat == GL_STENCIL_INDEX) {
	    switch(dstType) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackByteI;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUbyteI;
		break;
	      case GL_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackShortI;
		break;
	      case GL_UNSIGNED_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUshortI;
		break;
	      case GL_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackIntI;
		break;
	      case GL_UNSIGNED_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUintI;
		break;
	      case GL_BITMAP:
		spanInfo->spanModifier[spanCount++] = __glSpanPackBitmap;
		break;
	    }
	} else {
	    switch(dstType) {
	      case GL_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackByte;
		break;
	      case GL_UNSIGNED_BYTE:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUbyte;
		break;
	      case GL_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackShort;
		break;
	      case GL_UNSIGNED_SHORT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUshort;
		break;
	      case GL_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackInt;
		break;
	      case GL_UNSIGNED_INT:
		spanInfo->spanModifier[spanCount++] = __glSpanPackUint;
		break;
	    }
	}
    }

    /*
    ** Seventh step:  Mis-align data as needed, and perform byte swapping
    **   if requested by the user.
    */
    if (dstSwap) {
        if (spanInfo->dstElementSize == 2) {
            spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes2Dst;
        } else /* if (spanInfo->dstElementSize == 4) */ {
            spanInfo->spanModifier[spanCount++] = __glSpanSwapBytes4Dst;
        }
    } else if (dstAlign) {
        if (spanInfo->dstElementSize == 2) {
            spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels2Dst;
        } else /* if (spanInfo->dstElementSize == 4) */ {
            spanInfo->spanModifier[spanCount++] = __glSpanAlignPixels4Dst;
        }
    }

    /*
    ** Sanity check:  If we have zero span routines, then this simply
    **   isn't going to work.  We need to at least copy the data.
    */
    if (spanCount == 0) {
	spanInfo->spanModifier[spanCount++] = __glSpanCopy;
    }

    /*
    ** Final step:  Pick a copying function.
    */
    switch(spanCount) {
      case 1:
	cpfn = __glCopyImage1;
	break;
      case 2:
	cpfn = __glCopyImage2;
	break;
      case 3:
	cpfn = __glCopyImage3;
	break;
      case 4:
	cpfn = __glCopyImage4;
	break;
      case 5:
	cpfn = __glCopyImage5;
	break;
      case 6:
	cpfn = __glCopyImage6;
	break;
      default:
        ASSERTOPENGL(FALSE, "Default hit\n");
      case 7:
	cpfn = __glCopyImage7;
	break;
    }

    (*cpfn)(gc, spanInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_attri.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include "lighting.h"

#ifdef unix
#include <GL/glxproto.h>
#endif

void APIPRIVATE __glim_AlphaFunc(GLenum af, GLfloat ref)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((af < GL_NEVER) || (af > GL_ALWAYS)) {
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    if (__GL_FLOAT_LTZ (ref)) ref = __glZero;
    if (__GL_FLOAT_COMPARE_PONE (ref, >)) ref = __glOne;

    if ((gc->state.raster.alphaFunction != af) || 
        __GL_FLOAT_NE (gc->state.raster.alphaReference, ref)) {
        gc->state.raster.alphaFunction = af;
        gc->state.raster.alphaReference = ref;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ALPHATEST);
#endif
        gc->validateMask |= __GL_VALIDATE_ALPHA_FUNC;
    }
}

void APIPRIVATE __glim_BlendFunc(GLenum sf, GLenum df)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (sf) {
      case GL_ZERO:
      case GL_ONE:
      case GL_DST_COLOR:
      case GL_ONE_MINUS_DST_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
      case GL_SRC_ALPHA_SATURATE:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (df) {
      case GL_ZERO:
      case GL_ONE:
      case GL_SRC_COLOR:
      case GL_ONE_MINUS_SRC_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    if ((gc->state.raster.blendSrc != sf) || 
        (gc->state.raster.blendDst != df)) {
        gc->state.raster.blendSrc = sf;
        gc->state.raster.blendDst = df;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, BLEND);
#endif
    }
}

void APIPRIVATE __glim_ClearAccum(GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
    __GLfloat minusOne;
    __GLfloat one;
    __GL_SETUP_NOT_IN_BEGIN();

    minusOne = __glMinusOne;
    one = __glOne;
    if (r < minusOne) r = minusOne;
    if (r > one) r = one;
    if (g < minusOne) g = minusOne;
    if (g > one) g = one;
    if (b < minusOne) b = minusOne;
    if (b > one) b = one;
    if (a < minusOne) a = minusOne;
    if (a > one) a = one;

    if (__GL_FLOAT_NE (gc->state.accum.clear.r, r) || 
        __GL_FLOAT_NE (gc->state.accum.clear.g, g) ||
        __GL_FLOAT_NE (gc->state.accum.clear.b, b) || 
        __GL_FLOAT_NE (gc->state.accum.clear.a, a)) 
    {
        gc->state.accum.clear.r = r;
        gc->state.accum.clear.g = g;
        gc->state.accum.clear.b = b;
        gc->state.accum.clear.a = a;
        __GL_DELAY_VALIDATE(gc);
    }
}

void APIPRIVATE __glim_ClearColor (GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
    __GLfloat zero;
    __GLfloat one;
    __GL_SETUP_NOT_IN_BEGIN();

    zero = (__GLfloat)__glZero;
    one = (__GLfloat)__glOne;
    if (__GL_FLOAT_LTZ(r)) r = zero;
    if (__GL_FLOAT_COMPARE_PONE (r, >)) r = one;
    if (__GL_FLOAT_LTZ(g)) g = zero;
    if (__GL_FLOAT_COMPARE_PONE (g, >)) g = one;
    if (__GL_FLOAT_LTZ(b)) b = zero;
    if (__GL_FLOAT_COMPARE_PONE (b, >)) b = one;
    if (__GL_FLOAT_LTZ(a)) a = zero;
    if (__GL_FLOAT_COMPARE_PONE (a, >)) a = one;

#if 0
    if (__GL_FLOAT_NE (gc->state.raster.clear.r, r) || 
        __GL_FLOAT_NE (gc->state.raster.clear.g, g) ||
        __GL_FLOAT_NE (gc->state.raster.clear.b, b) || 
        __GL_FLOAT_NE (gc->state.raster.clear.a, a)) 
    {
#endif
        gc->state.raster.clear.r = r;
        gc->state.raster.clear.g = g;
        gc->state.raster.clear.b = b;
        gc->state.raster.clear.a = a;
	
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    //}
}

void APIPRIVATE __glim_ClearDepth(GLdouble z)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (z < (GLdouble) 0) z = (GLdouble)0;
    if (z > (GLdouble) 1) z = (GLdouble)1;
    if (gc->state.depth.clear != z) {
        gc->state.depth.clear = z;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
#ifdef _MCD_
      MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_ClearIndex(GLfloat val)
{
    __GL_SETUP_NOT_IN_BEGIN();

    val = __GL_MASK_INDEXF(gc, val);
    gc->state.raster.clearIndex = val;

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
}

void APIPRIVATE __glim_ClearStencil(GLint s)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->state.stencil.clear != (GLshort) (s & __GL_MAX_STENCIL_VALUE)) {
        gc->state.stencil.clear = (GLshort) (s & __GL_MAX_STENCIL_VALUE);
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_ColorMask(GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((gc->state.raster.rMask != r) || (gc->state.raster.gMask != g) ||
        (gc->state.raster.bMask != b) || (gc->state.raster.aMask != a)) {
        gc->state.raster.rMask = r;
        gc->state.raster.gMask = g;
        gc->state.raster.bMask = b;
        gc->state.raster.aMask = a;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_ColorMaterial(GLenum face, GLenum p)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (face) {
      case GL_FRONT:
      case GL_BACK:
      case GL_FRONT_AND_BACK:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (p) {
      case GL_EMISSION:
      case GL_SPECULAR:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_AMBIENT_AND_DIFFUSE:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    gc->state.light.colorMaterialFace = face;
    gc->state.light.colorMaterialParam = p;

    if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) {
#ifdef NT
	ComputeColorMaterialChange(gc);
#endif
	(*gc->procs.pickColorMaterialProcs)(gc);
	(*gc->procs.applyColor)(gc);
    }

    MCD_STATE_DIRTY(gc, COLORMATERIAL);
}

void APIPRIVATE __glim_CullFace(GLenum cfm)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (cfm) {
      case GL_FRONT:
      case GL_BACK:
      case GL_FRONT_AND_BACK:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->state.polygon.cull != cfm) {
        gc->state.polygon.cull = cfm;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
    }
}

void APIPRIVATE __glim_DepthFunc(GLenum zf)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((zf < GL_NEVER) || (zf > GL_ALWAYS)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->modes.depthBits != 0)
        gc->state.depth.testFunc = zf;
    else
        gc->state.depth.testFunc = GL_ALWAYS;
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, DEPTHTEST);
#endif
}

void APIPRIVATE __glim_DepthMask(GLboolean enabled)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->state.depth.writeEnable != enabled) {
        gc->state.depth.writeEnable = enabled;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_DrawBuffer(GLenum mode)
{
    GLint i;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_NONE:
	gc->state.raster.drawBuffer = GL_NONE;
	break;
      case GL_FRONT_RIGHT:
      case GL_BACK_RIGHT:
      case GL_RIGHT:
      not_supported_in_this_implementation:
	__glSetError(GL_INVALID_OPERATION);
	return;
      case GL_FRONT:
      case GL_FRONT_LEFT:
	gc->state.raster.drawBuffer = GL_FRONT;
	break;
      case GL_FRONT_AND_BACK:
      case GL_LEFT:
	if (!gc->modes.doubleBufferMode) {
	    gc->state.raster.drawBuffer = GL_FRONT;
	} else {
	    gc->state.raster.drawBuffer = GL_FRONT_AND_BACK;
	}
	break;
      case GL_BACK:
      case GL_BACK_LEFT:
	if (!gc->modes.doubleBufferMode) {
	    goto not_supported_in_this_implementation;
	}
	gc->state.raster.drawBuffer = GL_BACK;
	break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
	i = mode - GL_AUX0;
	if (i >= gc->modes.maxAuxBuffers) {
	    goto not_supported_in_this_implementation;
	}
	gc->state.raster.drawBuffer = mode;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->state.raster.drawBufferReturn != mode) {
        gc->state.raster.drawBufferReturn = mode;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
    }
}

void APIPRIVATE __glim_Fogfv(GLenum p, const GLfloat pv[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (p) {
      case GL_FOG_COLOR:
	__glClampAndScaleColorf(gc, &gc->state.fog.color, pv);
#ifdef NT
	if (gc->state.fog.color.r == gc->state.fog.color.g
	 && gc->state.fog.color.r == gc->state.fog.color.b)
	    gc->state.fog.flags |= __GL_FOG_GRAY_RGB;
	else
	    gc->state.fog.flags &= ~__GL_FOG_GRAY_RGB;
#endif
	break;
      case GL_FOG_DENSITY:
	if (pv[0] < __glZero) {
	    __glSetError(GL_INVALID_VALUE);
	    return;
	}
	gc->state.fog.density = pv[0];
#ifdef NT
	gc->state.fog.density2neg = -(pv[0] * pv[0]);
#endif
	break;
      case GL_FOG_END:
	gc->state.fog.end = pv[0];
	break;
      case GL_FOG_START:
	gc->state.fog.start = pv[0];
	break;
      case GL_FOG_INDEX:
        gc->state.fog.index = __GL_MASK_INDEXF(gc, pv[0]);
	break;
      case GL_FOG_MODE:
	switch ((GLenum) pv[0]) {
	  case GL_EXP:
	  case GL_EXP2:
	  case GL_LINEAR:
	    gc->state.fog.mode = (GLenum) pv[0];
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    /*
    ** Recompute cached 1/(end - start) value for linear fogging.
    */
    if (gc->state.fog.mode == GL_LINEAR) {
	if (gc->state.fog.start != gc->state.fog.end) {
	    gc->state.fog.oneOverEMinusS =  
		__glOne / (gc->state.fog.end - gc->state.fog.start);
	} else {
	    /*
	    ** Use zero as the undefined value.
	    */
	    gc->state.fog.oneOverEMinusS = __glZero;
	}
    }

    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FOG);
#endif
}

void APIPRIVATE __glim_FrontFace(GLenum dir)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (dir) {
      case GL_CW:
      case GL_CCW:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (gc->state.polygon.frontFaceDirection != dir) {
        gc->state.polygon.frontFaceDirection = dir;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
    }
}

void APIPRIVATE __glim_Hint(GLenum target, GLenum mode)
{
    __GLhintState *hs;
    __GL_SETUP_NOT_IN_BEGIN();

    hs = &gc->state.hints;
    switch (mode) {
      case GL_DONT_CARE:
      case GL_FASTEST:
      case GL_NICEST:
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    switch (target) {
      case GL_PERSPECTIVE_CORRECTION_HINT:
        if (hs->perspectiveCorrection == mode) return;
        hs->perspectiveCorrection = mode;
        break;
      case GL_POINT_SMOOTH_HINT:
        if (hs->pointSmooth == mode) return;
        hs->pointSmooth = mode;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, HINTS);
#endif
        return;
      case GL_LINE_SMOOTH_HINT:
        if (hs->lineSmooth == mode) return;
        hs->lineSmooth = mode;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, HINTS);
#endif
        return;
      case GL_POLYGON_SMOOTH_HINT:
        if (hs->polygonSmooth == mode) return;
        hs->polygonSmooth = mode;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, HINTS);
#endif
        return;
      case GL_FOG_HINT:
        if (hs->fog == mode) return;
        hs->fog = mode;
        break;
#ifdef GL_WIN_phong_shading
      case GL_PHONG_HINT_WIN:
        if (hs->phong == mode) return;
        hs->phong = mode;
        break;
#endif //GL_WIN_phong_shading
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, HINTS);
#endif
}

void APIPRIVATE __glim_IndexMask(GLuint i)
{
    __GL_SETUP_NOT_IN_BEGIN();

    i = __GL_MASK_INDEXI(gc, i);
	if (gc->state.raster.writeMask != (GLint) i) {
	  gc->state.raster.writeMask = (GLint) i;
	  __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
	}
	
}

void FASTCALL __glTransformLightDirection(__GLcontext *gc, __GLlightSourceState *lss)
{
    __GLcoord dir;
    __GLfloat q;
    GLint target = (GLint)((ULONG_PTR)(lss - &gc->state.light.source[0]));
    __GLtransform *tr;

    dir.x = lss->direction.x;
    dir.y = lss->direction.y;
    dir.z = lss->direction.z;
#ifdef NT
    ASSERTOPENGL(lss->direction.w == __glOne, "Direction with invalid w\n");
    q = -(dir.x * lss->position.x + dir.y * lss->position.y +
	  dir.z * lss->position.z);
#else
    if (lss->position.w != __glZero) {
	q = -(dir.x * lss->position.x + dir.y * lss->position.y +
	      dir.z * lss->position.z) / lss->position.w;
    } else {
	q = __glZero;
    }
#endif // NT
    dir.w = q;

    tr = gc->transform.modelView;
    if (tr->flags & XFORM_UPDATE_INVERSE) {
	__glComputeInverseTranspose(gc, tr);
    }
    (*tr->inverseTranspose.xf4)(&lss->directionEye, &dir.x,
                                &tr->inverseTranspose);
    __glNormalize(&lss->directionEyeNorm.x, &lss->directionEye.x);
    gc->light.source[target].direction = lss->directionEyeNorm;
}

void APIPRIVATE __glim_Lightfv(GLenum light, GLenum p, const GLfloat pv[])
{
    __GLlightSourceState *lss;
    __GLmatrix *m;
    __GL_SETUP_NOT_IN_BEGIN();

    light -= GL_LIGHT0;
#ifdef NT
    // light is unsigned!
    if (light >= (GLenum) gc->constants.numberOfLights) {
#else
    if ((light < 0) || (light >= gc->constants.numberOfLights)) {
#endif // NT
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    lss = &gc->state.light.source[light];
    switch (p) {
      case GL_AMBIENT:
	__glScaleColorf(gc, &lss->ambient, pv);
	break;
      case GL_DIFFUSE:
	__glScaleColorf(gc, &lss->diffuse, pv);
	break;
      case GL_SPECULAR:
	__glScaleColorf(gc, &lss->specular, pv);
	break;
      case GL_POSITION:
	lss->position.x = pv[0];
	lss->position.y = pv[1];
	lss->position.z = pv[2];
	lss->position.w = pv[3];

	/*
	** Transform light position into eye space
	*/
	m = &gc->transform.modelView->matrix;
	(*m->xf4)(&lss->positionEye, &lss->position.x, m);
	//
	// Grab a copy of the matrix so we can do this again later for
        // infinite lighting (avoiding normal transformations):
	//        
        lss->lightMatrix = gc->transform.modelView->matrix;
	break;
      case GL_SPOT_DIRECTION:
	lss->direction.x = pv[0];
	lss->direction.y = pv[1];
	lss->direction.z = pv[2];
	lss->direction.w = __glOne;
	__glTransformLightDirection(gc, lss);
	break;
      case GL_SPOT_EXPONENT:
	if ((pv[0] < (__GLfloat) 0) || (pv[0] > (__GLfloat) 128)) {
	  bad_value:
	    __glSetError(GL_INVALID_VALUE);
	    return;
	}
	lss->spotLightExponent = pv[0];
	break;
      case GL_SPOT_CUTOFF:
	if ((pv[0] != (__GLfloat) 180) && ((pv[0] < (__GLfloat) 0) || (pv[0] > (__GLfloat) 90))) {
	    goto bad_value;
	}
	lss->spotLightCutOffAngle = pv[0];
	break;
      case GL_CONSTANT_ATTENUATION:
	if (pv[0] < __glZero) {
	    goto bad_value;
	}
	lss->constantAttenuation = pv[0];
	break;
      case GL_LINEAR_ATTENUATION:
	if (pv[0] < __glZero) {
	    goto bad_value;
	}
	lss->linearAttenuation = pv[0];
	break;
      case GL_QUADRATIC_ATTENUATION:
	if (pv[0] < __glZero) {
	    goto bad_value;
	}
	lss->quadraticAttenuation = pv[0];
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
    gc->state.light.dirtyLights |= 1 << light;
    MCD_STATE_DIRTY(gc, LIGHTS);
}

void APIPRIVATE __glim_LightModelfv(GLenum p, const GLfloat pv[])
{
    __GLlightModelState *model;
    __GL_SETUP_NOT_IN_BEGIN();

    model = &gc->state.light.model;
    switch (p) {
      case GL_LIGHT_MODEL_AMBIENT:
	__glScaleColorf(gc, &model->ambient, pv);
	break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
	model->localViewer = pv[0] != __glZero;
	break;
      case GL_LIGHT_MODEL_TWO_SIDE:
	model->twoSided = pv[0] != __glZero;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
    MCD_STATE_DIRTY(gc, LIGHTMODEL);
}

void APIPRIVATE __glim_LineStipple(GLint factor, GLushort stipple)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (factor < 1) {
	factor = 1;
    }
    if (factor > 255) {
	factor = 255;
    }
	if ((gc->state.line.stippleRepeat != (GLshort) factor) || 
		(gc->state.line.stipple != stipple)) {
	  gc->state.line.stippleRepeat = (GLshort) factor;
	  gc->state.line.stipple = stipple;
	  __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, LINEDRAW);
#endif
	}
}

static GLint RoundWidth(__GLfloat size)
{
    if (size < (__GLfloat) 1.0)
	return 1;
    return size + (__GLfloat) 0.5;
}

static __GLfloat ClampWidth(__GLcontext *gc, __GLfloat size)
{
    __GLfloat minSize = gc->constants.lineWidthMinimum;
    __GLfloat maxSize = gc->constants.lineWidthMaximum;
    __GLfloat gran = gc->constants.lineWidthGranularity;
    GLint i;

    if (size <= minSize) return minSize;
    if (size >= maxSize) return maxSize;
	
    /* choose closest fence post */
    i = (GLint)(((size - minSize) / gran) + __glHalf);
    return minSize + i * gran;
}

void APIPRIVATE __glim_LineWidth(GLfloat width)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (width <= 0) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

    if (gc->state.line.requestedWidth == width) return;
    gc->state.line.requestedWidth = width;
    gc->state.line.aliasedWidth = RoundWidth(width);
    gc->state.line.smoothWidth = ClampWidth(gc, width);
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, LINEDRAW);
#endif
}

void APIPRIVATE __glim_LogicOp(GLenum op)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((op < GL_CLEAR) || (op > GL_SET)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
	if (gc->state.raster.logicOp != op) {
	  gc->state.raster.logicOp = op;
	  __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, LOGICOP);
#endif
	}
}

static GLint ApplyParameterF(__GLcontext *gc, __GLmaterialState *ms,
			     GLenum p, const GLfloat pv[])
{
    switch (p) {
      case GL_COLOR_INDEXES:
	ms->cmapa = pv[0];
	ms->cmapd = pv[1];
	ms->cmaps = pv[2];
	return __GL_MATERIAL_COLORINDEXES;
      case GL_EMISSION:
	__glScaleColorf(gc, &ms->emissive, pv);
	return __GL_MATERIAL_EMISSIVE;
      case GL_SPECULAR:
	ms->specular.r = pv[0];
	ms->specular.g = pv[1];
	ms->specular.b = pv[2];
	ms->specular.a = pv[3];
	return __GL_MATERIAL_SPECULAR;
      case GL_SHININESS:
	ms->specularExponent = pv[0];
	return __GL_MATERIAL_SHININESS;
      case GL_AMBIENT:
	ms->ambient.r = pv[0];
	ms->ambient.g = pv[1];
	ms->ambient.b = pv[2];
	ms->ambient.a = pv[3];
	return __GL_MATERIAL_AMBIENT;
      case GL_DIFFUSE:
	ms->diffuse.r = pv[0];
	ms->diffuse.g = pv[1];
	ms->diffuse.b = pv[2];
	ms->diffuse.a = pv[3];
	return __GL_MATERIAL_DIFFUSE;
      case GL_AMBIENT_AND_DIFFUSE:
	ms->ambient.r = pv[0];
	ms->ambient.g = pv[1];
	ms->ambient.b = pv[2];
	ms->ambient.a = pv[3];
	ms->diffuse = ms->ambient;
	return __GL_MATERIAL_DIFFUSE | __GL_MATERIAL_AMBIENT;
    }
    return 0;
}

#ifdef SGI
GLenum __glErrorCheckMaterial(GLenum face, GLenum p, GLfloat pv0)
{
    switch (face) {
      case GL_FRONT:
      case GL_BACK:
      case GL_FRONT_AND_BACK:
	break;
      default:
	return GL_INVALID_ENUM;
    }
    switch (p) {
      case GL_COLOR_INDEXES:
      case GL_EMISSION:
      case GL_SPECULAR:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_AMBIENT_AND_DIFFUSE:
	break;
      case GL_SHININESS:
	if (pv0 < (GLfloat) 0 || pv0 > (GLfloat) 128) {
	    return GL_INVALID_VALUE;
	}
	break;
      default:
	return GL_INVALID_ENUM;
    }
    return GL_NO_ERROR;
}
#endif

//!!! can we 'batch' these calls up until begin is called?
void APIPRIVATE __glim_Materialfv(GLenum face, GLenum p, const GLfloat pv[])
{
    GLenum error;
    GLint frontChange, backChange;
    __GL_SETUP();

    switch (face) {
      case GL_FRONT:
	frontChange = ApplyParameterF(gc, &gc->state.light.front, p, pv);
	backChange = 0;
	break;
      case GL_BACK:
	backChange = ApplyParameterF(gc, &gc->state.light.back, p, pv);
	frontChange = 0;
	break;
      case GL_FRONT_AND_BACK:
	backChange = ApplyParameterF(gc, &gc->state.light.back, p, pv);
	frontChange = ApplyParameterF(gc, &gc->state.light.front, p, pv);
	break;
    }

    if (p != GL_COLOR_INDEXES) {
	__glValidateMaterial(gc, frontChange, backChange);
    }

    if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) {
	(*gc->procs.applyColor)(gc);
    }

    MCD_STATE_DIRTY(gc, MATERIAL);
}

static GLint RoundSize(__GLfloat size)
{
    if (size < (__GLfloat) 1.0)
	return 1;
    return size + (__GLfloat) 0.5;
}

static __GLfloat ClampSize(__GLcontext *gc, __GLfloat size)
{
    __GLfloat minSize = gc->constants.pointSizeMinimum;
    __GLfloat maxSize = gc->constants.pointSizeMaximum;
    __GLfloat gran = gc->constants.pointSizeGranularity;
    GLint i;

    if (size <= minSize) return minSize;
    if (size >= maxSize) return maxSize;
	
    /* choose closest fence post */
    i = (GLint)(((size - minSize) / gran) + __glHalf);
    return minSize + i * gran;
}

void APIPRIVATE __glim_PointSize(GLfloat f)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (f <= __glZero) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
	
	if (gc->state.point.requestedSize != f) {
	  gc->state.point.requestedSize = f;
	  gc->state.point.aliasedSize = RoundSize(f);
	  gc->state.point.smoothSize = ClampSize(gc, f);
	  __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, POINTDRAW);
#endif
	}
}

void APIPRIVATE __glim_PolygonMode(GLenum face, GLenum mode)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_FILL:
        break;
      case GL_POINT:
	__GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
	break;
      case GL_LINE:
	__GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (face) {
      case GL_FRONT:
	gc->state.polygon.frontMode = mode;
	break;
      case GL_BACK:
	gc->state.polygon.backMode = mode;
	break;
      case GL_FRONT_AND_BACK:
	gc->state.polygon.frontMode = mode;
	gc->state.polygon.backMode = mode;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
}

#ifdef NT
void APIPRIVATE __glim_PolygonStipple(const GLubyte *mask, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_PolygonStipple(const GLubyte *mask)
#endif
{
    GLubyte *stipple;
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef NT
    if (_IsDlist)
    {
	const GLubyte *bits = mask;
	/* 
	** Just copy bits into stipple, convertPolygonStipple() will do the rest
	*/
	__GL_MEMCOPY(&gc->state.polygonStipple.stipple[0], bits,
		     sizeof(gc->state.polygonStipple.stipple));
    }
    else
    {
#endif
	stipple = &gc->state.polygonStipple.stipple[0];
	__glFillImage(gc, 32, 32, GL_COLOR_INDEX, GL_BITMAP, mask, stipple);
#ifdef NT
    }
#endif
    (*gc->procs.convertPolygonStipple)(gc);
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
}

void APIPRIVATE __glim_ShadeModel(GLenum sm)
{
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef GL_WIN_phong_shading
    if (!((sm == GL_FLAT) || (sm == GL_SMOOTH) || (sm == GL_PHONG_WIN))) 
#else
    if ((sm < GL_FLAT) || (sm > GL_SMOOTH)) 
#endif
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    if (gc->state.light.shadingModel != sm) 
    {
        gc->state.light.shadingModel = sm;
        __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
      MCD_STATE_DIRTY(gc, SHADEMODEL);
#endif
    }
}

void APIPRIVATE __glim_StencilMask(GLuint sm)
{
    __GL_SETUP_NOT_IN_BEGIN();

	if (gc->state.stencil.writeMask != 
		(GLshort)(sm & __GL_MAX_STENCIL_VALUE)) {
	  gc->state.stencil.writeMask = (GLshort) (sm & __GL_MAX_STENCIL_VALUE);
	  __GL_DELAY_VALIDATE(gc);
	  gc->validateMask |= __GL_VALIDATE_STENCIL_FUNC;
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
	}
}

void APIPRIVATE __glim_StencilFunc(GLenum func, GLint ref, GLuint mask)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((func < GL_NEVER) || (func > GL_ALWAYS)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (ref < 0) ref = 0;
    if (ref > __GL_MAX_STENCIL_VALUE) ref = __GL_MAX_STENCIL_VALUE;
	
	if ((gc->state.stencil.testFunc != func) ||
		(gc->state.stencil.reference != (GLshort) ref) ||
		(gc->state.stencil.mask = (GLshort)(mask & __GL_MAX_STENCIL_VALUE))) {
	  gc->state.stencil.testFunc = func;
	  gc->state.stencil.reference = (GLshort) ref;
	  gc->state.stencil.mask = (GLshort) (mask & __GL_MAX_STENCIL_VALUE);
	  __GL_DELAY_VALIDATE(gc);
	  gc->validateMask |= __GL_VALIDATE_STENCIL_FUNC;
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, STENCILTEST);
#endif
	}
}

void APIPRIVATE __glim_StencilOp(GLenum fail, GLenum depthFail, GLenum depthPass)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (fail) {
      case GL_KEEP: case GL_ZERO: case GL_REPLACE:
      case GL_INCR: case GL_DECR: case GL_INVERT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (depthFail) {
      case GL_KEEP: case GL_ZERO: case GL_REPLACE:
      case GL_INCR: case GL_DECR: case GL_INVERT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (depthPass) {
      case GL_KEEP: case GL_ZERO: case GL_REPLACE:
      case GL_INCR: case GL_DECR: case GL_INVERT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

	if ((gc->state.stencil.fail != fail) || 
		(gc->state.stencil.depthFail != depthFail) ||
		(gc->state.stencil.depthPass != depthPass) ) {
	  gc->state.stencil.fail = fail;
	  gc->state.stencil.depthFail = depthFail;
	  gc->state.stencil.depthPass = depthPass;
	  __GL_DELAY_VALIDATE(gc);
	  gc->validateMask |= __GL_VALIDATE_STENCIL_OP;
#ifdef _MCD_
	  MCD_STATE_DIRTY(gc, STENCILTEST);
#endif
	}
}

/************************************************************************/

/*
** Copy context information from src to dst.  Mark dst for validation
** when done.
*/
GLboolean FASTCALL __glCopyContext(__GLcontext *dst, const __GLcontext *src, GLuint mask)
{
    const __GLattribute *sp;
    GLboolean rv = GL_TRUE;

    sp = &src->state;

    if (dst == GLTEB_SRVCONTEXT()) {
	return GL_FALSE;
    }

    /*
    ** In order for a context copy to be successful, the source
    ** and destination color scales must match. We make the
    ** destination context match the source context, since it isn't
    ** currently the current one, and will be automatically rescaled
    ** when it next made current.
    ** 
    */

    /* set the new destination context scale factors */

    dst->frontBuffer.redScale   = src->frontBuffer.redScale;
    dst->frontBuffer.greenScale = src->frontBuffer.greenScale;
    dst->frontBuffer.blueScale  = src->frontBuffer.blueScale;
    dst->frontBuffer.alphaScale = src->frontBuffer.alphaScale;

    dst->redVertexScale         = src->redVertexScale;
    dst->greenVertexScale       = src->greenVertexScale;
    dst->blueVertexScale        = src->blueVertexScale;
    dst->alphaVertexScale       = src->alphaVertexScale;

    /* rescale the destination context with the new scale factors */

    __glContextSetColorScales(dst);

    if (mask & GL_ACCUM_BUFFER_BIT) {
	dst->state.accum = sp->accum;
    }

    if (mask & GL_COLOR_BUFFER_BIT) {
	dst->state.raster = sp->raster;
#ifdef NT
        // A copy can occur from a double-buffered context to a single
        // buffered context, leaving the drawBuffer in an invalid state
        // Fix it up if necessary
        if (dst->state.raster.drawBuffer == GL_BACK &&
            !dst->modes.doubleBufferMode)
        {
            dst->state.raster.drawBuffer = GL_FRONT;
        }
#endif
	dst->state.enables.general &= ~__GL_COLOR_BUFFER_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_COLOR_BUFFER_ENABLES;
	dst->validateMask |= __GL_VALIDATE_ALPHA_FUNC; /*XXX*/
    }

    if (mask & GL_CURRENT_BIT) {
	dst->state.current = sp->current;
    }

    if (mask & GL_DEPTH_BUFFER_BIT) {
	dst->state.depth = sp->depth;
	dst->state.enables.general &= ~__GL_DEPTH_TEST_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_DEPTH_TEST_ENABLE;
        __GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_DEPTH);
    }

    if (mask & GL_ENABLE_BIT) {
	dst->state.enables = sp->enables;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_LINE | __GL_DIRTY_POLYGON | 
		__GL_DIRTY_POINT | __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH);
#ifdef NT
	ComputeColorMaterialChange(dst);
#endif
	(*dst->procs.pickColorMaterialProcs)(dst);
	(*dst->procs.applyColor)(dst);
    }

    if (mask & GL_EVAL_BIT) {
	dst->state.evaluator = sp->evaluator;
	dst->state.enables.general &= ~__GL_AUTO_NORMAL_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_AUTO_NORMAL_ENABLE;
	dst->state.enables.eval1 = sp->enables.eval1;
	dst->state.enables.eval2 = sp->enables.eval2;
    }

    if (mask & GL_FOG_BIT) {
	dst->state.fog = sp->fog;
	dst->state.enables.general &= ~__GL_FOG_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_FOG_ENABLE;
#ifdef GL_WIN_specular_fog
        dst->state.enables.general &= ~__GL_FOG_SPEC_TEX_ENABLE;
        dst->state.enables.general |=
          sp->enables.general & __GL_FOG_SPEC_TEX_ENABLE;
#endif //GL_WIN_specular_fog
    }

    if (mask & GL_HINT_BIT) {
	dst->state.hints = sp->hints;
    }

    if (mask & GL_LIGHTING_BIT) {
	dst->state.light.colorMaterialFace = sp->light.colorMaterialFace;
	dst->state.light.colorMaterialParam = sp->light.colorMaterialParam;
	dst->state.light.shadingModel = sp->light.shadingModel;
	dst->state.light.model = sp->light.model;
	dst->state.light.front = sp->light.front;
	dst->state.light.back = sp->light.back;
        dst->state.light.dirtyLights = (1 << dst->constants.numberOfLights)-1;
	__GL_MEMCOPY(dst->state.light.source, sp->light.source,
		     dst->constants.numberOfLights
		     * sizeof(__GLlightSourceState));
	dst->state.enables.general &= ~__GL_LIGHTING_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_LIGHTING_ENABLES;
	dst->state.enables.lights = sp->enables.lights;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_LIGHTING);
    }

    if (mask & GL_LINE_BIT) {
	dst->state.line = sp->line;
	dst->state.enables.general &= ~__GL_LINE_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_LINE_ENABLES;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_LINE);
    }

    if (mask & GL_LIST_BIT) {
	dst->state.list = sp->list;
    }

    if (mask & GL_PIXEL_MODE_BIT) {
	dst->state.pixel.readBuffer = sp->pixel.readBuffer;
	dst->state.pixel.readBufferReturn = sp->pixel.readBufferReturn;
	dst->state.pixel.transferMode = sp->pixel.transferMode;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_PIXEL);
    }

    if (mask & GL_POINT_BIT) {
	dst->state.point = sp->point;
	dst->state.enables.general &= ~__GL_POINT_SMOOTH_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_POINT_SMOOTH_ENABLE;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_POINT);
    }

    if (mask & GL_POLYGON_BIT) {
	dst->state.polygon = sp->polygon;
	dst->state.enables.general &= ~__GL_POLYGON_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_POLYGON_ENABLES;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_POLYGON);
    }

    if (mask & GL_POLYGON_STIPPLE_BIT) {
	dst->state.polygonStipple = sp->polygonStipple;
	dst->state.enables.general &= ~__GL_POLYGON_STIPPLE_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_POLYGON_STIPPLE_ENABLE;
	__GL_DELAY_VALIDATE_MASK(dst, __GL_DIRTY_POLYGON |
		__GL_DIRTY_POLYGON_STIPPLE);
    }

    if (mask & GL_SCISSOR_BIT) {
	dst->state.scissor = sp->scissor;
	dst->state.enables.general &= ~__GL_SCISSOR_TEST_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_SCISSOR_TEST_ENABLE;
    }

    if (mask & GL_STENCIL_BUFFER_BIT) {
	dst->state.stencil = sp->stencil;
	dst->state.enables.general &= ~__GL_STENCIL_TEST_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_STENCIL_TEST_ENABLE;
	dst->validateMask |= __GL_VALIDATE_STENCIL_FUNC |
	    __GL_VALIDATE_STENCIL_OP; /*XXX*/
    }

    if (mask & GL_TEXTURE_BIT) {
	dst->state.texture.s = sp->texture.s;
	dst->state.texture.t = sp->texture.t;
	dst->state.texture.r = sp->texture.r;
	dst->state.texture.q = sp->texture.q;
	__GL_MEMCOPY(dst->state.texture.texture, sp->texture.texture,
		     dst->constants.numberOfTextures
		     * sizeof(__GLperTextureState));
	__GL_MEMCOPY(dst->state.texture.env, sp->texture.env,
		     dst->constants.numberOfTextureEnvs
		     * sizeof(__GLtextureEnvState));
	dst->state.enables.general &= ~__GL_TEXTURE_ENABLES;
	dst->state.enables.general |=
	    sp->enables.general & __GL_TEXTURE_ENABLES;
    }

    if (mask & GL_TRANSFORM_BIT) {
	dst->state.transform.matrixMode = sp->transform.matrixMode;
#ifdef NT
        if (sp->transform.eyeClipPlanes != NULL)
        {
            if (dst->state.transform.eyeClipPlanes != NULL)
            {
                __GL_MEMCOPY(dst->state.transform.eyeClipPlanes,
                             sp->transform.eyeClipPlanes,
                             dst->constants.numberOfClipPlanes *
                             sizeof(__GLcoord));
            }
        }
        else
        {
            dst->state.transform.eyeClipPlanes = NULL;
        }
#else
        __GL_MEMCOPY(dst->state.transform.eyeClipPlanes,
                     sp->transform.eyeClipPlanes,
                     dst->constants.numberOfClipPlanes *
                     sizeof(__GLcoord));
#endif
	dst->state.enables.general &= ~__GL_NORMALIZE_ENABLE;
	dst->state.enables.general |=
	    sp->enables.general & __GL_NORMALIZE_ENABLE;
    }

    if (mask & GL_VIEWPORT_BIT) {
	dst->state.viewport = sp->viewport;
        __glUpdateViewportDependents(dst);
    }

    __glContextUnsetColorScales(dst);

    __GL_DELAY_VALIDATE(dst);
#ifdef _MCD_
    MCD_STATE_DIRTY(dst, ALL);
#endif

    return rv;
}

/************************************************************************/

void APIPRIVATE __glim_PushAttrib(GLuint mask)
{
    __GLattribute **spp;
    __GLattribute *sp;
    __GL_SETUP_NOT_IN_BEGIN();

    spp = gc->attributes.stackPointer;
    if (spp < &gc->attributes.stack[gc->constants.maxAttribStackDepth]) {
	if (!(sp = *spp)) {
	    sp = (__GLattribute*)
		GCALLOCZ(gc, sizeof(__GLattribute));
	    if (NULL == sp)
            {
	        return;
            }
            
	    *spp = sp;
	}
	sp->mask = mask;
	sp->enables = gc->state.enables;	/* Always save enables */
	gc->attributes.stackPointer = spp + 1;

	if (mask & GL_ACCUM_BUFFER_BIT) {
	    sp->accum = gc->state.accum;
	}
	if (mask & GL_COLOR_BUFFER_BIT) {
	    sp->raster = gc->state.raster;
	}
	if (mask & GL_CURRENT_BIT) {
	    sp->current = gc->state.current;
	}
	if (mask & GL_DEPTH_BUFFER_BIT) {
	    sp->depth = gc->state.depth;
	}
	if (mask & GL_EVAL_BIT) {
	    sp->evaluator = gc->state.evaluator;
	}
	if (mask & GL_FOG_BIT) {
	    sp->fog = gc->state.fog;
	}
	if (mask & GL_HINT_BIT) {
	    sp->hints = gc->state.hints;
	}
	if (mask & GL_LIGHTING_BIT) {
	    size_t bytes = (size_t)
		(gc->constants.numberOfLights * sizeof(__GLlightSourceState));
	    sp->light.colorMaterialFace = gc->state.light.colorMaterialFace;
	    sp->light.colorMaterialParam = gc->state.light.colorMaterialParam;
	    sp->light.shadingModel = gc->state.light.shadingModel;
	    sp->light.model = gc->state.light.model;
	    sp->light.front = gc->state.light.front;
	    sp->light.back = gc->state.light.back;
	    sp->light.source = (__GLlightSourceState*)
		GCALLOC(gc, bytes);
#ifdef NT
	    if (NULL ==  sp->light.source)
	        sp->mask &= ~GL_LIGHTING_BIT;
	    else
	        __GL_MEMCOPY(sp->light.source, gc->state.light.source, bytes);
#else
	    __GL_MEMCOPY(sp->light.source, gc->state.light.source, bytes);
#endif
	}
	if (mask & GL_LINE_BIT) {
	    sp->line = gc->state.line;
	}
	if (mask & GL_LIST_BIT) {
	    sp->list = gc->state.list;
	}
	if (mask & GL_PIXEL_MODE_BIT) {
	    sp->pixel.readBuffer = gc->state.pixel.readBuffer;
	    sp->pixel.readBufferReturn = gc->state.pixel.readBufferReturn;
	    sp->pixel.transferMode = gc->state.pixel.transferMode;
	}
	if (mask & GL_POINT_BIT) {
	    sp->point = gc->state.point;
	}
	if (mask & GL_POLYGON_BIT) {
	    sp->polygon = gc->state.polygon;
	}
	if (mask & GL_POLYGON_STIPPLE_BIT) {
	    sp->polygonStipple = gc->state.polygonStipple;
	}
	if (mask & GL_SCISSOR_BIT) {
	    sp->scissor = gc->state.scissor;
	}
	if (mask & GL_STENCIL_BUFFER_BIT) {
	    sp->stencil = gc->state.stencil;
	}
	if (mask & GL_TEXTURE_BIT) {
	    size_t texbytes = (size_t) (gc->constants.numberOfTextures
					* sizeof(__GLperTextureState));
	    size_t envbytes = (size_t) (gc->constants.numberOfTextureEnvs
					* sizeof(__GLtextureEnvState));
	    sp->texture.s = gc->state.texture.s;
	    sp->texture.t = gc->state.texture.t;
	    sp->texture.r = gc->state.texture.r;
	    sp->texture.q = gc->state.texture.q;
#ifdef NT
	    sp->texture.texture = (__GLperTextureState*)
		GCALLOC(gc, texbytes);
	    sp->texture.env = (__GLtextureEnvState*)
		GCALLOC(gc, envbytes);
	    if ((NULL == sp->texture.texture) || (NULL == sp->texture.env)) {
	        if (sp->texture.texture)
	            GCFREE(gc, sp->texture.texture);
	        sp->texture.texture = NULL;
	        if (sp->texture.env)
	            GCFREE(gc, sp->texture.env);
	        sp->texture.env = NULL;
	        sp->mask &= ~GL_TEXTURE_BIT;
	    } else {
	        __GL_MEMCOPY(sp->texture.texture, gc->state.texture.texture,
			 texbytes);
	        __GL_MEMCOPY(sp->texture.env, gc->state.texture.env, envbytes);
	    }
#else
	    sp->texture.texture = (__GLperTextureState*)
		GCALLOC(gc, texbytes);
	    __GL_MEMCOPY(sp->texture.texture, gc->state.texture.texture,
			 texbytes);
	    sp->texture.env = (__GLtextureEnvState*)
		GCALLOC(gc, envbytes);
	    __GL_MEMCOPY(sp->texture.env, gc->state.texture.env, envbytes);
#endif
	}
	if (mask & GL_TRANSFORM_BIT) {
	    size_t bytes = (size_t)
		(gc->constants.numberOfClipPlanes * sizeof(__GLcoord));
	    sp->transform.matrixMode = gc->state.transform.matrixMode;
	    sp->transform.eyeClipPlanes = (__GLcoord*)
		GCALLOC(gc, bytes);
#ifdef NT
	    if (NULL == sp->transform.eyeClipPlanes)
	        sp->mask &= ~GL_TRANSFORM_BIT;
	    else
	        __GL_MEMCOPY(sp->transform.eyeClipPlanes,
			 gc->state.transform.eyeClipPlanes, bytes);
#else
	    __GL_MEMCOPY(sp->transform.eyeClipPlanes,
			 gc->state.transform.eyeClipPlanes, bytes);
#endif
	}
	if (mask & GL_VIEWPORT_BIT) {
	    sp->viewport = gc->state.viewport;
	}
    } else {
	__glSetError(GL_STACK_OVERFLOW);
	return;
    }
}

/************************************************************************/

GLuint FASTCALL __glInternalPopAttrib(__GLcontext *gc, GLboolean destroy)
{
    __GLattribute **spp;
    __GLattribute *sp;
    GLuint mask;
    GLuint dirtyMask = 0;

    spp = gc->attributes.stackPointer;
    if (spp > &gc->attributes.stack[0]) {
	--spp;
	sp = *spp;
	ASSERTOPENGL(sp != NULL, "No attribute data to pop\n");
	mask = sp->mask;
	gc->attributes.stackPointer = spp;
	if (mask & GL_ACCUM_BUFFER_BIT) {
	    gc->state.accum = sp->accum;
	}
	if (mask & GL_COLOR_BUFFER_BIT) {
	    gc->state.raster = sp->raster;
	    gc->state.enables.general &= ~__GL_COLOR_BUFFER_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_COLOR_BUFFER_ENABLES;
	    gc->validateMask |= __GL_VALIDATE_ALPHA_FUNC; /*XXX*/
	}
	if (mask & GL_CURRENT_BIT) {
	    gc->state.current = sp->current;
	}
	if (mask & GL_DEPTH_BUFFER_BIT) {
	    gc->state.depth = sp->depth;
	    gc->state.enables.general &= ~__GL_DEPTH_TEST_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_DEPTH_TEST_ENABLE;
            dirtyMask |= __GL_DIRTY_DEPTH;
	}
	if (mask & GL_ENABLE_BIT) {
	    gc->state.enables = sp->enables;
            dirtyMask |= (__GL_DIRTY_LINE | __GL_DIRTY_POLYGON |
		    __GL_DIRTY_POINT | __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH);
#ifdef NT
	    ComputeColorMaterialChange(gc);
#endif
	    (*gc->procs.pickColorMaterialProcs)(gc);
	    (*gc->procs.applyColor)(gc);
#ifdef NT
            if (!destroy)
            {
                // applyViewport does both
                (*gc->procs.applyViewport)(gc);
            }
#else
	    (*gc->procs.computeClipBox)(gc);
	    (*gc->procs.applyScissor)(gc);
#endif
	}
	if (mask & GL_EVAL_BIT) {
	    gc->state.evaluator = sp->evaluator;
	    gc->state.enables.general &= ~__GL_AUTO_NORMAL_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_AUTO_NORMAL_ENABLE;
	    gc->state.enables.eval1 = sp->enables.eval1;
	    gc->state.enables.eval2 = sp->enables.eval2;
	}
	if (mask & GL_FOG_BIT) {
	    gc->state.fog = sp->fog;
	    gc->state.enables.general &= ~__GL_FOG_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_FOG_ENABLE;
#ifdef GL_WIN_specular_fog
	    gc->state.enables.general &= ~__GL_FOG_SPEC_TEX_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_FOG_SPEC_TEX_ENABLE;
#endif //GL_WIN_specular_fog
	}
	if (mask & GL_HINT_BIT) {
	    gc->state.hints = sp->hints;
	}
	if (mask & GL_LIGHTING_BIT) {
	    gc->state.light.colorMaterialFace = sp->light.colorMaterialFace;
	    gc->state.light.colorMaterialParam = sp->light.colorMaterialParam;
	    gc->state.light.shadingModel = sp->light.shadingModel;
	    gc->state.light.model = sp->light.model;
	    gc->state.light.front = sp->light.front;
	    gc->state.light.back = sp->light.back;
            gc->state.light.dirtyLights =
                (1 << gc->constants.numberOfLights)-1;
	    __GL_MEMCOPY(gc->state.light.source, sp->light.source,
			 gc->constants.numberOfLights
			     * sizeof(__GLlightSourceState));
	    GCFREE(gc, sp->light.source);
	    sp->light.source = 0;
	    gc->state.enables.general &= ~__GL_LIGHTING_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_LIGHTING_ENABLES;
	    gc->state.enables.lights = sp->enables.lights;
            dirtyMask |= __GL_DIRTY_LIGHTING;
	}
	if (mask & GL_LINE_BIT) {
	    gc->state.line = sp->line;
	    gc->state.enables.general &= ~__GL_LINE_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_LINE_ENABLES;
            dirtyMask |= __GL_DIRTY_LINE;
	}
	if (mask & GL_LIST_BIT) {
	    gc->state.list = sp->list;
	}
	if (mask & GL_PIXEL_MODE_BIT) {
	    gc->state.pixel.transferMode = sp->pixel.transferMode;
	    gc->state.pixel.readBufferReturn = sp->pixel.readBufferReturn;
	    gc->state.pixel.readBuffer = sp->pixel.readBuffer;
            dirtyMask |= __GL_DIRTY_PIXEL;
	}
	if (mask & GL_POINT_BIT) {
	    gc->state.point = sp->point;
	    gc->state.enables.general &= ~__GL_POINT_SMOOTH_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_POINT_SMOOTH_ENABLE;
            dirtyMask |= __GL_DIRTY_POINT;
	}
	if (mask & GL_POLYGON_BIT) {
	    gc->state.polygon = sp->polygon;
	    gc->state.enables.general &= ~__GL_POLYGON_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_POLYGON_ENABLES;
            dirtyMask |= __GL_DIRTY_POLYGON;
	}
	if (mask & GL_POLYGON_STIPPLE_BIT) {
	    gc->state.polygonStipple = sp->polygonStipple;
	    gc->state.enables.general &= ~__GL_POLYGON_STIPPLE_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_POLYGON_STIPPLE_ENABLE;
	    (*gc->procs.convertPolygonStipple)(gc);
            dirtyMask |= __GL_DIRTY_POLYGON;
	}
	if (mask & GL_SCISSOR_BIT) {
	    gc->state.scissor = sp->scissor;
	    gc->state.enables.general &= ~__GL_SCISSOR_TEST_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_SCISSOR_TEST_ENABLE;
#ifdef NT
            if (!destroy)
            {
                // applyViewport does both
                (*gc->procs.applyViewport)(gc);
            }
#else
	    (*gc->procs.computeClipBox)(gc);
	    (*gc->procs.applyScissor)(gc);
#endif
	}
	if (mask & GL_STENCIL_BUFFER_BIT) {
	    gc->state.stencil = sp->stencil;
	    gc->state.enables.general &= ~__GL_STENCIL_TEST_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_STENCIL_TEST_ENABLE;
	    gc->validateMask |= __GL_VALIDATE_STENCIL_FUNC |
		__GL_VALIDATE_STENCIL_OP;/*XXX*/
	}
	if (mask & GL_TEXTURE_BIT) {
	    GLuint numTextures = gc->constants.numberOfTextures;
	    
	    gc->state.texture.s = sp->texture.s;
	    gc->state.texture.t = sp->texture.t;
	    gc->state.texture.r = sp->texture.r;
	    gc->state.texture.q = sp->texture.q;
	    /*
	    ** If the texture name is different, a new binding is
	    ** called for.  Deferring the binding is dangerous, because
	    ** the state before the pop has to be saved with the
	    ** texture that is being unbound.  If we defer the binding,
	    ** we need to watch out for cases like two pops in a row
	    ** or a pop followed by a bind.
	    */
	    {
		GLuint targetIndex;
		__GLperTextureState *pts, *spPts;

		pts = gc->state.texture.texture;
		spPts = sp->texture.texture;
		for (targetIndex = 0; targetIndex < numTextures; 
			targetIndex++, pts++, spPts++) {
		    if (pts->texobjs.name != spPts->texobjs.name) {
			__glBindTexture(gc, targetIndex, 
						spPts->texobjs.name, GL_TRUE);
		    }
		}
	    }
	    __GL_MEMCOPY(gc->state.texture.texture, sp->texture.texture,
			 numTextures * sizeof(__GLperTextureState));
	    __GL_MEMCOPY(gc->state.texture.env, sp->texture.env,
			 gc->constants.numberOfTextureEnvs
			     * sizeof(__GLtextureEnvState));
	    GCFREE(gc, sp->texture.texture);
	    sp->texture.texture = 0;
	    GCFREE(gc, sp->texture.env);
	    sp->texture.env = 0;
	    gc->state.enables.general &= ~__GL_TEXTURE_ENABLES;
	    gc->state.enables.general |=
		sp->enables.general & __GL_TEXTURE_ENABLES;
	}
	if (mask & GL_TRANSFORM_BIT) {
	    gc->state.transform.matrixMode = sp->transform.matrixMode;
	    __GL_MEMCOPY(gc->state.transform.eyeClipPlanes,
			 sp->transform.eyeClipPlanes,
			 gc->constants.numberOfClipPlanes * sizeof(__GLcoord));
	    GCFREE(gc, sp->transform.eyeClipPlanes);
	    sp->transform.eyeClipPlanes = 0;
	    gc->state.enables.general &= ~__GL_NORMALIZE_ENABLE;
	    gc->state.enables.general |=
		sp->enables.general & __GL_NORMALIZE_ENABLE;
	}
	if (mask & GL_VIEWPORT_BIT) {
	    gc->state.viewport = sp->viewport;
            __glUpdateViewportDependents(gc);
	}

	/*
	** Clear out mask so that any memory frees done above won't get
	** re-done when the context is destroyed
	*/
	sp->mask = 0;

	dirtyMask |= __GL_DIRTY_GENERIC;
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ALL);
#endif
    } else {
	__glSetError(GL_STACK_UNDERFLOW);
    }

    return dirtyMask;
}

void APIPRIVATE __glim_PopAttrib(void)
{
    GLuint dirtyMask;
    __GL_SETUP_NOT_IN_BEGIN();

    dirtyMask = __glInternalPopAttrib(gc, GL_FALSE);
    if (dirtyMask)
    {
	__GL_DELAY_VALIDATE_MASK(gc, dirtyMask);
    }
}

/************************************************************************/

void APIPRIVATE __glim_Disable(GLenum cap)
{
    GLuint frontChange, backChange;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (cap) {
      case GL_ALPHA_TEST:
        if (!(gc->state.enables.general & __GL_ALPHA_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_ALPHA_TEST_ENABLE;
        break;
      case GL_BLEND:
        if (!(gc->state.enables.general & __GL_BLEND_ENABLE)) return;
        gc->state.enables.general &= ~__GL_BLEND_ENABLE;
        break;
      case GL_COLOR_MATERIAL:
        if (!(gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE)) return;
        gc->state.enables.general &= ~__GL_COLOR_MATERIAL_ENABLE;
        frontChange = gc->light.front.colorMaterialChange;
        backChange  = gc->light.back.colorMaterialChange;
        ComputeColorMaterialChange(gc);
        (*gc->procs.pickColorMaterialProcs)(gc);
        __glValidateMaterial(gc, frontChange, backChange);
        break;
      case GL_CULL_FACE:
        if (!(gc->state.enables.general & __GL_CULL_FACE_ENABLE)) return;
        gc->state.enables.general &= ~__GL_CULL_FACE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_DEPTH_TEST:
        if (!(gc->state.enables.general & __GL_DEPTH_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_DEPTH_TEST_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
        break;
      case GL_POLYGON_OFFSET_POINT:
        if (!(gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_OFFSET_POINT_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
        break;
      case GL_POLYGON_OFFSET_LINE:
        if (!(gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_OFFSET_LINE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
        break;
      case GL_POLYGON_OFFSET_FILL:
        if (!(gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_OFFSET_FILL_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
        break;
      case GL_DITHER:
        if (!(gc->state.enables.general & __GL_DITHER_ENABLE)) return;
        gc->state.enables.general &= ~__GL_DITHER_ENABLE;
        break;
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
        if (!(gc->state.enables.general & __GL_FOG_SPEC_TEX_ENABLE))
            return;
        gc->state.enables.general &= ~__GL_FOG_SPEC_TEX_ENABLE;
        break;
#endif //GL_WIN_specular_fog
      case GL_FOG:
        if (!(gc->state.enables.general & __GL_FOG_ENABLE)) return;
        gc->state.enables.general &= ~__GL_FOG_ENABLE;
        break;
      case GL_LIGHTING:
        if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE)) return;
        gc->state.enables.general &= ~__GL_LIGHTING_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
#ifdef NT
        ComputeColorMaterialChange(gc);
#endif
        (*gc->procs.pickColorMaterialProcs)(gc);
        (*gc->procs.applyColor)(gc);
        return;
      case GL_LINE_SMOOTH:
        if (!(gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)) return;
        gc->state.enables.general &= ~__GL_LINE_SMOOTH_ENABLE;
        break;
      case GL_LINE_STIPPLE:
        if (!(gc->state.enables.general & __GL_LINE_STIPPLE_ENABLE)) return;
        gc->state.enables.general &= ~__GL_LINE_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_INDEX_LOGIC_OP:
        if (!(gc->state.enables.general & __GL_INDEX_LOGIC_OP_ENABLE)) return;
        gc->state.enables.general &= ~__GL_INDEX_LOGIC_OP_ENABLE;
        break;
      case GL_COLOR_LOGIC_OP:
        if (!(gc->state.enables.general & __GL_COLOR_LOGIC_OP_ENABLE)) return;
        gc->state.enables.general &= ~__GL_COLOR_LOGIC_OP_ENABLE;
        break;
      case GL_NORMALIZE:
        if (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE)) return;
        gc->state.enables.general &= ~__GL_NORMALIZE_ENABLE;
        break;
      case GL_POINT_SMOOTH:
        if (!(gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE)) return;
        gc->state.enables.general &= ~__GL_POINT_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_SMOOTH:
        if (!(gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE)) return;
        gc->state.enables.general &= ~__GL_POLYGON_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_STIPPLE:
        if (!(gc->state.enables.general & __GL_POLYGON_STIPPLE_ENABLE)) 
            return;
        gc->state.enables.general &= ~__GL_POLYGON_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_SCISSOR_TEST:
        if (!(gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_SCISSOR_TEST_ENABLE;
#ifdef NT
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, SCISSOR);
#endif
        // applyViewport does both
        (*gc->procs.applyViewport)(gc);
#else
        (*gc->procs.computeClipBox)(gc);
        (*gc->procs.applyScissor)(gc);
#endif
        break;
      case GL_STENCIL_TEST:
        if (!(gc->state.enables.general & __GL_STENCIL_TEST_ENABLE)) return;
        gc->state.enables.general &= ~__GL_STENCIL_TEST_ENABLE;
        break;
      case GL_TEXTURE_1D:
        if (!(gc->state.enables.general & __GL_TEXTURE_1D_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_1D_ENABLE;
        break;
      case GL_TEXTURE_2D:
        if (!(gc->state.enables.general & __GL_TEXTURE_2D_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_2D_ENABLE;
        break;
      case GL_AUTO_NORMAL:
        if (!(gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE)) return;
        gc->state.enables.general &= ~__GL_AUTO_NORMAL_ENABLE;
        break;
      case GL_TEXTURE_GEN_S:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_S_ENABLE;
        break;
      case GL_TEXTURE_GEN_T:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_T_ENABLE;
        break;
      case GL_TEXTURE_GEN_R:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_R_ENABLE;
        break;
      case GL_TEXTURE_GEN_Q:
        if (!(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE)) return;
        gc->state.enables.general &= ~__GL_TEXTURE_GEN_Q_ENABLE;
        break;
#ifdef GL_WIN_multiple_textures
      case GL_TEXCOMBINE_CLAMP_WIN:
        if (!(gc->state.enables.general & __GL_TEXCOMBINE_CLAMP_ENABLE))
        {
            return;
        }
        gc->state.enables.general &= ~__GL_TEXCOMBINE_CLAMP_ENABLE;
        break;
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
        gc->state.enables.general &= ~__GL_PALETTED_LIGHTING_ENABLE;
        break;
#endif
        
      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
        cap -= GL_CLIP_PLANE0;
        if (!(gc->state.enables.clipPlanes & (1 << cap))) return;
        gc->state.enables.clipPlanes &= ~(1 << cap);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, CLIPCTRL);
#endif
        break;
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
        cap -= GL_LIGHT0;
        if (!(gc->state.enables.lights & (1 << cap))) return;
        gc->state.enables.lights &= ~(1 << cap);
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
        MCD_STATE_DIRTY(gc, LIGHTS);
        return;
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
        cap = __GL_EVAL1D_INDEX(cap);
        if (!(gc->state.enables.eval1 & (GLushort) ~(1 << cap))) return;
        gc->state.enables.eval1 &= (GLushort) ~(1 << cap);
        break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
        cap = __GL_EVAL2D_INDEX(cap);
        if (!(gc->state.enables.eval2 & (GLushort) ~(1 << cap))) return;
        gc->state.enables.eval2 &= (GLushort) ~(1 << cap);
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ENABLES);
#endif
}

GLboolean APIPRIVATE __glim_IsEnabled(GLenum cap)
{
    GLuint bit;
    __GL_SETUP_NOT_IN_BEGIN2();

    switch (cap) {
      case GL_ALPHA_TEST:
	bit = gc->state.enables.general & __GL_ALPHA_TEST_ENABLE;
	break;
      case GL_BLEND:
	bit = gc->state.enables.general & __GL_BLEND_ENABLE;
	break;
      case GL_COLOR_MATERIAL:
	bit = gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE;
	break;
      case GL_CULL_FACE:
	bit = gc->state.enables.general & __GL_CULL_FACE_ENABLE;
	break;
      case GL_DEPTH_TEST:
	bit = gc->state.enables.general & __GL_DEPTH_TEST_ENABLE;
	break;
      case GL_POLYGON_OFFSET_POINT:
	bit = gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE;
        break;
      case GL_POLYGON_OFFSET_LINE:
	bit = gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE;
        break;
      case GL_POLYGON_OFFSET_FILL:
	bit = gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE;
        break;
      case GL_DITHER:
	bit = gc->state.enables.general & __GL_DITHER_ENABLE;
	break;
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
        bit = gc->state.enables.general & __GL_FOG_SPEC_TEX_ENABLE;
        break;
#endif //GL_WIN_specular_fog
      case GL_FOG:
        bit = gc->state.enables.general & __GL_FOG_ENABLE;
        break;  
      case GL_LIGHTING:
	bit = gc->state.enables.general & __GL_LIGHTING_ENABLE;
	break;
      case GL_LINE_SMOOTH:
	bit = gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE;
	break;
      case GL_LINE_STIPPLE:
	bit = gc->state.enables.general & __GL_LINE_STIPPLE_ENABLE;
	break;
      case GL_INDEX_LOGIC_OP:
	bit = gc->state.enables.general & __GL_INDEX_LOGIC_OP_ENABLE;
	break;
      case GL_COLOR_LOGIC_OP:
	bit = gc->state.enables.general & __GL_COLOR_LOGIC_OP_ENABLE;
	break;
      case GL_NORMALIZE:
	bit = gc->state.enables.general & __GL_NORMALIZE_ENABLE;
	break;
      case GL_POINT_SMOOTH:
	bit = gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE;
	break;
      case GL_POLYGON_SMOOTH:
	bit = gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE;
	break;
      case GL_POLYGON_STIPPLE:
	bit = gc->state.enables.general & __GL_POLYGON_STIPPLE_ENABLE;
	break;
      case GL_SCISSOR_TEST:
	bit = gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE;
	break;
      case GL_STENCIL_TEST:
	bit = gc->state.enables.general & __GL_STENCIL_TEST_ENABLE;
	break;
      case GL_TEXTURE_1D:
	bit = gc->state.enables.general & __GL_TEXTURE_1D_ENABLE;
	break;
      case GL_TEXTURE_2D:
	bit = gc->state.enables.general & __GL_TEXTURE_2D_ENABLE;
	break;
      case GL_AUTO_NORMAL:
	bit = gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE;
	break;
      case GL_TEXTURE_GEN_S:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE;
	break;
      case GL_TEXTURE_GEN_T:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE;
	break;
      case GL_TEXTURE_GEN_R:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE;
	break;
      case GL_TEXTURE_GEN_Q:
	bit = gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE;
	break;
#ifdef GL_WIN_multiple_textures
      case GL_TEXCOMBINE_CLAMP_WIN:
        bit = gc->state.enables.general & __GL_TEXCOMBINE_CLAMP_ENABLE;
        break;
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
        bit = gc->state.enables.general & __GL_PALETTED_LIGHTING_ENABLE;
        break;
#endif // GL_EXT_flat_paletted_lighting

      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
	cap -= GL_CLIP_PLANE0;
	bit = gc->state.enables.clipPlanes & (1 << cap);
	break;
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
	cap -= GL_LIGHT0;
	bit = gc->state.enables.lights & (1 << cap);
	break;
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
	cap = __GL_EVAL1D_INDEX(cap);
	bit = gc->state.enables.eval1 & (1 << cap);
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
	cap = __GL_EVAL2D_INDEX(cap);
	bit = gc->state.enables.eval2 & (1 << cap);
	break;
      case GL_VERTEX_ARRAY:
      case GL_NORMAL_ARRAY:
      case GL_COLOR_ARRAY:
      case GL_INDEX_ARRAY:
      case GL_TEXTURE_COORD_ARRAY:
      case GL_EDGE_FLAG_ARRAY:
	bit = gc->vertexArray.mask & vaEnable[cap - GL_VERTEX_ARRAY];
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return GL_FALSE;
    }
    return bit != 0;
}

void APIPRIVATE __glim_PolygonOffset(GLfloat factor, GLfloat units)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (__GL_FLOAT_NE (gc->state.polygon.factor, factor) || 
        __GL_FLOAT_NE (gc->state.polygon.units, units))
    {
        gc->state.polygon.factor = factor;
        gc->state.polygon.units = units;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_alpha.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop


/* - Fetch converts GLubyte alpha value to float and puts in __GLcolor
   - Likewise, Store does the reverse
   - All input coords are viewport biased
*/

static void FASTCALL 
Store(__GLalphaBuffer *afb, GLint x, GLint y, const __GLcolor *color)
{
    GLubyte *pAlpha;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);
    *pAlpha = (GLubyte) FTOL( color->a );
}

static void FASTCALL 
StoreSpan(__GLalphaBuffer *afb)
{
    GLint w;
    GLubyte *pAlpha;
    __GLcolor *cp;
    __GLcontext *gc = afb->buf.gc;

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), gc->polygon.shader.frag.x, 
                                              gc->polygon.shader.frag.y);
    for( ; w ; w--, cp++, pAlpha++ )
        *pAlpha = (GLubyte) FTOL( cp->a );
}

// Generic version of StoreSpan
static void FASTCALL 
StoreSpan2( __GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *cp )
{
    GLubyte *pAlpha;
    __GLcontext *gc = afb->buf.gc;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);
    for( ; w ; w--, cp++, pAlpha++ )
        *pAlpha = (GLubyte) FTOL( cp->a );
}

static void FASTCALL 
Fetch(__GLalphaBuffer *afb, GLint x, GLint y, __GLcolor *result)
{
    GLubyte *pAlpha;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);
    result->a = (__GLfloat) *pAlpha;
}

static void FASTCALL 
ReadSpan(__GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *results)
{
    GLubyte *pAlpha;

    pAlpha = __GL_FB_ADDRESS(afb, (GLubyte*), x, y);

    for( ; w ; w--, results++, pAlpha++ )
        results->a = (__GLfloat) *pAlpha;
}

static void FASTCALL Clear(__GLalphaBuffer *afb)
{
    __GLcontext *gc = afb->buf.gc;
    __GLcolor *clear;
    BYTE alphaClear;
    GLint x0, x1, y0, y1;
    int width, height, i;
    GLubyte *puj;

    // Check if alpha is masked
    if( ! gc->state.raster.aMask )
        return;

    // Get the alpha clear value
    clear = &gc->state.raster.clear;
    alphaClear = (BYTE) (clear->a*gc->frontBuffer.alphaScale);

    // Get area to clear
    x0 = __GL_UNBIAS_X(gc, gc->transform.clipX0);
    x1 = __GL_UNBIAS_X(gc, gc->transform.clipX1);
    y0 = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
    y1 = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
    width = x1 - x0;
    height = y1 - y0;
    if( (width <= 0) || (height <= 0) )
        return;

    puj = (GLubyte *)((ULONG_PTR)afb->buf.base + (y0*afb->buf.outerWidth) + x0 );

    if (width == afb->buf.outerWidth) {
        // Clearing contiguous buffer
        RtlFillMemory( (PVOID) puj, width * height, alphaClear);
        return;
    }

    // Clearing sub-rectangle of buffer
    for( i = height; i; i--, puj += afb->buf.outerWidth )
        RtlFillMemory( (PVOID) puj, width, alphaClear );
}

void FASTCALL __glInitAlpha(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    __GLalphaBuffer *afb = &cfb->alphaBuf;

    // The software alpha buffer is 8-bit.
    afb->buf.elementSize = sizeof(GLubyte);
    afb->store = Store;
    afb->storeSpan = StoreSpan;
    afb->storeSpan2 = StoreSpan2;
    afb->fetch = Fetch;
    afb->readSpan = ReadSpan;
    afb->clear = Clear;

    afb->buf.gc = gc;
    afb->alphaScale = cfb->alphaScale;
}

/*
** Initialize a lookup table that is indexed by the iterated alpha value.
** The table indicates whether the alpha test passed or failed, based on
** the current alpha function and the alpha reference value.
**
** NOTE:  The alpha span routines will never be called if the alpha test
** is GL_ALWAYS (its useless) or if the alpha test is GL_NEVER.  This
** is accomplished in the __glGenericPickSpanProcs procedure.
*/

void FASTCALL __glValidateAlphaTest(__GLcontext *gc)
{
    GLubyte *atft;
    GLint i, limit;
    GLint ref;
    GLenum alphaTestFunc = gc->state.raster.alphaFunction;

    limit = gc->constants.alphaTestSize;
    ref = (GLint)
	((gc->state.raster.alphaReference * gc->frontBuffer.alphaScale) *
	gc->constants.alphaTableConv);

    /*
    ** Allocate alpha test function table the first time.  It needs
    ** to have at most one entry for each possible alpha value.
    */
    atft = gc->alphaTestFuncTable;
    if (!atft) {
	atft = (GLubyte*) GCALLOC(gc, (limit) * sizeof(GLubyte));
	gc->alphaTestFuncTable = atft;
    }

    /*
    ** Build up alpha test lookup table.  The computed alpha value is
    ** used as an index into this table to determine if the alpha
    ** test passed or failed.
    */
    for (i = 0; i < limit; i++) {
	switch (alphaTestFunc) {
	  case GL_NEVER:	*atft++ = GL_FALSE; break;
	  case GL_LESS:		*atft++ = (GLubyte) (i <  ref); break;
	  case GL_EQUAL:	*atft++ = (GLubyte) (i == ref); break;
	  case GL_LEQUAL:	*atft++ = (GLubyte) (i <= ref); break;
	  case GL_GREATER:	*atft++ = (GLubyte) (i >  ref); break;
	  case GL_NOTEQUAL:	*atft++ = (GLubyte) (i != ref); break;
	  case GL_GEQUAL:	*atft++ = (GLubyte) (i >= ref); break;
	  case GL_ALWAYS:	*atft++ = GL_TRUE; break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_buffe.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.9 $
** $Date: 1993/04/22 00:20:39 $
*/
#include "precomp.h"
#pragma hdrstop

void FASTCALL __glInitGenericCB(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    cfb->buf.gc = gc;
    cfb->readSpan = __glReadSpan;
    cfb->returnSpan = __glReturnSpan;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_clip.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/07 18:43:05 $
*/
#include "precomp.h"
#pragma hdrstop

#ifdef _X86_
#include <gli386.h>
#endif

/*
** Clipping macros.  These are used to reduce the amount of code
** hand written below.
*/

#ifdef _X86_
// Do a four-component linear interpolation from b to a based on t

// Set up registers for multiple LERP4s
#ifdef NOT_FASTCALL
#define LERP_START(dst, a, b)                                                 \
    __asm mov ecx, dst							      \
    __asm mov edx, a							      \
    __asm mov eax, b
#else
// This relies on dst == ecx and a == edx due to fastcall argument passing
#define LERP_START(dst, a, b)                                                 \
    __asm mov eax, b
#endif
    
// Do a four-component linear interpolation from b to a based on t
// Offsets are assumed to be equal in a, b and d
// Offsets are assumed to increase by four for each component
// LERP_START must come before this
#define LERP4(t, offs)					                      \
    __asm fld t								      \
    __asm fld DWORD PTR [edx+offs]					      \
    __asm fsub DWORD PTR [eax+offs]					      \
    __asm fmul st(0), st(1)						      \
    __asm fld DWORD PTR [edx+offs+4]					      \
    __asm fsub DWORD PTR [eax+offs+4]					      \
    __asm fmul st(0), st(2)						      \
    __asm fld DWORD PTR [edx+offs+8]					      \
    __asm fsub DWORD PTR [eax+offs+8]					      \
    __asm fmul st(0), st(3)						      \
    __asm fld DWORD PTR [edx+offs+12]					      \
    __asm fsub DWORD PTR [eax+offs+12]					      \
    __asm fxch st(4)							      \
    __asm fmulp st(4), st(0)						      \
    /* Stack is now 8 4 0 12 */ 					      \
    __asm fadd DWORD PTR [eax+offs+8]					      \
    __asm fxch st(2)							      \
    /* Stack is now 0 4 8 12 */					              \
    __asm fadd DWORD PTR [eax+offs]					      \
    __asm fxch st(1)							      \
    /* Stack is now 4 0 8 12 */					              \
    __asm fadd DWORD PTR [eax+offs+4]					      \
    __asm fxch st(3)							      \
    /* Stack is now 12 0 8 4 */					              \
    __asm fadd DWORD PTR [eax+offs+12]					      \
    __asm fstp DWORD PTR [ecx+offs+12]					      \
    __asm fstp DWORD PTR [ecx+offs]					      \
    __asm fstp DWORD PTR [ecx+offs+8]					      \
    __asm fstp DWORD PTR [ecx+offs+4]					      \

#define __GL_CLIP_POS(d, a, b, t)       LERP4(t, VCLIP_x)
#define __GL_CLIP_COLOR(d, a, b, t)     LERP4(t, VFCOL_r)
#define __GL_CLIP_BACKCOLOR(d, a, b, t) LERP4(t, VBCOL_r)
#define __GL_CLIP_TEXTURE(d, a, b, t)   LERP4(t, VTEX_x)
#define __GL_CLIP_NORMAL(d, a, b, t)    LERP4(t, VNOR_x)
#define __GL_CLIP_EYE(d, a, b, t)       LERP4(t, VEYE_x)

#else // _X86_

#define LERP_START(dst, a, b)

#ifdef NT
// window is not used!
#define __GL_CLIP_POS(d,a,b,t) \
    d->clip.x = t*(a->clip.x - b->clip.x) + b->clip.x;	\
    d->clip.y = t*(a->clip.y - b->clip.y) + b->clip.y;	\
    d->clip.z = t*(a->clip.z - b->clip.z) + b->clip.z;  \
    d->clip.w = t*(a->clip.w - b->clip.w) + b->clip.w
#else
#define __GL_CLIP_POS(d,a,b,t) \
    d->clip.w = t*(a->clip.w - b->clip.w) + b->clip.w;	\
    /* XXX (mf) Handle w=0.0.  Mathematically incorrect, but prevents /0 */    \
    if( d->clip.w == (__GLfloat) 0.0 ) {		\
	d->window.w = (__GLfloat) 0.0;			\
    }							\
    else						\
    	d->window.w = ((__GLfloat) 1.0) / d->clip.w;    \
    d->clip.x = t*(a->clip.x - b->clip.x) + b->clip.x;	\
    d->clip.y = t*(a->clip.y - b->clip.y) + b->clip.y;	\
    d->clip.z = t*(a->clip.z - b->clip.z) + b->clip.z
#endif

#define __GL_CLIP_COLOR(d,a,b,t)				      \
    d->colors[__GL_FRONTFACE].r = t*(a->colors[__GL_FRONTFACE].r      \
        - b->colors[__GL_FRONTFACE].r) + b->colors[__GL_FRONTFACE].r; \
    d->colors[__GL_FRONTFACE].g = t*(a->colors[__GL_FRONTFACE].g      \
        - b->colors[__GL_FRONTFACE].g) + b->colors[__GL_FRONTFACE].g; \
    d->colors[__GL_FRONTFACE].b = t*(a->colors[__GL_FRONTFACE].b      \
        - b->colors[__GL_FRONTFACE].b) + b->colors[__GL_FRONTFACE].b; \
    d->colors[__GL_FRONTFACE].a = t*(a->colors[__GL_FRONTFACE].a      \
        - b->colors[__GL_FRONTFACE].a) + b->colors[__GL_FRONTFACE].a

#define __GL_CLIP_BACKCOLOR(d,a,b,t)				    \
    d->colors[__GL_BACKFACE].r = t*(a->colors[__GL_BACKFACE].r	    \
        - b->colors[__GL_BACKFACE].r) + b->colors[__GL_BACKFACE].r; \
    d->colors[__GL_BACKFACE].g = t*(a->colors[__GL_BACKFACE].g	    \
        - b->colors[__GL_BACKFACE].g) + b->colors[__GL_BACKFACE].g; \
    d->colors[__GL_BACKFACE].b = t*(a->colors[__GL_BACKFACE].b	    \
        - b->colors[__GL_BACKFACE].b) + b->colors[__GL_BACKFACE].b; \
    d->colors[__GL_BACKFACE].a = t*(a->colors[__GL_BACKFACE].a	    \
        - b->colors[__GL_BACKFACE].a) + b->colors[__GL_BACKFACE].a

#define __GL_CLIP_TEXTURE(d,a,b,t) \
    d->texture.x = t*(a->texture.x - b->texture.x) + b->texture.x; \
    d->texture.y = t*(a->texture.y - b->texture.y) + b->texture.y; \
    d->texture.z = t*(a->texture.z - b->texture.z) + b->texture.z; \
    d->texture.w = t*(a->texture.w - b->texture.w) + b->texture.w

#define __GL_CLIP_NORMAL(d,a,b,t)				      \
    d->normal.x = t*(a->normal.x - b->normal.x) + b->normal.x; \
    d->normal.y = t*(a->normal.y - b->normal.y) + b->normal.y; \
    d->normal.z = t*(a->normal.z - b->normal.z) + b->normal.z; 

#define __GL_CLIP_EYE(d,a,b,t)				      \
    d->eyeX = t*(a->eyeX - b->eyeX) + b->eyeX; \
    d->eyeY = t*(a->eyeY - b->eyeY) + b->eyeY; \
    d->eyeZ = t*(a->eyeZ - b->eyeZ) + b->eyeZ; 

#endif // _x86_

/*
** The following is done this way since when we are slow fogging we want to
** clip the eye.z coordinate only, while when we are cheap fogging we want
** to clip the fog value.  This way we avoid doubling the number of clip
** routines.
#ifdef GL_WIN_specular_fog
** anankan: If we are doing specularly lit textures, then we need to clip 
** the fog as well as eyeZ when both fog and specular_fog are enabled.
#endif //GL_WIN_specular_fog
*/

#define __GL_CLIP_FOG(d,a,b,t)	\
    if (a->has & __GL_HAS_FOG)  \
        d->fog = t * (a->fog - b->fog) + b->fog; \
    else \
        d->eyeZ = t*(a->eyeZ - b->eyeZ) + b->eyeZ

#define __GL_CLIP_INDEX(d,a,b,t)				     \
    d->colors[__GL_FRONTFACE].r = t*(a->colors[__GL_FRONTFACE].r     \
        - b->colors[__GL_FRONTFACE].r) + b->colors[__GL_FRONTFACE].r

#define __GL_CLIP_BACKINDEX(d,a,b,t)				   \
    d->colors[__GL_BACKFACE].r = t*(a->colors[__GL_BACKFACE].r	   \
        - b->colors[__GL_BACKFACE].r) + b->colors[__GL_BACKFACE].r

/************************************************************************/

/*
  Naming code:
   C = Front color
   B = Back color
   I = Front index
   X = Back index
   F = Fog
   T = Texture
   N = Normal
   Pos = <no letter>
  */


static void FASTCALL Clip(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
}

static void FASTCALL ClipC(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
}

static void FASTCALL ClipB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
}

static void FASTCALL ClipI(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
}

static void FASTCALL ClipX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
}


static void FASTCALL ClipCB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
}

static void FASTCALL ClipIX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
}

static void FASTCALL ClipT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipIT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipIXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipCT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipCBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
}

static void FASTCALL ClipF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipIXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipCBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

#ifdef GL_WIN_phong_shading
/************New Clip Procs*******************************/

static void FASTCALL ClipN(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNC(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNI(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}


static void FASTCALL ClipNCB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNIX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNIT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNIXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNCT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNCBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
}

static void FASTCALL ClipNF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNIXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNCBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}


static void FASTCALL ClipNE(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEC(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEI(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		  __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}


static void FASTCALL ClipNECB(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEIX(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNET(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEIT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEIXT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNECT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNECBT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static PFN_VERTEX_CLIP_PROC clipProcs[84] =
#else
static PFN_VERTEX_CLIP_PROC clipProcs[28] =
#endif //GL_WIN_phong_shading
{
    Clip, ClipI, ClipC, ClipX, ClipB, ClipIX, ClipCB,
    ClipF, ClipIF, ClipCF, ClipXF, ClipBF, ClipIXF, ClipCBF,
    ClipT, ClipIT, ClipCT, ClipXT, ClipBT, ClipIXT, ClipCBT,
    ClipFT, ClipIFT, ClipCFT, ClipXFT, ClipBFT, ClipIXFT, ClipCBFT,
#ifdef GL_WIN_phong_shading
    ClipN, ClipNI, ClipNC, ClipNX, ClipNB, ClipNIX, ClipNCB,
    ClipNF, ClipNIF, ClipNCF, ClipNXF, ClipNBF, ClipNIXF, ClipNCBF,
    ClipNT, ClipNIT, ClipNCT, ClipNXT, ClipNBT, ClipNIXT, ClipNCBT,
    ClipNFT, ClipNIFT, ClipNCFT, ClipNXFT, ClipNBFT, ClipNIXFT, ClipNCBFT,
      //
    ClipNE, ClipNEI, ClipNEC, ClipNEX, ClipNEB, ClipNEIX, ClipNECB,
    ClipNEF, ClipNEIF, ClipNECF, ClipNEXF, ClipNEBF, ClipNEIXF, ClipNECBF,
    ClipNET, ClipNEIT, ClipNECT, ClipNEXT, ClipNEBT, ClipNEIXT, ClipNECBT,
    ClipNEFT, ClipNEIFT, ClipNECFT, ClipNEXFT, ClipNEBFT, ClipNEIXFT, ClipNECBFT,
#endif //GL_WIN_phong_shading
};

#ifdef GL_WIN_phong_shading
void FASTCALL __glGenericPickParameterClipProcs(__GLcontext *gc)
{
    GLint line = 0, poly = 0;
    GLuint enables = gc->state.enables.general;
    GLboolean twoSided = (enables & __GL_LIGHTING_ENABLE)
                         && gc->state.light.model.twoSided;
    GLboolean colorMaterial = (enables & __GL_COLOR_MATERIAL_ENABLE);
    GLboolean doPhong = (enables & __GL_LIGHTING_ENABLE) &&
                        (gc->state.light.shadingModel == GL_PHONG_WIN);
    GLuint modeFlags = gc->polygon.shader.modeFlags;

#ifdef NT
    if (gc->renderMode == GL_SELECT)
    {
        gc->procs.lineClipParam = Clip;
        gc->procs.polyClipParam = Clip;
        return;
    }
#endif

    if (gc->modes.rgbMode) {
        if (doPhong) {
            if (!colorMaterial) {
                line = 28; //0+28
                poly = 28;
            } else {
                line = 30; //2+28
                poly = 30;
            }
        }
        else {
            if (gc->state.light.shadingModel != GL_FLAT) {
                line = 2;
                poly = 2;
            }
        }
    } else {
        if (doPhong) {
            if (!colorMaterial) {
                line = 28; //0+28
                poly = 28;
            } else {
                line = 29; //1+28
                poly = 29;
            }
        }
        else {
            if (gc->state.light.shadingModel != GL_FLAT) {
                line = 1;
                poly = 1;
            }
        }
    }


// Compute front and back color needs for polygons.
// Points and lines always use the front color.
// Unlit primitives always use the front color.
//
//  Cull enable?    Two sided?  Cull face   Color needs
//  N       N       BACK        FRONT
//  N       N       FRONT       FRONT
//  N       N       FRONT_AND_BACK  FRONT
//  N       Y       BACK        FRONT/BACK
//  N       Y       FRONT       FRONT/BACK
//  N       Y       FRONT_AND_BACK  FRONT/BACK
//  Y       N       BACK        FRONT
//  Y       N       FRONT       FRONT
//  Y       N       FRONT_AND_BACK  None
//  Y       Y       BACK        FRONT
//  Y       Y       FRONT       BACK
//  Y       Y       FRONT_AND_BACK  None
    
    if (gc->state.light.shadingModel != GL_FLAT &&
        (enables & __GL_LIGHTING_ENABLE) &&
        gc->state.light.model.twoSided)
    {
        if ((enables & __GL_CULL_FACE_ENABLE) == 0)
        {
            // Both colors are needed
            poly += 4;
        }
        else if (gc->state.polygon.cull == GL_FRONT)
        {
            // Only back colors are needed
            poly += 2;
        }
        else if (gc->state.polygon.cull == GL_FRONT_AND_BACK)
        {
            // Neither color is needed
            poly = 0;
        }
    }
    
    if ((modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG)) ||
	    ((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) == 
         __GL_SHADE_CHEAP_FOG)) {
#ifdef NT
        // POLYARRAY - fog is not computed in feedback mode!
        if (gc->renderMode == GL_RENDER)
        {
            line += 7;
            poly += 7;
        }
#else
        line += 7;
        poly += 7;
#endif
    }
    if (gc->texture.textureEnabled) { /*XXX - don't change this (see Derrick)*/
        line += 14;
        poly += 14;
    }
    if (doPhong && 
        (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        line += 28;
        poly += 28;
    }
    
    gc->procs.lineClipParam = clipProcs[line];
    gc->procs.polyClipParam = clipProcs[poly];
}

#else //GL_WIN_phong_shading

void FASTCALL __glGenericPickParameterClipProcs(__GLcontext *gc)
{
    GLint line = 0, poly = 0;
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    GLboolean twoSided = (enables & __GL_LIGHTING_ENABLE)
                         && gc->state.light.model.twoSided;

#ifdef NT
    if (gc->renderMode == GL_SELECT)
    {
        gc->procs.lineClipParam = Clip;
        gc->procs.polyClipParam = Clip;
        return;
    }
#endif

    if (gc->modes.rgbMode) {
        if (gc->state.light.shadingModel != GL_FLAT) {
            line = 2;
            poly = 2;
        }
    } else {
        if (gc->state.light.shadingModel != GL_FLAT) {
            line = 1;
            poly = 1;
        }
    }

// Compute front and back color needs for polygons.
// Points and lines always use the front color.
// Unlit primitives always use the front color.
//
//  Cull enable?    Two sided?  Cull face   Color needs
//  N       N       BACK        FRONT
//  N       N       FRONT       FRONT
//  N       N       FRONT_AND_BACK  FRONT
//  N       Y       BACK        FRONT/BACK
//  N       Y       FRONT       FRONT/BACK
//  N       Y       FRONT_AND_BACK  FRONT/BACK
//  Y       N       BACK        FRONT
//  Y       N       FRONT       FRONT
//  Y       N       FRONT_AND_BACK  None
//  Y       Y       BACK        FRONT
//  Y       Y       FRONT       BACK
//  Y       Y       FRONT_AND_BACK  None
    
    if (gc->state.light.shadingModel != GL_FLAT &&
        (enables & __GL_LIGHTING_ENABLE) &&
    gc->state.light.model.twoSided)
    {
        if ((enables & __GL_CULL_FACE_ENABLE) == 0)
        {
            // Both colors are needed
            poly += 4;
        }
        else if (gc->state.polygon.cull == GL_FRONT)
        {
            // Only back colors are needed
            poly += 2;
        }
        else if (gc->state.polygon.cull == GL_FRONT_AND_BACK)
        {
            // Neither color is needed
            poly = 0;
        }
    }
    
    if ((modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG)) ||
	    ((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) == 
         __GL_SHADE_CHEAP_FOG)) {
      
#ifdef NT
// POLYARRAY - fog is not computed in feedback mode!
    if (gc->renderMode == GL_RENDER)
    {
        line += 7;
        poly += 7;
    }
#else
    line += 7;
    poly += 7;
#endif
    }
    if (gc->texture.textureEnabled) { /*XXX - don't change this (see Derrick)*/
    line += 14;
    poly += 14;
    }
    gc->procs.lineClipParam = clipProcs[line];
    gc->procs.polyClipParam = clipProcs[poly];
}
#endif //GL_WIN_phong_shading
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_bitma.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.8 $
** $Date: 1993/08/31 16:23:06 $
*/
#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

#ifdef NT
void APIPRIVATE __glim_Bitmap(GLsizei w, GLsizei h, GLfloat xOrig, GLfloat yOrig,
		   GLfloat xMove, GLfloat yMove, const GLubyte *bitmap,
		   GLboolean _IsDlist)
#else
void APIPRIVATE __glim_Bitmap(GLsizei w, GLsizei h, GLfloat xOrig, GLfloat yOrig,
		   GLfloat xMove, GLfloat yMove, const GLubyte *bitmap)
#endif
{
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	    __glim_Bitmap(w,h,xOrig,yOrig,
		    xMove,yMove,bitmap,_IsDlist);
	    return;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

#ifdef NT
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // MCD does not hook glBitmap, so we go straight to the
    // simulations.  Therefore, if we are grabbing the device
    // lock lazily, we need to grab it now.

        if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc,
                                   RENDER_LOCK_FLAGS))
            return;

    // We may need to temporarily reset the viewport adjust values
    // before calling simulations.  If GenMcdResetViewportAdj returns
    // TRUE, the viewport is changed and we need restore later with
    // VP_NOBIAS.

        bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
    }

    if (_IsDlist)
    {
	const __GLbitmap *glbitmap = (const __GLbitmap *) bitmap;
	(*gc->procs.renderBitmap)(gc, glbitmap, (const GLubyte *) (glbitmap+1));
    }
    else
    {
#endif
	if ((w < 0) || (h < 0)) {
	    __glSetError(GL_INVALID_VALUE);
	    return;
	}
	(*gc->procs.bitmap)(gc, w, h, xOrig, yOrig, xMove, yMove, bitmap);
#ifdef NT
    }
#endif

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_bitdr.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.8 $
** $Date: 1993/04/10 04:07:00 $
*/
#include "precomp.h"
#pragma hdrstop

#define __GL_BITS_PER_UINT32 (sizeof(GLuint) * __GL_BITS_PER_BYTE)

void __glDrawBitmap(__GLcontext *gc, GLsizei width, GLsizei height,
                    GLfloat xOrig, GLfloat yOrig,
                    GLfloat xMove, GLfloat yMove,
                    const GLubyte oldbits[])
{
    __GLbitmap bitmap;
    GLubyte *newbits;
    size_t size;

    bitmap.width = width;
    bitmap.height = height;
    bitmap.xorig = xOrig;
    bitmap.yorig = yOrig;
    bitmap.xmove = xMove;
    bitmap.ymove = yMove;

    /*
    ** Could check the pixel transfer modes and see if we can maybe just
    ** render oldbits directly rather than converting it first.
    */
    size = (size_t) __glImageSize(width, height, GL_COLOR_INDEX, GL_BITMAP);
    newbits = (GLubyte *) gcTempAlloc(gc, size);

    __glFillImage(gc, width, height, GL_COLOR_INDEX, GL_BITMAP,
                  oldbits, newbits);

    (*gc->procs.renderBitmap)(gc, &bitmap, newbits);

    gcTempFree(gc, newbits);
}

void FASTCALL __glRenderBitmap(__GLcontext *gc, const __GLbitmap *bitmap,
                      const GLubyte *data)
{
    __GLfragment frag;
    __GLvertex *rp;
    __GLfloat fx;
    GLint x, y, bit;
    GLint ySign;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    // Crank down the fpu precision to 24-bit mantissa to gain front-end speed.
    // This will only affect code which relies on double arithmetic.  Also,
    // mask off FP exceptions.  Finally, to draw primitives, we can let the
    // FPU run in chop (truncation) mode since we have enough precision left
    // to convert to pixel units:

    FPU_SAVE_MODE();
    FPU_PREC_LOW_MASK_EXCEPTIONS();
    FPU_CHOP_ON_PREC_LOW();

    ySign = gc->constants.ySign;

    /*
    ** Check if current raster position is valid.  Do not render if invalid.
    ** Also, if selection is in progress skip the rendering of the
    ** bitmap.  Bitmaps are invisible to selection and do not generate
    ** selection hits.
    */
    rp = &gc->state.current.rasterPos;
    if (!gc->state.current.validRasterPos) {
        goto glBitmap_exit;
    }

    if (gc->renderMode == GL_SELECT) {
        rp->window.x += bitmap->xmove;
        rp->window.y += ySign * bitmap->ymove;
        goto glBitmap_exit;
    }

    if (gc->renderMode == GL_FEEDBACK) {
        __glFeedbackBitmap(gc, rp);
        /*
        ** Advance the raster position as if the bitmap had been rendered.
        */
        rp->window.x += bitmap->xmove;
        rp->window.y += ySign * bitmap->ymove;
        goto glBitmap_exit;
    }

    frag.color = *rp->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
        __GLfloat qInv;
        if (__GL_FLOAT_EQZ(rp->texture.w))
        {
            qInv = __glZero;
        }
        else
        {
            qInv = __glOne / rp->texture.w;
        }
        (*gc->procs.texture)(gc, &frag.color, rp->texture.x * qInv,
                               rp->texture.y * qInv, __glOne);
    }
    /* XXX - is this the correct test */
    if (gc->state.enables.general & __GL_FOG_ENABLE) {
        (*gc->procs.fogPoint)(gc, &frag, rp->eyeZ);
    }

    frag.z = rp->window.z;
    fx = (GLint) (rp->window.x - bitmap->xorig);
    frag.y = (GLint) (rp->window.y - ySign * bitmap->yorig);

    bit = 7;
    for (y = 0; y < bitmap->height; y++) {
        frag.x = fx;
        for (x = 0; x < bitmap->width; x++) {
            if (*data & (1<<bit)) {
                (*gc->procs.store)(gc->drawBuffer, &frag);
            }
            frag.x++;
            bit--;
            if (bit < 0) {
                bit = 7;
                data++;
            }
        }
        frag.y += ySign;
        if (bit != 7) {
            bit = 7;
            data++;
        }
    }

    /*
    ** Advance current raster position.
    */
    rp->window.x += bitmap->xmove;
    rp->window.y += ySign * bitmap->ymove;

glBitmap_exit:
    FPU_RESTORE_MODE_NO_EXCEPTIONS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_blend.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.14 $
** $Date: 1993/04/14 21:23:50 $
*/
#include "precomp.h"
#pragma hdrstop


void __glDoBlendSourceZERO(__GLcontext *gc, const __GLcolor *source,
		            const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat zero = __glZero;

#ifdef __GL_LINT
    gc = gc;
    source = source;
    dest = dest;
#endif
    result->r = zero;
    result->g = zero;
    result->b = zero;
    result->a = zero;
}

void __glDoBlendDestZERO(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
#ifdef __GL_LINT
    gc = gc;
    source = source;
    dest = dest;
    result = result;
#endif
    /* Pretend to add zero to each component of the result.
    **
    ** result->r += zero;
    ** result->g += zip;
    ** result->b += squat;
    ** result->a += a bagel;
    */
}

void __glDoBlendSourceONE(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

#ifdef __GL_LINT
    gc = gc;
    dest = dest;
#endif
    r = source->r;
    g = source->g;
    b = source->b;
    a = source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestONE(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

#ifdef __GL_LINT
    gc = gc;
    source = source;
#endif

    r = dest->r;
    g = dest->g;
    b = dest->b;
    a = dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendDestSC(__GLcontext *gc, const __GLcolor *source,
		        const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

    r = dest->r * source->r * gc->frontBuffer.oneOverRedScale;
    g = dest->g * source->g * gc->frontBuffer.oneOverGreenScale;
    b = dest->b * source->b * gc->frontBuffer.oneOverBlueScale;
    a = dest->a * source->a * gc->frontBuffer.oneOverAlphaScale;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendDestMSC(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat one = __glOne;

    r = dest->r * (one - source->r * gc->frontBuffer.oneOverRedScale);
    g = dest->g * (one - source->g * gc->frontBuffer.oneOverGreenScale);
    b = dest->b * (one - source->b * gc->frontBuffer.oneOverBlueScale);
    a = dest->a * (one - source->a * gc->frontBuffer.oneOverAlphaScale);

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceDC(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

    r = source->r * dest->r * gc->frontBuffer.oneOverRedScale;
    g = source->g * dest->g * gc->frontBuffer.oneOverGreenScale;
    b = source->b * dest->b * gc->frontBuffer.oneOverBlueScale;
    a = source->a * dest->a * gc->frontBuffer.oneOverAlphaScale;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendSourceMDC(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat one = __glOne;

    r = source->r * (one - dest->r * gc->frontBuffer.oneOverRedScale);
    g = source->g * (one - dest->g * gc->frontBuffer.oneOverGreenScale);
    b = source->b * (one - dest->b * gc->frontBuffer.oneOverBlueScale);
    a = source->a * (one - dest->a * gc->frontBuffer.oneOverAlphaScale);

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendSourceSA(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

#ifdef __GL_LINT
    dest = dest;
#endif
    a = source->a * gc->frontBuffer.oneOverAlphaScale;

    r = a * source->r;
    g = a * source->g;
    b = a * source->b;
    a = a * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestSA(__GLcontext *gc, const __GLcolor *source,
		        const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;

    r = a * dest->r;
    g = a * dest->g;
    b = a * dest->b;
    a = a * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceMSA(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat msa = __glOne - source->a * gc->frontBuffer.oneOverAlphaScale;

#ifdef __GL_LINT
    dest = dest;
#endif
    r = msa * source->r;
    g = msa * source->g;
    b = msa * source->b;
    a = msa * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestMSA(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat msa = 
	    __glOne - source->a * gc->frontBuffer.oneOverAlphaScale;

    r = msa * dest->r;
    g = msa * dest->g;
    b = msa * dest->b;
    a = msa * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceDA(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b;
    __GLfloat a = dest->a * gc->frontBuffer.oneOverAlphaScale;

    r = a * source->r;
    g = a * source->g;
    b = a * source->b;
    a = a * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestDA(__GLcontext *gc, const __GLcolor *source,
		        const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b;
    __GLfloat a = dest->a * gc->frontBuffer.oneOverAlphaScale;

#ifdef __GL_LINT
    source = source;
#endif
    r = a * dest->r;
    g = a * dest->g;
    b = a * dest->b;
    a = a * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceMDA(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat mda;

    mda = __glOne - dest->a * gc->frontBuffer.oneOverAlphaScale;

    r = mda * source->r;
    g = mda * source->g;
    b = mda * source->b;
    a = mda * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestMDA(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat mda;

#ifdef __GL_LINT
    source = source;
#endif
    mda = __glOne - dest->a * gc->frontBuffer.oneOverAlphaScale;

    r = mda * dest->r;
    g = mda * dest->g;
    b = mda * dest->b;
    a = mda * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceSAT(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b;
    __GLfloat sa, mda;

    mda = __glOne - dest->a * gc->frontBuffer.oneOverAlphaScale;
    sa = source->a * gc->frontBuffer.oneOverAlphaScale;
    if (sa < mda) {
	r = sa * source->r;
	g = sa * source->g;
	b = sa * source->b;
    } else {
	r = mda * source->r;
	g = mda * source->g;
	b = mda * source->b;
    }
    result->a = source->a;
    result->r = r;
    result->g = g;
    result->b = b;
}

/************************************************************************/

static void Nop(__GLcontext *gc, const __GLcolor *source,
                const __GLcolor *dest, __GLcolor *result)
{
#ifdef __GL_LINT
    gc = gc;
    source = source;
    dest = dest;
    result = result;
#endif
}

/*
** Generic blend not handled by cases below
*/
static void NoFetchBlend(__GLcontext *gc, __GLcolorBuffer *cfb,
			 const __GLfragment *frag, __GLcolor *result)
{
#ifdef __GL_LINT
    cfb = cfb;
#endif
    (*gc->procs.blendColor)(gc, &(frag->color), NULL, result);
}

/*
** Generic blend not handled by cases below
*/
static void FetchBlend(__GLcontext *gc, __GLcolorBuffer *cfb,
		       const __GLfragment *frag, __GLcolor *result) 
{
    __GLcolor dest;

    (*cfb->fetch)(cfb, frag->x, frag->y, &dest);

    (*gc->procs.blendColor)(gc, &(frag->color), &dest, result);
}

void __glDoBlend(__GLcontext *gc, const __GLcolor *source,
	          const __GLcolor *dest, __GLcolor *result)
{
    (*gc->procs.blendSrc)(gc, source, dest, result);
    (*gc->procs.blendDst)(gc, source, dest, result);

    if (result->r > gc->frontBuffer.redScale) {
	result->r = gc->frontBuffer.redScale;
    }
    if (result->g > gc->frontBuffer.greenScale) {
	result->g = gc->frontBuffer.greenScale;
    }
    if (result->b > gc->frontBuffer.blueScale) {
	result->b = gc->frontBuffer.blueScale;
    }
    if (result->a > gc->frontBuffer.alphaScale) {
	result->a = gc->frontBuffer.alphaScale;
    }
}

void __glDoBlendNoClamp(__GLcontext *gc, const __GLcolor *source,
	                 const __GLcolor *dest, __GLcolor *result)
{
    (*gc->procs.blendSrc)(gc, source, dest, result);
    (*gc->procs.blendDst)(gc, source, dest, result);
}

/*
** Source function == SRC_ALPHA and dest function == ZERO
*/
void __glDoBlend_SA_ZERO(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a;

#ifdef __GL_LINT
    dest = dest;
#endif
    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    result->r = source->r * a;
    result->g = source->g * a;
    result->b = source->b * a;
    result->a = source->a * a;
}

/*
** Source function == SRC_ALPHA and dest function == ONE
*/
void __glDoBlend_SA_ONE(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, ra, rr, rg, rb;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    rr = dest->r + source->r * a;
    if (rr > gc->frontBuffer.redScale) {
	rr = gc->frontBuffer.redScale;
    }
    rg = dest->g + source->g * a;
    if (rg > gc->frontBuffer.greenScale) {
	rg = gc->frontBuffer.greenScale;
    }
    rb = dest->b + source->b * a;
    if (rb > gc->frontBuffer.blueScale) {
	rb = gc->frontBuffer.blueScale;
    }
    ra = dest->a + source->a * a;
    if (ra > gc->frontBuffer.alphaScale) {
	ra = gc->frontBuffer.alphaScale;
    }

    result->r = rr;
    result->g = rg;
    result->b = rb;
    result->a = ra;
}

/*
** Source function == SRC_ALPHA and dest function == ONE_MINUS_SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_SA_MSA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, msa, rr, rg, rb, ra;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    msa = __glOne - a;
    rr = source->r * a + dest->r * msa;
    rg = source->g * a + dest->g * msa;
    rb = source->b * a + dest->b * msa;
    ra = source->a * a + dest->a * msa;

    result->r = rr;
    result->g = rg;
    result->b = rb;
    result->a = ra;
}

/*
** Source function == ONE_MINUS_SRC_ALPHA and dest function == SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_MSA_SA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, msa, rr, rg, rb, ra;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    msa = __glOne - a;
    rr = source->r * msa + dest->r * a;
    rg = source->g * msa + dest->g * a;
    rb = source->b * msa + dest->b * a;
    ra = source->a * msa + dest->a * a;

    result->r = rr;
    result->g = rg;
    result->b = rb;
    result->a = ra;
}

/*
** Source function == DST_ALPHA and dest function == ONE_MINUS_DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_DA_MDA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, mda;

    a = dest->a * gc->frontBuffer.oneOverAlphaScale;
    mda = __glOne - a;

    result->r = a * source->r + mda * dest->r;
    result->g = a * source->g + mda * dest->g;
    result->b = a * source->b + mda * dest->b;
    result->a = a * source->a + mda * dest->a;
}

/*
** Source function == ONE_MINUS_DST_ALPHA and dest function == DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_MDA_DA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, mda;

    a = dest->a * gc->frontBuffer.oneOverAlphaScale;
    mda = __glOne - a;

    result->r = mda * source->r + a * dest->r;
    result->g = mda * source->g + a * dest->g;
    result->b = mda * source->b + a * dest->b;
    result->a = mda * source->a + a * dest->a;
}


/* Generic blend span func.
*/
void FASTCALL __glBlendSpan(__GLcontext *gc)
{
    __GLcolor *cp, *fcp, temp;
    GLint w;

    // Fetch span if required
    if( gc->procs.blend == FetchBlend )
        __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;

    while (--w >= 0) {
	(*gc->procs.blendColor)(gc, cp, fcp, &temp);
	*cp = temp;
	cp++;
	fcp++;
    }
}

/*
** Source function == SRC_ALPHA and dest function == ONE_MINUS_SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_SA_MSA(__GLcontext *gc)
{
    __GLfloat a, msa, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = cp->a * oneOverAlpha;
	msa = one - a;

	rr = cp->r * a + fcp->r * msa;
	rg = cp->g * a + fcp->g * msa;
	rb = cp->b * a + fcp->b * msa;
	ra = cp->a * a + fcp->a * msa;

	cp->r = rr;
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
	fcp++;
    }
}

/*
** Source function == ONE_MINUS_SRC_ALPHA and dest function == SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_MSA_SA(__GLcontext *gc)
{
    __GLfloat a, msa, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = cp->a * oneOverAlpha;
	msa = __glOne - a;
	rr = cp->r * msa + fcp->r * a;
	rg = cp->g * msa + fcp->g * a;
	rb = cp->b * msa + fcp->b * a;
	ra = cp->a * msa + fcp->a * a;

	cp->r = rr;
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
	fcp++;
    }
}

void FASTCALL __glBlendSpan_SA_ZERO(__GLcontext *gc)
{
    __GLfloat a, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp;
    GLint w;

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = cp->a * oneOverAlpha;
	rr = cp->r * a;
	rg = cp->g * a;
	rb = cp->b * a;
	ra = cp->a * a;

	cp->r = rr;
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
    }
}

/*
** Source function == SRC_ALPHA and dest function == ONE
** Clamping is required
*/
void FASTCALL __glBlendSpan_SA_ONE(__GLcontext *gc)
{
    __GLfloat a, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat rs, gs, bs, as;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;
    as = gc->frontBuffer.alphaScale;
    while (--w >= 0) {
	a = cp->a * gc->frontBuffer.oneOverAlphaScale;
	rr = fcp->r + cp->r * a;
	rg = fcp->g + cp->g * a;
	if (rr > rs) {
	    rr = rs;
	}
	rb = fcp->b + cp->b * a;
	if (rg > gs) {
	    rg = gs;
	}
	ra = fcp->a + cp->a * a;
	if (rb > bs) {
	    rb = bs;
	}

	cp->r = rr;
	if (ra > as) {
	    ra = as;
	}
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
	fcp++;
    }
}

/*
** Source function == DST_ALPHA and dest function == ONE_MINUS_DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_DA_MDA(__GLcontext *gc)
{
    __GLfloat a, mda, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = fcp->a * oneOverAlpha;
	mda = one - a;

	cp->r = cp->r * a + fcp->r * mda;
	cp->g = cp->g * a + fcp->g * mda;
	cp->b = cp->b * a + fcp->b * mda;
	cp->a = cp->a * a + fcp->a * mda;

	cp++;
	fcp++;
    }
}

/*
** Source function == ONE_MINUS_DST_ALPHA and dest function == DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_MDA_DA(__GLcontext *gc)
{
    __GLfloat a, mda, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = fcp->a * oneOverAlpha;
	mda = one - a;

	cp->r = cp->r * mda + fcp->r * a;
	cp->g = cp->g * mda + fcp->g * a;
	cp->b = cp->b * mda + fcp->b * a;
	cp->a = cp->a * mda + fcp->a * a;

	cp++;
	fcp++;
    }
}

/************************************************************************/

void FASTCALL __glGenericPickBlendProcs(__GLcontext *gc)
{
    GLenum s = gc->state.raster.blendSrc;
    GLenum d = gc->state.raster.blendDst;

    if (gc->modes.colorIndexMode) {
	return;
    }
    /* Does the blending function need to fetch the dst color? */
    gc->procs.blendSpan = __glBlendSpan;
    if (d == GL_ZERO && s != GL_DST_COLOR && s != GL_ONE_MINUS_DST_COLOR &&
	    s != GL_DST_ALPHA && s != GL_ONE_MINUS_DST_ALPHA &&
	    s != GL_SRC_ALPHA_SATURATE) {
	gc->procs.blend = NoFetchBlend;
    } else {
	gc->procs.blend = FetchBlend;
    }
    if (!(gc->state.enables.general & __GL_BLEND_ENABLE)) {
	gc->procs.blendColor = Nop;
    } else {
	/* Look for any fast paths */
	if (s == GL_SRC_ALPHA) {
	    if (d == GL_ZERO) {
		gc->procs.blendColor = __glDoBlend_SA_ZERO;
		gc->procs.blendSpan = __glBlendSpan_SA_ZERO;
		return;
	    }
	    if (d == GL_ONE) {
		gc->procs.blendColor = __glDoBlend_SA_ONE;
		gc->procs.blendSpan = __glBlendSpan_SA_ONE;
		return;
	    }
	    if (d == GL_ONE_MINUS_SRC_ALPHA) {
		gc->procs.blendColor = __glDoBlend_SA_MSA;
		gc->procs.blendSpan = __glBlendSpan_SA_MSA;
		return;
	    }
	}
	else if (s == GL_ONE_MINUS_SRC_ALPHA) {
	    if (d == GL_SRC_ALPHA) {
		gc->procs.blendColor = __glDoBlend_MSA_SA;
		gc->procs.blendSpan = __glBlendSpan_MSA_SA;
		return;
	    }
	}
	else if (s == GL_DST_ALPHA) {
	    if (d == GL_ONE_MINUS_DST_ALPHA) {
		gc->procs.blendColor = __glDoBlend_DA_MDA;
		gc->procs.blendSpan = __glBlendSpan_DA_MDA;
		return;
	    }
        }
        else if (s == GL_ONE_MINUS_DST_ALPHA) {
	    if (d == GL_DST_ALPHA) {
		gc->procs.blendColor = __glDoBlend_MDA_DA;
		gc->procs.blendSpan = __glBlendSpan_MDA_DA;
		return;
	    }
        }

	/* Use generic blend function */
	if (    (d == GL_ONE_MINUS_SRC_COLOR) ||
	        (s == GL_ONE_MINUS_DST_COLOR) ||
	        (d == GL_ZERO) ||
	        (s == GL_ZERO)) {
	    gc->procs.blendColor = __glDoBlendNoClamp;
	} else {
	    gc->procs.blendColor = __glDoBlend;
	}
	switch (s) {
	  case GL_ZERO:
	    gc->procs.blendSrc = __glDoBlendSourceZERO;
	    break;
	  case GL_ONE:
	    gc->procs.blendSrc = __glDoBlendSourceONE;
	    break;
	  case GL_DST_COLOR:
	    gc->procs.blendSrc = __glDoBlendSourceDC;
	    break;
	  case GL_ONE_MINUS_DST_COLOR:
	    gc->procs.blendSrc = __glDoBlendSourceMDC;
	    break;
	  case GL_SRC_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceSA;
	    break;
	  case GL_ONE_MINUS_SRC_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceMSA;
	    break;
	  case GL_DST_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceDA;
	    break;
	  case GL_ONE_MINUS_DST_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceMDA;
	    break;
	  case GL_SRC_ALPHA_SATURATE:
	    gc->procs.blendSrc = __glDoBlendSourceSAT;
	    break;
	}
	switch (d) {
	  case GL_ZERO:
	    gc->procs.blendDst = __glDoBlendDestZERO;
	    break;
	  case GL_ONE:
	    gc->procs.blendDst = __glDoBlendDestONE;
	    break;
	  case GL_SRC_COLOR:
	    gc->procs.blendDst = __glDoBlendDestSC;
	    break;
	  case GL_ONE_MINUS_SRC_COLOR:
	    gc->procs.blendDst = __glDoBlendDestMSC;
	    break;
	  case GL_SRC_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestSA;
	    break;
	  case GL_ONE_MINUS_SRC_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestMSA;
	    break;
	  case GL_DST_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestDA;
	    break;
	  case GL_ONE_MINUS_DST_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestMDA;
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_conte.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <fixed.h>

static GLfloat DefaultAmbient[4] = { 0.2f, 0.2f, 0.2f, 1.0 };
static GLfloat DefaultDiffuse[4] = { 0.8f, 0.8f, 0.8f, 1.0 };
static GLfloat DefaultBlack[4] = { 0.0, 0.0, 0.0, 1.0 };
static GLfloat DefaultWhite[4] = { 1.0, 1.0, 1.0, 1.0 };

#ifdef NT
#define UB2F(ub)  ((GLfloat) ((ub) / 255.0))
#define B2F(b)    ((GLfloat) ((2 * (b) + 1) / 255.0))

GLfloat __glUByteToFloat[256] = {
    UB2F(  0), UB2F(  1), UB2F(  2), UB2F(  3),
    UB2F(  4), UB2F(  5), UB2F(  6), UB2F(  7),
    UB2F(  8), UB2F(  9), UB2F( 10), UB2F( 11),
    UB2F( 12), UB2F( 13), UB2F( 14), UB2F( 15),
    UB2F( 16), UB2F( 17), UB2F( 18), UB2F( 19),
    UB2F( 20), UB2F( 21), UB2F( 22), UB2F( 23),
    UB2F( 24), UB2F( 25), UB2F( 26), UB2F( 27),
    UB2F( 28), UB2F( 29), UB2F( 30), UB2F( 31),
    UB2F( 32), UB2F( 33), UB2F( 34), UB2F( 35),
    UB2F( 36), UB2F( 37), UB2F( 38), UB2F( 39),
    UB2F( 40), UB2F( 41), UB2F( 42), UB2F( 43),
    UB2F( 44), UB2F( 45), UB2F( 46), UB2F( 47),
    UB2F( 48), UB2F( 49), UB2F( 50), UB2F( 51),
    UB2F( 52), UB2F( 53), UB2F( 54), UB2F( 55),
    UB2F( 56), UB2F( 57), UB2F( 58), UB2F( 59),
    UB2F( 60), UB2F( 61), UB2F( 62), UB2F( 63),
    UB2F( 64), UB2F( 65), UB2F( 66), UB2F( 67),
    UB2F( 68), UB2F( 69), UB2F( 70), UB2F( 71),
    UB2F( 72), UB2F( 73), UB2F( 74), UB2F( 75),
    UB2F( 76), UB2F( 77), UB2F( 78), UB2F( 79),
    UB2F( 80), UB2F( 81), UB2F( 82), UB2F( 83),
    UB2F( 84), UB2F( 85), UB2F( 86), UB2F( 87),
    UB2F( 88), UB2F( 89), UB2F( 90), UB2F( 91),
    UB2F( 92), UB2F( 93), UB2F( 94), UB2F( 95),
    UB2F( 96), UB2F( 97), UB2F( 98), UB2F( 99),
    UB2F(100), UB2F(101), UB2F(102), UB2F(103),
    UB2F(104), UB2F(105), UB2F(106), UB2F(107),
    UB2F(108), UB2F(109), UB2F(110), UB2F(111),
    UB2F(112), UB2F(113), UB2F(114), UB2F(115),
    UB2F(116), UB2F(117), UB2F(118), UB2F(119),
    UB2F(120), UB2F(121), UB2F(122), UB2F(123),
    UB2F(124), UB2F(125), UB2F(126), UB2F(127),
    UB2F(128), UB2F(129), UB2F(130), UB2F(131),
    UB2F(132), UB2F(133), UB2F(134), UB2F(135),
    UB2F(136), UB2F(137), UB2F(138), UB2F(139),
    UB2F(140), UB2F(141), UB2F(142), UB2F(143),
    UB2F(144), UB2F(145), UB2F(146), UB2F(147),
    UB2F(148), UB2F(149), UB2F(150), UB2F(151),
    UB2F(152), UB2F(153), UB2F(154), UB2F(155),
    UB2F(156), UB2F(157), UB2F(158), UB2F(159),
    UB2F(160), UB2F(161), UB2F(162), UB2F(163),
    UB2F(164), UB2F(165), UB2F(166), UB2F(167),
    UB2F(168), UB2F(169), UB2F(170), UB2F(171),
    UB2F(172), UB2F(173), UB2F(174), UB2F(175),
    UB2F(176), UB2F(177), UB2F(178), UB2F(179),
    UB2F(180), UB2F(181), UB2F(182), UB2F(183),
    UB2F(184), UB2F(185), UB2F(186), UB2F(187),
    UB2F(188), UB2F(189), UB2F(190), UB2F(191),
    UB2F(192), UB2F(193), UB2F(194), UB2F(195),
    UB2F(196), UB2F(197), UB2F(198), UB2F(199),
    UB2F(200), UB2F(201), UB2F(202), UB2F(203),
    UB2F(204), UB2F(205), UB2F(206), UB2F(207),
    UB2F(208), UB2F(209), UB2F(210), UB2F(211),
    UB2F(212), UB2F(213), UB2F(214), UB2F(215),
    UB2F(216), UB2F(217), UB2F(218), UB2F(219),
    UB2F(220), UB2F(221), UB2F(222), UB2F(223),
    UB2F(224), UB2F(225), UB2F(226), UB2F(227),
    UB2F(228), UB2F(229), UB2F(230), UB2F(231),
    UB2F(232), UB2F(233), UB2F(234), UB2F(235),
    UB2F(236), UB2F(237), UB2F(238), UB2F(239),
    UB2F(240), UB2F(241), UB2F(242), UB2F(243),
    UB2F(244), UB2F(245), UB2F(246), UB2F(247),
    UB2F(248), UB2F(249), UB2F(250), UB2F(251),
    UB2F(252), UB2F(253), UB2F(254), UB2F(255),
};

GLfloat __glByteToFloat[256] = {
    B2F(   0), B2F(   1), B2F(   2), B2F(   3),
    B2F(   4), B2F(   5), B2F(   6), B2F(   7),
    B2F(   8), B2F(   9), B2F(  10), B2F(  11),
    B2F(  12), B2F(  13), B2F(  14), B2F(  15),
    B2F(  16), B2F(  17), B2F(  18), B2F(  19),
    B2F(  20), B2F(  21), B2F(  22), B2F(  23),
    B2F(  24), B2F(  25), B2F(  26), B2F(  27),
    B2F(  28), B2F(  29), B2F(  30), B2F(  31),
    B2F(  32), B2F(  33), B2F(  34), B2F(  35),
    B2F(  36), B2F(  37), B2F(  38), B2F(  39),
    B2F(  40), B2F(  41), B2F(  42), B2F(  43),
    B2F(  44), B2F(  45), B2F(  46), B2F(  47),
    B2F(  48), B2F(  49), B2F(  50), B2F(  51),
    B2F(  52), B2F(  53), B2F(  54), B2F(  55),
    B2F(  56), B2F(  57), B2F(  58), B2F(  59),
    B2F(  60), B2F(  61), B2F(  62), B2F(  63),
    B2F(  64), B2F(  65), B2F(  66), B2F(  67),
    B2F(  68), B2F(  69), B2F(  70), B2F(  71),
    B2F(  72), B2F(  73), B2F(  74), B2F(  75),
    B2F(  76), B2F(  77), B2F(  78), B2F(  79),
    B2F(  80), B2F(  81), B2F(  82), B2F(  83),
    B2F(  84), B2F(  85), B2F(  86), B2F(  87),
    B2F(  88), B2F(  89), B2F(  90), B2F(  91),
    B2F(  92), B2F(  93), B2F(  94), B2F(  95),
    B2F(  96), B2F(  97), B2F(  98), B2F(  99),
    B2F( 100), B2F( 101), B2F( 102), B2F( 103),
    B2F( 104), B2F( 105), B2F( 106), B2F( 107),
    B2F( 108), B2F( 109), B2F( 110), B2F( 111),
    B2F( 112), B2F( 113), B2F( 114), B2F( 115),
    B2F( 116), B2F( 117), B2F( 118), B2F( 119),
    B2F( 120), B2F( 121), B2F( 122), B2F( 123),
    B2F( 124), B2F( 125), B2F( 126), B2F( 127),
    B2F(-128), B2F(-127), B2F(-126), B2F(-125),
    B2F(-124), B2F(-123), B2F(-122), B2F(-121),
    B2F(-120), B2F(-119), B2F(-118), B2F(-117),
    B2F(-116), B2F(-115), B2F(-114), B2F(-113),
    B2F(-112), B2F(-111), B2F(-110), B2F(-109),
    B2F(-108), B2F(-107), B2F(-106), B2F(-105),
    B2F(-104), B2F(-103), B2F(-102), B2F(-101),
    B2F(-100), B2F( -99), B2F( -98), B2F( -97),
    B2F( -96), B2F( -95), B2F( -94), B2F( -93),
    B2F( -92), B2F( -91), B2F( -90), B2F( -89),
    B2F( -88), B2F( -87), B2F( -86), B2F( -85),
    B2F( -84), B2F( -83), B2F( -82), B2F( -81),
    B2F( -80), B2F( -79), B2F( -78), B2F( -77),
    B2F( -76), B2F( -75), B2F( -74), B2F( -73),
    B2F( -72), B2F( -71), B2F( -70), B2F( -69),
    B2F( -68), B2F( -67), B2F( -66), B2F( -65),
    B2F( -64), B2F( -63), B2F( -62), B2F( -61),
    B2F( -60), B2F( -59), B2F( -58), B2F( -57),
    B2F( -56), B2F( -55), B2F( -54), B2F( -53),
    B2F( -52), B2F( -51), B2F( -50), B2F( -49),
    B2F( -48), B2F( -47), B2F( -46), B2F( -45),
    B2F( -44), B2F( -43), B2F( -42), B2F( -41),
    B2F( -40), B2F( -39), B2F( -38), B2F( -37),
    B2F( -36), B2F( -35), B2F( -34), B2F( -33),
    B2F( -32), B2F( -31), B2F( -30), B2F( -29),
    B2F( -28), B2F( -27), B2F( -26), B2F( -25),
    B2F( -24), B2F( -23), B2F( -22), B2F( -21),
    B2F( -20), B2F( -19), B2F( -18), B2F( -17),
    B2F( -16), B2F( -15), B2F( -14), B2F( -13),
    B2F( -12), B2F( -11), B2F( -10), B2F(  -9),
    B2F(  -8), B2F(  -7), B2F(  -6), B2F(  -5),
    B2F(  -4), B2F(  -3), B2F(  -2), B2F(  -1),
};
#endif // NT

/*
** Early initialization of context.  Very little is done here, just enough
** to make a context viable.
*/

void FASTCALL __glEarlyInitContext(__GLcontext *gc)
{
    GLint numLights, attribDepth;
    GLint i;

    ASSERTOPENGL(__GL_MAX_MAX_VIEWPORT == __GL_MAX_WINDOW_WIDTH &&
		 __GL_MAX_MAX_VIEWPORT == __GL_MAX_WINDOW_HEIGHT,
		 "__GL_MAX_MAX_VIEWPORT mismatch\n");

    gc->constants.fviewportXAdjust = (__GLfloat) gc->constants.viewportXAdjust;
    gc->constants.fviewportYAdjust = (__GLfloat) gc->constants.viewportYAdjust;
    gc->procs.pickColorMaterialProcs = __glNopGC;
    gc->procs.applyColor = __glNopGC;

    /* Allocate memory to hold variable sized things */
    numLights = gc->constants.numberOfLights;
    gc->state.light.source = (__GLlightSourceState*)
	GCALLOCZ(gc, numLights*sizeof(__GLlightSourceState));
    gc->light.lutCache = NULL;
    gc->light.source = (__GLlightSourceMachine*)
	GCALLOCZ(gc, numLights*sizeof(__GLlightSourceMachine));
    attribDepth = gc->constants.maxAttribStackDepth;
    gc->attributes.stack = (__GLattribute**)
	GCALLOCZ(gc, attribDepth*sizeof(__GLattribute*));
    attribDepth = gc->constants.maxClientAttribStackDepth;
    gc->clientAttributes.stack = (__GLclientAttribute**)
	GCALLOCZ(gc, attribDepth*sizeof(__GLclientAttribute*));
    // now lazy allocate in RenderMode
    gc->select.stack = (GLuint*) NULL;

#ifdef NT
    // Allocate (n-1) vertices.  The last one is reserved by polyarray code.
    (void) PolyArrayAllocBuffer(gc, POLYDATA_BUFFER_SIZE + 1);
#ifndef NEW_PARTIAL_PRIM
    for (i = 0; i < sizeof(gc->vertex.pdSaved)/sizeof(gc->vertex.pdSaved[0]); i++)
	gc->vertex.pdSaved[i].color = &gc->vertex.pdSaved[i].colors[__GL_FRONTFACE];
#endif // NEW_PARTIAL_PRIM
#endif

#ifdef _X86_

    initClipCodesTable();
    initInvSqrtTable();

#endif // _X86_

    __glEarlyInitTextureState(gc);

#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    /*
    ** Allocate any aux color buffer records
    ** Note: Does not allocate the actual buffer memory, this is done elsewhere.
    */
    if (gc->modes.maxAuxBuffers > 0) {
	gc->auxBuffer = (__GLcolorBuffer *)
	    GCALLOCZ(gc, gc->modes.maxAuxBuffers*sizeof(__GLcolorBuffer));
    }
#endif

    __glInitDlistState(gc);
}

void FASTCALL __glContextSetColorScales(__GLcontext *gc)
{
    __GLfloat one = __glOne;
    __GLattribute **spp;
    __GLattribute *sp;
    GLuint mask;
    GLint i;

    gc->frontBuffer.oneOverRedScale = one / gc->frontBuffer.redScale;
    gc->frontBuffer.oneOverGreenScale = one / gc->frontBuffer.greenScale;
    gc->frontBuffer.oneOverBlueScale = one / gc->frontBuffer.blueScale;
    gc->frontBuffer.oneOverAlphaScale = one / gc->frontBuffer.alphaScale;

    gc->vertexToBufferIdentity = GL_TRUE;
    
    if (__GL_FLOAT_NEZ(gc->redVertexScale))
    {
        gc->oneOverRedVertexScale = one / gc->redVertexScale;
    }
    else
    {
        gc->oneOverRedVertexScale = __glZero;
    }
    
    if (__GL_FLOAT_NE(gc->redVertexScale, gc->frontBuffer.redScale))
    {
        gc->redVertexToBufferScale =
            gc->frontBuffer.redScale * gc->oneOverRedVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->redVertexToBufferScale = __glOne;
    }

    if (__GL_FLOAT_NEZ(gc->greenVertexScale))
    {
        gc->oneOverGreenVertexScale = one / gc->greenVertexScale;
    }
    else
    {
        gc->oneOverGreenVertexScale = __glZero;
    }

    if (__GL_FLOAT_NE(gc->greenVertexScale, gc->frontBuffer.greenScale))
    {
        gc->greenVertexToBufferScale =
            gc->frontBuffer.greenScale * gc->oneOverGreenVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->greenVertexToBufferScale = __glOne;
    }

    if (__GL_FLOAT_NEZ(gc->blueVertexScale))
    {
        gc->oneOverBlueVertexScale = one / gc->blueVertexScale;
    }
    else
    {
        gc->oneOverBlueVertexScale = __glZero;
    }
    
    if (__GL_FLOAT_NE(gc->blueVertexScale, gc->frontBuffer.blueScale))
    {
        gc->blueVertexToBufferScale =
            gc->frontBuffer.blueScale * gc->oneOverBlueVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->blueVertexToBufferScale = __glOne;
    }

    if (__GL_FLOAT_NEZ(gc->alphaVertexScale))
    {
        gc->oneOverAlphaVertexScale = one / gc->alphaVertexScale;
    }
    else
    {
        gc->oneOverAlphaVertexScale = __glZero;
    }
    
    if (__GL_FLOAT_NE(gc->alphaVertexScale, gc->frontBuffer.alphaScale))
    {
        gc->alphaVertexToBufferScale =
            gc->frontBuffer.alphaScale * gc->oneOverAlphaVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->alphaVertexToBufferScale = __glOne;
    }

    for (spp = &gc->attributes.stack[0]; spp < gc->attributes.stackPointer; 
	    spp++) {
	sp = *spp;
	mask = sp->mask;

	if (mask & GL_CURRENT_BIT) {
	    if (gc->modes.rgbMode) {
		__glScaleColorf(gc,
		    &sp->current.rasterPos.colors[__GL_FRONTFACE],
		    &sp->current.rasterPos.colors[__GL_FRONTFACE].r);
	    }
	}
	if (mask & GL_LIGHTING_BIT) {
	    __glScaleColorf(gc,
		&sp->light.model.ambient,
		&sp->light.model.ambient.r);
	    for (i=0; i<gc->constants.numberOfLights; i++) {
		__glScaleColorf(gc,
		    &sp->light.source[i].ambient,
		    &sp->light.source[i].ambient.r);
		__glScaleColorf(gc,
		    &sp->light.source[i].diffuse,
		    &sp->light.source[i].diffuse.r);
		__glScaleColorf(gc,
		    &sp->light.source[i].specular,
		    &sp->light.source[i].specular.r);
	    }
	    __glScaleColorf(gc,
		&sp->light.front.emissive,
		&sp->light.front.emissive.r);
	    __glScaleColorf(gc,
		&sp->light.back.emissive,
		&sp->light.back.emissive.r);
	}
#ifdef NT
        if (mask & GL_FOG_BIT)
        {
            __glScaleColorf(gc, &sp->fog.color, &sp->fog.color.r);
	    if (sp->fog.color.r == sp->fog.color.g
	     && sp->fog.color.r == sp->fog.color.b)
		sp->fog.flags |= __GL_FOG_GRAY_RGB;
	    else
		sp->fog.flags &= ~__GL_FOG_GRAY_RGB;
        }

#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FOG);
#endif
#endif
    }

    if (gc->modes.rgbMode) {
	__glScaleColorf(gc, 
	        &gc->state.current.rasterPos.colors[__GL_FRONTFACE], 
		&gc->state.current.rasterPos.colors[__GL_FRONTFACE].r);
    } 

    __glScaleColorf(gc, 
	    &gc->state.light.model.ambient,
	    &gc->state.light.model.ambient.r);
    for (i=0; i<gc->constants.numberOfLights; i++) {
	__glScaleColorf(gc,
		&gc->state.light.source[i].ambient,
		&gc->state.light.source[i].ambient.r);
	__glScaleColorf(gc,
		&gc->state.light.source[i].diffuse,
		&gc->state.light.source[i].diffuse.r);
	__glScaleColorf(gc,
		&gc->state.light.source[i].specular,
		&gc->state.light.source[i].specular.r);
    }
    __glScaleColorf(gc,
   	    &gc->state.light.front.emissive, 
   	    &gc->state.light.front.emissive.r);
    __glScaleColorf(gc,
   	    &gc->state.light.back.emissive, 
   	    &gc->state.light.back.emissive.r);
#ifdef NT
    __glScaleColorf(gc, &gc->state.fog.color, &gc->state.fog.color.r);
    if (gc->state.fog.color.r == gc->state.fog.color.g
     && gc->state.fog.color.r == gc->state.fog.color.b)
	gc->state.fog.flags |= __GL_FOG_GRAY_RGB;
    else
        gc->state.fog.flags &= ~__GL_FOG_GRAY_RGB;

#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FOG);
#endif
#endif

    __glPixelSetColorScales(gc);
}

void FASTCALL __glContextUnsetColorScales(__GLcontext *gc)
{
    GLint i;
    __GLattribute **spp;
    __GLattribute *sp;
    GLuint mask;

    for (spp = &gc->attributes.stack[0]; spp < gc->attributes.stackPointer; 
	    spp++) {
	sp = *spp;
	mask = sp->mask;

	if (mask & GL_CURRENT_BIT) {
	    if (gc->modes.rgbMode) {
		__glUnScaleColorf(gc,
		    &sp->current.rasterPos.colors[__GL_FRONTFACE].r,
		    &sp->current.rasterPos.colors[__GL_FRONTFACE]);
	    }
	}
	if (mask & GL_LIGHTING_BIT) {
	    __glUnScaleColorf(gc,
		&sp->light.model.ambient.r,
		&sp->light.model.ambient);
	    for (i=0; i<gc->constants.numberOfLights; i++) {
		__glUnScaleColorf(gc,
		    &sp->light.source[i].ambient.r,
		    &sp->light.source[i].ambient);
		__glUnScaleColorf(gc,
		    &sp->light.source[i].diffuse.r,
		    &sp->light.source[i].diffuse);
		__glUnScaleColorf(gc,
		    &sp->light.source[i].specular.r,
		    &sp->light.source[i].specular);
	    }
	    __glUnScaleColorf(gc,
		&sp->light.front.emissive.r,
		&sp->light.front.emissive);
	    __glUnScaleColorf(gc,
		&sp->light.back.emissive.r,
		&sp->light.back.emissive);
	}
#ifdef NT
        if (mask & GL_FOG_BIT)
        {
            __glUnScaleColorf(gc, &sp->fog.color.r, &sp->fog.color);
#ifdef _MCD_
            MCD_STATE_DIRTY(gc, FOG);
#endif
        }
#endif
    }

    if (gc->modes.rgbMode) {
	__glUnScaleColorf(gc,
	        &gc->state.current.rasterPos.colors[__GL_FRONTFACE].r,
		&gc->state.current.rasterPos.colors[__GL_FRONTFACE]);
    }
    __glUnScaleColorf(gc, 
	    &gc->state.light.model.ambient.r,
	    &gc->state.light.model.ambient);
    for (i=0; i<gc->constants.numberOfLights; i++) {
	__glUnScaleColorf(gc,
		&gc->state.light.source[i].ambient.r,
		&gc->state.light.source[i].ambient);
	__glUnScaleColorf(gc,
		&gc->state.light.source[i].diffuse.r,
		&gc->state.light.source[i].diffuse);
	__glUnScaleColorf(gc,
		&gc->state.light.source[i].specular.r,
		&gc->state.light.source[i].specular);
    }
    __glUnScaleColorf(gc,
   	    &gc->state.light.front.emissive.r,
   	    &gc->state.light.front.emissive);
    __glUnScaleColorf(gc,
   	    &gc->state.light.back.emissive.r,
   	    &gc->state.light.back.emissive);
#ifdef NT
    __glUnScaleColorf(gc, &gc->state.fog.color.r, &gc->state.fog.color);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FOG);
#endif
#endif
}

/*
** Initialize all user controllable state, plus any computed state that
** is only set by user commands.  For example, light source position
** is converted immediately into eye coordinates.
**
** Any state that would be initialized to zero is not done here because
** the memory assigned to the context has already been block zeroed.
**
** NOTE: Since this function may need memory allocation, caller must
** check that gengc->errorcode is not set indicating memory allocation
** error.  If error is set, context is in an unknown state and data
** structure integrity is not guaranteed.
*/
#if defined(_M_IA64)
#pragma optimize("",off)
#endif
void FASTCALL __glSoftResetContext(__GLcontext *gc)
{
    __GLlightSourceState *lss;
    __GLlightSourceMachine *lsm;
    __GLvertex *vx;
    GLint i, numLights;
    __GLfloat one = __glOne;

    /*
    ** Initialize constant values first so that they will
    ** be valid if needed by subsequent initialization steps.
    */

    if (gc->constants.alphaTestSize == 0) {
	gc->constants.alphaTestSize = 256;	/* A default */
    }
    gc->constants.alphaTableConv = (gc->constants.alphaTestSize - 1) / 
	    gc->frontBuffer.alphaScale;

    // viewportEpsilon is the smallest representable value in window
    // coordinates.  The number of fractional bits in a window
    // coordinate is known and fixed, so compute epsilon directly
    gc->constants.viewportEpsilon = 1.0f/(1 << __GL_VERTEX_FRAC_BITS);
    gc->constants.viewportAlmostHalf =
        __glHalf - gc->constants.viewportEpsilon;

    /* Allocate memory to hold variable sized things */
    numLights = gc->constants.numberOfLights;

    /* Misc machine state */
    gc->beginMode = __GL_NEED_VALIDATE;
    gc->dirtyMask = __GL_DIRTY_ALL;
    gc->validateMask = (GLuint) ~0;
    gc->attributes.stackPointer = &gc->attributes.stack[0];
    gc->clientAttributes.stackPointer = &gc->clientAttributes.stack[0];
#ifndef NT
// NT vertex allocation is done in __glEarlyInitContext.
    gc->vertex.v0 = &gc->vertex.vbuf[0];

    vx = &gc->vertex.vbuf[0];
    for (i = 0; i < __GL_NVBUF; i++, vx++) {
	vx->color = &vx->colors[__GL_FRONTFACE];
    }
#endif

    /* We need to initialize the matrix stuff early (before we handle */
    /* lighting) since we cache the modelview matrix with the light   */

    __glInitTransformState(gc);
#ifdef NT
    /* __glInitTransformState does memory allocation (incl. modelView */
    /* matrix which is needed later in this function.  If error code  */
    /* is set, we must exit.                                          */
    if (((__GLGENcontext *) gc)->errorcode)
        return;
#endif

    /* GL_LIGHTING_BIT state */
    gc->state.light.model.ambient.r = DefaultAmbient[0];
    gc->state.light.model.ambient.g = DefaultAmbient[1];
    gc->state.light.model.ambient.b = DefaultAmbient[2];
    gc->state.light.model.ambient.a = DefaultAmbient[3];
    gc->state.light.front.ambient.r = DefaultAmbient[0];
    gc->state.light.front.ambient.g = DefaultAmbient[1];
    gc->state.light.front.ambient.b = DefaultAmbient[2];
    gc->state.light.front.ambient.a = DefaultAmbient[3];
    gc->state.light.front.diffuse.r = DefaultDiffuse[0];
    gc->state.light.front.diffuse.g = DefaultDiffuse[1];
    gc->state.light.front.diffuse.b = DefaultDiffuse[2];
    gc->state.light.front.diffuse.a = DefaultDiffuse[3];
    gc->state.light.front.specular.r = DefaultBlack[0];
    gc->state.light.front.specular.g = DefaultBlack[1];
    gc->state.light.front.specular.b = DefaultBlack[2];
    gc->state.light.front.specular.a = DefaultBlack[3];
    gc->state.light.front.emissive.r = DefaultBlack[0];
    gc->state.light.front.emissive.g = DefaultBlack[1];
    gc->state.light.front.emissive.b = DefaultBlack[2];
    gc->state.light.front.emissive.a = DefaultBlack[3];
    gc->state.light.front.cmapa = 0;
    gc->state.light.front.cmapd = 1;
    gc->state.light.front.cmaps = 1;
    gc->state.light.back = gc->state.light.front;

    gc->light.front.specularExponent = -1;
    gc->light.front.specTable = NULL;
    gc->light.front.cache = NULL;
    gc->light.back.specularExponent = -1;
    gc->light.back.specTable = NULL;
    gc->light.back.cache = NULL;

    /* Initialize the individual lights */
    gc->state.light.dirtyLights = (1 << gc->constants.numberOfLights)-1;
    lss = &gc->state.light.source[0];
    lsm = &gc->light.source[0];
    for (i = 0; i < numLights; i++, lss++, lsm++) {
	lss->ambient.r = DefaultBlack[0];
	lss->ambient.g = DefaultBlack[1];
	lss->ambient.b = DefaultBlack[2];
	lss->ambient.a = DefaultBlack[3];
	if (i == 0) {
	    lss->diffuse.r = DefaultWhite[0];
	    lss->diffuse.g = DefaultWhite[1];
	    lss->diffuse.b = DefaultWhite[2];
	    lss->diffuse.a = DefaultWhite[3];
	} else {
	    lss->diffuse.r = DefaultBlack[0];
	    lss->diffuse.g = DefaultBlack[1];
	    lss->diffuse.b = DefaultBlack[2];
	    lss->diffuse.a = DefaultBlack[3];
	}
        lss->lightMatrix = gc->transform.modelView->matrix;
	lss->specular = lss->diffuse;
	lss->position.z = __glOne;
	lss->positionEye.z = __glOne;
	lsm->position.z = __glOne;
        lss->direction.z = __glMinusOne;
	lss->directionEye.z = __glMinusOne;
        lss->directionEyeNorm.z = __glMinusOne;
	lsm->direction.z = __glMinusOne;
	lss->spotLightCutOffAngle = 180;
	lss->constantAttenuation = __glOne;
	lsm->spotTable = NULL;
	lsm->spotLightExponent = -1;
	lsm->cache = NULL;
    }
    gc->state.light.colorMaterialFace = GL_FRONT_AND_BACK;
    gc->state.light.colorMaterialParam = GL_AMBIENT_AND_DIFFUSE;
    gc->state.light.shadingModel = GL_SMOOTH;

    /* GL_HINT_BIT state */
    gc->state.hints.perspectiveCorrection = GL_DONT_CARE;
    gc->state.hints.pointSmooth = GL_DONT_CARE;
    gc->state.hints.lineSmooth = GL_DONT_CARE;
    gc->state.hints.polygonSmooth = GL_DONT_CARE;
    gc->state.hints.fog = GL_DONT_CARE;
#ifdef GL_WIN_phong_shading
    gc->state.hints.phong = GL_DONT_CARE;
#endif //GL_WIN_phong_shading

    /* GL_CURRENT_BIT state */
    gc->state.current.rasterPos.window.x = gc->constants.fviewportXAdjust;
    gc->state.current.rasterPos.window.y = gc->constants.fviewportYAdjust;
    gc->state.current.rasterPos.clip.w = __glOne;
    gc->state.current.rasterPos.texture.w = __glOne;
    gc->state.current.rasterPos.color
	= &gc->state.current.rasterPos.colors[__GL_FRONTFACE];
    if (gc->modes.rgbMode) {
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].r = DefaultWhite[0];
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].g = DefaultWhite[1];
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].b = DefaultWhite[2];
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].a = DefaultWhite[3];
    } else {
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].r = __glOne;
    }
    gc->state.current.validRasterPos = GL_TRUE;
    gc->state.current.edgeTag = GL_TRUE;

    /* GL_FOG_BIT state */
    gc->state.fog.mode = GL_EXP;
    gc->state.fog.density = __glOne;
#ifdef NT
    gc->state.fog.density2neg = -(__glOne);
#endif
    gc->state.fog.end = (__GLfloat) 1.0;
    gc->state.fog.flags = __GL_FOG_GRAY_RGB; // default fog color is 0,0,0,0

    /* GL_POINT_BIT state */
    gc->state.point.requestedSize = (__GLfloat) 1.0;
    gc->state.point.smoothSize = (__GLfloat) 1.0;
    gc->state.point.aliasedSize = 1;

    /* GL_LINE_BIT state */
    gc->state.line.requestedWidth = (__GLfloat) 1.0;
    gc->state.line.smoothWidth = (__GLfloat) 1.0;
    gc->state.line.aliasedWidth = 1;
    gc->state.line.stipple = 0xFFFF;
    gc->state.line.stippleRepeat = 1;

    /* GL_POLYGON_BIT state */
    gc->state.polygon.frontMode = GL_FILL;
    gc->state.polygon.backMode = GL_FILL;
    gc->state.polygon.cull = GL_BACK;
    gc->state.polygon.frontFaceDirection = GL_CCW;

    /* GL_POLYGON_STIPPLE_BIT state */
    for (i = 0; i < 4*32; i++) {
	gc->state.polygonStipple.stipple[i] = 0xFF;
    }
    for (i = 0; i < 32; i++) {
	gc->polygon.stipple[i] = 0xFFFFFFFF;
    }

    /* GL_ACCUM_BUFFER_BIT state */

    /* GL_STENCIL_BUFFER_BIT state */
    gc->state.stencil.testFunc = GL_ALWAYS;
    gc->state.stencil.mask = __GL_MAX_STENCIL_VALUE;
    gc->state.stencil.fail = GL_KEEP;
    gc->state.stencil.depthFail = GL_KEEP;
    gc->state.stencil.depthPass = GL_KEEP;
    gc->state.stencil.writeMask = __GL_MAX_STENCIL_VALUE;

    /* GL_DEPTH_BUFFER_BIT state */
    gc->state.depth.writeEnable = GL_TRUE;
    gc->state.depth.testFunc = GL_LESS;
    gc->state.depth.clear = __glOne;

    /* GL_COLOR_BUFFER_BIT state */
    gc->renderMode = GL_RENDER;
    gc->state.raster.alphaFunction = GL_ALWAYS;
    gc->state.raster.blendSrc = GL_ONE;
    gc->state.raster.blendDst = GL_ZERO;
    gc->state.raster.logicOp = GL_COPY;
    gc->state.raster.rMask = GL_TRUE;
    gc->state.raster.gMask = GL_TRUE;
    gc->state.raster.bMask = GL_TRUE;
    gc->state.raster.aMask = GL_TRUE;
    if (gc->modes.doubleBufferMode) {
	gc->state.raster.drawBuffer = GL_BACK;
    } else {
	gc->state.raster.drawBuffer = GL_FRONT;
    }
    gc->state.raster.drawBufferReturn = gc->state.raster.drawBuffer;
    gc->state.current.userColor.r = (__GLfloat) 1.0;
    gc->state.current.userColor.g = (__GLfloat) 1.0;
    gc->state.current.userColor.b = (__GLfloat) 1.0;
    gc->state.current.userColor.a = (__GLfloat) 1.0;
    gc->state.current.userColorIndex = (__GLfloat) 1.0;
    if (gc->modes.colorIndexMode) {
	gc->state.raster.writeMask = (gc)->frontBuffer.redMax;
    }
    gc->state.enables.general |= __GL_DITHER_ENABLE;

    gc->select.hit = GL_FALSE;
    gc->select.sp = gc->select.stack;

    /*
    ** Initialize larger subsystems by calling their init codes.
    */
    __glInitEvaluatorState(gc);
    __glInitTextureState(gc);
    __glInitPixelState(gc);
    __glInitLUTCache(gc);
#ifdef NT
    __glInitVertexArray(gc);
#endif
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ALL);
#endif
}

#if defined(_M_IA64)
#pragma optimize("",on)
#endif


/************************************************************************/

/*
** Free any attribute state left on the stack.  Stop at the first
** zero in the array.
*/
void FASTCALL __glFreeAttributeState(__GLcontext *gc)
{
    __GLattribute *sp, **spp;

    for (spp = &gc->attributes.stack[0];
	 spp < &gc->attributes.stack[gc->constants.maxAttribStackDepth];
	 spp++) {
	if (sp = *spp) {
	    GCFREE(gc, sp);
	} else
	    break;
    }
    GCFREE(gc, gc->attributes.stack);
}

void FASTCALL __glFreeClientAttributeState(__GLcontext *gc)
{
    __GLclientAttribute *sp, **spp;

    for (spp = &gc->clientAttributes.stack[0];
	 spp < &gc->clientAttributes.stack[gc->constants.maxClientAttribStackDepth];
	 spp++) {
	if (sp = *spp) {
	    GCFREE(gc, sp);
	} else
	    break;
    }
    GCFREE(gc, gc->clientAttributes.stack);
}

/*
** Destroy a context.  If it's the current context then the
** current context is set to GL_NULL.
*/
void FASTCALL __glDestroyContext(__GLcontext *gc)
{
    __GLcontext *oldgc;

    oldgc = (__GLcontext *)GLTEB_SRVCONTEXT();

#ifndef NT
    /* Set the global context to the one we are destroying. */
    __gl_context = gc;
#else
    // Set paTeb to NULL for now.  If we ever need to reference pa in this
    // function, then set it up appropriately.
    gc->paTeb = NULL;
    GLTEB_SET_SRVCONTEXT(gc);

    /*
    ** Need to pop all pushed attributes to free storage.
    ** Then it will be safe to delete stack entries.
    */
    if (gc->attributes.stack) {
        while (gc->attributes.stackPointer > &gc->attributes.stack[0]) {
            (void) __glInternalPopAttrib(gc, GL_TRUE);
        }
    }
    if (gc->clientAttributes.stack) {
        while (gc->clientAttributes.stackPointer > &gc->clientAttributes.stack[0]) {
            (void) __glInternalPopClientAttrib(gc, GL_FALSE, GL_TRUE);
        }
    }
#endif

    GCFREE(gc, gc->state.light.source);
    GCFREE(gc, gc->light.source);
#ifdef NT
    // now lazy allocated
    if (gc->select.stack)
#endif
	GCFREE(gc, gc->select.stack);

    GCFREE(gc, gc->state.transform.eyeClipPlanes);
    GCFREE(gc, gc->transform.modelViewStack);
    GCFREE(gc, gc->transform.projectionStack);
    GCFREE(gc, gc->transform.textureStack);
    GCFREE(gc, gc->transform.clipTemp);

    GCFREE(gc, gc->alphaTestFuncTable);
#ifdef NT
    // they are one memory allocation.
    GCFREE(gc, gc->stencilBuffer.testFuncTable);
#else
    GCFREE(gc, gc->stencilBuffer.testFuncTable);
    GCFREE(gc, gc->stencilBuffer.failOpTable);
    GCFREE(gc, gc->stencilBuffer.depthFailOpTable);
    GCFREE(gc, gc->stencilBuffer.depthPassOpTable);
#endif

    /*
    ** Free other malloc'd data associated with the context
    */
    __glFreeEvaluatorState(gc);
    __glFreePixelState(gc);
    __glFreeDlistState(gc);
    if (gc->attributes.stack)   __glFreeAttributeState(gc);
    if (gc->clientAttributes.stack)   __glFreeClientAttributeState(gc);
    if (gc->texture.texture)  __glFreeTextureState(gc);
    if (gc->light.lutCache)   __glFreeLUTCache(gc);

#ifdef NT
    // Free the vertex buffer.
    PolyArrayFreeBuffer(gc);
#endif

#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    /*
    ** Free any aux color buffer records
    ** Note: Does not free the actual buffer memory, this is done elsewhere.
    */
    if (gc->auxBuffer) GCFREE(gc, gc->auxBuffer);
#endif

    /*
    ** Note: We do not free the software buffers here.  They are attached
    ** to the drawable, and is the glx extension's responsibility to free
    ** them when the drawable is destroyed.
    */

    FREE(gc);

    if (gc == oldgc) oldgc = NULL;
#ifndef NT
    __gl_context = oldgc;
#else
    GLTEB_SET_SRVCONTEXT(oldgc);
#endif
}

#ifdef NT
// See also __glSetError
void FASTCALL __glSetErrorEarly(__GLcontext *gc, GLenum code)
{
    if (gc == (__GLcontext *) NULL)
        return;

    if (!gc->error)
	gc->error = code;

    ASSERTOPENGL(gc->error == 0
        || (gc->error >= GL_INVALID_ENUM && gc->error <= GL_OUT_OF_MEMORY),
        "Bad error code in gc\n");

    DBGLEVEL2(LEVEL_INFO, "__glSetError error: %ld (0x%lX)\n", code, code);

#if 0
    try
    {
	DebugBreak();
    }
    finally
    {
    }
#endif
}
#endif // NT

void FASTCALL __glSetError(GLenum code)
{
    __GL_SETUP();

    __glSetErrorEarly(gc, code);
}

GLint APIPRIVATE __glim_RenderMode(GLenum mode)
{
    GLint rv;
    __GL_SETUP_NOT_IN_BEGIN2();

    switch (mode) {
      case GL_RENDER:
      case GL_FEEDBACK:
      case GL_SELECT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return 0;
    }

    /* Switch out of old render mode.  Get return value. */
    switch (gc->renderMode) {
      case GL_RENDER:
	rv = 0;
	break;
      case GL_FEEDBACK:
	rv = gc->feedback.overFlowed ? -1 :
	    (GLint)((ULONG_PTR)(gc->feedback.result - gc->feedback.resultBase));
	break;
      case GL_SELECT:
	rv = gc->select.overFlowed ? -1 : gc->select.hits;
	break;
    }

    switch (mode) {
      case GL_FEEDBACK:
	if (!gc->feedback.resultBase) {
	    __glSetError(GL_INVALID_OPERATION);
	    return rv;
	}
	gc->feedback.result = gc->feedback.resultBase;
	gc->feedback.overFlowed = GL_FALSE;
	break;
      case GL_SELECT:
	if (!gc->select.stack)
	{
	    gc->select.stack = (GLuint*) GCALLOCZ
		(gc, gc->constants.maxNameStackDepth*sizeof(GLuint));
	    if (!gc->select.stack)
	    {
		__glSetError(GL_OUT_OF_MEMORY);
		return rv;
	    }
	}
	if (!gc->select.resultBase) {
	    __glSetError(GL_INVALID_OPERATION);
	    return rv;
	}
	gc->select.result = gc->select.resultBase;
	gc->select.overFlowed = GL_FALSE;
	gc->select.sp = gc->select.stack;
	gc->select.hit = GL_FALSE;
	gc->select.hits = 0;
	gc->select.z = 0;
	break;
    }
    /* Switch to new render mode - do this last! */
    if (gc->renderMode == mode) return rv;
    gc->renderMode = mode;
    __GL_DELAY_VALIDATE(gc);
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_depth.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

static __GLzValue FASTCALL Fetch(__GLdepthBuffer *fb, GLint x, GLint y)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return fp[0];
}

static GLboolean StoreNEVER(__GLdepthBuffer *fb,
			    GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_FALSE;
}

static GLboolean StoreLESS(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreLESS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z < fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z == fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreLEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreLEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z <= fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreGREATER(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreGREATER: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z > fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreNOTEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreNOTEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z != fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreGEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreGEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z >= fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreALWAYS(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreALWAYS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    fp[0] = z;
    return GL_TRUE;
}

/************************************************************************/

static GLboolean StoreLESS_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z < fp[0];
}

static GLboolean StoreEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z == fp[0];
}

static GLboolean StoreLEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z <= fp[0];
}

static GLboolean StoreGREATER_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z > fp[0];
}

static GLboolean StoreNOTEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z != fp[0];
}

static GLboolean StoreGEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z >= fp[0];
}

static GLboolean StoreALWAYS_W(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_TRUE;
}


#ifdef NT
static __GLzValue FASTCALL Fetch16(__GLdepthBuffer *fb, GLint x, GLint y)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return (__GLzValue) fp[0];
}

static GLboolean Store16NEVER(__GLdepthBuffer *fb,
			    GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_FALSE;
}

static GLboolean Store16LESS(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16LESS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z < fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16EQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16EQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z == fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16LEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16LEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z <= fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16GREATER(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16GREATER: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z > fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16NOTEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16NOTEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z != fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16GEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16GEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z >= fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16ALWAYS(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16ALWAYS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    fp[0] = (__GLz16Value)z;
    return GL_TRUE;
}

/************************************************************************/

static GLboolean Store16LESS_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z < fp[0];
}

static GLboolean Store16EQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z == fp[0];
}

static GLboolean Store16LEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z <= fp[0];
}

static GLboolean Store16GREATER_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z > fp[0];
}

static GLboolean Store16NOTEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z != fp[0];
}

static GLboolean Store16GEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z >= fp[0];
}

static GLboolean Store16ALWAYS_W(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_TRUE;
}

#endif //NT

/************************************************************************/

static void FASTCALL Clear(__GLdepthBuffer *dfb)
{
    __GLcontext *gc = dfb->buf.gc;
    __GLzValue *fb;
    GLint x, y, x1, y1;
    GLint skip, w, w32, w4, w1;
    __GLzValue z = (__GLzValue)(gc->state.depth.clear * dfb->scale);

#ifdef NT
    if( !gc->state.depth.writeEnable )
	return;
#endif

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if (((w = x1 - x) == 0) || (y1 - y == 0)) {
	return;
    }

    fb = __GL_DEPTH_ADDR(dfb, (__GLzValue*), x, y);

#ifdef NT
    ASSERTOPENGL(sizeof(ULONG) == sizeof(__GLzValue),
                 "Incorrect __GLzValue size\n");
    skip = dfb->buf.outerWidth;
    if (skip == w)
    {
        w = w * (y1 - y) * sizeof(ULONG);
        RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) z);
    }
    else
    {
        w = w * sizeof(ULONG);      // convert to byte count
        for (; y < y1; y++)
        {
            RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) z);
            fb += skip;
        }
    }
#else
    skip = dfb->buf.outerWidth - w;
    w32 = w >> 5;
    w4 = (w & 31) >> 2;
    w1 = w & 3;
    for (; y < y1; y++) {
	w = w32;
	while (--w >= 0) {
	    fb[0] = z; fb[1] = z; fb[2] = z; fb[3] = z;
	    fb[4] = z; fb[5] = z; fb[6] = z; fb[7] = z;
	    fb[8] = z; fb[9] = z; fb[10] = z; fb[11] = z;
	    fb[12] = z; fb[13] = z; fb[14] = z; fb[15] = z;
	    fb[16] = z; fb[17] = z; fb[18] = z; fb[19] = z;
	    fb[20] = z; fb[21] = z; fb[22] = z; fb[23] = z;
	    fb[24] = z; fb[25] = z; fb[26] = z; fb[27] = z;
	    fb[28] = z; fb[29] = z; fb[30] = z; fb[31] = z;
	    fb += 32;
	}
	w = w4;
	while (--w >= 0) {
	    fb[0] = z; fb[1] = z; fb[2] = z; fb[3] = z;
	    fb += 4;
	}
	w = w1;
	while (--w >= 0) {
	    *fb++ = z;
	}
	fb += skip;
    }
#endif // NT

}

#ifdef NT
/************************************************************************/

static void FASTCALL Clear16(__GLdepthBuffer *dfb)
{
    __GLcontext *gc = dfb->buf.gc;
    __GLz16Value *fb;
    GLint x, y, x1, y1;
    GLint skip, w; 
    __GLz16Value z = (__GLz16Value)(gc->state.depth.clear * dfb->scale);
    __GLzValue zz = (z << 16) | z;

#ifdef NT
    if( !gc->state.depth.writeEnable )
	return;
#endif

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if (((w = x1 - x) == 0) || (y1 - y == 0)) {
	return;
    }

    fb = __GL_DEPTH_ADDR(dfb, (__GLz16Value*), x, y);

    skip = dfb->buf.outerWidth;

    // handle word overhangs onto long boundaries

    if( (ULONG_PTR)fb & 0x2 ) { // Left word overhang
	int ysav = y;
    	__GLz16Value *fbsav = fb;

	for( ; y < y1; y ++, fb+=skip ) {
	    *fb = z;
	}
	y = ysav;
	fb = fbsav+1;
	w--;
    }
    if( (ULONG)((ULONG_PTR)fb + w*sizeof(__GLz16Value)) & 0x2 ) {  // Right overhang
	int ysav = y;
    	__GLz16Value *fbsav = fb;

	w--;
	fb += w;
	for( ; y < y1; y ++, fb+=skip ) {
	    *fb = z;
	}
	y = ysav;
	fb = fbsav;
    }

    // Do 4byte-aligned stuff

    if (skip == w)
    {
        w = w * (y1 - y) * sizeof(__GLz16Value);
        RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) zz);
    }
    else
    {
	if( skip & 0x1 ) { // skip is odd - successive lines will NOT be
			   //  quad-word aligned
	    int i;
            for (; y < y1; y++)
            {
		for( i = 0; i < w; i ++ )
		    *fb++ = z;
                fb += (skip-w);
            }
	}
	else {
            w = w * sizeof(__GLz16Value);   // convert to byte count
            for (; y < y1; y++)
            {
                RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) zz);
                fb += skip;
            }
        }
    }

}
#endif // NT

/************************************************************************/

static GLboolean (*StoreProcs[32])(__GLdepthBuffer*, GLint, GLint, __GLzValue)
 = {
    StoreNEVER,
    StoreLESS,
    StoreEQUAL,
    StoreLEQUAL,
    StoreGREATER,
    StoreNOTEQUAL,
    StoreGEQUAL,
    StoreALWAYS,
    StoreNEVER,
    StoreLESS_W,
    StoreEQUAL_W,
    StoreLEQUAL_W,
    StoreGREATER_W,
    StoreNOTEQUAL_W,
    StoreGEQUAL_W,
    StoreALWAYS_W,
    Store16NEVER,
    Store16LESS,
    Store16EQUAL,
    Store16LEQUAL,
    Store16GREATER,
    Store16NOTEQUAL,
    Store16GEQUAL,
    Store16ALWAYS,
    Store16NEVER,
    Store16LESS_W,
    Store16EQUAL_W,
    Store16LEQUAL_W,
    Store16GREATER_W,
    Store16NOTEQUAL_W,
    Store16GEQUAL_W,
    Store16ALWAYS_W
};

static void FASTCALL Pick(__GLcontext *gc, __GLdepthBuffer *fb, GLint depthIndex)
{
    fb->store = StoreProcs[depthIndex];
    fb->storeRaw = StoreProcs[depthIndex];
}

void FASTCALL __glInitDepth32(__GLcontext *gc, __GLdepthBuffer *fb)
{
    fb->buf.elementSize = sizeof(__GLzValue);
    fb->buf.gc = gc;
    fb->scale = (__GLzValue) ~0;
    fb->writeMask = (__GLzValue) ~0;
    fb->pick = Pick;
    fb->clear = Clear;
    fb->store2 = StoreALWAYS;
    fb->fetch = Fetch;
}

#ifdef NT
void FASTCALL __glInitDepth16(__GLcontext *gc, __GLdepthBuffer *fb)
{
    fb->buf.elementSize = sizeof(__GLz16Value);
    fb->buf.gc = gc;
    fb->scale = (__GLz16Value) ~0;
    fb->writeMask = (__GLz16Value) ~0;
    fb->pick = Pick;
    fb->clear = Clear16;
    fb->store2 = Store16ALWAYS;
    fb->fetch = Fetch16;
}
#endif

void FASTCALL __glFreeDepth32(__GLcontext *gc, __GLdepthBuffer *fb)
{
#ifdef __GL_LINT
    gc = gc;
    fb = fb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_eval.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.26 $
** $Date: 1993/11/29 01:18:49 $
*/
#include "precomp.h"
#pragma hdrstop

#include "attrib.h"

static const
struct defaultMap {
    GLint	index;
    GLint	k;
    __GLfloat	values[4];
} defaultMaps[__GL_MAP_RANGE_COUNT] = {
    {__GL_C4, 4, 1.0, 1.0, 1.0, 1.0},
    {__GL_I , 1, 1.0, 0.0, 0.0, 0.0},
    {__GL_N3, 3, 0.0, 0.0, 1.0, 0.0},
    {__GL_T1, 1, 0.0, 0.0, 0.0, 0.0},
    {__GL_T2, 2, 0.0, 0.0, 0.0, 0.0},
    {__GL_T3, 3, 0.0, 0.0, 0.0, 0.0},
    {__GL_T4, 4, 0.0, 0.0, 0.0, 1.0},
    {__GL_V3, 3, 0.0, 0.0, 0.0, 0.0},
    {__GL_V4, 4, 0.0, 0.0, 0.0, 1.0},
};

void FASTCALL __glInitEvaluatorState(__GLcontext *gc)
{
    int i,j;
    const struct defaultMap *defMap;
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat **eval1Data;
    __GLfloat **eval2Data;

    for (i = 0; i < __GL_MAP_RANGE_COUNT; i++) {
	defMap = &(defaultMaps[i]);
	eval1 = &(gc->eval.eval1[i]);
	eval2 = &(gc->eval.eval2[i]);
	eval1Data = &(gc->eval.eval1Data[i]);
	eval2Data = &(gc->eval.eval2Data[i]);

	eval1->order = 1;
	eval1->u1 = __glZero;
	eval1->u2 = __glOne;
	eval1->k = defMap->k;
	eval2->majorOrder = 1;
	eval2->minorOrder = 1;
	eval2->u1 = __glZero;
	eval2->u2 = __glOne;
	eval2->v1 = __glZero;
	eval2->v2 = __glOne;
	eval2->k = defMap->k;
	*eval1Data = (__GLfloat *)
	    GCALLOC(gc, (size_t) (sizeof(__GLfloat) * defMap->k));
#ifdef NT
        if (NULL == *eval1Data) {
            return;
        }
#endif /* NT */
	*eval2Data = (__GLfloat *)
	    GCALLOC(gc, (size_t) (sizeof(__GLfloat) * defMap->k));
#ifdef NT
        if (NULL == *eval2Data) {
            return;
        }
#endif /* NT */
	for (j = 0; j < defMap->k; j++) {
	    (*eval1Data)[j] = defMap->values[j];
	    (*eval2Data)[j] = defMap->values[j];
	}
    }

    gc->eval.uorder = __glZero;
    gc->eval.vorder = __glZero;
    gc->eval.evalStackState = __glZero;

    gc->state.evaluator.u1.start = __glZero;
    gc->state.evaluator.u2.start = __glZero;
    gc->state.evaluator.v2.start = __glZero;
    gc->state.evaluator.u1.finish = __glOne;
    gc->state.evaluator.u2.finish = __glOne;
    gc->state.evaluator.v2.finish = __glOne;
    gc->state.evaluator.u1.n = 1;
    gc->state.evaluator.u2.n = 1;
    gc->state.evaluator.v2.n = 1;
}

void FASTCALL __glFreeEvaluatorState(__GLcontext *gc)
{
    int i;
    __GLevaluatorMachine *evals = &gc->eval;

    for (i = 0; i < __GL_MAP_RANGE_COUNT; i++) {
        if (evals->eval1Data[i]) {
            GCFREE(gc, evals->eval1Data[i]);
            evals->eval1Data[i] = 0;
        }
        if (evals->eval2Data[i]) {
            GCFREE(gc, evals->eval2Data[i]);
            evals->eval2Data[i] = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_feedb.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.21 $
** $Date: 1993/09/23 16:37:59 $
*/
#include "precomp.h"
#pragma hdrstop

void APIPRIVATE __glim_FeedbackBuffer(GLsizei bufferLength, GLenum type, GLfloat buffer[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((type < GL_2D) || (type > GL_4D_COLOR_TEXTURE)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (bufferLength < 0) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    if (gc->renderMode == GL_FEEDBACK) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }
    gc->feedback.resultBase = buffer;
    gc->feedback.result = buffer;
    gc->feedback.resultLength = bufferLength;
    gc->feedback.overFlowed = GL_FALSE;
    gc->feedback.type = type;
}

void APIPRIVATE __glim_PassThrough(GLfloat element)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_FEEDBACK) {
	__glFeedbackTag(gc, GL_PASS_THROUGH_TOKEN);
	__glFeedbackTag(gc, element);
    }
}

/************************************************************************/

void __glFeedbackTag(__GLcontext *gc, GLfloat f)
{
    if (!gc->feedback.overFlowed) {
	if (gc->feedback.result >=
		    gc->feedback.resultBase + gc->feedback.resultLength) {
	    gc->feedback.overFlowed = GL_TRUE;
	} else {
	    gc->feedback.result[0] = f;
	    gc->feedback.result = gc->feedback.result + 1;
	}
    }
}

static void FASTCALL feedback(__GLcontext *gc, __GLvertex *v)
{
    GLenum type = gc->feedback.type;

#ifdef NT
// Do coordinates
    __glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
    if (gc->constants.yInverted)
	__glFeedbackTag(gc, (gc->constants.height - 
                             (v->window.y - gc->constants.fviewportYAdjust)));
    else
	__glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
    if (type != GL_2D)
	__glFeedbackTag(gc, v->window.z / gc->depthBuffer.scale);
    /*
    ** NOTE: return clip.w, as window.w has no spec defined meaning.
    ** It is true that this implementation uses window.w, but thats
    ** something different.
    */
    if (type == GL_4D_COLOR_TEXTURE)
	__glFeedbackTag(gc, v->clip.w);
#else
    switch (type) {
      case GL_2D:
	__glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
	if (gc->constants.yInverted) {
	    __glFeedbackTag(gc, (gc->constants.height - 
		    (v->window.y - gc->constants.fviewportYAdjust)) - 
		    gc->constants.viewportEpsilon);
	} else {
	    __glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
	}
	break;
      case GL_3D:
      case GL_3D_COLOR:
      case GL_3D_COLOR_TEXTURE:
	__glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
	if (gc->constants.yInverted) {
	    __glFeedbackTag(gc, (gc->constants.height - 
		    (v->window.y - gc->constants.fviewportYAdjust)) - 
		    gc->constants.viewportEpsilon);
	} else {
	    __glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
	}
	__glFeedbackTag(gc, v->window.z / gc->depthBuffer.scale);
	break;
      case GL_4D_COLOR_TEXTURE:
	__glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
	if (gc->constants.yInverted) {
	    __glFeedbackTag(gc, (gc->constants.height - 
		    (v->window.y - gc->constants.fviewportYAdjust)) - 
		    gc->constants.viewportEpsilon);
	} else {
	    __glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
	}
	__glFeedbackTag(gc, v->window.z / gc->depthBuffer.scale);
	/*
	** NOTE: return clip.w, as window.w has no spec defined meaning.
	** It is true that this implementation uses window.w, but thats
	** something different.
	*/
	__glFeedbackTag(gc, v->clip.w);
	break;
    }
#endif
    switch (type) {
      case GL_3D_COLOR:
      case GL_3D_COLOR_TEXTURE:
      case GL_4D_COLOR_TEXTURE:
	{
	    __GLcolor *c = v->color;
	    if (gc->modes.rgbMode) {
		__glFeedbackTag(gc, c->r * gc->oneOverRedVertexScale);
		__glFeedbackTag(gc, c->g * gc->oneOverGreenVertexScale);
		__glFeedbackTag(gc, c->b * gc->oneOverBlueVertexScale);
		__glFeedbackTag(gc, c->a * gc->oneOverAlphaVertexScale);
	    } else {
		__glFeedbackTag(gc, c->r);
	    }
	}
	break;
      case GL_2D:
      case GL_3D:
        break;
    }
    switch (type) {
      case GL_3D_COLOR_TEXTURE:
      case GL_4D_COLOR_TEXTURE:
	__glFeedbackTag(gc, v->texture.x);
	__glFeedbackTag(gc, v->texture.y);
	__glFeedbackTag(gc, v->texture.z);
	__glFeedbackTag(gc, v->texture.w);
	break;
      case GL_2D:
      case GL_3D:
      case GL_3D_COLOR:
	break;
    }
}

void FASTCALL __glFeedbackCopyPixels(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_COPY_PIXEL_TOKEN);
    feedback(gc, vx);
}

void FASTCALL __glFeedbackDrawPixels(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_DRAW_PIXEL_TOKEN);
    feedback(gc, vx);
}

void FASTCALL __glFeedbackBitmap(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_BITMAP_TOKEN);
    feedback(gc, vx);
}

/* feedback version of renderPoint proc */
void FASTCALL __glFeedbackPoint(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_POINT_TOKEN);
    feedback(gc, vx);
}

/* feedback version of renderLine proc */
void FASTCALL __glFeedbackLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                   GLuint flags)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLcolor *oacp;

    oacp = a->color;
    if (!(modeFlags & __GL_SHADE_SMOOTH_LIGHT)
#ifdef GL_WIN_phong_shading
        && !(modeFlags & __GL_SHADE_PHONG)
#endif //GL_WIN_phong_shading
        ) {
        a->color = b->color;
    }

    if (gc->line.notResetStipple) {
        __glFeedbackTag(gc, GL_LINE_TOKEN);
    } else {
        gc->line.notResetStipple = GL_TRUE;
        __glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
    }
    feedback(gc, a);
    feedback(gc, b);

    a->color = oacp;
}

/* feedback version of renderTriangle proc */
void FASTCALL __glFeedbackTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			  __GLvertex *c)
{
    __GLfloat dxAC, dxBC, dyAC, dyBC, area;
    GLboolean ccw;
    GLint face;
    GLuint modeFlags;
#ifdef SGI
// not used
    GLboolean first;
    __GLfloat x, y, z, wInv;
    __GLfloat vpXScale, vpYScale, vpZScale;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    __GLviewport *vp;

    /* Compute window coordinates first, if not already done */
    vp = &gc->state.viewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;
#endif

    /* Compute signed area of the triangle */
    dxAC = a->window.x - c->window.x;
    dxBC = b->window.x - c->window.x;
    dyAC = a->window.y - c->window.y;
    dyBC = b->window.y - c->window.y;
    area = dxAC * dyBC - dxBC * dyAC;
    ccw = area >= __glZero;

    /*
    ** Figure out if face is culled or not.  The face check needs to be
    ** based on the vertex winding before sorting.  This code uses the
    ** reversed flag to invert the sense of ccw - an xor accomplishes
    ** this conversion without an if test.
    **
    ** 		ccw	reversed		xor
    ** 		---	--------		---
    ** 		0	0			0 (remain !ccw)
    ** 		1	0			1 (remain ccw)
    ** 		0	1			1 (become ccw)
    ** 		1	1			0 (become cw)
    */
    face = gc->polygon.face[ccw];
    if (face == gc->polygon.cullFace) {
	/* Culled */
	return;
    }

#ifdef NT
    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
    if (modeFlags & __GL_SHADE_SMOOTH_LIGHT)
    {	/* Smooth shading */
	if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
	{
	    a->color++;
	    b->color++;
	    c->color++;
	}
    }
    else
    {	/* Flat shading */
	__GLvertex *pv = gc->vertex.provoking;
	if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
	    pv->color++;
	a->color = pv->color;
	b->color = pv->color;
	c->color = pv->color;
    }
#else
    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
    needs = gc->vertex.needs;
    if (gc->state.light.shadingModel == GL_FLAT) {
	__GLvertex *pv = gc->vertex.provoking;
	GLuint pvneeds;
	GLuint faceNeeds;
	GLint colorFace;

	if (modeFlags & __GL_SHADE_TWOSIDED) {
	    colorFace = face;
	    faceNeeds = gc->vertex.faceNeeds[face];
	} else {
	    colorFace = __GL_FRONTFACE;
	    faceNeeds = gc->vertex.faceNeeds[__GL_FRONTFACE];
	}

	pv->color = &pv->colors[colorFace];
	a->color = pv->color;
	b->color = pv->color;
	c->color = pv->color;
	pvneeds = faceNeeds & (__GL_HAS_LIGHTING |
		__GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR);
	if (~pv->has & pvneeds) {
	    (*pv->validate)(gc, pv, pvneeds);
	}
    } else {
	GLuint faceNeeds;
	GLint colorFace;

	if (modeFlags & __GL_SHADE_TWOSIDED) {
	    colorFace = face;
	    needs |= gc->vertex.faceNeeds[face];
	} else {
	    colorFace = __GL_FRONTFACE;
	    needs |= gc->vertex.faceNeeds[__GL_FRONTFACE];
	}

	a->color = &a->colors[colorFace];
	b->color = &b->colors[colorFace];
	c->color = &c->colors[colorFace];
    }
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);
#endif

    /* Deal with polygon face modes */
    switch (gc->polygon.mode[face]) {
      case __GL_POLYGON_MODE_POINT:
#ifdef NT
	if (a->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackPoint(gc, a);
	if (b->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackPoint(gc, b);
	if (c->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackPoint(gc, c);
	break;
#else
	if (a->boundaryEdge) {
	    __glFeedbackTag(gc, GL_POINT_TOKEN);
	    feedback(gc, a);
	}
	if (b->boundaryEdge) {
	    __glFeedbackTag(gc, GL_POINT_TOKEN);
	    feedback(gc, b);
	}
	if (c->boundaryEdge) {
	    __glFeedbackTag(gc, GL_POINT_TOKEN);
	    feedback(gc, c);
	}
	break;
#endif
      case __GL_POLYGON_MODE_LINE:
#ifdef NT
	if (a->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackLine(gc, a, b, 0);
	if (b->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackLine(gc, b, c, 0);
	if (c->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackLine(gc, c, a, 0);
	break;
#else
	if (a->boundaryEdge) {
	    if (!gc->line.notResetStipple) {
		gc->line.notResetStipple = GL_TRUE;
		__glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
	    } else {
		__glFeedbackTag(gc, GL_LINE_TOKEN);
	    }
	    feedback(gc, a);
	    feedback(gc, b);
	}
	if (b->boundaryEdge) {
	    if (!gc->line.notResetStipple) {
		gc->line.notResetStipple = GL_TRUE;
		__glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
	    } else {
		__glFeedbackTag(gc, GL_LINE_TOKEN);
	    }
	    feedback(gc, b);
	    feedback(gc, c);
	}
	if (c->boundaryEdge) {
	    if (!gc->line.notResetStipple) {
		gc->line.notResetStipple = GL_TRUE;
		__glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
	    } else {
		__glFeedbackTag(gc, GL_LINE_TOKEN);
	    }
	    feedback(gc, c);
	    feedback(gc, a);
	}
	break;
#endif
      case __GL_POLYGON_MODE_FILL:
	__glFeedbackTag(gc, GL_POLYGON_TOKEN);
	__glFeedbackTag(gc, 3);
	feedback(gc, a);
	feedback(gc, b);
	feedback(gc, c);
	break;
    }

    /* Restore color pointers */
    a->color = &a->colors[__GL_FRONTFACE];
    b->color = &b->colors[__GL_FRONTFACE];
    c->color = &c->colors[__GL_FRONTFACE];
    if (gc->state.light.shadingModel == GL_FLAT) {
	__GLvertex *pv = gc->vertex.provoking;

	pv->color = &pv->colors[__GL_FRONTFACE];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_fog.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/07 18:46:43 $
*/
#include "precomp.h"
#pragma hdrstop

GLboolean FASTCALL __glFogSpan(__GLcontext *gc)
{
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
#ifdef NT
    bGrayFog = !gc->modes.colorIndexMode
		&& (gc->state.fog.flags & __GL_FOG_GRAY_RGB);
    if (bGrayFog)
    {
	while (--w >= 0)
	{
	    __GLfloat delta;
	    /* clamp fog value */
	    fog = f;
	    if (fog < __glZero) fog = __glZero;
	    else if (fog > __glOne) fog = __glOne;
	    oneMinusFog = __glOne - fog;
	    delta = oneMinusFog * fogColor->r;

	    /* Blend incoming color against the fog color */
	    cp->r = fog * cp->r + delta;
	    cp->g = fog * cp->g + delta;
	    cp->b = fog * cp->b + delta;

	    f += gc->polygon.shader.dfdx;
	    cp++;
	}
    }
    else
#endif
	while (--w >= 0) {
	    /* clamp fog value */
	    fog = f;
	    if (fog < __glZero) fog = __glZero;
	    else if (fog > __glOne) fog = __glOne;
	    oneMinusFog = __glOne - fog;

	    /* Blend incoming color against the fog color */
	    if (gc->modes.colorIndexMode) {
		cp->r = cp->r + oneMinusFog * gc->state.fog.index;
	    } else {
		cp->r = fog * cp->r + oneMinusFog * fogColor->r;
		cp->g = fog * cp->g + oneMinusFog * fogColor->g;
		cp->b = fog * cp->b + oneMinusFog * fogColor->b;
	    }

	    f += gc->polygon.shader.dfdx;
	    cp++;
	}

    return GL_FALSE;
}

GLboolean FASTCALL __glFogStippledSpan(__GLcontext *gc)
{
    __GLstippleWord bit, inMask, *sp;
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog;
    GLint count;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
#ifdef NT
    bGrayFog = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;
#endif
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		/* clamp fog value */
		fog = f;
		if (fog < __glZero) fog = __glZero;
		else if (fog > __glOne) fog = __glOne;
		oneMinusFog = __glOne - fog;

		/* Blend incoming color against the fog color */
		if (gc->modes.colorIndexMode) {
		    cp->r = cp->r + oneMinusFog * gc->state.fog.index;
		} else {
#ifdef NT
		    if (bGrayFog)
		    {
			__GLfloat delta = oneMinusFog * fogColor->r;

			cp->r = fog * cp->r + delta;
			cp->g = fog * cp->g + delta;
			cp->b = fog * cp->b + delta;
		    }
		    else
#endif
		    {
			cp->r = fog * cp->r + oneMinusFog * fogColor->r;
			cp->g = fog * cp->g + oneMinusFog * fogColor->g;
			cp->b = fog * cp->b + oneMinusFog * fogColor->b;
		    }
		}
	    }
	    f += gc->polygon.shader.dfdx;
	    cp++;
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

/************************************************************************/

GLboolean FASTCALL __glFogSpanSlow(__GLcontext *gc)
{
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog, eyeZ;
    __GLfloat density, density2neg, end;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
    density = gc->state.fog.density;
#ifdef NT
    bGrayFog = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;
    density2neg = gc->state.fog.density2neg;
#else
    density2 = density * density;
    start = gc->state.fog.start;
#endif
    end = gc->state.fog.end;
    while (--w >= 0) {
#ifdef NT
	/* Compute fog value */
	eyeZ = f;
	switch (gc->state.fog.mode) {
	  case GL_EXP:
	    if (eyeZ < __glZero)
		fog = __GL_POWF(__glE,  density * eyeZ);
	    else
		fog = __GL_POWF(__glE, -density * eyeZ);
	    /* clamp fog value */
	    if (fog > __glOne) fog = __glOne;
	    break;
	  case GL_EXP2:
	    fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
	    /* clamp fog value */
	    if (fog > __glOne) fog = __glOne;
	    break;
	  case GL_LINEAR:
	    if (eyeZ < __glZero)
		fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
	    else
		fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	    /* clamp fog value */
	    if (fog < __glZero) fog = __glZero;
	    else if (fog > __glOne) fog = __glOne;
	    break;
	}
#else
	/* Compute fog value */
	eyeZ = f;
	if (eyeZ < __glZero) eyeZ = -eyeZ;
	switch (gc->state.fog.mode) {
	  case GL_EXP:
	    fog = __GL_POWF(__glE, -density * eyeZ);
	    break;
	  case GL_EXP2:
	    fog = __GL_POWF(__glE, -(density2 * eyeZ * eyeZ));
	    break;
	  case GL_LINEAR:
	    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	    break;
	}

	/* clamp fog value */
	if (fog < __glZero) fog = __glZero;
	else if (fog > __glOne) fog = __glOne;
#endif
	oneMinusFog = __glOne - fog;

	/* Blend incoming color against the fog color */
	if (gc->modes.colorIndexMode) {
	    cp->r = cp->r + oneMinusFog * gc->state.fog.index;
	} else {
#ifdef NT
    	    if (bGrayFog)
	    {
		__GLfloat delta = oneMinusFog * fogColor->r;

		cp->r = fog * cp->r + delta;
		cp->g = fog * cp->g + delta;
		cp->b = fog * cp->b + delta;
	    }
	    else
#endif
	    {
		cp->r = fog * cp->r + oneMinusFog * fogColor->r;
		cp->g = fog * cp->g + oneMinusFog * fogColor->g;
		cp->b = fog * cp->b + oneMinusFog * fogColor->b;
	    }
	}

	f += gc->polygon.shader.dfdx;
	cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glFogStippledSpanSlow(__GLcontext *gc)
{
    __GLstippleWord bit, inMask, *sp;
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog, eyeZ;
    __GLfloat density, density2neg, end;
    GLint count;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
#ifdef NT
    bGrayFog = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;
#endif
    density = gc->state.fog.density;
#ifdef NT
    density2neg = gc->state.fog.density2neg;
#else
    density2 = density * density;
    start = gc->state.fog.start;
#endif
    end = gc->state.fog.end;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
#ifdef NT
		/* Compute fog value */
		eyeZ = f;
		switch (gc->state.fog.mode) {
		  case GL_EXP:
		    if (eyeZ < __glZero)
			fog = __GL_POWF(__glE,  density * eyeZ);
		    else
			fog = __GL_POWF(__glE, -density * eyeZ);
		    /* Clamp resulting fog value */
		    if (fog > __glOne) fog = __glOne;
		    break;
		  case GL_EXP2:
		    fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
		    /* Clamp resulting fog value */
		    if (fog > __glOne) fog = __glOne;
		    break;
		  case GL_LINEAR:
		    if (eyeZ < __glZero)
			fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
		    else
			fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
		    /* Clamp resulting fog value */
		    if (fog < __glZero) fog = __glZero;
		    else if (fog > __glOne) fog = __glOne;
		    break;
		}
#else
		/* Compute fog value */
		eyeZ = f;
		if (eyeZ < __glZero) eyeZ = -eyeZ;
		switch (gc->state.fog.mode) {
		  case GL_EXP:
		    fog = __GL_POWF(__glE, -density * eyeZ);
		    break;
		  case GL_EXP2:
		    fog = __GL_POWF(__glE, -(density2 * eyeZ * eyeZ));
		    break;
		  case GL_LINEAR:
		    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
		    break;
		}

		/* Clamp resulting fog value */
		if (fog < __glZero) fog = __glZero;
		else if (fog > __glOne) fog = __glOne;
#endif
		oneMinusFog = __glOne - fog;

		/* Blend incoming color against the fog color */
		if (gc->modes.colorIndexMode) {
		    cp->r = cp->r + oneMinusFog * gc->state.fog.index;
		} else {
#ifdef NT
		    if (bGrayFog)
		    {
			__GLfloat delta = oneMinusFog * fogColor->r;

			cp->r = fog * cp->r + delta;
			cp->g = fog * cp->g + delta;
			cp->b = fog * cp->b + delta;
		    }
		    else
#endif
		    {
			cp->r = fog * cp->r + oneMinusFog * fogColor->r;
			cp->g = fog * cp->g + oneMinusFog * fogColor->g;
			cp->b = fog * cp->b + oneMinusFog * fogColor->b;
		    }
		}
	    }
	    f += gc->polygon.shader.dfdx;
	    cp++;
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

/************************************************************************/

/*
** Compute the fog value given an eyeZ.  Then blend into fragment.
** This is used when fragment fogging is done (GL_FOG_HINT == GL_NICEST)
** or by the point rendering routines.
** NOTE: the code below has the -eyeZ factored out.
*/
void __glFogFragmentSlow(__GLcontext *gc, __GLfragment *frag, __GLfloat eyeZ)
{
    __GLfloat fog, oneMinusFog, density, density2neg, end;
    __GLcolor *fogColor;

#ifdef NT
    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	if (eyeZ < __glZero)
	    fog = __GL_POWF(__glE,  density * eyeZ);
	else
	    fog = __GL_POWF(__glE, -density * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_EXP2:
	density2neg = gc->state.fog.density2neg;
	fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	if (eyeZ < __glZero)
	    fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
	else
	    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	/* clamp fog value */
	if (fog < __glZero) fog = __glZero;
	else if (fog > __glOne) fog = __glOne;
	break;
    }
#else
    if (eyeZ < __glZero) eyeZ = -eyeZ;

    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -density * eyeZ);
	break;
      case GL_EXP2:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -(density * eyeZ * density * eyeZ));
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	break;
    }

    /*
    ** clamp fog value
    */
    if (fog < __glZero)
	fog = __glZero;
    else if (fog > __glOne)
	fog = __glOne;
#endif
    oneMinusFog = __glOne - fog;

    /*
    ** Blend incoming color against the fog color
    */
    fogColor = &gc->state.fog.color;
    if (gc->modes.colorIndexMode) {
	frag->color.r = frag->color.r + oneMinusFog * gc->state.fog.index;
    } else {
#ifdef NT
	if (gc->state.fog.flags & __GL_FOG_GRAY_RGB)
	{
	    __GLfloat delta = oneMinusFog * fogColor->r;

	    frag->color.r = fog * frag->color.r + delta;
	    frag->color.g = fog * frag->color.g + delta;
	    frag->color.b = fog * frag->color.b + delta;
	}
	else
#endif
	{
	    frag->color.r = fog * frag->color.r + oneMinusFog * fogColor->r;
	    frag->color.g = fog * frag->color.g + oneMinusFog * fogColor->g;
	    frag->color.b = fog * frag->color.b + oneMinusFog * fogColor->b;
	}
    }
}


/*
** Compute generic fog value for vertex.
*/
__GLfloat FASTCALL __glFogVertex(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat eyeZ, fog, density, density2neg, end;

    eyeZ = vx->eyeZ;
#ifdef NT
    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	if (eyeZ < __glZero)
	    fog = __GL_POWF(__glE,  density * eyeZ);
	else
	    fog = __GL_POWF(__glE, -density * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_EXP2:
	density2neg = gc->state.fog.density2neg;
	fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	if (eyeZ < __glZero)
	    fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
	else
	    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	/* clamp fog value */
	if (fog < __glZero) fog = __glZero;
	else if (fog > __glOne) fog = __glOne;
	break;
    }
#else
    if (eyeZ < __glZero) eyeZ = -eyeZ;

    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -density * eyeZ);
	break;
      case GL_EXP2:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -(density * eyeZ * density * eyeZ));
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	break;
    }

    /*
    ** Since this routine is called when we are doing slow fog, we can
    ** safely clamp the fog value here. 
    */
    if (fog < __glZero)
	fog = __glZero;
    else if (fog > __glOne)
	fog = __glOne;
#endif
    
    return fog;
}

/*
** Compute linear fog value for vertex
*/
__GLfloat FASTCALL __glFogVertexLinear(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat eyeZ, fog, end;

    eyeZ = vx->eyeZ;
#ifdef NT
    end = gc->state.fog.end;
    if (eyeZ < __glZero)
	fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
    else
	fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
#else
    if (eyeZ < __glZero) eyeZ = -eyeZ;

    end = gc->state.fog.end;
    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
#endif

    if (fog < __glZero)
	fog = __glZero;
    else if (fog > __glOne)
	fog = __glOne;
    
    return fog;
}


/*
** Compute the fogged color given an incoming color and a fog value.
*/
void __glFogColorSlow(__GLcontext *gc, __GLcolor *out, __GLcolor *in, 
		      __GLfloat fog)
{
    __GLcolor *fogColor;
    __GLfloat oneMinusFog;
    __GLfloat r, g, b;

    oneMinusFog = __glOne - fog;

    /*
    ** Blend incoming color against the fog color
    */
    fogColor = &gc->state.fog.color;
    if (gc->modes.colorIndexMode) {
	out->r = in->r + oneMinusFog * gc->state.fog.index;
    } else {
#ifdef NT
	if (gc->state.fog.flags & __GL_FOG_GRAY_RGB)
	{
	    __GLfloat delta = oneMinusFog * fogColor->r;

	    out->r = fog * in->r + delta;
	    out->g = fog * in->g + delta;
	    out->b = fog * in->b + delta;
	}
	else
#endif
	{
	    /*
	    ** The following is coded like this to give the instruction scheduler
	    ** a hand.
	    */
	    r = fog * in->r;
	    g = fog * in->g;
	    b = fog * in->b;
	    r += oneMinusFog * fogColor->r;
	    g += oneMinusFog * fogColor->g;
	    b += oneMinusFog * fogColor->b;
	    out->r = r;
	    out->g = g;
	    out->b = b;
	}
	out->a = in->a;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_get.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include <devlock.h>

#define __GL_FLOAT	0	/* __GLfloat */
#define __GL_FLOAT32	1	/* api 32 bit float */
#define __GL_FLOAT64	2	/* api 64 bit float */
#define __GL_INT32	3	/* api 32 bit int */
#define __GL_BOOLEAN	4	/* api 8 bit boolean */
#define __GL_COLOR	5	/* unscaled color in __GLfloat */
#define __GL_SCOLOR	6	/* scaled color in __GLfloat */

void __glConvertResult(__GLcontext *gc, GLint fromType, const void *rawdata,
		       GLint toType, void *result, GLint size);

void APIPRIVATE __glim_GetTexEnvfv(GLenum target,
			GLenum pname, GLfloat v[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (target != GL_TEXTURE_ENV) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	v[0] = gc->state.texture.env[0].mode;
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glUnScaleColorf(gc, v, &gc->state.texture.env[0].color);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexEnviv(GLenum target,
			 GLenum pname, GLint v[])	
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (target != GL_TEXTURE_ENV) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	v[0] = gc->state.texture.env[0].mode;
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glUnScaleColori(gc, v, &gc->state.texture.env[0].color);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetTexGenfv(GLenum coord, GLenum pname,
			GLfloat v[])
{
    __GLtextureCoordState* tcs;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S:
	tcs = &gc->state.texture.s;
	break;
      case GL_T:
	tcs = &gc->state.texture.t;
	break;
      case GL_R:
	tcs = &gc->state.texture.r;
	break;
      case GL_Q:
	tcs = &gc->state.texture.q;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	v[0] = tcs->mode;
	break;
      case GL_OBJECT_PLANE:
	v[0] = tcs->objectPlaneEquation.x;
	v[1] = tcs->objectPlaneEquation.y;
	v[2] = tcs->objectPlaneEquation.z;
	v[3] = tcs->objectPlaneEquation.w;
	break;
      case GL_EYE_PLANE:
	v[0] = tcs->eyePlaneEquation.x;
	v[1] = tcs->eyePlaneEquation.y;
	v[2] = tcs->eyePlaneEquation.z;
	v[3] = tcs->eyePlaneEquation.w;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexGendv(GLenum coord, GLenum pname,
			GLdouble v[])
{
    __GLtextureCoordState* tcs;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S:
	tcs = &gc->state.texture.s;
	break;
      case GL_T:
	tcs = &gc->state.texture.t;
	break;
      case GL_R:
	tcs = &gc->state.texture.r;
	break;
      case GL_Q:
	tcs = &gc->state.texture.q;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	v[0] = tcs->mode;
	break;
      case GL_OBJECT_PLANE:
	v[0] = tcs->objectPlaneEquation.x;
	v[1] = tcs->objectPlaneEquation.y;
	v[2] = tcs->objectPlaneEquation.z;
	v[3] = tcs->objectPlaneEquation.w;
	break;
      case GL_EYE_PLANE:
	v[0] = tcs->eyePlaneEquation.x;
	v[1] = tcs->eyePlaneEquation.y;
	v[2] = tcs->eyePlaneEquation.z;
	v[3] = tcs->eyePlaneEquation.w;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexGeniv(GLenum coord, GLenum pname,
			GLint v[])
{
    __GLtextureCoordState* tcs;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S:
	tcs = &gc->state.texture.s;
	break;
      case GL_T:
	tcs = &gc->state.texture.t;
	break;
      case GL_R:
	tcs = &gc->state.texture.r;
	break;
      case GL_Q:
	tcs = &gc->state.texture.q;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	v[0] = tcs->mode;
	break;
      case GL_OBJECT_PLANE:
	__glConvertResult(gc, __GL_FLOAT, &tcs->objectPlaneEquation.x,
			  __GL_INT32, v, 4);
	break;
      case GL_EYE_PLANE:
	__glConvertResult(gc, __GL_FLOAT, &tcs->eyePlaneEquation.x,
			  __GL_INT32, v, 4);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetTexParameterfv(GLenum target,
			      GLenum pname, GLfloat v[])
{
    __GLtextureParamState *pts;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	v[0] = pts->sWrapMode;
	break;
      case GL_TEXTURE_WRAP_T:
	v[0] = pts->tWrapMode;
	break;
      case GL_TEXTURE_MIN_FILTER:
	v[0] = pts->minFilter;
	break;
      case GL_TEXTURE_MAG_FILTER:
	v[0] = pts->magFilter;
	break;
      case GL_TEXTURE_BORDER_COLOR:
	v[0] = pts->borderColor.r;
	v[1] = pts->borderColor.g;
	v[2] = pts->borderColor.b;
	v[3] = pts->borderColor.a;
	break;
      case GL_TEXTURE_PRIORITY:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, target);
	    v[0] = ptos->priority;
	}
	break;
      case GL_TEXTURE_RESIDENT:
	{
	    __GLtextureObject *pto;
	    pto = __glLookUpTextureObject(gc, target);
	    v[0] = (GLfloat)(pto->resident);
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexParameteriv(GLenum target,
			      GLenum pname, GLint v[])
{
    __GLtextureParamState *pts;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	v[0] = pts->sWrapMode;
	break;
      case GL_TEXTURE_WRAP_T:
	v[0] = pts->tWrapMode;
	break;
      case GL_TEXTURE_MIN_FILTER:
	v[0] = pts->minFilter;
	break;
      case GL_TEXTURE_MAG_FILTER:
	v[0] = pts->magFilter;
	break;
      case GL_TEXTURE_BORDER_COLOR:
	v[0] = __GL_FLOAT_TO_I(pts->borderColor.r);
	v[1] = __GL_FLOAT_TO_I(pts->borderColor.g);
	v[2] = __GL_FLOAT_TO_I(pts->borderColor.b);
	v[3] = __GL_FLOAT_TO_I(pts->borderColor.a);
	break;
      case GL_TEXTURE_PRIORITY:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, target);
	    v[0] = __GL_FLOAT_TO_I(ptos->priority);
	}
	break;
      case GL_TEXTURE_RESIDENT:
	{
	    __GLtextureObject *pto;
	    pto = __glLookUpTextureObject(gc, target);
	    v[0] = (GLint)(pto->resident);
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetTexLevelParameterfv(GLenum target, GLint level,
				   GLenum pname, GLfloat v[])
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);

    if (!tex) {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if ((level < 0) || (level >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    lp = &tex->level[level];

    switch (pname) {
      case GL_TEXTURE_WIDTH:
	v[0] = lp->width;
        break;
      case GL_TEXTURE_HEIGHT:
	if (tex->dim == 1) {
	    v[0] = lp->height - lp->border*2;
	} else {
		v[0] = lp->height;
        }
        break;
      case GL_TEXTURE_COMPONENTS:
	v[0] = lp->requestedFormat;
        break;
      case GL_TEXTURE_BORDER:
	v[0] = lp->border;
	break;
      case GL_TEXTURE_RED_SIZE:
	v[0] = lp->redSize;
	break;
      case GL_TEXTURE_GREEN_SIZE:
	v[0] = lp->greenSize;
	break;
      case GL_TEXTURE_BLUE_SIZE:
	v[0] = lp->blueSize;
	break;
      case GL_TEXTURE_ALPHA_SIZE:
	v[0] = lp->alphaSize;
	break;
      case GL_TEXTURE_LUMINANCE_SIZE:
	v[0] = lp->luminanceSize;
	break;
      case GL_TEXTURE_INTENSITY_SIZE:
	v[0] = lp->intensitySize;
	break;
      default:
	goto bad_enum;
    }
}

void APIPRIVATE __glim_GetTexLevelParameteriv(GLenum target, GLint level,
				   GLenum pname, GLint v[])
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);

    if (!tex) {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if ((level < 0) || (level >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    lp = &tex->level[level];

    switch (pname) {
      case GL_TEXTURE_WIDTH:
	v[0] = lp->width;
        break;
      case GL_TEXTURE_HEIGHT:
	if (tex->dim == 1) {
	    v[0] = lp->height - lp->border*2;
	} else {
		v[0] = lp->height;
        }
        break;
      case GL_TEXTURE_COMPONENTS:
	v[0] = lp->requestedFormat;
        break;
      case GL_TEXTURE_BORDER:
	v[0] = lp->border;
	break;
      case GL_TEXTURE_RED_SIZE:
	v[0] = lp->redSize;
	break;
      case GL_TEXTURE_GREEN_SIZE:
	v[0] = lp->greenSize;
	break;
      case GL_TEXTURE_BLUE_SIZE:
	v[0] = lp->blueSize;
	break;
      case GL_TEXTURE_ALPHA_SIZE:
	v[0] = lp->alphaSize;
	break;
      case GL_TEXTURE_LUMINANCE_SIZE:
	v[0] = lp->luminanceSize;
	break;
      case GL_TEXTURE_INTENSITY_SIZE:
	v[0] = lp->intensitySize;
	break;
      default:
	goto bad_enum;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetClipPlane(GLenum plane, GLdouble eqn[4])
{
    GLint index;
    __GL_SETUP_NOT_IN_BEGIN();

    index = plane - GL_CLIP_PLANE0;
    if ((index < 0) || (index >= gc->constants.numberOfClipPlanes)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    eqn[0] = gc->state.transform.eyeClipPlanes[index].x;
    eqn[1] = gc->state.transform.eyeClipPlanes[index].y;
    eqn[2] = gc->state.transform.eyeClipPlanes[index].z;
    eqn[3] = gc->state.transform.eyeClipPlanes[index].w;
}

/************************************************************************/

void FASTCALL __glInitImagePack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		       GLint width, GLint height, GLenum format, GLenum type, 
		       const GLvoid *buf)
{
    spanInfo->x = __glZero;
    spanInfo->zoomx = __glOne;
    spanInfo->realWidth = spanInfo->width = width;
    spanInfo->height = height;

    spanInfo->srcSkipPixels = 0;
    spanInfo->srcSkipLines = 0;
    spanInfo->srcSwapBytes = GL_FALSE;
#ifdef __GL_STIPPLE_MSB
    spanInfo->srcLsbFirst = GL_FALSE;
#else
    spanInfo->srcLsbFirst = GL_TRUE;
#endif
    spanInfo->srcLineLength = width;

    spanInfo->dstFormat = format;
    spanInfo->dstType = type;
    spanInfo->dstImage = buf;
    __glLoadPackModes(gc, spanInfo);
}

void APIPRIVATE __glim_GetTexImage(GLenum target, GLint level, GLenum format, GLenum type,
			GLvoid *texels)
{
    GLint width, height;
    GLint internalFormat;
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);

    if (!tex || (target == GL_PROXY_TEXTURE_1D) ||
	        (target == GL_PROXY_TEXTURE_2D))
    {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    if ((level < 0) || (level >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    switch (format) {
      case GL_RGBA:
      case GL_RGB:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX:
#endif
	break;
      default:
	goto bad_enum;
    }
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    lp = &tex->level[level];

    internalFormat = lp->internalFormat;

#ifdef NT
    if (internalFormat == GL_NONE)
    {
        // No texture defined so don't return any data
        // Note: This cannot be an error case because
        // covgl calls GetTexImage without an image
        // and expects success
        return;
    }
#endif

#ifdef GL_EXT_paletted_texture
    // If the request is for color index data then the source
    // must be color indices
    if (format == GL_COLOR_INDEX &&
        internalFormat != GL_COLOR_INDEX8_EXT &&
        internalFormat != GL_COLOR_INDEX16_EXT)
    {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }
#endif
    
    width = lp->width;
    if (tex->dim == 1) {
	height = lp->height - lp->border*2;
    } else {
	height = lp->height;
    }
    spanInfo.srcImage = lp->buffer;
    switch (internalFormat) {
      case GL_LUMINANCE:
	spanInfo.srcFormat = GL_RED;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo.srcFormat = __GL_RED_ALPHA;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_RGB:
	spanInfo.srcFormat = GL_RGB;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_RGBA:
	spanInfo.srcFormat = GL_RGBA;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_ALPHA:
	spanInfo.srcFormat = GL_ALPHA;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_INTENSITY:
	spanInfo.srcFormat = GL_RED;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
        // Be a little tricky here because the internal format
        // is padded to 32 bits
	spanInfo.srcFormat = GL_BGRA_EXT;
	spanInfo.srcType = GL_UNSIGNED_BYTE;
        spanInfo.srcAlignment = 4;
	break;
      case GL_BGRA_EXT:
	spanInfo.srcFormat = GL_BGRA_EXT;
	spanInfo.srcType = GL_UNSIGNED_BYTE;
        spanInfo.srcAlignment = 4;
	break;
#endif
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX16_EXT:
        // We're copying out an indexed texture
        // If the destination format is color index then we want the
        // indices to go through the normal color index processing
        // If the desination isn't color index then we do not want
        // the normal color index processing to occur because the
        // I_TO_? maps will be used.  Instead we want the texture's
        // palette to be used, so use a different format to force
        // the new code path
        if (format == GL_COLOR_INDEX)
        {
            spanInfo.srcFormat = GL_COLOR_INDEX;
        }
        else
        {
            spanInfo.srcFormat = __GL_PALETTE_INDEX;
        }
        
        if (internalFormat == GL_COLOR_INDEX8_EXT)
        {
            // We can't just use tex->paletteSize because
            // this value is used to scale float items of srcType
            // to srcType's range, not to the palette range
            spanInfo.srcPaletteSize = 255;
            spanInfo.srcType = GL_UNSIGNED_BYTE;
        }
        else
        {
            ASSERTOPENGL(internalFormat == GL_COLOR_INDEX16_EXT,
                         "Unexpected internalFormat\n");

            spanInfo.srcPaletteSize = 65535;
            spanInfo.srcType = GL_UNSIGNED_SHORT;
        }
        spanInfo.srcAlignment = 1;
        spanInfo.srcPalette = tex->paletteData;
        break;
#endif
#ifdef NT
    default:
        ASSERTOPENGL(FALSE, "Unhandled internalFormat in GetTexImage\n");
        break;
#endif
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    __glInitImagePack(gc, &spanInfo, width, height, format, type, texels);
    if (tex->dim == 1) {
	spanInfo.srcSkipLines += lp->border;
    }
    __glInitPacker(gc, &spanInfo);
    __glInitUnpacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
}

/************************************************************************/

void APIPRIVATE __glim_GetPolygonStipple(GLubyte *outImage)
{
    __GLpixelSpanInfo spanInfo;
    __GL_SETUP_NOT_IN_BEGIN();

    spanInfo.srcImage = &(gc->state.polygonStipple.stipple[0]);
    spanInfo.srcType = GL_BITMAP;
    spanInfo.srcFormat = GL_COLOR_INDEX;
    spanInfo.srcAlignment = 4;
    __glInitImagePack(gc, &spanInfo, 32, 32, GL_COLOR_INDEX, GL_BITMAP, 
	    outImage);
    __glInitPacker(gc, &spanInfo);
    __glInitUnpacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
}

/************************************************************************/

void APIPRIVATE __glim_GetLightfv(GLenum light, GLenum pname,
		       GLfloat result[])
{
    GLint index;
    __GLlightSourceState *src;
    __GL_SETUP_NOT_IN_BEGIN();

    index = light - GL_LIGHT0;
    if ((index < 0) || (index >= gc->constants.numberOfLights)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    src = &gc->state.light.source[index];
    switch (pname) {
      case GL_AMBIENT:
	__glUnScaleColorf(gc, result, &src->ambient);
	break;
      case GL_DIFFUSE:
	__glUnScaleColorf(gc, result, &src->diffuse);
	break;
      case GL_SPECULAR:
	__glUnScaleColorf(gc, result, &src->specular);
	break;
      case GL_POSITION:
	result[0] = src->positionEye.x;
	result[1] = src->positionEye.y;
	result[2] = src->positionEye.z;
	result[3] = src->positionEye.w;
	break;
      case GL_SPOT_DIRECTION:
	result[0] = src->directionEye.x;
	result[1] = src->directionEye.y;
	result[2] = src->directionEye.z;
	break;
      case GL_SPOT_EXPONENT:
	result[0] = src->spotLightExponent;
	break;
      case GL_SPOT_CUTOFF:
	result[0] = src->spotLightCutOffAngle;
	break;
      case GL_CONSTANT_ATTENUATION:
        result[0] = src->constantAttenuation;
        break;
      case GL_LINEAR_ATTENUATION:
        result[0] = src->linearAttenuation;
        break;
      case GL_QUADRATIC_ATTENUATION:
        result[0] = src->quadraticAttenuation;
        break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetLightiv(GLenum light, GLenum pname,
		       GLint result[])
{
    GLint index;
    __GLlightSourceState *src;
    __GL_SETUP_NOT_IN_BEGIN();

    index = light - GL_LIGHT0;
    if ((index < 0) || (index >= gc->constants.numberOfLights)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    src = &gc->state.light.source[index];
    switch (pname) {
      case GL_AMBIENT:
	__glUnScaleColori(gc, result, &src->ambient);
	break;
      case GL_DIFFUSE:
	__glUnScaleColori(gc, result, &src->diffuse);
	break;
      case GL_SPECULAR:
	__glUnScaleColori(gc, result, &src->specular);
	break;
      case GL_POSITION:	    
	__glConvertResult(gc, __GL_FLOAT, &src->positionEye.x,
			  __GL_INT32, result, 4);
	break;
      case GL_SPOT_DIRECTION:
	__glConvertResult(gc, __GL_FLOAT, &src->directionEye.x,
			  __GL_INT32, result, 3);
	break;
      case GL_SPOT_EXPONENT:
	__glConvertResult(gc, __GL_FLOAT, &src->spotLightExponent,
			  __GL_INT32, result, 1);
	break;
      case GL_SPOT_CUTOFF:
	__glConvertResult(gc, __GL_FLOAT, &src->spotLightCutOffAngle,
			  __GL_INT32, result, 1);
	break;
      case GL_CONSTANT_ATTENUATION:
	__glConvertResult(gc, __GL_FLOAT, &src->constantAttenuation,
			  __GL_INT32, result, 1);
        break;
      case GL_LINEAR_ATTENUATION:
	__glConvertResult(gc, __GL_FLOAT, &src->linearAttenuation,
			  __GL_INT32, result, 1);
        break;
      case GL_QUADRATIC_ATTENUATION:
	__glConvertResult(gc, __GL_FLOAT, &src->quadraticAttenuation,
			  __GL_INT32, result, 1);
        break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetMaterialfv(GLenum face, GLenum pname,
			  GLfloat result[])
{
    __GLmaterialState *mat;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (face) {
      case GL_FRONT:
	mat = &gc->state.light.front;
	break;
      case GL_BACK:
	mat = &gc->state.light.back;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_COLOR_INDEXES:
	result[0] = mat->cmapa;
	result[1] = mat->cmapd;
	result[2] = mat->cmaps;
	break;
      case GL_SHININESS:
	result[0] = mat->specularExponent;
	break;
      case GL_EMISSION:
	__glUnScaleColorf(gc, result, &mat->emissive);
	break;
      case GL_AMBIENT:
	result[0] = mat->ambient.r;
	result[1] = mat->ambient.g;
	result[2] = mat->ambient.b;
	result[3] = mat->ambient.a;
	break;
      case GL_DIFFUSE:
	result[0] = mat->diffuse.r;
	result[1] = mat->diffuse.g;
	result[2] = mat->diffuse.b;
	result[3] = mat->diffuse.a;
	break;
      case GL_SPECULAR:
	result[0] = mat->specular.r;
	result[1] = mat->specular.g;
	result[2] = mat->specular.b;
	result[3] = mat->specular.a;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetMaterialiv(GLenum face, GLenum pname,
			  GLint result[])
{
    __GLmaterialState *mat;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (face) {
      case GL_FRONT:
	mat = &gc->state.light.front;
	break;
      case GL_BACK:
	mat = &gc->state.light.back;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_COLOR_INDEXES:
	__glConvertResult(gc, __GL_FLOAT, &mat->cmapa,
			  __GL_INT32, result, 3);
	break;
      case GL_SHININESS:
	__glConvertResult(gc, __GL_FLOAT, &mat->specularExponent,
			  __GL_INT32, result, 1);
	break;
      case GL_EMISSION:
	__glUnScaleColori(gc, result, &mat->emissive);
	break;
      case GL_AMBIENT:
	result[0] = __GL_FLOAT_TO_I(mat->ambient.r);
	result[1] = __GL_FLOAT_TO_I(mat->ambient.g);
	result[2] = __GL_FLOAT_TO_I(mat->ambient.b);
	result[3] = __GL_FLOAT_TO_I(mat->ambient.a);
	break;
      case GL_DIFFUSE:
	result[0] = __GL_FLOAT_TO_I(mat->diffuse.r);
	result[1] = __GL_FLOAT_TO_I(mat->diffuse.g);
	result[2] = __GL_FLOAT_TO_I(mat->diffuse.b);
	result[3] = __GL_FLOAT_TO_I(mat->diffuse.a);
	break;
      case GL_SPECULAR:
	result[0] = __GL_FLOAT_TO_I(mat->specular.r);
	result[1] = __GL_FLOAT_TO_I(mat->specular.g);
	result[2] = __GL_FLOAT_TO_I(mat->specular.b);
	result[3] = __GL_FLOAT_TO_I(mat->specular.a);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetMapfv(GLenum target, GLenum query, GLfloat buf[])
{
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat *eval1Data, *eval2Data;
    GLfloat *rp;
    GLint index, i, t;
    __GL_SETUP_NOT_IN_BEGIN();

    /*
    ** Check if target is valid.
    */
    rp = buf;
    switch (target) {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
	index = __GL_EVAL1D_INDEX(target);
	eval1 = &gc->eval.eval1[index];
	switch (query) {
	  case GL_COEFF:
	    t = eval1->order * eval1->k;
	    eval1Data = gc->eval.eval1Data[index];
	    for (i = 0; i < t; i++) {
		*rp++ = eval1Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval1->u1;
	    *rp++ = eval1->u2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval1[index].order;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
	index = __GL_EVAL2D_INDEX(target);
	eval2 = &gc->eval.eval2[index];
	switch (query) {
	  case GL_COEFF:
	    eval2Data = gc->eval.eval2Data[index];
	    t = eval2->majorOrder * eval2->minorOrder * eval2->k;
	    for (i = 0; i < t; i++) {
		*rp++ = eval2Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval2->u1;
	    *rp++ = eval2->u2;
	    *rp++ = eval2->v1;
	    *rp++ = eval2->v2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval2[index].majorOrder;
	    *rp++ = gc->eval.eval2[index].minorOrder;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetMapdv(GLenum target, GLenum query, GLdouble buf[])
{
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat *eval1Data, *eval2Data;
    GLdouble *rp;
    GLint index, i, t;
    __GL_SETUP_NOT_IN_BEGIN();

    /*
    ** Check if target is valid.
    */
    rp = buf;
    switch (target) {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
	index = __GL_EVAL1D_INDEX(target);
	eval1 = &gc->eval.eval1[index];
	switch (query) {
	  case GL_COEFF:
	    eval1Data = gc->eval.eval1Data[index];
	    t = eval1->order * eval1->k;
	    for (i = 0; i < t; i++) {
		*rp++ = eval1Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval1->u1;
	    *rp++ = eval1->u2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval1[index].order;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
	index = __GL_EVAL2D_INDEX(target);
	eval2 = &gc->eval.eval2[index];
	switch (query) {
	  case GL_COEFF:
	    eval2Data = gc->eval.eval2Data[index];
	    t = eval2->majorOrder * eval2->minorOrder * eval2->k;
	    for (i = 0; i < t; i++) {
		*rp++ = eval2Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval2->u1;
	    *rp++ = eval2->u2;
	    *rp++ = eval2->v1;
	    *rp++ = eval2->v2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval2[index].majorOrder;
	    *rp++ = gc->eval.eval2[index].minorOrder;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetMapiv(GLenum target, GLenum query, GLint buf[])
{
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat *eval1Data, *eval2Data;
    GLint *rp;
    GLint index, t;
    __GL_SETUP_NOT_IN_BEGIN();

    /*
    ** Check if target is valid.
    */
    rp = buf;
    switch (target) {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
	index = __GL_EVAL1D_INDEX(target);
	eval1 = &gc->eval.eval1[index];
	switch (query) {
	  case GL_COEFF:
	    eval1Data = gc->eval.eval1Data[index];
	    t = eval1->order * eval1->k;
	    __glConvertResult(gc, __GL_FLOAT, eval1Data,
			      __GL_INT32, rp, t);
	    break;
	  case GL_DOMAIN:
	    __glConvertResult(gc, __GL_FLOAT, &eval1->u1,
			      __GL_INT32, rp, 2);
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval1[index].order;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
	index = __GL_EVAL2D_INDEX(target);
	eval2 = &gc->eval.eval2[index];
	switch (query) {
	  case GL_COEFF:
	    eval2Data = gc->eval.eval2Data[index];
	    t = eval2->majorOrder * eval2->minorOrder * eval2->k;
	    __glConvertResult(gc, __GL_FLOAT, eval2Data,
			      __GL_INT32, rp, t);
	    break;
	  case GL_DOMAIN:
	    __glConvertResult(gc, __GL_FLOAT, &eval2->u1,
			      __GL_INT32, rp, 4);
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval2[index].majorOrder;
	    *rp++ = gc->eval.eval2[index].minorOrder;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/*****************************************************************************/

void APIPRIVATE __glim_GetPixelMapfv(GLenum map, GLfloat buf[])
{
    GLint index;
    GLint limit;
    GLfloat *rp;
    __GLpixelMapHead *pMap;
    __GL_SETUP_NOT_IN_BEGIN();

    pMap = gc->state.pixel.pixelMap;
    index = map - GL_PIXEL_MAP_I_TO_I;
    rp = buf;
    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
	{
	    GLint *fromp = pMap[index].base.mapI;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = *fromp++;
	    }
	}
	break;
      case GL_PIXEL_MAP_I_TO_R:      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:      case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R:      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:      case GL_PIXEL_MAP_A_TO_A:
	{
	    __GLfloat *fromp = pMap[index].base.mapF;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = *fromp++;
	    }
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetPixelMapuiv(GLenum map, GLuint buf[])
{
    GLint index;
    GLint limit;
    GLuint *rp;
    __GLpixelMapHead *pMap;
    __GL_SETUP_NOT_IN_BEGIN();

    pMap = gc->state.pixel.pixelMap;
    index = map - GL_PIXEL_MAP_I_TO_I;
    rp = buf;
    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
	{
	    GLint *fromp = pMap[index].base.mapI;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = *fromp++;
	    }
	}
	break;
      case GL_PIXEL_MAP_I_TO_R:      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:      case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R:      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:      case GL_PIXEL_MAP_A_TO_A:
	{
	    __GLfloat *fromp = pMap[index].base.mapF;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = (GLuint) *fromp++;
	    }
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetPixelMapusv(GLenum map, GLushort buf[])
{
    GLint index;
    GLint limit;
    GLushort *rp;
    __GLpixelMapHead *pMap;
    __GL_SETUP_NOT_IN_BEGIN();

    pMap = gc->state.pixel.pixelMap;
    index = map - GL_PIXEL_MAP_I_TO_I;
    rp = buf;
    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
	{
	    GLint *fromp = pMap[index].base.mapI;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = (GLushort) *fromp++;
	    }
	}
	break;
      case GL_PIXEL_MAP_I_TO_R:      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:      case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R:      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:      case GL_PIXEL_MAP_A_TO_A:
	{
	    __GLfloat *fromp = pMap[index].base.mapF;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = (GLushort) *fromp++;
	    }
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

/*
** Convert the results of a query from one type to another.
*/
void __glConvertResult(__GLcontext *gc, GLint fromType, const void *rawdata,
		       GLint toType, void *result, GLint size)
{
    GLint i;
    
    switch (fromType) {
      case __GL_FLOAT:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] = 
			(GLint)(((const __GLfloat *)rawdata)[i] >= (__GLfloat) 0.0 ?
			((const __GLfloat *)rawdata)[i] + __glHalf:
			((const __GLfloat *)rawdata)[i] - __glHalf);
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const __GLfloat *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_COLOR:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] =
		    __GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[i]);
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const __GLfloat *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_SCOLOR:
	switch (toType) {
	  case __GL_FLOAT32:
	    ((GLfloat *)result)[0] =
		((const __GLfloat *)rawdata)[0] * gc->oneOverRedVertexScale;
	    ((GLfloat *)result)[1] =
		((const __GLfloat *)rawdata)[1] * gc->oneOverGreenVertexScale;
	    ((GLfloat *)result)[2] =
		((const __GLfloat *)rawdata)[2] * gc->oneOverBlueVertexScale;
	    ((GLfloat *)result)[3] =
		((const __GLfloat *)rawdata)[3] * gc->oneOverAlphaVertexScale;
	    break;
	  case __GL_FLOAT64:
	    ((GLdouble *)result)[0] =
		((const __GLfloat *)rawdata)[0] * gc->oneOverRedVertexScale;
	    ((GLdouble *)result)[1] =
		((const __GLfloat *)rawdata)[1] * gc->oneOverGreenVertexScale;
	    ((GLdouble *)result)[2] =
		((const __GLfloat *)rawdata)[2] * gc->oneOverBlueVertexScale;
	    ((GLdouble *)result)[3] =
		((const __GLfloat *)rawdata)[3] * gc->oneOverAlphaVertexScale;
	    break;
	  case __GL_INT32:
	    ((GLint *)result)[0] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[0] *
				gc->oneOverRedVertexScale);
	    ((GLint *)result)[1] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[1] *
				gc->oneOverGreenVertexScale);
	    ((GLint *)result)[2] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[2] *
				gc->oneOverBlueVertexScale);
	    ((GLint *)result)[3] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[3] *
				gc->oneOverAlphaVertexScale);
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const __GLfloat *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_INT32:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const GLint *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const GLint *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] = ((const GLint *)rawdata)[i];
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] = ((const GLint *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_BOOLEAN:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const GLboolean *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const GLboolean *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] = ((const GLboolean *)rawdata)[i];
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const GLboolean *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
    }
}

/*
** Fetch the data for a query in its internal type, then convert it to the
** type that the user asked for.
*/
void __glDoGet(GLenum sq, void *result, GLint type, const char *procName)
{
    GLint index;
    __GLfloat ftemp[100], *fp = ftemp;		/* NOTE: for floats */
    __GLfloat ctemp[100], *cp = ctemp;		/* NOTE: for colors */
    __GLfloat sctemp[100], *scp = sctemp;	/* NOTE: for scaled colors */
    GLint itemp[100], *ip = itemp;		/* NOTE: for ints */
    GLboolean ltemp[100], *lp = ltemp;		/* NOTE: for logicals */
    __GLfloat *mp;
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef __GL_LINT
    procName = procName;
#endif
    switch (sq) {
      case GL_ALPHA_TEST:
      case GL_BLEND:
      case GL_COLOR_MATERIAL:
      case GL_CULL_FACE:
      case GL_DEPTH_TEST:
      case GL_DITHER:
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
#endif //GL_WIN_specular_fog
      case GL_FOG:
      case GL_LIGHTING:
      case GL_LINE_SMOOTH:
      case GL_LINE_STIPPLE:
      case GL_INDEX_LOGIC_OP:
      case GL_COLOR_LOGIC_OP:
      case GL_NORMALIZE:
      case GL_POINT_SMOOTH:
      case GL_POLYGON_SMOOTH:
      case GL_POLYGON_STIPPLE:
      case GL_SCISSOR_TEST:
      case GL_STENCIL_TEST:
      case GL_TEXTURE_1D:
      case GL_TEXTURE_2D:
      case GL_AUTO_NORMAL:
      case GL_TEXTURE_GEN_S:
      case GL_TEXTURE_GEN_T:
      case GL_TEXTURE_GEN_R:
      case GL_TEXTURE_GEN_Q:
#ifdef GL_WIN_multiple_textures
      case GL_TEXCOMBINE_CLAMP_WIN:
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
#endif // GL_EXT_flat_paletted_lighting
      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
      case GL_VERTEX_ARRAY:
      case GL_NORMAL_ARRAY:
      case GL_COLOR_ARRAY:
      case GL_INDEX_ARRAY:
      case GL_TEXTURE_COORD_ARRAY:
      case GL_EDGE_FLAG_ARRAY:
      case GL_POLYGON_OFFSET_POINT:
      case GL_POLYGON_OFFSET_LINE:
      case GL_POLYGON_OFFSET_FILL:
	*lp++ = __glim_IsEnabled(sq);
	break;
      case GL_MAX_TEXTURE_SIZE:
	*ip++ = gc->constants.maxTextureSize;
	break;
#ifdef GL_WIN_multiple_textures
      case GL_MAX_CURRENT_TEXTURES_WIN:
        *ip++ = (int)gc->constants.numberOfCurrentTextures;
        break;
      case GL_TEXCOMBINE_NATURAL_CLAMP_WIN:
        *ip++ = (int)gc->constants.texCombineNaturalClamp;
        break;
    case GL_CURRENT_TEXTURE_INDEX_WIN:
        *ip++ = (int)gc->texture.texIndex;
        break;
#endif // GL_WIN_multiple_textures
      case GL_SUBPIXEL_BITS:
	*ip++ = gc->constants.subpixelBits;
	break;
      case GL_MAX_LIST_NESTING:
	*ip++ = __GL_MAX_LIST_NESTING;
	break;
      case GL_CURRENT_COLOR:
        *cp++ = gc->state.current.userColor.r;
        *cp++ = gc->state.current.userColor.g;
        *cp++ = gc->state.current.userColor.b;
        *cp++ = gc->state.current.userColor.a;
        break;
      case GL_CURRENT_INDEX:
        *fp++ = gc->state.current.userColorIndex;
        break;
      case GL_CURRENT_NORMAL:
        *cp++ = gc->state.current.normal.x;
        *cp++ = gc->state.current.normal.y;
        *cp++ = gc->state.current.normal.z;
        break;
      case GL_CURRENT_TEXTURE_COORDS:
        *fp++ = gc->state.current.texture.x;
        *fp++ = gc->state.current.texture.y;
        *fp++ = gc->state.current.texture.z;
        *fp++ = gc->state.current.texture.w;
        break;
      case GL_CURRENT_RASTER_INDEX:
	if (gc->modes.rgbMode) {
	    /* Always return 1 */
	    *fp++ = (__GLfloat) 1.0;
	} else {
	    *fp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
	}
	break;
      case GL_CURRENT_RASTER_COLOR:
	if (gc->modes.colorIndexMode) {
	    /* Always return 1,1,1,1 */
	    *fp++ = (__GLfloat) 1.0;
	    *fp++ = (__GLfloat) 1.0;
	    *fp++ = (__GLfloat) 1.0;
	    *fp++ = (__GLfloat) 1.0;
	} else {
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
	}
        break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
        *fp++ = gc->state.current.rasterPos.texture.x;
        *fp++ = gc->state.current.rasterPos.texture.y;
        *fp++ = gc->state.current.rasterPos.texture.z;
        *fp++ = gc->state.current.rasterPos.texture.w;
	break;
      case GL_CURRENT_RASTER_POSITION:
        *fp++ = gc->state.current.rasterPos.window.x
	    - gc->constants.fviewportXAdjust;
	if (gc->constants.yInverted) {
	    *fp++ = gc->constants.height - 
		    (gc->state.current.rasterPos.window.y - 
		     gc->constants.fviewportYAdjust) -
		     gc->constants.viewportEpsilon;
	} else {
	    *fp++ = gc->state.current.rasterPos.window.y
		- gc->constants.fviewportYAdjust;
	}
        *fp++ = gc->state.current.rasterPos.window.z / gc->depthBuffer.scale;
	*fp++ = gc->state.current.rasterPos.clip.w;
        break;
      case GL_CURRENT_RASTER_POSITION_VALID:
        *lp++ = gc->state.current.validRasterPos;
	break;
      case GL_CURRENT_RASTER_DISTANCE:
	*fp++ = gc->state.current.rasterPos.eyeZ;
	break;
      case GL_POINT_SIZE:
        *fp++ = gc->state.point.requestedSize;
        break;
      case GL_POINT_SIZE_RANGE:
        *fp++ = gc->constants.pointSizeMinimum;
        *fp++ = gc->constants.pointSizeMaximum;
        break;
      case GL_POINT_SIZE_GRANULARITY:
        *fp++ = gc->constants.pointSizeGranularity;
        break;
      case GL_LINE_WIDTH:
        *fp++ = gc->state.line.requestedWidth;
        break;
      case GL_LINE_WIDTH_RANGE:
        *fp++ = gc->constants.lineWidthMinimum;
        *fp++ = gc->constants.lineWidthMaximum;
        break;
      case GL_LINE_WIDTH_GRANULARITY:
        *fp++ = gc->constants.lineWidthGranularity;
        break;
      case GL_LINE_STIPPLE_PATTERN:
        *ip++ = gc->state.line.stipple;
        break;
      case GL_LINE_STIPPLE_REPEAT:
        *ip++ = gc->state.line.stippleRepeat;
        break;
      case GL_POLYGON_MODE:
        *ip++ = gc->state.polygon.frontMode;
        *ip++ = gc->state.polygon.backMode;
        break;
      case GL_EDGE_FLAG:
        *lp++ = gc->state.current.edgeTag;
	break;
      case GL_CULL_FACE_MODE:
        *ip++ = gc->state.polygon.cull;
        break;
      case GL_FRONT_FACE:
        *ip++ = gc->state.polygon.frontFaceDirection;
        break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
        *lp++ = gc->state.light.model.localViewer;
        break;
      case GL_LIGHT_MODEL_TWO_SIDE:
        *lp++ = gc->state.light.model.twoSided;
        break;
      case GL_LIGHT_MODEL_AMBIENT:
	__glUnScaleColorf(gc, cp, &gc->state.light.model.ambient);
	cp += 4;
        break;
      case GL_COLOR_MATERIAL_FACE:
        *ip++ = gc->state.light.colorMaterialFace;
        break;
      case GL_COLOR_MATERIAL_PARAMETER:
        *ip++ = gc->state.light.colorMaterialParam;
        break;
      case GL_SHADE_MODEL:
        *ip++ = gc->state.light.shadingModel;
        break;
      case GL_FOG_INDEX:
        *fp++ = gc->state.fog.index;
        break;
      case GL_FOG_DENSITY:
        *fp++ = gc->state.fog.density;
        break;
      case GL_FOG_START:
        *fp++ = gc->state.fog.start;
        break;
      case GL_FOG_END:
        *fp++ = gc->state.fog.end;
        break;
      case GL_FOG_MODE:
        *ip++ = gc->state.fog.mode;
        break;
      case GL_FOG_COLOR:
        *scp++ = gc->state.fog.color.r;
        *scp++ = gc->state.fog.color.g;
        *scp++ = gc->state.fog.color.b;
        *scp++ = gc->state.fog.color.a;
        break;
      case GL_DEPTH_RANGE:
	/* These get scaled like colors, to [0, 2^31-1] */
        *cp++ = gc->state.viewport.zNear;
        *cp++ = gc->state.viewport.zFar;
        break;
      case GL_DEPTH_WRITEMASK:
	*lp++ = gc->state.depth.writeEnable;
	break;
      case GL_DEPTH_CLEAR_VALUE:
	/* This gets scaled like colors, to [0, 2^31-1] */
	*cp++ = gc->state.depth.clear;
	break;
      case GL_DEPTH_FUNC:
	*ip++ = gc->state.depth.testFunc;
	break;
      case GL_ACCUM_CLEAR_VALUE:
	*cp++ = gc->state.accum.clear.r;
	*cp++ = gc->state.accum.clear.g;
	*cp++ = gc->state.accum.clear.b;
	*cp++ = gc->state.accum.clear.a;
	break;
      case GL_STENCIL_CLEAR_VALUE:
        *ip++ = gc->state.stencil.clear;
        break;
      case GL_STENCIL_FUNC:
        *ip++ = gc->state.stencil.testFunc;
        break;
      case GL_STENCIL_VALUE_MASK:
	*ip++ = gc->state.stencil.mask;
	break;
      case GL_STENCIL_FAIL:
        *ip++ = gc->state.stencil.fail;
        break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
        *ip++ = gc->state.stencil.depthFail;
        break;
      case GL_STENCIL_PASS_DEPTH_PASS:
        *ip++ = gc->state.stencil.depthPass;
        break;
      case GL_STENCIL_REF:
        *ip++ = gc->state.stencil.reference;
        break;
      case GL_STENCIL_WRITEMASK:
        *ip++ = gc->state.stencil.writeMask;
        break;
      case GL_MATRIX_MODE:
        *ip++ = gc->state.transform.matrixMode;
        break;
      case GL_VIEWPORT:
        *ip++ = gc->state.viewport.x;
        *ip++ = gc->state.viewport.y;
        *ip++ = gc->state.viewport.width;
        *ip++ = gc->state.viewport.height;
        break;
      case GL_ATTRIB_STACK_DEPTH:
        *ip++ = (GLint)((ULONG_PTR)(gc->attributes.stackPointer - gc->attributes.stack));
        break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
        *ip++ = (GLint)((ULONG_PTR)(gc->clientAttributes.stackPointer - gc->clientAttributes.stack));
        break;
      case GL_MODELVIEW_STACK_DEPTH:
        *ip++ = 1 + (GLint)((ULONG_PTR)(gc->transform.modelView - gc->transform.modelViewStack));
        break;
      case GL_PROJECTION_STACK_DEPTH:
        *ip++ = 1 + (GLint)((ULONG_PTR)(gc->transform.projection - gc->transform.projectionStack));
        break;
      case GL_TEXTURE_STACK_DEPTH:
        *ip++ = 1 + (GLint)((ULONG_PTR)(gc->transform.texture - gc->transform.textureStack));
        break;
      case GL_MODELVIEW_MATRIX:
	mp = &gc->transform.modelView->matrix.matrix[0][0];
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
        break;
      case GL_PROJECTION_MATRIX:
	mp = &gc->transform.projection->matrix.matrix[0][0];
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
        break;
      case GL_TEXTURE_MATRIX:
	mp = &gc->transform.texture->matrix.matrix[0][0];
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
        break;
      case GL_ALPHA_TEST_FUNC:
        *ip++ = gc->state.raster.alphaFunction;
        break;
      case GL_ALPHA_TEST_REF:
        *fp++ = gc->state.raster.alphaReference;
        break;
      case GL_BLEND_DST:
        *ip++ = gc->state.raster.blendDst;
        break;
      case GL_BLEND_SRC:
        *ip++ = gc->state.raster.blendSrc;
        break;
      case GL_LOGIC_OP_MODE:
        *ip++ = gc->state.raster.logicOp;
        break;
      case GL_DRAW_BUFFER:
        *ip++ = gc->state.raster.drawBufferReturn;
        break;
      case GL_READ_BUFFER:
        *ip++ = gc->state.pixel.readBufferReturn;
        break;
      case GL_SCISSOR_BOX:
        *ip++ = gc->state.scissor.scissorX;
        *ip++ = gc->state.scissor.scissorY;
        *ip++ = gc->state.scissor.scissorWidth;
        *ip++ = gc->state.scissor.scissorHeight;
        break;
      case GL_INDEX_CLEAR_VALUE:
        *fp++ = gc->state.raster.clearIndex;
        break;
      case GL_INDEX_MODE:
        *lp++ = gc->modes.colorIndexMode ? GL_TRUE : GL_FALSE;
        break;
      case GL_INDEX_WRITEMASK:
        *ip++ = gc->state.raster.writeMask;
        break;
      case GL_COLOR_CLEAR_VALUE:
        *cp++ = gc->state.raster.clear.r;
        *cp++ = gc->state.raster.clear.g;
        *cp++ = gc->state.raster.clear.b;
        *cp++ = gc->state.raster.clear.a;
        break;
      case GL_RGBA_MODE:
        *lp++ = gc->modes.rgbMode ? GL_TRUE : GL_FALSE;
        break;
      case GL_COLOR_WRITEMASK:
        *lp++ = gc->state.raster.rMask;
        *lp++ = gc->state.raster.gMask;
        *lp++ = gc->state.raster.bMask;
        *lp++ = gc->state.raster.aMask;
        break;
      case GL_RENDER_MODE:
	*ip++ = gc->renderMode;
	break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
        *ip++ = gc->state.hints.perspectiveCorrection;
        break;
      case GL_POINT_SMOOTH_HINT:
        *ip++ = gc->state.hints.pointSmooth;
        break;
      case GL_LINE_SMOOTH_HINT:
        *ip++ = gc->state.hints.lineSmooth;
        break;
      case GL_POLYGON_SMOOTH_HINT:
        *ip++ = gc->state.hints.polygonSmooth;
        break;
      case GL_FOG_HINT:
        *ip++ = gc->state.hints.fog;
        break;
#ifdef GL_WIN_phong_shading
      case GL_PHONG_HINT_WIN:
        *ip++ = gc->state.hints.phong;
        break;
#endif //GL_WIN_phong_shading
      case GL_LIST_BASE:
        *ip++ = gc->state.list.listBase;
        break;
      case GL_LIST_INDEX:
	*ip++ = gc->dlist.currentList;
	break;
      case GL_LIST_MODE:
	*ip++ = gc->dlist.mode;
	break;
      case GL_PACK_SWAP_BYTES:
        *lp++ = gc->state.pixel.packModes.swapEndian;
        break;
      case GL_PACK_LSB_FIRST:
        *lp++ = gc->state.pixel.packModes.lsbFirst;
        break;
      case GL_PACK_ROW_LENGTH:
        *ip++ = gc->state.pixel.packModes.lineLength;
        break;
      case GL_PACK_SKIP_ROWS:
        *ip++ = gc->state.pixel.packModes.skipLines;
        break;
      case GL_PACK_SKIP_PIXELS:
        *ip++ = gc->state.pixel.packModes.skipPixels;
        break;
      case GL_PACK_ALIGNMENT:
        *ip++ = gc->state.pixel.packModes.alignment;
        break;
      case GL_UNPACK_SWAP_BYTES:
        *lp++ = gc->state.pixel.unpackModes.swapEndian;
        break;
      case GL_UNPACK_LSB_FIRST:
        *lp++ = gc->state.pixel.unpackModes.lsbFirst;
        break;
      case GL_UNPACK_ROW_LENGTH:
        *ip++ = gc->state.pixel.unpackModes.lineLength;
        break;
      case GL_UNPACK_SKIP_ROWS:
        *ip++ = gc->state.pixel.unpackModes.skipLines;
        break;
      case GL_UNPACK_SKIP_PIXELS:
        *ip++ = gc->state.pixel.unpackModes.skipPixels;
        break;
      case GL_UNPACK_ALIGNMENT:
        *ip++ = gc->state.pixel.unpackModes.alignment;
        break;
      case GL_MAP_COLOR:
        *lp++ = gc->state.pixel.transferMode.mapColor;
        break;
      case GL_MAP_STENCIL:
        *lp++ = gc->state.pixel.transferMode.mapStencil;
        break;
      case GL_INDEX_SHIFT:
        *ip++ = gc->state.pixel.transferMode.indexShift;
        break;
      case GL_INDEX_OFFSET:
        *ip++ = gc->state.pixel.transferMode.indexOffset;
        break;
      case GL_RED_SCALE:
        *fp++ = gc->state.pixel.transferMode.r_scale;
        break;
      case GL_GREEN_SCALE:
        *fp++ = gc->state.pixel.transferMode.g_scale;
        break;
      case GL_BLUE_SCALE:
        *fp++ = gc->state.pixel.transferMode.b_scale;
        break;
      case GL_ALPHA_SCALE:
        *fp++ = gc->state.pixel.transferMode.a_scale;
        break;
      case GL_DEPTH_SCALE:
        *fp++ = gc->state.pixel.transferMode.d_scale;
        break;
      case GL_RED_BIAS:
        *fp++ = gc->state.pixel.transferMode.r_bias;
	break;
      case GL_GREEN_BIAS:
        *fp++ = gc->state.pixel.transferMode.g_bias;
	break;
      case GL_BLUE_BIAS:
        *fp++ = gc->state.pixel.transferMode.b_bias;
	break;
      case GL_ALPHA_BIAS:
        *fp++ = gc->state.pixel.transferMode.a_bias;
	break;
      case GL_DEPTH_BIAS:
        *fp++ = gc->state.pixel.transferMode.d_bias;
	break;
      case GL_ZOOM_X:
        *fp++ = gc->state.pixel.transferMode.zoomX;
        break;
      case GL_ZOOM_Y:
        *fp++ = gc->state.pixel.transferMode.zoomY;
        break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:      case GL_PIXEL_MAP_S_TO_S_SIZE:
      case GL_PIXEL_MAP_I_TO_R_SIZE:      case GL_PIXEL_MAP_I_TO_G_SIZE:
      case GL_PIXEL_MAP_I_TO_B_SIZE:      case GL_PIXEL_MAP_I_TO_A_SIZE:
      case GL_PIXEL_MAP_R_TO_R_SIZE:      case GL_PIXEL_MAP_G_TO_G_SIZE:
      case GL_PIXEL_MAP_B_TO_B_SIZE:      case GL_PIXEL_MAP_A_TO_A_SIZE:
	index = sq - GL_PIXEL_MAP_I_TO_I_SIZE;
	*ip++ = gc->state.pixel.pixelMap[index].size;
	break;
      case GL_MAX_EVAL_ORDER:
        *ip++ = gc->constants.maxEvalOrder;
        break;
      case GL_MAX_LIGHTS:
        *ip++ = gc->constants.numberOfLights;
        break;
      case GL_MAX_CLIP_PLANES:
	*ip++ = gc->constants.numberOfClipPlanes;
	break;
      case GL_MAX_PIXEL_MAP_TABLE:
	*ip++ = gc->constants.maxPixelMapTable;
	break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
        *ip++ = gc->constants.maxAttribStackDepth;
        break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
        *ip++ = gc->constants.maxClientAttribStackDepth;
        break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
#ifdef NT
        *ip++ = __GL_WGL_MAX_MODELVIEW_STACK_DEPTH;
#else
        *ip++ = gc->constants.maxModelViewStackDepth;
#endif
        break;
      case GL_MAX_NAME_STACK_DEPTH:
        *ip++ = gc->constants.maxNameStackDepth;
        break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
#ifdef NT
        *ip++ = __GL_WGL_MAX_PROJECTION_STACK_DEPTH;
#else
        *ip++ = gc->constants.maxProjectionStackDepth;
#endif
        break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
#ifdef NT
        *ip++ = __GL_WGL_MAX_TEXTURE_STACK_DEPTH;
#else
        *ip++ = gc->constants.maxTextureStackDepth;
#endif
        break;
      case GL_INDEX_BITS:
	*ip++ = gc->modes.indexBits;
	break;
      case GL_RED_BITS:
	*ip++ = gc->modes.redBits;
	break;
      case GL_GREEN_BITS:
	*ip++ = gc->modes.greenBits;
	break;
      case GL_BLUE_BITS:
	*ip++ = gc->modes.blueBits;
	break;
      case GL_ALPHA_BITS:
	*ip++ = gc->modes.alphaBits;
	break;
      case GL_DEPTH_BITS:
        // gc->modes.depthBits is the number of bits in the total
        // depth pixel, not just the number of active bits.
        // Usually these quantities are the same, but not always
        // for MCD.
        *ip++ = ((__GLGENcontext *)gc)->gsurf.pfd.cDepthBits;
	break;
      case GL_STENCIL_BITS:
	*ip++ = gc->modes.stencilBits;
	break;
      case GL_ACCUM_RED_BITS:
      case GL_ACCUM_GREEN_BITS:
      case GL_ACCUM_BLUE_BITS:
      case GL_ACCUM_ALPHA_BITS:
	*ip++ = gc->modes.accumBits;
	break;
      case GL_MAP1_GRID_DOMAIN:
        *fp++ = gc->state.evaluator.u1.start;
        *fp++ = gc->state.evaluator.u1.finish;
        break;
      case GL_MAP1_GRID_SEGMENTS:
        *ip++ = gc->state.evaluator.u1.n;
        break;
      case GL_MAP2_GRID_DOMAIN:
        *fp++ = gc->state.evaluator.u2.start;
        *fp++ = gc->state.evaluator.u2.finish;
        *fp++ = gc->state.evaluator.v2.start;
        *fp++ = gc->state.evaluator.v2.finish;
        break;
      case GL_MAP2_GRID_SEGMENTS:
        *ip++ = gc->state.evaluator.u2.n;
        *ip++ = gc->state.evaluator.v2.n;
        break;
      case GL_NAME_STACK_DEPTH:
	*ip++ = (GLint)((ULONG_PTR)(gc->select.sp - gc->select.stack));
	break;
      case GL_MAX_VIEWPORT_DIMS:
	*ip++ = gc->constants.maxViewportWidth;
	*ip++ = gc->constants.maxViewportHeight;
	break;
      case GL_DOUBLEBUFFER:
	*lp++ = gc->modes.doubleBufferMode ? GL_TRUE : GL_FALSE;
	break;
      case GL_AUX_BUFFERS:
	*ip++ = gc->modes.maxAuxBuffers;
	break;
      case GL_STEREO:
	*lp++ = GL_FALSE;
	break;
      case GL_TEXTURE_BINDING_1D:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, GL_TEXTURE_1D);
	    *ip++ = ptos->name;
	}
	break;
      case GL_TEXTURE_BINDING_2D:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, GL_TEXTURE_2D);
	    *ip++ = ptos->name;
	}
	break;
      case GL_POLYGON_OFFSET_FACTOR:
	*fp++ = gc->state.polygon.factor;
	break;
      case GL_POLYGON_OFFSET_UNITS:
	*fp++ = gc->state.polygon.units;
	break;
      case GL_VERTEX_ARRAY_SIZE:
	*ip++ = gc->vertexArray.vertex.size;
	break;
      case GL_VERTEX_ARRAY_TYPE:
	*ip++ = gc->vertexArray.vertex.type;
	break;
      case GL_VERTEX_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.vertex.stride;
	break;
      case GL_NORMAL_ARRAY_TYPE:
	*ip++ = gc->vertexArray.normal.type;
	break;
      case GL_NORMAL_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.normal.stride;
	break;
      case GL_COLOR_ARRAY_SIZE:
	*ip++ = gc->vertexArray.color.size;
	break;
      case GL_COLOR_ARRAY_TYPE:
	*ip++ = gc->vertexArray.color.type;
	break;
      case GL_COLOR_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.color.stride;
	break;
      case GL_INDEX_ARRAY_TYPE:
	*ip++ = gc->vertexArray.index.type;
	break;
      case GL_INDEX_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.index.stride;
	break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
	*ip++ = gc->vertexArray.texCoord.size;
	break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
	*ip++ = gc->vertexArray.texCoord.type;
	break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.texCoord.stride;
	break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.edgeFlag.stride;
	break;
      case GL_FEEDBACK_BUFFER_SIZE:
        *ip++ = gc->feedback.resultLength;
        break;
      case GL_FEEDBACK_BUFFER_TYPE:
        *ip++ = gc->feedback.type;
        break;
      case GL_SELECTION_BUFFER_SIZE:
        *ip++ = gc->select.resultLength;
        break;
      case GL_MAX_ELEMENTS_INDICES_WIN:
	*ip++ = VA_DRAWRANGEELEM_MAX_INDICES;
	break;
      case GL_MAX_ELEMENTS_VERTICES_WIN:
	*ip++ = VA_DRAWRANGEELEM_MAX_VERTICES;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    /* Use the motion of the pointers to type convert the result */
    if (ip != itemp) {
	__glConvertResult(gc, __GL_INT32, itemp, type, result, (GLint)((ULONG_PTR)(ip - itemp)));
    } else
    if (fp != ftemp) {
	__glConvertResult(gc, __GL_FLOAT, ftemp, type, result, (GLint)((ULONG_PTR)(fp - ftemp)));
    } else
    if (lp != ltemp) {
	__glConvertResult(gc, __GL_BOOLEAN, ltemp, type, result, (GLint)((ULONG_PTR)(lp - ltemp)));
    } else
    if (cp != ctemp) {
	__glConvertResult(gc, __GL_COLOR, ctemp, type, result, (GLint)((ULONG_PTR)(cp - ctemp)));
    } else
    if (scp != sctemp) {
	__glConvertResult(gc, __GL_SCOLOR, sctemp, type, result, (GLint)((ULONG_PTR)(scp - sctemp)));
    }
}

#ifdef NT
// __glGenDoGet implemented in ..\generic\gencx.c
extern void FASTCALL __glGenDoGet(GLenum, void *, GLint, const char *);
#endif

void APIPRIVATE __glim_GetDoublev(GLenum sq, GLdouble result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_FLOAT64, "glGetDoublev");
#else
    __glDoGet(sq, result, __GL_FLOAT64, "glGetDoublev");
#endif
}

void APIPRIVATE __glim_GetFloatv(GLenum sq, GLfloat result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_FLOAT32, "glGetFloatv");
#else
    __glDoGet(sq, result, __GL_FLOAT32, "glGetFloatv");
#endif
}

void APIPRIVATE __glim_GetIntegerv(GLenum sq, GLint result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_INT32, "glGetIntegerv");
#else
    __glDoGet(sq, result, __GL_INT32, "glGetIntegerv");
#endif
}

void APIPRIVATE __glim_GetBooleanv(GLenum sq, GLboolean result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_BOOLEAN, "glGetBooleanv");
#else
    __glDoGet(sq, result, __GL_BOOLEAN, "glGetBooleanv");
#endif
}

/*
** Return the current error code.
*/
GLenum APIPRIVATE __glim_GetError(void)
{
    __GL_SETUP();
    GLint error;

#ifdef NT
    // glGetError is supposed to return GL_INVALID_OPERATION within
    // a glBegin/glEnd pair but this can cause problems with apps
    // which don't expect it.  The suggested behavior is to return
    // GL_NO_ERROR inside glBegin/glEnd but set the error code to
    // GL_INVALID_OPERATION so a later glGetError outside of the
    // glBegin/glEnd will return it
    if (__GL_IN_BEGIN())
    {
        error = GL_NO_ERROR;
        gc->error = GL_INVALID_OPERATION;
    }
    else
    {
#endif
        error = gc->error;
        gc->error = 0;
#ifdef NT
    }
#endif

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_light.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Lighting and coloring code.
**
** $Revision: 1.42 $
** $Date: 1993/12/08 02:20:39 $
*/

#include "precomp.h"
#pragma hdrstop

/*
** Scale an incoming color from the user.
*/
void FASTCALL __glScaleColorf(__GLcontext *gc, __GLcolor *dst, const GLfloat src[4])
{
    dst->r = src[0] * gc->redVertexScale;
    dst->g = src[1] * gc->greenVertexScale;
    dst->b = src[2] * gc->blueVertexScale;
    dst->a = src[3] * gc->alphaVertexScale;
}

/*
** Clamp and scale an incoming color from the user.
*/
void FASTCALL __glClampAndScaleColorf(__GLcontext *gc, __GLcolor *d, const GLfloat s[4])
{
    __GLfloat zero = __glZero;

    d->r = s[0] * gc->redVertexScale;
    if (d->r < zero) d->r = zero;
    if (d->r > gc->redVertexScale) d->r = gc->redVertexScale;

    d->g = s[1] * gc->greenVertexScale;
    if (d->g < zero) d->g = zero;
    if (d->g > gc->greenVertexScale) d->g = gc->greenVertexScale;

    d->b = s[2] * gc->blueVertexScale;
    if (d->b < zero) d->b = zero;
    if (d->b > gc->blueVertexScale) d->b = gc->blueVertexScale;

    d->a = s[3] * gc->alphaVertexScale;
    if (d->a < zero) d->a = zero;
    if (d->a > gc->alphaVertexScale) d->a = gc->alphaVertexScale;
}

/*
** Clamp an incoming color from the user.
*/
void FASTCALL __glClampColorf(__GLcontext *gc, __GLcolor *d, const GLfloat s[4])
{
    __GLfloat zero = __glZero;
    __GLfloat one = __glOne;
    __GLfloat r,g,b,a;

    r = s[0];
    g = s[1];
    b = s[2];
    a = s[3];

    if (r < zero) d->r = zero;
    else if (r > one) d->r = one;
    else d->r = r;

    if (g < zero) d->g = zero;
    else if (g > one) d->g = one;
    else d->g = g;

    if (b < zero) d->b = zero;
    else if (b > one) d->b = one;
    else d->b = b;

    if (a < zero) d->a = zero;
    else if (a > one) d->a = one;
    else d->a = a;
}

/*
** Clamp and scale an incoming color from the user.
*/
void FASTCALL __glClampAndScaleColori(__GLcontext *gc, __GLcolor *d, const GLint s[4])
{
    __GLfloat zero = __glZero;

    d->r = __GL_I_TO_FLOAT(s[0]) * gc->redVertexScale;
    if (d->r < zero) d->r = zero;
    if (d->r > gc->redVertexScale) d->r = gc->redVertexScale;

    d->g = __GL_I_TO_FLOAT(s[1]) * gc->greenVertexScale;
    if (d->g < zero) d->g = zero;
    if (d->g > gc->greenVertexScale) d->g = gc->greenVertexScale;

    d->b = __GL_I_TO_FLOAT(s[2]) * gc->blueVertexScale;
    if (d->b < zero) d->b = zero;
    if (d->b > gc->blueVertexScale) d->b = gc->blueVertexScale;

    d->a = __GL_I_TO_FLOAT(s[3]) * gc->alphaVertexScale;
    if (d->a < zero) d->a = zero;
    if (d->a > gc->alphaVertexScale) d->a = gc->alphaVertexScale;
}

/*
** Clamp an incoming color from the user.
*/
void FASTCALL __glClampColori(__GLcontext *gc, __GLcolor *d, const GLint s[4])
{
    __GLfloat zero = __glZero;
    __GLfloat one = __glOne;
    __GLfloat r,g,b,a;

    r = __GL_I_TO_FLOAT(s[0]);
    g = __GL_I_TO_FLOAT(s[1]);
    b = __GL_I_TO_FLOAT(s[2]);
    a = __GL_I_TO_FLOAT(s[3]);

    if (r < zero) d->r = zero;
    else if (r > one) d->r = one;
    else d->r = r;

    if (g < zero) d->g = zero;
    else if (g > one) d->g = one;
    else d->g = g;

    if (b < zero) d->b = zero;
    else if (b > one) d->b = one;
    else d->b = b;

    if (a < zero) d->a = zero;
    else if (a > one) d->a = one;
    else d->a = a;
}

/*
** Reverse the scaling back to the users original
*/
void FASTCALL __glUnScaleColorf(__GLcontext *gc, GLfloat dst[4], const __GLcolor* src)
{
    dst[0] = src->r * gc->oneOverRedVertexScale;
    dst[1] = src->g * gc->oneOverGreenVertexScale;
    dst[2] = src->b * gc->oneOverBlueVertexScale;
    dst[3] = src->a * gc->oneOverAlphaVertexScale;
}

/*
** Reverse the scaling back to the users original
*/
void FASTCALL __glUnScaleColori(__GLcontext *gc, GLint dst[4], const __GLcolor* src)
{
    dst[0] = __GL_FLOAT_TO_I(src->r * gc->oneOverRedVertexScale);
    dst[1] = __GL_FLOAT_TO_I(src->g * gc->oneOverGreenVertexScale);
    dst[2] = __GL_FLOAT_TO_I(src->b * gc->oneOverBlueVertexScale);
    dst[3] = __GL_FLOAT_TO_I(src->a * gc->oneOverAlphaVertexScale);
}

/*
** Clamp an already scaled RGB color.
*/
void FASTCALL __glClampRGBColor(__GLcontext *gc, __GLcolor *dst, const __GLcolor *src)
{
    __GLfloat zero = __glZero;
    __GLfloat r, g, b, a;
    __GLfloat rl, gl, bl, al;

    r = src->r; rl = gc->redVertexScale;
    if (r <= zero) {
	dst->r = zero;
    } else {
	if (r >= rl) {
	    dst->r = rl;
	} else {
	    dst->r = r;
	}
    }
    g = src->g; gl = gc->greenVertexScale;
    if (g <= zero) {
	dst->g = zero;
    } else {
	if (g >= gl) {
	    dst->g = gl;
	} else {
	    dst->g = g;
	}
    }
    b = src->b; bl = gc->blueVertexScale;
    if (b <= zero) {
	dst->b = zero;
    } else {
	if (b >= bl) {
	    dst->b = bl;
	} else {
	    dst->b = b;
	}
    }
    a = src->a; al = gc->alphaVertexScale;
    if (a <= zero) {
	dst->a = zero;
    } else {
	if (a >= al) {
	    dst->a = al;
	} else {
	    dst->a = a;
	}
    }
}

/************************************************************************/

/*
** gc->procs.applyColor procs.  These are used to apply the current color
** change to either a material color, or to current.color (when not
** lighting), preparing the color for copying into the vertex.
*/

void FASTCALL ChangeMaterialEmission(__GLcontext *gc, __GLmaterialState *ms,
				   __GLmaterialMachine *msm)
{
    __GLfloat r, g, b;

    r = gc->state.current.userColor.r * gc->redVertexScale;
    g = gc->state.current.userColor.g * gc->greenVertexScale;
    b = gc->state.current.userColor.b * gc->blueVertexScale;

    ms->emissive.r = r;
    ms->emissive.g = g;
    ms->emissive.b = b;
    ms->emissive.a = gc->state.current.userColor.a * gc->alphaVertexScale;

#ifdef NT
    // compute the invariant scene color
    msm->paSceneColor.r = ms->ambient.r * gc->state.light.model.ambient.r;
    msm->paSceneColor.g = ms->ambient.g * gc->state.light.model.ambient.g;
    msm->paSceneColor.b = ms->ambient.b * gc->state.light.model.ambient.b;
#else
    msm->sceneColor.r = r + ms->ambient.r * gc->state.light.model.ambient.r;
    msm->sceneColor.g = g + ms->ambient.g * gc->state.light.model.ambient.g;
    msm->sceneColor.b = b + ms->ambient.b * gc->state.light.model.ambient.b;
#endif
}

void FASTCALL ChangeMaterialSpecular(__GLcontext *gc, __GLmaterialState *ms,
				   __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;

    ms->specular.r = r;
    ms->specular.g = g;
    ms->specular.b = b;
    ms->specular.a = gc->state.current.userColor.a;

    /*
    ** Update per-light-source state that depends on material specular
    ** state
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached specular */
	lspmm->specular.r = r * lss->specular.r;
	lspmm->specular.g = g * lss->specular.g;
	lspmm->specular.b = b * lss->specular.b;
    }
}

void FASTCALL ChangeMaterialAmbient(__GLcontext *gc, __GLmaterialState *ms,
				  __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;

    ms->ambient.r = r;
    ms->ambient.g = g;
    ms->ambient.b = b;
    ms->ambient.a = gc->state.current.userColor.a;

#ifdef NT
    // compute the invariant scene color
    msm->paSceneColor.r = ms->emissive.r;
    msm->paSceneColor.g = ms->emissive.g;
    msm->paSceneColor.b = ms->emissive.b;
#else
    msm->sceneColor.r = ms->emissive.r + r * gc->state.light.model.ambient.r;
    msm->sceneColor.g = ms->emissive.g + g * gc->state.light.model.ambient.g;
    msm->sceneColor.b = ms->emissive.b + b * gc->state.light.model.ambient.b;
#endif

    /*
    ** Update per-light-source state that depends on material ambient
    ** state.
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached ambient */
	lspmm->ambient.r = r * lss->ambient.r;
	lspmm->ambient.g = g * lss->ambient.g;
	lspmm->ambient.b = b * lss->ambient.b;
    }
}

void FASTCALL ChangeMaterialDiffuse(__GLcontext *gc, __GLmaterialState *ms,
				  __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b, a;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;
    a = gc->state.current.userColor.a;

    ms->diffuse.r = r;
    ms->diffuse.g = g;
    ms->diffuse.b = b;
    ms->diffuse.a = a;

    if (a < __glZero) {
	a = __glZero;
    } else if (a > __glOne) {
	a = __glOne;
    }
    msm->alpha = a * gc->alphaVertexScale;

    /*
    ** Update per-light-source state that depends on material diffuse
    ** state.
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached diffuse */
	lspmm->diffuse.r = r * lss->diffuse.r;
	lspmm->diffuse.g = g * lss->diffuse.g;
	lspmm->diffuse.b = b * lss->diffuse.b;
    }
}

void FASTCALL ChangeMaterialAmbientAndDiffuse(__GLcontext *gc,
					    __GLmaterialState *ms,
					    __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b, a;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;
    a = gc->state.current.userColor.a;

    ms->ambient.r = r;
    ms->ambient.g = g;
    ms->ambient.b = b;
    ms->ambient.a = a;

    ms->diffuse.r = r;
    ms->diffuse.g = g;
    ms->diffuse.b = b;
    ms->diffuse.a = a;

#ifdef NT
    // compute the invariant scene color
    msm->paSceneColor.r = ms->emissive.r;
    msm->paSceneColor.g = ms->emissive.g;
    msm->paSceneColor.b = ms->emissive.b;
#else
    msm->sceneColor.r = ms->emissive.r + r * gc->state.light.model.ambient.r;
    msm->sceneColor.g = ms->emissive.g + g * gc->state.light.model.ambient.g;
    msm->sceneColor.b = ms->emissive.b + b * gc->state.light.model.ambient.b;
#endif

    if (a < __glZero) {
	a = __glZero;
    } else if (a > __glOne) {
	a = __glOne;
    }
    msm->alpha = a * gc->alphaVertexScale;

    /*
    ** Update per-light-source state that depends on per-material state.
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached ambient */
	lspmm->ambient.r = r * lss->ambient.r;
	lspmm->ambient.g = g * lss->ambient.g;
	lspmm->ambient.b = b * lss->ambient.b;

	/* Recompute per-light per-material cached diffuse */
	lspmm->diffuse.r = r * lss->diffuse.r;
	lspmm->diffuse.g = g * lss->diffuse.g;
	lspmm->diffuse.b = b * lss->diffuse.b;
    }
}

void FASTCALL __glChangeOneMaterialColor(__GLcontext *gc)
{
    (*gc->procs.changeMaterial)(gc, gc->light.cm, gc->light.cmm);
}

void FASTCALL __glChangeBothMaterialColors(__GLcontext *gc)
{
    (*gc->procs.changeMaterial)(gc, &gc->state.light.front, &gc->light.front);
    (*gc->procs.changeMaterial)(gc, &gc->state.light.back, &gc->light.back);
}

/************************************************************************/

/*
** DEPENDENCIES:
**
** Material 	EMISSIVE, AMBIENT, DIFFUSE, SHININESS
** Light Model 	AMBIENT
*/

/*
** Compute derived state for a material
*/
void ComputeMaterialState(__GLcontext *gc, __GLmaterialState *ms,
				 __GLmaterialMachine *msm, GLint changeBits)
{
    GLdouble  exponent;
    __GLspecLUTEntry *lut;

    if ((changeBits & (__GL_MATERIAL_EMISSIVE | __GL_MATERIAL_AMBIENT | 
	    __GL_MATERIAL_DIFFUSE | __GL_MATERIAL_SHININESS)) == 0) {
	return;
    }
    /* Only compute specular lookup table when it changes */
    if (!msm->cache || (ms->specularExponent != msm->specularExponent)) {
	/*
	** Specular lookup table generation.  Instead of performing a
	** "pow" computation each time a vertex is lit, we generate a
	** lookup table which approximates the pow function:
	**
	** 	n2 = n circle-dot hHat[i]
	** 	if (n2 >= threshold) {
	** 		n2spec = specTable[n2 * scale];
	** 		...
	** 	}
	**
	** Remember that n2 is a value constrained to be between 0.0 and
	** 1.0, inclusive (n is the normalized normal; hHat[i] is the
	** unit h vector).  "threshold" is the threshold where incoming
	** n2 values become meaningful for a given exponent.  The larger
	** the specular exponent, the closer "threshold" will approach
	** 1.0.
	**
	** A simple linear mapping of the n2 value to a table index will
	** not suffice because in most cases the majority of the table
	** entries would be zero, while the useful non-zero values would
	** be compressed into a few table entries.  By setting up a
	** threshold, we can use the entire table to represent the useful
	** values beyond the threshold.  "scale" is computed based on
	** this threshold.
	*/
	exponent = msm->specularExponent = ms->specularExponent;

	__glFreeSpecLUT(gc, msm->cache);
	lut = msm->cache = __glCreateSpecLUT(gc, exponent);
#ifdef NT
        if (lut)
        {
            msm->threshold = lut->threshold;
            msm->scale = lut->scale;
            msm->specTable = lut->table;
        }
        else
        {
            msm->threshold = (GLfloat) 0.0;
            msm->scale = (GLfloat) __GL_SPEC_LOOKUP_TABLE_SIZE;
            msm->specTable = NULL;
        }
#else
	msm->threshold = lut->threshold;
	msm->scale = lut->scale;
	msm->specTable = lut->table;
#endif // NT
    }

#ifdef NT
    /* Compute invariant scene color */
    if (changeBits & (__GL_MATERIAL_EMISSIVE | __GL_MATERIAL_AMBIENT))
    {
	if (msm->colorMaterialChange & __GL_MATERIAL_EMISSIVE)
	{
	    msm->paSceneColor.r = ms->ambient.r * gc->state.light.model.ambient.r;
	    msm->paSceneColor.g = ms->ambient.g * gc->state.light.model.ambient.g;
	    msm->paSceneColor.b = ms->ambient.b * gc->state.light.model.ambient.b;
	}
	else if (msm->colorMaterialChange & __GL_MATERIAL_AMBIENT)
	{
	    msm->paSceneColor.r = ms->emissive.r;
	    msm->paSceneColor.g = ms->emissive.g;
	    msm->paSceneColor.b = ms->emissive.b;
	}
	else
	{
	    // there is no color material but need to compute this anyway!
	    msm->paSceneColor.r = ms->emissive.r 
		+ ms->ambient.r * gc->state.light.model.ambient.r;
	    msm->paSceneColor.g = ms->emissive.g 
		+ ms->ambient.g * gc->state.light.model.ambient.g;
	    msm->paSceneColor.b = ms->emissive.b 
		+ ms->ambient.b * gc->state.light.model.ambient.b;
	}
    }
#else
    /* Compute scene color */
    if (changeBits & (__GL_MATERIAL_EMISSIVE | __GL_MATERIAL_AMBIENT)) {
	msm->sceneColor.r = ms->emissive.r
	    + ms->ambient.r * gc->state.light.model.ambient.r;
	msm->sceneColor.g = ms->emissive.g
	    + ms->ambient.g * gc->state.light.model.ambient.g;
	msm->sceneColor.b = ms->emissive.b
	    + ms->ambient.b * gc->state.light.model.ambient.b;
    }
#endif

    /* Clamp material alpha */
    if (changeBits & __GL_MATERIAL_DIFFUSE) {
	msm->alpha = ms->diffuse.a * gc->alphaVertexScale;
	if (msm->alpha < __glZero) {
	    msm->alpha = __glZero;
	} else if (msm->alpha > gc->alphaVertexScale) {
	    msm->alpha = gc->alphaVertexScale;
	}
    }
}

/*
** DEPENDENCIES:
**
** Derived state:
**
** Enables	LIGHTx
** Lightx	DIFFUSE, AMBIENT, SPECULAR, POSITION, SPOT_EXPONENT, 
**		SPOT_CUTOFF, CONSTANT_ATTENUATION, LINEAR_ATTENUATION,
**		QUADRATIC_ATTENUATION
** Light Model  LOCAL_VIEWER
*/

/*
** Compute any derived state for the enabled lights.
*/
void FASTCALL ComputeLightState(__GLcontext *gc)
{
    __GLlightSourceState *lss;
    __GLlightSourceMachine *lsm, **lsmp;
    __GLfloat zero;
    GLuint enables;
    GLint i;
    __GLspecLUTEntry *lut;

    zero = __glZero;

    lss = &gc->state.light.source[0];
    lsm = &gc->light.source[0];
    lsmp = &gc->light.sources;
    enables = gc->state.enables.lights;
    for (i = 0; i < gc->constants.numberOfLights;
	    i++, lss++, lsm++, enables >>= 1) {
	if (!(enables & 1)) continue;

	/* Link this enabled light on to the list */
	*lsmp = lsm;
	lsm->state = lss;	/* Could be done once, elsewhere... */
	lsmp = &lsm->next;

	/*
	** Compute per-light derived state that wasn't already done
	** in the api handlers.
	*/
	lsm->position = lss->positionEye;
	lsm->isSpot = lss->spotLightCutOffAngle != 180;
	if (lsm->isSpot) {
	    lsm->cosCutOffAngle =
		__GL_COSF(lss->spotLightCutOffAngle * __glDegreesToRadians);
	}

	if (lsm->isSpot && (!lsm->cache ||
	        (lsm->spotLightExponent != lss->spotLightExponent))) {
	    GLdouble exponent;

	    /*
	    ** Compute spot light exponent lookup table, but only when
	    ** the exponent changes value and the light is a spot light.
	    */
	    exponent = lsm->spotLightExponent = lss->spotLightExponent;

	    if (lsm->cache) {
		__glFreeSpecLUT(gc, lsm->cache);
	    }
	    lut = lsm->cache = __glCreateSpecLUT(gc, exponent);
#ifdef NT
            if (lut)
            {
                lsm->threshold = lut->threshold;
                lsm->scale = lut->scale;
                lsm->spotTable = lut->table;
            }
            else
            {
                lsm->threshold = (GLfloat) 0.0;
                lsm->scale = (GLfloat) __GL_SPEC_LOOKUP_TABLE_SIZE;
                lsm->spotTable = NULL;
            }
#else
	    lsm->threshold = lut->threshold;
	    lsm->scale = lut->scale;
	    lsm->spotTable = lut->table;
#endif // NT
	}

	lsm->constantAttenuation = lss->constantAttenuation;
    if (__GL_FLOAT_NEZ(lsm->constantAttenuation))
	    lsm->attenuation = __glOne / lss->constantAttenuation;
    else
        lsm->attenuation = __glOne;
	lsm->linearAttenuation = lss->linearAttenuation;
	lsm->quadraticAttenuation = lss->quadraticAttenuation;

	/*
	** Pick per-light calculation proc based on the state
	** of the light source
	*/
	if (gc->modes.colorIndexMode) {
	    lsm->sli = ((__GLfloat) 0.30) * lss->specular.r
		+ ((__GLfloat) 0.59) * lss->specular.g
		+ ((__GLfloat) 0.11) * lss->specular.b;
	    lsm->dli = ((__GLfloat) 0.30) * lss->diffuse.r
		+ ((__GLfloat) 0.59) * lss->diffuse.g
		+ ((__GLfloat) 0.11) * lss->diffuse.b;
	}
	if (!gc->state.light.model.localViewer && !lsm->isSpot
		&& (lsm->position.w == zero)) {
	    __GLfloat hv[3];

	    /* Compute unit h[i] (normalized) */
	    __glNormalize(hv, &lsm->position.x);
	    lsm->unitVPpli.x = hv[0];
	    lsm->unitVPpli.y = hv[1];
	    lsm->unitVPpli.z = hv[2];
	    hv[2] += __glOne;
	    __glNormalize(&lsm->hHat.x, hv);
	    lsm->slowPath = GL_FALSE;
	} else {
	    lsm->slowPath = GL_TRUE;
	}
    }
    *lsmp = 0;
}

/*
** DEPENDENCIES:
**
** Procs:
**
** Light Model	LOCAL_VIEWER
** Lightx	SPOT_CUTOFF, POSITION
** Enables	LIGHTING
** modeFlags	CHEAP_FOG
*/
void FASTCALL ComputeLightProcs(__GLcontext *gc)
{
    GLboolean anySlow = GL_FALSE;
    __GLlightSourceMachine *lsm;

    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	if (lsm->slowPath) {
	    anySlow = GL_TRUE;
	    break;
	}
    }

#ifdef NT
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
	    (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT) &&
	    gc->renderMode == GL_RENDER)
    {
	if (gc->modes.colorIndexMode)
	    gc->procs.paApplyCheapFog = PolyArrayCheapFogCIColor;
	else
	    gc->procs.paApplyCheapFog = PolyArrayCheapFogRGBColor;
    }
    else
	gc->procs.paApplyCheapFog = 0;	// for debugging

    if (gc->state.enables.general & __GL_LIGHTING_ENABLE)
    {
#ifdef GL_WIN_phong_shading
        if (gc->state.light.shadingModel == GL_PHONG_WIN)
        {
            __glGenericPickPhongProcs (gc);
        }
        //else
#endif //GL_WIN_phong_shading
	if (gc->modes.colorIndexMode)
	{
	    if (!anySlow)
		gc->procs.paCalcColor = PolyArrayFastCalcCIColor;
	    else
		gc->procs.paCalcColor = PolyArrayCalcCIColor;
	}
	else
	{
	    if (!anySlow)
	    {
		// If there are no color material changes in front and back
		// faces, use the zippy function!
		if (!gc->light.front.colorMaterialChange
		 && !gc->light.back.colorMaterialChange)
		    gc->procs.paCalcColor = PolyArrayZippyCalcRGBColor;
		else
		    gc->procs.paCalcColor = PolyArrayFastCalcRGBColor;
	    }
	    else
	    {
		gc->procs.paCalcColor = PolyArrayCalcRGBColor;
	    }
	}
    }
    else
    {
	// set it to NULL for debugging
	gc->procs.paCalcColor = (PFN_POLYARRAYCALCCOLOR) NULL;
    }

    if (gc->modes.colorIndexMode)
	gc->procs.paCalcColorSkip = PolyArrayFillIndex0;
    else
	gc->procs.paCalcColorSkip = PolyArrayFillColor0;
#else
    if (gc->state.enables.general & __GL_LIGHTING_ENABLE) {
	if (gc->modes.colorIndexMode) {
	    if (!anySlow) {
		gc->procs.calcColor = __glFastCalcCIColor;
	    } else {
		gc->procs.calcColor = __glCalcCIColor;
	    }
	} else {
	    if (!anySlow) {
		gc->procs.calcColor = __glFastCalcRGBColor;
	    } else {
		gc->procs.calcColor = __glCalcRGBColor;
	    }
	}
	gc->procs.calcRasterColor = gc->procs.calcColor;
	if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
		(gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT) &&
		gc->renderMode == GL_RENDER) {
	    gc->procs.calcColor2 = gc->procs.calcColor;
	    if (gc->modes.colorIndexMode) {
		gc->procs.calcColor = __glFogLitCIColor;
	    } else {
		gc->procs.calcColor = __glFogLitRGBColor;
	    }
	}
    } else {
	gc->procs.calcRasterColor = __glNopLight;
	if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
		(gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT) &&
		gc->renderMode == GL_RENDER) {
	    if (gc->modes.colorIndexMode) {
		gc->procs.calcColor = __glFogCIColor;
	    } else {
		gc->procs.calcColor = __glFogRGBColor;
	    }
	} else {
	    gc->procs.calcColor = __glNopLight;
	}
    }
#endif
}

/*
** DEPENDENCIES:
**
** Material	AMBIENT, DIFFUSE, SPECULAR
** Lightx	AMBIENT, DIFFUSE, SPECULAR
*/
void FASTCALL ComputeLightMaterialState(__GLcontext *gc, GLint frontChange,
				      GLint backChange)
{
    __GLmaterialState *front, *back;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat r, g, b;
    GLint allChange;

    allChange = frontChange | backChange;
    if ((allChange & (__GL_MATERIAL_AMBIENT | __GL_MATERIAL_DIFFUSE | 
	    __GL_MATERIAL_SPECULAR)) == 0) {
	return;
    }

    front = &gc->state.light.front;
    back = &gc->state.light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lss = lsm->state;
	/*
	** Pre-multiply and the front & back ambient, diffuse and
	** specular colors
	*/
	if (allChange & __GL_MATERIAL_AMBIENT) {
	    r = lss->ambient.r;
	    g = lss->ambient.g;
	    b = lss->ambient.b;
	    if (frontChange & __GL_MATERIAL_AMBIENT) {
		lsm->front.ambient.r = front->ambient.r * r;
		lsm->front.ambient.g = front->ambient.g * g;
		lsm->front.ambient.b = front->ambient.b * b;
	    }
	    if (backChange & __GL_MATERIAL_AMBIENT) {
		lsm->back.ambient.r = back->ambient.r * r;
		lsm->back.ambient.g = back->ambient.g * g;
		lsm->back.ambient.b = back->ambient.b * b;
	    }
	}

	if (allChange & __GL_MATERIAL_DIFFUSE) {
	    r = lss->diffuse.r;
	    g = lss->diffuse.g;
	    b = lss->diffuse.b;
	    if (frontChange & __GL_MATERIAL_DIFFUSE) {
		lsm->front.diffuse.r = front->diffuse.r * r;
		lsm->front.diffuse.g = front->diffuse.g * g;
		lsm->front.diffuse.b = front->diffuse.b * b;
	    }
	    if (backChange & __GL_MATERIAL_DIFFUSE) {
		lsm->back.diffuse.r = back->diffuse.r * r;
		lsm->back.diffuse.g = back->diffuse.g * g;
		lsm->back.diffuse.b = back->diffuse.b * b;
	    }
	}

	if (allChange & __GL_MATERIAL_SPECULAR) {
	    r = lss->specular.r;
	    g = lss->specular.g;
	    b = lss->specular.b;
	    if (frontChange & __GL_MATERIAL_SPECULAR) {
		lsm->front.specular.r = front->specular.r * r;
		lsm->front.specular.g = front->specular.g * g;
		lsm->front.specular.b = front->specular.b * b;
	    }
	    if (backChange & __GL_MATERIAL_SPECULAR) {
		lsm->back.specular.r = back->specular.r * r;
		lsm->back.specular.g = back->specular.g * g;
		lsm->back.specular.b = back->specular.b * b;
	    }
	}
    }
}

/*
** DEPENDENCIES:
**
** Material 	EMISSIVE, AMBIENT, DIFFUSE, SHININESS, SPECULAR
** Light Model 	AMBIENT
** Lightx	AMBIENT, DIFFUSE, SPECULAR
*/

/*
** Recompute light state based upon the material change indicated by 
** frontChange and backChange.
*/
void FASTCALL __glValidateMaterial(__GLcontext *gc, GLint frontChange, GLint backChange)
{
    ComputeMaterialState(gc, &gc->state.light.front, &gc->light.front, 
	    frontChange);
    ComputeMaterialState(gc, &gc->state.light.back, &gc->light.back, 
	    backChange);
    ComputeLightMaterialState(gc, frontChange, backChange);
}

/*
** DEPENDENCIES:
**
** Enables	LIGHTx, LIGHTING
** ( Material 	EMISSIVE, AMBIENT, DIFFUSE, SHININESS, SPECULAR )
** Light Model 	AMBIENT, LOCAL_VIEWER
** Lightx	DIFFUSE, AMBIENT, SPECULAR, POSITION, SPOT_EXPONENT, 
**		SPOT_CUTOFF, CONSTANT_ATTENUATION, LINEAR_ATTENUATION,
**		QUADRATIC_ATTENUATION
** modeFlags	CHEAP_FOG
*/

/*
** Pre-compute lighting state.
*/
void FASTCALL __glValidateLighting(__GLcontext *gc)
{
    if (gc->dirtyMask & __GL_DIRTY_LIGHTING) {
	ComputeLightState(gc);
	ComputeLightProcs(gc);
	__glValidateMaterial(gc, __GL_MATERIAL_ALL, __GL_MATERIAL_ALL);
    } else {
	ComputeLightProcs(gc);
    }
}

void FASTCALL __glGenericPickColorMaterialProcs(__GLcontext *gc)
{
    if (gc->modes.rgbMode) {
	if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) {
	    switch (gc->state.light.colorMaterialFace) {
	      case GL_FRONT_AND_BACK:
		gc->procs.applyColor = __glChangeBothMaterialColors;
		gc->light.cm = 0;
		gc->light.cmm = 0;
		break;
	      case GL_FRONT:
		gc->procs.applyColor = __glChangeOneMaterialColor;
		gc->light.cm = &gc->state.light.front;
		gc->light.cmm = &gc->light.front;
		break;
	      case GL_BACK:
		gc->procs.applyColor = __glChangeOneMaterialColor;
		gc->light.cm = &gc->state.light.back;
		gc->light.cmm = &gc->light.back;
		break;
	    }
	    switch (gc->state.light.colorMaterialParam) {
	      case GL_EMISSION:
		gc->procs.changeMaterial = ChangeMaterialEmission;
		break;
	      case GL_SPECULAR:
		gc->procs.changeMaterial = ChangeMaterialSpecular;
		break;
	      case GL_AMBIENT:
		gc->procs.changeMaterial = ChangeMaterialAmbient;
		break;
	      case GL_DIFFUSE:
		gc->procs.changeMaterial = ChangeMaterialDiffuse;
		break;
	      case GL_AMBIENT_AND_DIFFUSE:
		gc->procs.changeMaterial = ChangeMaterialAmbientAndDiffuse;
		break;
	    }
	} else {
	    gc->procs.applyColor = __glNopGC;
	}
    } else {
	/*
	** When in color index mode the value is copied from the
	** current.userColorIndex into the vertex
	*/
	gc->procs.applyColor = __glNopGC;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_image.c ===
/*
** Copyright 1991,1992 Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.7 $
** $Date: 1993/06/18 00:29:39 $
*/
#include "precomp.h"
#pragma hdrstop

GLubyte __glMsbToLsbTable[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

static GLubyte LowBitsMask[9] = {
    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff,
};

static GLubyte HighBitsMask[9] = {
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff,
};

/************************************************************************/

void FASTCALL __glConvertStipple(__GLcontext *gc)
{
    GLubyte b0, b1, b2, b3, *stipple;
    GLuint *dst;
    GLint i;

    stipple = &gc->state.polygonStipple.stipple[0];
    dst = &gc->polygon.stipple[0];
#ifdef __GL_STIPPLE_MSB
    /*
    ** Convert input stipple bytes which are in little endian MSB format
    ** into a single long word, whose high bit represents the left most
    ** X coordinate of a 32 bit span.
    */
    for (i = 0; i < 32; i++) {
	b0 = *stipple++;
	b1 = *stipple++;
	b2 = *stipple++;
	b3 = *stipple++;
	*dst++ = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
    }
#else
    /*
    ** Make 32bit form of the stipple for easier rendering.
    */
    for (i = 0; i < 32; i++) {
	b0 = __glMsbToLsbTable[*stipple++];
	b1 = __glMsbToLsbTable[*stipple++];
	b2 = __glMsbToLsbTable[*stipple++];
	b3 = __glMsbToLsbTable[*stipple++];
	*dst++ = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
    }
#endif
}

/************************************************************************/

/*
** Compute memory required for internal packed array of data of given type
** and format.
*/
GLint APIPRIVATE __glImageSize(GLsizei width, GLsizei height, GLenum format, GLenum type) 
{
    GLint bytes_per_row;
    GLint components;

    components = __glElementsPerGroup(format);
    if (type == GL_BITMAP) {
	bytes_per_row = (width + 7) >> 3;
    } else {
	bytes_per_row =(GLint)__glBytesPerElement(type) * width;
    }
    return bytes_per_row * height * components;
}

/*
** Extract array from user's data applying all pixel store modes.
** The internal packed array format used has LSB_FIRST = FALSE and 
** ALIGNMENT = 1.
*/
void APIPRIVATE __glFillImage(__GLcontext *gc, GLsizei width, GLsizei height,
		   GLenum format, GLenum type,
		   const GLvoid *userdata, GLubyte *newimage)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint line_length = gc->state.pixel.unpackModes.lineLength;
    GLint alignment = gc->state.pixel.unpackModes.alignment;
    GLint skip_pixels = gc->state.pixel.unpackModes.skipPixels;
    GLint skip_lines = gc->state.pixel.unpackModes.skipLines;
    GLint groups_per_line;
    GLint group_size;
    GLint lsb_first = gc->state.pixel.unpackModes.lsbFirst;
    GLint swap_bytes = gc->state.pixel.unpackModes.swapEndian;
    GLint elements_per_line;
    const GLubyte *start;
    const GLubyte *iter;
    GLubyte *iter2;
    GLint i, j, k;

    components = __glElementsPerGroup(format);
    if (line_length > 0) {
	groups_per_line = line_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint elements_left;
	GLint bit_offset;
	GLint current_byte;
	GLint next_byte;
	GLint high_bit_mask;
	GLint low_bit_mask;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((const GLubyte*) userdata) + skip_lines * rowsize + 
		(skip_pixels * components / 8);
	bit_offset = (skip_pixels * components) % 8;
	high_bit_mask = LowBitsMask[8-bit_offset];
	low_bit_mask = HighBitsMask[bit_offset];
	elements_per_line = width * components;
	iter2 = newimage;
	for (i = 0; i < height; i++) {
	    elements_left = elements_per_line;
	    iter = start;
	    while (elements_left) {
		/* First retrieve low bits from current byte */
		if (lsb_first) {
		    current_byte = __glMsbToLsbTable[iter[0]];
		} else {
		    current_byte = iter[0];
		}
		if (bit_offset) {
		    /* Need to read next byte to finish current byte */
		    if (elements_left > (8 - bit_offset)) {
			if (lsb_first) {
			    next_byte = __glMsbToLsbTable[iter[1]];
			} else {
			    next_byte = iter[1];
			}
			current_byte = 
			    ((current_byte & high_bit_mask) << bit_offset) |
			    ((next_byte & low_bit_mask) >> (8 - bit_offset));
		    } else {
			current_byte = 
			    ((current_byte & high_bit_mask) << bit_offset);
		    }
		} 
		if (elements_left >= 8) {
		    *iter2 = (GLubyte) current_byte;
		    elements_left -= 8;
		} else {
		    *iter2 = (GLubyte)
			(current_byte & HighBitsMask[elements_left]);
		    elements_left = 0;
		}
		iter2++;
		iter++;
	    }
	    start += rowsize;
	}
    } else {
	element_size = (GLint)__glBytesPerElement(type);
	group_size = element_size * components;
	if (element_size == 1) swap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((const GLubyte*) userdata) + skip_lines * rowsize
	    + skip_pixels * group_size;
	iter2 = newimage;
	elements_per_line = width * components;

	if (swap_bytes) {
	    for (i = 0; i < height; i++) {
		iter = start;
		for (j = 0; j < elements_per_line; j++) {
		    for (k = 1; k <= element_size; k++) {
			iter2[k-1] = iter[element_size - k];
		    }
		    iter2 += element_size;
		    iter += element_size;
		}
		start += rowsize;
	    }
	} else {
	    if (rowsize == elements_per_line * element_size) {
		/* Ha!  This is mondo easy! */
		__GL_MEMCOPY(iter2, start,
			     elements_per_line * element_size * height);
	    } else {
		iter = start;
		for (i = 0; i < height; i++) {
		    __GL_MEMCOPY(iter2, iter, elements_per_line * element_size);
		    iter2 += elements_per_line * element_size;
		    iter += rowsize;
		}
	    }
	}
    }
}

/*
** Insert array into user's data applying all pixel store modes.
** The internal packed array format used has LSB_FIRST = FALSE and 
** ALIGNMENT = 1.  __glEmptyImage() because it is the opposite of 
** __glFillImage().
*/
void __glEmptyImage(__GLcontext *gc, GLsizei width, GLsizei height,
		    GLenum format, GLenum type,
		    const GLubyte *oldimage, GLvoid *userdata)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint line_length = gc->state.pixel.packModes.lineLength;
    GLint alignment = gc->state.pixel.packModes.alignment;
    GLint skip_pixels = gc->state.pixel.packModes.skipPixels;
    GLint skip_lines = gc->state.pixel.packModes.skipLines;
    GLint groups_per_line;
    GLint group_size;
    GLint lsb_first = gc->state.pixel.packModes.lsbFirst;
    GLint swap_bytes = gc->state.pixel.packModes.swapEndian;
    GLint elements_per_line;
    GLubyte *start;
    GLubyte *iter;
    const GLubyte *iter2;
    GLint i, j, k;

    components = __glElementsPerGroup(format);
    if (line_length > 0) {
	groups_per_line = line_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint elements_left;
	GLint bit_offset;
	GLint current_byte;
	GLint high_bit_mask;
	GLint low_bit_mask;
	GLint write_mask;
	GLubyte write_byte;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((GLubyte*) userdata) + skip_lines * rowsize + 
		(skip_pixels * components / 8);
	bit_offset = (skip_pixels * components) % 8;
	high_bit_mask = LowBitsMask[8-bit_offset];
	low_bit_mask = HighBitsMask[bit_offset];
	elements_per_line = width * components;
	iter2 = oldimage;
	for (i = 0; i < height; i++) {
	    elements_left = elements_per_line;
	    iter = start;
	    write_mask = high_bit_mask;
	    write_byte = 0;
	    while (elements_left) {
		/* Set up write_mask (to write to current byte) */
		if (elements_left + bit_offset < 8) {
		    /* Need to trim write_mask */
		    write_mask &= HighBitsMask[bit_offset+elements_left];
		}

		if (lsb_first) {
		    current_byte = __glMsbToLsbTable[iter[0]];
		} else {
		    current_byte = iter[0];
		}

		if (bit_offset) {
		    write_byte |= (GLubyte) (iter2[0] >> bit_offset);
		    current_byte = (current_byte & ~write_mask) | 
			    (write_byte & write_mask);
		    write_byte = (GLubyte) (iter2[0] << (8 - bit_offset));
		} else {
		    current_byte = (current_byte & ~write_mask) |
			    (iter2[0] & write_mask);
		}

		if (lsb_first) {
		    iter[0] = __glMsbToLsbTable[current_byte];
		} else {
		    iter[0] = (GLubyte) current_byte;
		}

		if (elements_left >= 8) {
		    elements_left -= 8;
		} else {
		    elements_left = 0;
		}
		iter2++;
		iter++;
		write_mask = 0xff;
	    }
	    if (write_byte) {
		/* Some data left over that still needs writing */
		write_mask &= low_bit_mask;
		if (lsb_first) {
		    current_byte = __glMsbToLsbTable[iter[0]];
		} else {
		    current_byte = iter[0];
		}

		current_byte = (current_byte & ~write_mask) |
			(write_byte & write_mask);
		
		if (lsb_first) {
		    iter[0] = __glMsbToLsbTable[current_byte];
		} else {
		    iter[0] = (GLubyte) current_byte;
		}
	    }
	    start += rowsize;
	}
    } else {
	element_size = (GLint)__glBytesPerElement(type);
	group_size = element_size * components;
	if (element_size == 1) swap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((GLubyte*) userdata) + skip_lines * rowsize
	    + skip_pixels * group_size;
	iter2 = oldimage;
	elements_per_line = width * components;

	if (swap_bytes) {
	    for (i = 0; i < height; i++) {
		iter = start;
		for (j = 0; j < elements_per_line; j++) {
		    for (k = 1; k <= element_size; k++) {
			iter[k-1] = iter2[element_size - k];
		    }
		    iter2 += element_size;
		    iter += element_size;
		}
		start += rowsize;
	    }
	} else {
	    if (rowsize == elements_per_line * element_size) {
		/* Ha!  This is mondo easy! */
		__GL_MEMCOPY(start, iter2,
			     elements_per_line * element_size * height);
	    } else {
		iter = start;
		for (i = 0; i < height; i++) {
		    __GL_MEMCOPY(iter, iter2, elements_per_line * element_size);
		    iter2 += elements_per_line * element_size;
		    iter += rowsize;
		}
	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_globa.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#ifdef NT
// Disable long to float conversion warning.
#pragma warning (disable:4244)
#endif // NT

__GLcoord __gl_frustumClipPlanes[6] = {
    {  1.0,  0.0,  0.0,  1.0 },		/* left */
    { -1.0,  0.0,  0.0,  1.0 },		/* right */
    {  0.0,  1.0,  0.0,  1.0 },		/* bottom */
    {  0.0, -1.0,  0.0,  1.0 },		/* top */
    {  0.0,  0.0,  1.0,  1.0 },		/* zNear */
    {  0.0,  0.0, -1.0,  1.0 },		/* zFar */
};

GLbyte __glDitherTable[16] = {
    0, 8, 2, 10,
    12, 4, 14, 6,
    3, 11, 1, 9,
    15, 7, 13, 5,
};

// Clip coordinate offsets for frustum clipping
GLuint __glFrustumOffsets[6] =
{
    FIELD_OFFSET(__GLvertex, clip.x),
    FIELD_OFFSET(__GLvertex, clip.x),
    FIELD_OFFSET(__GLvertex, clip.y),
    FIELD_OFFSET(__GLvertex, clip.y),
    FIELD_OFFSET(__GLvertex, clip.z),
    FIELD_OFFSET(__GLvertex, clip.z)
};

#ifdef NT
#if defined(_X86_) || defined(_ALPHA_) || defined(_MIPS_) || defined(_PPC_)

const double __glDoubleTwo            = ((double) 2.0);
const double __glDoubleMinusTwo       = ((double) -2.0);

// On Alpha, register f31 is always read as zero.
#ifndef _ALPHA_
const __GLfloat __glZero              = ((__GLfloat) 0.0);
#endif

const __GLfloat __glOne               = ((__GLfloat) 1.0);
const __GLfloat __glMinusOne          = ((__GLfloat) -1.0);
const __GLfloat __glHalf              = ((__GLfloat) 0.5);
const __GLfloat __glDegreesToRadians  = ((__GLfloat) 3.14159265358979323846 /
                                         (__GLfloat) 180.0);
const __GLfloat __glPi                = ((__GLfloat) 3.14159265358979323846);
const __GLfloat __glSqrt2             = ((__GLfloat) 1.41421356237309504880);
const __GLfloat __glE                 = ((__GLfloat) 2.7182818284590452354);
const __GLfloat __glVal128            = ((__GLfloat) 128.0);
const __GLfloat __glVal255            = ((__GLfloat) 255.0);
const __GLfloat __glOneOver255        = ((__GLfloat) (1.0 / 255.0));
const __GLfloat __glVal256            = ((__GLfloat) 256.0);
const __GLfloat __glOneOver512        = ((__GLfloat) (1.0 / 512.0));
const __GLfloat __glVal768            = ((__GLfloat) 768.0);
const __GLfloat __glVal65535          = ((__GLfloat) 65535.0);
const __GLfloat __glVal65536          = ((__GLfloat) 65536.0);
const __GLfloat __glTexSubDiv         = ((__GLfloat) TEX_SUBDIV);
const __GLfloat __glOneOver65535      = ((__GLfloat) (1.0 / 65535.0));
const __GLfloat __glVal2147483648     = ((__GLfloat) 2147483648.0);
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
const __GLfloat __glVal4294965000     =  ((__GLfloat) (4294965000.0));
const __GLfloat __glOneOver4294965000 =  ((__GLfloat) (1.0 / 4294965000.0));

#endif // Real values
#endif // NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_lines.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** Process the incoming line by calling all of the appropriate line procs.
** Return value is ignored.
**
** It sets gc->polygon.shader.cfb to gc->drawBuffer.
*/
GLboolean FASTCALL __glProcessLine(__GLcontext *gc)
{
    GLboolean stippling, retval;
    GLint i,n;
#ifdef NT
    GLint length;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;

    length = gc->polygon.shader.length;
    
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (length+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        words = stackWords;
    }

    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return GL_TRUE;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vFbcolors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return GL_TRUE;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }
#else
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLcolor vFbcolors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    gc->polygon.shader.cfb = gc->drawBuffer;

    stippling = GL_FALSE;
    n = gc->procs.line.n;

    gc->polygon.shader.done = GL_FALSE;

    /* Step 1:  Perform early line stipple, coloring procs */
    for (i = 0; i < n; i++) {
	if (stippling) {
	    if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		/* Line stippled away! */
		retval = GL_TRUE;
		goto __glProcessLineExit;
	    }
	} else {
	    if ((*gc->procs.line.lineFuncs[i])(gc)) {
		if (gc->polygon.shader.done)
                {
                    retval = GL_TRUE;
        	    goto __glProcessLineExit;
        	}
		stippling = GL_TRUE;
	    }
	}
    }

    if (stippling) {
	retval = (*gc->procs.line.wideStippledLineRep)(gc);
    } else {
	retval = (*gc->procs.line.wideLineRep)(gc);
    }
__glProcessLineExit:
#ifdef NT
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
    return (retval);
}

/*
** Process the incoming line by calling the 3 appropriate line procs.  It does
** not chain to gc->procs.line.wideLineRep, but returns instead.  This is a 
** specific fast path.
**
** Return value is ignored.
**
** It sets gc->polygon.shader.cfb to gc->drawBuffer.
*/
GLboolean FASTCALL __glProcessLine3NW(__GLcontext *gc)
{
    GLboolean retval;
#ifdef NT
    GLint length;
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;

    length = gc->polygon.shader.length;
    
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (length+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        words = stackWords;
    }

    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return GL_TRUE;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vFbcolors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return GL_TRUE;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }
#else
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLcolor vFbcolors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    gc->polygon.shader.cfb = gc->drawBuffer;

    gc->polygon.shader.done = GL_FALSE;

    /* Call non-stippled procs... */
    if ((*gc->procs.line.lineFuncs[0])(gc)) {
	if (gc->polygon.shader.done)
        {
            retval = GL_TRUE;
            goto __glProcessLine3NWExit;
        }
	goto stippled1;
    }
    if ((*gc->procs.line.lineFuncs[1])(gc)) {
	if (gc->polygon.shader.done)
        {
            retval = GL_TRUE;
            goto __glProcessLine3NWExit;
        }
	goto stippled2;
    }
    retval = (*gc->procs.line.lineFuncs[2])(gc);
    goto __glProcessLine3NWExit;

stippled1:
    if ((*gc->procs.line.stippledLineFuncs[1])(gc)) {
	retval = GL_TRUE;
	goto __glProcessLine3NWExit;
    }
stippled2:
    retval = (*gc->procs.line.stippledLineFuncs[2])(gc);
__glProcessLine3NWExit:
#ifdef NT
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
    return (retval);
}

/*
** Take incoming line, duplicate it, and continue processing.
**
** Return value is ignored.
*/
GLboolean FASTCALL __glWideLineRep(__GLcontext *gc)
{
    GLint i, m, n, width;
    GLboolean stippling;

    n = gc->procs.line.n;
    m = gc->procs.line.m;
    
    width = gc->line.options.width;

    /* Step 2:  Replicate wide line */
    while (--width >= 0) {
	stippling = GL_FALSE;
	for (i = n; i < m; i++) {
	    if (stippling) {
		if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		    /* Line stippled away! */
		    goto nextLine;
		}
	    } else {
		if ((*gc->procs.line.lineFuncs[i])(gc)) {
		    if (gc->polygon.shader.done) {
			gc->polygon.shader.done = GL_FALSE;
			goto nextLine;
		    }
		    stippling = GL_TRUE;
		}
	    }
	}
	if (stippling) {
	    (*gc->procs.line.drawStippledLine)(gc);
	} else {
	    (*gc->procs.line.drawLine)(gc);
	}
nextLine:
	if (gc->line.options.axis == __GL_X_MAJOR) {
	    gc->line.options.yStart++;
	} else {
	    gc->line.options.xStart++;
	}
    }

    return GL_FALSE;
}

/*
** Take incoming stippled line, duplicate it, and continue processing.
**
** Return value is ignored.
*/
GLboolean FASTCALL __glWideStippleLineRep(__GLcontext *gc)
{
    GLint i, m, n, width;
    GLint stipLen;
    GLint w;
    __GLlineState *ls = &gc->state.line;
    __GLstippleWord *fsp, *tsp;

#ifndef NT
    __GLstippleWord stipplePat[__GL_MAX_STIPPLE_WORDS];
    
    w = gc->polygon.shader.length;
#else
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *stipplePat;
    
    w = gc->polygon.shader.length;
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        stipplePat = gcTempAlloc(gc, (w+__GL_STIPPLE_BITS-1)/8);
        if (stipplePat == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        stipplePat = stackWords;
    }
#endif
    
    n = gc->procs.line.n;
    m = gc->procs.line.m;
    
    width = ls->aliasedWidth;

    /*
    ** XXX - Saving the stipple like this is only really necessary if 
    ** depth or stencil testing.
    */
    stipLen = (w + __GL_STIPPLE_BITS - 1) >> __GL_STIPPLE_COUNT_BITS;

    fsp = gc->polygon.shader.stipplePat;
    tsp = stipplePat;
    for (i = 0; i < stipLen; i++) {
	*tsp++ = *fsp++;
    }

    /* Step 2:  Replicate wide line */
    while (--width >= 0) {
	for (i = n; i < m; i++) {
	    if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		/* Line stippled away! */
		goto nextLine;
	    }
	}
	(*gc->procs.line.drawStippledLine)(gc);
nextLine:
	if (width) {
	    tsp = gc->polygon.shader.stipplePat;
	    fsp = stipplePat;
	    for (i = 0; i < stipLen; i++) {
		*tsp++ = *fsp++;
	    }

	    if (gc->line.options.axis == __GL_X_MAJOR) {
		gc->line.options.yStart++;
	    } else {
		gc->line.options.xStart++;
	    }
	}
    }

#ifdef NT
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, stipplePat);
    }
#endif
    
    return GL_FALSE;
}

/*
** Take incoming line and draw it to both FRONT and BACK buffers.
**
** This routines sets gc->polygon.shader.cfb to &gc->frontBuffer
** and then to &gc->backBuffer
**
** Return value is ignored.
*/
GLboolean FASTCALL __glDrawBothLine(__GLcontext *gc)
{
    GLint i, j, m, l;
    GLboolean stippling;
    GLint w;
    __GLcolor *fcp, *tcp;
#ifdef NT
    __GLcolor colors[__GL_MAX_STACKED_COLORS];
    __GLcolor *vColors;
    
    w = gc->polygon.shader.length;
    if (w > __GL_MAX_STACKED_COLORS)
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
        if (NULL == vColors)
            return GL_TRUE;
    }
    else
    {
        vColors = colors;
    }
#else
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];

    w = gc->polygon.shader.length;
#endif

    m = gc->procs.line.m;
    l = gc->procs.line.l;
    
    /*
    ** XXX - Saving colors like this is only really necessary if blending,
    ** logicOping, or masking.  
    */
    fcp = gc->polygon.shader.colors;
    tcp = vColors;
    if (gc->modes.rgbMode) {
	for (i = 0; i < w; i++) {
	    *tcp++ = *fcp++;
	}
    } else {
	for (i = 0; i < w; i++) {
	    tcp->r = fcp->r;
	    fcp++;
	    tcp++;
	}
    }

    /* Step 3:  Draw to FRONT_AND_BACK */
    for (j = 0; j < 2; j++) {
	if (j == 0) {
	    gc->polygon.shader.cfb = &gc->frontBuffer;
	} else {
	    gc->polygon.shader.cfb = &gc->backBuffer;
	}
	stippling = GL_FALSE;
	for (i = m; i < l; i++) {
	    if (stippling) {
		if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		    /* Line stippled away! */
		    break;
		}
	    } else {
		if ((*gc->procs.line.lineFuncs[i])(gc)) {
		    if (gc->polygon.shader.done) {
			gc->polygon.shader.done = GL_FALSE;
			break;
		    }
		    stippling = GL_TRUE;
		}
	    }
	}

	if (j == 0) {
	    tcp = gc->polygon.shader.colors;
	    fcp = vColors;
	    if (gc->modes.rgbMode) {
		for (i = 0; i < w; i++) {
		    *tcp++ = *fcp++;
		}
	    } else {
		for (i = 0; i < w; i++) {
		    tcp->r = fcp->r;
		    fcp++;
		    tcp++;
		}
	    }
	}
    }
#ifdef NT
    if (w > __GL_MAX_STACKED_COLORS)
    {
        gcTempFree(gc, vColors);
    }
#endif
    return GL_FALSE;
}

/*
** Take incoming stippled line and draw it to both FRONT and BACK buffers.
**
** Return value is ignored.
*/
GLboolean FASTCALL __glDrawBothStippledLine(__GLcontext *gc)
{
    GLint i, m, l, j;
    GLint stipLen;
    GLint w;
    __GLstippleWord *fsp, *tsp;
    __GLcolor *fcp, *tcp;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *stipplePat;
    __GLcolor colors[__GL_MAX_STACKED_COLORS];
    __GLcolor *vColors;

    w = gc->polygon.shader.length;
    
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        stipplePat = gcTempAlloc(gc, (w+__GL_STIPPLE_BITS-1)/8);
        if (stipplePat == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        stipplePat = stackWords;
    }

    if (w > __GL_MAX_STACKED_COLORS)
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (w > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, stipplePat);
            }
            return GL_TRUE;
        }
    }
    else
    {
        vColors = colors;
    }
#else
    __GLstippleWord stipplePat[__GL_MAX_STIPPLE_WORDS];
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];

    w = gc->polygon.shader.length;
#endif

    l = gc->procs.line.l;
    m = gc->procs.line.m;
    

    /*
    ** XXX - Saving colors like this is only really necessary if blending,
    ** logicOping, or masking, and not drawing to FRONT_AND_BACK (because
    ** if we are, then that proc will save colors too)
    */
    fcp = gc->polygon.shader.colors;
    tcp = vColors;
    if (gc->modes.rgbMode) {
	for (i = 0; i < w; i++) {
	    *tcp++ = *fcp++;
	}
    } else {
	for (i = 0; i < w; i++) {
	    tcp->r = fcp->r;
	    fcp++;
	    tcp++;
	}
    }

    /*
    ** XXX - Saving the stipple like this is only really necessary if 
    ** depth or stencil testing.
    */
    stipLen = (w + __GL_STIPPLE_BITS - 1) >> __GL_STIPPLE_COUNT_BITS;

    fsp = gc->polygon.shader.stipplePat;
    tsp = stipplePat;
    for (i = 0; i < stipLen; i++) {
	*tsp++ = *fsp++;
    }

    /* Step 2:  Replicate wide line */
    for (j = 0; j < 2; j++) {
	if (j == 0) {
	    gc->polygon.shader.cfb = &gc->frontBuffer;
	} else {
	    gc->polygon.shader.cfb = &gc->backBuffer;
	}
	for (i = m; i < l; i++) {
	    if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		/* Line stippled away! */
		break;
	    }
	}
	if (j == 0) {
	    tcp = gc->polygon.shader.colors;
	    fcp = vColors;
	    if (gc->modes.rgbMode) {
		for (i = 0; i < w; i++) {
		    *tcp++ = *fcp++;
		}
	    } else {
		for (i = 0; i < w; i++) {
		    tcp->r = fcp->r;
		    fcp++;
		    tcp++;
		}
	    }

	    tsp = gc->polygon.shader.stipplePat;
	    fsp = stipplePat;
	    for (i = 0; i < stipLen; i++) {
		*tsp++ = *fsp++;
	    }
	}
    }
#ifdef NT
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, stipplePat);
    }
    if (w > __GL_MAX_STACKED_COLORS)
    {
        gcTempFree(gc, vColors);
    }
#endif
    return GL_FALSE;
}

GLboolean FASTCALL __glScissorLine(__GLcontext *gc)
{
    GLint clipX0, clipX1;
    GLint clipY0, clipY1;
    GLint xStart, yStart, xEnd, yEnd;
    GLint xLittle, yLittle;
    GLint xBig, yBig;
    GLint fraction, dfraction;
    GLint highWord, lowWord;
    GLint bigs, littles;
    GLint failed, count;
    GLint w;
    __GLstippleWord bit, outMask, *osp;

    w = gc->polygon.shader.length;
    
    clipX0 = gc->transform.clipX0;
    clipX1 = gc->transform.clipX1;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;

    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;

    /* If the start point is in the scissor region, we attempt to trivially
    ** accept the line.
    */
    if (xStart >= clipX0 && xStart < clipX1 &&
	    yStart >= clipY0 && yStart < clipY1) {

	w--;	/* Makes our math simpler */
	/* Trivial accept attempt */
	xEnd = xStart + xBig * w;
	yEnd = yStart + yBig * w;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}

	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;

	/* Invert negative minor slopes so we can assume dfraction > 0 */
	if (dfraction < 0) {
	    dfraction = -dfraction;
	    fraction = 0x7fffffff - fraction;
	}

	/* Now we compute number of littles and bigs in this line */

	/* We perform a 16 by 32 bit multiply.  Ugh. */
	highWord = (((GLuint) dfraction) >> 16) * w + 
		(((GLuint) fraction) >> 16);
	lowWord = (dfraction & 0xffff) * w + (fraction & 0xffff);
	highWord += (((GLuint) lowWord) >> 16);
	bigs = ((GLuint) highWord) >> 15;
	littles = w - bigs;

	/* Second trivial accept attempt */
	xEnd = xStart + xBig*bigs + xLittle*littles;
	yEnd = yStart + yBig*bigs + yLittle*littles;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}
	w++;	/* Restore w */
    } else {
	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;
    }

    /*
    ** Note that we don't bother to try trivially rejecting this line.  After
    ** all, it has already been clipped, and the only way that it might
    ** possibly be trivially rejected is if it is a piece of a wide line that
    ** runs right along the edge of the window.
    */

    /*
    ** This sucks.  The line needs to be scissored.
    ** Well, it should only happen rarely, so we can afford
    ** to make it slow.  We achieve this by tediously stippling the line.
    ** (rather than clipping it, of course, which would be faster but harder).
    */
    failed = 0;
    osp = gc->polygon.shader.stipplePat;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (xStart < clipX0 || xStart >= clipX1 ||
		    yStart < clipY0 || yStart >= clipY1) {
		outMask &= ~bit;
		failed++;
	    }

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		xStart += xBig;
		yStart += yBig;
	    } else {
		xStart += xLittle;
		yStart += yLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}

	*osp++ = outMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_TRUE;
    }

    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glScissorStippledLine(__GLcontext *gc)
{
    GLint clipX0, clipX1;
    GLint clipY0, clipY1;
    GLint xStart, yStart, xEnd, yEnd;
    GLint xLittle, yLittle;
    GLint xBig, yBig;
    GLint fraction, dfraction;
    GLint highWord, lowWord;
    GLint bigs, littles;
    GLint failed, count;
    GLint w;
    __GLstippleWord *sp;
    __GLstippleWord bit, outMask, inMask;

    w = gc->polygon.shader.length;

    clipX0 = gc->transform.clipX0;
    clipX1 = gc->transform.clipX1;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;

    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;

    /* If the start point is in the scissor region, we attempt to trivially
    ** accept the line.
    */
    if (xStart >= clipX0 && xStart < clipX1 &&
	    yStart >= clipY0 && yStart < clipY1) {

	w--;	/* Makes our math simpler */
	/* Trivial accept attempt */
	xEnd = xStart + xBig * w;
	yEnd = yStart + yBig * w;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}

	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;

	/* Invert negative minor slopes so we can assume dfraction > 0 */
	if (dfraction < 0) {
	    dfraction = -dfraction;
	    fraction = 0x7fffffff - fraction;
	}

	/* Now we compute number of littles and bigs in this line */

	/* We perform a 16 by 32 bit multiply.  Ugh. */
	highWord = (((GLuint) dfraction) >> 16) * w + 
		(((GLuint) fraction) >> 16);
	lowWord = (dfraction & 0xffff) * w + (fraction & 0xffff);
	highWord += (((GLuint) lowWord) >> 16);
	bigs = ((GLuint) highWord) >> 15;
	littles = w - bigs;

	/* Second trivial accept attempt */
	xEnd = xStart + xBig*bigs + xLittle*littles;
	yEnd = yStart + yBig*bigs + yLittle*littles;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}
	w++;	/* Restore w */
    } else {
	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;
    }

    /*
    ** Note that we don't bother to try trivially rejecting this line.  After
    ** all, it has already been clipped, and the only way that it might
    ** possibly be trivially rejected is if it is a piece of a wide line that
    ** runs right along the edge of the window.
    */

    /*
    ** This sucks.  The line needs to be scissored.
    ** Well, it should only happen rarely, so we can afford
    ** to make it slow.  We achieve this by tediously stippling the line.
    ** (rather than clipping it, of course, which would be faster but harder).
    */
    sp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		if (xStart < clipX0 || xStart >= clipX1 ||
			yStart < clipY0 || yStart >= clipY1) {
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		xStart += xBig;
		yStart += yBig;
	    } else {
		xStart += xLittle;
		yStart += yLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}

	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }

    return GL_TRUE;
}

/*
** Create a stipple based upon the current line stipple for this line.
*/
GLboolean FASTCALL __glStippleLine(__GLcontext *gc)
{
    GLint failed, count, stippleRepeat;
    GLint stipple, currentBit, stipplePos, repeat;
    __GLstippleWord bit, outMask, *osp;
    __GLlineState *ls = &gc->state.line;
    GLint w;

    w = gc->polygon.shader.length;
    osp = gc->polygon.shader.stipplePat;
    repeat = gc->line.repeat;
    stippleRepeat = ls->stippleRepeat;
    stipplePos = gc->line.stipplePosition;
    currentBit = 1 << stipplePos;
    stipple = ls->stipple;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if ((stipple & currentBit) == 0) {
		/* Stippled fragment away */
		outMask &= ~bit;
		failed++;
	    }

	    if (++repeat >= stippleRepeat) {
		stipplePos = (stipplePos + 1) & 0xf;
		currentBit = 1 << stipplePos;
		repeat = 0;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    gc->line.repeat = repeat;
    gc->line.stipplePosition = stipplePos;

    if (failed == 0) {
	return GL_FALSE;
    } else if (failed != gc->polygon.shader.length) {
	return GL_TRUE;
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Apply the stencil test to this line.
*/
GLboolean FASTCALL __glStencilTestLine(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    GLint count, failed;
    __GLstippleWord bit, outMask, *osp;
    GLuint smask;
    GLint w;

    w = gc->polygon.shader.length;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    smask = gc->state.stencil.mask;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    cell = sfb[0];
	    if (!tft[cell & smask]) {
		/* Test failed */
		outMask &= ~bit;
		sfb[0] = fail[cell];
		failed++;
	    }

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		sfb += dspBig;
	    } else {
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Apply the stencil test to this stippled line.
*/
GLboolean FASTCALL __glStencilTestStippledLine(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint count, failed;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLint dspLittle, dspBig;
    GLuint smask;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    smask = gc->state.stencil.mask;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		cell = sfb[0];
		if (!tft[cell & smask]) {
		    /* Test failed */
		    outMask &= ~bit;
		    sfb[0] = fail[cell];
		    failed++;
		}
	    } else failed++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		sfb += dspBig;
	    } else {
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }
    return GL_TRUE;
}

#ifndef __GL_USEASMCODE

GLboolean FASTCALL __glDepthTestLine(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		if (writeEnabled) {
		    zfb[0] = z;
		}
	    } else {
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

#endif

GLboolean FASTCALL __glDepthTestStippledLine(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    if (writeEnabled) {
			zfb[0] = z;
		    }
		} else {
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean FASTCALL __glDepthTestStencilLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		sfb[0] = zPassOp[sfb[0]];
		if (writeEnabled) {
		    zfb[0] = z;
		}
	    } else {
		sfb[0] = zFailOp[sfb[0]];
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepthTestStencilStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    sfb[0] = zPassOp[sfb[0]];
		    if (writeEnabled) {
			zfb[0] = z;
		    }
		} else {
		    sfb[0] = zFailOp[sfb[0]];
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }

    return GL_TRUE;
}

#ifdef NT
GLboolean FASTCALL __glDepth16TestLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    z16 = z >> Z16_SHIFT;
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		if (writeEnabled) {
		    zfb[0] = z16;
		}
	    } else {
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepth16TestStippledLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		z16 = z >> Z16_SHIFT;
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    if (writeEnabled) {
			zfb[0] = z16;
		    }
		} else {
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean FASTCALL __glDepth16TestStencilLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    z16 = z >> Z16_SHIFT;
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		sfb[0] = zPassOp[sfb[0]];
		if (writeEnabled) {
		    zfb[0] = z16;
		}
	    } else {
		sfb[0] = zFailOp[sfb[0]];
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepth16TestStencilStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		z16 = z >> Z16_SHIFT;
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    sfb[0] = zPassOp[sfb[0]];
		    if (writeEnabled) {
			zfb[0] = z16;
		    }
		} else {
		    sfb[0] = zFailOp[sfb[0]];
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }

    return GL_TRUE;
}
#endif // NT

GLboolean FASTCALL __glDepthPassLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    while (--w >= 0) {
	sfb[0] = zPassOp[sfb[0]];
	fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    sfb += dspBig;
	} else {
	    sfb += dspLittle;
	}
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glDepthPassStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    __GLstippleWord bit, inMask, *sp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		sfb[0] = zPassOp[sfb[0]];
	    }
	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		sfb += dspBig;
	    } else {
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glDitherCILine(__GLcontext *gc)
{
    /* XXX - Dither the CI line */
    return GL_FALSE;
}

GLboolean FASTCALL __glDitherCIStippledLine(__GLcontext *gc)
{
    /* XXX - Dither the CI stippled line */
    return GL_FALSE;
}

GLboolean FASTCALL __glDitherRGBALine(__GLcontext *gc)
{
    /* XXX - Dither the RGBA line */
    return GL_FALSE;
}

GLboolean FASTCALL __glDitherRGBAStippledLine(__GLcontext *gc)
{
    /* XXX - Dither the RGBA stippled line */
    return GL_FALSE;
}

/*
** This store line proc lives just above cfb->store, so it does
** fetching, blending, dithering, logicOping, masking, and storing.
**
** It uses the colorBuffer pointed to by gc->polygon.shader.cfb.
*/
GLboolean FASTCALL __glStoreLine(__GLcontext *gc)
{
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint len;

    len = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;
    store = cfb->store;
    frag.x = gc->line.options.xStart;
    frag.y = gc->line.options.yStart;

    while (--len >= 0) {
	frag.color = *cp++;
	(*store)(cfb, &frag);

	fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    frag.x += xBig;
	    frag.y += yBig;
	} else {
	    frag.x += xLittle;
	    frag.y += yLittle;
	}
    }

    return GL_FALSE;
}

/*
** This store line proc lives just above cfb->store, so it does
** fetching, blending, dithering, logicOping, masking, and storing.
**
** It uses the colorBuffer pointed to by gc->polygon.shader.cfb.
*/
GLboolean FASTCALL __glStoreStippledLine(__GLcontext *gc)
{
    GLint x, y, xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint len;

    len = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;
    store = cfb->store;
    x = gc->line.options.xStart;
    y = gc->line.options.yStart;

    while (len) {
	count = len;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	len -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		frag.x = x;
		frag.y = y;
		frag.color = *cp;
		(*store)(cfb, &frag);
	    }

	    cp++;
	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		x += xBig;
		y += yBig;
	    } else {
		x += xLittle;
		y += yLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glAntiAliasLine(__GLcontext *gc)
{
    __GLfloat length;	/* Dist along length */
    __GLfloat width;	/* Dist along width */
    GLint fraction, dfraction;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLcolor *cp;
    __GLfloat coverage;
    __GLfloat lineWidth;
    __GLfloat lineLength;
    GLint failed, count;
    __GLstippleWord bit, outMask, *osp;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    w = gc->polygon.shader.length;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    cp = gc->polygon.shader.colors;

    dlLittle = gc->line.options.dlLittle;
    dlBig = gc->line.options.dlBig;
    ddLittle = gc->line.options.ddLittle;
    ddBig = gc->line.options.ddBig;

    length = gc->line.options.plength;
    width = gc->line.options.pwidth;
    lineLength = gc->line.options.realLength - __glHalf;
    lineWidth = __glHalf * gc->state.line.smoothWidth - __glHalf;


    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);

	while (--count >= 0) {
	    /* Coverage for sides */
	    if (width > lineWidth) {
		coverage = lineWidth - width + __glOne;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } else if (width < -lineWidth) {
		coverage = width + lineWidth + __glOne;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } else {
		coverage = __glOne;
	    }

	    /* Coverage for start, end */
	    if (length < __glHalf) {
		coverage *= length + __glHalf;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } else if (length > lineLength) {
		coverage *= lineLength - length + __glOne;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } 

	    /* Coverage for internal stipples */
	    if ( modeFlags & __GL_SHADE_LINE_STIPPLE ) {
		__GLfloat stippleOffset;
		GLint lowStip, highStip;
		GLint lowBit, highBit;
		GLint lowVal, highVal;
		__GLfloat percent;

		/* Minor correction */
		if (length > __glHalf) {
		    stippleOffset = gc->line.options.stippleOffset + length;
		} else {
		    stippleOffset = gc->line.options.stippleOffset + __glHalf;
		}
		lowStip = __GL_FAST_FLOORF_I(stippleOffset);
		highStip = lowStip + 1;

		/* percent is the percent of highStip that will be used */
		percent = stippleOffset - lowStip;

		lowBit = (GLint) (lowStip * 
			gc->line.options.oneOverStippleRepeat) & 0xf;
		highBit = (GLint) (highStip * 
			gc->line.options.oneOverStippleRepeat) & 0xf;

		if (gc->state.line.stipple & (1<<lowBit)) {
		    lowVal = 1;
		} else {
		    lowVal = 0;
		}

		if (gc->state.line.stipple & (1<<highBit)) {
		    highVal = 1;
		} else {
		    highVal = 0;
		}

		coverage *= lowVal * (__glOne - percent) +
			highVal * percent;
	    }

	    if (coverage == __glZero) {
coverageZero:;
		outMask &= ~bit;
		failed++;
	    } else {
		if (gc->modes.colorIndexMode) {
		    cp->r = __glBuildAntiAliasIndex(cp->r, coverage);
		} else {
		    cp->a *= coverage;
		}
	    }
	    cp++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		length += dlBig;
		width += ddBig;
	    } else {
		length += dlLittle;
		width += ddLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glAntiAliasStippledLine(__GLcontext *gc)
{
    __GLfloat length;	/* Dist along length */
    __GLfloat width;	/* Dist along width */
    GLint fraction, dfraction;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLcolor *cp;
    __GLfloat coverage;
    __GLfloat lineWidth;
    __GLfloat lineLength;
    GLint failed, count;
    __GLstippleWord bit, outMask, inMask, *sp;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    cp = gc->polygon.shader.colors;

    dlLittle = gc->line.options.dlLittle;
    dlBig = gc->line.options.dlBig;
    ddLittle = gc->line.options.ddLittle;
    ddBig = gc->line.options.ddBig;

    length = gc->line.options.plength;
    width = gc->line.options.pwidth;
    lineLength = gc->line.options.realLength - __glHalf;
    lineWidth = __glHalf * gc->state.line.smoothWidth - __glHalf;

    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		/* Coverage for sides */
		if (width > lineWidth) {
		    coverage = lineWidth - width + __glOne;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} else if (width < -lineWidth) {
		    coverage = width + lineWidth + __glOne;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} else {
		    coverage = __glOne;
		}

		/* Coverage for start, end */
		if (length < __glHalf) {
		    coverage *= length + __glHalf;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} else if (length > lineLength) {
		    coverage *= lineLength - length + __glOne;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} 

		/* Coverage for internal stipples */
		if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
		    __GLfloat stippleOffset;
		    GLint lowStip, highStip;
		    GLint lowBit, highBit;
		    GLint lowVal, highVal;
		    __GLfloat percent;

		    /* Minor correction */
		    if (length > __glHalf) {
			stippleOffset = gc->line.options.stippleOffset + length;
		    } else {
			stippleOffset = gc->line.options.stippleOffset + __glHalf;
		    }
		    lowStip = __GL_FAST_FLOORF_I(stippleOffset);
		    highStip = lowStip + 1;

		    /* percent is the percent of highStip that will be used */
		    percent = stippleOffset - lowStip;

		    lowBit = (GLint) (lowStip * 
			    gc->line.options.oneOverStippleRepeat) & 0xf;
		    highBit = (GLint) (highStip * 
			    gc->line.options.oneOverStippleRepeat) & 0xf;

		    if (gc->state.line.stipple & (1<<lowBit)) {
			lowVal = 1;
		    } else {
			lowVal = 0;
		    }

		    if (gc->state.line.stipple & (1<<highBit)) {
			highVal = 1;
		    } else {
			highVal = 0;
		    }

		    coverage *= lowVal * (__glOne - percent) +
			    highVal * percent;
		}

		if (coverage == __glZero) {
coverageZero:;
		    outMask &= ~bit;
		    failed++;
		} else {
		    if (gc->modes.colorIndexMode) {
			cp->r = __glBuildAntiAliasIndex(cp->r, coverage);
		    } else {
			cp->a *= coverage;
		    }
		}
	    } else failed++;
	    cp++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		length += dlBig;
		width += ddBig;
	    } else {
		length += dlLittle;
		width += ddLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed == gc->polygon.shader.length) {
	return GL_TRUE;
    }
    return GL_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_lined.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop
#include "phong.h"

#define __TWO_31 ((__GLfloat) 2147483648.0)

/*
** Most line functions will start off by computing the information 
** computed by this routine.
**
** The excessive number of labels in this routine is partly due
** to the fact that it is used as a model for writing an assembly 
** equivalent.
*/
#ifndef NT
void FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start, end;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    GLint intMinorStart;
    __GLfloat dx, dy;
    __GLfloat offset;
    __GLfloat slope;
    __GLlineState *ls = &gc->state.line;
    __GLfloat halfWidth;
    __GLfloat x0frac, x1frac, y0frac, y1frac, half, totDist;

    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;
    gc->line.options.width = gc->state.line.aliasedWidth;

    x0=v0->window.x;
    y0=v0->window.y;
    x1=v1->window.x;
    y1=v1->window.y;
    dx=x1-x0;
    dy=y1-y0;

    halfWidth = (ls->aliasedWidth - 1) * __glHalf;

    /* Ugh.  This is slow.  Bummer. */
    x0frac = x0 - ((GLint) x0);
    x1frac = x1 - ((GLint) x1);
    y0frac = y0 - ((GLint) y0);
    y1frac = y1 - ((GLint) y1);
    half = __glHalf;

    if (dx > __glZero) {
	if (dy > __glZero) {
	    if (dx > dy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
		slope = dy/dx;

		start = (GLint) (x0);
		end = (GLint) (x1);

		y0frac -= half;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + x0frac - half;
		if (totDist > half) start++;

		y1frac -= half;
		if (y1frac < 0) y1frac = -y1frac;

		totDist = y1frac + x1frac - half;
		if (totDist > half) end++;

		offset = start + half - x0;

		gc->line.options.length = dx;
		gc->line.options.numPixels = end - start;

xmajorfinish:
		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;
		minorStart = y0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.yStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
		slope = dx/dy;

		start = (GLint) (y0);
		end = (GLint) (y1);

		x0frac -= half;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = y0frac + x0frac - half;
		if (totDist > half) start++;

		x1frac -= half;
		if (x1frac < 0) x1frac = -x1frac;

		totDist = y1frac + x1frac - half;
		if (totDist > half) end++;

		offset = start + half - y0;

		gc->line.options.length = dy;
		gc->line.options.numPixels = end - start;

ymajorfinish:
		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;
		minorStart = x0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.xStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    }
	} else {
	    if (dx > -dy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
		slope = dx/-dy;

		start = (GLint) (y0);
		end = (GLint) (y1);

		x0frac -= half;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = x0frac + half - y0frac;
		if (totDist > half) start--;

		x1frac -= half;
		if (x1frac < 0) x1frac = -x1frac;

		totDist = x1frac + half - y1frac;
		if (totDist > half) end--;

		offset = y0 - (start + half);

		gc->line.options.length = -dy;
		gc->line.options.numPixels = start - end;
		goto ymajorfinish;
	    }
	}
    } else {
	if (dy > __glZero) {
	    if (-dx > dy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
		slope = dy/-dx;

		start = (GLint) (x0);
		end = (GLint) (x1);

		y0frac -= half;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + half - x0frac;
		if (totDist > half) start--;

		y1frac -= half;
		if (y1frac < 0) y1frac = -y1frac;

		totDist = y1frac + half - x1frac;
		if (totDist > half) end--;

		offset = x0 - (start + half);

		gc->line.options.length = -dx;
		gc->line.options.numPixels = start - end;

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
		goto posymajor;
	    }
	} else {
	    if (dx < dy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
#ifdef NT 
		if (dx == dy && dy == 0) {
		    gc->line.options.numPixels = 0;
		    return;
		}
#else
		if (dx == dy && dy == 0) return;
#endif
		gc->line.options.xBig = -1;
		goto negymajor;
	    }
	}
    }
}
#endif

#ifdef NT
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, GLuint flags)
#else
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
#endif
{
    __GLlineState *ls = &gc->state.line;
    __GLfloat invDelta;
    __GLfloat winv, r;
    __GLcolor *cp;
    __GLfloat offset;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

#ifndef NT
    __glInitLineData(gc, v0, v1);
    if (gc->line.options.numPixels == 0) return;
#else
    GLboolean init;
    CHOP_ROUND_ON();

    init = (GLboolean)__glInitLineData(gc, v0, v1);

    CHOP_ROUND_OFF();

    if (!init)
    {
        return;
    }

    invDelta = gc->line.options.oneOverLength;
#endif

    offset = gc->line.options.offset;

    /*
    ** Set up increments for any enabled line options.
    */
#ifndef NT
    invDelta = __glOne / gc->line.options.length;
#endif
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        __GLfloat dzdx;

        /*
        ** Calculate window z coordinate increment and starting position.
        */
        dzdx = (v1->window.z - v0->window.z) * invDelta;
#ifdef NT
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
            gc->polygon.shader.frag.z = 
              (__GLzValue)(Z16_SCALE *(v0->window.z + dzdx * offset));
            gc->polygon.shader.dzdx = (GLint)(Z16_SCALE * dzdx);
        }
        else {
            gc->polygon.shader.frag.z = 
              (__GLzValue)(v0->window.z + dzdx * offset);
            gc->polygon.shader.dzdx = (GLint)dzdx;
        }
#else
        gc->polygon.shader.frag.z = (__GLzValue)(v0->window.z + dzdx * offset);
        gc->polygon.shader.dzdx = (GLint)dzdx;
#endif
    }

    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        if (!gc->line.notResetStipple) {
            gc->line.stipplePosition = 0;
            gc->line.repeat = 0;
            gc->line.notResetStipple = GL_TRUE;
        }
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        gc->line.options.f0 = f0 = v0->eyeZ;
        gc->polygon.shader.dfdx = dfdx = 
            (v1->eyeZ - v0->eyeZ) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        f0 = v0->fog;
        f1 = v1->fog;
        gc->line.options.f0 = f0;
        gc->polygon.shader.dfdx = dfdx = (f1 - f0) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }
    
    if (modeFlags & __GL_SHADE_TEXTURE) {
        __GLfloat v0QW, v1QW;
        __GLfloat dS, dT, dQWdX;
        winv = v0->window.w;

        /*
        ** Calculate texture s and t value increments.
        */
        v0QW = v0->texture.w * winv;
        v1QW = v1->texture.w * v1->window.w;
        dS = (v1->texture.x * v1QW - v0->texture.x * v0QW) * invDelta;
        dT = (v1->texture.y * v1QW - v0->texture.y * v0QW) * invDelta;
        gc->polygon.shader.dsdx = dS;
        gc->polygon.shader.dtdx = dT;
        gc->polygon.shader.dqwdx = dQWdX = (v1QW - v0QW) * invDelta;
        gc->polygon.shader.frag.s = v0->texture.x * winv + dS * offset;
        gc->polygon.shader.frag.t = v0->texture.y * winv + dT * offset;
        gc->polygon.shader.frag.qw = v0->texture.w * winv + dQWdX * offset;
    } 
    
#ifdef GL_WIN_phong_shading
    if (modeFlags & __GL_SHADE_PHONG) 
        (*gc->procs.phong.InitLineParams) (gc, v0, v1, invDelta);
#endif //GL_WIN_phong_shading

    if ((modeFlags & __GL_SHADE_SMOOTH) 
#ifdef GL_WIN_phong_shading
        || ((modeFlags & __GL_SHADE_PHONG) &&
            (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_COLOR_XPOLATE))
#endif //GL_WIN_phong_shading
        ) {
        __GLcolor *c0 = v0->color;
        __GLcolor *c1 = v1->color;
        __GLfloat drdx, dgdx, dbdx, dadx;

        /*
        ** Calculate red, green, blue and alpha value increments.
        */
        drdx = (c1->r - c0->r) * invDelta;
        if (gc->modes.rgbMode) {
            dgdx = (c1->g - c0->g) * invDelta;
            dbdx = (c1->b - c0->b) * invDelta;
            dadx = (c1->a - c0->a) * invDelta;
            gc->polygon.shader.dgdx = dgdx;
            gc->polygon.shader.dbdx = dbdx;
            gc->polygon.shader.dadx = dadx;
        }
        gc->polygon.shader.drdx = drdx;
        cp = v0->color;
    } else {
        cp = v1->color;

        // Initialize these values to zero even for the flat case
        // because there is an optimization in so_prim which will
        // turn off smooth shading without repicking, so these need
        // to be valid
        gc->polygon.shader.drdx = __glZero;
        gc->polygon.shader.dgdx = __glZero;
        gc->polygon.shader.dbdx = __glZero;
        gc->polygon.shader.dadx = __glZero;
    }

    r = cp->r;
    if (modeFlags & __GL_SHADE_RGB) {
        __GLfloat g,b,a;

        g = cp->g;
        b = cp->b;
        a = cp->a;
        gc->polygon.shader.frag.color.g = g;
        gc->polygon.shader.frag.color.b = b;
        gc->polygon.shader.frag.color.a = a;
    }
    gc->polygon.shader.frag.color.r = r;
    
    gc->polygon.shader.length = gc->line.options.numPixels;
    (*gc->procs.line.processLine)(gc);
}

#ifdef NT
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
                                    __GLvertex *v1, GLuint flags)
#else
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
                                    __GLvertex *v1)
#endif
{
    __GLcolor v0col, v1col;
    __GLcolor *v0ocp, *v1ocp;

    (*gc->procs.fogColor)(gc, &v0col, v1->color, v0->fog);
    (*gc->procs.fogColor)(gc, &v1col, v1->color, v1->fog);
    v0ocp = v0->color;
    v1ocp = v1->color;
    v0->color = &v0col;
    v1->color = &v1col;

#ifdef NT
    (*gc->procs.renderLine2)(gc, v0, v1, flags);
#else
    (*gc->procs.renderLine2)(gc, v0, v1);
#endif
    
    v0->color = v0ocp;
    v1->color = v1ocp;
}


/************************************************************************/

/*
** Most line functions will start off by computing the information 
** computed by this routine.
**
** The excessive number of labels in this routine is partly due
** to the fact that it is used as a model for writing an assembly 
** equivalent.
*/
void FASTCALL __glInitAALineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start;
    __GLfloat width;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    GLint intMinorStart;
    __GLfloat dx, dy;
    __GLfloat offset;
    __GLfloat slope;
    __GLlineState *ls = &gc->state.line;
    __GLfloat halfWidth;
    __GLfloat realLength, oneOverRealLength;
    __GLfloat dldx, dldy;
    __GLfloat dddx, dddy;

    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;

    x0=v0->window.x;
    y0=v0->window.y;
    x1=v1->window.x;
    y1=v1->window.y;
    dx=x1-x0;
    dy=y1-y0;
    realLength = __GL_SQRTF(dx*dx+dy*dy);
    oneOverRealLength = realLength == __glZero ? __glZero : __glOne/realLength;
    gc->line.options.realLength = realLength;
    gc->line.options.dldx = dldx = dx * oneOverRealLength;
    gc->line.options.dldy = dldy = dy * oneOverRealLength;
    gc->line.options.dddx = dddx = -dldy;
    gc->line.options.dddy = dddy = dldx;

    if (dx > __glZero) {
	if (dy > __glZero) {	/* dx > 0, dy > 0 */
	    gc->line.options.dlBig = dldx + dldy;
	    gc->line.options.ddBig = dddx + dddy;
	    if (dx > dy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
		gc->line.options.dlLittle = dldx;
		gc->line.options.ddLittle = dddx;
		slope = dy/dx;
		start = (GLint) x0;
		offset = start + __glHalf - x0;

		gc->line.options.length = dx;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(x1 - x0) + 1;

		width = __GL_FAST_CEILF(gc->state.line.smoothWidth * 
			realLength / dx);
xmajorfinish:
		gc->line.options.width = (GLint)width + 1;
		halfWidth = width * __glHalf;

		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;
		minorStart = y0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.yStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
		gc->line.options.dlLittle = dldy;
		gc->line.options.ddLittle = dddy;
		slope = dx/dy;
		start = (GLint) y0;
		offset = start + __glHalf - y0;

		gc->line.options.length = dy;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(y1 - y0) + 1;

		width = __GL_FAST_CEILF(gc->state.line.smoothWidth * 
			realLength / dy);
ymajorfinish:
		gc->line.options.width = (GLint)width + 1;
		halfWidth = width * __glHalf;

		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;
		minorStart = x0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.xStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    }
	} else {		/* dx > 0, dy <= 0 */
	    gc->line.options.dlBig = dldx - dldy;
	    gc->line.options.ddBig = dddx - dddy;
	    if (dx > -dy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
		gc->line.options.dlLittle = -dldy;
		gc->line.options.ddLittle = -dddy;
		slope = dx/-dy;
		start = (GLint) y0;
		offset = y0 - (start + __glHalf);

		gc->line.options.length = -dy;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(y0 - y1) + 1;

		width = __GL_FAST_CEILF(-gc->state.line.smoothWidth * 
			realLength / dy);

		goto ymajorfinish;
	    }
	}
    } else {
	if (dy > __glZero) {	/* dx <= 0, dy > 0 */
	    gc->line.options.dlBig = dldy - dldx;
	    gc->line.options.ddBig = dddy - dddx;
	    if (-dx > dy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
		gc->line.options.dlLittle = -dldx;
		gc->line.options.ddLittle = -dddx;
		slope = dy/-dx;
		start = (GLint) x0;
		offset = x0 - (start + __glHalf);

		gc->line.options.length = -dx;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(x0 - x1) + 1;

		width = __GL_FAST_CEILF(-gc->state.line.smoothWidth * 
			realLength / dx);

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
		goto posymajor;
	    }
	} else {		/* dx <= 0, dy <= 0 */
	    gc->line.options.dlBig = -dldx - dldy;
	    gc->line.options.ddBig = -dddx - dddy;
	    if (dx < dy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
		if (dx == dy && dy == 0) {
		    gc->line.options.length = 0;
		    return;
		}
		gc->line.options.xBig = -1;
		goto negymajor;
	    }
	}
    }
}

#ifdef NT
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, GLuint flags)
#else
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
#endif
{
    __GLlineState *ls = &gc->state.line;
    __GLfloat invDelta;
    __GLfloat winv;
    __GLcolor *cp;
    __GLfloat offset;
    GLint lineRep;
    GLint x, y, xBig, xLittle, yBig, yLittle;
    GLint fraction, dfraction;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLfloat length, width;
    __GLfloat lineLength;
    __GLfloat dx, dy;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    __glInitAALineData(gc, v0, v1);
    if (gc->line.options.length == 0) return;

    offset = gc->line.options.offset;

    /*
    ** Set up increments for any enabled line options.
    */
    invDelta = __glOne / gc->line.options.length;
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        /*
        ** Calculate window z coordinate increment and starting position.
        */
#ifdef NT
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
            gc->polygon.shader.dzdx = (GLint)((v1->window.z - v0->window.z) * 
                                              invDelta * Z16_SCALE);
            gc->polygon.shader.frag.z = (GLint)(Z16_SCALE*v0->window.z + 
                                                gc->polygon.shader.dzdx * offset);
        }
        else {
            gc->polygon.shader.dzdx = (GLint)((v1->window.z - v0->window.z) * 
                                              invDelta);
            gc->polygon.shader.frag.z = (GLint)(v0->window.z + 
                                                gc->polygon.shader.dzdx * offset);
        }
#else
        gc->polygon.shader.dzdx = (GLint)((v1->window.z - v0->window.z) * 
                                          invDelta);
        gc->polygon.shader.frag.z = (GLint)(v0->window.z + 
                                            gc->polygon.shader.dzdx * offset);
#endif
    } 

    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        if (!gc->line.notResetStipple) {
            gc->line.stipplePosition = 0;
            gc->line.repeat = 0;
            gc->line.notResetStipple = GL_TRUE;
        }
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        f0 = v0->eyeZ;
        f1 = v1->eyeZ;
        gc->line.options.f0 = f0;
        gc->polygon.shader.dfdx = dfdx = (f1 - f0) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        f0 = v0->fog;
        f1 = v1->fog;
        gc->line.options.f0 = f0;
        gc->polygon.shader.dfdx = dfdx = (f1 - f0) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }

    if ((modeFlags & __GL_SHADE_SMOOTH) 
#ifdef GL_WIN_phong_shading
        || ((modeFlags & __GL_SHADE_PHONG) &&
            (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_COLOR_XPOLATE))
#endif //GL_WIN_phong_shading
        ) 
    {
        __GLcolor *c0 = v0->color;
        __GLcolor *c1 = v1->color;

        /*
        ** Calculate red, green, blue and alpha value increments.
        */
        gc->polygon.shader.drdx = (c1->r - c0->r) * invDelta;
        if (gc->modes.rgbMode) {
            gc->polygon.shader.dgdx = (c1->g - c0->g) * invDelta;
            gc->polygon.shader.dbdx = (c1->b - c0->b) * invDelta;
            gc->polygon.shader.dadx = (c1->a - c0->a) * invDelta;
        }
        cp = v0->color;
    } else {
        cp = v1->color;

        // Initialize these values to zero even for the flat case
        // because there is an optimization in so_prim which will
        // turn off smooth shading without repicking, so these need
        // to be valid
        gc->polygon.shader.drdx = __glZero;
        gc->polygon.shader.dgdx = __glZero;
        gc->polygon.shader.dbdx = __glZero;
        gc->polygon.shader.dadx = __glZero;
    }

    gc->polygon.shader.frag.color.r = cp->r;
    if (gc->modes.rgbMode) {
        gc->polygon.shader.frag.color.g = cp->g;
        gc->polygon.shader.frag.color.b = cp->b;
        gc->polygon.shader.frag.color.a = cp->a;
    }

    if (gc->texture.textureEnabled) {
        __GLfloat v0QW, v1QW;
        __GLfloat dS, dT;

        /*
        ** Calculate texture s and t value increments.
        */
        v0QW = v0->texture.w * v0->window.w;
        v1QW = v1->texture.w * v1->window.w;
        dS = (v1->texture.x * v1QW - v0->texture.x * v0QW) * invDelta;
        dT = (v1->texture.y * v1QW - v0->texture.y * v0QW) * invDelta;
        gc->polygon.shader.dsdx = dS;
        gc->polygon.shader.dtdx = dT;
        gc->polygon.shader.dqwdx = (v1QW - v0QW) * invDelta;
        
        winv = v0->window.w;
        gc->polygon.shader.frag.s = v0->texture.x * winv + 
          gc->polygon.shader.dsdx * offset;
        gc->polygon.shader.frag.t = v0->texture.y * winv + 
          gc->polygon.shader.dtdx * offset;
        gc->polygon.shader.frag.qw = v0->texture.w * winv + 
          gc->polygon.shader.dqwdx * offset;
    } 

    lineRep = gc->line.options.width;
    
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    
    x = gc->line.options.xStart;
    y = gc->line.options.yStart;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    
    dlLittle = gc->line.options.dlLittle;
    dlBig = gc->line.options.dlBig;
    ddLittle = gc->line.options.ddLittle;
    ddBig = gc->line.options.ddBig;
    
    dx = x + __glHalf - v0->window.x;
    dy = y + __glHalf - v0->window.y;
    length = dx * gc->line.options.dldx +
      dy * gc->line.options.dldy;
    width = dx * gc->line.options.dddx +
      dy * gc->line.options.dddy;
    lineLength = gc->line.options.realLength + __glHalf;
    
    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        gc->line.options.stippleOffset = 
          gc->line.stipplePosition * gc->state.line.stippleRepeat +
          gc->line.repeat - __glHalf;
        
        /* XXX Move to a validation routine? */
        gc->line.options.oneOverStippleRepeat = 
          __glOne / gc->state.line.stippleRepeat;
    }
    
    while (--lineRep >= 0) {
        /* Trace the line backwards as needed */
        while (length > -__glHalf) {
            fraction -= dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                length -= dlBig;
                width -= ddBig;
                x -= xBig;
                y -= yBig;
            } else {
                length -= dlLittle;
                width -= ddLittle;
                x -= xLittle;
                y -= yLittle;
            }
        }

        /* Trace line forwards to correct */
        while (length <= -__glHalf) {
            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                length += dlBig;
                width += ddBig;
                x += xBig;
                y += yBig;
            } else {
                length += dlLittle;
                width += ddLittle;
                x += xLittle;
                y += yLittle;
            }
        }
        
#ifdef GL_WIN_phong_shading
    if (modeFlags & __GL_SHADE_PHONG) 
        (*gc->procs.phong.InitLineParams) (gc, v0, v1, invDelta);
#endif //GL_WIN_phong_shading
    
        /* Save new fraction/dfraction */
        gc->line.options.plength = length;
        gc->line.options.pwidth = width;
        gc->line.options.fraction = fraction;
        gc->line.options.dfraction = dfraction;
        gc->line.options.xStart = x;
        gc->line.options.yStart = y;
        
        gc->polygon.shader.length = gc->line.options.numPixels;
        (*gc->procs.line.processLine)(gc);
        
        if (gc->line.options.axis == __GL_X_MAJOR) {
            y++;
            length += gc->line.options.dldy;
            width += gc->line.options.dddy;
        } else {
            x++;
            length += gc->line.options.dldx;
            width += gc->line.options.dddx;
        }
    }
    
    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        /* Update stipple.  Ugh. */
        int increase;
        int posInc;

        /* Shift stipple by 'increase' bits */
        increase = (GLint)__GL_FAST_CEILF(gc->line.options.realLength);
        
        posInc = increase / gc->state.line.stippleRepeat;
        
        gc->line.stipplePosition = (gc->line.stipplePosition + posInc) & 0xf;
        gc->line.repeat = (gc->line.repeat + increase) % gc->state.line.stippleRepeat;
    }
}

#ifdef NT
void FASTCALL __glNopLineBegin(__GLcontext *gc)
{
}

void FASTCALL __glNopLineEnd(__GLcontext *gc)
{
}
#endif // NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_phong.c ===
/******************************Module*Header*******************************\
* Module Name: so_phong.c
*
* Routines to draw primitives
*
* Created: 10-16-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <fixed.h>
#include <glmath.h>

#ifdef GL_WIN_phong_shading

#ifdef _X86_
#include <gli386.h>
#endif

#define __FASTEST

// Macros
#define DOT(m,a,b)      m = (a)->x*(b)->x + (a)->y*(b)->y + (a)->z*(b)->z
#define MAGN2(m,v)      DOT(m,v,v)

#if _X86_

#define SHADER  __GLcontext.polygon.shader

#define GET_HALF_AREA(gc, a, b, c)\
\
__asm{ mov     eax, a                                                                           };\
__asm{ mov     ecx, c                                                                           };\
__asm{ mov     ebx, b                                                                           };\
__asm{ mov     edx, gc                                                                          };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxAC                     */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyBC dxAC                */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxBC dyBC dxAC           */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyAC dxBC dyBC dxAC      */ };\
__asm{ fxch    ST(2)                                             /* dyBC dxBC dyAC dxAC      */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyBC)][edx]                                             };\
__asm{ fmul    ST, ST(3)                                         /* dxACdyBC dxBC dyAC dxAC  */ };\
__asm{ fxch    ST(2)                                             /* dyAC dxBC dxACdyBC dxAC  */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyAC)][edx]                                             };\
__asm{ fmul    ST, ST(1)                                         /* dxBCdyAC dxBC dxACdyBC dxAC */};\
__asm{ fxch    ST(1)                                             /* dxBC dxBCdyAC dxACdyBC dxAC */};\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxBC)][edx]              /* dxBCdyAC dxACdyBC dxAC   */ };\
__asm{ fsubp   ST(1), ST                                /* +1*/  /* area dxAC                */ };\
__asm{ fxch    ST(1)                                             /* dxAC area                */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxAC)][edx]              /* area                     */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.area)][edx]     /* +1*/  /* (empty)                  */ };

#define STORE_AREA_PARAMS   

#else

#define GET_HALF_AREA(gc, a, b, c)\
    /* Compute signed half-area of the triangle */                  \
    dxAC = a->window.x - c->window.x;                               \
    dxBC = b->window.x - c->window.x;                               \
    dyAC = a->window.y - c->window.y;                               \
    dyBC = b->window.y - c->window.y;                               \
    gc->polygon.shader.area = dxAC * dyBC - dxBC * dyAC;

#define STORE_AREA_PARAMS\
    gc->polygon.shader.dxAC = dxAC;                                 \
    gc->polygon.shader.dxBC = dxBC;                                 \
    gc->polygon.shader.dyAC = dyAC;                                 \
    gc->polygon.shader.dyBC = dyBC;    

#endif


#if 0
#define ACCUM_MAT_CHANGE(dst,src) \
    if ((src)->dirtyBits & __GL_MATERIAL_AMBIENT)                           \
        (dst).ambient = (src)->ambient;                                     \
    if ((src)->dirtyBits & __GL_MATERIAL_DIFFUSE)                           \
        (dst).diffuse = (src)->diffuse;                                     \
    if ((src)->dirtyBits & __GL_MATERIAL_SPECULAR)                          \
        (dst).specular = (src)->specular;                                   \
    if ((src)->dirtyBits & __GL_MATERIAL_EMISSIVE)                          \
        (dst).emissive = (src)->emissive;                                   \
    if ((src)->dirtyBits & __GL_MATERIAL_SHININESS)                         \
        (dst).shininess = (src)->shininess;                                 \
    if ((src)->dirtyBits & __GL_MATERIAL_COLORINDEXES)                      \
    {                                                                      \
        (dst).cmapa = (src)->cmapa;                                         \ 
        (dst).cmapd = (src)->cmapd;                                         \
        (dst).cmaps = (src)->cmaps;                                         \
    }                                                                      \
    (dst).dirtyBits |= (src)->dirtyBits;                                   
#endif

#define SORT_AND_CULL_FACE(a, b, c, face, ccw)\
                                                                            \
    /*                                                                      \
    ** Sort vertices in y.  Keep track if a reversal of the winding         \
    ** occurs in direction (0 means no reversal, 1 means reversal).         \
    ** Save old vertex pointers in case we end up not doing a fill.         \
    */                                                                      \
    reversed = 0;                                                           \
    if (__GL_VERTEX_COMPARE(a->window.y, <, b->window.y)) {                 \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            /* Already sorted */                                            \
        } else {                                                            \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=b; b=c; c=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=c; c=b; b=temp;                                   \
            }                                                               \
        }                                                                   \
    } else {                                                                \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=a; a=b; b=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=b; b=c; c=temp;                                   \
            }                                                               \
        } else {                                                            \
            temp=a; a=c; c=temp;                                            \
            reversed = 1;                                                   \
        }                                                                   \
    }                                                                       \
                                                                            \
    GET_HALF_AREA(gc, a, b, c);                                             \
    ccw = !__GL_FLOAT_LTZ(gc->polygon.shader.area);                         \
                                                                            \
    /*                                                                      \
    ** Figure out if face is culled or not.  The face check needs to be     \
    ** based on the vertex winding before sorting.  This code uses the      \
    ** reversed flag to invert the sense of ccw - an xor accomplishes       \
    ** this conversion without an if test.                                  \
    **                                                                      \
    **      ccw reversed        xor                                         \
    **      --- --------        ---                                         \
    **      0   0           0 (remain !ccw)                                 \
    **      1   0           1 (remain ccw)                                  \
    **      0   1           1 (become ccw)                                  \
    **      1   1           0 (become cw)                                   \
    */                                                                      \
    face = gc->polygon.face[ccw ^ reversed];                                \
    if (face == gc->polygon.cullFace) {                                     \
    /* Culled */                                                            \
    return;                                                                 \
    }                                                                       \
                                                                            \
    STORE_AREA_PARAMS;                                                      


//*************** Local functions *******************
void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft);
void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight);

void InitLineParamsVan (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                        __GLfloat invDelta);
void InitLineParamsAccel (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                         __GLfloat invDelta);

static void SetInitialPhongParameters(__GLcontext *gc, __GLvertex *a,
                                      __GLcoord *an, __GLcolor *ac, 
                                      __GLfloat aFog,
                                      __GLfloat dx, __GLfloat dy);

void FASTCALL FillPhongSubTriangle(__GLcontext *gc, GLint iyBottom, 
                                     GLint iyTop);

void InitSpanInterpolationAccel (__GLcontext *gc);
void InitSpanNEInterpolationVan (__GLcontext *gc);
void InitSpanNInterpolationVan (__GLcontext *gc);

void UpdateParamsAlongSpanAccel (__GLcontext *gc);                    
void UpdateNAlongSpanVan (__GLcontext *gc);
void UpdateNEAlongSpanVan (__GLcontext *gc);

void ComputeRGBColorVanZippy (__GLcontext *gc, __GLcolor *outColor); 
void ComputeRGBColorVanFast  (__GLcontext *gc, __GLcolor *outColor); 
void ComputeRGBColorVanSlow  (__GLcontext *gc, __GLcolor *outColor);

void ComputeRGBColorAccelZippy (__GLcontext *gc, __GLcolor *outColor);
void ComputeRGBColorAccelFast  (__GLcontext *gc, __GLcolor *outColor);
// Not implemented yet. This is to accelerate Slow Lights
void ComputeRGBColorAccelSlow  (__GLcontext *gc, __GLcolor *outColor);


// No Zippy versions for CI color
// since there is no Color material for CI
void ComputeCIColorVanFast (__GLcontext *gc, __GLcolor *outColor);   
void ComputeCIColorVanSlow  (__GLcontext *gc, __GLcolor *outColor);

void ComputeCIColorAccelFast (__GLcontext *gc, __GLcolor *outColor);

void ComputePhongInvarientRGBColor (__GLcontext *gc);              

void __glCalcForwardDifferences( GLint w, __GLfloat p0, __GLfloat p1,
                              __GLfloat p2, __GLfloat *d1, __GLfloat *d2 );
#ifdef GL_WIN_specular_fog
__GLfloat ComputeSpecValue (__GLcontext *gc, __GLvertex *vx);
#endif //GL_WIN_specular_fog

/********************* Code **************************************/
#ifdef GL_WIN_specular_fog
__GLfloat ComputeSpecValue (__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLmaterialMachine *msm;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
    __GLcoord n, e;
    __GLfloat fog = 0;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;

    zero = __glZero;

    n = vx->normal;
    e.x = vx->eyeX;
    e.y = vx->eyeY;
    e.z = vx->eyeZ;
    e.w = vx->eyeW;
    
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    msm = &gc->light.front;
    nxi = n.x;
    nyi = n.y;
    nzi = n.z;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;

    localViewer = gc->state.light.model.localViewer;

    eyeWIsZero = __GL_FLOAT_EQZ(vx->eyeW);
    
    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
            
        lss = lsm->state;
        lspmm = &lsm->front;
            
        if (lsm->slowPath || eyeWIsZero)
        {
            __GLcoord hHat, vPli, vPliHat, vPeHat;
            __GLfloat att, attSpot;
            __GLfloat hv[3];
                
            /* Compute unit h[i] */
            __glVecSub4(&vPli, &e, &lsm->position);
            __glNormalize(&vPliHat.x, &vPli.x);
            if (localViewer)
            {
                __glVecSub4(&vPeHat, &e, &Pe);
                __glNormalize(&vPeHat.x, &vPeHat.x);
                hv[0] = vPliHat.x + vPeHat.x;
                hv[1] = vPliHat.y + vPeHat.y;
                hv[2] = vPliHat.z + vPeHat.z;
            }
            else
            {
                hv[0] = vPliHat.x;
                hv[1] = vPliHat.y;
                hv[2] = vPliHat.z + __glOne;
            }
            __glNormalize(&hHat.x, hv);
                
            /* Compute attenuation */
            if (__GL_FLOAT_NEZ(lsm->position.w))
            {
                __GLfloat k0, k1, k2, dist;
                    
                k0 = lsm->constantAttenuation;
                k1 = lsm->linearAttenuation;
                k2 = lsm->quadraticAttenuation;
                if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                {
                    /* Use pre-computed 1/k0 */
                    att = lsm->attenuation;
                }
                else
                {
                    __GLfloat den;

                    dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                    den = k0 + k1 * dist + k2 * dist * dist;
                    att = __GL_FLOAT_EQZ(den) ? __glOne : __glOne / den;
                }
            }
            else
            {
                att = __glOne;
            }
                
            /* Compute spot effect if light is a spot light */
            attSpot = att;
            if (lsm->isSpot)
            {
                __GLfloat dot, px, py, pz;
                    
                px = -vPliHat.x;
                py = -vPliHat.y;
                pz = -vPliHat.z;
                dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                {
                    GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale 
                                       + __glHalf);
                    if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                        attSpot = att * lsm->spotTable[ix];
                }
                else
                {
                    attSpot = zero;
                }
            }
                
            /* Add in remaining effect of light, if any */
            if (attSpot)
            {
                __GLfloat n1, n2;
                __GLcolor sum;
                    
                n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
                        fog += n2;
                    }
                }
            }
        }
        else
        {
            __GLfloat n1, n2;
                
            /* Add in specular and diffuse effect of light, if any */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                 nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
            {
                n2= nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                n2 -= msm_threshold;
                if (__GL_FLOAT_GEZ(n2)) 
                {
                    __GLfloat fx = n2 * msm_scale + __glHalf;
                    if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                    else
                        n2 = __glOne;
                    fog += n2;
                }
            }
        }
    }
        
    fog = 1.0 - fog;
    if (__GL_FLOAT_LTZ (fog)) fog = __glZero;
    return fog;
}
#endif //GL_WIN_specular_fog

static void AccumMatChange (__GLmatChange *dst, __GLmatChange *src)
{
    if (src->dirtyBits & __GL_MATERIAL_AMBIENT)                          
        dst->ambient = src->ambient;                                     
 
   if (src->dirtyBits & __GL_MATERIAL_DIFFUSE)                 
        dst->diffuse = src->diffuse;                           
    if (src->dirtyBits & __GL_MATERIAL_SPECULAR)                
        dst->specular = src->specular;                         
    if (src->dirtyBits & __GL_MATERIAL_EMISSIVE)                
        dst->emissive = src->emissive;                         
    if (src->dirtyBits & __GL_MATERIAL_SHININESS)               
        dst->shininess = src->shininess;                       
    if (src->dirtyBits & __GL_MATERIAL_COLORINDEXES)            
    {                                                                     
        dst->cmapa = src->cmapa;                                       
        dst->cmapd = src->cmapd;                                       
        dst->cmaps = src->cmaps;                                       
    }                                                                     
    dst->dirtyBits |= src->dirtyBits;                                   
}

// Propagate the valid Normals through the vertex buffer.
//
// IN:  color, normal (front)
// OUT: color, normal (front) (all vertices are updated)

void FASTCALL PolyArrayPhongPropagateColorNormal(__GLcontext *gc, 
                                                 POLYARRAY *pa)
{
    POLYDATA *pd;
    POLYDATA *pdLast;
    GLuint paNeeds;
    GLboolean doFrontColor, doBackColor;
    POLYMATERIAL  *pm;
    __GLphongMaterialData *pmdata = NULL;
    
    
    paNeeds = gc->vertex.paNeeds;
    doFrontColor = paNeeds & PANEEDS_FRONT_COLOR;
    doBackColor  = paNeeds & PANEEDS_BACK_COLOR;

    if (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE)
        ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, 
                     "Eye coordinate should be available now\n");
    
    // If color is not needed, fill in the colors field 
    // with default.
    
    if (paNeeds & PANEEDS_SKIP_LIGHTING)
    {
        /////?????????!!!!!!!!!!! Look again!!!
        if (doFrontColor) (*gc->procs.paCalcColorSkip)(gc, pa, 0);
        if (doBackColor) (*gc->procs.paCalcColorSkip)(gc, pa, 1);
        return ;
    }


    pdLast = pa->pdNextVertex-1;

    // Check is there are any glMaterial calls that were made 
    // immediately after glBegin, the ones made after the first
    // glVertex call are ignored.

    if (pa->flags & (POLYARRAY_MATERIAL_BACK | POLYARRAY_MATERIAL_BACK))
    {
        pm = GLTEB_CLTPOLYMATERIAL();

        //DbgPrint ("Has the costly material change\n");
        pmdata = (__GLphongMaterialData *)
            GCALLOC(gc, sizeof(__GLphongMaterialData));
        if (pmdata == NULL)
        {
            return;
        }

        pmdata->flags = 0;
        pmdata->matChange[__GL_PHONG_FRONT_FIRST].dirtyBits = 0;
        pmdata->matChange[__GL_PHONG_BACK_FIRST].dirtyBits = 0;
        pmdata->matChange[__GL_PHONG_FRONT_TRAIL].dirtyBits = 0;
        pmdata->matChange[__GL_PHONG_BACK_TRAIL].dirtyBits = 0;

        if (pa->pd0->flags & POLYARRAY_MATERIAL_BACK)
        {
            AccumMatChange (&(pmdata->matChange[__GL_PHONG_BACK_FIRST]),
                            *(&pm->pdMaterial0[pa->pd0 - pa->pdBuffer0].front
                              +1));
            pmdata->flags |= __GL_PHONG_BACK_FIRST_VALID;
        }
        
        if (pa->pd0->flags & POLYARRAY_MATERIAL_FRONT)
        {
            AccumMatChange (&(pmdata->matChange[__GL_PHONG_FRONT_FIRST]),
                            *(&pm->pdMaterial0[pa->pd0 - pa->pdBuffer0].front));
            pmdata->flags |= __GL_PHONG_FRONT_FIRST_VALID;
        }

        // Accumulate the remaining material changes to be applied later
        for (pd = pa->pd0 + 1; pd <= pdLast; pd++)
        {
            if (pd->flags & POLYARRAY_MATERIAL_BACK)
            {
                AccumMatChange (&(pmdata->matChange[__GL_PHONG_BACK_TRAIL]),
                                *(&pm->pdMaterial0[pd - pa->pdBuffer0].front+1));
                pmdata->flags |= __GL_PHONG_BACK_TRAIL_VALID;
            }
            
            if (pd->flags & POLYARRAY_MATERIAL_FRONT)
            {
                AccumMatChange (&(pmdata->matChange[__GL_PHONG_FRONT_TRAIL]), 
                                *(&pm->pdMaterial0[pd - pa->pdBuffer0].front));
                pmdata->flags |= __GL_PHONG_FRONT_TRAIL_VALID;
            }
            
        }
        pa->phong = pmdata;
        pa->flags |= POLYARRAY_PHONG_DATA_VALID;
    }
    

    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE)
        {
            if (!(pd->flags & POLYDATA_COLOR_VALID))
            {
                // If color has not changed for this vertex, 
                // use the previously computed color.
                
                ASSERTOPENGL(pd != pa->pd0, "no initial color\n");
                if (gc->modes.colorIndexMode)
                {
                    pd->colors[0].r = (pd-1)->colors[0].r;
                }
                else
                {
                    pd->colors[0].r = (pd-1)->colors[0].r;
                    pd->colors[0].g = (pd-1)->colors[0].g;
                    pd->colors[0].b = (pd-1)->colors[0].b;
                    pd->colors[0].a = (pd-1)->colors[0].a;
                }
                pd->flags |= POLYDATA_COLOR_VALID;
            }
            else if (pa->flags & POLYARRAY_CLAMP_COLOR) 
            {
                if (gc->modes.colorIndexMode)
                {
                    __GL_CLAMP_CI(pd->colors[0].r, gc, pd->colors[0].r);
                }
                else
                {
                    __GL_CLAMP_R(pd->colors[0].r, gc, pd->colors[0].r);
                    __GL_CLAMP_G(pd->colors[0].g, gc, pd->colors[0].g);
                    __GL_CLAMP_B(pd->colors[0].b, gc, pd->colors[0].b);
                    __GL_CLAMP_A(pd->colors[0].a, gc, pd->colors[0].a);
                }
            }
        }
        
        if (!(pd->flags & POLYDATA_NORMAL_VALID))
        {
            // If the normal has not changed for this vertex, 
            // use the previously computed normal.
            ASSERTOPENGL(pd != pa->pd0, "no initial normal\n");
            pd->normal = (pd-1)->normal;
            pd->flags |= POLYDATA_NORMAL_VALID;
        }
        else
        {
            if (gc->vertex.paNeeds & PANEEDS_NORMAL) 
            {
                (*gc->mInv->xf3)(&pd->normal, &pd->normal.x, gc->mInv);
                if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
                    __glNormalize(&pd->normal.x, &pd->normal.x);
            }
        }
    } 

    gc->vertex.paNeeds &= ~PANEEDS_NORMAL;
    pa->flags &= ~POLYARRAY_MATERIAL_FRONT;
    pa->flags &= ~POLYARRAY_MATERIAL_BACK;
    pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

}


void FASTCALL 
__glRenderPhongTriangle(__GLcontext *gc, __GLvertex *a, 
                        __GLvertex *b, __GLvertex *c)
{
    GLuint needs, modeFlags;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *temp;
    
#ifdef NO_RENDERING
    return;
#endif
    
    //Assert that Lighting is on for Phong-shading to take place
    ASSERTOPENGL(gc->state.enables.general & __GL_LIGHTING_ENABLE,
                 "No lighting. Should be smooth-shaded\n");
    
    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    
    if (__GL_FLOAT_EQZ(gc->polygon.shader.area))
        return;
    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
    if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
    {
        gc->polygon.shader.phong.face = __GL_BACKFACE; 
    }
    else
    {
        gc->polygon.shader.phong.face = __GL_FRONTFACE; 
    }
    
    (*gc->procs.fillTriangle) (gc, a, b, c, (GLboolean) ccw);;
}




void FASTCALL 
__glFillPhongTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b, 
                      __GLvertex *c, GLboolean ccw)
{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLfloat aFog, bFog;
    __GLfloat dxAB, dyAB;
    __GLfloat dx, dy, dxdyLeft, dxdyRight;
    __GLcolor *ac, *bc;
    __GLcoord *an, *bn;
    __GLcoord ae, be, ce;
    GLint aIY, bIY, cIY;
    GLuint modeFlags;
    __GLfloat dxdyAC;
    __GLcoord dnAC, dnBC, *cn;
    __GLcoord deAC, deBC;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    GLuint flags = 0, msm_colorMaterialChange;
    GLboolean needColor;

    //CHOP_ROUND_ON();
    FPU_SAVE_MODE ();
    FPU_CHOP_ON ();
    
    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);

    modeFlags = gc->polygon.shader.modeFlags;

    if (gc->polygon.shader.phong.face == __GL_FRONTFACE)
        msm_colorMaterialChange = gc->light.front.colorMaterialChange;
    else
        msm_colorMaterialChange = gc->light.back.colorMaterialChange;

    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB)) 
    {
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;
        needColor = GL_TRUE;
    }
    
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //!!! Compute Invariant color if possible !!!!!!!!
    //!!!    Use Otto's optimizations here    !!!!!!!!
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(phong->flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    phong->flags |= flags;


    /* Fetch some stuff we are going to reuse */
    modeFlags = gc->polygon.shader.modeFlags;
    dxAC = gc->polygon.shader.dxAC;
    dxBC = gc->polygon.shader.dxBC;
    dyAC = gc->polygon.shader.dyAC;
    dyBC = gc->polygon.shader.dyBC;
    ac = a->color;
    bc = b->color;
    an = &(a->normal);
    bn = &(b->normal);
    ae.x = a->eyeX; ae.y = a->eyeY; ae.z = a->eyeZ; ae.w = a->eyeW;
    be.x = b->eyeX; be.y = b->eyeY; be.z = b->eyeZ; be.w = b->eyeW;
    
    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */

    __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    t1 = dyAC * oneOverArea;
    t2 = dyBC * oneOverArea;
    t3 = dxAC * oneOverArea;
    t4 = dxBC * oneOverArea;
    
    /* Normals */
    cn = &(c->normal);
    dnAC.x = an->x - cn->x;
    dnAC.y = an->y - cn->y;
    dnAC.z = an->z - cn->z;

    dnBC.x = bn->x - cn->x;
    dnBC.y = bn->y - cn->y;
    dnBC.z = bn->z - cn->z;

    gc->polygon.shader.phong.dndx.x = dnAC.x * t2 - dnBC.x * t1;
    gc->polygon.shader.phong.dndy.x = dnBC.x * t3 - dnAC.x * t4;
    gc->polygon.shader.phong.dndx.y = dnAC.y * t2 - dnBC.y * t1;
    gc->polygon.shader.phong.dndy.y = dnBC.y * t3 - dnAC.y * t4;
    gc->polygon.shader.phong.dndx.z = dnAC.z * t2 - dnBC.z * t1;
    gc->polygon.shader.phong.dndy.z = dnBC.z * t3 - dnAC.z * t4;

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        ce.x = c->eyeX; ce.y = c->eyeY; ce.z = c->eyeZ; ce.w = c->eyeW;

        deAC.x = ae.x - ce.x;
        deAC.y = ae.y - ce.y;
        deAC.z = ae.z - ce.z;
        deAC.w = ae.w - ce.w;

        deBC.x = be.x - ce.x;
        deBC.y = be.y - ce.y;
        deBC.z = be.z - ce.z;
        deBC.w = be.w - ce.w;

        gc->polygon.shader.phong.dedx.x = deAC.x * t2 - deBC.x * t1;
        gc->polygon.shader.phong.dedy.x = deBC.x * t3 - deAC.x * t4;
        gc->polygon.shader.phong.dedx.y = deAC.y * t2 - deBC.y * t1;
        gc->polygon.shader.phong.dedy.y = deBC.y * t3 - deAC.y * t4;
        gc->polygon.shader.phong.dedx.z = deAC.z * t2 - deBC.z * t1;
        gc->polygon.shader.phong.dedy.z = deBC.z * t3 - deAC.z * t4;
        gc->polygon.shader.phong.dedx.w = deAC.w * t2 - deBC.w * t1;
        gc->polygon.shader.phong.dedy.w = deBC.w * t3 - deAC.w * t4;
    }
    
    if (modeFlags & __GL_SHADE_RGB) 
    {
        __GLfloat drAC, dgAC, dbAC, daAC;
        __GLfloat drBC, dgBC, dbBC, daBC;
        __GLcolor *cc;
        
        /* Colors */
        if (needColor)
        {
            cc = c->color;
            drAC = ac->r - cc->r;
            drBC = bc->r - cc->r;
            dgAC = ac->g - cc->g;
            dgBC = bc->g - cc->g;
            dbAC = ac->b - cc->b;
            dbBC = bc->b - cc->b;
            daAC = ac->a - cc->a;
            daBC = bc->a - cc->a;
        
        
            gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
            gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
            gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
            gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
            gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
            gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;
            gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
            gc->polygon.shader.dady = daBC * t3 - daAC * t4;
        }

        if (modeFlags & __GL_SHADE_TEXTURE) 
        {
            __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
            __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;

            awinv = a->window.w;
            bwinv = b->window.w;
            cwinv = c->window.w;
            scwinv = c->texture.x * cwinv;
            tcwinv = c->texture.y * cwinv;
            qwcwinv = c->texture.w * cwinv;

            dsAC = a->texture.x * awinv - scwinv;
            dsBC = b->texture.x * bwinv - scwinv;
            dtAC = a->texture.y * awinv - tcwinv;
            dtBC = b->texture.y * bwinv - tcwinv;
            dqwAC = a->texture.w * awinv - qwcwinv;
            dqwBC = b->texture.w * bwinv - qwcwinv;

            gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
            gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;
            gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
            gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;
            gc->polygon.shader.dqwdx = dqwAC * t2 - dqwBC * t1;
            gc->polygon.shader.dqwdy = dqwBC * t3 - dqwAC * t4;
        }
    } 

    if (modeFlags & __GL_SHADE_DEPTH_ITER) 
    {
        __GLfloat dzAC, dzBC;

        dzAC = a->window.z - c->window.z;
        dzBC = b->window.z - c->window.z;
        
        gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
        gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
            gc->polygon.shader.dzdx = 
              FLT_TO_Z16_SCALE(gc->polygon.shader.dzdxf);
        }
        else {
            gc->polygon.shader.dzdx = FTOL(gc->polygon.shader.dzdxf);
        }
    }

#ifdef GL_WIN_specular_fog
    if (gc->polygon.shader.modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        /* Use eyeZ for interpolation value */
        aFog = a->eyeZ;
        bFog = b->eyeZ;
        cFog = c->eyeZ;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    } 
    else if (gc->polygon.shader.modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;
        
        aFog = bFog = cFog = 1.0f;
        
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            aFog = ComputeSpecValue (gc, a);
            bFog = ComputeSpecValue (gc, b);
            cFog = ComputeSpecValue (gc, c);
        }

        if (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)
        {
            aFog *= a->fog;
            bFog *= b->fog;
            cFog *= c->fog;
        }
        
        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
#else  //GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        /* Use eyeZ for interpolation value */
        aFog = a->eyeZ;
        bFog = b->eyeZ;
        cFog = c->eyeZ;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        /* Use fog for interpolation value */
        aFog = a->fog;
        bFog = b->fog;
        cFog = c->fog;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    } 
#endif //GL_WIN_specular_fog
    
    __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(dxAC, dyAC, dxdyAC);
    
    /* Snap each y coordinate to its pixel center */
    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

#ifdef __DBG_PRINT
    DbgPrint ("aIY=%d, bIY=%d, cIY=%d\n", aIY, bIY, cIY);
#endif
    
    /*
    ** This algorithim always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */
    dxAB = a->window.x - b->window.x;
    dyAB = a->window.y - b->window.y;
    if (ccw) {
        dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
        SnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);
        dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
        SetInitialPhongParameters(gc, a, an, ac, aFog, dx, dy);
        if (aIY != bIY) {
            dxdyRight = dxAB / dyAB;
            SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight,
                       dxdyRight);
#ifdef __DBG_PRINT
            DbgPrint ("dxdyRight = %f\n", dxdyRight);
#endif
            FillPhongSubTriangle(gc, aIY, bIY);
        }

        if (bIY != cIY) {
            dxdyRight = dxBC / dyBC;
            dy = (bIY + __glHalf) - b->window.y;
            SnapXRight(&gc->polygon.shader, b->window.x + dy*dxdyRight,
                       dxdyRight);
#ifdef __DBG_PRINT
            DbgPrint ("dxdyRight = %f\n", dxdyRight);
#endif
            FillPhongSubTriangle(gc, bIY, cIY);
        }
    } else {
        dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
        SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyAC, dxdyAC);
#ifdef __DBG_PRINT
        DbgPrint ("dxdyRight = %f\n", dxdyAC);
#endif
        if (aIY != bIY) {
            dxdyLeft = dxAB / dyAB;
            SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
            dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            SetInitialPhongParameters(gc, a, an, ac, aFog, dx, dy);
            FillPhongSubTriangle(gc, aIY, bIY);
        }

        if (bIY != cIY) {
            dxdyLeft = dxBC / dyBC;
            dy = (bIY + __glHalf) - b->window.y;
            SnapXLeft(gc, b->window.x + dy*dxdyLeft, dxdyLeft);
            dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            SetInitialPhongParameters(gc, b, bn, bc, bFog, dx, dy);
            FillPhongSubTriangle(gc, bIY, cIY);
        }
    }
    
    FPU_RESTORE_MODE();  // CHOP_ROUND_OFF();
}



static void SetInitialPhongParameters(__GLcontext *gc, __GLvertex *a,
                                      __GLcoord *an, __GLcolor *ac, 
                                      __GLfloat aFog, __GLfloat dx, 
                                      __GLfloat dy)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLshade *sh = &gc->polygon.shader;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    GLuint modeFlags = sh->modeFlags;
    GLboolean needColor = (gc->polygon.shader.phong.flags & 
                               __GL_PHONG_NEED_COLOR_XPOLATE);

#define bPolygonOffset \
        (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE )


     /* Set parameters for the shader */ 
    phong->nCur.x = an->x + dx*phong->dndx.x + dy*phong->dndy.x;
    phong->nCur.y = an->y + dx*phong->dndx.y + dy*phong->dndy.y;
    phong->nCur.z = an->z + dx*phong->dndx.z + dy*phong->dndy.z;

    phong->nLittle.x = phong->dndy.x + little * phong->dndx.x;
    phong->nLittle.y = phong->dndy.y + little * phong->dndx.y;
    phong->nLittle.z = phong->dndy.z + little * phong->dndx.z;

    if (big > little) 
    {
        phong->nBig.x = phong->nLittle.x + phong->dndx.x;
        phong->nBig.y = phong->nLittle.y + phong->dndx.y;
        phong->nBig.z = phong->nLittle.z + phong->dndx.z;
    }
    else
    {
        phong->nBig.x = phong->nLittle.x - phong->dndx.x;
        phong->nBig.y = phong->nLittle.y - phong->dndx.y;
        phong->nBig.z = phong->nLittle.z - phong->dndx.z;
    }

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        phong->eCur.x = a->eyeX + dx*phong->dedx.x + dy*phong->dedy.x;
        phong->eCur.y = a->eyeY + dx*phong->dedx.y + dy*phong->dedy.y;
        phong->eCur.z = a->eyeZ + dx*phong->dedx.z + dy*phong->dedy.z;
        phong->eCur.w = a->eyeW + dx*phong->dedx.w + dy*phong->dedy.w;

        phong->eLittle.x = phong->dedy.x + little * phong->dedx.x;
        phong->eLittle.y = phong->dedy.y + little * phong->dedx.y;
        phong->eLittle.z = phong->dedy.z + little * phong->dedx.z;
        phong->eLittle.w = phong->dedy.w + little * phong->dedx.w;

        if (big > little) 
        {
            phong->eBig.x = phong->eLittle.x + phong->dedx.x;
            phong->eBig.y = phong->eLittle.y + phong->dedx.y;
            phong->eBig.z = phong->eLittle.z + phong->dedx.z;
            phong->eBig.w = phong->eLittle.w + phong->dedx.w;
        }
        else
        {
            phong->eBig.x = phong->eLittle.x - phong->dedx.x;
            phong->eBig.y = phong->eLittle.y - phong->dedx.y;
            phong->eBig.z = phong->eLittle.z - phong->dedx.z;
            phong->eBig.w = phong->eLittle.w - phong->dedx.w;
        }
    }
        
    if (big > little) 
    {
        if (modeFlags & __GL_SHADE_RGB) 
        {
            if (needColor)
            {
                
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;

                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle + sh->drdx;
            
                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle + sh->dgdx;
            
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle + sh->dbdx;
                
                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle + sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) 
            {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                  + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle + sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                  + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle + sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                  + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle + sh->dqwdx;
            }
        } 

        if (modeFlags & __GL_SHADE_DEPTH_ITER) 
        {
            __GLfloat zLittle, zOffset;

            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if (gc->modes.depthBits == 16) 
            {
                sh->frag.z = (__GLzValue)
                FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                 + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle + sh->dzdxf);
            }
            else 
            {
                sh->frag.z = (__GLzValue)
                  FTOL(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf +
                       zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle + sh->dzdxf);
            }
        }

        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle + sh->dfdx;
        }
    } 
    else 
    {    
        if (modeFlags & __GL_SHADE_RGB) 
        {
            if (needColor)
            {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle - sh->drdx;

                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle - sh->dgdx;
                
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle - sh->dbdx;
                
                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle - sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) 
            {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                  + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle - sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                  + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle - sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                  + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle - sh->dqwdx;
            }
        } 

        if (modeFlags & __GL_SHADE_DEPTH_ITER) 
        {
            __GLfloat zLittle, zOffset;

            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if(( gc->modes.depthBits == 16 ) &&
               ( gc->depthBuffer.scale <= (GLuint)0xffff )) 
            {
                sh->frag.z = (__GLzValue)
                  FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                     + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle - sh->dzdxf);
            }
            else 
            {
                sh->frag.z = (__GLzValue)
                  FTOL( a->window.z + dx*sh->dzdxf + dy*sh->dzdyf+ zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle - sh->dzdxf);
            }
        }
        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle - sh->dfdx;
        }
    }
}


/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

static void FASTCALL FillPhongSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint dxLeftFrac, dxRightFrac;
    GLint dxLeftLittle, dxRightLittle;
    GLint dxLeftBig, dxRightBig;
    GLint spanWidth, clipY0, clipY1;
    GLuint modeFlags;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLboolean needColor = (phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE);
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;
    int iMaxWidth, iDy, dxLeft, dxRight;

    ixLeft = gc->polygon.shader.ixLeft;
    dxLeft = (gc->polygon.shader.dxLeftBig < gc->polygon.shader.dxLeftLittle) ?
             gc->polygon.shader.dxLeftBig : gc->polygon.shader.dxLeftLittle;
    ixRight = gc->polygon.shader.ixRight;
    dxRight = (gc->polygon.shader.dxRightBig > gc->polygon.shader.dxRightLittle) ?
              gc->polygon.shader.dxRightBig : gc->polygon.shader.dxRightLittle;
    iMaxWidth = ixRight - ixLeft;
    iDy = iyTop - iyBottom - 1;
    ixRight += dxRight * iDy;
    ixLeft += dxLeft * iDy;
    iMaxWidth = (iMaxWidth < (ixRight - ixLeft)) ? ixRight - ixLeft :
        iMaxWidth;
    
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (iMaxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
    
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, 
                                               iMaxWidth * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, 
                                                 iMaxWidth * sizeof(__GLcolor));
        if (NULL == vFbcolors) {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;
    dxLeftFrac = gc->polygon.shader.dxLeftFrac;
    dxLeftBig = gc->polygon.shader.dxLeftBig;
    dxLeftLittle = gc->polygon.shader.dxLeftLittle;
    dxRightFrac = gc->polygon.shader.dxRightFrac;
    dxRightBig = gc->polygon.shader.dxRightBig;
    dxRightLittle = gc->polygon.shader.dxRightLittle;
    modeFlags = gc->polygon.shader.modeFlags;

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    if (modeFlags & __GL_SHADE_STENCIL_TEST) {
        gc->polygon.shader.sbuf =
          __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
                            ixLeft, iyBottom);
    }
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
    if( gc->modes.depthBits == 32 )
        gc->polygon.shader.zbuf = (__GLzValue *)
             __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                ixLeft, iyBottom);
    else
        gc->polygon.shader.zbuf = (__GLzValue *)
            __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                ixLeft, iyBottom);
    }
    gc->polygon.shader.cfb = gc->drawBuffer;
    while (iyBottom < iyTop) 
    {
        spanWidth = ixRight - ixLeft;
        /*
        ** Only render spans that have non-zero width and which are
        ** not scissored out vertically.
        */
        if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) 
        {
            gc->polygon.shader.frag.x = ixLeft;
            gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.length = spanWidth;
            /* Initialize Parameters to interpolate */
            (*gc->procs.phong.InitSpanInterpolation) (gc);
            (*gc->procs.span.processSpan)(gc);
        }

        /* Advance right edge fixed point, adjusting for carry */
        ixRightFrac += dxRightFrac;
        if (ixRightFrac < 0) 
        {
            /* Carry/Borrow'd. Use large step */
            ixRight += dxRightBig;
            ixRightFrac &= ~0x80000000;
        } 
        else 
        {
            ixRight += dxRightLittle;
        }

        iyBottom++;
        ixLeftFrac += dxLeftFrac;

        if (ixLeftFrac < 0) 
        {
            /* Carry/Borrow'd.  Use large step */
            ixLeft += dxLeftBig;
            ixLeftFrac &= ~0x80000000;
            
            phong->nCur.x += phong->nBig.x;
            phong->nCur.y += phong->nBig.y;
            phong->nCur.z += phong->nBig.z;
            
            if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
            {
                phong->eCur.x += phong->eBig.x;
                phong->eCur.y += phong->eBig.y;
                phong->eCur.z += phong->eBig.z;
                phong->eCur.w += phong->eBig.w;
            }

            if (modeFlags & __GL_SHADE_RGB) 
            {
                if (needColor) 
                {
                    gc->polygon.shader.frag.color.r +=gc->polygon.shader.rBig;
                    gc->polygon.shader.frag.color.g +=gc->polygon.shader.gBig;
                    gc->polygon.shader.frag.color.b +=gc->polygon.shader.bBig;
                    gc->polygon.shader.frag.color.a +=gc->polygon.shader.aBig;
                }
                if (modeFlags & __GL_SHADE_TEXTURE) 
                {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sBig;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tBig;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwBig;
                }
            } 

            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                  ((GLubyte*) gc->polygon.shader.sbuf
                   + gc->polygon.shader.sbufBig);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
            }

            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                  ((GLubyte*) gc->polygon.shader.zbuf
                   + gc->polygon.shader.zbufBig);
            }

            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fBig;
            }
        } 
        else 
        {
            /* Use small step */
            ixLeft += dxLeftLittle;

            phong->nCur.x += phong->nLittle.x;
            phong->nCur.y += phong->nLittle.y;
            phong->nCur.z += phong->nLittle.z;
            
            if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
            {
                phong->eCur.x += phong->eLittle.x;
                phong->eCur.y += phong->eLittle.y;
                phong->eCur.z += phong->eLittle.z;
                phong->eCur.w += phong->eLittle.w;
            }

            if (modeFlags & __GL_SHADE_RGB) 
            {
                if (needColor) 
                {
                    gc->polygon.shader.frag.color.r += 
                                               gc->polygon.shader.rLittle;
                    gc->polygon.shader.frag.color.g += 
                                               gc->polygon.shader.gLittle;
                    gc->polygon.shader.frag.color.b += 
                                               gc->polygon.shader.bLittle;
                    gc->polygon.shader.frag.color.a += 
                                               gc->polygon.shader.aLittle;
                }
                
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sLittle;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tLittle;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwLittle;
                }
            } 

            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                  ((GLubyte*) gc->polygon.shader.sbuf
                   + gc->polygon.shader.sbufLittle);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
            }
            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                  ((GLubyte*) gc->polygon.shader.zbuf
                   + gc->polygon.shader.zbufLittle);
            }
            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fLittle;
            }
        }
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
#ifdef NT
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
}

static void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    GLint ixLeft, ixLeftFrac, lineBytes, elementSize, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(xLeft);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixLeftFrac = __GL_VERTEX_PROMOTED_FRACTION(xLeft) + 0x40000000;

#ifdef __DBG_PRINT
    DbgPrint ("dxdyLeft = %f\n", dxdyLeft);
#endif
    
    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);
    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;

    /* Compute big and little steps */
    iLittle = FTOL(dxdyLeft);
    gc->polygon.shader.dxLeftFrac = FLT_FRACTION(dxdyLeft - iLittle);
    if (dxdyLeft < 0) {
        iBig = iLittle - 1;
    } else {
        iBig = iLittle + 1;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_STENCIL_TEST) {
        /*
        ** Compute the big and little stencil buffer steps.  We walk the
        ** memory pointers for the stencil buffer along the edge of the
        ** triangle as we walk the edge.  This way we don't have to
        ** recompute the buffer address as we go.
        */
        elementSize = gc->stencilBuffer.buf.elementSize;
        lineBytes = elementSize * gc->stencilBuffer.buf.outerWidth;
        gc->polygon.shader.sbufLittle = lineBytes + iLittle * elementSize;
        gc->polygon.shader.sbufBig = lineBytes + iBig * elementSize;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        /*
        ** Compute the big and little depth buffer steps.  We walk the
        ** memory pointers for the depth buffer along the edge of the
        ** triangle as we walk the edge.  This way we don't have to
        ** recompute the buffer address as we go.
        */
        elementSize = gc->depthBuffer.buf.elementSize;
        lineBytes = elementSize * gc->depthBuffer.buf.outerWidth;
        gc->polygon.shader.zbufLittle = lineBytes + iLittle * elementSize;
        gc->polygon.shader.zbufBig = lineBytes + iBig * elementSize;
    }
    gc->polygon.shader.dxLeftLittle = iLittle;
    gc->polygon.shader.dxLeftBig = iBig;
}

static void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight)
{
    GLint ixRight, ixRightFrac, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixRight = __GL_VERTEX_FLOAT_TO_INT(xRight);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixRightFrac = __GL_VERTEX_PROMOTED_FRACTION(xRight) + 0x40000000;
    
    sh->ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);
    sh->ixRightFrac = ixRightFrac & ~0x80000000;
    
    /* Compute big and little steps */
    iLittle = FTOL(dxdyRight);
    sh->dxRightFrac = FLT_FRACTION(dxdyRight - iLittle);
    if (dxdyRight < 0) {
        iBig = iLittle - 1;
    } else {
        iBig = iLittle + 1;
    }
    sh->dxRightLittle = iLittle;
    sh->dxRightBig = iBig;
}


void InitLineParamsVan (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                        __GLfloat invDelta)
{
    __GLcoord *n0 = &(v0->normal);
    __GLcoord *n1 = &(v1->normal);
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLuint msm_colorMaterialChange, flags=0;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    msm_colorMaterialChange = gc->light.front.colorMaterialChange;
    phong->face = __GL_FRONTFACE;

    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB))
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;

    //Compute Invariant color if possible
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    gc->polygon.shader.phong.flags |= flags;

    phong->dndx.x = (n1->x - n0->x) * invDelta;
    phong->dndx.y = (n1->y - n0->y) * invDelta;
    phong->dndx.z = (n1->z - n0->z) * invDelta;

    phong->nTmp.x = n0->x;
    phong->nTmp.y = n0->y;
    phong->nTmp.z = n0->z;

    if (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        phong->dedx.x = (v1->eyeX - v0->eyeX) * invDelta;
        phong->dedx.y = (v1->eyeY - v0->eyeY) * invDelta;
        phong->dedx.z = (v1->eyeZ - v0->eyeZ) * invDelta;

        phong->eTmp.x = v0->eyeX;
        phong->eTmp.y = v0->eyeY;
        phong->eTmp.z = v0->eyeZ;
    }
}


void InitLineParamsAccel (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                        __GLfloat invDelta)
{
    __GLcoord normal;
    __GLcoord *n0 = &(v0->normal);
    __GLcoord *n1 = &normal;
    __GLcoord *n2 = &(v1->normal);
    __GLlightSourceMachine *lsm;
    GLuint msm_colorMaterialChange, flags = 0;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    GLint face = phong->face, curL, w;
    
    msm_colorMaterialChange = gc->light.front.colorMaterialChange;
    phong->face = __GL_FRONTFACE;
    w = gc->line.options.numPixels;
    
    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB))
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;

    //Compute Invariant color if possible
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    gc->polygon.shader.phong.flags |= flags;

    phong->dndx.x = (n2->x - n0->x) * invDelta;
    phong->dndx.y = (n2->y - n0->y) * invDelta;
    phong->dndx.x = (n2->z - n0->z) * invDelta;


    normal.x = (n0->x + n2->x)/2.0f;
    normal.y = (n0->y + n2->y)/2.0f;
    normal.z = (n0->z + n2->z)/2.0f;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&normal.x, &normal.x);
    
    for (lsm = gc->light.sources, curL = 0; lsm; 
         lsm = lsm->next, curL++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        GLfloat d0, d1, d2;

        /***** Diffuse *****/
        DOT (d0,n0,L);
        DOT (d1,n1,L);
        DOT (d2,n2,L);
            
        __glCalcForwardDifferences(w, d0, d1, d2, &pld->Ddel, &pld->Ddel2);
        pld->Dcurr = d0;

        /***** Specular ******/
        DOT (d0,n0,H);
        DOT (d1,n1,H);
        DOT (d2,n2,H);
            
        __glCalcForwardDifferences(w, d0, d1, d2, &pld->Sdel, &pld->Sdel2);
        pld->Scurr = d0;
    }

    phong->numLights = curL;
}


void InitSpanNEInterpolationVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp = phong->nCur;
    phong->eTmp = phong->eCur;
}


void InitSpanNInterpolationVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp = phong->nCur;
}

void InitSpanInterpolationAccel (__GLcontext *gc)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint face = phong->face;
    __GLlightSourceMachine *lsm;
    __GLcoord n0, n1, n2, dndx;
    __GLcoord *N0 = &n0;
    __GLcoord *N1 = &n1;
    __GLcoord *N2 = &n2;
    
    GLint curL, w, w2;
    
    w = gc->polygon.shader.length;
    w2 = w / 2;
    
    if (face == __GL_FRONTFACE)
    {
        //msm = &gc->light.front;
        n0.x = phong->nCur.x;
        n0.y = phong->nCur.y;
        n0.z = phong->nCur.z;

        dndx.x = phong->dndx.x;
        dndx.y = phong->dndx.y;
        dndx.z = phong->dndx.z;
    }
    else
    {
        //msm = &gc->light.back;
        n0.x = -phong->nCur.x;
        n0.y = -phong->nCur.y;
        n0.z = -phong->nCur.z;

        dndx.x = -phong->dndx.x;
        dndx.y = -phong->dndx.y;
        dndx.z = -phong->dndx.z;
    }
    
    if (w > 2)
    {
        n2.x = n0.x + w*dndx.x;
        n2.y = n0.y + w*dndx.y;
        n2.z = n0.z + w*dndx.z;
        
        n1.x = n0.x + w2*dndx.x;
        n1.y = n0.y + w2*dndx.y;
        n1.z = n0.z + w2*dndx.z;
    }
    
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
    {
        __glNormalize(&n0.x, &n0.x);
        if (w > 2)
        {
            __glNormalize(&n1.x, &n1.x);
            __glNormalize(&n2.x, &n2.x);
        }
    }
    
    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        GLfloat d0, d1, d2;
        
        if (w > 2)
        {
            /***** Diffuse *****/
            DOT (d0,N0,L);
            DOT (d1,N1,L);
            DOT (d2,N2,L);
            
            __glCalcForwardDifferences(w, d0, d1, d2, &pld->Ddel, 
                                    &pld->Ddel2);
            pld->Dcurr = d0;
            
            /***** Specular ******/
            DOT (d0, N0, H);
            DOT (d1, N1, H);
            DOT (d2, N2, H);
            
            __glCalcForwardDifferences(w, d0, d1, d2, &pld->Sdel, 
                                    &pld->Sdel2);
            pld->Scurr = d0;
        }
        else
        {
            /***** Diffuse *****/
            DOT (d0,(&n0),L);
            pld->Dcurr = d0;
            pld->Ddel = 0.0;
            pld->Ddel2 = 0.0;

            /***** Specular ******/
            DOT (d0,(&n0),H);
            pld->Scurr = d0;
            pld->Sdel = 0.0;
            pld->Sdel2 = 0.0;
        }
    }
    phong->numLights = curL;
}


void UpdateParamsAlongSpanAccel (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
  
    for (i=0; i<phong->numLights; i++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[i]);
        
        /* Diffuse */
        pld->Dcurr += pld->Ddel; 
        pld->Ddel += pld->Ddel2;

        /* Specular */
        pld->Scurr += pld->Sdel; 
        pld->Sdel += pld->Sdel2;
    }
}


void UpdateNAlongSpanVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp.x += phong->dndx.x;
    phong->nTmp.y += phong->dndx.y;
    phong->nTmp.z += phong->dndx.z;
}

void UpdateNEAlongSpanVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp.x += phong->dndx.x;
    phong->nTmp.y += phong->dndx.y;
    phong->nTmp.z += phong->dndx.z;

    phong->eTmp.x += phong->dedx.x;
    phong->eTmp.y += phong->dedx.y;
    phong->eTmp.z += phong->dedx.z;
    phong->eTmp.w += phong->dedx.w;
}


GLboolean FASTCALL __glPhongCISpan(__GLcontext *gc)
{
    __GLcolor *cp, outColor;
    __GLfloat r, drdx;
    __GLcoord dndx;
    GLint w;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLboolean needColor = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_COLOR_XPOLATE);

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
  
    if (needColor)
    {
        phong->tmpColor.r = gc->polygon.shader.frag.color.r;
        drdx = gc->polygon.shader.drdx;
    }
    
    while (--w >= 0) 
    {
        /* Compute color using appropriate parameters */
        (*gc->procs.phong.ComputeCIColor) (gc, &outColor);

        cp->r = outColor.r;

        /* Update parameters */
        (*gc->procs.phong.UpdateAlongSpan) (gc);
        
        if (needColor)
            phong->tmpColor.r += drdx;

        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glPhongRGBASpan (__GLcontext *gc)
{
    __GLcolor *cp, dcdx, outColor;
    __GLcoord dndx;
    GLint w;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLboolean needColor = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_COLOR_XPOLATE);

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;

    if (needColor)
    {
        phong->tmpColor = gc->polygon.shader.frag.color;
        dcdx.r = gc->polygon.shader.drdx;
        dcdx.g = gc->polygon.shader.dgdx;
        dcdx.b = gc->polygon.shader.dbdx;
        dcdx.a = gc->polygon.shader.dadx;
    }
    
    while (--w >= 0) 
    {
        /* Compute color using appropriate parameters */
        (*gc->procs.phong.ComputeRGBColor) (gc, &outColor);
        
        cp->r = outColor.r;
        cp->g = outColor.g;
        cp->b = outColor.b;
        cp->a = outColor.a;
        
        /* Update parameters */
        (*gc->procs.phong.UpdateAlongSpan) (gc);
        
        if (needColor)
        {
            phong->tmpColor.r += dcdx.r;
            phong->tmpColor.g += dcdx.g;
            phong->tmpColor.b += dcdx.b;
            phong->tmpColor.a += dcdx.a;
        }
        cp++;
    }
    return GL_FALSE;
}


/*******************************************************************
 * RGB, Use Normal,                   Fast-lights, no ColorMaterial*
 *******************************************************************/
void ComputeRGBColorVanZippy (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLcoord n;
    __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat rsi=0.0, gsi=0.0, bsi=0.0;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    ASSERTOPENGL (phong->flags & __GL_PHONG_INV_COLOR_VALID, 
                  "Zippy, invarient color should have been computed\n");
    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }

    rsi = phong->invColor.r;
    gsi = phong->invColor.g;
    bsi = phong->invColor.b;

    msm_alpha = msm->alpha;
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    
    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
        
        lspmm = &lsm->front + face;
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
          nzi * lsm->unitVPpli.z;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * 
                  lsm->hHat.z) - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                rsi += n2 * lspmm->specular.r;
                gsi += n2 * lspmm->specular.g;
                bsi += n2 * lspmm->specular.b;
            }
            rsi += n1 * lspmm->diffuse.r;
            gsi += n1 * lspmm->diffuse.g;
            bsi += n1 * lspmm->diffuse.b;
        }
    }
    __GL_CLAMP_R(outColor->r, gc, rsi);
    __GL_CLAMP_G(outColor->g, gc, gsi);
    __GL_CLAMP_B(outColor->b, gc, bsi);
    outColor->a = msm_alpha;
}


/*******************************************************************
 * RGB, Use Normal,                   Fast-lights, ColorMaterial   *
 *******************************************************************/
void ComputeRGBColorVanFast  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLcolor emissiveAmbientI;
    __GLcolor inColor;
    __GLcolor diffuseSpecularI;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint    msm_colorMaterialChange;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    __GLcoord n;
    
    zero = __glZero;


    // Optimization: If no colors have been interpolated
    // Use the Zippy function
    if (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE))
        ComputeRGBColorVanZippy  (gc, outColor);
    
    inColor = phong->tmpColor;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;
    msm_colorMaterialChange = msm->colorMaterialChange;

    // Save latest colors normalized to 0..1
    ri = inColor.r * gc->oneOverRedVertexScale;
    gi = inColor.g * gc->oneOverGreenVertexScale;
    bi = inColor.b * gc->oneOverBlueVertexScale;
    alpha = inColor.a;

    // Compute invarient emissive and ambient components for this vertex.
    if (phong->flags & __GL_PHONG_INV_COLOR_VALID)
    {
        emissiveAmbientI.r = phong->invColor.r;
        emissiveAmbientI.g = phong->invColor.g;
        emissiveAmbientI.b = phong->invColor.b;
    }
    else
    {
        lm_ambient.r = gc->state.light.model.ambient.r;
        lm_ambient.g = gc->state.light.model.ambient.g;
        lm_ambient.b = gc->state.light.model.ambient.b;

        baseEmissiveAmbient.r = msm->paSceneColor.r;
        baseEmissiveAmbient.g = msm->paSceneColor.g;
        baseEmissiveAmbient.b = msm->paSceneColor.b;
        
        if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
        {
            emissiveAmbientI.r = baseEmissiveAmbient.r
              + ri * lm_ambient.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g
              + gi * lm_ambient.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b
              + bi * lm_ambient.b;

            // Add per-light per-material ambient
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lss = lsm->state;
                emissiveAmbientI.r += ri * lss->ambient.r;
                emissiveAmbientI.g += gi * lss->ambient.g;
                emissiveAmbientI.b += bi * lss->ambient.b;
            }
        }
        else
        {
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lspmm = &lsm->front + face;
                baseEmissiveAmbient.r += lspmm->ambient.r;
                baseEmissiveAmbient.g += lspmm->ambient.g;
                baseEmissiveAmbient.b += lspmm->ambient.b;
            }
            emissiveAmbientI.r = baseEmissiveAmbient.r + inColor.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g + inColor.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b + inColor.b;
        }
    }

    // Compute the diffuse and specular components for this vertex.

    diffuseSpecularI.r = zero;
    diffuseSpecularI.g = zero;
    diffuseSpecularI.b = zero;

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;

        lss = lsm->state;
        lspmm = &lsm->front + face;

        /* Add in specular and diffuse effect of light, if any */
        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
          nzi * lsm->unitVPpli.z;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
            n2 -= msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                {
                    /* Recompute per-light per-material cached specular */
                    diffuseSpecularI.r += n2 * ri * lss->specular.r;
                    diffuseSpecularI.g += n2 * gi * lss->specular.g;
                    diffuseSpecularI.b += n2 * bi * lss->specular.b;
                }
                else
                {
                    diffuseSpecularI.r += n2 * lspmm->specular.r;
                    diffuseSpecularI.g += n2 * lspmm->specular.g;
                    diffuseSpecularI.b += n2 * lspmm->specular.b;
                }
            }

            if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
            {
                /* Recompute per-light per-material cached diffuse */
                diffuseSpecularI.r += n1 * ri * lss->diffuse.r;
                diffuseSpecularI.g += n1 * gi * lss->diffuse.g;
                diffuseSpecularI.b += n1 * bi * lss->diffuse.b;
            }
            else
            {
                diffuseSpecularI.r += n1 * lspmm->diffuse.r;
                diffuseSpecularI.g += n1 * lspmm->diffuse.g;
                diffuseSpecularI.b += n1 * lspmm->diffuse.b;
            }
        }
    }

    __GL_CLAMP_R(outColor->r, gc, emissiveAmbientI.r + diffuseSpecularI.r);
    __GL_CLAMP_G(outColor->g, gc, emissiveAmbientI.g + diffuseSpecularI.g);
    __GL_CLAMP_B(outColor->b, gc, emissiveAmbientI.b + diffuseSpecularI.b);

    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
    {
        __GL_CLAMP_A(outColor->a, gc, alpha);
    }
    else
        outColor->a = msm_alpha;
}


/*******************************************************************
 * RGB, Use Normal,                   Slow-lights, ColorMaterial   *
 *******************************************************************/
void ComputeRGBColorVanSlow  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLfloat rsi, gsi, bsi;
    __GLcolor sceneColorI;
    __GLmaterialMachine *msm;
    __GLcolor inColor;
     __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    __GLcolor msm_paSceneColor;
    GLuint    msm_colorMaterialChange;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
    __GLcoord n;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
 
    zero = __glZero;

    inColor = phong->tmpColor;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }
 
    lm_ambient.r = gc->state.light.model.ambient.r;
    lm_ambient.g = gc->state.light.model.ambient.g;
    lm_ambient.b = gc->state.light.model.ambient.b;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;
    msm_colorMaterialChange = msm->colorMaterialChange;
    msm_paSceneColor = msm->paSceneColor;

    localViewer = gc->state.light.model.localViewer;

    // Get invarient scene color if there is no ambient or emissive color 
    // material.

    sceneColorI.r = msm_paSceneColor.r;
    sceneColorI.g = msm_paSceneColor.g;
    sceneColorI.b = msm_paSceneColor.b;

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        // Save latest colors normalized to 0..1
            
        ri = inColor.r * gc->oneOverRedVertexScale;
        gi = inColor.g * gc->oneOverGreenVertexScale;
        bi = inColor.b * gc->oneOverBlueVertexScale;
        alpha = inColor.a;

        // Compute scene color.
        // If color has not changed, the previous sceneColorI values are 
        // used!

        if (msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                       __GL_MATERIAL_EMISSIVE))
        {
            if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
            {
                sceneColorI.r = msm_paSceneColor.r + ri * lm_ambient.r;
                sceneColorI.g = msm_paSceneColor.g + gi * lm_ambient.g;
                sceneColorI.b = msm_paSceneColor.b + bi * lm_ambient.b;
            }
            else
            {
                sceneColorI.r = msm_paSceneColor.r + inColor.r;
                sceneColorI.g = msm_paSceneColor.g + inColor.g;
                sceneColorI.b = msm_paSceneColor.b + inColor.b;
            }
        }
    }
        
    // Compute the diffuse and specular components for this vertex.
    rsi = sceneColorI.r;
    gsi = sceneColorI.g;
    bsi = sceneColorI.b;

    eyeWIsZero = __GL_FLOAT_EQZ(phong->eTmp.w);
    
    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
            
        lss = lsm->state;
        lspmm = &lsm->front + face;
            
        if (lsm->slowPath || eyeWIsZero)
        {
            __GLcoord hHat, vPli, vPliHat, vPeHat;
            __GLfloat att, attSpot;
            __GLfloat hv[3];
                
            /* Compute unit h[i] */
            __glVecSub4(&vPli, &phong->eTmp, &lsm->position);
            __glNormalize(&vPliHat.x, &vPli.x);
            if (localViewer)
            {
                __glVecSub4(&vPeHat, &phong->eTmp, &Pe);
                __glNormalize(&vPeHat.x, &vPeHat.x);
                hv[0] = vPliHat.x + vPeHat.x;
                hv[1] = vPliHat.y + vPeHat.y;
                hv[2] = vPliHat.z + vPeHat.z;
            }
            else
            {
                hv[0] = vPliHat.x;
                hv[1] = vPliHat.y;
                hv[2] = vPliHat.z + __glOne;
            }
            __glNormalize(&hHat.x, hv);
                
            /* Compute attenuation */
            if (__GL_FLOAT_NEZ(lsm->position.w))
            {
                __GLfloat k0, k1, k2, dist;
                    
                k0 = lsm->constantAttenuation;
                k1 = lsm->linearAttenuation;
                k2 = lsm->quadraticAttenuation;
                if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                {
                    /* Use pre-computed 1/k0 */
                    att = lsm->attenuation;
                }
                else
                {
                    __GLfloat den;

                    dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                    den = k0 + k1 * dist + k2 * dist * dist;
                    att = __GL_FLOAT_EQZ(den) ? __glOne : __glOne / den;
                }
            }
            else
            {
                att = __glOne;
            }
                
            /* Compute spot effect if light is a spot light */
            attSpot = att;
            if (lsm->isSpot)
            {
                __GLfloat dot, px, py, pz;
                    
                px = -vPliHat.x;
                py = -vPliHat.y;
                pz = -vPliHat.z;
                dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                {
                    GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale 
                                       + __glHalf);
                    if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                        attSpot = att * lsm->spotTable[ix];
                }
                else
                {
                    attSpot = zero;
                }
            }
                
            /* Add in remaining effect of light, if any */
            if (attSpot)
            {
                __GLfloat n1, n2;
                __GLcolor sum;
                    
                if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                {
                    sum.r = ri * lss->ambient.r;
                    sum.g = gi * lss->ambient.g;
                    sum.b = bi * lss->ambient.b;
                }
                else
                {
                    sum.r = lspmm->ambient.r;
                    sum.g = lspmm->ambient.g;
                    sum.b = lspmm->ambient.b;
                }
                    
                n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
                        if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                        {
                            /* Recompute per-light per-material cached specular */
                            sum.r += n2 * ri * lss->specular.r;
                            sum.g += n2 * gi * lss->specular.g;
                            sum.b += n2 * bi * lss->specular.b;
                        }
                        else
                        {
                            sum.r += n2 * lspmm->specular.r;
                            sum.g += n2 * lspmm->specular.g;
                            sum.b += n2 * lspmm->specular.b;
                        }
                    }
                    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                    {
                        /* Recompute per-light per-material cached diffuse */
                        sum.r += n1 * ri * lss->diffuse.r;
                        sum.g += n1 * gi * lss->diffuse.g;
                        sum.b += n1 * bi * lss->diffuse.b;
                    }
                    else
                    {
                        sum.r += n1 * lspmm->diffuse.r;
                        sum.g += n1 * lspmm->diffuse.g;
                        sum.b += n1 * lspmm->diffuse.b;
                    }
                }
                    
                rsi += attSpot * sum.r;
                gsi += attSpot * sum.g;
                bsi += attSpot * sum.b;
            }
        }
        else
        {
            __GLfloat n1, n2;
                
            if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
            {
                rsi += ri * lss->ambient.r;
                gsi += gi * lss->ambient.g;
                bsi += bi * lss->ambient.b;
            }
            else
            {
                rsi += lspmm->ambient.r;
                gsi += lspmm->ambient.g;
                bsi += lspmm->ambient.b;
            }
                
            /* Add in specular and diffuse effect of light, if any */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                 nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
            {
                n2= nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                n2 -= msm_threshold;
                if (__GL_FLOAT_GEZ(n2)) 
                {
                    __GLfloat fx = n2 * msm_scale + __glHalf;
                    if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                    else
                        n2 = __glOne;
                    if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                    {
                        /* Recompute per-light per-material cached specular */
                        rsi += n2 * ri * lss->specular.r;
                        gsi += n2 * gi * lss->specular.g;
                        bsi += n2 * bi * lss->specular.b;
                    }
                    else
                    {
                        rsi += n2 * lspmm->specular.r;
                        gsi += n2 * lspmm->specular.g;
                        bsi += n2 * lspmm->specular.b;
                    }
                }
                if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                {
                    /* Recompute per-light per-material cached diffuse */
                    rsi += n1 * ri * lss->diffuse.r;
                    gsi += n1 * gi * lss->diffuse.g;
                    bsi += n1 * bi * lss->diffuse.b;
                }
                else
                {
                    rsi += n1 * lspmm->diffuse.r;
                    gsi += n1 * lspmm->diffuse.g;
                    bsi += n1 * lspmm->diffuse.b;
                }
            }
        }
    }
        
    __GL_CLAMP_R(outColor->r, gc, rsi);
    __GL_CLAMP_G(outColor->g, gc, gsi);
    __GL_CLAMP_B(outColor->b, gc, bsi);
          
    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
    {
        __GL_CLAMP_A(outColor->a, gc, alpha);
    }
    else
        outColor->a = msm_alpha;
}

/*******************************************************************
 * RGB, Use Dot,                Fast-lights, no ColorMaterial      *
 *******************************************************************/
void ComputeRGBColorAccelZippy (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat rsi=0.0, gsi=0.0, bsi=0.0;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint curL;

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    ASSERTOPENGL (phong->flags & __GL_PHONG_INV_COLOR_VALID, 
                  "Zippy, invarient color should have been computed\n");
    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");

    rsi = phong->invColor.r;
    gsi = phong->invColor.g;
    bsi = phong->invColor.b;
    msm_alpha = msm->alpha;
   
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    
    for (lsm = gc->light.sources, curL = 0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat n1, n2, x, y, x2, y2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLfloat a, b, c, d, e, f, g, h, i;   
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = pld->Dcurr;
        lspmm = &lsm->front + face;
        if (__GL_FLOAT_GTZ(n1))
        {
#ifdef __FASTEST
            n2 = pld->Scurr - msm_threshold;
#endif //__FASTEST
#ifdef __SLOW
            x = phong->tmp_pos.x; x2 = x*x;
            y = phong->tmp_pos.y; y2 = y*y;

            a = pld->A[0]; b = pld->A[1];
            c = pld->A[2]; d = pld->A[3];
            e = pld->A[4]; f = pld->A[5];
            g = pld->A[6]; h = pld->A[7];
            i = pld->A[8];
        
            n2 = (a*x+b*y+c)/__GL_SQRTF(d*x2+e*x*y+f*y2+g*x+h*y+i);
#endif //__SLOW
#ifdef __FASTER
            x = phong->tmp_pos.x; x2 = x*x;
            y = phong->tmp_pos.y; y2 = y*y;

            n2 = pld->S[5]*x2 + pld->S[4]*x*y + pld->S[3]*y2 + pld->S[2]*x + 
              pld->S[1]*y + pld->S[0];
#endif //__FASTER
        
            //n2 -= msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                rsi += n2 * lspmm->specular.r;
                gsi += n2 * lspmm->specular.g;
                bsi += n2 * lspmm->specular.b;
                
            }
            rsi += n1 * lspmm->diffuse.r;
            gsi += n1 * lspmm->diffuse.g;
            bsi += n1 * lspmm->diffuse.b;
        }
    }
    __GL_CLAMP_R(outColor->r, gc, rsi);
    __GL_CLAMP_G(outColor->g, gc, gsi);
    __GL_CLAMP_B(outColor->b, gc, bsi);
    outColor->a = msm_alpha;
}


/*******************************************************************
 * RGB, Use Dot,                Fast-lights, ColorMaterial         *
 *******************************************************************/
void ComputeRGBColorAccelFast  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLcolor emissiveAmbientI;
    __GLcolor inColor;
    __GLcolor diffuseSpecularI;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint    msm_colorMaterialChange;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint curL;
    
    zero = __glZero;

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    msm_colorMaterialChange = msm->colorMaterialChange;

    ASSERTOPENGL (phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE, 
                  "Fast, need  color interpolation\n");
#if 0
    ASSERTOPENGL (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE), 
                  "Normalization should have been disabled\n");
#endif

    inColor = phong->tmpColor;
    
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;

    // Save latest colors normalized to 0..1
    ri = inColor.r * gc->oneOverRedVertexScale;
    gi = inColor.g * gc->oneOverGreenVertexScale;
    bi = inColor.b * gc->oneOverBlueVertexScale;
    alpha = inColor.a;

    // Compute invarient emissive and ambient components for this vertex.
    if (phong->flags & __GL_PHONG_INV_COLOR_VALID)
    {
        emissiveAmbientI.r = phong->invColor.r;
        emissiveAmbientI.g = phong->invColor.g;
        emissiveAmbientI.b = phong->invColor.b;
    }
    else
    {
        lm_ambient.r = gc->state.light.model.ambient.r;
        lm_ambient.g = gc->state.light.model.ambient.g;
        lm_ambient.b = gc->state.light.model.ambient.b;

        baseEmissiveAmbient.r = msm->paSceneColor.r;
        baseEmissiveAmbient.g = msm->paSceneColor.g;
        baseEmissiveAmbient.b = msm->paSceneColor.b;
        
        if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
        {
            emissiveAmbientI.r = baseEmissiveAmbient.r
              + ri * lm_ambient.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g
              + gi * lm_ambient.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b
              + bi * lm_ambient.b;

            // Add per-light per-material ambient
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lss = lsm->state;
                emissiveAmbientI.r += ri * lss->ambient.r;
                emissiveAmbientI.g += gi * lss->ambient.g;
                emissiveAmbientI.b += bi * lss->ambient.b;
            }
        }
        else
        {
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lspmm = &lsm->front + face;
                baseEmissiveAmbient.r += lspmm->ambient.r;
                baseEmissiveAmbient.g += lspmm->ambient.g;
                baseEmissiveAmbient.b += lspmm->ambient.b;
            }
            emissiveAmbientI.r = baseEmissiveAmbient.r + inColor.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g + inColor.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b + inColor.b;
        }
    }

    // Compute the diffuse and specular components for this vertex.
    diffuseSpecularI.r = zero;
    diffuseSpecularI.g = zero;
    diffuseSpecularI.b = zero;

    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat n1, n2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);

        lss = lsm->state;
        lspmm = &lsm->front + face;

        /* Add in specular and diffuse effect of light, if any */
        n1 = pld->Dcurr;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = pld->Scurr - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                {
                    /* Recompute per-light per-material cached specular */
                    diffuseSpecularI.r += n2 * ri * lss->specular.r;
                    diffuseSpecularI.g += n2 * gi * lss->specular.g;
                    diffuseSpecularI.b += n2 * bi * lss->specular.b;
                }
                else
                {
                    diffuseSpecularI.r += n2 * lspmm->specular.r;
                    diffuseSpecularI.g += n2 * lspmm->specular.g;
                    diffuseSpecularI.b += n2 * lspmm->specular.b;
                }
            }

            if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
            {
                /* Recompute per-light per-material cached diffuse */
                diffuseSpecularI.r += n1 * ri * lss->diffuse.r;
                diffuseSpecularI.g += n1 * gi * lss->diffuse.g;
                diffuseSpecularI.b += n1 * bi * lss->diffuse.b;
            }
            else
            {
                diffuseSpecularI.r += n1 * lspmm->diffuse.r;
                diffuseSpecularI.g += n1 * lspmm->diffuse.g;
                diffuseSpecularI.b += n1 * lspmm->diffuse.b;
            }
        }
    }

    __GL_CLAMP_R(outColor->r, gc, emissiveAmbientI.r + diffuseSpecularI.r);
    __GL_CLAMP_G(outColor->g, gc, emissiveAmbientI.g + diffuseSpecularI.g);
    __GL_CLAMP_B(outColor->b, gc, emissiveAmbientI.b + diffuseSpecularI.b);

    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
    {
        __GL_CLAMP_A(outColor->a, gc, alpha);
    }
    else
        outColor->a = msm_alpha;
}


/*******************************************************************
 * CI, Vanilla,                      Fast-lights                   *
 *******************************************************************/
void ComputeCIColorVanFast (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat zero;
    __GLcoord n;
    __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLmaterialState *ms;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat ci, si, di;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLfloat   redMaxF;
    GLint     redMaxI;

    zero = __glZero;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }
    
    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");
   
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;
    
    si = zero;
    di = zero;

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
        
        lspmm = &lsm->front + face;
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
          nzi * lsm->unitVPpli.z;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * 
                  lsm->hHat.z) - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                si += n2 * lsm->sli;
            }
            di += n1 * lsm->dli;
        }
    }

	/* Compute final color */
	if (si > __glOne)
	    si = __glOne;

	ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
	    + si * (ms_cmaps - ms_cmapa);

    // need to mask color index before color clipping
	if (ci > redMaxF) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) ci;
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	} 
    else if (ci < 0) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) __GL_FLOORF(ci);
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	}

    outColor->r = ci;
}


/*******************************************************************
 * CI, Vanilla,                      Slow-lights                   *
 *******************************************************************/
void ComputeCIColorVanSlow  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourceMachine *lsm;
    __GLmaterialState *ms;
    __GLmaterialMachine *msm;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat ci, si, di;
    GLfloat   redMaxF;
    GLint     redMaxI;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    __GLcoord n;


    zero = __glZero;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }
    
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    localViewer = gc->state.light.model.localViewer;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;


    si = zero;
    di = zero;

    eyeWIsZero = __GL_FLOAT_EQZ(phong->eTmp.w);

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        if (lsm->slowPath || eyeWIsZero)
        {
            __GLfloat n1, n2, att, attSpot;
            __GLcoord vPliHat, vPli, hHat, vPeHat;
            __GLfloat hv[3];

            /* Compute vPli, hi (normalized) */
            __glVecSub4(&vPli, &phong->eTmp, &lsm->position);
            __glNormalize(&vPliHat.x, &vPli.x);
            if (localViewer)
            {
                __glVecSub4(&vPeHat, &phong->eTmp, &Pe);
                __glNormalize(&vPeHat.x, &vPeHat.x);
                hv[0] = vPliHat.x + vPeHat.x;
                hv[1] = vPliHat.y + vPeHat.y;
                hv[2] = vPliHat.z + vPeHat.z;
            }
            else
            {
                hv[0] = vPliHat.x;
                hv[1] = vPliHat.y;
                hv[2] = vPliHat.z + __glOne;
            }
            __glNormalize(&hHat.x, hv);

            /* Compute attenuation */
            if (__GL_FLOAT_NEZ(lsm->position.w))
            {
                __GLfloat k0, k1, k2, dist;

                k0 = lsm->constantAttenuation;
                k1 = lsm->linearAttenuation;
                k2 = lsm->quadraticAttenuation;
                if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                {
                    /* Use pre-computed 1/k0 */
                    att = lsm->attenuation;
                }
                else
                {
                    __GLfloat den;

                    dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                    den = k0 + k1 * dist + k2 * dist * dist;
                    att = __GL_FLOAT_EQZ(den) ? __glOne : __glOne / den;
                }
            }
            else
            {
                att = __glOne;
            }

            /* Compute spot effect if light is a spot light */
            attSpot = att;
            if (lsm->isSpot)
            {
                __GLfloat dot, px, py, pz;

                px = -vPliHat.x;
                py = -vPliHat.y;
                pz = -vPliHat.z;
                dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                {
                    GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale 
                                       + __glHalf);
                    if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                        attSpot = att * lsm->spotTable[ix];
                }
                else
                {
                  attSpot = zero;
                }
            }

            /* Add in remaining effect of light, if any */
            if (attSpot)
            {
                n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                if (__GL_FLOAT_GTZ(n1)) 
                {
                    n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
                        si += attSpot * n2 * lsm->sli;
                    }
                    di += attSpot * n1 * lsm->dli;
                }
            }
        }
        else
        {
            __GLfloat n1, n2;

            /* Compute specular contribution */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                 nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
            {
                n2= nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                n2 -= msm_threshold;
                if (__GL_FLOAT_GEZ(n2))
                {
                    __GLfloat fx = n2 * msm_scale + __glHalf;
                    if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                    else
                        n2 = __glOne;
                    si += n2 * lsm->sli;
                }
                di += n1 * lsm->dli;
            }
        }
    }

    /* Compute final color */
    if (si > __glOne)
        si = __glOne;

    ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
        + si * (ms_cmaps - ms_cmapa);
    if (ci > ms_cmaps)
        ci = ms_cmaps;

    // need to mask color index before color clipping

    if (ci > redMaxF) 
    {
        GLfloat fraction;
        GLint integer;

        integer = (GLint) ci;
        fraction = ci - (GLfloat) integer;
        integer = integer & redMaxI;
        ci = (GLfloat) integer + fraction;
    } 
    else if (ci < 0) 
    {
        GLfloat fraction;
        GLint integer;

        integer = (GLint) __GL_FLOORF(ci);
        fraction = ci - (GLfloat) integer;
        integer = integer & redMaxI;
        ci = (GLfloat) integer + fraction;
    }
    outColor->r = ci;
}



/*******************************************************************
 * CI, Fast-lights, Fast-path                                      *
 *******************************************************************/
void ComputeCIColorAccelFast (__GLcontext *gc, __GLcolor *outColor)
{
    __GLfloat zero;
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLmaterialState *ms;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat ci, si, di;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLfloat   redMaxF;
    GLint     redMaxI;
    GLint curL;

    zero = __glZero;

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
    }
    

    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");
   
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;
    
    si = zero;
    di = zero;

    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat n1, n2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        
        lspmm = &lsm->front + face;
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = pld->Dcurr;
        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = pld->Scurr - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                si += n2 * lsm->sli;
            }
            di += n1 * lsm->dli;
        }
    }

	/* Compute final color */
	if (si > __glOne)
	    si = __glOne;

	ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
	    + si * (ms_cmaps - ms_cmapa);

    // need to mask color index before color clipping
	if (ci > redMaxF) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) ci;
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	} 
    else if (ci < 0) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) __GL_FLOORF(ci);
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	}

    outColor->r = ci;
}


void ComputePhongInvarientRGBColor (__GLcontext *gc)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha;
    __GLfloat rsi, gsi, bsi;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    // Compute invarient emissive and ambient components for this vertex.

    rsi = msm->paSceneColor.r;
    gsi = msm->paSceneColor.g;
    bsi = msm->paSceneColor.b;

    // add invarient per-light per-material cached ambient

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        lspmm = &lsm->front + face;
        rsi += lspmm->ambient.r;
        gsi += lspmm->ambient.g;
        bsi += lspmm->ambient.b;
    }
    phong->invColor.r = rsi;
    phong->invColor.g = gsi;
    phong->invColor.b = bsi;
}

void FASTCALL __glGenericPickPhongProcs(__GLcontext *gc)
{
    __GLlightSourceMachine *lsm;
    GLboolean anySlow = GL_FALSE;
    GLboolean colorMaterial = (gc->state.enables.general & 
                               __GL_COLOR_MATERIAL_ENABLE);
    GLboolean rgb_mode = (gc->polygon.shader.modeFlags & __GL_SHADE_RGB);
    GLboolean normalize = (gc->state.enables.general & __GL_NORMALIZE_ENABLE);
    GLboolean doVanilla = GL_FALSE;
    
    gc->polygon.shader.phong.flags = 0;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
        if (lsm->slowPath) {
            anySlow = GL_TRUE;
            // Assuming here that anySlow means need Eye XPolate
            gc->polygon.shader.phong.flags |= __GL_PHONG_NEED_EYE_XPOLATE;
            break;
        }
    }
    
    doVanilla = (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE)
                 || (anySlow)
                 || (gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE)
                 || (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)
        );
    
    
    if ((gc->state.hints.phong == GL_NICEST) || doVanilla)
    {
        gc->procs.phong.InitLineParams = InitLineParamsVan;
        
        if (anySlow)
        {
            gc->procs.phong.InitSpanInterpolation = InitSpanNEInterpolationVan;
            gc->procs.phong.UpdateAlongSpan = UpdateNEAlongSpanVan;
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorVanSlow;
            gc->procs.phong.ComputeCIColor = ComputeCIColorVanSlow;
        }
        else
        {
            gc->procs.phong.InitSpanInterpolation = InitSpanNInterpolationVan;
            gc->procs.phong.UpdateAlongSpan = UpdateNAlongSpanVan;
            gc->procs.phong.ComputeCIColor = ComputeCIColorVanFast;
            if (colorMaterial)
            {
                gc->procs.phong.ComputeRGBColor = ComputeRGBColorVanFast;
            }
            else
            {
                gc->procs.phong.ComputeRGBColor = ComputeRGBColorVanZippy;
            }
        }
    }
    else
    {
        ASSERTOPENGL (!anySlow, "Slow lights currently turned off\n");
        
        gc->procs.phong.InitSpanInterpolation = InitSpanInterpolationAccel;
        gc->procs.phong.UpdateAlongSpan = UpdateParamsAlongSpanAccel;
        gc->procs.phong.InitLineParams    = InitLineParamsAccel;
        gc->procs.phong.ComputeCIColor = ComputeCIColorAccelFast;
        
        if (colorMaterial)
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelFast;
        else
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelZippy;
        
    }
}

void __glCalcForwardDifferences( GLint w, __GLfloat p0, __GLfloat p1,
        __GLfloat p2, __GLfloat *d1, __GLfloat *d2 )
{
// Compute quadratic forward differences along a span of length w, from
// points p0, p1, p2
    __GLfloat dx;
    __GLfloat a0, a1, a2;

    if( w < 2 ) {
        *d1 = *d2 = 0.0f;
        return;
    }

    dx = 1.0f / w; // normalization factor

    // quadratic polynomial coefficients
    a0 = p0;
    a1 = ( -3.0f*p0 + 4.0f*p1 - p2) * dx;
    a2 = 2.0f * (p0 - 2.0f*p1 + p2) * dx * dx;

#ifdef __DEBUG_PRINT
    DbgPrint ("a2=%f, a1=%f, a0=%f\n", a2, a1, a0);
#endif
    // forward difference parameters
    *d1 = a1 + a2;
    *d2 = 2.0f * a2;
}



#ifdef __JUNKED_CODE
void InitSpanInterpolationFast (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    
    phong->tmp_pos.x = phong->cur_pos.x;
    phong->tmp_pos.y = phong->cur_pos.y;
    
    for (i=0; i<phong->numLights; i++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[i]);
        
        /* Diffuse */
        pld->D_tmp = pld->D_curr;
        pld->Ddel_tmp = pld->DdelSpan;

        /* Specular */
        pld->S_tmp = pld->S_curr;
        pld->Sdel_tmp = pld->SdelSpan;
    }
}


#ifdef __TWO
        ASSERTOPENGL (!anySlow, "Slow lights currently turned off\n");

        gc->procs.phong.InitInterpolation = InitializePhongInterpolationVan;
        gc->procs.phong.SetInitParams = SetInitialPhongInterpolationVan;
        gc->procs.phong.UpdateAlongEdge = UpdateParamsAlongEdgeVan;
        
        gc->procs.phong.InitSpanInterpolation = InitSpanInterpolationTWO;
        gc->procs.phong.UpdateAlongSpan = UpdateParamsAlongSpanFast;
        
        //Line related
        gc->procs.phong.InitLineParams    = InitLineParamsFast;

        if (colorMaterial)
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelFast;
        else
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelZippy;
#else
        gc->procs.phong.InitInterpolation = InitializePhongInterpolationFast;
        gc->procs.phong.SetInitParams     = SetInitialPhongInterpolationFast;
        gc->procs.phong.UpdateAlongEdge   = UpdateParamsAlongEdgeFast;
        gc->procs.phong.InitSpanInterpolation = InitSpanInterpolationFast;
        gc->procs.phong.UpdateAlongSpan   = UpdateParamsAlongSpanFast;
        gc->procs.phong.ComputeCIColor    = ComputeCIColorAccelFast;

        //Line related
        gc->procs.phong.InitLineParams    = InitLineParamsFast;

        if (colorMaterial)
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelFast;
        else
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelZippy;
#endif

void InitSpanInterpolationTWO (__GLcontext *gc)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint face = phong->face;
    __GLlightSourceMachine *lsm;
    //__GLmaterialMachine *msm;
    __GLcoord n, dndx;
    __GLcoord *A = &dndx;
    __GLcoord *C = &n;
    __GLfloat a, b, c, d, e, f, g, h, i;   
    GLint curL;
    

    if (face == __GL_FRONTFACE)
    {
        //msm = &gc->light.front;
        n.x = phong->nCur.x;
        n.y = phong->nCur.y;
        n.z = phong->nCur.z;

        dndx.x = phong->dndx.x;
        dndx.y = phong->dndx.y;
        dndx.z = phong->dndx.z;
    }
    else
    {
        //msm = &gc->light.back;
        n.x = -phong->nCur.x;
        n.y = -phong->nCur.y;
        n.z = -phong->nCur.z;

        dndx.x = -phong->dndx.x;
        dndx.y = -phong->dndx.y;
        dndx.z = -phong->dndx.z;
    }
    
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);
    
    MAGN2 (d,A);                  //d = A.A 
    DOT   (g,A,C); g *= 2.0;      //g = 2A.C
    MAGN2 (i,C);                  //i = C.C

    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat i2, iRt, tmp5, tmp2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        
        i2 = (i*i);
        iRt = __GL_SQRTF(i);

        /***** Diffuse *****/
        // Remaining Bishop parameters
        DOT (a,L,A);              //a = L.A/|L|
        DOT (c,L,C);              //c = L.C/|L|

        tmp2 = (2.0*a*i - c*g)/(2.0*i*iRt);
        tmp5 = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

        // Constant deltas
        pld->Ddel2Span = 2*tmp5;
        pld->Ddel_tmp = tmp2 + tmp5;
        pld->D_tmp = c/iRt;

        /***** Specular ******/
        // Remaining Bishop parameters
        DOT (a,H,A);              //a = H.A/|H|
        DOT (c,H,C);              //c = H.C/|H|

        // Polynomial coefficients
        tmp2 = (2.0*a*i - c*g)/(2.0*i*iRt);
        tmp5 = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

        // Constant deltas
        pld->Sdel2Span = 2*tmp5;
        pld->Sdel_tmp = tmp2 + tmp5;
        pld->S_tmp = c/iRt;
    }
    phong->numLights = curL;
}

void SetInitialPhongInterpolationVan (__GLcontext *gc, __GLvertex *a, 
                                       __GLcoord *an, __GLfloat dx, 
                                       __GLfloat dy)
{
    __GLshade *sh = &gc->polygon.shader;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;

    phong->nCur.x = an->x + dx*phong->dndx.x + dy*phong->dndy.x;
    phong->nCur.y = an->y + dx*phong->dndx.y + dy*phong->dndy.y;
    phong->nCur.z = an->z + dx*phong->dndx.z + dy*phong->dndy.z;

    phong->nLittle.x = phong->dndy.x + little * phong->dndx.x;
    phong->nLittle.y = phong->dndy.y + little * phong->dndx.y;
    phong->nLittle.z = phong->dndy.z + little * phong->dndx.z;

    if (big > little) 
    {
        phong->nBig.x = phong->nLittle.x + phong->dndx.x;
        phong->nBig.y = phong->nLittle.y + phong->dndx.y;
        phong->nBig.z = phong->nLittle.z + phong->dndx.z;
    }
    else
    {
        phong->nBig.x = phong->nLittle.x - phong->dndx.x;
        phong->nBig.y = phong->nLittle.y - phong->dndx.y;
        phong->nBig.z = phong->nLittle.z - phong->dndx.z;
    }

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        phong->eCur.x = a->eyeX + dx*phong->dedx.x + dy*phong->dedy.x;
        phong->eCur.y = a->eyeY + dx*phong->dedx.y + dy*phong->dedy.y;
        phong->eCur.z = a->eyeZ + dx*phong->dedx.z + dy*phong->dedy.z;
        phong->eCur.w = a->eyeW + dx*phong->dedx.w + dy*phong->dedy.w;

        phong->eLittle.x = phong->dedy.x + little * phong->dedx.x;
        phong->eLittle.y = phong->dedy.y + little * phong->dedx.y;
        phong->eLittle.z = phong->dedy.z + little * phong->dedx.z;
        phong->eLittle.w = phong->dedy.w + little * phong->dedx.w;

        if (big > little) 
        {
            phong->eBig.x = phong->eLittle.x + phong->dedx.x;
            phong->eBig.y = phong->eLittle.y + phong->dedx.y;
            phong->eBig.z = phong->eLittle.z + phong->dedx.z;
            phong->eBig.w = phong->eLittle.w + phong->dedx.w;
        }
        else
        {
            phong->eBig.x = phong->eLittle.x - phong->dedx.x;
            phong->eBig.y = phong->eLittle.y - phong->dedx.y;
            phong->eBig.z = phong->eLittle.z - phong->dedx.z;
            phong->eBig.w = phong->eLittle.w - phong->dedx.w;
        }
    }
}

/* Equivalent to SetInitialPhongParameters. Does for D and S */
void SetInitialPhongInterpolationFast (__GLcontext *gc, __GLvertex *a, 
                                       __GLcoord *an, __GLfloat dx, 
                                       __GLfloat dy)
{
    __GLshade *sh = &gc->polygon.shader;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat little2 = little*little;
    __GLfloat big = sh->dxLeftBig;
    __GLfloat big2 = big*big;
    __GLfloat dx2 = dx*dx;
    __GLfloat dy2 = dy*dy;
    __GLcoord pos;
    int i;
    GLfloat x, x2, y, y2;
    GLfloat aa, b, c, d, e, f, g, h, ii;

    phong->cur_pos.x += dx;
    phong->cur_pos.y += dy;
    pos = phong->cur_pos;
    x = phong->cur_pos.x; x2 = x*x;
    y = phong->cur_pos.y; y2 = y*y;
    
    for (i = 0; i<phong->numLights; i++)
    {
        __GLphongPerLightData *pld = &phong->perLight[i];
        __GLfloat tmp1, tmp2, tmp3;

        /**** Diffuse Parameters *****/
        pld->D_curr = pld->D[5]*x2 + pld->D[4]*x*y + pld->D[3]*y2 + 
                      pld->D[2]*x + pld->D[1]*y + pld->D[0];

        tmp1 = 2*pld->D[5]*x + pld->D[4]*y + pld->D[2];
        tmp2 = 2*pld->D[3]*y + pld->D[4]*x + pld->D[1];

        // Compute the along-edge del2 and del terms (Little)
        tmp3 = pld->D[5]*little2 + pld->D[4]*little + pld->D[3];
        pld->Ddel2EdgeLittle =  2*tmp3;
        pld->DdelEdgeLittle =  tmp1*little + tmp2 + tmp3;

        // Compute the along-edge del2 and del terms (Big)
        tmp3 =  pld->D[5]*big2 + pld->D[4]*big + pld->D[3];
        pld->Ddel2EdgeBig =  2*tmp3;
        pld->DdelEdgeBig =  tmp1*big + tmp2 + tmp3;

        // Compute the along-span del terms
        pld->DdelSpan = tmp1 + pld->D[5];
        pld->DdelSpanEdgeBig = pld->D[4] + 2*pld->D[5]*big;
        pld->DdelSpanEdgeLittle = pld->D[4] + 2*pld->D[5]*little;
        
        /**** Specular Parameters ****/
#ifndef __SLOW
        pld->S_curr = pld->S[5]*x2 + pld->S[4]*x*y + pld->S[3]*y2 + 
                      pld->S[2]*x + pld->S[1]*y + pld->S[0];
#else
        aa = pld->A[0]; b = pld->A[1];
        c = pld->A[2]; d = pld->A[3];
        e = pld->A[4]; f = pld->A[5];
        g = pld->A[6]; h = pld->A[7];
        ii = pld->A[8];
        
        pld->S_curr = (aa*x+b*y+c)/__GL_SQRTF(d*x2+e*x*y+f*y2+g*x+h*y+ii);

#endif

        tmp1 = 2*pld->S[5]*x + pld->S[4]*y + pld->S[2];
        tmp2 = 2*pld->S[3]*y + pld->S[4]*x + pld->S[1];

        // Compute the along-edge del2 and del terms (Little)
        tmp3 = pld->S[5]*little2 + pld->S[4]*little + pld->S[3];
        pld->Sdel2EdgeLittle =  2*tmp3;
        pld->SdelEdgeLittle =  tmp1*little + tmp2 + tmp3;

        // Compute the along-edge del2 and del terms (Big)
        tmp3 =  pld->S[5]*big2 + pld->S[4]*big + pld->S[3];
        pld->Sdel2EdgeBig =  2*tmp3;
        pld->SdelEdgeBig =  tmp1*big + tmp2 + tmp3;

        // Compute the along-span del terms
        pld->SdelSpan = tmp1 + pld->S[5];
        pld->SdelSpanEdgeBig = pld->S[4] + 2*pld->S[5]*big;
        pld->SdelSpanEdgeLittle = pld->S[4] + 2*pld->S[5]*little;
        
    }
}


/* Called when: Normalization Enabled, FastLights */
/******************************************************
 ****Set up the Polynomial for diffuse illumination****
 ******************************************************
 *                                                    *
 *                2              2                    *
 * SD (x,y) = D_5x + D_4xy + D_3y + D_2x + D_1y + D_0 *
 *                                                    *
 * D_i are expressed in terms of: a,b,c,d,e,f,g,h,i   *
 *                                                    *
 * D_0 = c/sqrt(i)                                    *
 * D_1 = (2bi - ch)/(2i*sqrt(i))                      *
 * D_2 = (2ai - cg)/(2i*sqrt(i))                      *
 * D_3 = (3ch^2 - 4cfi - 4bhi)/(4i^2*sqrt(i))         *
 * D_4 = (3cgh - 2ci - 2bgi - 2ahi)/(8i^2*sqrt(i))    *
 * D_5 = (3ig^2 - 4cdi - 4agi)/(4i^2*sqrt(i))         *
 ******************************************************/
void InitializePhongInterpolationFast (__GLcontext *gc, __GLvertex *v)
{
    GLboolean colorMaterial = (gc->state.enables.general & 
                               __GL_COLOR_MATERIAL_ENABLE);
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLmaterialMachine *msm;
    GLuint msm_colorMaterialChange;
    __GLfloat msm_alpha;
    __GLfloat rsi, gsi, bsi;
    __GLcoord normal;
    GLint curL;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLshade *sh = &gc->polygon.shader;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    __GLcoord *A = &(phong->dndx);
    __GLcoord *B = &(phong->dndy);
    __GLcoord *C;
    //From Bishop's paper
    __GLfloat a, b, c, d, e, f, g, h, i;   

#ifdef __CENTER
    normal.x = v->normal.x + (v->window.x - phong->center.x)*A->x 
                           + (v->window.y - phong->center.y)*B->x;
    normal.y = v->normal.y + (v->window.x - phong->center.x)*A->y
                           + (v->window.y - phong->center.y)*B->y;
    normal.z = v->normal.z + (v->window.x - phong->center.x)*A->z
                           + (v->window.y - phong->center.y)*B->z;
#else
    normal.x = v->normal.x;
    normal.y = v->normal.y;
    normal.z = v->normal.z;
#endif
    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
    }
    else
    {
        msm = &gc->light.back;
        normal.x = -normal.x;
        normal.y = -normal.y;
        normal.z = -normal.z;
    }
    
    C = &normal;
    //msm_colorMaterialChange = msm->colorMaterialChange;
#ifdef __DBG_PRINT
    DbgPrint ("A = (%f, %f, %f)\n", A->x, A->y, A->z);
    DbgPrint ("B = (%f, %f, %f)\n", B->x, B->y, B->z);
    DbgPrint ("C = (%f, %f, %f)\n", C->x, C->y, C->z);
#endif
    
    //***********Diffuse Bishop Parameters*****************************
    //a, b, c depend upon the light vector, so compute inside the loop
    //d, e, f, g, h, i depend only upon the incoming normal
    
    MAGN2 (d, A);                 //d = A.A 
    DOT   (e,A,B); e *= 2.0;      //e = 2A.B
    MAGN2 (f, B);                 //f = B.B
    DOT   (g,A,C); g *= 2.0;      //g = 2A.C
    DOT   (h,B,C); h *= 2.0;      //h = 2B.C
    MAGN2 (i,C);                  //i = C.C

    // Normalization not needed since 
    // it was done (if needed) during normal propagation.
    // Compute the per-light interpolation parameters 
    
    for (lsm = gc->light.sources, curL = 0; lsm; 
         lsm = lsm->next, curL++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        GLfloat i2, iRt;
        
        i2 = i*i;
        iRt = __GL_SQRTF(i);
        
        /***** Diffuse *****/
        // Remaining Bishop parameters
        DOT (a,L,A);              //a = L.A/|L|
        DOT (b,L,B);              //b = L.B/|L|
        DOT (c,L,C);              //c = L.C/|L|


        // Polynomial coefficients
        //DOT (pld->D[0], &normal, L);
        pld->D[0] = c/iRt;
        pld->D[1] = (2.0*b*i - c*h)/(2.0*i*iRt);
        pld->D[2] = (2.0*a*i - c*g)/(2.0*i*iRt);
        pld->D[3] = (3.0*c*h*h - 4.0*c*f*i - 4.0*b*h*i)/(8.0*i2*iRt);
        pld->D[4] = (3.0*c*g*h - 2.0*c*e*i - 2.0*b*g*i - 2.0*a*h*i)/
                    (4.0*i2*iRt);
        pld->D[5] = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

#ifdef __DBG_PRINT
        DbgPrint ("D[0]= %f, D[1]=%f, D[2]=%f, D[3]=%f, D[4]=%f, D[5]=%f\n",
                  pld->D[0], pld->D[1], pld->D[2], pld->D[3], pld->D[4], 
                  pld->D[5]);
#endif
        // Constant deltas
        pld->Ddel2Span = 2*pld->D[5];
        pld->D_curr = pld->D[0];
#ifdef __DBG_PRINT
        DbgPrint ("Ddel2Span= %f, D_curr=%f\n", pld->Ddel2Span, pld->D_curr);
#endif

        /***** Specular ******/
        // Remaining Bishop parameters
        DOT (a,H,A);              //a = H.A/|H|
        DOT (b,H,B);              //b = H.B/|H|
        DOT (c,H,C);              //c = H.C/|H|

        // Polynomial coefficients
        DOT (pld->S[0], &normal, H);
        pld->S[1] = (2.0*b*i - c*h)/(2.0*i*iRt);
        pld->S[2] = (2.0*a*i - c*g)/(2.0*i*iRt);
        pld->S[3] = (3.0*c*h*h - 4.0*c*f*i - 4.0*b*h*i)/(8.0*i2*iRt);
        pld->S[4] = (3.0*c*g*h - 2.0*c*e*i - 2.0*b*g*i - 2.0*a*h*i)/
                    (4.0*i2*iRt);
        pld->S[5] = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

        // Constant deltas
        pld->Sdel2Span = 2*pld->S[5];
        pld->S_curr = pld->S[0];

#ifdef __SLOW
        pld->A[0] = a; pld->A[1] = b;
        pld->A[2] = c; pld->A[3] = d;
        pld->A[4] = e; pld->A[5] = f;
        pld->A[6] = g; pld->A[7] = h;
        pld->A[8] = i; 
#endif        
#ifdef __DBG_PRINT
        DbgPrint ("L = (%f, %f, %f)\n", L->x, L->y, L->z);
        DbgPrint ("H = (%f, %f, %f)\n", H->x, H->y, H->z);
        DbgPrint ("a= %f, b=%f, c=%f, d=%f, e=%f, f=%f, g=%f, h=%f, i=%f\n",
                  a, b, c, d, e, f, g, h, i);
#endif
    }

    phong->numLights = curL;
#ifdef __CENTER
    phong->cur_pos.x = v->window.x - phong->center.x;
    phong->cur_pos.y = v->window.y - phong->center.y;
#else
    phong->cur_pos.x = 0.0;
    phong->cur_pos.y = 0.0;
#endif
}


void InitializePhongInterpolationSlow (__GLcontext *gc, __GLvertex *v)
{
}

/* Do nothing */
void InitializePhongInterpolationVan (__GLcontext *gc, __GLvertex *v)
{
    __GLphongShader *phong = &gc->polygon.shader.phong;

#ifdef __DBG_PRINT
    DbgPrint ("dndx = (%f, %f, %f)\n", phong->dndx.x, phong->dndx.y, 
                                       phong->dndx.z);
    DbgPrint ("dndy = (%f, %f, %f)\n", phong->dndy.x, phong->dndy.y, 
                                       phong->dndy.z);
    DbgPrint ("normal = (%f, %f, %f)\n", v->normal.x, v->normal.y, 
                                         v->normal.z);
#endif
}

void UpdateParamsAlongEdgeFast (__GLcontext *gc, __GLfloat dxLeft, 
                                GLboolean useBigStep)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    __GLphongPerLightData *pld;
    GLint i;

    if (useBigStep)
    {
        for (i=0; i<phong->numLights; i++)
        {
            pld = &(phong->perLight[i]);

            /** Diffuse Parameters **/
            pld->D_curr += pld->DdelEdgeBig;
            pld->DdelEdgeBig += pld->Ddel2EdgeBig;
            pld->DdelEdgeLittle += pld->Ddel2EdgeBig;
            pld->DdelSpan += pld->DdelSpanEdgeBig;

            /** Specular Parameters **/
            pld->S_curr += pld->SdelEdgeBig;
            pld->SdelEdgeBig += pld->Sdel2EdgeBig;
            pld->SdelEdgeLittle += pld->Sdel2EdgeBig;
            pld->SdelSpan += pld->SdelSpanEdgeBig;
        }
    }
    else //Use small step
    {
        for (i=0; i<phong->numLights; i++)
        {
            pld = &(phong->perLight[i]);

            /** Diffuse Parameters **/
            pld->D_curr += pld->DdelEdgeLittle;
            pld->DdelEdgeBig += pld->Ddel2EdgeLittle;
            pld->DdelEdgeLittle += pld->Ddel2EdgeLittle;
            pld->DdelSpan += pld->DdelSpanEdgeLittle;

            /** Specular Parameters **/
            pld->S_curr += pld->SdelEdgeLittle;
            pld->SdelEdgeBig += pld->Sdel2EdgeLittle;
            pld->SdelEdgeLittle += pld->Sdel2EdgeLittle;
            pld->SdelSpan += pld->SdelSpanEdgeLittle;
        }
    }

    phong->cur_pos.x += dxLeft;
    phong->cur_pos.y += 1.0;
}



void UpdateParamsAlongEdgeVan (__GLcontext *gc, __GLfloat dxLeft, 
                                GLboolean useBigStep)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    if (useBigStep)
    {
        phong->nCur.x += phong->nBig.x;
        phong->nCur.y += phong->nBig.y;
        phong->nCur.z += phong->nBig.z;
    }
    else
    {
        phong->nCur.x += phong->nLittle.x;
        phong->nCur.y += phong->nLittle.y;
        phong->nCur.z += phong->nLittle.z;
    }

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        if (useBigStep)
        {
            phong->eCur.x += phong->eBig.x;
            phong->eCur.y += phong->eBig.y;
            phong->eCur.z += phong->eBig.z;
            phong->eCur.w += phong->eBig.w;
        }
        else
        {
            phong->eCur.x += phong->eLittle.x;
            phong->eCur.y += phong->eLittle.y;
            phong->eCur.z += phong->eLittle.z;
            phong->eCur.w += phong->eLittle.w;
        }
    }
}


#endif //__JUNKED_CODE

#endif // GL_WIN_phong_shading
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_linec.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** The following is a discussion of the math used to do edge clipping against
** a clipping plane.
** 
**     P1 is an end point of the edge
**     P2 is the other end point of the edge
** 
**     Q = t*P1 + (1 - t)*P2
**     That is, Q lies somewhere on the line formed by P1 and P2.
** 
**     0 <= t <= 1
**     This constrains Q to lie between P1 and P2.
** 
**     C is the plane equation for the clipping plane
** 
**     D1 = P1 dot C
**     D1 is the distance between P1 and C.  If P1 lies on the plane
**     then D1 will be zero.  The sign of D1 will determine which side
**     of the plane that P1 is on, with negative being outside.
** 
**     D2 = P2 dot C
**     D2 is the distance between P2 and C.  If P2 lies on the plane
**     then D2 will be zero.  The sign of D2 will determine which side
**     of the plane that P2 is on, with negative being outside.
** 
** Because we are trying to find the intersection of the P1 P2 line
** segment with the clipping plane we require that:
** 
**     Q dot C = 0
** 
** Therefore
** 
**     (t*P1 + (1 - t)*P2) dot C = 0
** 
**     (t*P1 + P2 - t*P2) dot C = 0
** 
**     t*P1 dot C + P2 dot C - t*P2 dot C = 0
** 
** Substituting D1 and D2 in
** 
**     t*D1 + D2 - t*D2 = 0
** 
** Solving for t
** 
**     t = -D2 / (D1 - D2)
** 
**     t = D2 / (D2 - D1)
*/

/*
** Clip a line against the frustum clip planes and any user clipping planes.
** If an edge remains after clipping then compute the window coordinates
** and invoke the renderer.
**
** Notice:  This algorithim is an example of an implementation that is
** different than what the spec says.  This is equivalent in functionality
** and meets the spec, but doesn't clip in eye space.  This clipper clips
** in NTVP (clip) space.
**
** Trivial accept/reject has already been dealt with.
*/
#ifdef NT
void FASTCALL __glClipLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                           GLuint flags)
#else
void __glClipLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b)
#endif
{
#ifdef NT
    __GLvertex *provokingA = a;
    __GLvertex *provokingB = b;
#else
    __GLvertex *provoking = b;
#endif
    __GLvertex np1, np2;
    __GLcoord *plane;
    GLuint needs, allClipCodes, clipCodes;
    PFN_VERTEX_CLIP_PROC clip;
    __GLfloat zero;
    __GLfloat winx, winy;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    __GLfloat vpXScale, vpYScale, vpZScale;
    __GLviewport *vp;
    __GLfloat x, y, z, wInv;
    GLint i;

    // We have to turn rounding on.  Otherwise, the fast FP-comparison
    // routines below can fail:
    FPU_SAVE_MODE();
    FPU_ROUND_ON_PREC_HI();

    /* Check for trivial pass of the line */
    allClipCodes = a->clipCode | b->clipCode;

    /*
    ** For each clippling plane that something is out on, clip
    ** check the verticies.  Note that no bits will be set in
    ** allClipCodes for clip planes that are not enabled.
    */
    zero = __glZero;
    clip = gc->procs.lineClipParam;

    /* 
    ** Do user clip planes first, because we will maintain eye coordinates
    ** only while doing user clip planes.  They are ignored for the
    ** frustum clipping planes.
    */
    clipCodes = allClipCodes >> 6;
    if (clipCodes) {
	plane = &gc->state.transform.eyeClipPlanes[0];
	do {
	    /*
	    ** See if this clip plane has anything out of it.  If not,
	    ** press onward to check the next plane.  Note that we
	    ** shift this mask to the right at the bottom of the loop.
	    */
	    if (clipCodes & 1) {
		__GLfloat t, d1, d2;

		d1 = (plane->x * ((POLYDATA *)a)->eye.x) +
		     (plane->y * ((POLYDATA *)a)->eye.y) +
		     (plane->z * ((POLYDATA *)a)->eye.z) +
		     (plane->w * ((POLYDATA *)a)->eye.w);
		d2 = (plane->x * ((POLYDATA *)b)->eye.x) +
		     (plane->y * ((POLYDATA *)b)->eye.y) +
		     (plane->z * ((POLYDATA *)b)->eye.z) +
		     (plane->w * ((POLYDATA *)b)->eye.w);
		if (__GL_FLOAT_LTZ(d1)) {
		    /* a is out */
		    if (__GL_FLOAT_LTZ(d2)) {
			/* a & b are out */
                        FPU_RESTORE_MODE();
			return;
		    }

		    /*
		    ** A is out and B is in.  Compute new A coordinate
		    ** clipped to the plane.
		    */
		    t = d2 / (d2 - d1);
		    (*clip)(&np1, a, b, t);
		    ((POLYDATA *)&np1)->eye.x =
			t*(((POLYDATA *)a)->eye.x - ((POLYDATA *)b)->eye.x) +
			((POLYDATA *)b)->eye.x;
		    ((POLYDATA *)&np1)->eye.y =
			t*(((POLYDATA *)a)->eye.y - ((POLYDATA *)b)->eye.y) +
			((POLYDATA *)b)->eye.y;
		    ((POLYDATA *)&np1)->eye.z =
			t*(((POLYDATA *)a)->eye.z - ((POLYDATA *)b)->eye.z) +
			((POLYDATA *)b)->eye.z;
		    ((POLYDATA *)&np1)->eye.w =
			t*(((POLYDATA *)a)->eye.w - ((POLYDATA *)b)->eye.w) +
			((POLYDATA *)b)->eye.w;
		    a = &np1;
		    a->has = b->has;
		    ASSERTOPENGL(!(a->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		} else {
		    /* a is in */
		    if (__GL_FLOAT_LTZ(d2)) {
			/*
			** A is in and B is out.  Compute new B
			** coordinate clipped to the plane.
			**
			** NOTE: To avoid cracking in polygons with
			** shared clipped edges we always compute "t"
			** from the out vertex to the in vertex.  The
			** above clipping code gets this for free (b is
			** in and a is out).  In this code b is out and a
			** is in, so we reverse the t computation and the
			** argument order to (*clip).
			*/
			t = d1 / (d1 - d2);
			(*clip)(&np2, b, a, t);
			((POLYDATA *)&np2)->eye.x =
			    t*(((POLYDATA *)b)->eye.x - ((POLYDATA *)a)->eye.x)+
			    ((POLYDATA *)a)->eye.x;
			((POLYDATA *)&np2)->eye.y =
			    t*(((POLYDATA *)b)->eye.y - ((POLYDATA *)a)->eye.y)+
			    ((POLYDATA *)a)->eye.y;
			((POLYDATA *)&np2)->eye.z =
			    t*(((POLYDATA *)b)->eye.z - ((POLYDATA *)a)->eye.z)+
			    ((POLYDATA *)a)->eye.z;
			((POLYDATA *)&np2)->eye.w =
			    t*(((POLYDATA *)b)->eye.w - ((POLYDATA *)a)->eye.w)+
			    ((POLYDATA *)a)->eye.w;
			b = &np2;
			b->has = a->has;
			ASSERTOPENGL(!(b->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		    } else {
			/* A and B are in */
		    }
		}
	    }
	    plane++;
	    clipCodes >>= 1;
	} while (clipCodes);
    }

    allClipCodes &= __GL_FRUSTUM_CLIP_MASK;
    if (allClipCodes) {
	i = 0;
	do {
	    /*
	    ** See if this clip plane has anything out of it.  If not,
	    ** press onward to check the next plane.  Note that we
	    ** shift this mask to the right at the bottom of the loop.
	    */
	    if (allClipCodes & 1) {
		__GLfloat t, d1, d2;

                if (i & 1)
                {
                    d1 = a->clip.w -
                        *(__GLfloat *)((GLubyte *)a + __glFrustumOffsets[i]);
                    d2 = b->clip.w -
                        *(__GLfloat *)((GLubyte *)b + __glFrustumOffsets[i]);
                }
                else
                {
                    d1 = *(__GLfloat *)((GLubyte *)a + __glFrustumOffsets[i]) +
                        a->clip.w;
                    d2 = *(__GLfloat *)((GLubyte *)b + __glFrustumOffsets[i]) +
                        b->clip.w;
                }

		if (__GL_FLOAT_LTZ(d1)) {
		    /* a is out */
		    if (__GL_FLOAT_LTZ(d2)) {
			/* a & b are out */
                        FPU_RESTORE_MODE();
			return;
		    }

		    /*
		    ** A is out and B is in.  Compute new A coordinate
		    ** clipped to the plane.
		    */
		    t = d2 / (d2 - d1);
		    (*clip)(&np1, a, b, t);
		    a = &np1;
		    a->has = b->has;
		    ASSERTOPENGL(!(a->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		} else {
		    /* a is in */
		    if (__GL_FLOAT_LTZ(d2)) {
			/*
			** A is in and B is out.  Compute new B
			** coordinate clipped to the plane.
			**
			** NOTE: To avoid cracking in polygons with
			** shared clipped edges we always compute "t"
			** from the out vertex to the in vertex.  The
			** above clipping code gets this for free (b is
			** in and a is out).  In this code b is out and a
			** is in, so we reverse the t computation and the
			** argument order to (*clip).
			*/
			t = d1 / (d1 - d2);
			(*clip)(&np2, b, a, t);
			b = &np2;
			b->has = a->has;
			ASSERTOPENGL(!(b->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		    } else {
			/* A and B are in */
		    }
		}
	    }
            i++;
	    allClipCodes >>= 1;
	} while (allClipCodes);
    }

    vp = &gc->state.viewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;

    /* Compute window coordinates for vertices generated by clipping */
    if (provokingA->clipCode != 0)
    {
        wInv = __glOne / a->clip.w;
        x = a->clip.x; 
        y = a->clip.y; 
        z = a->clip.z;
        winx = x * vpXScale * wInv + vpXCenter;
        winy = y * vpYScale * wInv + vpYCenter;

        if (winx < gc->transform.fminx)
            winx = gc->transform.fminx;
        else if (winx >= gc->transform.fmaxx)
            winx = gc->transform.fmaxx - gc->constants.viewportEpsilon;

        if (winy < gc->transform.fminy)
            winy = gc->transform.fminy;
        else if (winy >= gc->transform.fmaxy)
            winy = gc->transform.fmaxy - gc->constants.viewportEpsilon;

        a->window.z = z * vpZScale * wInv + vpZCenter;
        a->window.w = wInv;
        a->window.x = winx;
        a->window.y = winy;

        // Update color pointer since this vertex is a new one
        // generated by clipping
        if (gc->state.light.shadingModel == GL_FLAT)
        {
            a->color = &provokingA->colors[__GL_FRONTFACE];
        }
        else
        {
            a->color = &a->colors[__GL_FRONTFACE];
        }
    }

    if (provokingB->clipCode != 0)
    {
        wInv = __glOne / b->clip.w;
        x = b->clip.x; 
        y = b->clip.y; 
        z = b->clip.z;
        winx = x * vpXScale * wInv + vpXCenter;
        winy = y * vpYScale * wInv + vpYCenter;

        if (winx < gc->transform.fminx)
            winx = gc->transform.fminx;
        else if (winx >= gc->transform.fmaxx)
            winx = gc->transform.fmaxx - gc->constants.viewportEpsilon;

        if (winy < gc->transform.fminy)
            winy = gc->transform.fminy;
        else if (winy >= gc->transform.fmaxy)
            winy = gc->transform.fmaxy - gc->constants.viewportEpsilon;

        b->window.z = z * vpZScale * wInv + vpZCenter;
        b->window.w = wInv;
        b->window.x = winx;
        b->window.y = winy;
        
        if (gc->state.light.shadingModel == GL_FLAT)
        {
            b->color = &provokingB->colors[__GL_FRONTFACE];
        }
        else
        {
            b->color = &b->colors[__GL_FRONTFACE];
        }
    }

    // Restore the floating-point mode for rendering:
    FPU_RESTORE_MODE();

    /* Validate line state */
    if (gc->state.light.shadingModel == GL_FLAT) {
	// Add the vertices then restore the b color pointer
        //
        // Note that although b is the only new vertex, up
        // to two vertices can be added because each new vertex
        // generated by clipping must be added.  For a line where
        // both endpoints are out of the clipping region, both
        // an entry and an exit vertex must be added
        if (provokingA->clipCode != 0)
        {
            // a was out so a new vertex was added at the point of
            // entry
            flags |= __GL_LVERT_FIRST;
        }
        // b is always added since either:
        // b was in and is new so it needs to be added
        // b was out so a new vertex was added at the exit point
        (*gc->procs.renderLine)(gc, a, b, flags);
        
#ifndef NT
	b->color = &b->colors[__GL_FRONTFACE];
#endif
    } else {
        if (provokingA->clipCode != 0)
        {
            flags |= __GL_LVERT_FIRST;
        }
        (*gc->procs.renderLine)(gc, a, b, flags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_names.c ===
/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list table management routines.
**
** $Revision: 1.3 $
** $Date: 1995/02/11 00:53:45 $
*/

#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include "..\..\dlist\dlistint.h"

/************************************************************************/
/*
** The Name Space Management code is used to store and retreive named
** data structures.  The data being stored is referred to with void
** pointers to allow for the storage of any type of structure.
**
** Note that this code was developed for dlist name management.
** The bulk of it remains the same, but the semaphores for locking
** dlist access have been moved up one level.  The code that uses
** this module for name space management must enclose the calls
** to Names entry points with LOCK and UNLOCK statements.
*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*
** Internal data structures.  Not intended for consumption outside of
** this module.
*/
/*----------------------------------------------------------------------*/

/*
** The name space is implemented as a 2-3 tree.
** The depth of the tree is the same for
** the entire tree (so we always know once we reach that depth that the
** node found is a leaf).
**
** A 2-3 tree in a nutshell goes like this:
**
** Every node at the maximum depth is a leaf, all other nodes are branch
**   nodes and have 2 or 3 children.
**
** A new node can be inserted in O(depth) time and an old node can be deleted
**   in O(depth) time.  During this insertion or deletion, the tree is
**   automatically rebalanced.
**
**
** Hmmm.  Derrick Burns mentions splay trees.  They would probably work
** as well if not better, and might be easier to code.  Maybe later -- little
** point in re-writing working code.
**
** Leaf nodes are arrays of sequential display lists.  The typical tree will
** actually only be one node (since users will define a few sequential
** lists, all of which fit into one leaf node).
**
** The range of display lists stored in a leaf is indicated by "start" and
** "end" (inclusive).
**
** There are two varieties of leaves.  There are leaves which contain unused
** (but reserved) display lists.  They are unique in that "lists" will be
** NULL.  The other type of leaf contains display lists currently in use.
** "lists" will not be NULL for these leaves, and will point to an array
** containing the actual display lists.
**
** Leaves containing unused (but reserved) display lists are generated when
** the user calls glGenLists().
**
** As the user starts using these reserved lists, the leaf containing unused
** (reserved) lists is split into two (or sometimes three) leaves.  One of
** the leaves will contain the display list the user is currently using, and
** the other will contain the rest of the still unused display lists.
**
** When this split takes place, the new leaf (containing the "now used" display
** lists) will be sized to __GL_DLIST_MIN_ARRAY_BLOCK entries if possible
** (with one of the array entries being the new display list, and the other
** entries pointing to a NOP dummy display list).  As the user continues
** to define more and more display lists, the leaf containing a range
** of used display lists will continue to grow until it reaches a
** size of __GL_DLIST_MAX_ARRAY_BLOCK entries, at which point a new
** leaf will be created to hold additional lists.
*/

/*
** A leaf node.
** The data pointers are void so diffent types of data structures can
** be managed.  The dataInfo pointer points back to information needed
** to manage the specific data structure pointed to by a void pointer.
*/
struct __GLnamesLeafRec {
    __GLnamesBranch *parent;    /* parent node - must be first */
    GLuint start;               /* start of range */
    GLuint end;                 /* end of range */
    void **dataList;            /* array of ptrs to named data */
    __GLnamesArrayTypeInfo *dataInfo;   /* ptr to data type info */
};

/*
** A branch node.
** The section of the tree in children[0] has name values all <= low.
** The section in children[1] has values: low < value <= medium.
** The section in children[2] (if not NULL) has values > medium.
*/
struct __GLnamesBranchRec {
    __GLnamesBranch *parent;            /* parent node - must be first */
    GLuint low;                         /* children[0] all <= low */
    GLuint medium;                      /* children[1] all <= medium & > low */
    __GLnamesBranch *children[3];       /* children[2] all > medium */
};

/*----------------------------------------------------------------------*/
/*
** Name Space Manager internal routines.
*/
/*----------------------------------------------------------------------*/

/*
** Sets up a new names tree and returns a pointer to it.
*/
__GLnamesArray * FASTCALL __glNamesNewArray(__GLcontext *gc, __GLnamesArrayTypeInfo *dataInfo)
{
    __GLnamesArray *array;
    int i;

    array = (__GLnamesArray *) GCALLOC(gc, sizeof(__GLnamesArray));
    if (array == NULL) {
        __glSetError(GL_OUT_OF_MEMORY);
        return NULL;
    }

#ifdef NT
    __try
    {
        InitializeCriticalSection(&array->critsec);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        GCFREE(gc, array);
        __glSetError(GL_OUT_OF_MEMORY);
        return NULL;
    }
#endif

    array->refcount = 1;
    array->tree = NULL;
    array->depth = 0;
    array->dataInfo = dataInfo;
    /*
    ** Pre-allocate a few leaves and branches for paranoid OUT_OF_MEMORY
    ** reasons.
    */
    array->nbranches = __GL_DL_EXTRA_BRANCHES;
    array->nleaves = __GL_DL_EXTRA_LEAVES;
    for (i = 0; i < __GL_DL_EXTRA_BRANCHES; i++) {
        array->branches[i] = (__GLnamesBranch*)
                GCALLOC(gc, sizeof(__GLnamesBranch));
        if (array->branches[i] == NULL) {
            array->nbranches = i;
            break;
        }
    }
    for (i = 0; i < __GL_DL_EXTRA_LEAVES; i++) {
        array->leaves[i] = (__GLnamesLeaf*)
                GCALLOC(gc, sizeof(__GLnamesLeaf));
        if (array->leaves[i] == NULL) {
            array->nleaves = i;
            break;
        }
    }

    return array;
}

static void FASTCALL freeLeafData(__GLcontext *gc, void **dataList)
{
    /*
    ** Note that the actual data pointed to by the elements of this list
    ** have already been freed with the callback.
    */
    GCFREE(gc, dataList);
}


static void FASTCALL freeLeaf(__GLcontext *gc, __GLnamesLeaf *leaf)
{
    if (leaf->dataList) {
        freeLeafData(gc, leaf->dataList);
    }
    GCFREE(gc, leaf);
}


static void FASTCALL freeBranch(__GLcontext *gc, __GLnamesBranch *branch)
{
    GCFREE(gc, branch);
}


/*
** Free an entire names tree.
*/
void FASTCALL __glNamesFreeTree(__GLcontext *gc, __GLnamesArray *array,
                       __GLnamesBranch *tree, GLint depth)
{
    GLuint i;
    __GLnamesLeaf *leaf;
    void *empty;
    GLint maxdepth = array->depth;

    __GL_NAMES_ASSERT_LOCKED(array);

    if (tree == NULL) return;

    if (depth < maxdepth) {
        __glNamesFreeTree(gc, array, tree->children[2], depth+1);
        __glNamesFreeTree(gc, array, tree->children[1], depth+1);
        __glNamesFreeTree(gc, array, tree->children[0], depth+1);

        freeBranch(gc, tree);
    } else {
        leaf = (__GLnamesLeaf *) tree;
        empty = array->dataInfo->empty;

        if (leaf->dataList) {
            for (i=leaf->start; i<=leaf->end; i++) {
                if (leaf->dataList[i - leaf->start] != empty) {
                    ASSERTOPENGL(leaf->dataInfo->free != NULL,
                                 "No free function\n");
                    (*leaf->dataInfo->free)(gc,
                                leaf->dataList[i - leaf->start]);
                    leaf->dataList[i - leaf->start] = empty;
                }
            }
        }
        freeLeaf(gc, leaf);
    }
}

void FASTCALL __glNamesFreeArray(__GLcontext *gc, __GLnamesArray *array)
{
    GLuint i;

    __GL_NAMES_ASSERT_LOCKED(array);

    for (i = 0; i < array->nbranches; i++) {
        GCFREE(gc, array->branches[i]);
    }
    for (i = 0; i < array->nleaves; i++) {
        GCFREE(gc, array->leaves[i]);
    }

    __glNamesFreeTree(gc, array, array->tree, 0);

    __GL_NAMES_UNLOCK(array);
#ifdef NT
    DeleteCriticalSection(&array->critsec);
#endif

    GCFREE(gc, array);
}


/*
** Find the leaf with the given name.
** If exact is TRUE, then only the leaf that contains this name will
**   be returned (NULL, otherwise).
** If exact is FALSE, than the leaf containing the number will be returned
**   if it exists, and otherwise the next highest leaf will be returned.
**   A NULL value indicates that number is higher than any other leaves in
**   the tree.
** This routine has been tuned for the case of finding the number in
** the tree, since this is the most likely case when dispatching a
** display list.
*/
static __GLnamesLeaf * FASTCALL findLeaf(__GLnamesArray *array, GLuint number,
                                                GLint exact)
{
    __GLnamesBranch *branch;
    __GLnamesLeaf *leaf;
    int depth = array->depth, r;

    __GL_NAMES_ASSERT_LOCKED(array);

    branch = array->tree;

    while (depth > 0 && branch) {

        /* rather than following if-then-else code
         * for correct branch, evaluate all conditions
         * quickly to compute correct branch.
         */
        int r = (number > branch->low) + (number > branch->medium);
        ASSERTOPENGL(branch->low <= branch->medium,
                     "Branch ordering wrong\n");
        branch = branch->children[r];
        --depth;
    }
    if (!(leaf = (__GLnamesLeaf *) branch)) return NULL;

    /* the case we want to optimize is the one in which we
     * actually find the node, so evaluate both conditions
     * quickly, since both results are required in this case
     * and return appropriately.  the choice of the final
     * if construct is to match the current vagaries of the
     * 3.19 compiler code generator (db)
     */
    r = (leaf->end < number) | (exact&(number<leaf->start));
    if (!r) return leaf;
        return NULL;
}


/*
** Copy data from leaf->lists into newleaf->lists.
*/
static void FASTCALL copyLeafInfo(__GLnamesLeaf *leaf, __GLnamesLeaf *newleaf)
{
    GLint offset;
    GLuint number;
    GLuint i;

    number = newleaf->end - newleaf->start + 1;
    offset = newleaf->start - leaf->start;

    for (i = 0; i < number; i++) {
        newleaf->dataList[i] = leaf->dataList[i+offset];
    }
}

/*
** Attempt to fix a possible situation caused by lack of memory.
*/
static GLboolean FASTCALL fixMemoryProblem(__GLcontext *gc, __GLnamesArray *array)
{
    GLuint i;

    __GL_NAMES_ASSERT_LOCKED(array);

    for (i = array->nbranches; i < __GL_DL_EXTRA_BRANCHES; i++) {
        array->branches[i] = (__GLnamesBranch*)
            GCALLOC(gc, sizeof(__GLnamesBranch));
        if (array->branches[i] == NULL) {
            array->nbranches = i;
            return GL_FALSE;
        }
    }
    array->nbranches = __GL_DL_EXTRA_BRANCHES;
    for (i = array->nleaves; i < __GL_DL_EXTRA_LEAVES; i++) {
        array->leaves[i] = (__GLnamesLeaf*) GCALLOC(gc, sizeof(__GLnamesLeaf));
        if (array->leaves[i] == NULL) {
            array->nleaves = i;
            return GL_FALSE;
        }
    }
    array->nleaves = __GL_DL_EXTRA_LEAVES;
    return GL_TRUE;
}

/*
** Compute the maximum value contained in the given tree.  If
** curdepth == maxdepth, the tree is simply a leaf.
*/
static GLuint FASTCALL computeMax(__GLnamesBranch *branch, GLint curdepth,
                         GLint maxdepth)
{
    __GLnamesLeaf *leaf;

    while (curdepth < maxdepth) {
        if (branch->children[2] != NULL) {
            branch = branch->children[2];
        } else if (branch->children[1] != NULL) {
            return branch->medium;
        } else {
            return branch->low;
        }
        curdepth++;
    }
    leaf = (__GLnamesLeaf *) branch;
    return leaf->end;
}

/*
** Make sure that all parents of this child know that maxval is the
** highest value that can be found in this child.
*/
static void FASTCALL pushMaxVal(__GLnamesBranch *child, GLuint maxval)
{
    __GLnamesBranch *parent;

    while (parent = child->parent) {
        if (parent->children[0] == child) {
            parent->low = maxval;
            if (parent->children[1] != NULL) {
                return;
            }
        } else if (parent->children[1] == child) {
            parent->medium = maxval;
            if (parent->children[2] != NULL) {
                return;
            }
        } else {
            ASSERTOPENGL(parent->children[2] == child,
                         "Parent/child relationship incorrect\n");
        }
        child = parent;
    }
}

static GLboolean FASTCALL allocLeafData(__GLcontext *gc, __GLnamesLeaf *leaf)
{
    GLint number;
    GLint i;

    number = leaf->end - leaf->start + 1;
    leaf->dataList = (void **) GCALLOC(gc, (size_t)(sizeof(void *)*number));
    if (!leaf->dataList) return GL_FALSE;

    for (i=0; i < number; i++) {
        leaf->dataList[i] = leaf->dataInfo->empty;
    }
    return GL_TRUE;
}

static GLboolean FASTCALL reallocLeafData(__GLcontext *gc, __GLnamesLeaf *leaf)
{
    size_t number;
    void **answer;

    number = (size_t) (leaf->end - leaf->start + 1);
    answer = (void **) GCREALLOC(gc, leaf->dataList, sizeof(void *)*number);
    if (answer) {
        leaf->dataList = answer;
        return GL_TRUE;
    } else {
        /*
        ** Crud!  Out of memory!
        */
        return GL_FALSE;
    }
}

static __GLnamesLeaf * FASTCALL allocLeaf(__GLcontext *gc, __GLnamesArray *array)
{
    __GLnamesLeaf *leaf;

    leaf = (__GLnamesLeaf *) GCALLOC(gc, sizeof(__GLnamesLeaf));

    if (leaf == NULL) {
        /*
        ** Ouch!  No memory?  We had better use one of the preallocated
        ** leaves.
        */

        __GL_NAMES_ASSERT_LOCKED(array);

        ASSERTOPENGL(array->nleaves != 0,
                     "No preallocated leaves\n");
        array->nleaves--;
        leaf = array->leaves[array->nleaves];
    }

    leaf->parent = NULL;
    leaf->dataList = NULL;
    leaf->dataInfo = array->dataInfo;

    return leaf;
}


/*
** Allocates a branch node.
*/
static __GLnamesBranch * FASTCALL allocBranch(__GLcontext *gc, __GLnamesArray *array)
{
    __GLnamesBranch *branch;

    branch = (__GLnamesBranch *) GCALLOC(gc, sizeof(__GLnamesBranch));

    if (branch == NULL) {
        /*
        ** Ouch!  No memory?  We had better use one of the preallocated
        ** branches.
        */

        __GL_NAMES_ASSERT_LOCKED(array);

        ASSERTOPENGL(array->nbranches != 0,
                     "No preallocated branches\n");
        array->nbranches--;
        branch = array->branches[array->nbranches];
    }

    branch->children[0] = branch->children[1] = branch->children[2] = NULL;
    branch->parent = NULL;

    return branch;
}

/*
** Remove the child from the parent.  depth refers to the parent.
** This deletion may delete a child from a parent with only two children.
** If so, the parent itself will soon be deleted, of course.
*/
static void FASTCALL deleteChild(__GLnamesArray *array, __GLnamesBranch *parent,
                        __GLnamesBranch *child, GLint depth)
{
    GLuint maxval;
    GLint maxdepth;

    __GL_NAMES_ASSERT_LOCKED(array);

    maxdepth = array->depth;

    if (parent->children[0] == child) {
        parent->children[0] = parent->children[1];
        parent->children[1] = parent->children[2];
        parent->children[2] = NULL;
        parent->low = parent->medium;
        if (parent->children[1] != NULL) {
            maxval = computeMax(parent->children[1], depth+1, maxdepth);
            parent->medium = maxval;
        } else parent->medium = 0;
    } else if (parent->children[1] == child) {
        parent->children[1] = parent->children[2];
        parent->children[2] = NULL;
        if (parent->children[1] != NULL) {
            maxval = computeMax(parent->children[1], depth+1, maxdepth);
            parent->medium = maxval;
        } else parent->medium = 0;
    } else {
        ASSERTOPENGL(parent->children[2] == child,
                     "Parent/child relationship wrong\n");
        parent->children[2] = NULL;
        pushMaxVal(parent, parent->medium);
    }
}

/*
** Add child to parent.  child is a leaf if curdepth == maxdepth - 1
** (curdepth refers to the depth of the parent, not the child).  Parent
** only has one or two children (thus has room for another child).
*/
static void FASTCALL addChild(__GLnamesBranch *parent, __GLnamesBranch *child,
                     GLint curdepth, GLint maxdepth)
{
    GLuint maxval;

    maxval = computeMax(child, curdepth+1, maxdepth);

    child->parent = parent;
    if (maxval > parent->medium && parent->children[1] != NULL) {
        /* This becomes the third child */
        parent->children[2] = child;

        /* Propagate the maximum value for this child to its parents */
        pushMaxVal(parent, maxval);
    } else if (maxval > parent->low) {
        /* This becomes the second child */
        parent->children[2] = parent->children[1];
        parent->children[1] = child;
        parent->medium = maxval;

        if (parent->children[2] == NULL) {
            pushMaxVal(parent, maxval);
        }
    } else {
        parent->children[2] = parent->children[1];
        parent->children[1] = parent->children[0];
        parent->children[0] = child;
        parent->medium = parent->low;
        parent->low = maxval;
    }
}

/*
** From the three children in parent, and the extraChild, build two parents:
** parent and newParent.  curdepth refers to the depth of parent.  parent
** is part of the tree, so its maxval needs to be propagated up if it
** changes.
*/
static void FASTCALL splitParent(__GLnamesBranch *parent,
                                __GLnamesBranch *newParent,
                                __GLnamesBranch *extraChild,
                                GLint curdepth,
                                GLint maxdepth)
{
    __GLnamesBranch *children[4], *tempchild;
    GLuint maxvals[4], tempval;
    int i;

    /* Collect our four children */
    children[0] = parent->children[0];
    maxvals[0] = parent->low;
    children[1] = parent->children[1];
    maxvals[1] = parent->medium;
    children[2] = parent->children[2];
    maxvals[2] = computeMax(children[2], curdepth+1, maxdepth);
    children[3] = extraChild;
    maxvals[3] = computeMax(extraChild, curdepth+1, maxdepth);

    /* Children 0-2 are sorted.  Sort child 3 too. */
    for (i = 3; i > 0; i--) {
        if (maxvals[i] < maxvals[i-1]) {
            tempval = maxvals[i];
            tempchild = children[i];
            maxvals[i] = maxvals[i-1];
            children[i] = children[i-1];
            maxvals[i-1] = tempval;
            children[i-1] = tempchild;
        }
    }

    /* Construct the two parents */
    parent->low = maxvals[0];
    parent->children[0] = children[0];
    parent->medium = maxvals[1];
    parent->children[1] = children[1];
    parent->children[2] = NULL;
    children[0]->parent = parent;
    children[1]->parent = parent;
    pushMaxVal(parent, maxvals[1]);

    newParent->low = maxvals[2];
    newParent->children[0] = children[2];
    newParent->medium = maxvals[3];
    newParent->children[1] = children[3];
    newParent->children[2] = NULL;
    children[2]->parent = newParent;
    children[3]->parent = newParent;
}

/*
** Build a parent from child1 and child2.  depth tells the depth of
** the trees pointed to by child1 and child2.
*/
static void FASTCALL buildParent(__GLnamesBranch *parent, __GLnamesBranch *child1,
                        __GLnamesBranch *child2, GLint depth)
{
    GLuint maxChild1, maxChild2;

    child1->parent = parent;
    child2->parent = parent;
    maxChild1 = computeMax(child1, 0, depth);
    maxChild2 = computeMax(child2, 0, depth);
    if (maxChild2 > maxChild1) {
        parent->children[0] = child1;
        parent->low = maxChild1;
        parent->children[1] = child2;
        parent->medium = maxChild2;
    } else {
        parent->children[0] = child2;
        parent->low = maxChild2;
        parent->children[1] = child1;
        parent->medium = maxChild1;
    }
}

/*
** Insert the new leaf into the tree.
*/
static void FASTCALL insertLeaf(__GLcontext *gc, __GLnamesArray *array,
                                __GLnamesLeaf *leaf)
{
    __GLnamesBranch *extraChild;
    __GLnamesBranch *branch;
    __GLnamesBranch *parent;
    __GLnamesBranch *newParent;
    GLint maxdepth, curdepth;
    GLuint number;

    __GL_NAMES_ASSERT_LOCKED(array);

    number = leaf->end;
    maxdepth = array->depth;
    branch = array->tree;
    if (!branch) {
        /* No tree!  Make a one leaf tree. */
        array->depth = 0;
        array->tree = (__GLnamesBranch *) leaf;
        return;
    }

    curdepth = 0;
    while (curdepth < maxdepth) {
        if (number <= branch->low) {
            branch = branch->children[0];
        } else if (number <= branch->medium) {
            branch = branch->children[1];
        } else {
            if (branch->children[2] != NULL) {
                branch = branch->children[2];
            } else {
                branch = branch->children[1];
            }
        }
        curdepth++;
    }

    /*
    ** Ok, we just managed to work our way to the bottom of the tree.
    ** 'leaf' becomes the extraChild, and we now try to insert it anywhere
    ** it will fit.
    */
    extraChild = (__GLnamesBranch *) leaf;
    parent = branch->parent;

    curdepth--;
    while (parent) {
        if (parent->children[2] == NULL) {
            /* We have room to squeeze this node in here! */
            addChild(parent, extraChild, curdepth, maxdepth);
            return;
        }

        /*
        ** We have one parent and four children.  This simply
        ** won't do.  We create a new parent, and end up with two
        ** parents with two children each.  That works.
        */
        newParent = allocBranch(gc, array);
        splitParent(parent, newParent, extraChild, curdepth, maxdepth);

        /*
        ** Great.  Now newParent becomes the orphan, and we try to
        ** trivially insert it up a level.
        */
        extraChild = newParent;
        branch = parent;
        parent = branch->parent;
        curdepth--;
    }

    /* We just reached the top node, and there is no parent, and we
    ** still haven't managed to rid ourselves of an extra child.  So,
    ** we make a new parent to take branch and extraChild as it's two
    ** children.  We have to increase the depth of the tree, of course.
    */
    ASSERTOPENGL(curdepth == -1, "Wrong depth at top\n");
    parent = allocBranch(gc, array);
    buildParent(parent, branch, extraChild, maxdepth);
    array->tree = parent;
    array->depth++;
}

/*
** Delete the given leaf from the tree.  The leaf itself is not
** freed or anything, so the calling procedure needs to worry about it.
*/
static void FASTCALL deleteLeaf(__GLcontext *gc, __GLnamesArray *array,
                                __GLnamesLeaf *leaf)
{
    __GLnamesBranch *orphan;
    __GLnamesBranch *parent, *newParent;
    __GLnamesBranch *grandparent;
    GLint depth, maxdepth;
    GLuint maxval;

    __GL_NAMES_ASSERT_LOCKED(array);

    maxdepth = depth = array->depth;
    parent = leaf->parent;
    if (parent == NULL) {
        /* Ack!  We just nuked the only node! */
        array->tree = NULL;
        return;
    }

    deleteChild(array, parent, (__GLnamesBranch *) leaf, depth-1);

    /*
    ** depth is the depth of the child in this case.
    */
    depth--;
    while (parent->children[1] == NULL) {
        /* Crud.  Need to do work. */
        orphan = parent->children[0];

        /* Ax the parent, insert child into grandparent. */
        grandparent = parent->parent;

        if (grandparent == NULL) {
            /*
            ** Hmmm.  Parent was the root.  Nuke it and make the orphan
            ** the new root.
            */
            freeBranch(gc, parent);
            array->tree = orphan;
            orphan->parent = NULL;
            array->depth--;
            return;
        }

        deleteChild(array, grandparent, parent, depth-1);
        freeBranch(gc, parent);

        /* The parent is dead.  Find a new parent. */
        maxval = computeMax(orphan, depth+1, maxdepth);
        if (grandparent->children[1] == NULL ||
                maxval <= grandparent->low) {
            parent = grandparent->children[0];
        } else {
            parent = grandparent->children[1];
        }

        /* Insert orphan into new parent. */
        if (parent->children[2] != NULL) {
            newParent = allocBranch(gc, array);
            splitParent(parent, newParent, orphan, depth, maxdepth);
            /* We know there is room! */
            addChild(grandparent, newParent, depth-1, maxdepth);
            return;
        }

        /* The parent has room for the child */
        addChild(parent, orphan, depth, maxdepth);

        depth--;
        parent = grandparent;
    }
}

/*
** Shrink the leaf by adjusting start and end.
** If necessary, call pushMaxVal() to notify the database about the change.
** Also fix up the lists pointer if necessary.
*/
static void FASTCALL resizeLeaf(__GLcontext *gc, __GLnamesLeaf *leaf,
                                GLuint newstart, GLuint newend)
{
    GLuint oldstart, oldend;
    GLuint newsize, offset, i;

    oldstart = leaf->start;
    oldend = leaf->end;

    leaf->start = newstart;
    if (newend != oldend) {
        leaf->end = newend;
        pushMaxVal((__GLnamesBranch *) leaf, newend);
    }
    if (leaf->dataList == NULL) return;

    /*
    ** Copy the appropriate pointers to the begining of the array, and
    ** realloc it.
    */
    offset = newstart - oldstart;
    newsize = newend - newstart + 1;
    if (offset) {
        for (i=0; i<newsize; i++) {
            /*
            ** Copy the whole structure with one line.
            */
            leaf->dataList[i] = leaf->dataList[i+offset];
        }
    }
    reallocLeafData(gc, leaf);
}

/*
** Find the previous leaf (before "leaf") in the tree.
*/
static __GLnamesLeaf * FASTCALL prevLeaf(__GLnamesLeaf *leaf)
{
    __GLnamesBranch *branch, *child;
    GLint reldepth;

    branch = leaf->parent;
    if (!branch) return NULL;           /* A one leaf tree! */

    child = (__GLnamesBranch *) leaf;

    /* We start off at a relative depth of 1 above the child (-1) */
    reldepth = -1;

    while (branch) {
        /* If the child was the 3rd child, branch down to the second. */
        if (branch->children[2] == child) {
            branch = branch->children[1];
            reldepth++;         /* One level lower */
            break;
        } else if (branch->children[1] == child) {
            /* If the child was the 2nd child, branch down to the first */
            branch = branch->children[0];
            reldepth++;         /* One level lower */
            break;
        } else {
            /* Must have been 1st child */
            ASSERTOPENGL(branch->children[0] == child,
                         "Parent/child relationship wrong\n");
        }
        /*
        ** Otherwise, we have already visited all of this branch's children,
        ** so we go up a level.
        */
        child = branch;
        branch = branch->parent;
        reldepth--;     /* One level higher */
    }
    if (!branch) return NULL;   /* All leaves visited! */

    /* Go down the 'right'most trail of this branch until we get to
    ** a child, then return it.
    */
    while (reldepth) {
        if (branch->children[2] != NULL) {
            branch = branch->children[2];
        } else if (branch->children[1] != NULL) {
            branch = branch->children[1];
        } else {
            branch = branch->children[0];
        }
        reldepth++;             /* One level lower */
    }

    return (__GLnamesLeaf *) branch;
}

/*
** Find the first leaf in the tree.
*/
static __GLnamesLeaf * FASTCALL firstLeaf(__GLnamesArray *array)
{
    __GLnamesBranch *branch;
    GLint maxdepth, curdepth;

    __GL_NAMES_ASSERT_LOCKED(array);

    maxdepth = array->depth;
    curdepth = 0;
    branch = array->tree;

    /* No tree, no leaves! */
    if (!branch) return NULL;

    /* Take the 'left'most branch until we reach a leaf */
    while (curdepth != maxdepth) {
        branch = branch->children[0];
        curdepth++;
    }
    return (__GLnamesLeaf *) branch;
}

/*
** Find the next leaf (after "leaf") in the tree.
*/
static __GLnamesLeaf * FASTCALL nextLeaf(__GLnamesLeaf *leaf)
{
    __GLnamesBranch *branch, *child;
    GLint reldepth;

    branch = leaf->parent;
    if (!branch) return NULL;           /* A one leaf tree! */

    child = (__GLnamesBranch *) leaf;

    /* We start off at a relative depth of 1 above the child (-1) */
    reldepth = -1;

    while (branch) {
        /* If the child was the 1st child, branch down to the second. */
        if (branch->children[0] == child) {
            branch = branch->children[1];
            reldepth++;         /* One level lower */
            break;
        } else if (branch->children[1] == child) {
            /*
            ** If the child was the 2nd child, and there is a third, branch
            ** down to it.
            */
            if (branch->children[2] != NULL) {
                branch = branch->children[2];
                reldepth++;     /* One level lower */
                break;
            }
        } else {
            /* Must have been 3rd child */
            ASSERTOPENGL(branch->children[2] == child,
                         "Parent/child relationship wrong\n");
        }
        /*
        ** Otherwise, we have already visited all of this branch's children,
        ** so we go up a level.
        */
        child = branch;
        branch = branch->parent;
        reldepth--;     /* One level higher */
    }
    if (!branch) return NULL;   /* All leaves visited! */

    /* Go down the 'left'most trail of this branch until we get to
    ** a child, then return it.
    */
    while (reldepth) {
        branch = branch->children[0];
        reldepth++;             /* One level lower */
    }

    return (__GLnamesLeaf *) branch;
}

/*
** Merge leaf2 into leaf1, and free leaf2.
** Need to pushMaxVal on the new leaf.
** We can assume that leaf1 and leaf2 are fit for merging.
** The return value is GL_TRUE if we did it.
*/
static GLboolean FASTCALL mergeLeaves(__GLcontext *gc, __GLnamesLeaf *leaf1,
                             __GLnamesLeaf *leaf2)
{
    GLuint end;
    GLuint i;
    GLuint number, offset;

    /* If we don't have to merge lists, it is easy. */
    if (leaf1->dataList == NULL) {
        ASSERTOPENGL(leaf2->dataList == NULL, "Data already exists\n");
        if (leaf1->start < leaf2->start) {
            leaf1->end = leaf2->end;
            pushMaxVal((__GLnamesBranch *) leaf1, leaf1->end);
        } else {
            leaf1->start = leaf2->start;
        }
        freeLeaf(gc, leaf2);
        return GL_TRUE;
    }

    /*
    ** Yick!  Need to merge lists.
    */
    ASSERTOPENGL(leaf2->dataList != NULL, "No data\n");
    if (leaf1->start < leaf2->start) {
        /*
        ** Expand size of leaf1's array, copy leaf2's array into it,
        ** free leaf2.
        */
        offset = leaf1->end - leaf1->start + 1;
        number = leaf2->end - leaf2->start + 1;
        end = leaf1->end;
        leaf1->end = leaf2->end;
        if (!reallocLeafData(gc, leaf1)) {
            /*
            ** Heavens!  No memory?  That sucks!
            ** We won't bother merging.  It is never an absolutely critical
            ** operation.
            */
            leaf1->end = end;
            return GL_FALSE;
        }
        for (i = 0; i < number; i++) {
            leaf1->dataList[i+offset] = leaf2->dataList[i];
        }

        freeLeaf(gc, leaf2);

        pushMaxVal((__GLnamesBranch *) leaf1, leaf1->end);
    } else {
        /*
        ** Expand the size of leaf2's array, copy leaf1's array into it.
        ** Then free leaf1's array, copy leaf2's array to leaf1, and free
        ** leaf2.
        */
        offset = leaf2->end - leaf2->start + 1;
        number = leaf1->end - leaf1->start + 1;
        end = leaf2->end;
        leaf2->end = leaf1->end;
        if (!reallocLeafData(gc, leaf2)) {
            /*
            ** Heavens!  No memory?  That sucks!
            ** We won't bother merging.  It is never an absolutely critical
            ** operation.
            */
            leaf2->end = end;
            return GL_FALSE;
        }
        for (i = 0; i < number; i++) {
            leaf2->dataList[i+offset] = leaf1->dataList[i];
        }

        freeLeafData(gc, leaf1->dataList);
        leaf1->start = leaf2->start;

        leaf1->dataList = leaf2->dataList;
        leaf2->dataList = NULL;
        freeLeaf(gc, leaf2);
    }
    return GL_TRUE;
}

/*
** Check if this leaf can merge with any neighbors, and if so, do it.
*/
static void FASTCALL mergeLeaf(__GLcontext *gc, __GLnamesArray *array,
                                __GLnamesLeaf *leaf)
{
    __GLnamesLeaf *next, *prev;

    __GL_NAMES_ASSERT_LOCKED(array);

    next = nextLeaf(leaf);
    if (next) {
        /* Try to merge with next leaf */
        if (leaf->end + 1 == next->start) {
            if ((leaf->dataList == NULL && next->dataList == NULL) ||
                    (next->dataList && leaf->dataList &&
                    next->end - leaf->start < (GLuint) __GL_DLIST_MAX_ARRAY_BLOCK)) {
                /* It's legal to merge these leaves */
                deleteLeaf(gc, array, next);
                if (!mergeLeaves(gc, leaf, next)) {
                    /*
                    ** Ack!  No memory?  We bail on the merge.
                    */
                    insertLeaf(gc, array, next);
                    return;
                }
            }
        }
    }

    prev = prevLeaf(leaf);
    if (prev) {
        /* Try to merge with prev leaf */
        if (prev->end + 1 == leaf->start) {
            if ((prev->dataList == NULL && leaf->dataList == NULL) ||
                    (leaf->dataList && prev->dataList &&
                    leaf->end - prev->start < (GLuint) __GL_DLIST_MAX_ARRAY_BLOCK)) {
                /* It's legal to merge these leaves */
                deleteLeaf(gc, array, prev);
                if (!mergeLeaves(gc, leaf, prev)) {
                    /*
                    ** Ack!  No memory?  We bail on the merge.
                    */
                    insertLeaf(gc, array, prev);
                    return;
                }
            }
        }
    }
}

GLboolean FASTCALL __glNamesNewData(__GLcontext *gc, __GLnamesArray *array,
                                GLuint name, void *data)
{
    __GLnamesLeaf *leaf, *newleaf;
    GLint entry;
    GLuint start, end;

    __GL_NAMES_LOCK(array);

    leaf = findLeaf(array, name, GL_TRUE);

    /*
    ** First we check for possible memory problems, since it will be
    ** difficult to back out once we start.
    */
    if (leaf == NULL || leaf->dataList == NULL) {
        /*
        ** May need memory in these cases.
        */
        if (array->nbranches != __GL_DL_EXTRA_BRANCHES ||
                array->nleaves != __GL_DL_EXTRA_LEAVES) {
            if (!fixMemoryProblem(gc, array)) {
                __GL_NAMES_UNLOCK(array);
                __glSetError(GL_OUT_OF_MEMORY);
                return GL_FALSE;
            }
        }
    }

    if (!leaf) {
        /*
        ** Make new leaf with just this display list
        */
        leaf = allocLeaf(gc, array);
        leaf->start = leaf->end = name;
        if (data) {
            if (!allocLeafData(gc, leaf)) {
                /*
                ** Bummer.  No new list for you!
                */
                freeLeaf(gc, leaf);
                __GL_NAMES_UNLOCK(array);
                __glSetError(GL_OUT_OF_MEMORY);
                return GL_FALSE;
            }
            leaf->dataList[0] = data;
            (*(GLint *)data) = 1;               /* set the refcount */
        }
        insertLeaf(gc, array, leaf);
        mergeLeaf(gc, array, leaf);
        __GL_NAMES_UNLOCK(array);
        return GL_TRUE;
    } else if (leaf->dataList) {
        /*
        ** Simply update the appropriate entry in the lists array
        */
        entry = name - leaf->start;
        if (leaf->dataList[entry] != leaf->dataInfo->empty) {
            ASSERTOPENGL(leaf->dataInfo->free != NULL,
                         "No free function\n");
            (*leaf->dataInfo->free)(gc, leaf->dataList[entry]);
            leaf->dataList[entry] = leaf->dataInfo->empty;
        }
        if (data) {
            leaf->dataList[entry] = data;
            (*(GLint *)data) = 1;               /* set the refcount */
        }
        __GL_NAMES_UNLOCK(array);
        return GL_TRUE;
    } else {
        if (!data) {
            /*
            ** If there isn't really any list, we are done.
            */
            __GL_NAMES_UNLOCK(array);
            return GL_TRUE;
        }

        /*
        ** Allocate some or all of the lists in leaf.  If only some, then
        ** leaf needs to be split into two or three leaves.
        **
        ** First we decide what range of numbers to allocate an array for.
        ** (be careful of possible word wrap error)
        */
        start = name - __GL_DLIST_MIN_ARRAY_BLOCK/2;
        if (start < leaf->start || start > name) {
            start = leaf->start;
        }
        end = start + __GL_DLIST_MIN_ARRAY_BLOCK - 1;
        if (end > leaf->end || end < start) {
            end = leaf->end;
        }

        if (start - leaf->start < (GLuint) __GL_DLIST_MIN_ARRAY_BLOCK) {
            start = leaf->start;
        }
        if (leaf->end - end < (GLuint) __GL_DLIST_MIN_ARRAY_BLOCK) {
            end = leaf->end;
        }

        if (start == leaf->start) {
            if (end == leaf->end) {
                /*
                ** Simply allocate the entire array.
                */
                if (!allocLeafData(gc, leaf)) {
                    /*
                    ** Whoa!  No memory!  Never mind!
                    */
                    __glSetError(GL_OUT_OF_MEMORY);
                    __GL_NAMES_UNLOCK(array);
                    return GL_FALSE;
                }
                {
                    GLint entry = name - leaf->start;
                    leaf->dataList[entry] = data;
                    (*(GLint *)data) = 1;               /* set the refcount */
                }
                mergeLeaf(gc, array, leaf);
                __GL_NAMES_UNLOCK(array);
                return GL_TRUE;
            } else {
                /*
                ** Shrink the existing leaf, and create a new one to hold
                ** the new arrays (done outside the "if" statement).
                */
                resizeLeaf(gc, leaf, end+1, leaf->end);
            }
        } else if (end == leaf->end) {
            /*
            ** Shrink the existing leaf, and create a new one to hold
            ** the new arrays (done outside the "if" statement).
            */
            resizeLeaf(gc, leaf, leaf->start, start-1);
        } else {
            /*
            ** Crud.  The middle of the leaf was deleted.  This is tough.
            */
            newleaf = allocLeaf(gc, array);

            newleaf->start = end+1;
            newleaf->end = leaf->end;
            resizeLeaf(gc, leaf, leaf->start, start-1);
            insertLeaf(gc, array, newleaf);
        }
        leaf = allocLeaf(gc, array);
        leaf->start = start;
        leaf->end = end;
        if (!allocLeafData(gc, leaf)) {
            /*
            ** Whoa!  No memory!  Never mind!
            */
            insertLeaf(gc, array, leaf);
            mergeLeaf(gc, array, leaf);
            __glSetError(GL_OUT_OF_MEMORY);
            __GL_NAMES_UNLOCK(array);
            return GL_FALSE;
        }
        {
            GLint entry = name - leaf->start;
            leaf->dataList[entry] = data;
            (*(GLint *)data) = 1;               /* set the refcount */
        }
        insertLeaf(gc, array, leaf);
        mergeLeaf(gc, array, leaf);
        __GL_NAMES_UNLOCK(array);
        return GL_TRUE;
    }
}


/*
** Lock the named data.  Locking data both looks the data up,
** and guarantees that another thread will not delete the data out from
** under us.  This data will be unlocked with __glNamesUnlockData().
**
** A return value of NULL indicates that no data with the specified name
** was found.
*/
void * FASTCALL __glNamesLockData(__GLcontext *gc, __GLnamesArray *array,
                        GLuint name)
{
    __GLnamesLeaf *leaf;
    void *data;
    GLint offset;

    __GL_NAMES_LOCK(array);

    /*
    ** Lock access to data.
    */
    leaf = findLeaf(array, name, GL_TRUE);
    if (leaf == NULL || leaf->dataList == NULL) {
        __GL_NAMES_UNLOCK(array);
        return NULL;
    }
    offset = name - leaf->start;
    data = leaf->dataList[offset];
    if (data) {
        (*(GLint *)data)++;             /* Increment the refcount. */
    }
    __GL_NAMES_UNLOCK(array);
    return data;
}


/*
** Lock all of the data in the user's names array.  Locking data
** both looks the data up, and guarantees that another thread will not
** delete the data out from under us.  These data structs will be unlocked
** with __glNamesUnlockDataList().
**
** All entries of the array are guaranteed to be non-NULL.  This is
** accomplished by sticking an empty data structure in those slots where
** no data was set.
*/
void FASTCALL __glNamesLockDataList(__GLcontext *gc, __GLnamesArray *array,
                        GLsizei n, GLenum type, GLuint base,
                        const GLvoid *names, void *dataPtrs[])
{
    __GLnamesLeaf *leaf;
    void **data;
    void *tempData;
    void *empty;
    GLuint curName;

    __GL_NAMES_LOCK(array);

    empty = array->dataInfo->empty;

    data = dataPtrs;

    /*
    ** Note that this code is designed to take advantage of coherence.
    ** After looking up (and locking) a single display list in
    ** listnums[], the next list is checked for in the same leaf that
    ** contained the previous.  This will make typical uses of CallLists()
    ** quite fast (text, for example).
    */

    /*
    ** Lock access to array.
    */
    switch(type) {
      case GL_BYTE:
        /*
        ** Coded poorly for optimization purposes
        */
        {
            const GLbyte *p = (const GLbyte *) names;

Bstart:
            if (--n >= 0) {
                /* Optimization for possibly common font case */
                curName = base + *p++;
Bfind:
                leaf = findLeaf(array, curName, GL_TRUE);
                if (leaf && leaf->dataList) {
                    GLint reldiff;
                    GLuint relend;
                    void **leafData;

                    leafData = leaf->dataList;
                    tempData = leafData[curName - leaf->start];

                    /* All possible display lists can be found here */
                    reldiff = base - leaf->start;
                    relend = leaf->end - leaf->start;

Bsave:
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                    if (--n >= 0) {
                        curName = *p++ + reldiff;
                        if (curName <= relend) {
                            tempData = leafData[curName];
                            goto Bsave;
                        }
                        curName = curName + leaf->start;
                        goto Bfind;
                    }
                } else {
                    (*(GLint *)empty)++;                /* increment refcount */
                    *data++ = empty;
                    goto Bstart;
                }
            }
        }
        break;
      case GL_UNSIGNED_BYTE:
        /*
        ** Coded poorly for optimization purposes
        */
        {
            const GLubyte *p = (const GLubyte *) names;

UBstart:
            if (--n >= 0) {
                /* Optimization for possibly common font case */
                curName = base + *p++;
UBfind:
                leaf = findLeaf(array, curName, GL_TRUE);
                if (leaf && leaf->dataList) {
                    GLint reldiff;
                    GLuint relend;
                    void **leafData;

                    leafData = leaf->dataList;
                    tempData = leafData[curName - leaf->start];

                    /* All possible display lists can be found here */
                    reldiff = base - leaf->start;
                    relend = leaf->end - leaf->start;

UBsave:
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                    if (--n >= 0) {
                        curName = *p++ + reldiff;
                        if (curName <= relend) {
                            tempData = leafData[curName];
                            goto UBsave;
                        }
                        curName = curName + leaf->start;
                        goto UBfind;
                    }
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                    goto UBstart;
                }
            }
        }
        break;
      case GL_SHORT:
        {
            const GLshort *p = (const GLshort *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_UNSIGNED_SHORT:
        {
            const GLushort *p = (const GLushort *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_INT:
        {
            const GLint *p = (const GLint *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_UNSIGNED_INT:
        {
            const GLuint *p = (const GLuint *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_FLOAT:
        {
            const GLfloat *p = (const GLfloat *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_2_BYTES:
        {
            const GLubyte *p = (const GLubyte *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + ((p[0] << 8) | p[1]);
                p += 2;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_3_BYTES:
        {
            const GLubyte *p = (const GLubyte *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + ((p[0] << 16) | (p[1] << 8) | p[2]);
                p += 3;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_4_BYTES:
        {
            const GLubyte *p = (const GLubyte *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + ((p[0] << 24) | (p[1] << 16) |
                        (p[2] << 8) | p[3]);
                p += 4;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      default:
        /* This should be impossible */
        ASSERTOPENGL(FALSE, "Default hit\n");
    }

    __GL_NAMES_UNLOCK(array);
}

/*
** Unlocks data that was previously locked with __glNamesLockData().
*/
void FASTCALL __glNamesUnlockData(__GLcontext *gc, void *data,
                                  __GLnamesCleanupFunc cleanup)
{
    GLint *pRefcount;
    ASSERTOPENGL(data, "No data to unlock\n");

    pRefcount = data;
    (*pRefcount)--;             /* decrement the refcount */
    ASSERTOPENGL(*pRefcount >= 0, "Invalid refcount\n");
    if (*pRefcount == 0) {
        /*
        ** We are the last person to see this list alive.  Free it.
        */
       (*cleanup)(gc, data);
    }
}



/*
** Unlocks an array of named data that was previously locked with
** __glNamesLockDataList().
*/
void FASTCALL __glNamesUnlockDataList(__GLcontext *gc, GLsizei n,
                                      void *dataList[],
                                      __GLnamesCleanupFunc cleanup)
{
    GLint i;
    GLint *pRefcount;

    /*
    ** The refcount comes first in all data definitions, so the
    ** data pointer also points to the refcount.
    */
    for (i = 0; i < n; i++) {
        pRefcount = (GLint *)(dataList[i]);
        (*pRefcount) --;                        /* decrement the refcount */
        ASSERTOPENGL(*pRefcount >= 0, "Invalid refcount\n");
        if (*pRefcount == 0) {
            /*
            ** We are the last person to see this list alive.  Free it.
            */
            (*cleanup)(gc, (void *)pRefcount);
        }
    }
}


GLuint FASTCALL __glNamesGenRange(__GLcontext *gc, __GLnamesArray *array,
                         GLsizei range)
{
    GLuint lastUsed;
    GLuint nextUsed;
    GLuint maxUsed;
    __GLnamesLeaf *leaf;
    __GLnamesLeaf *nextleaf;
    __GLnamesLeaf *newleaf;

    __GL_NAMES_LOCK(array);

    /*
    ** First we check for possible memory problems, since it will be
    ** difficult to back out once we start.
    */
    if (array->nbranches != __GL_DL_EXTRA_BRANCHES ||
            array->nleaves != __GL_DL_EXTRA_LEAVES) {
        if (!fixMemoryProblem(gc, array)) {
            __GL_NAMES_UNLOCK(array);
            __glSetError(GL_OUT_OF_MEMORY);
            return 0;
        }
    }

    leaf = firstLeaf(array);

    /*
    ** Can we possibly allocate the appropriate number before the first leaf?
    */
    if (leaf && leaf->start > (GLuint)range) {
        if (leaf->dataList == NULL) {
            /*
            ** Ha!  We can trivially extend leaf!
            */
            leaf->start -= range;
            __GL_NAMES_UNLOCK(array);
            return leaf->start;
        } else {
            /*
            ** Must make a new leaf
            */
            newleaf = allocLeaf(gc, array);

            newleaf->start = 1;
            newleaf->end = range;
            insertLeaf(gc, array, newleaf);

            __GL_NAMES_UNLOCK(array);
            return 1;
        }
    }

    while (leaf) {
        nextleaf = nextLeaf(leaf);
        if (!nextleaf) break;

        lastUsed = leaf->end + 1;
        nextUsed = nextleaf->start;

        /* Room for (lastUsed) - (nextUsed-1) here */
        if (nextUsed - lastUsed >= (GLuint)range) {
            if (leaf->dataList == NULL) {
                /* Trivial to expand 'leaf' */
                leaf->end += range;
                pushMaxVal((__GLnamesBranch *) leaf, leaf->end);

                if (nextUsed - lastUsed == (GLuint)range && nextleaf->dataList == NULL) {
                    mergeLeaf(gc, array, leaf);
                }

                __GL_NAMES_UNLOCK(array);
                return lastUsed;
            } else if (nextleaf->dataList == NULL) {
                /* Trivial to expand 'nextleaf' */
                nextleaf->start -= range;

                __GL_NAMES_UNLOCK(array);
                return nextleaf->start;
            } else {
                newleaf = allocLeaf(gc, array);

                newleaf->start = lastUsed;
                newleaf->end = lastUsed + range - 1;
                insertLeaf(gc, array, newleaf);

                __GL_NAMES_UNLOCK(array);
                return lastUsed;
            }
        }

        leaf = nextleaf;
    }

    if (leaf == NULL) {
        newleaf = allocLeaf(gc, array);

        newleaf->start = 1;
        newleaf->end = range;
        insertLeaf(gc, array, newleaf);

        __GL_NAMES_UNLOCK(array);
        return 1;
    } else {
        lastUsed = leaf->end;
        maxUsed = lastUsed + range;
        if (maxUsed < lastUsed) {
            /* Word wrap!  Ack! */
            __GL_NAMES_UNLOCK(array);
            return 0;
        }
        if (leaf->dataList == NULL) {
            /* Trivial to expand 'leaf' */
            leaf->end += range;
            pushMaxVal((__GLnamesBranch *) leaf, leaf->end);

            __GL_NAMES_UNLOCK(array);
            return lastUsed + 1;
        } else {
            /* Need to make new leaf */
            newleaf = allocLeaf(gc, array);

            newleaf->start = lastUsed + 1;
            newleaf->end = maxUsed;
            insertLeaf(gc, array, newleaf);

            __GL_NAMES_UNLOCK(array);
            return lastUsed + 1;
        }
    }
}

void FASTCALL __glNamesDeleteRange(__GLcontext *gc, __GLnamesArray *array,
                          GLuint name, GLsizei range)
{
    __GLnamesLeaf *leaf;
    /*LINTED nextleaf ok; lint doesn't understand for loops*/
    __GLnamesLeaf *nextleaf;
    __GLnamesLeaf *newleaf;
    void *empty;
    GLuint start, end, i;
    GLuint firstdel, lastdel;
    GLuint memoryProblem;

    if (range == 0) return;

    __GL_NAMES_LOCK(array);

    /*
    ** First we check for possible memory problems, since it will be
    ** difficult to back out once we start.  We note a possible problem,
    ** and check for it before fragmenting a leaf.
    */
    memoryProblem = 0;
    if (array->nbranches != __GL_DL_EXTRA_BRANCHES ||
            array->nleaves != __GL_DL_EXTRA_LEAVES) {
        memoryProblem = 1;
    }

    firstdel = name;
    lastdel = name+range-1;

    /*LINTED nextleaf ok; lint bug*/
    for (leaf = findLeaf(array, name, GL_FALSE); leaf != NULL;
            leaf = nextleaf) {
        nextleaf = nextLeaf(leaf);
        start = leaf->start;
        end = leaf->end;
        if (lastdel < start) break;
        if (firstdel > end) continue;

        if (firstdel > start) start = firstdel;
        if (lastdel < end) end = lastdel;

        /*
        ** Need to delete the range of lists from start to end.
        */
        if (leaf->dataList) {
            empty = array->dataInfo->empty;
            for (i=start; i<=end; i++) {
                if (leaf->dataList[i - leaf->start] != empty) {
                    (*leaf->dataInfo->free)(gc,
                        (void *)leaf->dataList[i - leaf->start]);
                    leaf->dataList[i - leaf->start] = empty;
                }
            }
        }

        if (start == leaf->start) {
            if (end == leaf->end) {
                /* Bye bye leaf! */
                deleteLeaf(gc, array, leaf);
                freeLeaf(gc, leaf);
            } else {
                /* Shrink leaf */
                resizeLeaf(gc, leaf, end+1, leaf->end);
            }
        } else if (end == leaf->end) {
            /* Shrink leaf */
            resizeLeaf(gc, leaf, leaf->start, start-1);
        } else {
            if (memoryProblem) {
                if (!fixMemoryProblem(gc, array)) {
                    __GL_NAMES_UNLOCK(array);
                    __glSetError(GL_OUT_OF_MEMORY);
                    return;
                }
            }
            /* Crud.  The middle of the leaf was deleted.  This is tough. */
            newleaf = allocLeaf(gc, array);

            newleaf->start = end+1;
            newleaf->end = leaf->end;
            if (leaf->dataList) {
                if (!allocLeafData(gc, newleaf)) {
                    /*
                    ** Darn!  We are in trouble.  This is a bad spot for an
                    ** out of memory error.  It is also darn unlikely,
                    ** because we just freed up some memory.
                    */
                    freeLeaf(gc, newleaf);
                    __GL_NAMES_UNLOCK(array);
                    __glSetError(GL_OUT_OF_MEMORY);
                    return;
                }
                copyLeafInfo(leaf, newleaf);
            }
            resizeLeaf(gc, leaf, leaf->start, start-1);
            insertLeaf(gc, array, newleaf);
            break;
        }
    }

    __GL_NAMES_UNLOCK(array);
}

GLboolean FASTCALL __glNamesIsName(__GLcontext *gc, __GLnamesArray *array,
                          GLuint name)
{
    GLboolean isName;

    __GL_NAMES_LOCK(array);

    /*
    ** If the name retrieves a leaf, it is in the current name space.
    */
    isName = findLeaf(array, name, GL_TRUE) != NULL;

    __GL_NAMES_UNLOCK(array);

    return isName;
}


/*
** Generates a list of (not necessarily contiguous) names.
*/
void FASTCALL __glNamesGenNames(__GLcontext *gc, __GLnamesArray *array,
                       GLsizei n, GLuint* names)
{
    GLuint start, nameVal;
    int i;

    if (NULL == names) return;

    start = __glNamesGenRange(gc, array, n);
    for (i=0, nameVal=start; i < n; i++, nameVal++) {
        names[i] = nameVal;
    }

}

/*
** Deletes a list of (not necessarily contiguous) names.
*/
void FASTCALL __glNamesDeleteNames(__GLcontext *gc, __GLnamesArray *array,
                          GLsizei n, const GLuint* names)
{
    GLuint start, rangeVal, i;

    /*
    ** Because of resizing leaves, etc, it is best to work in ranges
    ** as much as possible.  So break the list into ranges
    ** and delete them that way.  This degrades into deleting
    ** them one at a time if the list is disjoint or non-ascending.
    ** It also only calls DeleteRange once if the list is a
    ** contiguous range of names.
    */
    start = rangeVal = names[0];
    for (i=0; i < (GLuint)n; i++, rangeVal++) {
        if (names[i] != rangeVal) {
            __glNamesDeleteRange(gc,array,start,rangeVal-start);
            start = rangeVal = names[i];
        }
    }
    __glNamesDeleteRange(gc,array,start,rangeVal-start);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_math.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Mathematical subroutines needed by the GL.
**
** $Revision: 1.12 $
** $Date: 1993/12/11 01:03:25 $
*/
#include "precomp.h"
#pragma hdrstop

#include "xform.h"

#ifdef SGI
// SGIBUG None of the assembly routines copies matrixType!
#ifndef __GL_ASM_COPYMATRIX
/*
** Copy src to dst
*/
void FASTCALL __glCopyMatrix(__GLmatrix *dst, const __GLmatrix *src)
{
    dst->matrixType = src->matrixType;
    dst->matrix[0][0] = src->matrix[0][0];
    dst->matrix[0][1] = src->matrix[0][1];
    dst->matrix[0][2] = src->matrix[0][2];
    dst->matrix[0][3] = src->matrix[0][3];

    dst->matrix[1][0] = src->matrix[1][0];
    dst->matrix[1][1] = src->matrix[1][1];
    dst->matrix[1][2] = src->matrix[1][2];
    dst->matrix[1][3] = src->matrix[1][3];

    dst->matrix[2][0] = src->matrix[2][0];
    dst->matrix[2][1] = src->matrix[2][1];
    dst->matrix[2][2] = src->matrix[2][2];
    dst->matrix[2][3] = src->matrix[2][3];

    dst->matrix[3][0] = src->matrix[3][0];
    dst->matrix[3][1] = src->matrix[3][1];
    dst->matrix[3][2] = src->matrix[3][2];
    dst->matrix[3][3] = src->matrix[3][3];
}
#endif /*  __GL_ASM_COPYMATRIX */
#endif // SGI

/*
** Make m an identity matrix
*/
void FASTCALL __glMakeIdentity(__GLmatrix *m)
{
    __GLfloat zer = __glZero;
    __GLfloat one = ((__GLfloat) 1.0);;
    m->matrix[0][0] = one; m->matrix[0][1] = zer;
        m->matrix[0][2] = zer; m->matrix[0][3] = zer;
    m->matrix[1][0] = zer; m->matrix[1][1] = one;
        m->matrix[1][2] = zer; m->matrix[1][3] = zer;
    m->matrix[2][0] = zer; m->matrix[2][1] = zer;
        m->matrix[2][2] = one; m->matrix[2][3] = zer;
    m->matrix[3][0] = zer; m->matrix[3][1] = zer;
        m->matrix[3][2] = zer; m->matrix[3][3] = one;
    m->matrixType = __GL_MT_IDENTITY;
}


#ifndef __GL_ASM_MULTMATRIX
/*
** Compute r = a * b, where r can equal b.
*/
void FASTCALL __glMultMatrix(__GLmatrix *r, const __GLmatrix *a, const __GLmatrix *b)
{
    __GLfloat b00, b01, b02, b03;
    __GLfloat b10, b11, b12, b13;
    __GLfloat b20, b21, b22, b23;
    __GLfloat b30, b31, b32, b33;
    GLint i;

    b00 = b->matrix[0][0]; b01 = b->matrix[0][1];
        b02 = b->matrix[0][2]; b03 = b->matrix[0][3];
    b10 = b->matrix[1][0]; b11 = b->matrix[1][1];
        b12 = b->matrix[1][2]; b13 = b->matrix[1][3];
    b20 = b->matrix[2][0]; b21 = b->matrix[2][1];
        b22 = b->matrix[2][2]; b23 = b->matrix[2][3];
    b30 = b->matrix[3][0]; b31 = b->matrix[3][1];
        b32 = b->matrix[3][2]; b33 = b->matrix[3][3];

    for (i = 0; i < 4; i++) {
	r->matrix[i][0] = a->matrix[i][0]*b00 + a->matrix[i][1]*b10
	    + a->matrix[i][2]*b20 + a->matrix[i][3]*b30;
	r->matrix[i][1] = a->matrix[i][0]*b01 + a->matrix[i][1]*b11
	    + a->matrix[i][2]*b21 + a->matrix[i][3]*b31;
	r->matrix[i][2] = a->matrix[i][0]*b02 + a->matrix[i][1]*b12
	    + a->matrix[i][2]*b22 + a->matrix[i][3]*b32;
	r->matrix[i][3] = a->matrix[i][0]*b03 + a->matrix[i][1]*b13
	    + a->matrix[i][2]*b23 + a->matrix[i][3]*b33;
    }
}
#endif /*  __GL_ASM_MULTMATRIX */

#ifndef __GL_ASM_NORMALIZE
/*
** Normalize v into vout.
*/
void FASTCALL __glNormalize(__GLfloat vout[3], const __GLfloat v[3])
{
    __GLfloat len;

    len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
    if (__GL_FLOAT_LEZ(len)) 
    {
        vout[0] = __glZero;
        vout[1] = __glZero;
        vout[2] = __glZero;
        return;
    } else {
        if (len == ((__GLfloat) 1.0)) 
        {
	        vout[0] = v[0];
	        vout[1] = v[1];
	        vout[2] = v[2];
        } else {
	        len = ((__GLfloat) 1.0) / __GL_SQRTF(len);
	        vout[0] = v[0] * len;
	        vout[1] = v[1] * len;
	        vout[2] = v[2] * len;
        }
    }
}

#endif /* __GL_ASM_NORMALIZE */

#ifndef __GL_ASM_NORMAL_BATCH
/*
** Normalize normals in a polyarray.
*/
void FASTCALL __glNormalizeBatch(POLYARRAY *pa)
{
    POLYDATA *  const pdLast = pa->pdNextVertex;
    POLYDATA  *pd = pa->pd0;

    for (; pd < pdLast; pd++)
    {
        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            __GLcoord * const v   = &pd->normal;
            const __GLfloat len = v->x*v->x + v->y*v->y + v->z*v->z;
            if (__GL_FLOAT_LEZ(len)) 
            {
	            v->x = __glZero;
	            v->y = __glZero;
	            v->z = __glZero;
            } else 
            {
	            if (fabs(len - (GLfloat)1.0) > (__GLfloat) 0.0001) 
                {
                    const __GLfloat   tmp = ((__GLfloat)1.0) / __GL_SQRTF(len);
	                v->x = v->x * tmp;
	                v->y = v->y * tmp;
	                v->z = v->z * tmp;
	            }
            }
        }
    }
}
#endif /* __GL_ASM_NORMAL_BATCH */

/*
** inverse = invert(transpose(src))

This code uses Cramer's Rule to calculate the matrix inverse.
In general, the inverse transpose has this form:

[          ] -t    [                                   ]
[          ]       [             -t             -t t   ]
[  Q    P  ]       [   S(SQ - PT)     -(SQ - PT)  T    ]
[          ]       [                                   ]
[          ]       [                                   ]
[          ]    =  [                                   ]
[          ]       [        -1  t                      ]
[          ]       [     -(Q  P)             1         ]
[  T    S  ]       [   -------------   -------------   ]
[          ]       [         -1  t t         -1  t t   ]
[          ]       [   S - (Q  P) T    S - (Q  P) T    ]

But in the usual case that P,S == [0, 0, 0, 1], this is enough:

[          ] -t    [                                   ]
[          ]       [         -t              -t t      ]
[  Q    0  ]       [        Q              -Q  T       ]
[          ]       [                                   ]
[          ]       [                                   ]
[          ]    =  [                                   ]
[          ]       [                                   ]
[          ]       [                                   ]
[  T    1  ]       [        0                1         ]
[          ]       [                                   ]
[          ]       [                                   ]

*/
void FASTCALL __glInvertTransposeMatrix(__GLmatrix *inverse, const __GLmatrix *src)
{
    __GLfloat x00, x01, x02;
    __GLfloat x10, x11, x12;
    __GLfloat x20, x21, x22;
    __GLfloat rcp;

#ifdef NT
  // The matrix type of the inverse transpose is not necessarily the
  // same as that of the input.  Always set it to general here to
  // be safe.  The type can be refined later if necessary.
  inverse->matrixType = __GL_MT_GENERAL;
  if (src->matrixType)
#else
  /* propagate matrix type & branch if general */
  if (inverse->matrixType = src->matrixType)
#endif
  {
    __GLfloat z00, z01, z02;
    __GLfloat z10, z11, z12;
    __GLfloat z20, z21, z22;

    /* read 3x3 matrix into registers */
    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x02 = src->matrix[0][2];
    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x12 = src->matrix[1][2];
    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x22 = src->matrix[2][2];

    /* compute first three 2x2 cofactors */
    z20 = x01*x12 - x11*x02;
    z10 = x21*x02 - x01*x22;
    z00 = x11*x22 - x12*x21;

    /* compute 3x3 determinant & its reciprocal */
    rcp = x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
        return;
    rcp = (float)1/rcp;

    /* compute other six 2x2 cofactors */
    z01 = x20*x12 - x10*x22;
    z02 = x10*x21 - x20*x11;
    z11 = x00*x22 - x20*x02;
    z12 = x20*x01 - x00*x21;
    z21 = x10*x02 - x00*x12;
    z22 = x00*x11 - x10*x01;

    /* multiply all cofactors by reciprocal */
    inverse->matrix[0][0] = z00*rcp;
    inverse->matrix[0][1] = z01*rcp;
    inverse->matrix[0][2] = z02*rcp;
    inverse->matrix[1][0] = z10*rcp;
    inverse->matrix[1][1] = z11*rcp;
    inverse->matrix[1][2] = z12*rcp;
    inverse->matrix[2][0] = z20*rcp;
    inverse->matrix[2][1] = z21*rcp;
    inverse->matrix[2][2] = z22*rcp;

    /* read translation vector & negate */
    x00 = -src->matrix[3][0];
    x01 = -src->matrix[3][1];
    x02 = -src->matrix[3][2];

    /* store bottom row of inverse transpose */
    inverse->matrix[3][0] = 0;
    inverse->matrix[3][1] = 0;
    inverse->matrix[3][2] = 0;
    inverse->matrix[3][3] = 1;

    /* finish by tranforming translation vector */
    inverse->matrix[0][3] = inverse->matrix[0][0]*x00 +
			    inverse->matrix[0][1]*x01 +
			    inverse->matrix[0][2]*x02;
    inverse->matrix[1][3] = inverse->matrix[1][0]*x00 +
			    inverse->matrix[1][1]*x01 +
			    inverse->matrix[1][2]*x02;
    inverse->matrix[2][3] = inverse->matrix[2][0]*x00 +
			    inverse->matrix[2][1]*x01 +
			    inverse->matrix[2][2]*x02;

    if ((rcp <= ((float)1.0 + __GL_MATRIX_UNITY_SCALE_EPSILON)) &&
        (rcp >= ((float)1.0 - __GL_MATRIX_UNITY_SCALE_EPSILON))) {
        inverse->nonScaling = GL_TRUE;
    } else {
        inverse->nonScaling = GL_FALSE;
    }

  }
  else
  {
    __GLfloat x30, x31, x32;
    __GLfloat y01, y02, y03, y12, y13, y23;
    __GLfloat z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x30 = src->matrix[3][0];
    x31 = src->matrix[3][1];

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->matrix[0][2];
    x03 = src->matrix[0][3];
    x12 = src->matrix[1][2];
    x13 = src->matrix[1][3];
    x22 = src->matrix[2][2];
    x23 = src->matrix[2][3];
    x32 = src->matrix[3][2];
    x33 = src->matrix[3][3];

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x30 = src->matrix[3][0];
    x31 = src->matrix[3][1];

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
	return;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->matrix[0][0] = z00*rcp;
    inverse->matrix[0][1] = z01*rcp;
    inverse->matrix[1][0] = z10*rcp;
    inverse->matrix[0][2] = z02*rcp;
    inverse->matrix[2][0] = z20*rcp;
    inverse->matrix[0][3] = z03*rcp;
    inverse->matrix[3][0] = z30*rcp;
    inverse->matrix[1][1] = z11*rcp;
    inverse->matrix[1][2] = z12*rcp;
    inverse->matrix[2][1] = z21*rcp;
    inverse->matrix[1][3] = z13*rcp;
    inverse->matrix[3][1] = z31*rcp;
    inverse->matrix[2][2] = z22*rcp;
    inverse->matrix[2][3] = z23*rcp;
    inverse->matrix[3][2] = z32*rcp;
    inverse->matrix[3][3] = z33*rcp;

    if ((inverse->matrix[3][0] == __glZero) && 
        (inverse->matrix[3][1] == __glZero) &&
        (inverse->matrix[3][2] == __glZero)) {

        if (((rcp <= ((float)1.0 + __GL_MATRIX_UNITY_SCALE_EPSILON)) &&
            (rcp >= ((float)1.0 - __GL_MATRIX_UNITY_SCALE_EPSILON)))) {
            inverse->nonScaling = GL_TRUE;
        } else {
            inverse->nonScaling = GL_FALSE;
        }
        
    } else {
        inverse->nonScaling = GL_FALSE;        
    }
  }
}

/*
 * Find the 3x3 transpose of a matrix.  This is used to calculate the light
 * vector in object space for fast infinite lighting.
 */

void __glTranspose3x3(__GLmatrix *dst, __GLmatrix *src)
{

    __GLfloat x00, x01, x02;
    __GLfloat x10, x11, x12;
    __GLfloat x20, x21, x22;

    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x02 = src->matrix[0][2];

    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x12 = src->matrix[1][2];

    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x22 = src->matrix[2][2];

    dst->matrix[0][0] = x00;
    dst->matrix[1][0] = x01;
    dst->matrix[2][0] = x02;
    dst->matrix[3][0] = __glZero;

    dst->matrix[0][1] = x10;
    dst->matrix[1][1] = x11;
    dst->matrix[2][1] = x12;
    dst->matrix[3][1] = __glZero;

    dst->matrix[0][2] = x20;
    dst->matrix[1][2] = x21;
    dst->matrix[2][2] = x22;
    dst->matrix[3][2] = __glZero;

    dst->matrix[0][3] = __glZero;
    dst->matrix[1][3] = __glZero;
    dst->matrix[2][3] = __glZero;
    dst->matrix[3][3] = __glOne;
}

#ifdef NT

/*
** Return the closest integer log based 2 of a number
*/

static GLubyte logTab[256] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
                               4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                               5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                               5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};

GLint FASTCALL __glIntLog2(__GLfloat f)
{
    GLuint i = (GLuint) FTOL(f);

    if (i & 0xffff0000) {
        if (i & 0xff000000) {
            return ((GLint)logTab[i >> 24] + 24);
        } else {
            return ((GLint)logTab[i >> 16] + 16);
	}
    } else {
        if (i & 0xff00) {
            return ((GLint)logTab[i >> 8] + 8);
        } else {
            return ((GLint)logTab[i]);
        }
    }
}

#else

GLint __glIntLog2(__GLfloat f)
{
    return (GLint)(__GL_LOGF(f) * __GL_M_LN2_INV);
}

#endif

GLfloat FASTCALL __glClampf(GLfloat fval, __GLfloat zero, __GLfloat one)
{
    if (fval < zero) return zero;
    else if (fval > one) return one;
    else return fval;
}

/*
** r = vector from p1 to p2
*/
#ifndef __GL_ASM_VECSUB4
void FASTCALL __glVecSub4(__GLcoord *r,
                          const __GLcoord *p1, const __GLcoord *p2)
{
    __GLfloat oneOverW;

    if (p2->w == __glZero) {
	if (p1->w == __glZero) {
	    r->x = p2->x - p1->x;
	    r->y = p2->y - p1->y;
	    r->z = p2->z - p1->z;
	} else {
	    r->x = p2->x;
	    r->y = p2->y;
	    r->z = p2->z;
	}
    } else
    if (p1->w == __glZero) {
	r->x = -p1->x;
	r->y = -p1->y;
	r->z = -p1->z;
    } else{
	oneOverW = ((__GLfloat) 1.0) / p2->w;
	r->x = p2->x * oneOverW;
	r->y = p2->y * oneOverW;
	r->z = p2->z * oneOverW;
	oneOverW = ((__GLfloat) 1.0) / p1->w;
	r->x -= p1->x * oneOverW;
	r->y -= p1->y * oneOverW;
	r->z -= p1->z * oneOverW;
    }
}
#endif // !__GL_ASM_VECSUB4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_listc.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/23 00:34:54 $
*/
#include "precomp.h"
#pragma hdrstop

#include "listcomp.h"
#include "g_listop.h"
#include "lcfuncs.h"
#include "dlist.h"
#include "dlistopt.h"

#ifndef NT
// Move to dlist.
/*
** The code in here makes a lot of assumptions about the size of the 
** various user types (GLfloat, GLint, etcetra).  
*/

#define __GL_IMAGE_BITMAP	0
#define __GL_IMAGE_INDICES	1
#define __GL_IMAGE_RGBA		2

void __gllc_Bitmap(GLsizei width, GLsizei height,
		   GLfloat xorig, GLfloat yorig, 
		   GLfloat xmove, GLfloat ymove, 
		   const GLubyte *oldbits)
{
    __GLbitmap *bitmap;
    GLubyte *newbits;
    GLint imageSize;
    __GL_SETUP();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }

    imageSize = height * ((width + 7) >> 3);
    imageSize = __GL_PAD(imageSize);

    bitmap = (__GLbitmap *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(imageSize + sizeof(__GLbitmap)),
                                DLIST_GENERIC_OP(Bitmap));
    if (bitmap == NULL) return;

    bitmap->width = width;
    bitmap->height = height;
    bitmap->xorig = xorig;
    bitmap->yorig = yorig;
    bitmap->xmove = xmove;
    bitmap->ymove = ymove;
    bitmap->imageSize = imageSize;

    newbits = (GLubyte *)bitmap + sizeof(__GLbitmap); 
    __glFillImage(gc, width, height, GL_COLOR_INDEX, GL_BITMAP, 
                  oldbits, newbits);

    __glDlistAppendOp(gc, bitmap, __glle_Bitmap);
}

const GLubyte *__glle_Bitmap(const GLubyte *PC)
{
    const __GLbitmap *bitmap;
    __GL_SETUP();
    GLuint beginMode;

    bitmap = (const __GLbitmap *) PC;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return PC + sizeof(__GLbitmap) + bitmap->imageSize;
	}
    }

    (*gc->procs.renderBitmap)(gc, bitmap, (const GLubyte *) (bitmap+1));

    return PC + sizeof(__GLbitmap) + bitmap->imageSize;
}

void FASTCALL __gllei_PolygonStipple(__GLcontext *gc, const GLubyte *bits)
{
    if (__GL_IN_BEGIN()) {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }

    /* 
    ** Just copy bits into stipple, convertPolygonStipple() will do the rest.
    */
    __GL_MEMCOPY(&gc->state.polygonStipple.stipple[0], bits,
		 sizeof(gc->state.polygonStipple.stipple));
    (*gc->procs.convertPolygonStipple)(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
}

void __gllc_PolygonStipple(const GLubyte *mask)
{
    void *data;
    __GL_SETUP();
    GLubyte *newbits;

    newbits = (GLubyte *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(__glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP)),
                                DLIST_GENERIC_OP(PolygonStipple));
    if (newbits == NULL) return;

    __glFillImage(gc, 32, 32, GL_COLOR_INDEX, GL_BITMAP, mask, newbits);

    __glDlistAppendOp(gc, newbits, __glle_PolygonStipple);
}

const GLubyte *__glle_PolygonStipple(const GLubyte *PC)
{
    __GL_SETUP();

    __gllei_PolygonStipple(gc, (const GLubyte *) (PC));
    return PC + __glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP);
}

typedef struct __GLmap1_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     order;
        /*        points  */
} __GLmap1;

void __gllc_Map1f(GLenum target, 
		  GLfloat u1, GLfloat u2,
		  GLint stride, GLint order,
		  const GLfloat *points)
{
    __GLmap1 *map1data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();
    
    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (order > gc->constants.maxEvalOrder || stride < k ||
	    order < 1 || u1 == u2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap1) + 
	    __glMap1_size(k, order) * sizeof(__GLfloat);

    map1data = (__GLmap1 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map1));
    if (map1data == NULL) return;

    map1data->target = target;
    map1data->u1 = u1;
    map1data->u2 = u2;
    map1data->order = order;
    data = (__GLfloat *) ((GLubyte *)map1data + sizeof(__GLmap1));
    __glFillMap1f(k, order, stride, points, data);

    __glDlistAppendOp(gc, map1data, __glle_Map1);
}

const GLubyte *__glle_Map1(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLmap1 *map1data;
    GLint k;

    map1data = (const __GLmap1 *) PC;
    k = __glEvalComputeK(map1data->target);

    /* Stride of "k" matches internal stride */
#ifdef __GL_DOUBLE
    (*gc->dispatchState->dispatch->Map1d)
#else /* __GL_DOUBLE */
    (*gc->dispatchState->dispatch->Map1f)
#endif /* __GL_DOUBLE */
	    (map1data->target, map1data->u1, map1data->u2,
	    k, map1data->order, (const __GLfloat *)(PC + sizeof(__GLmap1)));

    return PC + sizeof(__GLmap1) + 
	    __glMap1_size(k, map1data->order) * sizeof(__GLfloat);
}

void __gllc_Map1d(GLenum target, 
		  GLdouble u1, GLdouble u2,
		  GLint stride, GLint order, 
		  const GLdouble *points)
{
    __GLmap1 *map1data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();
    
    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (order > gc->constants.maxEvalOrder || stride < k ||
	    order < 1 || u1 == u2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap1) + 
	    __glMap1_size(k, order) * sizeof(__GLfloat);

    map1data = (__GLmap1 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map1));
    if (map1data == NULL) return;

    map1data->target = target;
    map1data->u1 = u1;
    map1data->u2 = u2;
    map1data->order = order;
    data = (__GLfloat *) ((GLubyte *)map1data + sizeof(__GLmap1));
    __glFillMap1d(k, order, stride, points, data);

    __glDlistAppendOp(gc, map1data, __glle_Map1);
}

typedef struct __GLmap2_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     uorder;
        __GLfloat v1;
        __GLfloat v2;
        GLint     vorder;
        /*        points  */
} __GLmap2;

void __gllc_Map2f(GLenum target, 
		  GLfloat u1, GLfloat u2,
		  GLint ustride, GLint uorder, 
		  GLfloat v1, GLfloat v2,
		  GLint vstride, GLint vorder, 
		  const GLfloat *points)
{
    __GLmap2 *map2data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();

    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (vorder > gc->constants.maxEvalOrder || vstride < k ||
	    vorder < 1 || u1 == u2 || ustride < k ||
	    uorder > gc->constants.maxEvalOrder || uorder < 1 ||
	    v1 == v2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap2) + 
	    __glMap2_size(k, uorder, vorder) * sizeof(__GLfloat);

    map2data = (__GLmap2 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map2));
    if (map2data == NULL) return;

    map2data->target = target;
    map2data->u1 = u1;
    map2data->u2 = u2;
    map2data->uorder = uorder;
    map2data->v1 = v1;
    map2data->v2 = v2;
    map2data->vorder = vorder;

    data = (__GLfloat *) ((GLubyte *)map2data + sizeof(__GLmap2));
    __glFillMap2f(k, uorder, vorder, ustride, vstride, points, data);

    __glDlistAppendOp(gc, map2data, __glle_Map2);
}

const GLubyte *__glle_Map2(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLmap2 *map2data;
    GLint k;

    map2data = (const __GLmap2 *) PC;
    k = __glEvalComputeK(map2data->target);

    /* Stride of "k" and "k * vorder" matches internal strides */
#ifdef __GL_DOUBLE
    (*gc->dispatchState->dispatch->Map2d)
#else /* __GL_DOUBLE */
    (*gc->dispatchState->dispatch->Map2f)
#endif /* __GL_DOUBLE */
	    (map2data->target, 
	    map2data->u1, map2data->u2, k * map2data->vorder, map2data->uorder,
	    map2data->v1, map2data->v2, k, map2data->vorder,
	    (const __GLfloat *)(PC + sizeof(__GLmap2)));
    
    return PC + sizeof(__GLmap2) + 
	    __glMap2_size(k, map2data->uorder, map2data->vorder) * 
	    sizeof(__GLfloat);
}

void __gllc_Map2d(GLenum target, 
		  GLdouble u1, GLdouble u2,
                  GLint ustride, GLint uorder, 
		  GLdouble v1, GLdouble v2,
		  GLint vstride, GLint vorder, 
		  const GLdouble *points)
{
    __GLmap2 *map2data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();

    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (vorder > gc->constants.maxEvalOrder || vstride < k ||
	    vorder < 1 || u1 == u2 || ustride < k ||
	    uorder > gc->constants.maxEvalOrder || uorder < 1 ||
	    v1 == v2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap2) + 
	    __glMap2_size(k, uorder, vorder) * sizeof(__GLfloat);

    map2data = (__GLmap2 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map2));
    if (map2data == NULL) return;

    map2data->target = target;
    map2data->u1 = u1;
    map2data->u2 = u2;
    map2data->uorder = uorder;
    map2data->v1 = v1;
    map2data->v2 = v2;
    map2data->vorder = vorder;

    data = (__GLfloat *) ((GLubyte *)map2data + sizeof(__GLmap2));
    __glFillMap2d(k, uorder, vorder, ustride, vstride, points, data);

    __glDlistAppendOp(gc, map2data, __glle_Map2);
}

typedef struct __GLdrawPixels_Rec {
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        /*      pixels  */
} __GLdrawPixels;

const GLubyte *__glle_DrawPixels(const GLubyte *PC)
{
    const __GLdrawPixels *pixdata;
    GLint imageSize;
    __GL_SETUP();
    GLuint beginMode;

    pixdata = (const __GLdrawPixels *) PC;
    imageSize = __glImageSize(pixdata->width, pixdata->height, 
			      pixdata->format, pixdata->type);

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return PC + sizeof(__GLdrawPixels) + __GL_PAD(imageSize);
	}
    }

    (*gc->procs.drawPixels)(gc, pixdata->width, pixdata->height, 
			    pixdata->format, pixdata->type, 
			    (const GLubyte *)(PC + sizeof(__GLdrawPixels)), 
			    GL_TRUE);
    return PC + sizeof(__GLdrawPixels) + __GL_PAD(imageSize);
}

void __gllc_DrawPixels(GLint width, GLint height, GLenum format, 
		       GLenum type, const GLvoid *pixels)
{
    __GLdrawPixels *pixdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case GL_DEPTH_COMPONENT:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    pixdata = (__GLdrawPixels *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLdrawPixels) + imageSize),
                                DLIST_GENERIC_OP(DrawPixels));
    if (pixdata == NULL) return;

    pixdata->width = width;
    pixdata->height = height;
    pixdata->format = format;
    pixdata->type = type;

    __glFillImage(gc, width, height, format, type, pixels, 
                  (GLubyte *)pixdata + sizeof(__GLdrawPixels));

    __glDlistAppendOp(gc, pixdata, __glle_DrawPixels);
}

typedef struct __GLtexImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage1D;

const GLubyte *__glle_TexImage1D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexImage1D *data;

    data = (const __GLtexImage1D *) PC;
    __gllei_TexImage1D(gc, data->target, data->level, data->components, 
		       data->width, data->border, data->format, data->type, 
		       (const GLubyte *)(PC + sizeof(__GLtexImage1D)));

    return PC + sizeof(__GLtexImage1D) + __GL_PAD(data->imageSize);
}

typedef struct __GLtexImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLsizei height;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage2D;

const GLubyte *__glle_TexImage2D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexImage2D *data;

    data = (const __GLtexImage2D *) PC;
    __gllei_TexImage2D(gc, data->target, data->level, data->components, 
		       data->width, data->height, data->border, data->format, 
		       data->type,
		       (const GLubyte *)(PC + sizeof(__GLtexImage2D)));

    return PC + sizeof(__GLtexImage2D) + __GL_PAD(data->imageSize);
}

void __gllc_TexImage1D(GLenum target, GLint level, 
		       GLint components,
		       GLint width, GLint border, GLenum format, 
		       GLenum type, const GLvoid *pixels)
{
    __GLtexImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue(gc);
	return;
    }
    if (width < 0) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    if (target == GL_PROXY_TEXTURE_1D_EXT) {
	imageSize = 0;
    } else {
	imageSize = __glImageSize(width, 1, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage1D)+imageSize),
                                DLIST_GENERIC_OP(TexImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0 && pixels != NULL) {
        __glFillImage(gc, width, 1, format, type, pixels, 
                      (GLubyte *)texdata + sizeof(__GLtexImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage1D);
}

void __gllc_TexImage2D(GLenum target, GLint level, 
		       GLint components,
		       GLint width, GLint height, GLint border, 
		       GLenum format, GLenum type, 
		       const GLvoid *pixels)
{
    __GLtexImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue(gc);
	return;
    }
    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    if (target == GL_PROXY_TEXTURE_2D_EXT) {
	imageSize = 0;
    } else {
        imageSize = __glImageSize(width, height, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->height = height;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0 && pixels != NULL) {
        __glFillImage(gc, width, height, format, type, pixels, 
                      (GLubyte *) (GLubyte *)texdata + sizeof(__GLtexImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage2D);
}


typedef struct __GLtexSubImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLsizei width;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage1D;

const GLubyte *__glle_TexSubImage1D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexSubImage1D *data;

    data = (const __GLtexSubImage1D *) PC;
    __gllei_TexSubImage1D(gc, data->target, data->level, 
			     data->xoffset, data->width,
			     data->format, data->type, 
			  (const GLubyte *)(PC + sizeof(__GLtexSubImage1D)));
    return PC + sizeof(__GLtexSubImage1D) + __GL_PAD(data->imageSize);
}

void __gllc_TexSubImage1D(GLenum target, GLint level,
			     GLint xoffset, GLsizei width,
			     GLenum format, GLenum type, const GLvoid *pixels)
{
    __GLtexSubImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if (width < 0) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    imageSize = __glImageSize(width, 1, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage1D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->width = width;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, 1, format, type, pixels, 
		(GLubyte *)texdata + sizeof(__GLtexSubImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage1D);
}

typedef struct __GLtexSubImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLint   yoffset;
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage2D;

const GLubyte *__glle_TexSubImage2D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexSubImage2D *data;

    data = (const __GLtexSubImage2D *) PC;
    __gllei_TexSubImage2D(gc, data->target, data->level,
			     data->xoffset, data->yoffset,
			     data->width, data->height,
			     data->format, data->type,
		       (const GLubyte *)(PC + sizeof(__GLtexSubImage2D)));
    return PC + sizeof(__GLtexSubImage2D) + __GL_PAD(data->imageSize);
}

void __gllc_TexSubImage2D(GLenum target, GLint level,
			     GLint xoffset, GLint yoffset,
			     GLsizei width, GLsizei height,
			     GLenum format, GLenum type, const GLvoid *pixels)
{
    __GLtexSubImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->yoffset = yoffset;
    texdata->width = width;
    texdata->height = height;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, height, format, type, pixels, 
		(GLubyte *) texdata + sizeof(__GLtexSubImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage2D);
}
#endif // !NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_pick.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include "texture.h"

/*
** Determine if the alpha color component is needed.  If it's not needed
** then the renderers can avoid computing it.
*/
GLboolean FASTCALL __glNeedAlpha(__GLcontext *gc)
{
    if (gc->modes.colorIndexMode) {
        return GL_FALSE;
    }

    if (gc->state.enables.general & __GL_ALPHA_TEST_ENABLE) {
        return GL_TRUE;
    }
    if (gc->modes.alphaBits > 0) {
        return GL_TRUE;
    }

    if (gc->state.enables.general & __GL_BLEND_ENABLE) {
        GLint src = gc->state.raster.blendSrc;
        GLint dst = gc->state.raster.blendDst;
        /*
        ** See if one of the source alpha combinations are used.
        */
        if ((src == GL_SRC_ALPHA) ||
            (src == GL_ONE_MINUS_SRC_ALPHA) ||
            (src == GL_SRC_ALPHA_SATURATE) ||
            (dst == GL_SRC_ALPHA) ||
            (dst == GL_ONE_MINUS_SRC_ALPHA)) {
            return GL_TRUE;
        }
    }
    return GL_FALSE;
}

/************************************************************************/

/* these are depth test routines for C.. */
GLboolean (FASTCALL *__glCDTPixel[32])(__GLzValue, __GLzValue *) = {
    /* unsigned ops, no mask */
    __glDT_NEVER,
    __glDT_LESS,
    __glDT_EQUAL,
    __glDT_LEQUAL,
    __glDT_GREATER,
    __glDT_NOTEQUAL,
    __glDT_GEQUAL,
    __glDT_ALWAYS,
    /* unsigned ops, mask */
    __glDT_NEVER,
    __glDT_LESS_M,
    __glDT_EQUAL_M,
    __glDT_LEQUAL_M,
    __glDT_GREATER_M,
    __glDT_NOTEQUAL_M,
    __glDT_GEQUAL_M,
    __glDT_ALWAYS_M,
    /* unsigned ops, no mask */
    __glDT_NEVER,
    __glDT16_LESS,
    __glDT16_EQUAL,
    __glDT16_LEQUAL,
    __glDT16_GREATER,
    __glDT16_NOTEQUAL,
    __glDT16_GEQUAL,
    __glDT16_ALWAYS,
    /* unsigned ops, mask */
    __glDT_NEVER,
    __glDT16_LESS_M,
    __glDT16_EQUAL_M,
    __glDT16_LEQUAL_M,
    __glDT16_GREATER_M,
    __glDT16_NOTEQUAL_M,
    __glDT16_GEQUAL_M,
    __glDT16_ALWAYS_M,
};

#ifdef __GL_USEASMCODE
void (*__glSDepthTestPixel[16])(void) = {
    NULL,
    __glDTS_LESS,
    __glDTS_EQUAL,
    __glDTS_LEQUAL,
    __glDTS_GREATER,
    __glDTS_NOTEQUAL,
    __glDTS_GEQUAL,
    __glDTS_ALWAYS,
    NULL,
    __glDTS_LESS_M,
    __glDTS_EQUAL_M,
    __glDTS_LEQUAL_M,
    __glDTS_GREATER_M,
    __glDTS_NOTEQUAL_M,
    __glDTS_GEQUAL_M,
    __glDTS_ALWAYS_M,
};
#endif

/************************************************************************/

void FASTCALL __glGenericPickPointProcs(__GLcontext *gc)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    if (gc->renderMode == GL_FEEDBACK) 
    {
        gc->procs.renderPoint = __glFeedbackPoint;
        return;
    } 
    if (gc->renderMode == GL_SELECT) 
    {
        gc->procs.renderPoint = __glSelectPoint;
        return;
    } 
    if (gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE) 
    {
        if (gc->modes.colorIndexMode) 
        {
            gc->procs.renderPoint = __glRenderAntiAliasedCIPoint;
        } 
        else 
        {
            gc->procs.renderPoint = __glRenderAntiAliasedRGBPoint;
        }
        return;
    } 
    else if (gc->state.point.aliasedSize != 1) 
    {
        gc->procs.renderPoint = __glRenderAliasedPointN;
    } 
    else if (gc->texture.textureEnabled) 
    {
        gc->procs.renderPoint = __glRenderAliasedPoint1;
    } 
    else 
    {
        gc->procs.renderPoint = __glRenderAliasedPoint1_NoTex;
    }

#ifdef __BUGGY_RENDER_POINT
#ifdef NT
    if ((modeFlags & __GL_SHADE_CHEAP_FOG) &&
        !(modeFlags & __GL_SHADE_SMOOTH_LIGHT))
    {
        gc->procs.renderPoint2 = gc->procs.renderPoint;
        gc->procs.renderPoint = __glRenderFlatFogPoint;
    }
    else if (modeFlags & __GL_SHADE_SLOW_FOG)
    {
        gc->procs.renderPoint2 = gc->procs.renderPoint;
        gc->procs.renderPoint = __glRenderFlatFogPointSlow;
    }
#else
// SGIBUG the slow fog path does not compute vertex->fog value!
    if (((modeFlags & __GL_SHADE_CHEAP_FOG) &&
        !(modeFlags & __GL_SHADE_SMOOTH_LIGHT)) ||
        (modeFlags & __GL_SHADE_SLOW_FOG)) {
    gc->procs.renderPoint2 = gc->procs.renderPoint;
    gc->procs.renderPoint = __glRenderFlatFogPoint;
    }
#endif
#endif //__BUGGY_RENDER_POINT
}

#ifdef __GL_USEASMCODE
static void (*LDepthTestPixel[16])(void) = {
    NULL,
    __glDTP_LESS,
    __glDTP_EQUAL,
    __glDTP_LEQUAL,
    __glDTP_GREATER,
    __glDTP_NOTEQUAL,
    __glDTP_GEQUAL,
    __glDTP_ALWAYS,
    NULL,
    __glDTP_LESS_M,
    __glDTP_EQUAL_M,
    __glDTP_LEQUAL_M,
    __glDTP_GREATER_M,
    __glDTP_NOTEQUAL_M,
    __glDTP_GEQUAL_M,
    __glDTP_ALWAYS_M,
};
#endif

void FASTCALL __glGenericPickRenderBitmapProcs(__GLcontext *gc)
{
    gc->procs.renderBitmap = __glRenderBitmap;
}

void FASTCALL __glGenericPickClipProcs(__GLcontext *gc)
{
    gc->procs.clipTriangle = __glClipTriangle;
}

void FASTCALL __glGenericPickTextureProcs(__GLcontext *gc)
{
    __GLtexture *current;
    __GLtextureParamState *params;

#ifdef NT
    /* Pick coordinate generation function */
    if ((gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) &&
    (gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) &&
    !(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) &&
    !(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE) &&
    (gc->state.texture.s.mode == gc->state.texture.t.mode))
    {
    /* Use a special function when both modes are enabled and identical */
    if (gc->state.texture.s.mode == GL_SPHERE_MAP)
    {
        gc->procs.paCalcTexture = PolyArrayCalcSphereMap;
    }
    else
    {
        __GLcoord *cs, *ct;

        cs = &gc->state.texture.s.eyePlaneEquation;
        ct = &gc->state.texture.t.eyePlaneEquation;
        if (cs->x == ct->x && cs->y == ct->y
         && cs->z == ct->z && cs->w == ct->w)
        {
        if (gc->state.texture.s.mode == GL_EYE_LINEAR)
            gc->procs.paCalcTexture = PolyArrayCalcEyeLinearSameST;
        else
            gc->procs.paCalcTexture = PolyArrayCalcObjectLinearSameST;
        }
        else
        {
        if (gc->state.texture.s.mode == GL_EYE_LINEAR)
            gc->procs.paCalcTexture = PolyArrayCalcEyeLinear;
        else
            gc->procs.paCalcTexture = PolyArrayCalcObjectLinear;
        }
    }
    }
    else
    {
    if (gc->state.enables.general & (__GL_TEXTURE_GEN_S_ENABLE |
                                     __GL_TEXTURE_GEN_T_ENABLE |
                                     __GL_TEXTURE_GEN_R_ENABLE |
                                     __GL_TEXTURE_GEN_Q_ENABLE))
        /* Use fast function when both are disabled */
        gc->procs.paCalcTexture = PolyArrayCalcMixedTexture;
    else
        gc->procs.paCalcTexture = PolyArrayCalcTexture;
    }
#else
    /* Pick coordinate generation function */
    if ((gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) &&
	(gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) &&
	!(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) &&
	!(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE) &&
	(gc->state.texture.s.mode == gc->state.texture.t.mode)) {
	/* Use a special function when both modes are enabled and identical */
	switch (gc->state.texture.s.mode) {
	  case GL_EYE_LINEAR:
	    gc->procs.calcTexture = __glCalcEyeLinear;
	    break;
	  case GL_OBJECT_LINEAR:
	    gc->procs.calcTexture = __glCalcObjectLinear;
	    break;
	  case GL_SPHERE_MAP:
	    gc->procs.calcTexture = __glCalcSphereMap;
	    break;
	}
    } else {
	if (!(gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) &&
	    !(gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) &&
	    !(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) &&
	    !(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE)) {
	    /* Use fast function when both are disabled */
	    gc->procs.calcTexture = __glCalcTexture;
	} else {
	    gc->procs.calcTexture = __glCalcMixedTexture;
	}
    }
#endif // NT

    gc->texture.currentTexture = current = 0;
    if (gc->state.enables.general & __GL_TEXTURE_2D_ENABLE) {
    if (__glIsTextureConsistent(gc, GL_TEXTURE_2D)) {
        params = __glLookUpTextureParams(gc, GL_TEXTURE_2D);
        gc->texture.currentTexture =
        current = __glLookUpTexture(gc, GL_TEXTURE_2D);
    }
    } else
    if (gc->state.enables.general & __GL_TEXTURE_1D_ENABLE) {
    if (__glIsTextureConsistent(gc, GL_TEXTURE_1D)) {
        params = __glLookUpTextureParams(gc, GL_TEXTURE_1D);
        gc->texture.currentTexture =
        current = __glLookUpTexture(gc, GL_TEXTURE_1D);
    }
    } else {
    current = NULL;
    }

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, TEXTURE);
#endif

    /* Pick texturing function for the current texture */
    if (current) {
    GLenum baseFormat;

/* XXX most of this should be bound into the texture param code, right? */
        current->params = *params;

    /*
    ** Figure out if mipmapping is being used.  If not, then the
    ** rho computations can be avoided as there is only one texture
    ** to choose from.
    */
    gc->procs.calcLineRho = __glComputeLineRho;
    gc->procs.calcPolygonRho = __glComputePolygonRho;
    if ((current->params.minFilter == GL_LINEAR)
        || (current->params.minFilter == GL_NEAREST)) {
        /* No mipmapping needed */
        if (current->params.minFilter == current->params.magFilter) {
        /* No rho needed as min/mag application is identical */
        current->textureFunc = __glFastTextureFragment;
        gc->procs.calcLineRho = __glNopLineRho;
        gc->procs.calcPolygonRho = __glNopPolygonRho;
        } else {
        current->textureFunc = __glTextureFragment;

        /*
        ** Pre-calculate min/mag switchover point.  The rho calculation
        ** doesn't perform a square root (ever).  Consequently, these
        ** constants are squared.
        */
        if ((current->params.magFilter == GL_LINEAR) &&
            ((current->params.minFilter == GL_NEAREST_MIPMAP_NEAREST) ||
             (current->params.minFilter == GL_LINEAR_MIPMAP_NEAREST))) {
            current->c = ((__GLfloat) 2.0);
        } else {
            current->c = __glOne;
        }
        }
    } else {
        current->textureFunc = __glMipMapFragment;

        /*
        ** Pre-calculate min/mag switchover point.  The rho
        ** calculation doesn't perform a square root (ever).
        ** Consequently, these constants are squared.
        */
        if ((current->params.magFilter == GL_LINEAR) &&
        ((current->params.minFilter == GL_NEAREST_MIPMAP_NEAREST) ||
         (current->params.minFilter == GL_LINEAR_MIPMAP_NEAREST))) {
        current->c = ((__GLfloat) 2.0);
        } else {
        current->c = __glOne;
        }
    }

    /* Pick environment function */
    baseFormat = current->level[0].baseFormat;
    switch (gc->state.texture.env[0].mode) {
      case GL_MODULATE:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glTextureModulateL;
        break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glTextureModulateLA;
        break;
          case GL_RGB:
        current->env = __glTextureModulateRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureModulateRGBA;
        break;
          case GL_ALPHA:
        current->env = __glTextureModulateA;
        break;
          case GL_INTENSITY:
        current->env = __glTextureModulateI;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
      case GL_DECAL:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glNopGCCOLOR;
                break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glNopGCCOLOR;
                break;
          case GL_RGB:
        current->env = __glTextureDecalRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureDecalRGBA;
        break;
          case GL_ALPHA:
        current->env = __glNopGCCOLOR;
        break;
          case GL_INTENSITY:
        current->env = __glNopGCCOLOR;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
      case GL_BLEND:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glTextureBlendL;
                break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glTextureBlendLA;
        break;
          case GL_RGB:
        current->env = __glTextureBlendRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureBlendRGBA;
        break;
          case GL_ALPHA:
        current->env = __glTextureBlendA;
        break;
          case GL_INTENSITY:
        current->env = __glTextureBlendI;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
      case GL_REPLACE:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glTextureReplaceL;
        break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glTextureReplaceLA;
        break;
          case GL_RGB:
        current->env = __glTextureReplaceRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureReplaceRGBA;
        break;
          case GL_ALPHA:
        current->env = __glTextureReplaceA;
        break;
          case GL_INTENSITY:
        current->env = __glTextureReplaceI;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
#ifdef NT
        default:
            ASSERTOPENGL(FALSE, "Unexpected texture mode\n");
            break;
#endif
    }

    /* Pick mag/min functions */
    switch (current->dim) {
      case 1:
        current->nearest = __glNearestFilter1;
        current->linear = __glLinearFilter1;
        break;
      case 2:
        current->nearest = __glNearestFilter2;
        current->linear = __glLinearFilter2;

        // Accelerate BGR{A}8 case when wrap modes are both REPEAT
        if( (current->params.sWrapMode == GL_REPEAT) &&
            (current->params.tWrapMode == GL_REPEAT)
          )
        {
            __GLmipMapLevel *lp = &current->level[0];

            if( lp->extract == __glExtractTexelBGR8 ) 
             current->linear = __glLinearFilter2_BGR8Repeat;
            else if( lp->extract == __glExtractTexelBGRA8 ) 
	            current->linear = __glLinearFilter2_BGRA8Repeat;
        }
        break;
    }

    /* set mag filter function */
    switch (current->params.magFilter) {
      case GL_LINEAR:
        current->magnify = __glLinearFilter;
        break;
      case GL_NEAREST:
        current->magnify = __glNearestFilter;
        break;
    }

    /* set min filter function */
    switch (current->params.minFilter) {
      case GL_LINEAR:
        current->minnify = __glLinearFilter;
        break;
      case GL_NEAREST:
        current->minnify = __glNearestFilter;
        break;
      case GL_NEAREST_MIPMAP_NEAREST:
        current->minnify = __glNMNFilter;
        break;
      case GL_LINEAR_MIPMAP_NEAREST:
        current->minnify = __glLMNFilter;
        break;
      case GL_NEAREST_MIPMAP_LINEAR:
        current->minnify = __glNMLFilter;
        break;
      case GL_LINEAR_MIPMAP_LINEAR:
        current->minnify = __glLMLFilter;
        break;
    }

    gc->procs.texture = current->textureFunc;
    } else {
    gc->procs.texture = 0;
    }
}


void FASTCALL __glGenericPickFogProcs(__GLcontext *gc)
{
#ifdef GL_WIN_specular_fog
    /*
    ** If specular shading is on, coerce the fog sub-system to go through
    ** DONT_CARE path. Disregard the GL_NICEST hint!!!
    */
#endif //GL_WIN_specular_fog

    if ((gc->state.enables.general & __GL_FOG_ENABLE) 
#ifdef GL_WIN_specular_fog
        || (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG) 
#endif //GL_WIN_specular_fog
        )
    {
        if ((gc->state.hints.fog == GL_NICEST) 
#ifdef GL_WIN_specular_fog
            && !(gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG) 
#endif //GL_WIN_specular_fog
            ) 
        {
            gc->procs.fogVertex = 0;    /* Better not be called */
        } 
        else 
        {
            if (gc->state.fog.mode == GL_LINEAR) 
                gc->procs.fogVertex = __glFogVertexLinear;
            else
                gc->procs.fogVertex = __glFogVertex;
        }
        gc->procs.fogPoint = __glFogFragmentSlow;
        gc->procs.fogColor = __glFogColorSlow;
    } 
    else 
    {
        gc->procs.fogVertex = 0;
        gc->procs.fogPoint = 0;
        gc->procs.fogColor = 0;
    }
}

void FASTCALL __glGenericPickBufferProcs(__GLcontext *gc)
{
    GLint i;
    __GLbufferMachine *buffers;

    buffers = &gc->buffers;
    buffers->doubleStore = GL_FALSE;

    /* Set draw buffer pointer */
    switch (gc->state.raster.drawBuffer) {
      case GL_FRONT:
    gc->drawBuffer = gc->front;
    break;
      case GL_FRONT_AND_BACK:
    if (gc->modes.doubleBufferMode) {
        gc->drawBuffer = gc->back;
        buffers->doubleStore = GL_TRUE;
    } else {
        gc->drawBuffer = gc->front;
    }
    break;
      case GL_BACK:
    gc->drawBuffer = gc->back;
    break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
    i = gc->state.raster.drawBuffer - GL_AUX0;
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    gc->drawBuffer = &gc->auxBuffer[i];
#endif
    break;
    }
}

void FASTCALL __glGenericPickPixelProcs(__GLcontext *gc)
{
    __GLpixelTransferMode *tm;
    __GLpixelMachine *pm;
    GLboolean mapColor;
    GLfloat red, green, blue, alpha;
    GLint entry;
    GLuint enables = gc->state.enables.general;
    __GLpixelMapHead *pmap;
    GLint i;

    /* Set read buffer pointer */
    switch (gc->state.pixel.readBuffer) {
      case GL_FRONT:
    gc->readBuffer = gc->front;
    break;
      case GL_BACK:
    gc->readBuffer = gc->back;
    break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
    i = gc->state.pixel.readBuffer - GL_AUX0;
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    gc->readBuffer = &gc->auxBuffer[i];
#endif
    break;
    }

    if (gc->texture.textureEnabled
        || (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)) {
    gc->procs.pxStore = __glSlowDrawPixelsStore;
    } else {
    gc->procs.pxStore = gc->procs.store;
    }

    tm = &gc->state.pixel.transferMode;
    pm = &(gc->pixel);
    mapColor = tm->mapColor;
    if (mapColor || gc->modes.rgbMode || tm->indexShift || tm->indexOffset) {
    pm->iToICurrent = GL_FALSE;
    pm->iToRGBACurrent = GL_FALSE;
    pm->modifyCI = GL_TRUE;
    } else {
    pm->modifyCI = GL_FALSE;
    }
    if (tm->mapStencil || tm->indexShift || tm->indexOffset) {
    pm->modifyStencil = GL_TRUE;
    } else {
    pm->modifyStencil = GL_FALSE;
    }
    if (tm->d_scale != __glOne || tm->d_bias) {
    pm->modifyDepth = GL_TRUE;
    } else {
    pm->modifyDepth = GL_FALSE;
    }
    if (mapColor || tm->r_bias || tm->g_bias || tm->b_bias || tm->a_bias ||
    tm->r_scale != __glOne || tm->g_scale != __glOne ||
    tm->b_scale != __glOne || tm->a_scale != __glOne) {
    pm->modifyRGBA = GL_TRUE;
    pm->rgbaCurrent = GL_FALSE;
    } else {
    pm->modifyRGBA = GL_FALSE;
    }

    if (pm->modifyRGBA) {
    /* Compute default values for red, green, blue, alpha */
    red = gc->state.pixel.transferMode.r_bias;
    green = gc->state.pixel.transferMode.g_bias;
    blue = gc->state.pixel.transferMode.b_bias;
    alpha = gc->state.pixel.transferMode.a_scale +
        gc->state.pixel.transferMode.a_bias;
    if (mapColor) {
        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
        entry = (GLint)(red * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        red = pmap->base.mapF[entry];

        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
        entry = (GLint)(green * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        green = pmap->base.mapF[entry];

        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
        entry = (GLint)(blue * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        blue = pmap->base.mapF[entry];

        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
        entry = (GLint)(alpha * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        alpha = pmap->base.mapF[entry];
    } else {
        if (red > __glOne) red = __glOne;
        else if (red < 0) red = 0;
        if (green > __glOne) green = __glOne;
        else if (green < 0) green = 0;
        if (blue > __glOne) blue = __glOne;
        else if (blue < 0) blue = 0;
        if (alpha > __glOne) alpha = __glOne;
        else if (alpha < 0) alpha = 0;
    }
    pm->red0Mod = red * gc->frontBuffer.redScale;
    pm->green0Mod = green * gc->frontBuffer.greenScale;
    pm->blue0Mod = blue * gc->frontBuffer.blueScale;
    pm->alpha1Mod = alpha * gc->frontBuffer.alphaScale;
    } else {
    pm->red0Mod = __glZero;
    pm->green0Mod = __glZero;
    pm->blue0Mod = __glZero;
    pm->alpha1Mod = gc->frontBuffer.alphaScale;
    }

    gc->procs.drawPixels = __glSlowPickDrawPixels;
    gc->procs.readPixels = __glSlowPickReadPixels;
    gc->procs.copyPixels = __glSlowPickCopyPixels;
}

/*
** pick the depth function pointers
*/
int FASTCALL __glGenericPickDepthProcs(__GLcontext *gc)
{
    GLint   depthIndex;

    depthIndex = gc->state.depth.testFunc - GL_NEVER;

    if (gc->modes.depthBits && gc->modes.haveDepthBuffer) {
        if (gc->state.depth.writeEnable == GL_FALSE)
            depthIndex += 8;

        if (gc->depthBuffer.buf.elementSize == 2)
            depthIndex += 16;
    } else {
        /*
        ** No depthBits so force StoreALWAYS_W, _glDT_ALWAYS_M, etc.
        */
        depthIndex = (GL_ALWAYS - GL_NEVER) + 8;
    }

    (*gc->depthBuffer.pick)(gc, &gc->depthBuffer, depthIndex);

    gc->procs.DTPixel = __glCDTPixel[depthIndex];
#ifdef __GL_USEASMCODE
    gc->procs.span.depthTestPixel = __glSDepthTestPixel[depthIndex];
    gc->procs.line.depthTestPixel = __glPDepthTestPixel[depthIndex];

    if( gc->procs.line.depthTestLine ) {
    if( __glDTLine[depthIndex] ) {
        *(gc->procs.line.depthTestLine) = __glDTLine[depthIndex];
    } else {
        /*
        ** If this happens, it may mean one of two things:
        ** (a) __glDTLine is malformed
        ** (b) A device-dependent line picker was a bit careless.
        **     This will probably happen if that implementation is
        **     not using the slow path.  
        **  Eg: For NEWPORT, AA depth lines go through slow path,
        **  but non-AA depth lines have a fast path.  When switching
        **  to a non-AA path, we may end up here, but that's ok, since
        **  we are not using the slow path.  If that is about to happen,
        **  the line picker will be reinvoked.
        */

        /*
        ** use some generic function here that will work
        */
        *(gc->procs.line.depthTestLine) = __glDepthTestLine_asm;
    }
    }
#endif

    return depthIndex;
}

void FASTCALL __glGenericValidate(__GLcontext *gc)
{
    (*gc->procs.pickAllProcs)(gc);
}

void FASTCALL __glGenericPickAllProcs(__GLcontext *gc)
{
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = 0;

    if (gc->dirtyMask & (__GL_DIRTY_TEXTURE | __GL_DIRTY_GENERIC)) {
        /* 
        ** Set textureEnabled flag early on, so we can set modeFlags
        ** based upon it.
        */
        (*gc->procs.pickTextureProcs)(gc);
        gc->texture.textureEnabled = gc->modes.rgbMode
          && gc->texture.currentTexture;
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LIGHTING)) {

#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif

        // Check and see whether the current texturing settings will
        // completely replace the polygon color
        if (gc->texture.textureEnabled &&
#ifdef GL_EXT_flat_paletted_lighting
            (enables & __GL_PALETTED_LIGHTING_ENABLE) == 0 &&
#endif
            gc->state.texture.env[0].mode == GL_REPLACE &&
            (gc->texture.currentTexture->level[0].baseFormat == GL_RGBA ||
             gc->texture.currentTexture->level[0].baseFormat == GL_INTENSITY ||
             gc->texture.currentTexture->level[0].baseFormat ==
             GL_LUMINANCE_ALPHA ||
             ((enables & __GL_BLEND_ENABLE) == 0 &&
              (gc->texture.currentTexture->level[0].baseFormat ==
               GL_LUMINANCE ||
               gc->texture.currentTexture->level[0].baseFormat == GL_RGB)))) 
        {
            modeFlags |= __GL_SHADE_FULL_REPLACE_TEXTURE;
        }
    }

    /* Compute shading mode flags before triangle, span, and line picker */
    if (gc->modes.rgbMode) {
        modeFlags |= __GL_SHADE_RGB;
        if (gc->texture.textureEnabled) {
            modeFlags |= __GL_SHADE_TEXTURE;
        }
        if (enables & __GL_BLEND_ENABLE) {
            modeFlags |= __GL_SHADE_BLEND;
        }
        if (enables & __GL_ALPHA_TEST_ENABLE) {
            modeFlags |= __GL_SHADE_ALPHA_TEST;
        }
        if (enables & __GL_COLOR_LOGIC_OP_ENABLE) {
            modeFlags |= __GL_SHADE_LOGICOP;
        }
        if (!gc->state.raster.rMask ||
            !gc->state.raster.gMask ||
            !gc->state.raster.bMask
#ifndef NT
            // NT doesn't support destination alpha so there's no point
            // in worrying about the alpha mask since we'll never write
            // alpha values anyway
            || !gc->state.raster.aMask
#endif
            )
        {
            modeFlags |= __GL_SHADE_MASK;
        }
    } else {
        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            modeFlags |= __GL_SHADE_LOGICOP;
        }
        if (gc->state.raster.writeMask != __GL_MASK_INDEXI(gc, ~0)) {
            modeFlags |= __GL_SHADE_MASK;
        }
    }

    if (gc->state.light.shadingModel == GL_SMOOTH) {
        modeFlags |= __GL_SHADE_SMOOTH | __GL_SHADE_SMOOTH_LIGHT;

#ifdef GL_WIN_phong_shading
    } else if (gc->state.light.shadingModel == GL_PHONG_WIN) {
        if (enables & __GL_LIGHTING_ENABLE)
            modeFlags |= __GL_SHADE_PHONG;
        else
            modeFlags |= __GL_SHADE_SMOOTH | __GL_SHADE_SMOOTH_LIGHT;
#endif //GL_WIN_phong_shading
    }

    if ((enables & __GL_DEPTH_TEST_ENABLE) && 
        gc->modes.haveDepthBuffer) {
        modeFlags |= ( __GL_SHADE_DEPTH_TEST |  __GL_SHADE_DEPTH_ITER );
    }
    if (enables & __GL_CULL_FACE_ENABLE) {
        modeFlags |= __GL_SHADE_CULL_FACE;
    }
    if (enables & __GL_DITHER_ENABLE) {
        modeFlags |= __GL_SHADE_DITHER;
    }
    if (enables & __GL_POLYGON_STIPPLE_ENABLE) {
        modeFlags |= __GL_SHADE_STIPPLE;
    }
    if (enables & __GL_LINE_STIPPLE_ENABLE) {
        modeFlags |= __GL_SHADE_LINE_STIPPLE;
    }
    if ((enables & __GL_STENCIL_TEST_ENABLE) && 
        gc->modes.haveStencilBuffer) {
        modeFlags |= __GL_SHADE_STENCIL_TEST;
    }
    if ((enables & __GL_LIGHTING_ENABLE) && 
        gc->state.light.model.twoSided) {
        modeFlags |= __GL_SHADE_TWOSIDED;
    }

#ifdef GL_WIN_specular_fog
    /*
    ** Specularly lit textures using fog only if: 
    ** -- Lighting is enabled
    ** -- Texturing is enabled
    ** -- Texturing mode is GL_MODULATE
    ** -- Lighting calculation is not skipped
    ** -- No two sided lighting
    */
    if (
        (gc->state.texture.env[0].mode == GL_MODULATE) &&
        (enables &  __GL_FOG_SPEC_TEX_ENABLE) &&
        (enables & __GL_LIGHTING_ENABLE) &&
        !(modeFlags & __GL_SHADE_TWOSIDED) &&
         (modeFlags & __GL_SHADE_TEXTURE) &&
        !(
          (modeFlags & __GL_SHADE_FULL_REPLACE_TEXTURE) &&
          (gc->renderMode == GL_RENDER)
          )
        )
    {
        modeFlags |= __GL_SHADE_SPEC_FOG;
        modeFlags |= __GL_SHADE_INTERP_FOG;
    }
#endif //GL_WIN_specular_fog

    if (enables & __GL_FOG_ENABLE) 
    {
        /* Figure out type of fogging to do.  Try to do cheap fog */
        if (!(modeFlags & __GL_SHADE_TEXTURE) &&
#ifdef GL_WIN_phong_shading
            !(modeFlags & __GL_SHADE_PHONG) &&
#endif //GL_WIN_phong_shading
            (gc->state.hints.fog != GL_NICEST)) {
            /*
            #ifdef NT
            ** Cheap fog can be done.  Now figure out which kind we
            ** will do.  If smooth shading, its easy - just update
            ** the color in DrawPolyArray.  Otherwise, set has flag
            ** later on to use smooth shading to do flat shaded fogging.
            #else
            ** Cheap fog can be done.  Now figure out which kind we
            ** will do.  If smooth shading, its easy - just change
            ** the calcColor proc (let the color proc picker do it).
            ** Otherwise, set has flag later on to use smooth shading
            ** to do flat shaded fogging.
            #endif
            */
            modeFlags |= __GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH;
        } else {
            /* Use slowest fog mode */
            modeFlags |= __GL_SHADE_SLOW_FOG;

            if ((gc->state.hints.fog == GL_NICEST) 
#ifdef GL_WIN_specular_fog
                && (!(modeFlags & __GL_SHADE_SPEC_FOG))
#endif //GL_WIN_specular_fog
                )
            {
                modeFlags |= __GL_SHADE_COMPUTE_FOG;
            }
            else
            {
                modeFlags |= __GL_SHADE_INTERP_FOG;
            }
        }
    }
    gc->polygon.shader.modeFlags = modeFlags;

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LIGHTING)) {
        (*gc->front->pick)(gc, gc->front);
        if (gc->modes.doubleBufferMode) {
            (*gc->back->pick)(gc, gc->back);
        }
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
        {
            GLint i;

            for (i = 0; i < gc->modes.maxAuxBuffers; i++) {
                (*gc->auxBuffer[i].pick)(gc, &gc->auxBuffer[i]);
            }
        }
#endif
        if (gc->modes.haveStencilBuffer) {
            (*gc->stencilBuffer.pick)(gc, &gc->stencilBuffer);
        }
        (*gc->procs.pickBufferProcs)(gc);

        /* 
        ** Note: Must call gc->front->pick and gc->back->pick before calling
        ** pickStoreProcs.  This also must be called prior to line, point, 
        ** polygon, clipping, or bitmap pickers.  The LIGHT implementation
        ** depends upon it.
        */
        (*gc->procs.pickStoreProcs)(gc);

#ifdef NT
        /*
        ** Compute the color material change bits before lighting since
        ** __glValidateLighting calls ComputeMaterialState.
        */
        ComputeColorMaterialChange(gc);
#endif

        __glValidateLighting(gc);
        
        /*
        ** Note: pickColorMaterialProcs is called frequently outside of this
        ** generic picking routine.
        */
        (*gc->procs.pickColorMaterialProcs)(gc);
        
        (*gc->procs.pickBlendProcs)(gc);
        (*gc->procs.pickFogProcs)(gc);
        
        (*gc->procs.pickParameterClipProcs)(gc);
        (*gc->procs.pickClipProcs)(gc);
        
        /*
        ** Needs to be done after pickStoreProcs.
        */
        (*gc->procs.pickRenderBitmapProcs)(gc);
        
        if (gc->validateMask & __GL_VALIDATE_ALPHA_FUNC) {
            __glValidateAlphaTest(gc);
        }
    }

#ifdef NT
    // Compute paNeeds flags PANEEDS_TEXCOORD, PANEEDS_NORMAL,
    // PANEEDS_RASTERPOS_NORMAL, PANEEDS_CLIP_ONLY, and PANEEDS_SKIP_LIGHTING.

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LIGHTING)) 
    {
        GLuint paNeeds;

        paNeeds = gc->vertex.paNeeds;
        paNeeds &= ~(PANEEDS_TEXCOORD | PANEEDS_NORMAL |
                     PANEEDS_RASTERPOS_NORMAL | PANEEDS_CLIP_ONLY |
                     PANEEDS_SKIP_LIGHTING);

        // Compute PANEEDS_SKIP_LIGHTING flag.
        // If we're rendering with a replace mode texture which fills all
        // the color components then lighting is unnecessary in most cases.
        if ((modeFlags & __GL_SHADE_FULL_REPLACE_TEXTURE) &&
            (gc->renderMode == GL_RENDER))
            paNeeds |= PANEEDS_SKIP_LIGHTING;
        
        // Compute PANEEDS_TEXCOORD.
        // Feedback needs texture coordinates when the feedback type is
        // GL_3D_COLOR_TEXTURE or GL_4D_COLOR_TEXTURE whether or not it is
        // enabled.
        if (gc->texture.textureEnabled || gc->renderMode == GL_FEEDBACK)
            paNeeds |= PANEEDS_TEXCOORD;

        // Compute PANEEDS_NORMAL.
#ifdef NEW_NORMAL_PROCESSING
	if(enables & __GL_LIGHTING_ENABLE && 
       !(paNeeds & PANEEDS_SKIP_LIGHTING)) // uses PANEEDS_SKIP_LIGHTING computed above
        paNeeds |= PANEEDS_NORMAL;
    if (
        ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	    && (enables & __GL_TEXTURE_GEN_S_ENABLE)
	    && (gc->state.texture.s.mode == GL_SPHERE_MAP))
	    ||
	    ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	    && (enables & __GL_TEXTURE_GEN_T_ENABLE)
	    && (gc->state.texture.t.mode == GL_SPHERE_MAP))
	   )
        paNeeds |= PANEEDS_NORMAL_FOR_TEXTURE;
#else
	if
	(
	    ((enables & __GL_LIGHTING_ENABLE)
	  && !(paNeeds & PANEEDS_SKIP_LIGHTING)) // uses PANEEDS_SKIP_LIGHTING computed above
	 ||
	    ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	  && (enables & __GL_TEXTURE_GEN_S_ENABLE)
	  && (gc->state.texture.s.mode == GL_SPHERE_MAP))
	 ||
	    ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	  && (enables & __GL_TEXTURE_GEN_T_ENABLE)
	  && (gc->state.texture.t.mode == GL_SPHERE_MAP))
	)
            paNeeds |= PANEEDS_NORMAL | PANEEDS_NORMAL_FOR_TEXTURE;
#endif

        // Compute PANEEDS_RASTERPOS_NORMAL.
#ifdef NEW_NORMAL_PROCESSING
	if (enables & __GL_LIGHTING_ENABLE)
        paNeeds |= PANEEDS_RASTERPOS_NORMAL;
	 if ((enables & __GL_TEXTURE_GEN_S_ENABLE && gc->state.texture.s.mode == GL_SPHERE_MAP)
	    ||
	    (enables & __GL_TEXTURE_GEN_T_ENABLE && gc->state.texture.t.mode == GL_SPHERE_MAP))
        paNeeds |= PANEEDS_RASTERPOS_NORMAL_FOR_TEXTURE;
#else
	if
	(
	    (enables & __GL_LIGHTING_ENABLE)
	 ||
	    ((enables & __GL_TEXTURE_GEN_S_ENABLE)
	  && (gc->state.texture.s.mode == GL_SPHERE_MAP))
	 ||
	    ((enables & __GL_TEXTURE_GEN_T_ENABLE)
	  && (gc->state.texture.t.mode == GL_SPHERE_MAP))
	)
            paNeeds |= PANEEDS_RASTERPOS_NORMAL;
#endif
        // Compute PANEEDS_CLIP_ONLY.
        // It is set in selection mode to take a fast path in DrawPolyArray.
        // It must be cleared by RasterPos before calling DrawPolyArray!
        if (gc->renderMode == GL_SELECT) 
        {
            paNeeds |= PANEEDS_CLIP_ONLY;
            paNeeds &= ~PANEEDS_NORMAL;
        }

        gc->vertex.paNeeds = paNeeds;
    }

    // Compute PANEEDS_EDGEFLAG flag

    // __GL_DIRTY_POLYGON test is probably sufficient.
    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_POLYGON)) 
    {
        if (gc->state.polygon.frontMode != GL_FILL
            || gc->state.polygon.backMode  != GL_FILL)
            gc->vertex.paNeeds |= PANEEDS_EDGEFLAG;
        else
            gc->vertex.paNeeds &= ~PANEEDS_EDGEFLAG;
    }
#endif // NT

    if (gc->dirtyMask & __GL_DIRTY_POLYGON_STIPPLE) {
        /*
        ** Usually, the polygon stipple is converted immediately after
        ** it is changed.  However, if the polygon stipple was changed
        ** when this context was the destination of a CopyContext, then
        ** the polygon stipple will be converted here.
        */
        (*gc->procs.convertPolygonStipple)(gc);
    }

// Compute paNeeds flags PANEEDS_FRONT_COLOR and PANEEDS_BACK_COLOR

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_POLYGON |
        __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH))
    {
        GLuint paNeeds;

        /* 
        ** May be used for picking Rect() procs, need to check polygon 
        ** bit.  Must also be called after gc->vertex.needs is set.!!!
        ** Needs to be called prior to point, line, and triangle pickers.
        ** Also needs to be called after the store procs picker is called.
        */
        (*gc->procs.pickVertexProcs)(gc);
        
        (*gc->procs.pickSpanProcs)(gc);
        (*gc->procs.pickTriangleProcs)(gc);

#ifdef NT
// Compute front and back color needs for polygons.
// Points and lines always use the front color.
// Unlit primitives always use the front color.
//
//  Cull enable?    Two sided?  Cull face   Color needs
//       N             N         BACK        FRONT
//       N             N         FRONT       FRONT
//       N             N     FRONT_AND_BACK  FRONT
//       N             Y         BACK        FRONT/BACK
//       N             Y         FRONT       FRONT/BACK
//       N             Y     FRONT_AND_BACK  FRONT/BACK
//       Y             N         BACK        FRONT
//       Y             N         FRONT       FRONT
//       Y             N     FRONT_AND_BACK  None
//       Y             Y         BACK        FRONT
//       Y             Y         FRONT       BACK
//       Y             Y     FRONT_AND_BACK  None

        paNeeds = gc->vertex.paNeeds;
        paNeeds &= ~(PANEEDS_FRONT_COLOR | PANEEDS_BACK_COLOR);
        if (enables & __GL_LIGHTING_ENABLE) 
        {
            if (!(enables & __GL_CULL_FACE_ENABLE)) 
            {
                if (gc->state.light.model.twoSided)
                    paNeeds |= PANEEDS_FRONT_COLOR | PANEEDS_BACK_COLOR;
                else
                    paNeeds |= PANEEDS_FRONT_COLOR;
            } 
            else 
            {
                if (!(gc->state.polygon.cull == GL_FRONT_AND_BACK)) 
                {
                  if (gc->state.polygon.cull == GL_FRONT
                      && gc->state.light.model.twoSided)
                      paNeeds |= PANEEDS_BACK_COLOR;
                  else
                      paNeeds |= PANEEDS_FRONT_COLOR;
                }
            }
        } 
        else
            paNeeds |= PANEEDS_FRONT_COLOR;

        gc->vertex.paNeeds = paNeeds;
#endif
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_POINT |
                         __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickPointProcs)(gc);
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LINE |
                         __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickLineProcs)(gc);
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_PIXEL | 
                         __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickPixelProcs)(gc);
    }

    /*
    ** deal with the depth function pointers last. This has to be done last.
    */
    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickDepthProcs)(gc);
    }

    gc->validateMask = 0;
    gc->dirtyMask = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_polyc.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.16 $
** $Date: 1993/09/23 16:33:23 $
*/
#include "precomp.h"
#pragma hdrstop
#include <fixed.h>

/*
** Clip an input polygon against a clipping plane outputing the new
** vertex pointers in ov and return the number of them.  See the line
** clipping code for an in depth discussion of how "t" is computed.
**
** NOTE: In order to handle non-convex polygons here without dying,
** we count the number of verticies generated by clipping.  If the
** count ever gets to 3, then it must be a non-convex polygon (because
** it means the polygon crossed the clipping plane three times, which is
** impossible for a convex polygon).
*/
static GLint clipToPlane(__GLcontext *gc, __GLvertex **iv, GLint niv,
             __GLvertex **ov, GLuint offs, GLboolean negate)
{
    GLint i, nout, generated;
    __GLvertex *s, *p, *newVertex, *temp;
    __GLfloat pDist, sDist, t;
    PFN_VERTEX_CLIP_PROC clip;
#ifdef GL_WIN_phong_shading
    GLboolean doNormalize = (gc->state.enables.general & 
                             __GL_NORMALIZE_ENABLE);
#endif //GL_WIN_phong_shading

    nout = 0;
    generated = 0;
    temp = gc->transform.nextClipTemp;
    clip = gc->procs.polyClipParam;

    s = iv[niv-1];
    if (negate)
    {
        sDist = s->clip.w - *(__GLfloat *)((GLubyte *)s + offs);
    }
    else
    {
        sDist = *(__GLfloat *)((GLubyte *)s + offs) + s->clip.w;
    }

    for (i = 0; i < niv; i++) {
        p = iv[i];
        if (negate)
        {
            pDist = p->clip.w - *(__GLfloat *)((GLubyte *)p + offs);
        }
        else
        {
            pDist = *(__GLfloat *)((GLubyte *)p + offs) + p->clip.w;
        }

        if (__GL_FLOAT_GEZ(pDist)) {
            /* p is inside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /* s is inside the clipping plane half space */
                *ov++ = p;
                nout++;
            } else {
                /* s is outside the clipping plane half space */
                t = pDist / (pDist - sDist);
                newVertex = temp++;
                (*clip)(newVertex, s, p, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading
#ifndef NT
                // edgeflag is now part of has field.
                newVertex->boundaryEdge = s->boundaryEdge;
#endif
                newVertex->has = s->has;
                newVertex->clipCode = s->clipCode;
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                *ov++ = p;
                nout += 2;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                    return 0;
                }
            }
        } else {
            /* p is outside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /*
                ** s is inside the clipping plane half space
                **
                ** NOTE: To avoid cracking in polygons with shared
                ** clipped edges we always compute "t" from the out
                ** vertex to the in vertex.  The above clipping code gets
                ** this for free (p is in and s is out).  In this code p
                ** is out and s is in, so we reverse the t computation
                ** and the argument order to __glDoClip.
                */
                t = sDist / (sDist - pDist);
                newVertex = temp++;
                (*clip)(newVertex, p, s, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading
#ifdef NT
                // edgeflag is now part of has field.
                newVertex->has = s->has | __GL_HAS_EDGEFLAG_BOUNDARY;
                newVertex->clipCode = p->clipCode;
#else
                newVertex->boundaryEdge = GL_TRUE;
                newVertex->has = s->has;
#endif
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                nout++;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                    return 0;
                }
            } else {
                /* both points are outside */
            }
        }
        s = p;
        sDist = pDist;
    }
    gc->transform.nextClipTemp = temp;
    return nout;
}

/* 
** Identical to clipToPlane(), except that the clipping is done in eye
** space.
*/
static GLint clipToPlaneEye(__GLcontext *gc, __GLvertex **iv, GLint niv,
                __GLvertex **ov, __GLcoord *plane)
{
    GLint i, nout, generated;
    __GLvertex *s, *p, *newVertex, *temp;
    __GLfloat pDist, sDist, t;
    PFN_VERTEX_CLIP_PROC clip;
#ifdef GL_WIN_phong_shading
    GLboolean doNormalize = (gc->state.enables.general & 
                             __GL_NORMALIZE_ENABLE);
#endif //GL_WIN_phong_shading

    nout = 0;
    generated = 0;
    temp = gc->transform.nextClipTemp;
    clip = gc->procs.polyClipParam;

    s = iv[niv-1];
    sDist = (((POLYDATA *)s)->eye.x * plane->x) +
      (((POLYDATA *)s)->eye.y * plane->y) +
      (((POLYDATA *)s)->eye.z * plane->z) +
      (((POLYDATA *)s)->eye.w * plane->w);
    for (i = 0; i < niv; i++) {
        p = iv[i];
        pDist = (((POLYDATA *)p)->eye.x * plane->x) +
          (((POLYDATA *)p)->eye.y * plane->y) +
          (((POLYDATA *)p)->eye.z * plane->z) +
          (((POLYDATA *)p)->eye.w * plane->w);
        if (__GL_FLOAT_GEZ(pDist)) {
            /* p is inside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /* s is inside the clipping plane half space */
                *ov++ = p;
                nout++;
            } else {
                /* s is outside the clipping plane half space */
                t = pDist / (pDist - sDist);
                newVertex = temp++;
                (*clip)(newVertex, s, p, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading
                ((POLYDATA *)newVertex)->eye.x =
                  t*(((POLYDATA *)s)->eye.x - ((POLYDATA *)p)->eye.x) +
                  ((POLYDATA *)p)->eye.x;
                ((POLYDATA *)newVertex)->eye.y =
                  t*(((POLYDATA *)s)->eye.y - ((POLYDATA *)p)->eye.y) +
                  ((POLYDATA *)p)->eye.y;
                ((POLYDATA *)newVertex)->eye.z =
                  t*(((POLYDATA *)s)->eye.z - ((POLYDATA *)p)->eye.z) +
                  ((POLYDATA *)p)->eye.z;
                ((POLYDATA *)newVertex)->eye.w =
                  t*(((POLYDATA *)s)->eye.w - ((POLYDATA *)p)->eye.w) +
                  ((POLYDATA *)p)->eye.w;
#ifndef NT
                // edgeflag is now part of has field.
                newVertex->boundaryEdge = s->boundaryEdge;
#endif
                newVertex->has = s->has;
                newVertex->clipCode = s->clipCode;
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                *ov++ = p;
                nout += 2;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                  return 0;
                }
            }
        } else {
            /* p is outside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /*
                ** s is inside the clipping plane half space
                **
                ** NOTE: To avoid cracking in polygons with shared
                ** clipped edges we always compute "t" from the out
                ** vertex to the in vertex.  The above clipping code gets
                ** this for free (p is in and s is out).  In this code p
                ** is out and s is in, so we reverse the t computation
                ** and the argument order to __glDoClip.
                */
                t = sDist / (sDist - pDist);
                newVertex = temp++;
                (*clip)(newVertex, p, s, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading

                ((POLYDATA *)newVertex)->eye.x =
                  t*(((POLYDATA *)p)->eye.x - ((POLYDATA *)s)->eye.x) +
                  ((POLYDATA *)s)->eye.x;
                ((POLYDATA *)newVertex)->eye.y =
                  t*(((POLYDATA *)p)->eye.y - ((POLYDATA *)s)->eye.y) +
                  ((POLYDATA *)s)->eye.y;
                ((POLYDATA *)newVertex)->eye.z =
                  t*(((POLYDATA *)p)->eye.z - ((POLYDATA *)s)->eye.z) +
                  ((POLYDATA *)s)->eye.z;
                ((POLYDATA *)newVertex)->eye.w =
                  t*(((POLYDATA *)p)->eye.w - ((POLYDATA *)s)->eye.w) +
                  ((POLYDATA *)s)->eye.w;
#ifdef NT
                // edgeflag is now part of has field.
                newVertex->has = s->has | __GL_HAS_EDGEFLAG_BOUNDARY;
                newVertex->clipCode = p->clipCode;
#else
                newVertex->boundaryEdge = GL_TRUE;
                newVertex->has = s->has;
#endif
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                nout++;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                  return 0;
                }
            } else {
                /* both points are outside */
            }
        }
        s = p;
        sDist = pDist;
    }
    gc->transform.nextClipTemp = temp;
    return nout;
}

/*
** Each clipping plane can add at most one vertex to a convex polygon (it may
** remove up to all of the verticies).  The clipping will leave a polygon
** convex.  Because of this the maximum number of verticies output from
** the clipToPlane procedure will be total number of clip planes (assuming
** each plane adds one new vertex) plus the original number of verticies
** (3 since this if for triangles).
*/

#ifndef __CLIP_FIX
#define __GL_TOTAL_CLIP_PLANES 20   /*XXX*/
#ifdef NT
#define __GL_MAX_CLIP_VERTEX (__GL_TOTAL_CLIP_PLANES + __GL_MAX_POLYGON_CLIP_SIZE)
#else
#define __GL_MAX_CLIP_VERTEX (__GL_TOTAL_CLIP_PLANES + __GL_NVBUF)
#endif
#endif


void __glDoPolygonClip(__GLcontext *gc, __GLvertex **iv, GLint nout,
                       GLuint allClipCodes)
{
#ifndef __CLIP_FIX 
    __GLvertex *ov[__GL_TOTAL_CLIP_PLANES][__GL_MAX_CLIP_VERTEX];
#endif
    __GLvertex **ivp;
    __GLvertex **ovp;
    __GLvertex *p0, *p1, *p2;
    __GLcoord *plane;
    GLint i;
    __GLviewport *vp;
    __GLfloat one, vpXScale, vpYScale, vpZScale;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    PFN_RENDER_TRIANGLE rt;
    __GLfloat llx, lly, urx, ury;
    __GLfloat winx, winy;
    GLuint clipCodes;

    // We have to turn rounding on.  Otherwise, the fast FP-comparison
    // routines below can fail:
    FPU_SAVE_MODE();
    FPU_ROUND_ON_PREC_HI();

    /*
    ** Reset nextClipTemp pointer for any new verticies that are generated
    ** during the clipping.
    */
    gc->transform.nextClipTemp = gc->transform.clipTemp;

    ivp = &iv[0];

    /*
    ** Check each of the clipping planes by examining the allClipCodes
    ** mask. Note that no bits will be set in allClipCodes for clip
    ** planes that are not enabled.
    */
    if (allClipCodes) {
        /* Now clip against the clipping planes */
#ifndef __CLIP_FIX
        ovp = &ov[0][0];
#else
        ovp = &(((__GLGENcontext *)gc)->pwndLocked->buffers->clip_verts[0][0]);
#endif
        /* 
        ** Do user clip planes first, because we will maintain eye coordinates
        ** only while doing user clip planes.  They are ignored for the 
        ** frustum clipping planes.
        */
        clipCodes = allClipCodes >> 6;
        if (clipCodes) {
            plane = &gc->state.transform.eyeClipPlanes[0];
            do {
                if (clipCodes & 1) {
                    nout = clipToPlaneEye(gc, ivp, nout, ovp, plane);
                    ASSERTOPENGL(nout <= __GL_MAX_CLIP_VERTEX,
                                 "Too many clip vertices\n");
                    if (nout < 3) {
                        FPU_RESTORE_MODE();
                        return;
                    }
                    ivp = ovp;
                    ovp += __GL_MAX_CLIP_VERTEX;
                }
                clipCodes >>= 1;
                plane++;
            } while (clipCodes);
        }

        allClipCodes &= __GL_FRUSTUM_CLIP_MASK;
        if (allClipCodes) {
            i = 0;
            do {
                if (allClipCodes & 1) {
                    nout = clipToPlane(gc, ivp, nout, ovp,
                                       __glFrustumOffsets[i],
                                       (GLboolean)(i & 1));
                    ASSERTOPENGL(nout <= __GL_MAX_CLIP_VERTEX,
                                 "Too many clip vertices\n");
                    if (nout < 3) {
                        FPU_RESTORE_MODE();
                        return;
                    }
                    ivp = ovp;
                    ovp += __GL_MAX_CLIP_VERTEX;
                }
                allClipCodes >>= 1;
                i++;
            } while (allClipCodes);
        }

        /*
        ** Calculate final screen coordinates.  Next phase of polygon
        ** processing assumes that window coordinates are already computed.
        */
        vp = &gc->state.viewport;
        vpXCenter = vp->xCenter;
        vpYCenter = vp->yCenter;
        vpZCenter = vp->zCenter;
        vpXScale = vp->xScale;
        vpYScale = vp->yScale;
        vpZScale = vp->zScale;
        ovp = ivp;
        one = __glOne;
        
        llx = vpXCenter - vpXScale;
        urx = vpXCenter + vpXScale;
        if (vpYScale > 0) {
            lly = vpYCenter - vpYScale;
            ury = vpYCenter + vpYScale;
        } else {
            lly = vpYCenter + vpYScale;
            ury = vpYCenter - vpYScale;
        }
        
        for (i = nout; --i >= 0; ) {
            __GLfloat x, y, z, wInv;

            p0 = *ovp++;
            
            // If the clipCode is zero then the window coordinates
            // were computed at the time of clipCode determination
            // Generated vertices' clipCodes are set to the out vertex
            // to ensure that their window coords are computed
            if (p0->clipCode != 0)
            {
#ifdef NT
                /* XXX (mf) prevent divide-by-zero */
                if (__GL_FLOAT_EQZ(p0->clip.w))
                    wInv = __glZero;
                else 
                    wInv = one / p0->clip.w;
#else
                wInv = one / p0->clip.w;
#endif
                x = p0->clip.x; y = p0->clip.y; z = p0->clip.z;
                winx = x * vpXScale * wInv + vpXCenter;
                winy = y * vpYScale * wInv + vpYCenter;
                p0->window.z = z * vpZScale * wInv + vpZCenter;
                p0->window.w = wInv;
                /* 
                ** Check if these window coordinates are legal.  At this 
                ** point, it is quite possible that they are not.  Trivially
                ** pull them into the legal viewport region if necessary.
                */
                if (winx < llx) winx = llx;
                else if (winx > urx) winx = urx;
                if (winy < lly) winy = lly;
                else if (winy > ury) winy = ury;
                p0->window.x = winx;
                p0->window.y = winy;
            }
        }
    }

    // Restore mode before rendering
    FPU_RESTORE_MODE();

#if 0 //def GL_WIN_phong_shading
    if (gc->state.light.shadingModel == GL_PHONG_EXT)
    {
        __GLvertex *minv;
        __GLvertex **cv;
        GLint j, index;

        minv = *ivp; index=0;
        
        //Reorder the vertices so that p0 is the one with the least y and x 
        for (i=0, cv=ivp; i<nout; i++, cv++)
        {
            if (__GL_VERTEX_COMPARE((*cv)->window.y, <, minv->window.y))
            {
                minv = *cv;
                index = i;
            }
            else if (__GL_VERTEX_COMPARE((*cv)->window.y, ==, minv->window.y))
            {
                if (__GL_VERTEX_COMPARE((*cv)->window.x, <, minv->window.x))
                {
                    minv = *cv;
                    index = i;
                }
            }
        }

        DbgPrint ("MinIndex = %d\n", index);
        
        j = index;
        p0 = (__GLvertex *) ivp[j];
        p1 = (__GLvertex *) ivp[(++j)%nout];
        p2 = (__GLvertex *) ivp[(++j)%nout];
        rt = gc->procs.renderTriangle;
        if (nout == 3) 
        {
            (*rt)(gc, p0, p1, p2);
        } 
        else 
        {
            for (i = 0; i < nout - 2; i++) 
            {
                GLuint t1, t2;
                if (i == 0) 
                {
                    /*
                    ** Third edge of first sub-triangle is always non-boundary
                    */
                    // edgeflag is now part of has field.
                    t1 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                    p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                    (*rt)(gc, p0, p1, p2);
                    p2->has |= t1;
                } 
                else
                    if (i == nout - 3) 
                    {
                        /*
                        ** First edge of last sub-triangle is always 
                        ** non-boundary
                        */
                        // edgeflag is now part of has field.
                        t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                        p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                        (*rt)(gc, p0, p1, p2);
                        p0->has |= t1;
                    } 
                    else 
                    {
                        /*
                        ** Interior sub-triangles have the first and last edge
                        ** marked non-boundary
                        */
                        // edgeflag is now part of has field.
                        t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                        t2 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                        p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                        p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                        (*rt)(gc, p0, p1, p2);
                        p0->has |= t1;
                        p2->has |= t2;
                    }
                p1 = p2;
                p2 = (__GLvertex *) ivp[(++j)%nout];
            }
        }
    }
    else
    {
#endif //GL_WIN_phong_shading

    /*
    ** Subdivide the clipped polygon into triangles.  Only convex polys
    ** are supported so this is okay to do.  Non-convex polys will do
    ** something odd here, but thats the clients fault.
    */
    p0 = *ivp++;
    p1 = *ivp++;
    p2 = *ivp++;
    rt = gc->procs.renderTriangle;
    if (nout == 3) 
    {
        (*rt)(gc, p0, p1, p2);
    } 
    else 
    {
        for (i = 0; i < nout - 2; i++) 
        {
              GLuint t1, t2;
              if (i == 0) 
              {
                  /*
                  ** Third edge of first sub-triangle is always non-boundary
                  */
                  // edgeflag is now part of has field.
                  t1 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                  p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                  (*rt)(gc, p0, p1, p2);
                  p2->has |= t1;
              } 
              else
                  if (i == nout - 3) 
                  {
                      /*
                      ** First edge of last sub-triangle is always 
                      ** non-boundary
                      */
                      // edgeflag is now part of has field.
                      t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                      p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                      (*rt)(gc, p0, p1, p2);
                      p0->has |= t1;
                  } 
                  else 
                  {
                      /*
                      ** Interior sub-triangles have the first and last edge
                      ** marked non-boundary
                      */
                      // edgeflag is now part of has field.
                      t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                      t2 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                      p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                      p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                      (*rt)(gc, p0, p1, p2);
                      p0->has |= t1;
                      p2->has |= t2;
                  }
              p1 = p2;
              p2 = (__GLvertex *) *ivp++;
        }
    }
#if 0 //def GL_WIN_phong_shading
    }
#endif //GL_WIN_phong_shading
}

void FASTCALL __glClipPolygon(__GLcontext *gc, __GLvertex *v0, GLint nv)
{
#ifdef NT
    __GLvertex *iv[__GL_MAX_POLYGON_CLIP_SIZE];
#else
    __GLvertex *iv[__GL_NVBUF];
#endif
    __GLvertex **ivp;
    GLint i;
    GLuint andCodes, orCodes;

    gc->vertex.provoking = v0;

    /*
    ** Generate array of addresses of the verticies.  And all the
    ** clip codes together while we are at it.
    */
    ivp = &iv[0];
    andCodes = (GLuint)(-1);
    orCodes = 0;
    for (i = nv; --i >= 0; ) {
    andCodes &= v0->clipCode;
    orCodes |= v0->clipCode;
    *ivp++ = v0++;
    }

    if (andCodes != 0) {
    /*
    ** Trivially reject the polygon.  If andCodes is non-zero then
    ** every vertex in the polygon is outside of the same set of
    ** clipping planes (at least one).
    */
    return;
    }
    __glDoPolygonClip(gc, &iv[0], nv, orCodes);
}

void FASTCALL __glClipTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
              __GLvertex *c, GLuint orCodes)
{
    __GLvertex *iv[3];

    iv[0] = a;
    iv[1] = b;
    iv[2] = c;

    __glDoPolygonClip(gc, &iv[0], 3, orCodes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_pntdr.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.12 $
** $Date: 1993/10/07 18:57:21 $
*/
#include "precomp.h"
#pragma hdrstop

#include <fixed.h>

void FASTCALL __glRenderAliasedPoint1_NoTex(__GLcontext *gc, __GLvertex *vx)
{
    __GLfragment frag;

    frag.x = __GL_VERTEX_FLOAT_TO_INT(vx->window.x);
    frag.y = __GL_VERTEX_FLOAT_TO_INT(vx->window.y);
    frag.z = (__GLzValue)FTOL(vx->window.z);
 
    /*
    ** Compute the color
    */
    frag.color = *vx->color;

    /*
    ** Fog if enabled
    */
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
        !(gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }
    else if (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }

    /* Render the single point */
    (*gc->procs.store)(gc->drawBuffer, &frag);
}

void FASTCALL __glRenderAliasedPoint1(__GLcontext *gc, __GLvertex *vx)
{
    __GLfragment frag;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    frag.x = __GL_VERTEX_FLOAT_TO_INT(vx->window.x);
    frag.y = __GL_VERTEX_FLOAT_TO_INT(vx->window.y);
    frag.z = (__GLzValue)FTOL(vx->window.z);

    /*
    ** Compute the color
    */
    frag.color = *vx->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
	__GLfloat qInv = (vx->texture.w == (__GLfloat) 0.0) ? (__GLfloat) 0.0 : __glOne / vx->texture.w;
	(*gc->procs.texture)(gc, &frag.color, vx->texture.x * qInv,
			       vx->texture.y * qInv, __glOne);
    }

    /*
    ** Fog if enabled
    */
    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((modeFlags & __GL_SHADE_INTERP_FOG) 
             || 
             (((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) 
               == __GL_SHADE_CHEAP_FOG)))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }



    /* Render the single point */
    (*gc->procs.store)(gc->drawBuffer, &frag);
}

void FASTCALL __glRenderAliasedPointN(__GLcontext *gc, __GLvertex *vx)
{
    GLint pointSize, pointSizeHalf, ix, iy, xLeft, xRight, yBottom, yTop;
    __GLfragment frag;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLfloat tmp;

    /*
    ** Compute the x and y starting coordinates for rendering the square.
    */
    pointSize = gc->state.point.aliasedSize;
    pointSizeHalf = pointSize >> 1;
    if (pointSize & 1) {
	/* odd point size */
	xLeft = __GL_VERTEX_FLOAT_TO_INT(vx->window.x) - pointSizeHalf;
	yBottom = __GL_VERTEX_FLOAT_TO_INT(vx->window.y) - pointSizeHalf;
    } else {
	/* even point size */
        tmp = vx->window.x+__glHalf;
	xLeft = __GL_VERTEX_FLOAT_TO_INT(tmp) - pointSizeHalf;
        tmp = vx->window.y+__glHalf;
	yBottom = __GL_VERTEX_FLOAT_TO_INT(tmp) - pointSizeHalf;
    }
    xRight = xLeft + pointSize;
    yTop = yBottom + pointSize;

    /*
    ** Compute the color
    */
    frag.color = *vx->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
	__GLfloat qInv = __glOne / vx->texture.w;
	(*gc->procs.texture)(gc, &frag.color, vx->texture.x * qInv,
			       vx->texture.y * qInv, __glOne);
    }

    /*
    ** Fog if enabled
    */

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((modeFlags & __GL_SHADE_INTERP_FOG) 
             || 
             (((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) 
               == __GL_SHADE_CHEAP_FOG)))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }

    
    /*
    ** Now render the square centered on xCenter,yCenter.
    */
    frag.z = (__GLzValue)FTOL(vx->window.z);
    for (iy = yBottom; iy < yTop; iy++) {
	for (ix = xLeft; ix < xRight; ix++) {
	    frag.x = ix;
	    frag.y = iy;
	    (*gc->procs.store)(gc->drawBuffer, &frag);
	}
    }
}


#ifdef __BUGGY_RENDER_POINT
void FASTCALL __glRenderFlatFogPoint(__GLcontext *gc, __GLvertex *vx)
{
    __GLcolor *vxocp;
    __GLcolor vxcol;

    (*gc->procs.fogColor)(gc, &vxcol, vx->color, vx->fog);
    vxocp = vx->color;
    vx->color = &vxcol;

    (*gc->procs.renderPoint2)(gc, vx);

    vx->color = vxocp;
}


#ifdef NT
// vx->fog is invalid if it is __GL_SHADE_SLOW_FOG!
void FASTCALL __glRenderFlatFogPointSlow(__GLcontext *gc, __GLvertex *vx)
{
    __GLcolor *vxocp;
    __GLcolor vxcol;

    // compute fog value first!
    vx->fog = __glFogVertex(gc, vx);

    (*gc->procs.fogColor)(gc, &vxcol, vx->color, vx->fog);
    vxocp = vx->color;
    vx->color = &vxcol;

    (*gc->procs.renderPoint2)(gc, vx);

    vx->color = vxocp;
}
#endif
#endif //__BUGGY_RENDER_POINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_pntaa.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.10 $
** $Date: 1993/06/18 00:30:15 $
*/
#include "precomp.h"
#pragma hdrstop

#include <fixed.h>

/*
** This is a little wierd.  What it does is to dither "comp" into the high
** n-4 bits, and add 16 * antiAliasPercent.  Dithering of the low bits is
** left to the usual methods (the store and span procs, for example).
*/
__GLfloat __glBuildAntiAliasIndex(__GLfloat index, 
				  __GLfloat antiAliasPercent)
{
    GLint newlowbits;

    newlowbits = (GLint)((__GL_CI_ANTI_ALIAS_DIVISOR - 1) * antiAliasPercent + (__GLfloat) 0.5);
    return (((int) index) & ~(__GL_CI_ANTI_ALIAS_DIVISOR - 1)) | newlowbits;
}

/************************************************************************/

/*
** To anti-alias points the below code operates a simple algrorithim that
** sub-samples the bounding box of the pixel area covered by the point.
** At each sub-sample the distance from the sample to the center of the
** point is computed and compared against the distance from the edge of
** the circle to the center.  If the computed distance is <= the edge
** distance then the sample is inside the circle.  All the samples for a
** particular pixel center are summed up and then the resulting value is
** divided by the total samples in the pixel.  This gives us a coverage value
** to use to adjust the fragment alpha with before storing (there is
** an analagous affect when color index anti-aliasing is being done).
**
** The code below implements this simple algrorithim, but has been tuned
** so it might be difficult to translate.  Basically, every possible operation
** that could be moved out of the Coverage code (i.e., invariants across
** the coverage test) has been done.  Also, the minimal area is sampled
** over.
*/

/* Code below knows alot about these constants so beware */
#define	__GL_FILTER_SIZE	__glOne
#define __GL_HALF_FILTER_SIZE	__glHalf
#define __GL_SAMPLES		4
#define __GL_SAMPLE_HIT		((__GLfloat) 0.0625)	/* 1 / (4*4) */
#define __GL_SAMPLE_DELTA	((__GLfloat) 0.25)	/* 1 / 4 */
#define __GL_HALF_SAMPLE_DELTA	((__GLfloat) 0.125)
/* -halffilter + half delta */
#define __GL_COORD_ADJUST	((__GLfloat) -0.375)

/*
** Return an estimate of the pixel coverage using sub-sampling.
**
** NOTE: The subtraction of xCenter,yCenter has been moved into the
** caller to save time.  Consequently the starting coordinate may not be
** on a pixel center, but thats ok.
*/
static __GLfloat Coverage(__GLfloat xStart, __GLfloat yStart,
			  __GLfloat radiusSquared)
{
    GLint i;
    __GLfloat delta, yBottom, sampleX, sampleY;
    __GLfloat hits, hitsInc;

    /*
    ** Get starting sample x & y positions.  We take our starting
    ** coordinate, back off half a filter size then add half a delta to
    ** it.  This constrains the sampling to lie entirely within the
    ** pixel, never on the edges of the pixel.  The constants above
    ** have this adjustment pre-computed.
    */
    sampleX = xStart + __GL_COORD_ADJUST;
    yBottom = yStart + __GL_COORD_ADJUST;

    delta = __GL_SAMPLE_DELTA;
    hits = __glZero;
    hitsInc = __GL_SAMPLE_HIT;
    for (i = __GL_SAMPLES; --i >= 0; ) {
	__GLfloat check = radiusSquared - sampleX * sampleX;

	/* Unrolled inner loop - change this code if __GL_SAMPLES changes */
	sampleY = yBottom;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}
	sampleY += delta;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}
	sampleY += delta;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}
	sampleY += delta;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}

	sampleX += delta;
    }
    return hits;
}

void FASTCALL __glRenderAntiAliasedRGBPoint(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat xCenter, yCenter, radius, radiusSquared, coverage, x, y;
    __GLfloat zero, one, oldAlpha, xStart;
    __GLfloat tmp;
    __GLfragment frag;
    GLint w, width, height, ixLeft, iyBottom;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    /*
    ** Determine area to compute coverage over.  The area is bloated by
    ** the filter's width & height implicitly.  By truncating to integer
    ** (NOTE: the x,y coordinate is always positive here) we are
    ** guaranteed to find the lowest coordinate that needs examination
    ** because of the nature of circles.  Similarly, by truncating the
    ** ending coordinate and adding one we get the pixel just past the
    ** upper/right edge of the circle.
    */
    radius = gc->state.point.smoothSize * __glHalf;
    radiusSquared = radius * radius;
    xCenter = vx->window.x;
    yCenter = vx->window.y;

    /* Truncate down to get starting coordinate */
    tmp = xCenter-radius;
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(tmp);
    tmp = yCenter-radius;
    iyBottom = __GL_VERTEX_FLOAT_TO_INT(tmp);

    /*
    ** Truncate down and add 1 to get the ending coordinate, then subtract
    ** out the start to get the width & height.
    */
    tmp = xCenter+radius;
    width = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - ixLeft;
    tmp = yCenter+radius;
    height = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - iyBottom;

    /*
    ** Setup fragment.  The fragment base color will be constant
    ** (approximately) across the entire pixel.  The only thing that will
    ** change is the alpha (for rgb) or the red component (for color
    ** index).
    */
    frag.z = (__GLzValue)vx->window.z;
    frag.color = *vx->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
	(*gc->procs.texture)(gc, &frag.color, vx->texture.x, vx->texture.y,
			       __glOne);
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((gc->polygon.shader.modeFlags & __GL_SHADE_INTERP_FOG)
             || 
             ((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) 
                 == __GL_SHADE_CHEAP_FOG))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }
    

    /*
    ** Now render the circle centered on xCenter,yCenter.  Move the
    ** subtraction of xCenter,yCenter outside of the loop to doing
    ** it up front in xStart and y.  This way the coverage code can
    ** assume the incoming starting coordinate has been properly
    ** adjusted.
    */
    zero = __glZero;
    one = __glOne;
    oldAlpha = frag.color.a;
    xStart = ixLeft + __glHalf - xCenter;
    y = iyBottom + __glHalf - yCenter;
    frag.y = iyBottom;
    while (--height >= 0) {
	x = xStart;
	frag.x = ixLeft;
	for (w = width; --w >= 0; ) {
	    coverage = Coverage(x, y, radiusSquared);
	    if (coverage > zero) {
		frag.color.a = oldAlpha * coverage;
		(*gc->procs.store)(gc->drawBuffer, &frag);
	    }
	    x += one;
	    frag.x++;
	}
	y += one;
	frag.y++;
    }
}

void FASTCALL __glRenderAntiAliasedCIPoint(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat xCenter, yCenter, radius, radiusSquared, coverage, x, y;
    __GLfloat zero, one, oldIndex, xStart;
    __GLfloat tmp;
    __GLfragment frag;
    GLint w, width, height, ixLeft, iyBottom;

    /*
    ** Determine area to compute coverage over.  The area is bloated by
    ** the filter's width & height implicitly.  By truncating to integer
    ** (NOTE: the x,y coordinate is always positive here) we are
    ** guaranteed to find the lowest coordinate that needs examination
    ** because of the nature of circles.  Similarly, by truncating the
    ** ending coordinate and adding one we get the pixel just past the
    ** upper/right edge of the circle.
    */
    radius = gc->state.point.smoothSize * __glHalf;
    radiusSquared = radius * radius;
    xCenter = vx->window.x;
    yCenter = vx->window.y;

    /* Truncate down to get starting coordinate */
    tmp = xCenter-radius;
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(tmp);
    tmp = yCenter-radius;
    iyBottom = __GL_VERTEX_FLOAT_TO_INT(tmp);

    /*
    ** Truncate down and add 1 to get the ending coordinate, then subtract
    ** out the start to get the width & height.
    */
    tmp = xCenter+radius;
    width = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - ixLeft;
    tmp = yCenter+radius;
    height = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - iyBottom;

    /*
    ** Setup fragment.  The fragment base color will be constant
    ** (approximately) across the entire pixel.  The only thing that will
    ** change is the alpha (for rgb) or the red component (for color
    ** index).
    */
    frag.z = (__GLzValue)vx->window.z;
    frag.color.r = vx->color->r;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((gc->polygon.shader.modeFlags & __GL_SHADE_INTERP_FOG)
             || 
             ((gc->polygon.shader.modeFlags & (__GL_SHADE_CHEAP_FOG | 
                                               __GL_SHADE_SMOOTH_LIGHT)) 
              == __GL_SHADE_CHEAP_FOG))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }

    /*
    ** Now render the circle centered on xCenter,yCenter.  Move the
    ** subtraction of xCenter,yCenter outside of the loop to doing
    ** it up front in xStart and y.  This way the coverage code can
    ** assume the incoming starting coordinate has been properly
    ** adjusted.
    */
    zero = __glZero;
    one = __glOne;
    oldIndex = frag.color.r;
    xStart = ixLeft + __glHalf - xCenter;
    y = iyBottom + __glHalf - yCenter;
    frag.y = iyBottom;
    while (--height >= 0) {
	x = xStart;
	frag.x = ixLeft;
	for (w = width; --w >= 0; ) {
	    coverage = Coverage(x, y, radiusSquared);
	    if (coverage > zero) {
		frag.color.r = __glBuildAntiAliasIndex(oldIndex, coverage);
		(*gc->procs.store)(gc->drawBuffer, &frag);
	    }
	    x += one;
	    frag.x++;
	}
	y += one;
	frag.y++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_polym.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop
#include <fixed.h>

#if _X86_

#define SHADER	__GLcontext.polygon.shader

#define GET_HALF_AREA(gc, a, b, c)\
\
__asm{ mov     eax, a                                                                           };\
__asm{ mov     ecx, c                                                                           };\
__asm{ mov     ebx, b                                                                           };\
__asm{ mov     edx, gc                                                                          };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxAC                     */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyBC dxAC                */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxBC dyBC dxAC           */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyAC dxBC dyBC dxAC      */ };\
__asm{ fxch    ST(2)                                             /* dyBC dxBC dyAC dxAC      */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyBC)][edx]                                             };\
__asm{ fmul    ST, ST(3)                                         /* dxACdyBC dxBC dyAC dxAC  */ };\
__asm{ fxch    ST(2)                                             /* dyAC dxBC dxACdyBC dxAC  */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyAC)][edx]                                             };\
__asm{ fmul    ST, ST(1)                                         /* dxBCdyAC dxBC dxACdyBC dxAC */};\
__asm{ fxch    ST(1)                                             /* dxBC dxBCdyAC dxACdyBC dxAC */};\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxBC)][edx]              /* dxBCdyAC dxACdyBC dxAC   */ };\
__asm{ fsubp   ST(1), ST                                /* +1*/  /* area dxAC                */ };\
__asm{ fxch    ST(1)                                             /* dxAC area                */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxAC)][edx]              /* area                     */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.area)][edx]     /* +1*/  /* (empty)                  */ };

#define STORE_AREA_PARAMS   

#else

#define GET_HALF_AREA(gc, a, b, c)\
    /* Compute signed half-area of the triangle */                  \
    dxAC = a->window.x - c->window.x;                               \
    dxBC = b->window.x - c->window.x;                               \
    dyAC = a->window.y - c->window.y;                               \
    dyBC = b->window.y - c->window.y;                               \
    gc->polygon.shader.area = dxAC * dyBC - dxBC * dyAC;

#define STORE_AREA_PARAMS\
    gc->polygon.shader.dxAC = dxAC;                                 \
    gc->polygon.shader.dxBC = dxBC;                                 \
    gc->polygon.shader.dyAC = dyAC;                                 \
    gc->polygon.shader.dyBC = dyBC;    

#endif


#define SORT_AND_CULL_FACE(a, b, c, face, ccw)\
                                                                            \
    /*                                                                      \
    ** Sort vertices in y.  Keep track if a reversal of the winding         \
    ** occurs in direction (0 means no reversal, 1 means reversal).         \
    ** Save old vertex pointers in case we end up not doing a fill.         \
    */                                                                      \
    reversed = 0;                                                           \
    if (__GL_VERTEX_COMPARE(a->window.y, <, b->window.y)) {                 \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            /* Already sorted */                                            \
        } else {                                                            \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=b; b=c; c=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=c; c=b; b=temp;                                   \
            }                                                               \
        }                                                                   \
    } else {                                                                \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=a; a=b; b=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=b; b=c; c=temp;                                   \
            }                                                               \
        } else {                                                            \
            temp=a; a=c; c=temp;                                            \
            reversed = 1;                                                   \
        }                                                                   \
    }                                                                       \
                                                                            \
    GET_HALF_AREA(gc, a, b, c);                                             \
    ccw = !__GL_FLOAT_LTZ(gc->polygon.shader.area);                         \
                                                                            \
    /*                                                                      \
    ** Figure out if face is culled or not.  The face check needs to be     \
    ** based on the vertex winding before sorting.  This code uses the      \
    ** reversed flag to invert the sense of ccw - an xor accomplishes       \
    ** this conversion without an if test.                                  \
    **                                                                      \
    **      ccw reversed        xor                                         \
    **      --- --------        ---                                         \
    **      0   0           0 (remain !ccw)                                 \
    **      1   0           1 (remain ccw)                                  \
    **      0   1           1 (become ccw)                                  \
    **      1   1           0 (become cw)                                   \
    */                                                                      \
    face = gc->polygon.face[ccw ^ reversed];                                \
    if (face == gc->polygon.cullFace) {                                     \
    /* Culled */                                                            \
    return;                                                                 \
    }                                                                       \
                                                                            \
    STORE_AREA_PARAMS;                                                      


// #define NO_RENDERING


void __glTriangleOffsetZ( __GLcontext *gc, __GLvertex *a, __GLvertex *b,
			  __GLvertex *c)
{
    __GLfloat dzAC, dzBC;
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat zOffset;

    // Calc dzdxf, dzdyf values as in __glFillTriangle

    /* Pre-compute one over polygon area */

    if( gc->polygon.shader.area == 0.0f )
        oneOverArea = (__GLfloat)(__glOne / __GL_PGON_OFFSET_NEAR_ZERO);
    else
        oneOverArea = __glOne / gc->polygon.shader.area;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */
    t1 = gc->polygon.shader.dyAC * oneOverArea;
    t2 = gc->polygon.shader.dyBC * oneOverArea;
    t3 = gc->polygon.shader.dxAC * oneOverArea;
    t4 = gc->polygon.shader.dxBC * oneOverArea;

    dzAC = a->window.z - c->window.z;
    dzBC = b->window.z - c->window.z;
    gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
    gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;

    zOffset = __glPolygonOffsetZ(gc);
    a->window.z += zOffset;
    b->window.z += zOffset;
    c->window.z += zOffset;
}

// Polygon offset z-munge: we modify the window.z of the vertices with the
// offset z, then restore the z after rendering, due to the possibility of the
// vertices being sent down multiple times by a higher-order primitive.

#define SAVE_WINDOW_Z \
    awinz = a->window.z; bwinz = b->window.z; cwinz = c->window.z;

#define RESTORE_WINDOW_Z \
    a->window.z = awinz; \
    b->window.z = bwinz; \
    c->window.z = cwinz;

#ifdef GL_EXT_flat_paletted_lighting
void __glPickLightingPalette(__GLcontext *gc)
{
    __GLtexture *tex;
    GLint loffset;

    tex = gc->texture.currentTexture;
    loffset = (GLint)(gc->vertex.provoking->color->r *
                      gc->oneOverRedVertexScale *
                      tex->paletteDivision) << tex->paletteDivShift;
    tex->paletteData = tex->paletteTotalData+loffset;
    __glGenSetPaletteOffset(gc, tex, loffset);
}
#endif GL_EXT_flat_paletted_lighting

/*
** Generic triangle handling code.  This code is used when render mode
** is GL_RENDER and the polygon modes are not both fill.
*/
void FASTCALL __glRenderTriangle(__GLcontext *gc, __GLvertex *a, 
                                 __GLvertex *b, __GLvertex *c)
{
    GLuint needs, modeFlags, faceNeeds;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *oa, *ob, *oc;
    __GLvertex *temp;
    __GLfloat awinz, bwinz, cwinz;

#ifdef NO_RENDERING
    return;
#endif
    
    oa = a; ob = b; oc = c;

    SORT_AND_CULL_FACE(a, b, c, face, ccw);

    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
#ifdef NT
    if (modeFlags & __GL_SHADE_SMOOTH_LIGHT)
    {   /* Smooth shading */
        if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
        {
            a->color++;
            b->color++;
            c->color++;
        }
    }
#ifdef GL_WIN_phong_shading
    else if (modeFlags & __GL_SHADE_PHONG)
    {   /* Phong shading */
        if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
            gc->polygon.shader.phong.face = __GL_BACKFACE; 
        else
            gc->polygon.shader.phong.face = __GL_FRONTFACE;
    }
#endif //GL_WIN_phong_shading
    else
    {   /* Flat shading */
        __GLvertex *pv = gc->vertex.provoking;
        if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
            pv->color++;
        a->color = pv->color;
        b->color = pv->color;
        c->color = pv->color;
    }
#else
    if (modeFlags & __GL_SHADE_TWOSIDED) {
	colorFace = face;
	faceNeeds = gc->vertex.faceNeeds[face];
    } else {
	colorFace = __GL_FRONTFACE;
	faceNeeds = gc->vertex.faceNeeds[__GL_FRONTFACE];
    }

    /*
    ** Choose colors for the vertices.
    */
    needs = gc->vertex.needs;
    pv = gc->vertex.provoking;
    if (modeFlags & __GL_SHADE_SMOOTH_LIGHT) {
	/* Smooth shading */
	a->color = &a->colors[colorFace];
	b->color = &b->colors[colorFace];
	c->color = &c->colors[colorFace];
	needs |= faceNeeds;
    } else {
	GLuint pvneeds;

	/*
	** Validate the lighting (and color) information in the provoking
	** vertex only.  Fill routines always use gc->vertex.provoking->color
	** to find the color.
	*/
	pv->color = &pv->colors[colorFace];
	a->color = pv->color;
	b->color = pv->color;
	c->color = pv->color;
	pvneeds = faceNeeds & (__GL_HAS_LIGHTING | 
		__GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR);
	if (~pv->has & pvneeds) {
	    (*pv->validate)(gc, pv, pvneeds);
	}
    }

    /* Validate vertices */
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);
#endif

    /* Render triangle using the faces polygon mode */
    switch (gc->polygon.mode[face]) {
      case __GL_POLYGON_MODE_FILL:
	if (__GL_FLOAT_NEZ(gc->polygon.shader.area)) {
#ifdef GL_EXT_flat_paletted_lighting
            if ((gc->state.enables.general & __GL_PALETTED_LIGHTING_ENABLE) &&
                (modeFlags & __GL_SHADE_SMOOTH_LIGHT) == 0 &&
                gc->texture.currentTexture != NULL)
            {
                __glPickLightingPalette(gc);
            }
#endif
	    (*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
	}
	break;
      case __GL_POLYGON_MODE_POINT:
        if( gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE ) {
            SAVE_WINDOW_Z;
            __glTriangleOffsetZ( gc, a, b, c );
        }
#ifdef NT
        if (oa->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            (*gc->procs.renderPoint)(gc, oa);
        if (ob->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            (*gc->procs.renderPoint)(gc, ob);
        if (oc->has & __GL_HAS_EDGEFLAG_BOUNDARY)
          (*gc->procs.renderPoint)(gc, oc);

        if( gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE ) {
            RESTORE_WINDOW_Z;
        }
        break;
#else
	if (oa->boundaryEdge) (*gc->procs.renderPoint)(gc, oa);
	if (ob->boundaryEdge) (*gc->procs.renderPoint)(gc, ob);
	if (oc->boundaryEdge) (*gc->procs.renderPoint)(gc, oc);
	break;
#endif
      case __GL_POLYGON_MODE_LINE:
        if( gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE ) {
            SAVE_WINDOW_Z;
            __glTriangleOffsetZ( gc, a, b, c );
        }
#ifdef NT
        (*gc->procs.lineBegin)(gc);
        if ((oa->has & __GL_HAS_EDGEFLAG_BOUNDARY) &&
            (ob->has & __GL_HAS_EDGEFLAG_BOUNDARY) &&
            (oc->has & __GL_HAS_EDGEFLAG_BOUNDARY))
        {
            // Is this an important case to optimize?
            (*gc->procs.renderLine)(gc, oa, ob, __GL_LVERT_FIRST);
            (*gc->procs.renderLine)(gc, ob, oc, 0);
            (*gc->procs.renderLine)(gc, oc, oa, 0);
        }
        else
        {
            if (oa->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            {
                (*gc->procs.renderLine)(gc, oa, ob, __GL_LVERT_FIRST);
            }
            if (ob->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            {
                (*gc->procs.renderLine)(gc, ob, oc, __GL_LVERT_FIRST);
            }
            if (oc->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            {
                (*gc->procs.renderLine)(gc, oc, oa, __GL_LVERT_FIRST);
            }
        }
        (*gc->procs.lineEnd)(gc);
        if( gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE ) {
            RESTORE_WINDOW_Z;
        }
        break;
#else
	if (oa->boundaryEdge) {
	    (*gc->procs.renderLine)(gc, oa, ob);
	}
	if (ob->boundaryEdge) {
	    (*gc->procs.renderLine)(gc, ob, oc);
	}
	if (oc->boundaryEdge) {
	    (*gc->procs.renderLine)(gc, oc, oa);
	}
	break;
#endif
    }

    /* Restore color pointers */
    a->color = &a->colors[__GL_FRONTFACE];
    b->color = &b->colors[__GL_FRONTFACE];
    c->color = &c->colors[__GL_FRONTFACE];

#ifdef NT
    if (!(modeFlags & __GL_SHADE_SMOOTH_LIGHT)
#ifdef GL_WIN_phong_shading
        && !(modeFlags & __GL_SHADE_PHONG)
#endif //GL_WIN_phong_shading
        )
    {
        __GLvertex *pv = gc->vertex.provoking;
        pv->color = &pv->colors[__GL_FRONTFACE];
    }
#else
    pv->color = &pv->colors[__GL_FRONTFACE];
#endif
}



/************************************************************************/

/*
** Generic triangle handling code.  This code is used when render mode
** is GL_RENDER and both polygon modes are FILL and the triangle is
** being flat shaded.
*/
void FASTCALL __glRenderFlatTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			    __GLvertex *c)
{
    GLuint needs, pvneeds, modeFlags, faceNeeds;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *temp;

#ifdef NO_RENDERING
    return;
#endif
    
    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (__GL_FLOAT_EQZ(gc->polygon.shader.area))
	return;

    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
#ifdef GL_EXT_flat_paletted_lighting
    ASSERTOPENGL((modeFlags & __GL_SHADE_SMOOTH_LIGHT) == 0,
                 "Flat triangle with smooth shading\n");
    if ((gc->state.enables.general & __GL_PALETTED_LIGHTING_ENABLE) &&
        gc->texture.currentTexture != NULL)
    {
        __glPickLightingPalette(gc);
    }
#endif
#ifdef NT
//!!! don't we need to update a,b,c color pointers if cheap fog is enabled?
    if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
    {
	__GLvertex *pv = gc->vertex.provoking;

	/* Fill triangle */
	pv->color++;
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
	pv->color--;
    }
    else
    {
	/* Fill triangle */
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
    }
#else
    if (modeFlags & __GL_SHADE_TWOSIDED) {
	colorFace = face;
	faceNeeds = gc->vertex.faceNeeds[face];
    } else {
	colorFace = __GL_FRONTFACE;
	faceNeeds = gc->vertex.faceNeeds[__GL_FRONTFACE];
    }

    /*
    ** Choose colors for the vertices.
    */
    needs = gc->vertex.needs;
    pv = gc->vertex.provoking;

    /*
    ** Validate the lighting (and color) information in the provoking
    ** vertex only.  Fill routines always use gc->vertex.provoking->color
    ** to find the color.
    */
    pv->color = &pv->colors[colorFace];
    pvneeds = faceNeeds & (__GL_HAS_LIGHTING |
	    __GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR);
    if (~pv->has & pvneeds) {
	(*pv->validate)(gc, pv, pvneeds);
    }

    /* Validate vertices */
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);

    /* Fill triangle */
    (*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);

    /* Restore color pointers */
    pv->color = &pv->colors[__GL_FRONTFACE];
#endif
}

/************************************************************************/

/*
** Generic triangle handling code.  This code is used when render mode
** is GL_RENDER and both polygon modes are FILL and the triangle is
** being smooth shaded.
*/
void FASTCALL __glRenderSmoothTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			      __GLvertex *c)
 {
    GLuint needs, modeFlags;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *temp;

#ifdef NO_RENDERING
    return;
#endif
    
    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (__GL_FLOAT_EQZ(gc->polygon.shader.area))
	return;

    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
#ifdef GL_EXT_flat_paletted_lighting
    // No lighting because smooth shading is always on in this routine
#endif
#ifdef NT
    if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
    {
	/* Fill triangle */
	a->color++;
	b->color++;
	c->color++;
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
	a->color--;
	b->color--;
	c->color--;
    }
    else
    {
	/* Fill triangle */
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
    }
#else
    needs = gc->vertex.needs;
    if (modeFlags & __GL_SHADE_TWOSIDED) {
	colorFace = face;
	needs |= gc->vertex.faceNeeds[face];
    } else {
	colorFace = __GL_FRONTFACE;
	needs |= gc->vertex.faceNeeds[__GL_FRONTFACE];
    }

    /*
    ** Choose colors for the vertices.
    */
    a->color = &a->colors[colorFace];
    b->color = &b->colors[colorFace];
    c->color = &c->colors[colorFace];

    /* Validate vertices */
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);

    /* Fill triangle */
    (*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);

    /* Restore color pointers */
    a->color = &a->colors[__GL_FRONTFACE];
    b->color = &b->colors[__GL_FRONTFACE];
    c->color = &c->colors[__GL_FRONTFACE];
#endif
}


void FASTCALL __glDontRenderTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			    __GLvertex *c)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_polyd.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include <fixed.h>

/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

static void FASTCALL FillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint dxLeftFrac, dxRightFrac;
    GLint dxLeftLittle, dxRightLittle;
    GLint dxLeftBig, dxRightBig;
    GLint spanWidth, clipY0, clipY1;
    GLuint modeFlags;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;
    int iMaxWidth, iDy, dxLeft, dxRight;

    ixLeft = gc->polygon.shader.ixLeft;
    dxLeft = (gc->polygon.shader.dxLeftBig < gc->polygon.shader.dxLeftLittle) ?
        gc->polygon.shader.dxLeftBig : gc->polygon.shader.dxLeftLittle;
    ixRight = gc->polygon.shader.ixRight;
    dxRight = (gc->polygon.shader.dxRightBig > gc->polygon.shader.dxRightLittle) ?
        gc->polygon.shader.dxRightBig : gc->polygon.shader.dxRightLittle;
    iMaxWidth = ixRight - ixLeft;
    iDy = iyTop - iyBottom - 1;
    ixRight += dxRight * iDy;
    ixLeft += dxLeft * iDy;
    iMaxWidth = (iMaxWidth < (ixRight - ixLeft)) ? ixRight - ixLeft :
        iMaxWidth;
    
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (iMaxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
    
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, iMaxWidth * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, iMaxWidth * sizeof(__GLcolor));
        if (NULL == vFbcolors) {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLcolor vFbcolors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
#endif

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;
    dxLeftFrac = gc->polygon.shader.dxLeftFrac;
    dxLeftBig = gc->polygon.shader.dxLeftBig;
    dxLeftLittle = gc->polygon.shader.dxLeftLittle;
    dxRightFrac = gc->polygon.shader.dxRightFrac;
    dxRightBig = gc->polygon.shader.dxRightBig;
    dxRightLittle = gc->polygon.shader.dxRightLittle;
    modeFlags = gc->polygon.shader.modeFlags;

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    if (modeFlags & __GL_SHADE_STENCIL_TEST) {
        gc->polygon.shader.sbuf =
            __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
                              ixLeft, iyBottom);
    }
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
#ifdef NT
        if( gc->modes.depthBits == 32 )
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                ixLeft, iyBottom);
        else
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                ixLeft, iyBottom);
#else
        gc->polygon.shader.zbuf =
            __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                            ixLeft, iyBottom);
#endif
    }
    gc->polygon.shader.cfb = gc->drawBuffer;
    while (iyBottom < iyTop) {
        spanWidth = ixRight - ixLeft;
        /*
        ** Only render spans that have non-zero width and which are
        ** not scissored out vertically.
        */
        if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
            gc->polygon.shader.frag.x = ixLeft;
            gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.length = spanWidth;
            (*gc->procs.span.processSpan)(gc);
        }

        /* Advance right edge fixed point, adjusting for carry */
        ixRightFrac += dxRightFrac;
        if (ixRightFrac < 0) {
            /* Carry/Borrow'd. Use large step */
            ixRight += dxRightBig;
            ixRightFrac &= ~0x80000000;
        } else {
            ixRight += dxRightLittle;
        }

        iyBottom++;
        ixLeftFrac += dxLeftFrac;
        if (ixLeftFrac < 0) {
            /* Carry/Borrow'd.  Use large step */
            ixLeft += dxLeftBig;
            ixLeftFrac &= ~0x80000000;

            if (modeFlags & __GL_SHADE_RGB) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rBig;
                    gc->polygon.shader.frag.color.g += gc->polygon.shader.gBig;
                    gc->polygon.shader.frag.color.b += gc->polygon.shader.bBig;
                    gc->polygon.shader.frag.color.a += gc->polygon.shader.aBig;
                }
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sBig;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tBig;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwBig;
                }
            } else {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rBig;
                }
            }
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                    ((GLubyte*) gc->polygon.shader.sbuf
                     + gc->polygon.shader.sbufBig);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
            }

            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                    ((GLubyte*) gc->polygon.shader.zbuf
                     + gc->polygon.shader.zbufBig);
            }

            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fBig;
            }
        } else {
            /* Use small step */
            ixLeft += dxLeftLittle;
            if (modeFlags & __GL_SHADE_RGB) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rLittle;
                    gc->polygon.shader.frag.color.g += gc->polygon.shader.gLittle;
                    gc->polygon.shader.frag.color.b += gc->polygon.shader.bLittle;
                    gc->polygon.shader.frag.color.a += gc->polygon.shader.aLittle;
                }
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sLittle;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tLittle;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwLittle;
                }
            } else {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rLittle;
                }
            }
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                    ((GLubyte*) gc->polygon.shader.sbuf
                     + gc->polygon.shader.sbufLittle);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
            }
            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                    ((GLubyte*) gc->polygon.shader.zbuf
                     + gc->polygon.shader.zbufLittle);
            }

            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fLittle;
            }
        }
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
#ifdef NT
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
}

static void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    GLint ixLeft, ixLeftFrac, lineBytes, elementSize, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(xLeft);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixLeftFrac = __GL_VERTEX_PROMOTED_FRACTION(xLeft) + 0x40000000;

    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);
    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;

    /* Compute big and little steps */
    iLittle = FTOL(dxdyLeft);
    gc->polygon.shader.dxLeftFrac = FLT_FRACTION(dxdyLeft - iLittle);
    if (dxdyLeft < 0) {
	iBig = iLittle - 1;
    } else {
	iBig = iLittle + 1;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_STENCIL_TEST) {
	/*
	** Compute the big and little stencil buffer steps.  We walk the
	** memory pointers for the stencil buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
	elementSize = gc->stencilBuffer.buf.elementSize;
	lineBytes = elementSize * gc->stencilBuffer.buf.outerWidth;
	gc->polygon.shader.sbufLittle = lineBytes + iLittle * elementSize;
	gc->polygon.shader.sbufBig = lineBytes + iBig * elementSize;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
	/*
	** Compute the big and little depth buffer steps.  We walk the
	** memory pointers for the depth buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
	elementSize = gc->depthBuffer.buf.elementSize;
	lineBytes = elementSize * gc->depthBuffer.buf.outerWidth;
	gc->polygon.shader.zbufLittle = lineBytes + iLittle * elementSize;
	gc->polygon.shader.zbufBig = lineBytes + iBig * elementSize;
    }
    gc->polygon.shader.dxLeftLittle = iLittle;
    gc->polygon.shader.dxLeftBig = iBig;
}

static void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight)
{
    GLint ixRight, ixRightFrac, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixRight = __GL_VERTEX_FLOAT_TO_INT(xRight);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixRightFrac = __GL_VERTEX_PROMOTED_FRACTION(xRight) + 0x40000000;

    sh->ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);
    sh->ixRightFrac = ixRightFrac & ~0x80000000;

    /* Compute big and little steps */
    iLittle = FTOL(dxdyRight);
    sh->dxRightFrac = FLT_FRACTION(dxdyRight - iLittle);
    if (dxdyRight < 0) {
	iBig = iLittle - 1;
    } else {
	iBig = iLittle + 1;
    }
    sh->dxRightLittle = iLittle;
    sh->dxRightBig = iBig;
}


__GLfloat __glPolygonOffsetZ(__GLcontext *gc )
{

    __GLshade *sh = &gc->polygon.shader;
    __GLfloat factor;
    __GLfloat maxdZ;
    __GLfloat bias;
    __GLfloat offsetZ;

    /*
    ** Calculate factor and bias
    */
    factor = gc->state.polygon.factor;

    // For 16-bit z, bias = units,
    // For 32-bit z, we only have 24 bits of resolution from the floating
    // point z value.  Therefore, the minimum resolvable difference in z
    // values is 8-bits, and we multiply units by 2**8, or 256.

    if( gc->modes.depthBits == 16 )
        bias = gc->state.polygon.units;
    else
        bias = gc->state.polygon.units * __glVal256;

    /*
    ** find the maximum Z slope with respect to X and Y
    */
    // Note: all z values have already been scaled up from [0,1]
    if(__GL_ABSF(sh->dzdxf) > __GL_ABSF(sh->dzdyf))
        maxdZ = __GL_ABSF(sh->dzdxf);
    else
        maxdZ = __GL_ABSF(sh->dzdyf);

    offsetZ = factor * maxdZ + bias;

    // XXX! This value should really be clamped, but supposedly we don't
    // bother in other parts of the code, so leave it for now.  Clamping
    // should also only be applied AFTER the addition of offsetZ to any
    // base value.
    return( offsetZ );
}

#ifdef NT
static void SetInitialParameters(__GLcontext *gc, const __GLvertex *a,
				 const __GLcolor *ac, __GLfloat aFog,
				 __GLfloat dx, __GLfloat dy)
{
    __GLshade *sh = &gc->polygon.shader;
#else
static void SetInitialParameters(__GLshade *sh, const __GLvertex *a,
				 const __GLcolor *ac, __GLfloat aFog,
				 __GLfloat dx, __GLfloat dy)
{
#endif
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    GLuint modeFlags = sh->modeFlags;
#define bPolygonOffset \
        (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE )


    if (big > little) {
        if (modeFlags & __GL_SHADE_RGB) {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle + sh->drdx;
                
                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle + sh->dgdx;
                
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle + sh->dbdx;

                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle + sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                    + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle + sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                    + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle + sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                    + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle + sh->dqwdx;
                }
        } else {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle + sh->drdx;
            }
        }
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
            __GLfloat zLittle, zOffset;
            
            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if (gc->modes.depthBits == 16) {
                sh->frag.z = (__GLzValue)
                    FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                     + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle + sh->dzdxf);
            }
            else {
                sh->frag.z = (__GLzValue)
                    FTOL(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf +
                         zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle + sh->dzdxf);
            }
        }
        
        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle + sh->dfdx;
        }
    } else {	
        if (modeFlags & __GL_SHADE_RGB) {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle - sh->drdx;
                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle - sh->dgdx;
                
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle - sh->dbdx;
                
                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle - sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                    + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle - sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                    + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle - sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                    + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle - sh->dqwdx;
            }
        } else {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle - sh->drdx;
            }
        }
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
            __GLfloat zLittle, zOffset;
            
            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if(( gc->modes.depthBits == 16 ) &&
               ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
                sh->frag.z = (__GLzValue)
                    FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                     + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle - sh->dzdxf);
            }
            else {
                sh->frag.z = (__GLzValue)
                    FTOL( a->window.z + dx*sh->dzdxf + dy*sh->dzdyf+ zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle - sh->dzdxf);
            }
        }
        
        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle - sh->dfdx;
        }
    }
}


void FASTCALL __glFillTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
		      __GLvertex *c, GLboolean ccw)

{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLfloat aFog, bFog;
    __GLfloat dxAB, dyAB;
    __GLfloat dx, dy, dxdyLeft, dxdyRight;
    __GLcolor *ac, *bc;
    GLint aIY, bIY, cIY;
    GLuint modeFlags;
    __GLfloat dxdyAC;

    CHOP_ROUND_ON();
    
    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);

    /* Fetch some stuff we are going to reuse */
    modeFlags = gc->polygon.shader.modeFlags;
    dxAC = gc->polygon.shader.dxAC;
    dxBC = gc->polygon.shader.dxBC;
    dyAC = gc->polygon.shader.dyAC;
    dyBC = gc->polygon.shader.dyBC;
    ac = a->color;
    bc = b->color;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */

    __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    t1 = dyAC * oneOverArea;
    t2 = dyBC * oneOverArea;
    t3 = dxAC * oneOverArea;
    t4 = dxBC * oneOverArea;
    
    if (modeFlags & __GL_SHADE_RGB) {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    dgAC = ac->g - cc->g;
	    dgBC = bc->g - cc->g;
	    dbAC = ac->b - cc->b;
	    dbBC = bc->b - cc->b;
	    daAC = ac->a - cc->a;
	    daBC = bc->a - cc->a;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	    gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
	    gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
	    gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
	    gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;
	    gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
	    gc->polygon.shader.dady = daBC * t3 - daAC * t4;
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color = *flatColor;
	}
	if (modeFlags & __GL_SHADE_TEXTURE) {
	    __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
	    __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;

	    awinv = a->window.w;
	    bwinv = b->window.w;
	    cwinv = c->window.w;
	    scwinv = c->texture.x * cwinv;
	    tcwinv = c->texture.y * cwinv;
	    qwcwinv = c->texture.w * cwinv;

	    dsAC = a->texture.x * awinv - scwinv;
	    dsBC = b->texture.x * bwinv - scwinv;
	    dtAC = a->texture.y * awinv - tcwinv;
	    dtBC = b->texture.y * bwinv - tcwinv;
	    dqwAC = a->texture.w * awinv - qwcwinv;
	    dqwBC = b->texture.w * bwinv - qwcwinv;

	    gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
	    gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;
	    gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
	    gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;
	    gc->polygon.shader.dqwdx = dqwAC * t2 - dqwBC * t1;
	    gc->polygon.shader.dqwdy = dqwBC * t3 - dqwAC * t4;

	}
    } else {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color.r = flatColor->r;
	}
    }
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	__GLfloat dzAC, dzBC;

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;

	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
#ifdef NT
	if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
	    gc->polygon.shader.dzdx = 
                FLT_TO_Z16_SCALE(gc->polygon.shader.dzdxf);
	}
	else {
	    gc->polygon.shader.dzdx = FTOL(gc->polygon.shader.dzdxf);
	}
#else
	gc->polygon.shader.dzdx = (GLint) gc->polygon.shader.dzdxf;
#endif
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        aFog = a->eyeZ;
        bFog = b->eyeZ;
        cFog = c->eyeZ;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;
        
        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        aFog = a->fog;
        bFog = b->fog;
        cFog = c->fog;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;
        
        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
    

    __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(dxAC, dyAC, dxdyAC);
    
    /* Snap each y coordinate to its pixel center */
    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    /*
    ** This algorithim always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */
    dxAB = a->window.x - b->window.x;
    dyAB = a->window.y - b->window.y;
    if (ccw) {
	dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
	SnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);
	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
#ifdef NT
	SetInitialParameters(gc, a, ac, aFog, dx, dy);
#else
	SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
#endif
	if (aIY != bIY) {
	    dxdyRight = dxAB / dyAB;
	    SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight,
		       dxdyRight);
	    FillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyRight = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXRight(&gc->polygon.shader, b->window.x + dy*dxdyRight,
		       dxdyRight);
	    FillSubTriangle(gc, bIY, cIY);
	}
    } else {
	dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
	SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyAC, dxdyAC);
	if (aIY != bIY) {
	    dxdyLeft = dxAB / dyAB;
	    SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
#ifdef NT
	    SetInitialParameters(gc, a, ac, aFog, dx, dy);
#else
	    SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
#endif
	    FillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyLeft = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXLeft(gc, b->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
#ifdef NT
	    SetInitialParameters(gc, b, bc, bFog, dx, dy);
#else
	    SetInitialParameters(&gc->polygon.shader, b, bc, bFog, dx, dy);
#endif
	    FillSubTriangle(gc, bIY, cIY);
	}
    }

    CHOP_ROUND_OFF();

}

void FASTCALL __glFillFlatFogTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                             __GLvertex *c, GLboolean ccw)
{
    __GLcolor acol, bcol, ccol;
    __GLcolor *aocp, *bocp, *cocp;
    __GLvertex *pv;

    pv = gc->vertex.provoking;
    (*gc->procs.fogColor)(gc, &acol, pv->color, a->fog);
    (*gc->procs.fogColor)(gc, &bcol, pv->color, b->fog);
    (*gc->procs.fogColor)(gc, &ccol, pv->color, c->fog);
    aocp = a->color;
    bocp = b->color;
    cocp = c->color;
    a->color = &acol;
    b->color = &bcol;
    c->color = &ccol;

    (*gc->procs.fillTriangle2)(gc, a, b, c, ccw);

    a->color = aocp;
    b->color = bocp;
    c->color = cocp;
}

#ifdef GL_WIN_specular_fog
void FASTCALL __glFillFlatSpecFogTriangle(__GLcontext *gc, __GLvertex *a, 
                                          __GLvertex *b, __GLvertex *c, 
                                          GLboolean ccw)
{
    __GLfloat af, bf, cf;
    __GLvertex *pv;

    pv = gc->vertex.provoking;
    
    af = a->fog;
    bf = b->fog;
    cf = c->fog;
    
    a->fog = b->fog = c->fog = pv->fog;
    
    (*gc->procs.fillTriangle2)(gc, a, b, c, ccw);

    a->fog = af;
    b->fog = bf;
    c->fog = cf;
}
#endif //GL_WIN_specular_fog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_polya.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#ifdef GL_WIN_phong_shading
#include "phong.h"
#endif //GL_WIN_phong_shading


/*
** Normal form of a line: Ax + By + C = 0.  When evaluated at a point P,
** the value is zero when P is on the line.  For points off the line,
** the sign of the value determines which side of the line P is on.
*/
typedef struct {
    __GLfloat a, b, c;

    /*
    ** The sign of an edge is determined by plugging the third vertex
    ** of the triangle into the line equation.  This flag is GL_TRUE when
    ** the sign is positive.
    */
    GLboolean edgeSign;
} __glLineEquation;

/*
** Machine state for rendering triangles.
*/
typedef struct {
    __GLfloat dyAB;
    __GLfloat dyBC;
    __glLineEquation ab;
    __glLineEquation bc;
    __glLineEquation ca;
    __GLfloat area;
    GLint areaSign;
} __glTriangleMachine;

/*
** Plane equation coefficients.  One plane equation exists for each of
** the parameters being computed across the surface of the triangle.
*/
typedef struct {
    __GLfloat a, b, c, d;
} __glPlaneEquation;

/*
** Cache for some of the coverage computation constants.
*/
typedef struct {
    __GLfloat dx, dy;
    GLint samples;
    GLint samplesSquared;
    __GLfloat samplesSquaredInv;
    GLboolean lastCoverageWasOne;
    __GLfloat leftDelta, rightDelta;
    __GLfloat bottomDelta, topDelta;
} __glCoverageStuff;

/*
** Compute the constants A, B and C for a line equation in the general
** form:  Ax + By + C = 0.  A given point at (x,y) can be plugged into
** the left side of the equation and yield a number which indiates whether
** or not the point is on the line.  If the result is zero, then the point
** is on the line.  The sign of the result determines which side of
** the line the point is on.  To handle tie cases properly we need a way
** to assign a point on the edge to only one triangle.  To do this, we
** look at the sign of the equation evaluated at "c".  For edges whose
** sign at "c" is positive, we allow points on the edge to be in the
** triangle.
*/
static void FindLineEqation(__glLineEquation *eq, const __GLvertex *a,
			    const __GLvertex *b, const __GLvertex *c)
{
    __GLfloat dy, dx, valueAtC;

    /*
    ** Sort a,b so that the ordering of the verticies is consistent,
    ** regardless of the order given to this procedure.
    */
    if (b->window.y < a->window.y) {
	const __GLvertex *temp = b;
	b = a;
	a = temp;
    } else
    if ((b->window.y == a->window.y) && (b->window.x < a->window.x)) {
	const __GLvertex *temp = b;
	b = a;
	a = temp;
    }

    dy = b->window.y - a->window.y;
    dx = b->window.x - a->window.x;
    eq->a = -dy;
    eq->b = dx;
    eq->c = dy * a->window.x - dx * a->window.y;

    valueAtC = eq->a * c->window.x + eq->b * c->window.y + eq->c;
    if (valueAtC > 0) {
	eq->edgeSign = GL_TRUE;
    } else {
	eq->edgeSign = GL_FALSE;
    }
}

/*
** Given three points in (x,y,p) find the plane equation coeffecients
** for the plane that contains the three points.  First find the cross
** product of two of the vectors defined by the three points, then
** use one of the points to find "d".
*/
static void FindPlaneEquation(__glPlaneEquation *eq,
			      const __GLvertex *a, const __GLvertex *b,
			      const __GLvertex *c, __GLfloat p1,
			      __GLfloat p2, __GLfloat p3)
{
    __GLfloat v1x, v1y, v1p;
    __GLfloat v2x, v2y, v2p;
    __GLfloat nx, ny, np, k;

    /* find vector v1 */
    v1x = b->window.x - a->window.x;
    v1y = b->window.y - a->window.y;
    v1p = p2 - p1;

    /* find vector v2 */
    v2x = c->window.x - a->window.x;
    v2y = c->window.y - a->window.y;
    v2p = p3 - p1;

    /* find the cross product (== normal) for the plane */
    nx = v1y*v2p - v1p*v2y;
    ny = v1p*v2x - v1x*v2p;
    np = v1x*v2y - v1y*v2x;

    /*
    ** V dot N = k.  Find k.  We can use any of the three points on
    ** the plane, so we use a.
    */
    k = a->window.x*nx + a->window.y*ny + p1*np;

    /*
    ** Finally, setup the plane equation coeffecients.  Force c to be one
    ** by dividing everything through by c.
    */
    eq->a = nx / np;
    eq->b = ny / np;
    eq->c = ((__GLfloat) 1.0);
    eq->d = -k / np;
}

/*
** Solve for p in the plane equation.
*/
static __GLfloat FindP(__glPlaneEquation *eq, __GLfloat x, __GLfloat y)
{
    return -(eq->a * x + eq->b * y + eq->d);
}

/*
** See if a given point is on the same side of the edge as the other
** vertex in the triangle not part of this edge.  When the line
** equation evaluates to zero, make points which are on lines with
** a negative edge sign (edgeSign GL_FALSE) part of the triangle.
*/
#define In(eq,x,y) \
    (((eq)->a * (x) + (eq)->b * (y) + (eq)->c > 0) == (eq)->edgeSign)

/*
** Determine if the point x,y is in or out of the triangle.  Evaluate
** each line equation for the point and compare the sign of the result
** with the edgeSign flag.
*/
#define Inside(tm,x,y) \
    (In(&(tm)->ab, x, y) && In(&(tm)->bc, x, y) && In(&(tm)->ca, x, y))

#define	FILTER_WIDTH	((__GLfloat) 1.0)
#define	FILTER_HEIGHT	((__GLfloat) 1.0)

/*
** Precompute stuff that is constant for all coverage tests.
*/
static void FASTCALL ComputeCoverageStuff(__glCoverageStuff *cs, GLint samples)
{
    __GLfloat dx, dy, fs = samples;
    __GLfloat half = ((__GLfloat) 0.5);

    cs->dx = dx = FILTER_WIDTH / fs;
    cs->dy = dy = FILTER_HEIGHT / fs;
    cs->leftDelta = -(FILTER_WIDTH / 2) + dx * half;
    cs->rightDelta = (FILTER_WIDTH / 2) - dx * half;
    cs->bottomDelta = -(FILTER_HEIGHT / 2) + dy * half;
    cs->topDelta = (FILTER_HEIGHT / 2) - dy * half;
    cs->samplesSquared = samples * samples;
    cs->samplesSquaredInv = ((__GLfloat) 1.0) / cs->samplesSquared;
    cs->samples = samples;
}

/*
** Return an estimate of the pixel coverage using sub-sampling.
*/
static __GLfloat Coverage(__glTriangleMachine *tm, __GLfloat *xs,
			  __GLfloat *ys, __glCoverageStuff *cs)
{
    GLint xx, yy, hits, samples;
    __GLfloat dx, dy, yBottom, px, py;
    __GLfloat minX, minY, maxX, maxY;

    hits = 0;
    samples = cs->samples;
    dx = cs->dx;
    dy = cs->dy;
    px = *xs + cs->leftDelta;
    yBottom = *ys + cs->bottomDelta;

    /*
    ** If the last coverage was one (the pixel to the left in x from us),
    ** then if the upper right and lower right sample positions are
    ** also in then this entire pixel must be in.
    */
    if (cs->lastCoverageWasOne) {
	__GLfloat urx, ury;
	urx = *xs + cs->rightDelta;
	ury = *ys + cs->topDelta;
	if (Inside(tm, urx, ury) && Inside(tm, urx, yBottom)) {
	    return ((__GLfloat) 1.0);
	}
    }

    /*
    ** Setup minimum and maximum x,y coordinates.  The min and max values
    ** are used to find a "good" point that is actually within the
    ** triangle so that parameter values can be computed correctly.
    */
    minX = 999999;
    maxX = __glMinusOne;
    minY = 999999;
    maxY = __glMinusOne;
    for (xx = 0; xx < samples; xx++) {
	py = yBottom;
	for (yy = 0; yy < samples; yy++) {
	    if (Inside(tm, px, py)) {
		if (px < minX) minX = px;
		if (px > maxX) maxX = px;
		if (py < minY) minY = py;
		if (py > maxY) maxY = py;
		hits++;
	    }
	    py += dy;
	}
	px += dx;
    }
    if (hits) {
	/*
	** Return the average of the two coordinates which is guaranteed
	** to be in the triangle.
	*/
	*xs = (minX + maxX) * ((__GLfloat) 0.5);
	*ys = (minY + maxY) * ((__GLfloat) 0.5);
	if (hits == cs->samplesSquared) {
	    /* Keep track when the last coverage was one */
	    cs->lastCoverageWasOne = GL_TRUE;
	    return ((__GLfloat) 1.0);
	}
    }
    cs->lastCoverageWasOne = GL_FALSE;
    return hits * cs->samplesSquaredInv;
}

/*
** Force f to have no more precision than the subpixel precision allows.
** Even though "f" is biased this still works and does not generate an
** overflow.
*/
#define __GL_FIX_PRECISION(f)					 \
    ((__GLfloat) ((GLint) (f * (1 << gc->constants.subpixelBits))) \
     / (1 << gc->constants.subpixelBits))

void FASTCALL __glFillAntiAliasedTriangle(__GLcontext *gc, __GLvertex *a,
				 __GLvertex *b, __GLvertex *c,
				 GLboolean ccw)
{
    __glTriangleMachine tm;
    __glCoverageStuff cs;
    __GLcolor *ca, *cb, *cc, *flatColor;
    GLint x, y, left, right, bottom, top, samples;
    __glPlaneEquation qwp, zp, rp, gp, bp, ap, ezp, sp, tp;
    __glPlaneEquation fp;
    GLboolean rgbMode;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    __GLfloat zero = __glZero;
    __GLfloat area, ax, bx, cx, ay, by, cy;
    __GLshade *sh = &gc->polygon.shader;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

#ifdef __GL_LINT
    ccw = ccw;
#endif
    /*
    ** Recompute the area of the triangle after constraining the incoming
    ** coordinates to the subpixel precision.  The viewport bias gives
    ** more precision (typically) than the subpixel precision.  Because of
    ** this the algorithim below can fail to reject an essentially empty
    ** triangle and instead fill a large area.  The scan converter fill
    ** routines (eg polydraw.c) don't have this trouble because of the
    ** very nature of edge walking.
    **
    ** NOTE: Notice that here as in other places, when the area calculation
    ** is done we are careful to do it as a series of subtractions followed by
    ** multiplications.  This is done to guarantee that no overflow will
    ** occur (remember that the coordinates are biased by a potentially large
    ** number, and that multiplying two biased numbers will square the bias).
    */
    ax = __GL_FIX_PRECISION(a->window.x);
    bx = __GL_FIX_PRECISION(b->window.x);
    cx = __GL_FIX_PRECISION(c->window.x);
    ay = __GL_FIX_PRECISION(a->window.y);
    by = __GL_FIX_PRECISION(b->window.y);
    cy = __GL_FIX_PRECISION(c->window.y);
    area = (ax - cx) * (by - cy) - (bx - cx) * (ay - cy);
    if (area == zero) {
        return;
    }

    ca = a->color;
    cb = b->color;
    cc = c->color;
    flatColor = gc->vertex.provoking->color;

    /*
    ** Construct plane equations for all of the parameters that are
    ** computed for the triangle: z, r, g, b, a, s, t, f
    */
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        FindPlaneEquation(&zp, a, b, c, a->window.z, b->window.z, c->window.z);
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        FindPlaneEquation(&ezp, a, b, c, a->eyeZ, b->eyeZ, c->eyeZ);
    } 
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        FindPlaneEquation(&fp, a, b, c, a->fog, b->fog, c->fog);
    }

    if (modeFlags & __GL_SHADE_TEXTURE) {
        __GLfloat one = __glOne;
        __GLfloat aWInv = a->window.w;
        __GLfloat bWInv = b->window.w;
        __GLfloat cWInv = c->window.w;
        FindPlaneEquation(&qwp, a, b, c, a->texture.w * aWInv,
                          b->texture.w * bWInv, c->texture.w * cWInv);
        FindPlaneEquation(&sp, a, b, c, a->texture.x * aWInv,
                          b->texture.x * bWInv, c->texture.x * cWInv);
        FindPlaneEquation(&tp, a, b, c, a->texture.y * aWInv,
                          b->texture.y * bWInv, c->texture.y * cWInv);
    }
    rgbMode = gc->modes.rgbMode;
    if (modeFlags & __GL_SHADE_SMOOTH) {
        FindPlaneEquation(&rp, a, b, c, ca->r, cb->r, cc->r);
        if (rgbMode) {
            FindPlaneEquation(&gp, a, b, c, ca->g, cb->g, cc->g);
            FindPlaneEquation(&bp, a, b, c, ca->b, cb->b, cc->b);
            FindPlaneEquation(&ap, a, b, c, ca->a, cb->a, cc->a);
        }
    }

    /*
    ** Compute general form of the line equations for each of the
    ** edges of the triangle.
    */
    FindLineEqation(&tm.ab, a, b, c);
    FindLineEqation(&tm.bc, b, c, a);
    FindLineEqation(&tm.ca, c, a, b);

    /* Compute bounding box of the triangle */
    left = (GLint)a->window.x;
    if (b->window.x < left) left = (GLint)b->window.x;
    if (c->window.x < left) left = (GLint)c->window.x;
    right = (GLint)a->window.x;
    if (b->window.x > right) right = (GLint)b->window.x;
    if (c->window.x > right) right = (GLint)c->window.x;
    bottom = (GLint)a->window.y;
    if (b->window.y < bottom) bottom = (GLint)b->window.y;
    if (c->window.y < bottom) bottom = (GLint)c->window.y;
    top = (GLint)a->window.y;
    if (b->window.y > top) top = (GLint)b->window.y;
    if (c->window.y > top) top = (GLint)c->window.y;

    /* Bloat the bounding box when anti aliasing */
    left -= (GLint)FILTER_WIDTH;
    right += (GLint)FILTER_WIDTH;
    bottom -= (GLint)FILTER_HEIGHT;
    top += (GLint)FILTER_HEIGHT;
    
    /* Init coverage computations */
    samples = (gc->state.hints.polygonSmooth == GL_NICEST) ? 8 : 4;
    ComputeCoverageStuff(&cs, samples);
    
    /* Scan over the bounding box of the triangle */
    for (y = bottom; y <= top; y++) {
        cs.lastCoverageWasOne = GL_FALSE;
        for (x = left; x <= right; x++) {
            __GLfloat coverage;
            __GLfloat xs, ys;

            if (modeFlags & __GL_SHADE_STIPPLE) {
                /*
                ** Check the window coordinate against the stipple and
                ** and see if the pixel can be written
                */
                GLint row = y & 31;
                GLint col = x & 31;
                if ((gc->polygon.stipple[row] & (1<<col)) == 0) {
                    /*
                    ** Stipple bit is clear.  Do not render this pixel
                    ** of the triangle.
                    */
                    continue;
                }
            }
        
            xs = x + __glHalf;      /* sample point is at pixel center */
            ys = y + __glHalf;
            coverage = Coverage(&tm, &xs, &ys, &cs);
            if (coverage != zero) {
                __GLfragment frag;

                /*
                ** Fill in fragment for rendering.  First compute the color
                ** of the fragment.
                */
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    frag.color.r = FindP(&rp, xs, ys);
                    if (rgbMode) {
                        frag.color.g = FindP(&gp, xs, ys);
                        frag.color.b = FindP(&bp, xs, ys);
                        frag.color.a = FindP(&ap, xs, ys);
                    }
                } else {
                    frag.color.r = flatColor->r;
                    if (rgbMode) {
                        frag.color.g = flatColor->g;
                        frag.color.b = flatColor->b;
                        frag.color.a = flatColor->a;
                    }
                }
            
                /*
                ** Texture the fragment.
                */
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    __GLfloat qw, s, t, rho;
                
                    qw = FindP(&qwp, xs, ys);
                    s = FindP(&sp, xs, ys);
                    t = FindP(&tp, xs, ys);
                    rho = (*gc->procs.calcPolygonRho)(gc, sh, s, t, qw);
#ifdef NT
                    if( qw == (__GLfloat) 0.0 )
                        s = t = (__GLfloat) 0;
                    else {
                        s /= qw;
                        t /= qw;
                    }
#else
                    s /= qw;
                    t /= qw;
#endif
                    (*gc->procs.texture)(gc, &frag.color, s, t, rho);
                }
            
                /*
                ** Fog the resulting color.
                */
                if (modeFlags & __GL_SHADE_COMPUTE_FOG)
                {
                    __GLfloat eyeZ = FindP(&ezp, xs, ys);
                    __glFogFragmentSlow(gc, &frag, eyeZ);
                }
                else if (modeFlags & __GL_SHADE_INTERP_FOG)
                {
                    __GLfloat fog = FindP(&fp, xs, ys);
                    __glFogColorSlow(gc, &(frag.color), &(frag.color), fog);  
                }

                /*
                ** Apply anti-aliasing effect
                */
                if (rgbMode) {
                    frag.color.a *= coverage;
                } else {
                    frag.color.r =
                      __glBuildAntiAliasIndex(frag.color.r,
                                              coverage);
                }
                
                /*
                ** Finally, render the fragment.
                */
                frag.x = (GLint)xs;
                frag.y = (GLint)ys;
                if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                    frag.z = (__GLzValue)FindP(&zp, xs, ys);
                }
                (*gc->procs.store)(cfb, &frag);
            }
        }
    }
}


#ifdef GL_WIN_phong_shading

void FASTCALL __glFillAntiAliasedPhongTriangle(__GLcontext *gc, __GLvertex *a,
                                               __GLvertex *b, __GLvertex *c,
                                               GLboolean ccw)
{
#if 1
    __glTriangleMachine tm;
    __glCoverageStuff cs;
    __GLcolor *ca, *cb, *cc, *flatColor;
    GLint x, y, left, right, bottom, top, samples;
    __glPlaneEquation qwp, zp, rp, gp, bp, ap, ezp, sp, tp;
    __glPlaneEquation exp, eyp, ewp, nxp, nyp, nzp;
    __glPlaneEquation fp;
    GLboolean rgbMode;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    __GLfloat zero = __glZero;
    __GLfloat area, ax, bx, cx, ay, by, cy;
    __GLshade *sh = &gc->polygon.shader;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLcoord *na, *nb, *nc, ea, eb, ec;
    GLuint msm_colorMaterialChange, flags=0;
    GLboolean needColor, needEye;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    
    if (gc->polygon.shader.phong.face == __GL_FRONTFACE)
        msm_colorMaterialChange = gc->light.back.colorMaterialChange;
    else
        msm_colorMaterialChange = gc->light.back.colorMaterialChange;

    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB))
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;

    //Compute Invariant color if possible
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    gc->polygon.shader.phong.flags |= flags;

    needColor = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_COLOR_XPOLATE);
    needEye = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_EYE_XPOLATE);

#ifdef __GL_LINT
    ccw = ccw;
#endif
    /*
    ** Recompute the area of the triangle after constraining the incoming
    ** coordinates to the subpixel precision.  The viewport bias gives
    ** more precision (typically) than the subpixel precision.  Because of
    ** this the algorithim below can fail to reject an essentially empty
    ** triangle and instead fill a large area.  The scan converter fill
    ** routines (eg polydraw.c) don't have this trouble because of the
    ** very nature of edge walking.
    **
    ** NOTE: Notice that here as in other places, when the area calculation
    ** is done we are careful to do it as a series of subtractions followed by
    ** multiplications.  This is done to guarantee that no overflow will
    ** occur (remember that the coordinates are biased by a potentially large
    ** number, and that multiplying two biased numbers will square the bias).
    */
    ax = __GL_FIX_PRECISION(a->window.x);
    bx = __GL_FIX_PRECISION(b->window.x);
    cx = __GL_FIX_PRECISION(c->window.x);
    ay = __GL_FIX_PRECISION(a->window.y);
    by = __GL_FIX_PRECISION(b->window.y);
    cy = __GL_FIX_PRECISION(c->window.y);
    area = (ax - cx) * (by - cy) - (bx - cx) * (ay - cy);
    if (area == zero) {
        return;
    }

    na = &a->normal;
    nb = &b->normal;
    nc = &c->normal;

    if (needColor)
    {
      ca = a->color;
      cb = b->color;
      cc = c->color;
      flatColor = gc->vertex.provoking->color;
    }

    if (needEye)
    {
        ea.x = a->eyeX; ea.y = a->eyeY; ea.z = a->eyeZ; ea.w = a->eyeW; 
        eb.x = b->eyeX; eb.y = b->eyeY; eb.z = b->eyeZ; eb.w = b->eyeW; 
        ec.x = c->eyeX; ec.y = c->eyeY; ec.z = c->eyeZ; ec.w = c->eyeW; 
    }
    

    /*
    ** Construct plane equations for all of the parameters that are
    ** computed for the triangle: z, r, g, b, a, s, t, f
    */
    if (modeFlags & __GL_SHADE_DEPTH_ITER) 
    {
        FindPlaneEquation(&zp, a, b, c, a->window.z, b->window.z, 
                          c->window.z);
    }

#ifdef GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        FindPlaneEquation(&ezp, a, b, c, a->eyeZ, b->eyeZ, c->eyeZ);
    } 
    else if (modeFlags & __GL_SHADE_INTERP_FOG) 
    {
        __GLfloat aFog = 1.0f, bFog = 1.0f, cFog = 1.0f;

        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            aFog = ComputeSpecValue (gc, a);
            bFog = ComputeSpecValue (gc, b);
            cFog = ComputeSpecValue (gc, c);
        }

        if (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)
        {
            aFog *= a->fog;
            bFog *= b->fog;
            cFog *= c->fog;
        }

        FindPlaneEquation(&fp, a, b, c, aFog, bFog, cFog);
    }
#else //GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_SLOW_FOG) 
    {
        FindPlaneEquation(&ezp, a, b, c, a->eyeZ, b->eyeZ, c->eyeZ);
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG) 
    {
        FindPlaneEquation(&fp, a, b, c, a->fog, b->fog, c->fog);
    }
#endif //GL_WIN_specular_fog

    if (modeFlags & __GL_SHADE_TEXTURE) 
    {
        __GLfloat one = __glOne;
        __GLfloat aWInv = a->window.w;
        __GLfloat bWInv = b->window.w;
        __GLfloat cWInv = c->window.w;
        FindPlaneEquation(&qwp, a, b, c, a->texture.w * aWInv,
                          b->texture.w * bWInv, c->texture.w * cWInv);
        FindPlaneEquation(&sp, a, b, c, a->texture.x * aWInv,
                          b->texture.x * bWInv, c->texture.x * cWInv);
        FindPlaneEquation(&tp, a, b, c, a->texture.y * aWInv,
                          b->texture.y * bWInv, c->texture.y * cWInv);
    }

    rgbMode = gc->modes.rgbMode;

    if (needColor)
    {
        if (modeFlags & __GL_SHADE_SMOOTH) {
            FindPlaneEquation(&rp, a, b, c, ca->r, cb->r, cc->r);
            if (rgbMode) {
               FindPlaneEquation(&gp, a, b, c, ca->g, cb->g, cc->g);
               FindPlaneEquation(&bp, a, b, c, ca->b, cb->b, cc->b);
               FindPlaneEquation(&ap, a, b, c, ca->a, cb->a, cc->a);
            }
        }
    }
    
    if (needEye)
    {
        FindPlaneEquation(&exp, a, b, c, ea.x, eb.x, ec.x);
        FindPlaneEquation(&eyp, a, b, c, ea.y, eb.y, ec.y);
        // FindPlaneEquation(&ezp, a, b, c, ea.z, eb.z, ec.z);
        FindPlaneEquation(&ewp, a, b, c, ea.w, eb.w, ec.w);
    }

    FindPlaneEquation(&nxp, a, b, c, na->x, nb->x, nc->x);
    FindPlaneEquation(&nyp, a, b, c, na->y, nb->y, nc->y);
    FindPlaneEquation(&nzp, a, b, c, na->z, nb->z, nc->z);

    /*
    ** Compute general form of the line equations for each of the
    ** edges of the triangle.
    */
    FindLineEqation(&tm.ab, a, b, c);
    FindLineEqation(&tm.bc, b, c, a);
    FindLineEqation(&tm.ca, c, a, b);

    /* Compute bounding box of the triangle */
    left = (GLint)a->window.x;
    if (b->window.x < left) left = (GLint)b->window.x;
    if (c->window.x < left) left = (GLint)c->window.x;
    right = (GLint)a->window.x;
    if (b->window.x > right) right = (GLint)b->window.x;
    if (c->window.x > right) right = (GLint)c->window.x;
    bottom = (GLint)a->window.y;
    if (b->window.y < bottom) bottom = (GLint)b->window.y;
    if (c->window.y < bottom) bottom = (GLint)c->window.y;
    top = (GLint)a->window.y;
    if (b->window.y > top) top = (GLint)b->window.y;
    if (c->window.y > top) top = (GLint)c->window.y;

    /* Bloat the bounding box when anti aliasing */
    left -= (GLint)FILTER_WIDTH;
    right += (GLint)FILTER_WIDTH;
    bottom -= (GLint)FILTER_HEIGHT;
    top += (GLint)FILTER_HEIGHT;

    /* Init coverage computations */
    samples = (gc->state.hints.polygonSmooth == GL_NICEST) ? 8 : 4;
    ComputeCoverageStuff(&cs, samples);

    /* Scan over the bounding box of the triangle */
    for (y = bottom; y <= top; y++) 
    {
        cs.lastCoverageWasOne = GL_FALSE;
        for (x = left; x <= right; x++) 
        {
            __GLfloat coverage;
            __GLfloat xs, ys;

            if (modeFlags & __GL_SHADE_STIPPLE) 
            {
                /*
                ** Check the window coordinate against the stipple and
                ** and see if the pixel can be written
                */
                GLint row = y & 31;
                GLint col = x & 31;
                if ((gc->polygon.stipple[row] & (1<<col)) == 0) 
                {
                    /*
                    ** Stipple bit is clear.  Do not render this pixel
                    ** of the triangle.
                    */
                    continue;
                }
            }

            xs = x + __glHalf;      /* sample point is at pixel center */
            ys = y + __glHalf;
            coverage = Coverage(&tm, &xs, &ys, &cs);
            if (coverage != zero) 
            {
                __GLfragment frag;
                /*
                ** Fill in fragment for rendering.  First compute the color
                ** of the fragment.
                */
                phong->nTmp.x = FindP(&nxp, xs, ys);
                phong->nTmp.y = FindP(&nyp, xs, ys);
                phong->nTmp.z = FindP(&nzp, xs, ys);

                if (needColor) 
                {
                    phong->tmpColor.r = FindP(&rp, xs, ys);
                    if (modeFlags & __GL_SHADE_RGB) 
                    {
                        phong->tmpColor.g = FindP(&gp, xs, ys);
                        phong->tmpColor.b = FindP(&bp, xs, ys);
                        phong->tmpColor.a = FindP(&ap, xs, ys);
                    }
                }
                
                if (needEye) 
                {
                    phong->eTmp.x = FindP(&exp, xs, ys);
                    phong->eTmp.y = FindP(&eyp, xs, ys);
                    phong->eTmp.z = FindP(&ezp, xs, ys);
                    phong->eTmp.w = FindP(&ewp, xs, ys);
                }
                
                
                if (modeFlags & __GL_SHADE_RGB)
                    (*gc->procs.phong.ComputeRGBColor) (gc, &(frag.color));
                else
                    (*gc->procs.phong.ComputeCIColor) (gc, &(frag.color));

                /*
                ** Texture the fragment.
                */
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    __GLfloat qw, s, t, rho;

                    qw = FindP(&qwp, xs, ys);
                    s = FindP(&sp, xs, ys);
                    t = FindP(&tp, xs, ys);
                    rho = (*gc->procs.calcPolygonRho)(gc, sh, s, t, qw);
                    if( qw == (__GLfloat) 0.0 )
                        s = t = (__GLfloat) 0;
                    else {
                        s /= qw;
                        t /= qw;
                    }
                    (*gc->procs.texture)(gc, &frag.color, s, t, rho);
                }

                /*
                ** Fog the resulting color.
                */
                if (modeFlags & __GL_SHADE_COMPUTE_FOG)
                {
                    __GLfloat eyeZ = FindP(&ezp, xs, ys);
                    __glFogFragmentSlow(gc, &frag, eyeZ);
                } 
                else if (modeFlags & __GL_SHADE_INTERP_FOG) 
                {
                    __GLfloat fog = FindP(&fp, xs, ys);
                    __glFogColorSlow(gc, &(frag.color), &(frag.color), fog);  
                }

                /*
                ** Apply anti-aliasing effect
                */
                if (rgbMode) {
                    frag.color.a *= coverage;
                } else {
                    frag.color.r =
                      __glBuildAntiAliasIndex(frag.color.r,
                                          coverage);
                }

                /*
                ** Finally, render the fragment.
                */
                frag.x = (GLint)xs;
                frag.y = (GLint)ys;
                if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                    frag.z = (__GLzValue)FindP(&zp, xs, ys);
                }
                (*gc->procs.store)(cfb, &frag);
            }
        }
    }
#endif
}
#endif //GL_WIN_phong_shading
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_polys.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** Process the incoming span by calling all of the appropriate span procs.
*/
GLboolean FASTCALL __glProcessSpan(__GLcontext *gc)
{
    GLint m, i;

    m = gc->procs.span.m;

    gc->polygon.shader.done = GL_FALSE;
    for (i = 0; i < m; i++) {
        if ((*gc->procs.span.spanFuncs[i])(gc)) {
            i++;
            break;
        }
    }

    if (i != m && !gc->polygon.shader.done) {
        for (; i<m; i++) {
            if ((*gc->procs.span.stippledSpanFuncs[i])(gc)) {
                break;
            }
        }
    }

    return GL_FALSE;
}

/*
** Process the incoming span by calling all of the appropriate span procs.
**
** This routine sets gc->polygon.shader.cfb to &gc->frontBuffer and then
** to &gc->backBuffer.
*/
GLboolean FASTCALL __glProcessReplicateSpan(__GLcontext *gc)
{
    GLint n, m, i;
    __GLcolor colors[__GL_MAX_MAX_VIEWPORT], *fcp, *tcp;
    GLint w;

    w = gc->polygon.shader.length;
    n = gc->procs.span.n;
    m = gc->procs.span.m; 

    gc->polygon.shader.done = GL_FALSE;
    for (i = 0; i < n; i++) {
        if ((*gc->procs.span.spanFuncs[i])(gc)) {
            i++;
            goto earlyStipple;
        }
    }

    fcp = gc->polygon.shader.colors;
    tcp = colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    ASSERTOPENGL (m == n + 1, "m != n+1, wrong spanProc will be chosen");

    gc->polygon.shader.cfb = &gc->frontBuffer;
        (*gc->frontBuffer.storeSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.spanFuncs[i])(gc);
    // }

    fcp = colors;
    tcp = gc->polygon.shader.colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    gc->polygon.shader.cfb = &gc->backBuffer;
        (*gc->backBuffer.storeSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.spanFuncs[i])(gc);
    // }

    return GL_FALSE;

earlyStipple:
    if (gc->polygon.shader.done) return GL_FALSE;

    for (; i < n; i++) {
        if ((*gc->procs.span.stippledSpanFuncs[i])(gc)) {
            return GL_FALSE;
        }
    }

    fcp = gc->polygon.shader.colors;
    tcp = colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    gc->polygon.shader.cfb = &gc->frontBuffer;
        (*gc->frontBuffer.storeStippledSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.stippledSpanFuncs[i])(gc);
    // }

    fcp = colors;
    tcp = gc->polygon.shader.colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    gc->polygon.shader.cfb = &gc->backBuffer;
        (*gc->backBuffer.storeStippledSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.stippledSpanFuncs[i])(gc);
    // }

    return GL_FALSE;
}

/*
** Perform scissoring on the incoming span, advancing parameter
** values only if necessary.
**
** Returns GL_TRUE if span was entirely (or sometimes when partially) clipped, 
** GL_FALSE otherwise.
*/
GLboolean FASTCALL __glClipSpan(__GLcontext *gc)
{
    GLint clipX0, clipX1, delta;
    GLint x, xr;
    GLint w, w2;
    GLboolean stippled;

    w = gc->polygon.shader.length;

    x = gc->polygon.shader.frag.x;
    stippled = GL_FALSE;
    clipX0 = gc->transform.clipX0;
    clipX1 = gc->transform.clipX1;
    xr = x + w;
    if ((x < clipX0) || (xr > clipX1)) {
        /*
        ** Span needs to be scissored in some fashion
        */
        if ((xr <= clipX0) || (x >= clipX1)) {
            /* Scissor out the entire span */
            gc->polygon.shader.done = GL_TRUE;
            return GL_TRUE;
        }
        if (xr > clipX1) {
            /*
            ** Span is clipped by the right edge of the scissor.  This is 
            ** easy, we will simply reduce the width of this span!
            */
            w = clipX1 - x;
        }
        if (x < clipX0) {
            __GLstippleWord bit, outMask, *osp;
            GLint count;

            /*
            ** Span is clipped by the left edge of the scissor.  This is hard.
            ** We have two choices.
            **
            ** 1) We can stipple the first half of the span.
            ** 2) We can bump all of the iterator values.
            **
            ** The problem with approach number 2 is that the routine 
            ** which originally asks to have a span processed has assumed 
            ** that the iterator values will not be munged.  So, if we 
            ** wanted to implement 2 (which would make this case faster),
            ** we would need to change that assumption, and make the higher
            ** routine shadow all of the iterator values, which would slow
            ** down all paths.  This is probably not a good trade to speed
            ** this path up, since this path will only occur when the scissor
            ** region (or window) is smaller than the viewport, and this span
            ** happens to hit the left edge of the scissor region (or window).
            **
            ** Therefore, we choose number 1.
            */
            delta = clipX0 - x;

            osp = gc->polygon.shader.stipplePat;
            w2 = w;
            while (w2) {
                count = w2;
                if (count > __GL_STIPPLE_BITS) {
                    count = __GL_STIPPLE_BITS;
                }
                w2 -= count;

                outMask = (__GLstippleWord) ~0;
                bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
                while (--count >= 0) {
                    if (delta > 0) {
                        delta--;
                        outMask &= ~bit;
                    }
#ifdef __GL_STIPPLE_MSB
                    bit >>= 1;
#else
                    bit <<= 1;
#endif
                }

                *osp++ = outMask;
            }

            stippled = GL_TRUE;
        }
    }
    ASSERTOPENGL(w <= __GL_MAX_MAX_VIEWPORT,
                 "Too many pixels generated by clip\n");

    gc->polygon.shader.length = w;

    return stippled;
}

/*
** Generate the polygon stipple for a span.
*/
GLboolean FASTCALL __glStippleSpan(__GLcontext *gc)
{
    __GLstippleWord stipple;
    __GLstippleWord *sp;
    GLint count;
    GLint shift;
    GLint w;

    w = gc->polygon.shader.length;

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height - 
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        gc->polygon.shader.done = GL_TRUE;
        return GL_TRUE;
    }

    /* Replicate stipple word */
    count = w;
    sp = gc->polygon.shader.stipplePat;
    while (count > 0) {
        *sp++ = stipple;
        count -= __GL_STIPPLE_BITS;
    }

    return GL_TRUE;
}

/*
** Generate the polygon stipple for a stippled span.
*/
GLboolean FASTCALL __glStippleStippledSpan(__GLcontext *gc)
{
    __GLstippleWord stipple;
    __GLstippleWord *sp;
    GLint count;
    GLint shift;
    GLint w;

    w = gc->polygon.shader.length;

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height - 
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        gc->polygon.shader.done = GL_TRUE;
        return GL_TRUE;
    }

    /* Replicate stipple word */
    count = w;
    sp = gc->polygon.shader.stipplePat;
    while (count > 0) {
        *sp++ &= stipple;
        count -= __GL_STIPPLE_BITS;
    }

    return GL_FALSE;
}

/************************************************************************/

/*
** Alpha test span uses a lookup table to do the alpha test function.
** Output a stipple with 1's where the test passed, and 0's where the
** test failed.
*/
GLboolean FASTCALL __glAlphaTestSpan(__GLcontext *gc)
{
    GLubyte *atft;
    GLint failed, count, ia;
    __GLstippleWord bit, outMask, *osp;
    __GLcolor *cp;
    GLint maxAlpha;
    GLint w;

    w = gc->polygon.shader.length;

    atft = &gc->alphaTestFuncTable[0];
    cp = gc->polygon.shader.colors;
    maxAlpha = gc->constants.alphaTestSize - 1;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            ia = (GLint)(gc->constants.alphaTableConv * cp->a);
            if (ia < 0) ia = 0;
            if (ia > maxAlpha) ia = maxAlpha;
            if (!atft[ia]) {
                /* Test failed */
                outMask &= ~bit;
                failed++;
            }
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of alpha test span that checks the stipple at each
** pixel and avoids the test where the stipple disallows it.
*/
GLboolean FASTCALL __glAlphaTestStippledSpan(__GLcontext *gc)
{
    GLubyte *atft;
    GLint count, ia, failed;
    __GLstippleWord bit, inMask, outMask, *isp;
    __GLcolor *cp;
    GLint maxAlpha;
    GLint w;

    w = gc->polygon.shader.length;
    isp = gc->polygon.shader.stipplePat;

    atft = &gc->alphaTestFuncTable[0];
    cp = gc->polygon.shader.colors;
    maxAlpha = gc->constants.alphaTestSize - 1;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *isp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                ia = (GLint)(gc->constants.alphaTableConv * cp->a);
                if (ia < 0) ia = 0;
                if (ia > maxAlpha) ia = maxAlpha;
                if (!atft[ia]) {
                    /* Test failed */
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *isp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next stippled span proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/************************************************************************/

/*
** Perform stencil testing.  Apply test fail operation as we go.
** Generate a stipple with 1's where the test passed and 0's where the
** test failed.
*/
GLboolean FASTCALL __glStencilTestSpan(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint count, failed;
    __GLstippleWord bit, outMask, *osp;
    GLint w;

    w = gc->polygon.shader.length;

    sfb = gc->polygon.shader.sbuf;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            cell = sfb[0];
            /* test func table already anded cell values with mask */
            if (!tft[cell]) {
                /* Test failed */
                outMask &= ~bit;
                sfb[0] = fail[cell];
                failed++;
            }
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of stencil test.
*/
GLboolean FASTCALL __glStencilTestStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint failed, count;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLuint smask;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    sfb = gc->polygon.shader.sbuf;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    smask = gc->state.stencil.mask;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                cell = sfb[0];
                if (!tft[cell & smask]) {
                    /* Test failed */
                    outMask &= ~bit;
                    sfb[0] = fail[cell];
                    failed++;
                }
            } else failed++;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/************************************************************************/

/*
** Depth test a span, when stenciling is disabled.
*/
GLboolean FASTCALL __glDepthTestSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    zfb = gc->polygon.shader.zbuf;
    testFunc = gc->procs.DTPixel;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if( (*testFunc)(z, zfb) == GL_FALSE ) {
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            (GLubyte *) zfb += stride;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of depth test span, when stenciling is disabled.
*/
GLboolean FASTCALL __glDepthTestStippledSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    sp = gc->polygon.shader.stipplePat;
    w = gc->polygon.shader.length;

    zfb = gc->polygon.shader.zbuf;
    testFunc = gc->procs.DTPixel;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if( (*testFunc)(z, zfb) == GL_FALSE ) {
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            (GLubyte *) zfb += stride;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/*
** Depth test a span when stenciling is enabled.
*/
GLboolean FASTCALL __glDepthTestStencilSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    zfb = gc->polygon.shader.zbuf;
    sfb = gc->polygon.shader.sbuf;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    testFunc = gc->procs.DTPixel;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if( (*testFunc)(z, zfb) ) {
                sfb[0] = zPassOp[sfb[0]];
            } else {
                sfb[0] = zFailOp[sfb[0]];
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            (GLubyte *) zfb += stride;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepthTestStencilStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    zfb = gc->polygon.shader.zbuf;
    sfb = gc->polygon.shader.sbuf;
    testFunc = gc->procs.DTPixel;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if( (*testFunc)(z, zfb) ) {
                    sfb[0] = zPassOp[sfb[0]];
                } else {
                    sfb[0] = zFailOp[sfb[0]];
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            (GLubyte *) zfb += stride;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }

    return GL_TRUE;
}

/*
** Apply stencil depth pass op when depth testing is off.
*/
GLboolean FASTCALL __glDepthPassSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;

    sfb = gc->polygon.shader.sbuf;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    count = w;
    while (--count >= 0) {
        sfb[0] = zPassOp[sfb[0]];
        sfb++;
    }

    return GL_FALSE;
}

/*
** Apply stencil depth pass op when depth testing is off.
*/
GLboolean FASTCALL __glDepthPassStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint count;
    __GLstippleWord bit, inMask, *sp;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    sfb = gc->polygon.shader.sbuf;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                sfb[0] = zPassOp[sfb[0]];
            }
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    /* Call next proc */
    return GL_FALSE;
}

/************************************************************************/

GLboolean FASTCALL __glShadeCISpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r, drdx;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    drdx = gc->polygon.shader.drdx;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        r += drdx;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glShadeRGBASpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r, g, b, a;
    __GLfloat drdx, dgdx, dbdx, dadx;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    g = gc->polygon.shader.frag.color.g;
    b = gc->polygon.shader.frag.color.b;
    a = gc->polygon.shader.frag.color.a;
    drdx = gc->polygon.shader.drdx;
    dgdx = gc->polygon.shader.dgdx;
    dbdx = gc->polygon.shader.dbdx;
    dadx = gc->polygon.shader.dadx;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        cp->g = g;
        cp->b = b;
        cp->a = a;
        r += drdx;
        g += dgdx;
        b += dbdx;
        a += dadx;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glFlatCISpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glFlatRGBASpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r, g, b, a;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    g = gc->polygon.shader.frag.color.g;
    b = gc->polygon.shader.frag.color.b;
    a = gc->polygon.shader.frag.color.a;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        cp->g = g;
        cp->b = b;
        cp->a = a;
        cp++;
    }

    return GL_FALSE;
}

/************************************************************************/

// Special case where qw = 0 for the span
GLboolean FASTCALL __glTextureSpanZeroQW(__GLcontext *gc)
{
    __GLcolor *cp;
    GLint w;

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;

    while (--w >= 0) {
        // No need to compute rho here - it is undefined for qw = 0
        (*gc->procs.texture)(gc, cp, __glZero, __glZero, __glZero);
        cp++;
    }
    return GL_FALSE;
}

GLboolean FASTCALL __glTextureSpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat s, t, qw;
    GLint w;

    qw = gc->polygon.shader.frag.qw;

    if( qw == (__GLfloat) 0.0 ) {
        return __glTextureSpanZeroQW( gc );
    }

    w = gc->polygon.shader.length;
    s = gc->polygon.shader.frag.s;
    t = gc->polygon.shader.frag.t;
    cp = gc->polygon.shader.colors;

    while (--w >= 0) {
        __GLfloat sw, tw, rho, qwinv;

        qwinv = __glOne / qw;
        sw = s * qwinv;
        tw = t * qwinv;

        rho = (*gc->procs.calcPolygonRho)(gc, &gc->polygon.shader,
                                            s, t, qw);
        (*gc->procs.texture)(gc, cp, sw, tw, rho);
        s += gc->polygon.shader.dsdx;
        t += gc->polygon.shader.dtdx;
        qw += gc->polygon.shader.dqwdx;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glTextureStippledSpan(__GLcontext *gc)
{
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    __GLcolor *cp;
    __GLfloat s, t, qw;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    s = gc->polygon.shader.frag.s;
    t = gc->polygon.shader.frag.t;
    qw = gc->polygon.shader.frag.qw;
    cp = gc->polygon.shader.colors;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                __GLfloat sw, tw, rho, qwinv;

                if( qw == (__GLfloat) 0.0 ) {
                    sw = tw = (__GLfloat) 0.0;
                }
                else {
                    qwinv = __glOne / qw;
                    sw = s * qwinv;
                    tw = t * qwinv;
                }
                rho = (*gc->procs.calcPolygonRho)(gc, &gc->polygon.shader,
                                                    s, t, qw);
                (*gc->procs.texture)(gc, cp, sw, tw, rho);
            }
            s += gc->polygon.shader.dsdx;
            t += gc->polygon.shader.dtdx;
            qw += gc->polygon.shader.dqwdx;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    return GL_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_slows.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

GLboolean __glReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
		       __GLcolor *results, GLint w)
{
    while (--w >= 0) {
	(*cfb->readColor)(cfb, x, y, results);
	x++;
	results++;
    }

    return GL_FALSE;
}

/*
** NOTE: this is a hack.  Late in the game we determined that returning
** a span of data should not also blend.  So this code stacks the old
** blend enable value, disables blending, updates the pick procs, and
** then does the store.  Obviously this is a real slow thing to
** do.
*/
void __glReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
		    const __GLaccumCell *ac, __GLfloat scale, GLint w)
{
    __GLfragment frag;
    GLuint oldEnables;
    __GLcontext *gc = cfb->buf.gc;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLaccumBuffer *afb = &gc->accumBuffer;

    /* Temporarily disable blending if its enabled */
    oldEnables = gc->state.enables.general;
    if (oldEnables & __GL_BLEND_ENABLE) {
	gc->state.enables.general &= ~__GL_BLEND_ENABLE;
	__GL_DELAY_VALIDATE(gc);
	(*gc->procs.validate)(gc);
    }

    rscale = scale * afb->oneOverRedScale;
    gscale = scale * afb->oneOverGreenScale;
    bscale = scale * afb->oneOverBlueScale;
    ascale = scale * afb->oneOverAlphaScale;

    frag.x = x;
    frag.y = y;
    while (--w >= 0) {
	frag.color.r = ac->r * rscale;
	frag.color.g = ac->g * gscale;
	frag.color.b = ac->b * bscale;
	frag.color.a = ac->a * ascale;
	__glClampRGBColor(cfb->buf.gc, &frag.color, &frag.color);
	(*cfb->store)(cfb, &frag);
	frag.x++;
	ac++;
    }

    /* Restore blending enable */
    if (oldEnables & __GL_BLEND_ENABLE) {
	gc->state.enables.general = oldEnables;
	__GL_DELAY_VALIDATE(gc);
	(*gc->procs.validate)(gc);
    }
}

GLboolean FASTCALL __glFetchSpan(__GLcontext *gc)
{
    __GLcolor *fcp;
    __GLcolorBuffer *cfb;
    GLint x, y;
    GLint w;

    w = gc->polygon.shader.length;

    fcp = gc->polygon.shader.fbcolors;
    cfb = gc->polygon.shader.cfb;
    x = gc->polygon.shader.frag.x;
    y = gc->polygon.shader.frag.y;
    (*cfb->readSpan)(cfb, x, y, fcp, w);

    return GL_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_tcltb.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#ifdef GL_EXT_paletted_texture
GLboolean __glCheckColorTableArgs(__GLcontext *gc, GLenum format, GLenum type)
{
    switch (format)
    {
      case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
    default:
    bad_enum:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    return GL_TRUE;
}

void APIPRIVATE __glim_ColorTableEXT(GLenum target,
                                     GLenum internalFormat, GLsizei width,
                                     GLenum format, GLenum type,
                                     const GLvoid *data, GLboolean _IsDlist)
{
    __GLtexture *tex;
    GLint level;
    __GLpixelSpanInfo spanInfo;
    GLenum baseFormat;
    RGBQUAD *newData;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    switch(internalFormat)
    {
    case GL_RGB:		case 3:
    case GL_R3_G3_B2:		case GL_RGB4:
    case GL_RGB5:		case GL_RGB8:
    case GL_RGB10:	        case GL_RGB12:
    case GL_RGB16:
	baseFormat = GL_RGB;
        break;
    case GL_RGBA:		case 4:
    case GL_RGBA2:	        case GL_RGBA4:
    case GL_RGBA8:              case GL_RGB5_A1:
    case GL_RGBA12:             case GL_RGBA16:
    case GL_RGB10_A2:
	baseFormat = GL_RGBA;
        break;
    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // width must be a positive power of two greater than zero
    if (width <= 0 || (width & (width-1)) != 0)
    {
        __glSetError(GL_INVALID_VALUE);
        return;
    }

    if (!__glCheckColorTableArgs(gc, format, type))
    {
        return;
    }

    tex = __glLookUpTexture(gc, target);
        
    if (target == GL_PROXY_TEXTURE_1D ||
        target == GL_PROXY_TEXTURE_2D)
    {
        // Consider - How do MCD's indicate their palette support?
        
        // We're only in this case if it's a legal proxy target value
        // so there's no need to do a real check
        ASSERTOPENGL(tex != NULL, "Invalid proxy target");
        
        tex->paletteRequestedFormat = internalFormat;
        tex->paletteTotalSize = width;
        tex->paletteSize = tex->paletteTotalSize;
        
        // Proxies have no data so there's no need to do any more
        return;
    }

    if (data == NULL)
    {
        return;
    }
    
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Allocate palette storage
    newData = GCREALLOC(gc, tex->paletteTotalData, sizeof(RGBQUAD)*width);
    if (newData == NULL)
    {
        return;
    }

    tex->paletteBaseFormat = baseFormat;
    tex->paletteRequestedFormat = internalFormat;
    tex->paletteTotalSize = width;
    __glSetPaletteSubdivision(tex, tex->paletteTotalSize);
    tex->paletteTotalData = newData;
    tex->paletteData = tex->paletteTotalData;

    // This routine can be called on any kind of texture, not necessarily
    // color-indexed ones.  If it is a color-index texture then we
    // need to set the appropriate baseFormat and extract procs
    // according to the palette data
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        for (level = 0; level < gc->constants.maxMipMapLevel; level++)
        {
            tex->level[level].baseFormat = tex->paletteBaseFormat;
            // Pick proper extraction proc
            if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT)
            {
                __glSetPaletteLevelExtract8(tex, &tex->level[level],
                                            tex->level[level].border);
            }
            else
            {
                ASSERTOPENGL(tex->level[0].internalFormat ==
                             GL_COLOR_INDEX16_EXT,
                             "Unexpected internalFormat\n");
            
                __glSetPaletteLevelExtract16(tex, &tex->level[level],
                                             tex->level[level].border);
            }
        }
        
        // We need to repick the texture procs because the baseFormat
        // field has changed
        __GL_DELAY_VALIDATE(gc);
    }

    // Copy user palette data into BGRA form
    spanInfo.dstImage = tex->paletteTotalData;
    __glInitTextureUnpack(gc, &spanInfo, width, 1, format, type, data, 
                          GL_BGRA_EXT, _IsDlist);
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);

    // Don't update the optimized palette unless it would actually
    // get used
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        __GLtextureObject *pto;
        
        pto = __glLookUpTextureObject(gc, target);
        __glGenUpdateTexturePalette(gc, tex, pto->loadKey,
                                    0, tex->paletteTotalSize);
    }
}

void APIPRIVATE __glim_ColorSubTableEXT(GLenum target, GLsizei start,
                                        GLsizei count, GLenum format,
                                        GLenum type, const GLvoid *data,
                                        GLboolean _IsDlist)
{
    __GLtexture *tex;
    __GLpixelSpanInfo spanInfo;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    if (!__glCheckColorTableArgs(gc, format, type))
    {
        return;
    }

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL ||
        target == GL_PROXY_TEXTURE_1D ||
        target == GL_PROXY_TEXTURE_2D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    if (data == NULL)
    {
        return;
    }
    
    // Validate start and count
    if (start > tex->paletteTotalSize ||
        start+count > tex->paletteTotalSize)
    {
        __glSetError(GL_INVALID_VALUE);
        return;
    }

    // Copy user palette data into BGRA form
    spanInfo.dstImage = tex->paletteTotalData;
    __glInitTextureUnpack(gc, &spanInfo, count, 1, format, type, data, 
                          GL_BGRA_EXT, _IsDlist);
    spanInfo.dstSkipPixels += start;
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);

    // Don't update the optimized palette unless it would actually
    // get used
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        __GLtextureObject *pto;
        
        pto = __glLookUpTextureObject(gc, target);
        __glGenUpdateTexturePalette(gc, tex, pto->loadKey, start, count);
    }
}

void APIPRIVATE __glim_GetColorTableEXT(GLenum target, GLenum format,
                                        GLenum type, GLvoid *data)
{
    __GLtexture *tex;
    GLint level;
    __GLpixelSpanInfo spanInfo;
    GLenum baseFormat;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();
    
    if (!__glCheckColorTableArgs(gc, format, type))
    {
        return;
    }
    
    tex = __glLookUpTexture(gc, target);
    if (tex == NULL ||
        target == GL_PROXY_TEXTURE_1D ||
        target == GL_PROXY_TEXTURE_2D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    
    ASSERTOPENGL(tex->paletteTotalData != NULL,
                 "GetColorTable with no palette data\n");

    // Copy BGRA data into user buffer
    spanInfo.srcImage = tex->paletteTotalData;
    spanInfo.srcFormat = GL_BGRA_EXT;
    spanInfo.srcType = GL_UNSIGNED_BYTE;
    spanInfo.srcAlignment = 4;
    __glInitImagePack(gc, &spanInfo, tex->paletteTotalSize, 1,
                      format, type, data);
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
}

void APIPRIVATE __glim_GetColorTableParameterivEXT(GLenum target,
                                                   GLenum pname,
                                                   GLint *params)
{
    __GLtexture *tex;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_FORMAT_EXT:
        *params = tex->paletteRequestedFormat;
        break;
    case GL_COLOR_TABLE_WIDTH_EXT:
        *params = tex->paletteTotalSize;
        break;
    case GL_COLOR_TABLE_RED_SIZE_EXT:
    case GL_COLOR_TABLE_GREEN_SIZE_EXT:
    case GL_COLOR_TABLE_BLUE_SIZE_EXT:
    case GL_COLOR_TABLE_ALPHA_SIZE_EXT:
        *params = 8;
        break;
#ifdef GL_EXT_flat_paletted_lighting
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        *params = tex->paletteSize;
        break;
#endif

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_GetColorTableParameterfvEXT(GLenum target,
                                                   GLenum pname,
                                                   GLfloat *params)
{
    __GLtexture *tex;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_FORMAT_EXT:
        *params = (GLfloat)tex->paletteRequestedFormat;
        break;
    case GL_COLOR_TABLE_WIDTH_EXT:
        *params = (GLfloat)tex->paletteTotalSize;
        break;
    case GL_COLOR_TABLE_RED_SIZE_EXT:
    case GL_COLOR_TABLE_GREEN_SIZE_EXT:
    case GL_COLOR_TABLE_BLUE_SIZE_EXT:
    case GL_COLOR_TABLE_ALPHA_SIZE_EXT:
        *params = (GLfloat)8;
        break;
#ifdef GL_EXT_flat_paletted_lighting
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        *params = (GLfloat)tex->paletteSize;
        break;
#endif

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}
#endif // GL_EXT_paletted_texture

#ifdef GL_EXT_flat_paletted_lighting
void APIPRIVATE __glim_ColorTableParameterivEXT(GLenum target,
                                                GLenum pname,
                                                const GLint *params)
{
    __GLtexture *tex;
    GLint ival;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        ival = *params;
        
        // Value must be an integer power of two between one and the total
        // palette size
        if ((ival & (ival-1)) != 0 ||
            ival < 1 ||
            ival > tex->paletteTotalSize)
        {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        
        __glSetPaletteSubdivision(tex, ival);
        break;

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_ColorTableParameterfvEXT(GLenum target,
                                                GLenum pname,
                                                const GLfloat *params)
{
    __GLtexture *tex;
    GLfloat fval;
    GLint ival;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        fval = *params;
        ival = (int)fval;
        
        // Value must be an integer power of two between one and the total
        // palette size
        if (fval != (GLfloat)ival ||
            (ival & (ival-1)) != 0 ||
            ival < 1 ||
            ival > tex->paletteTotalSize)
        {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        
        __glSetPaletteSubdivision(tex, ival);
        break;

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}
#endif // GL_EXT_flat_paletted_lighting
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_selec.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.12 $
** $Date: 1993/09/23 16:30:58 $
*/
#include "precomp.h"
#pragma hdrstop

void APIPRIVATE __glim_SelectBuffer(GLsizei bufferLength, GLuint buffer[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (bufferLength < 0) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    if (gc->renderMode == GL_SELECT) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }
    gc->select.overFlowed = GL_FALSE;
    gc->select.resultBase = buffer;
    gc->select.resultLength = bufferLength;
    gc->select.result = buffer;
}

void APIPRIVATE __glim_InitNames(void)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	gc->select.sp = gc->select.stack;
	gc->select.hit = GL_FALSE;
    }
}

void APIPRIVATE __glim_LoadName(GLuint name)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	if (gc->select.sp == gc->select.stack) {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
	gc->select.sp[ -1 ] = name;
	gc->select.hit = GL_FALSE;
    }
}

void APIPRIVATE __glim_PopName(void)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	if (gc->select.sp == gc->select.stack) {
	    __glSetError(GL_STACK_UNDERFLOW);
	    return;
	}
	gc->select.sp = gc->select.sp - 1;
	gc->select.hit = GL_FALSE;
    }
}

void APIPRIVATE __glim_PushName(GLuint name)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	// make sure that we have a stack
	ASSERTOPENGL(gc->select.stack != 0 && gc->select.sp != 0,
                     "No selection stack\n");
	if (gc->select.sp >= &gc->select.stack[gc->constants.maxNameStackDepth]) {
	    __glSetError(GL_STACK_OVERFLOW);
	    return;
	}
	gc->select.sp[0] = name;
	gc->select.sp = gc->select.sp + 1;
	gc->select.hit = GL_FALSE;
    }
}

/************************************************************************/

#define __GL_CONVERT_Z_TO_UINT(z)  ((GLuint) z)

/*
** Copy current name stack into the users result buffer.
*/
void __glSelectHit(__GLcontext *gc, __GLfloat z)
{
    GLuint *src;
    GLuint *dest = gc->select.result;
    GLuint *end = gc->select.resultBase + gc->select.resultLength;
    GLuint iz;

    if (gc->select.overFlowed) {
	return;
    }
    
    /* Scale z to [0, 2^32 -1] range.
    ** If buffer is 32 bit, no coversion necessary.  Otherwise we
    ** have to unscale to [0,1] range and rescale to final range.
    ** 4294965000 is the number used throughout lighting code to
    ** come short of 2^32-1 to avoid floating point errors.
    */
    if (gc->depthBuffer.buf.depth == 32) {
        iz = __GL_CONVERT_Z_TO_UINT(z);
    } else {
        iz = z * 4294965000 / gc->depthBuffer.scale;
    }

    if (!gc->select.hit) {
	gc->select.hit = GL_TRUE;

	/* Put number of elements in name stack out first */
	if (dest == end) {
	  overflow:
	    gc->select.overFlowed = GL_TRUE;
	    gc->select.result = end;
	    return;
	}
	*dest++ = (GLint)((ULONG_PTR)(gc->select.sp - gc->select.stack));
	gc->select.hits++;

	/* Put out smallest z */
	if (dest == end) goto overflow;
	gc->select.z = dest;
	*dest++ = iz;

	/* Put out largest z */
	if (dest == end) goto overflow;
	*dest++ = iz;

	/* Copy name stack into output buffer */
	for (src = gc->select.stack; src < gc->select.sp; src++) {
	    if (dest == end) {
		goto overflow;
	    }
	    *dest++ = *src;
	}
	gc->select.result = dest;
    } else {
	/* Update range of Z values */
	ASSERTOPENGL(gc->select.z != 0, "Select Z is zero\n");
	if (iz < gc->select.z[0]) {
	    gc->select.z[0] = iz;
	}
	if (iz > gc->select.z[1]) {
	    gc->select.z[1] = iz;
	}
    }
}

#ifdef NT
void FASTCALL __glSelectTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			__GLvertex *c)
{
    __GLfloat dxAC, dxBC, dyAC, dyBC, area;
    GLint ccw, face;

// From __glRenderTriangle.

    /* Compute signed area of the triangle */
    dxAC = a->window.x - c->window.x;
    dxBC = b->window.x - c->window.x;
    dyAC = a->window.y - c->window.y;
    dyBC = b->window.y - c->window.y;
    area = dxAC * dyBC - dxBC * dyAC;
    ccw = area >= __glZero;

    face = gc->polygon.face[ccw];
    if (face == gc->polygon.cullFace)
	/* Culled */
	return;

    __glSelectHit(gc, a->window.z);
    __glSelectHit(gc, b->window.z);
    __glSelectHit(gc, c->window.z);
}
#else
// SGIBUG - This code fails to take into account y inversion when
// computing face orientation!
void __glSelectTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			__GLvertex *c)
{
    __GLfloat x, y, z, wInv;
    __GLfloat vpXScale, vpYScale, vpZScale;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    __GLviewport *vp;

    /* Compute window coordinates first, if not already done */
    vp = &gc->state.viewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;

    if (gc->state.enables.general & __GL_CULL_FACE_ENABLE) {
	__GLfloat dxAC, dxBC, dyAC, dyBC, area;
	GLboolean ccw, frontFacing;

	/* Compute signed area of the triangle */
	dxAC = a->window.x - c->window.x;
	dxBC = b->window.x - c->window.x;
	dyAC = a->window.y - c->window.y;
	dyBC = b->window.y - c->window.y;
	area = dxAC * dyBC - dxBC * dyAC;
	ccw = area >= __glZero;

	if (gc->state.polygon.frontFaceDirection == GL_CCW) {
	    frontFacing = ccw;
	} else {
	    frontFacing = !ccw;
	}
	if ((gc->state.polygon.cull == GL_FRONT_AND_BACK) ||
	    ((gc->state.polygon.cull == GL_FRONT) && frontFacing) ||
	    ((gc->state.polygon.cull == GL_BACK) && !frontFacing)) {
	    /* Culled */
	    return;
	}
    }
    __glSelectHit(gc, a->window.z);
    __glSelectHit(gc, b->window.z);
    __glSelectHit(gc, c->window.z);
}
#endif

void FASTCALL __glSelectLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			     GLuint flags)
{
    __glSelectHit(gc, a->window.z);
    __glSelectHit(gc, b->window.z);
}

void FASTCALL __glSelectPoint(__GLcontext *gc, __GLvertex *v)
{
    __glSelectHit(gc, v->window.z);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_specc.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1993/07/27 17:42:12 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** A simple few routines which saves a cache for specular and spotlight
** computation (rather than recomputing the tables every time the user
** changes the specular or spotlight exponents).
*/

/*
** Any more than TOO_MANY_LUT_ENTRIES entries, and we free any that 
** become unreferenced.
*/
#define TOO_MANY_LUT_ENTRIES	32

typedef struct {
    __GLfloat exp;
    __GLspecLUTEntry *table;
} __GLspecLUTEntryPtr;

typedef struct __GLspecLUTCache_Rec {
    GLint nentries;
    GLint allocatedSize;
    __GLspecLUTEntryPtr entries[1];
} __GLspecLUTCache;

void FASTCALL __glInitLUTCache(__GLcontext *gc)
{
    __GLspecLUTCache *lutCache;

    lutCache = gc->light.lutCache = (__GLspecLUTCache *) 
	    GCALLOC(gc, sizeof(__GLspecLUTCache));
#ifdef NT
    if (!lutCache)
        return;
#endif // NT
    lutCache->nentries = 0;
    lutCache->allocatedSize = 1;
}

void FASTCALL __glFreeLUTCache(__GLcontext *gc)
{
    int i;
    GLint nentries;
    __GLspecLUTEntryPtr *entry;
    __GLspecLUTCache *lutCache;

    lutCache = gc->light.lutCache;
#ifdef NT
    if (!lutCache)
        return;
#endif // NT
    nentries = lutCache->nentries;
    for (i = 0; i < nentries; i++) {
	entry = &(lutCache->entries[i]);
	GCFREE(gc, entry->table);
    }
    GCFREE(gc, lutCache);
}

static __GLspecLUTEntry *findEntry(__GLspecLUTCache *lutCache, __GLfloat exp, 
				   GLint *location)
{
    GLint nentries;
    GLint bottom, half, top;
    __GLspecLUTEntry *table;
    __GLspecLUTEntryPtr *entry;

#ifdef NT
    ASSERTOPENGL(lutCache != NULL, "No LUT cache\n");
#endif // NT
    nentries = lutCache->nentries;
    /* First attempt to find this entry in our cache */
    bottom = 0;
    top = nentries;
    while (top > bottom) {
	/* Entry might exist in the range [bottom, top-1] */
	half = (bottom+top)/2;
	entry = &(lutCache->entries[half]);
	if (entry->exp == exp) {
	    /* Found the table already cached! */
	    table = entry->table;
	    *location = half;
	    return table;
	}
	if (exp < entry->exp) {
	    /* exp might exist somewhere earlier in the table */
	    top = half;
	} else /* exp > entry->exp */ {
	    /* exp might exist somewhere later in the table */
	    bottom = half+1;
	}
    }
    *location = bottom;
    return NULL;
}

__GLspecLUTEntry *__glCreateSpecLUT(__GLcontext *gc, __GLfloat exp)
{
    GLint nentries, allocatedSize;
    GLint location;
    __GLspecLUTCache *lutCache;
    __GLspecLUTEntryPtr *entry;
    __GLspecLUTEntry *table;
    __GLfloat *tableEntry;
    GLdouble threshold, scale, x, dx;
    GLint i;

    /* This code uses double-precision math, so make sure that the FPU */
    /* is set properly: */

    FPU_SAVE_MODE();
    FPU_CHOP_OFF_PREC_HI();

    lutCache = gc->light.lutCache;
#ifdef NT
    if (!lutCache)
        return (__GLspecLUTEntry *)NULL;
#endif // NT

    if (table = findEntry(lutCache, exp, &location)) {
	table->refcount++;
	return table;
    }
    /* 
    ** We failed to find our entry in our cache anywhere, and have to compute 
    ** it.
    */
    lutCache->nentries = nentries = 1 + lutCache->nentries;
    allocatedSize = lutCache->allocatedSize;

    if (nentries > allocatedSize) {
        /* Allocate space for another six entries (arbitrarily) */
        lutCache->allocatedSize = allocatedSize = allocatedSize + 6;
        if (!(lutCache = (__GLspecLUTCache *)
                GCREALLOC(gc, lutCache, sizeof(__GLspecLUTCache) +
                          allocatedSize * sizeof(__GLspecLUTEntryPtr))))
        {
            gc->light.lutCache->allocatedSize -= 6;
            gc->light.lutCache->nentries -= 1;
            return (__GLspecLUTEntry *)NULL;
        }
        gc->light.lutCache = lutCache;
    }

    /*
    ** We have enough space now.  So we stick the new entry in the array
    ** at entry 'location'.  The rest of the entries need to be moved up
    ** (move [location, nentries-2] up to [location+1, nentries-1]).
    */
    if (nentries-location-1) {
#ifdef NT
	__GL_MEMMOVE(&(lutCache->entries[location+1]), 
		&(lutCache->entries[location]),
		(nentries-location-1) * sizeof(__GLspecLUTEntryPtr));
#else
	__GL_MEMCOPY(&(lutCache->entries[location+1]), 
		&(lutCache->entries[location]),
		(nentries-location-1) * sizeof(__GLspecLUTEntryPtr));
#endif
    }
    entry = &(lutCache->entries[location]);
    entry->exp = exp;
    table = entry->table = (__GLspecLUTEntry *) 
	    GCALLOC(gc, sizeof(__GLspecLUTEntry));
#ifdef NT
    if (!table)
        return (__GLspecLUTEntry *)NULL;
#endif // NT

    /* Compute threshold */
    if (exp == (__GLfloat) 0.0) {
	threshold = (GLdouble) 0.0;
    } else {
#ifdef NT
    // Changing this enabled conformance to pass for color index visuals
    // with 4096 colors, and did not seem to affect anything else.
    // What this does is sort of reduce the granularity at the beginning
    // of the table, because without it we were getting too big a jump
    // between 0 and the first entry in the table, causing l_sen.c to fail.
	threshold = (GLdouble) __GL_POWF((__GLfloat) 0.0005, (__GLfloat) 1.0 / exp);
#else
	threshold = __GL_POWF(0.002, 1.0 / exp);
#endif
    }

    scale = (GLdouble) (__GL_SPEC_LOOKUP_TABLE_SIZE - 1) / ((GLdouble) 1.0 - threshold);
    dx = (GLdouble) 1.0 / scale;
    x = threshold;
    tableEntry = table->table;
    for (i = __GL_SPEC_LOOKUP_TABLE_SIZE; --i >= 0; ) {
	*tableEntry++ = __GL_POWF(x, exp);
	x += dx;
    }
    table->threshold = threshold;
    table->scale = scale;
    table->refcount = 1;
    table->exp = exp;

    FPU_RESTORE_MODE();

    return table;
}

void FASTCALL __glFreeSpecLUT(__GLcontext *gc, __GLspecLUTEntry *lut)
{
    __GLspecLUTCache *lutCache;
    GLint location, nentries;
    __GLspecLUTEntry *table;

    if (lut == NULL) return;

    ASSERTOPENGL(lut->refcount != 0, "Invalid refcount\n");

    lut->refcount--;
    if (lut->refcount > 0) return;

    lutCache = gc->light.lutCache;
#ifdef NT
    ASSERTOPENGL(lutCache != NULL, "No LUT cache\n");
#endif // NT

    table = findEntry(lutCache, lut->exp, &location);

    ASSERTOPENGL(table == lut, "Wrong LUT found\n");

    if (table->refcount == 0 && lutCache->nentries >= TOO_MANY_LUT_ENTRIES) {
	/* 
	** Free entry 'location'.
	** This requires reducing lutCache->nentries by one, and copying 
	** entries [location+1, nentries] to [location, nentries-1].
	*/
	lutCache->nentries = nentries = lutCache->nentries - 1;
#ifdef NT
	__GL_MEMMOVE(&(lutCache->entries[location]),
		&(lutCache->entries[location+1]),
		(nentries-location) * sizeof(__GLspecLUTEntryPtr));
#else
	__GL_MEMCOPY(&(lutCache->entries[location]),
		&(lutCache->entries[location+1]),
		(nentries-location) * sizeof(__GLspecLUTEntryPtr));
#endif
	GCFREE(gc, table);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_stenc.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

GLint FASTCALL Fetch(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    return fb[0];
}

static void Store(__GLstencilBuffer *sfb, GLint x, GLint y,GLint v)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = (__GLstencilCell) ((v & sfb->buf.gc->state.stencil.writeMask)
		       | (fb[0] & ~sfb->buf.gc->state.stencil.writeMask));
}

static GLboolean FASTCALL TestFunc(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    return sfb->testFuncTable[fb[0] & sfb->buf.gc->state.stencil.mask];
}

static void FASTCALL FailOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = sfb->failOpTable[fb[0]];
}

static void FASTCALL PassDepthFailOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = sfb->depthFailOpTable[fb[0]];
}

static void FASTCALL DepthPassOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = sfb->depthPassOpTable[fb[0]];
}

static GLboolean FASTCALL NoOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    return GL_FALSE;
}

/************************************************************************/

static void FASTCALL Clear(__GLstencilBuffer *sfb)
{
    __GLcontext *gc = sfb->buf.gc;
    __GLstencilCell *fb;
    GLint x, y, x1, y1, skip, w, w8, w1;
    __GLstencilCell sten = (__GLstencilCell)gc->state.stencil.clear;

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if (((w = x1 - x) == 0) || (y1 - y == 0)) {
	return;
    }

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);

    skip = sfb->buf.outerWidth - w;
    w8 = w >> 3;
    w1 = w & 7;
    if (gc->state.stencil.writeMask == __GL_MAX_STENCIL_VALUE) {
	for (; y < y1; y++) {
	    w = w8;
	    while (--w >= 0) {
		fb[0] = sten; fb[1] = sten; fb[2] = sten; fb[3] = sten;
		fb[4] = sten; fb[5] = sten; fb[6] = sten; fb[7] = sten;
		fb += 8;
	    }
	    w = w1;
	    while (--w >= 0) {
		*fb++ = sten;
	    }
	    fb += skip;
	}
    } else {
	GLint mask;

	mask = gc->state.stencil.writeMask;
	sten = sten & mask;
	mask = ~mask;

	for (; y < y1; y++) {
	    w = w8;
	    while (--w >= 0) {
		fb[0] = (fb[0] & mask) | (sten); 
		fb[1] = (fb[1] & mask) | (sten); 
		fb[2] = (fb[2] & mask) | (sten); 
		fb[3] = (fb[3] & mask) | (sten); 
		fb[4] = (fb[4] & mask) | (sten); 
		fb[5] = (fb[5] & mask) | (sten); 
		fb[6] = (fb[6] & mask) | (sten); 
		fb[7] = (fb[7] & mask) | (sten); 
		fb += 8;
	    }
	    w = w1;
	    while (--w >= 0) {
		fb[0] = (fb[0] & mask) | (sten);
		fb++;
	    }
	    fb += skip;
	}
    }
}

/************************************************************************/

static void buildOpTable(__GLstencilCell *tp, GLenum op,
			 __GLstencilCell reference, __GLstencilCell writeMask)
{
    GLuint i;
    __GLstencilCell newValue;
    __GLstencilCell notWriteMask = ~writeMask;

    for (i = 0; i < __GL_STENCIL_RANGE; i++) {
	switch (op) {
	  case GL_KEEP:		newValue = (__GLstencilCell)i; break;
	  case GL_ZERO:		newValue = 0; break;
	  case GL_REPLACE:	newValue = reference; break;
	  case GL_INVERT:	newValue = ~i; break;
	  case GL_INCR:
	    /* Clamp so no overflow occurs */
	    if (i == __GL_MAX_STENCIL_VALUE) {
		newValue = (__GLstencilCell)i;
	    } else {
		newValue = i + 1;
	    }
	    break;
	  case GL_DECR:
	    /* Clamp so no underflow occurs */
	    if (i == 0) {
		newValue = 0;
	    } else {
		newValue = i - 1;
	    }
	    break;
	}
	*tp++ = (i & notWriteMask) | (newValue & writeMask);
    }
}

#ifdef NT
void FASTCALL __glValidateStencil(__GLcontext *gc, __GLstencilBuffer *sfb)
#else
void FASTCALL __glValidateStencil(__GLcontext *gc)
#endif // NT
{
    GLint i;
    __GLstencilCell reference, mask, writeMask;
    __GLstencilCell refVal; //actual reference value, part of GL state
    
    GLenum testFunc;
    GLboolean *tp;

    /*
    ** Validate the stencil tables even if stenciling is disabled.  This
    ** function is only called if the stencil func or op changes, and it
    ** won't get called later if stenciling is turned on, so we need to get
    ** it right now.
    */

    mask = (__GLstencilCell) gc->state.stencil.mask;
    refVal = ((__GLstencilCell) gc->state.stencil.reference);
    reference = (__GLstencilCell) (refVal & mask);
    testFunc = gc->state.stencil.testFunc;

    /*
    ** Build up test function table.  The current stencil buffer value
    ** will be the index to this table.
    */
    tp = &gc->stencilBuffer.testFuncTable[0];
    
    // If we don't have a stencil buffer then set everything to
    // do nothing
    if (!gc->modes.haveStencilBuffer)
    {
        sfb->testFunc = NoOp;
        sfb->failOp = NoOp;
        sfb->passDepthFailOp = NoOp;
        sfb->depthPassOp = NoOp;
        return;
    }
    else if (tp != NULL && sfb->testFunc == NoOp)
    {
        // If we've recovered from not having a stencil buffer then
        // turn the functions back on
        sfb->testFunc = TestFunc;
        sfb->failOp = FailOp;
        sfb->passDepthFailOp = PassDepthFailOp;
        sfb->depthPassOp = DepthPassOp;
    }

    if (!tp)
    {
        gc->stencilBuffer.testFuncTable = tp = (GLboolean *)
            GCALLOC(gc, (sizeof(GLboolean)+3*sizeof(__GLstencilCell))*
                    __GL_STENCIL_RANGE);
        if (!tp)
        {
            sfb->testFunc = NoOp;
            sfb->failOp = NoOp;
            sfb->passDepthFailOp = NoOp;
            sfb->depthPassOp = NoOp;
            gc->stencilBuffer.failOpTable =
            gc->stencilBuffer.depthFailOpTable =
            gc->stencilBuffer.depthPassOpTable = (__GLstencilCell*) NULL;
            return;
        }
        else
        {
            sfb->testFunc = TestFunc;
            sfb->failOp = FailOp;
            sfb->passDepthFailOp = PassDepthFailOp;
            sfb->depthPassOp = DepthPassOp;
        }
        gc->stencilBuffer.failOpTable = (__GLstencilCell*)
            (gc->stencilBuffer.testFuncTable + __GL_STENCIL_RANGE);
        gc->stencilBuffer.depthFailOpTable = (__GLstencilCell*)
            (gc->stencilBuffer.failOpTable + __GL_STENCIL_RANGE);
        gc->stencilBuffer.depthPassOpTable = (__GLstencilCell*)
            (gc->stencilBuffer.depthFailOpTable + __GL_STENCIL_RANGE);
    }
    for (i = 0; i < __GL_STENCIL_RANGE; i++) {
	switch (testFunc) {
	  case GL_NEVER:	*tp++ = GL_FALSE; break;
	  case GL_LESS:		*tp++ = reference < (i & mask); break;
	  case GL_EQUAL:	*tp++ = reference == (i & mask); break;
	  case GL_LEQUAL:	*tp++ = reference <= (i & mask); break;
	  case GL_GREATER:	*tp++ = reference > (i & mask); break;
	  case GL_NOTEQUAL:	*tp++ = reference != (i & mask); break;
	  case GL_GEQUAL:	*tp++ = reference >= (i & mask); break;
	  case GL_ALWAYS:	*tp++ = GL_TRUE; break;
	}
    }

    /*
    ** Build up fail op table.
    */
    writeMask = (__GLstencilCell) gc->state.stencil.writeMask;
    buildOpTable(&gc->stencilBuffer.failOpTable[0],
		 gc->state.stencil.fail, refVal, writeMask);
    buildOpTable(&gc->stencilBuffer.depthFailOpTable[0],
		 gc->state.stencil.depthFail, refVal, writeMask);
    buildOpTable(&gc->stencilBuffer.depthPassOpTable[0],
		 gc->state.stencil.depthPass, refVal, writeMask);
}

/************************************************************************/

static void FASTCALL Pick(__GLcontext *gc, __GLstencilBuffer *sfb)
{
#ifdef __GL_LINT
    sfb = sfb;
#endif
    if (gc->validateMask & (__GL_VALIDATE_STENCIL_FUNC |
			    __GL_VALIDATE_STENCIL_OP)) {
#ifdef NT
        __glValidateStencil(gc, sfb);
#else
	__glValidateStencil(gc);
#endif // NT
    }
}

void FASTCALL __glInitStencil8(__GLcontext *gc, __GLstencilBuffer *sfb)
{
    sfb->buf.elementSize = sizeof(__GLstencilCell);
    sfb->buf.gc = gc;
    sfb->pick = Pick;
    sfb->store = Store;
    sfb->fetch = Fetch;
#ifndef NT
// Initialized in __glValidateStencil.
    sfb->testFunc = TestFunc;
    sfb->failOp = FailOp;
    sfb->passDepthFailOp = PassDepthFailOp;
    sfb->depthPassOp = DepthPassOp;
#endif // !NT
    sfb->clear = Clear;
}

void FASTCALL __glFreeStencil8(__GLcontext *gc, __GLstencilBuffer *fb)
{
#ifdef __GL_LINT
    gc = gc;
    fb = fb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_store.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.13 $
** $Date: 1993/05/14 09:00:53 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** Store fragment proc.
** alpha test on, stencil test on, depth test on
*/
void FASTCALL __glDoStore_ASD(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }
    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	(*gc->stencilBuffer.passDepthFailOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);


    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test on, stencil test on, depth test off
*/
void FASTCALL __glDoStore_AS(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }
    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test on, stencil test off, depth test on
*/
void FASTCALL __glDoStore_AD(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }
    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test on, depth test on
*/
void FASTCALL __glDoStore_SD(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	(*gc->stencilBuffer.passDepthFailOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test on, stencil test off, depth test off
*/
void FASTCALL __glDoStore_A(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test on, depth test off, draw to current buffer
*/
void FASTCALL __glDoStore_S(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test off, depth test on
*/
void FASTCALL __glDoStore_D(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test off, depth test off, draw to current buffer
*/
void FASTCALL __glDoStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/************************************************************************/

void FASTCALL __glDoNullStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
}

void FASTCALL __glDoDoubleStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext * gc = cfb->buf.gc;
    cfb = gc->front;
    cfb->store( cfb, frag );
    cfb = gc->back;
    cfb->store( cfb, frag );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_prim.c ===
/******************************Module*Header*******************************\
* Module Name: so_prim.c
*
* Routines to draw primitives
*
* Created: 10-16-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.13 $
** $Date: 1993/08/31 16:23:41 $
*/
#include "precomp.h"
#pragma hdrstop

#include "glmath.h"
#include "devlock.h"

typedef void (FASTCALL *PFN_XFORM)
    (__GLcoord *, const __GLfloat *, const __GLmatrix *);

typedef void (FASTCALL *PFN_XFORMBATCH)
    (__GLcoord *, __GLcoord *, const __GLmatrix *);

#ifndef NEW_PARTIAL_PRIM
typedef void (FASTCALL *PFN_POLYARRAYDRAW)(__GLcontext *, POLYARRAY *);
#endif // NEW_PARTIAL_PRIM

typedef void (FASTCALL *PFN_POLYARRAYRENDER)(__GLcontext *, POLYARRAY *);

// The PA* functions apply to one array entry only.
// The PolyArray* functions apply to the whole array.

void FASTCALL PARenderPoint(__GLcontext *gc, __GLvertex *v);
void FASTCALL PARenderTriangle(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2);
void PARenderQuadFast(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3);
void PARenderQuadSlow(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3);
void FASTCALL PAApplyMaterial(__GLcontext *gc, __GLmatChange *mat, GLint face);
void FASTCALL PASphereGen(POLYDATA *pd, __GLcoord *result);

GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckFrustumWOne(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
                                     POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckAll(__GLcontext *gc, POLYARRAY *pa,
                               POLYDATA *pdLast);

void FASTCALL PolyArrayRenderPoints(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderLines(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderLStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderTriangles(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderTStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderTFan(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderQuads(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderQStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderPolygon(__GLcontext *gc, POLYARRAY *pa);

#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawPoints(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawLines(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawLLoop(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawLStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawTriangles(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawTStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawTFan(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawQuads(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawQStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawPolygon(__GLcontext *gc, POLYARRAY *pa);
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayPropagateIndex(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayPropagateSameIndex(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayPropagateSameColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayPropagateColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayProcessEye(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayProcessEdgeFlag(POLYARRAY *pa);

void FASTCALL PolyArrayComputeFog(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayApplyMaterials(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcLightCache(__GLcontext *gc);
GLuint FASTCALL PolyArrayCheckClippedPrimitive(__GLcontext *gc, POLYARRAY *pa, GLuint andCodes);
POLYARRAY * FASTCALL PolyArrayRemoveClippedPrimitives(POLYARRAY *pa0);

void RestoreAfterMcd(__GLGENcontext *gengc,
                     POLYARRAY *paBegin, POLYARRAY *paEnd);

// Turn on clipcode optimization
#define POLYARRAY_AND_CLIPCODES     1

// Some assertions used in this code

// ASSERT_PRIMITIVE
#if !((GL_POINTS         == 0x0000)     \
   && (GL_LINES          == 0x0001)     \
   && (GL_LINE_LOOP      == 0x0002)     \
   && (GL_LINE_STRIP     == 0x0003)     \
   && (GL_TRIANGLES      == 0x0004)     \
   && (GL_TRIANGLE_STRIP == 0x0005)     \
   && (GL_TRIANGLE_FAN   == 0x0006)     \
   && (GL_QUADS          == 0x0007)     \
   && (GL_QUAD_STRIP     == 0x0008)     \
   && (GL_POLYGON        == 0x0009))
#error "bad primitive ordering\n"
#endif

// ASSERT_FACE
#if !((__GL_FRONTFACE == 0) && (__GL_BACKFACE == 1))
#error "bad face ordering\n"
#endif

// ASSERT_MATERIAL
#if !((POLYARRAY_MATERIAL_FRONT == POLYDATA_MATERIAL_FRONT)      \
   && (POLYARRAY_MATERIAL_BACK  == POLYDATA_MATERIAL_BACK))
#error "bad material mask\n"
#endif

// ASSERT_VERTEX
#if !((POLYARRAY_VERTEX2 == POLYDATA_VERTEX2)   \
   && (POLYARRAY_VERTEX3 == POLYDATA_VERTEX3)   \
   && (POLYARRAY_VERTEX4 == POLYDATA_VERTEX4))
#error "bad vertex flags\n"
#endif

//!!! Set it to 0!
#define ENABLE_PERF_CHECK 0
#if ENABLE_PERF_CHECK
// Performance check macro
#define PERF_CHECK(expr,str)            \
    {                                   \
        static BOOL bPrinted = FALSE;   \
        if (!(expr) && !bPrinted)       \
        {                               \
            bPrinted = TRUE;            \
            WARNING("PERF_CHECK: " str);\
        }                               \
    }
#else
#define PERF_CHECK(expr,str)
#endif // ENABLE_PERF_CHECK

// Copy processed vertex.
#define PA_COPY_PROCESSED_VERTEX(pdDst,pdSrc)                   \
    {                                                           \
        *(pdDst) = *(pdSrc);                                    \
        /* must update color pointer for polygon to work! */    \
        (pdDst)->color = &(pdDst)->colors[__GL_FRONTFACE];      \
    }
#define PA_COPY_VERTEX(pdDst,pdSrc)     PA_COPY_PROCESSED_VERTEX(pdDst,pdSrc)

#define PD_ARRAY(ary, idx) \
    ((POLYDATA *)((GLubyte *)(ary)+(sizeof(POLYDATA) * idx)))
#define PD_VERTEX(ary, idx) \
    ((__GLvertex *)((GLubyte *)(ary)+(sizeof(__GLvertex) *idx)))

#ifndef NEW_PARTIAL_PRIM
// Poly array draw routines.
// ASSERT_PRIMITIVE
PFN_POLYARRAYDRAW afnPolyArrayDraw[] =
{
    (PFN_POLYARRAYDRAW) PolyArrayDrawPoints,
    (PFN_POLYARRAYDRAW) PolyArrayDrawLines,
    (PFN_POLYARRAYDRAW) PolyArrayDrawLLoop,
    (PFN_POLYARRAYDRAW) PolyArrayDrawLStrip,
    (PFN_POLYARRAYDRAW) PolyArrayDrawTriangles,
    (PFN_POLYARRAYDRAW) PolyArrayDrawTStrip,
    (PFN_POLYARRAYDRAW) PolyArrayDrawTFan,
    (PFN_POLYARRAYDRAW) PolyArrayDrawQuads,
    (PFN_POLYARRAYDRAW) PolyArrayDrawQStrip,
    (PFN_POLYARRAYDRAW) PolyArrayDrawPolygon,
};
#endif // NEW_PARTIAL_PRIM

// READ THIS NOTE BEFORE YOU MAKE ANY CHANGES!
//
// NOTE: This function is also called by RasterPos to compute its associated
//       color and texture coordinates!
//       This code has to update current values and material even if there is
//       no vertex.

//!!! special case provoking vertex?

void APIPRIVATE __glim_DrawPolyArray(void *_pa0)
{
    __GLtransform *trMV;
    __GLmatrix    *m, *mEye;
    GLuint        enables;
    GLuint        paNeeds;
    GLuint        orCodes, andCodes;
    GLuint        paflagsAll;
    POLYDATA      *pd;
    POLYARRAY     *pa0 = (POLYARRAY *) _pa0;
    POLYARRAY     *pa;
    PFN_XFORM     pfnXformEye;
    PFN_XFORMBATCH pfnXform;
    GLuint (FASTCALL *clipCheck)(__GLcontext *gc, POLYARRAY *pa,
                                 POLYDATA *pdLast);

    __GLmatrix    *mInv;
    GLboolean     doEye;
    __GLcolor     scaledUserColor;
    GLuint        paFlags;
    __GLcolor     *pScaledUserColor;
    __GLcoord     *pCurrentNormal;
    __GLcoord     *pCurrentTexture;
    GLboolean     bXformLightToNorm = FALSE;
    GLuint        primFlags;
    BOOL          bMcdProcessDone;
    BOOL          bIsRasterPos;
    POLYARRAY*    paPrev = 0;

    __GL_SETUP();

    // Crank down the fpu precision to 24-bit mantissa to gain front-end speed.
    // This will only affect code which relies on double arithmetic.  Also,
    // mask off FP exceptions:

    FPU_SAVE_MODE();
    FPU_PREC_LOW_MASK_EXCEPTIONS();

// There are 3 possible begin modes.  If we are in the begin/end bracket,
// it is __GL_IN_BEGIN.  If we are not in the begin/end bracket, it is either
// __GL_NOT_IN_BEGIN or __GL_NEED_VALIDATE.
// Validation should only be done inside the display lock!

    ASSERTOPENGL(gc->beginMode != __GL_IN_BEGIN, "bad beginMode!");

    if (gc->beginMode == __GL_NEED_VALIDATE)
        (*gc->procs.validate)(gc);

    gc->beginMode = __GL_IN_BEGIN;

    // Initialize variables.

    enables = gc->state.enables.general;

    paNeeds = gc->vertex.paNeeds;

    paflagsAll = 0;

    // Need to save this flag because pa0 can be modified later,
    // possibly dropping the flag.
    bIsRasterPos = pa0->flags & POLYARRAY_RASTERPOS;

// ---------------------------------------------------------
// Update final current values and initialize current values at index 0
// if not given.  Material changes are updated later.

    paFlags = 0;

    if (!gc->modes.colorIndexMode) {
        __GL_SCALE_AND_CHECK_CLAMP_RGBA(scaledUserColor.r,
                                        scaledUserColor.g,
                                        scaledUserColor.b,
                                        scaledUserColor.a,
                                        gc, paFlags,
                                        gc->state.current.userColor.r,
                                        gc->state.current.userColor.g,
                                        gc->state.current.userColor.b,
                                        gc->state.current.userColor.a);
        pScaledUserColor = &scaledUserColor;
    } else {
        __GL_CHECK_CLAMP_CI(scaledUserColor.r, gc, paFlags, gc->state.current.userColorIndex);
    }

    pCurrentNormal = &gc->state.current.normal;
    pCurrentTexture = &gc->state.current.texture;
    primFlags = 0;

    // Optimization Possibility:
    // Currently, for every Primitive, we check to see if any of the
    // Attributes have been set by the evaluator. This could be potentially
    // optimized by having two versions of this loop (perhaps in a macro or
    // a function call); one which makes the checks and the other which doesnt.
    // If no evaluator is enabled, we could call the faster version (with
    // no checks)

    for (pa = pa0; pa; pa = pa->paNext)
    {
        POLYDATA *pd0;

        pd0 = pa->pd0;
        if (gc->modes.colorIndexMode)
        {
            // CI mode.
            // Update final current RGBA color incase one is given.

            if (pa->flags & POLYARRAY_OTHER_COLOR)
                gc->state.current.userColor = pa->otherColor;

            // Update final current CI color.

            if (!(pd0->flags & POLYDATA_COLOR_VALID))
            {
                pd0->flags |= POLYDATA_COLOR_VALID;
                pd0->colors[0].r = gc->state.current.userColorIndex;
                pa->flags |= paFlags;
            }

            // Update current color. pdCurColor could be NULL is there
            // were no glColor calls.
            if (pa->pdCurColor)
            {
                gc->state.current.userColorIndex = pa->pdCurColor->colors[0].r;
            }

            paFlags = (pa->flags & POLYARRAY_CLAMP_COLOR);
        }
        else
        {
            // RGBA mode.
            // Update final current CI color in case one is given.

            if (pa->flags & POLYARRAY_OTHER_COLOR)
                gc->state.current.userColorIndex = pa->otherColor.r;

            // Update final current RGBA color.

            if (!(pd0->flags & POLYDATA_COLOR_VALID))
            {
                pd0->flags |= POLYDATA_COLOR_VALID;
                pd0->colors[0] = *pScaledUserColor;
                pa->flags |= paFlags;
            }

            // Update current color. pdCurColor could be NULL is there
            // were no glColor calls.
            if (pa->pdCurColor)
            {
                pScaledUserColor = &pa->pdCurColor->colors[0];
            }

            paFlags = (pa->flags & POLYARRAY_CLAMP_COLOR);
        }

        // Update final current normal.

        if (!(pd0->flags & POLYDATA_NORMAL_VALID))
        {
            if (paNeeds & PANEEDS_NORMAL) {
                pd0->flags |= POLYDATA_NORMAL_VALID;
                // can also be pd0->normal = gc->state.current.normal!
                pd0->normal.x = pCurrentNormal->x;
                pd0->normal.y = pCurrentNormal->y;
                pd0->normal.z = pCurrentNormal->z;
            }
        }

        // Update current normal. pdCurNormal could be NULL if there
        // were no glNormal calls.
        if (pa->pdCurNormal)
        {
            pCurrentNormal = &pa->pdCurNormal->normal;
        }

        // Update final current texture coordinates.

        if (!(pd0->flags & POLYDATA_TEXTURE_VALID))
        {
            if (paNeeds & PANEEDS_TEXCOORD) {
                pd0->flags |= POLYDATA_TEXTURE_VALID;
                pd0->texture = *pCurrentTexture;

                if (__GL_FLOAT_COMPARE_PONE(pd0->texture.w, !=))
                    pa->flags |= POLYARRAY_TEXTURE4;
                else if (__GL_FLOAT_NEZ(pd0->texture.z))
                    pa->flags |= POLYARRAY_TEXTURE3;
                else if (__GL_FLOAT_NEZ(pd0->texture.y))
                    pa->flags |= POLYARRAY_TEXTURE2;
                else
                    pa->flags |= POLYARRAY_TEXTURE1;
            }
        }

        // Update current texture. pdCurTexture could be NULL if there
        // were no glTexture calls.
        if (pa->pdCurTexture)
        {
            pCurrentTexture = &pa->pdCurTexture->texture;
        }

        /*
         * Update current pointers. They have to point to the latest valid data.
         */
        if (pa->pdCurColor < pa->pdLastEvalColor)
        {
            pa->pdCurColor = pa->pdLastEvalColor;
        }
        if (pa->pdCurNormal < pa->pdLastEvalNormal)
        {
            pa->pdCurNormal = pa->pdLastEvalNormal;
        }
        if (pa->pdCurTexture < pa->pdLastEvalTexture)
        {
            pa->pdCurTexture = pa->pdLastEvalTexture;
        }
        // Update the texture key for hardware accelaration:

        pa->textureKey = gc->textureKey;

        // Update final current edge flag.

        if (!(pd0->flags & POLYDATA_EDGEFLAG_VALID))
        {
            if (gc->state.current.edgeTag)
                pd0->flags |= POLYDATA_EDGEFLAG_VALID | POLYDATA_EDGEFLAG_BOUNDARY;
            else
                pd0->flags |= POLYDATA_EDGEFLAG_VALID;
        }

        if (pa->pdCurEdgeFlag)
        {
            gc->state.current.edgeTag = (GLboolean)
                (pa->pdCurEdgeFlag->flags & POLYDATA_EDGEFLAG_BOUNDARY);
        }

        // Accumulate pa flags.

        paflagsAll |= pa->flags;

        // Accumulate primitive type bits
        primFlags |= 1 << pa->primType;

        if (pa->pd0 == pa->pdNextVertex)
        {
        // The polyarray has no vertices.
        // We have to apply material changes if there were any between BEGIN/END
        // and remove the polyarray from the chain
            if (pa->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK))
                PolyArrayApplyMaterials(gc, pa);
            if (paPrev)
                paPrev->paNext = pa->paNext;
            else
                pa0 = pa->paNext;
            PolyArrayRestoreColorPointer(pa);
        }
        else
        {
            paPrev = pa;
        }
    }

    // Store the normalized user color:

    if (!gc->modes.colorIndexMode)
    {
        gc->state.current.userColor.r = pScaledUserColor->r * gc->oneOverRedVertexScale;
        gc->state.current.userColor.g = pScaledUserColor->g * gc->oneOverGreenVertexScale;
        gc->state.current.userColor.b = pScaledUserColor->b * gc->oneOverBlueVertexScale;
        gc->state.current.userColor.a = pScaledUserColor->a * gc->oneOverAlphaVertexScale;
    }

    gc->state.current.normal.x = pCurrentNormal->x;
    gc->state.current.normal.y = pCurrentNormal->y;
    gc->state.current.normal.z = pCurrentNormal->z;

    gc->state.current.texture = *pCurrentTexture;

    // All polyarrays could be removed if they had no vertices
    if (!pa0)
    {
        bXformLightToNorm = FALSE;
        goto drawpolyarray_exit;
    }

    //
    // Get the modeling matrix:
    //

    trMV = gc->transform.modelView;


    // ---------------------------------------------------------
    //
    // Allow MCD 2.0 to do transform and light if possible.
    // Don't try it for rasterpos calls.
    //

    bMcdProcessDone = FALSE;

#if MCD_VER_MAJOR >= 2
    if (((__GLGENcontext *)gc)->pMcdState != NULL &&
        McdDriverInfo.mcdDriver.pMCDrvProcess != NULL &&
        gc->renderMode == GL_RENDER &&
        !bIsRasterPos)
#else
    if (0)
#endif
    {
        POLYMATERIAL *pm;
        PDMATERIAL *pdMat;
        POLYARRAY *paEnd;

        // If no material changes have ever been seen then there
        // won't be a polymaterial at all.
        pm = GLTEB_CLTPOLYMATERIAL();
        if (pm != NULL)
        {
            pdMat = pm->pdMaterial0;
        }
        else
        {
            pdMat = NULL;
        }

        paEnd = GenMcdProcessPrim((__GLGENcontext *)gc,
                                  pa0, paflagsAll, primFlags,
                                  (MCDTRANSFORM *)trMV,
                                  (MCDMATERIALCHANGES *)pdMat);

        RestoreAfterMcd((__GLGENcontext *)gc, pa0, paEnd);
        bMcdProcessDone = TRUE;

        if (paEnd == NULL)
        {
            goto drawpolyarray_exit;
        }
        else
        {
            // If MCDrvProcess kicks back we will not
            // call MCDrvDraw.  We could check for non-generic
            // here and abandon the batch, saving the front-end processing.
            // I don't think it's worth it since kicking back on
            // a non-generic format is basically a driver bug.
            pa0 = paEnd;
        }
    }


// ---------------------------------------------------------
// Initialize the normal matrix:
// Normals are not needed after color assignment and texture generation!
// The above is not true anymore. You need Normals for true PHONG shading.
// IN:  normal matrix
// OUT: normal matrix (processed)

    if (paNeeds & (PANEEDS_NORMAL | PANEEDS_NORMAL_FOR_TEXTURE))
    {
        if (trMV->flags & XFORM_UPDATE_INVERSE)
            __glComputeInverseTranspose(gc, trMV);
        gc->mInv = mInv = &trMV->inverseTranspose;
    }
#if DBG
    else
        gc->mInv = mInv = (__GLmatrix *) -1;
#endif

// ---------------------------------------------------------
// Find out is we have to transform normals for lighting
// We can only do lighting in object space if:
//      we're using infinite lighting AND
//      we're not doing two-sided lighting AND
//      we're rendering AND
//      the transformation matrix has unity scaling
//
    bXformLightToNorm =
        (gc->vertex.paNeeds & PANEEDS_NORMAL) &&
        (gc->renderMode == GL_RENDER) &&
        (mInv->nonScaling) &&
        ((paNeeds & (PANEEDS_FRONT_COLOR | PANEEDS_BACK_COLOR)) ==
                    PANEEDS_FRONT_COLOR) &&
        ((gc->procs.paCalcColor == PolyArrayFastCalcRGBColor) ||
         (gc->procs.paCalcColor == PolyArrayZippyCalcRGBColor) ||
         (gc->procs.paCalcColor == PolyArrayFastCalcCIColor));

// Transform normals for spherical map texture generation
//
    if (paNeeds & PANEEDS_NORMAL_FOR_TEXTURE)
    {
    // If we transform normals for texture, we have to process lighting in camera space
        bXformLightToNorm = FALSE;
    // Now transform normals
        for (pa = pa0; pa; pa = pa->paNext)
        {
            if (!(enables & __GL_NORMALIZE_ENABLE))
                (*mInv->xfNormBatch)(pa, mInv);
            else
                (*mInv->xfNormBatchN)(pa, mInv);
        }
        paNeeds &= ~PANEEDS_NORMAL;
    }

// ---------------------------------------------------------
// Process texture coordinates.  We need to do this while we still have
// valid object coordinate data.  If we need normals to perform the texture
// generation, we also transform the normals.
//
// Texture coordinates are modified in place.
//
// IN:  texture, obj, (eye), normal
// OUT: texture, (eye)

    if (paNeeds & PANEEDS_TEXCOORD)
    {
        if ((gc->procs.paCalcTexture == PolyArrayCalcTexture) &&
            (gc->transform.texture->matrix.matrixType == __GL_MT_IDENTITY)) {

            for (pa = pa0; pa; pa = pa->paNext)
            {
                PERF_CHECK(!(pa->flags & (POLYARRAY_TEXTURE3 | POLYARRAY_TEXTURE4)),
                           "Uses r, q texture coordinates!\n");

                // If all incoming vertices have valid texcoords, and texture
                // matrix is identity, and texgen is disabled, we are done.
                if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
                    && (pa->pdCurTexture != pa->pd0)
                // Need to test 2nd vertex because pdCurTexture may have been
                // advanced as a result of combining TexCoord command after End
                    && ((pa->pd0 + 1)->flags & POLYDATA_TEXTURE_VALID))
                  ;
                else
                    PolyArrayCalcTexture(gc, pa);
            }
        } else {
            for (pa = pa0; pa; pa = pa->paNext)
            {
                PERF_CHECK(!(pa->flags & (POLYARRAY_TEXTURE3 | POLYARRAY_TEXTURE4)),
                           "Uses r, q texture coordinates!\n");

                (*gc->procs.paCalcTexture)(gc, pa);
            }
        }
    }

    //
    // Process the eye coordinate if:
    //   user clip planes are enabled
    //   we're processing RASTERPOS
    //   we have slow lighting which needs the eye coordinate
    //
    // We need to process the eye coordinate here because the
    // object coordinate gets trashed by the initial obj->clip
    // transform.
    //
    //
    //

    clipCheck = gc->procs.paClipCheck;

    // Compute eye coord first
    // We need eye coordinates to do user clip plane clipping
    if ((clipCheck == PAClipCheckAll) ||
        bIsRasterPos ||
        (gc->procs.paCalcColor == PolyArrayCalcCIColor) ||
        (gc->procs.paCalcColor == PolyArrayCalcRGBColor) ||
#ifdef GL_WIN_phong_shading
        (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE) ||
#endif //GL_WIN_phong_shading
        (enables & __GL_FOG_ENABLE && gc->renderMode == GL_RENDER))
    {
        mEye = &trMV->matrix;

        if (paflagsAll & POLYARRAY_VERTEX4)
            pfnXformEye = mEye->xf4;
        else if (paflagsAll & POLYARRAY_VERTEX3)
            pfnXformEye = mEye->xf3;
        else
            pfnXformEye = mEye->xf2;

        doEye = TRUE;
    } else
        doEye = FALSE;


    // If any incoming coords contains w coord, use xf4.

    m = &trMV->mvp;

    if (paflagsAll & POLYARRAY_VERTEX4)
        pfnXform = (void*)m->xf4Batch;
    else if (paflagsAll & POLYARRAY_VERTEX3)
        pfnXform = (void*)m->xf3Batch;
    else
        pfnXform = (void*)m->xf2Batch;

//---------------------------------------------------------------------------
// If normalization is on, we will handle it here in one pass.  We will
// then transform the light into normal space
// flag.  Note that we need to save the original light values away so
// we can restore them before we exit.
//
    if (bXformLightToNorm)
    {
        __GLlightSourceMachine *lsm;
        LONG i;
        __GLmatrix matrix2;

        __glTranspose3x3(&matrix2, &trMV->matrix);
        for (i = 0, lsm = gc->light.sources; lsm; lsm = lsm->next, i++) {
            __GLcoord hv;
            __GLmatrix matrix;

            lsm->tmpHHat = lsm->hHat;
            lsm->tmpUnitVPpli = lsm->unitVPpli;


            __glMultMatrix(&matrix,
                           &gc->state.light.source[i].lightMatrix, &matrix2);

            hv = gc->state.light.source[i].position;

            __glXForm3x3(&hv, &hv.x, &matrix);
            __glNormalize(&lsm->unitVPpli.x, &hv.x);

            hv = lsm->unitVPpli;

            hv.x += matrix.matrix[2][0];
            hv.y += matrix.matrix[2][1];
            hv.z += matrix.matrix[2][2];

            __glNormalize(&lsm->hHat.x, &hv.x);
        }
    }

    PolyArrayCalcLightCache(gc);

// ---------------------------------------------------------
// Do transform, color, and lighting calculations.
//
// This is the heart of the rendering pipeline, so we try
// to do as many operations as possible while touching the
// least amount of memory to reduce cache affects.
//
// If it is phong-shading, dont update materials and dont do
// lighting.
// ---------------------------------------------------------

    for (pa = pa0; pa; pa = pa->paNext)
    {
        POLYDATA *pdLast;

#ifdef NEW_PARTIAL_PRIM
        pa->flags |= POLYARRAY_RENDER_PRIMITIVE;    // Needed for MCD
#endif
        pdLast = pa->pdNextVertex - 1;

// ---------------------------------------------------------
// Process the eye coordinate if we will need it in the
// pipeline and haven't yet processed it in texture generation.
// We have to do this before we trash the object coord in the
// next phase.
//
// IN:  obj
// OUT: eye

        if (doEye && !(pa->flags & POLYARRAY_EYE_PROCESSED)) {

            pa->flags |= POLYARRAY_EYE_PROCESSED;

            if (mEye->matrixType == __GL_MT_IDENTITY) {
                for (pd = pa->pd0; pd <= pdLast; pd++)
                    pd->eye = pd->obj;
            } else {
                for (pd = pa->pd0; pd <= pdLast; pd++)
                    (*pfnXformEye)(&pd->eye, (__GLfloat *) &pd->obj, mEye);
            }
        }

// ---------------------------------------------------------
// Process the object coordinate.  This generates the clip
// and window coordinates, along with the clip codes.
//
// IN:  obj (destroyed)
// OUT: clip, window

        orCodes  = 0;   // accumulate all clip codes
#ifdef POLYARRAY_AND_CLIPCODES
        andCodes = (GLuint) -1;
#endif


        if (m->matrixType == __GL_MT_IDENTITY)
        {
            // pd->clip = pd->obj;
            ASSERTOPENGL(&pd->clip == &pd->obj, "bad clip offset\n");
        }
        else
           (*pfnXform)(&pa->pd0->clip, &pdLast->clip, m);

        pa->orClipCodes  = 0;
        pa->andClipCodes = (GLuint)-1;

        if (clipCheck != PAClipCheckFrustum2D)
        {
            if (m->matrixType != __GL_MT_GENERAL &&
                !(pa->flags & POLYDATA_VERTEX4)  &&
                clipCheck != PAClipCheckAll)
                andCodes = PAClipCheckFrustumWOne(gc, pa, pdLast);
            else
                andCodes = (*clipCheck)(gc, pa, pdLast);
        }
        else
        {
            if (pa->flags & (POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
                andCodes = PAClipCheckFrustum(gc, pa, pdLast);
            else
                andCodes = PAClipCheckFrustum2D(gc, pa, pdLast);
        }
#ifdef POLYARRAY_AND_CLIPCODES
        if (andCodes)
        {
            andCodes = PolyArrayCheckClippedPrimitive(gc, pa, andCodes);
            // add POLYARRAY_REMOVE_PRIMITIVE flag
            paflagsAll |= pa->flags;
        }
        pa->andClipCodes = andCodes;
#endif

// ---------------------------------------------------------
// Process colors and materials if we're not in selection and
// haven't been completely clipped out.
//
// IN:  obj/eye, color (front), normal
// OUT: (normal), color (front and back)

        if (!(pa->flags & POLYARRAY_REMOVE_PRIMITIVE) &&
            !(paNeeds & PANEEDS_CLIP_ONLY))
        {
            if (!(enables & __GL_LIGHTING_ENABLE))
            {
                // Lighting is disabled.
                // Clamp RGBA colors, mask color index values.
                // Only front colors are computed, back colors are not needed.

                if (paNeeds & PANEEDS_SKIP_LIGHTING)
                {
                    // Note that when lighting calculation is skipped,
                    // we still need to fill in the colors field.
                    // Otherwise, the rasterization routines may get FP
                    // exceptions on invalid colors.

                    pa->flags |= POLYARRAY_SAME_COLOR_DATA;
                    (*gc->procs.paCalcColorSkip)(gc, pa, __GL_FRONTFACE);
                }
                else if (pa->flags & POLYARRAY_SAME_COLOR_DATA)
                {
                    if (gc->modes.colorIndexMode)
                        PolyArrayPropagateSameIndex(gc, pa);
                    else
                        PolyArrayPropagateSameColor(gc, pa);
                }
                else if (gc->modes.colorIndexMode)
                {
                    PolyArrayPropagateIndex(gc, pa);
                }
                else
                {
                    PolyArrayPropagateColor(gc, pa);
                }
            }
            else
            {
            // It is time to transform and normalize normals if nesessary
                if (bXformLightToNorm)
                {
                    if(enables & __GL_NORMALIZE_ENABLE)
                    {
                        __glNormalizeBatch(pa);
                    }
                }
                else
                {
                    if (paNeeds & PANEEDS_NORMAL)
                    {
                        if (!(enables & __GL_NORMALIZE_ENABLE))
                            (*mInv->xfNormBatch)(pa, mInv);
                        else
                            (*mInv->xfNormBatchN)(pa, mInv);
                    }
                }
#ifdef GL_WIN_phong_shading
                // if phong-shading, then do this at rendering time
                // else do it here
                if (!(gc->state.light.shadingModel == GL_PHONG_WIN)
                    || (pa->primType <= GL_POINTS))
#endif //GL_WIN_phong_shading
                {

                    // Lighting is enabled.

                    POLYDATA  *pd1, *pd2, *pdN;
                    GLint     face;
                    GLuint    matMask;
                    GLboolean doFrontColor, doBackColor, doColor;

                    // Clear POLYARRAY_SAME_COLOR_DATA flag if lighting is
                    // enabled.

                    pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

                    pdN = pa->pdNextVertex;

                    // Needs only front color for points and lines.

                    // ASSERT_PRIMITIVE
                    if ((unsigned int) pa->primType <= GL_LINE_STRIP)
                    {
                        doFrontColor = GL_TRUE;
                        doBackColor  = GL_FALSE;
                    }
                    else
                    {
                        doFrontColor = paNeeds & PANEEDS_FRONT_COLOR;
                        doBackColor  = paNeeds & PANEEDS_BACK_COLOR;
                    }

                    // Process front and back colors in two passes.
                    // Do back colors first!
                    //!!! We can potentially optimize 2-sided lighting in the
                    // slow path by running through all vertices and look for
                    // color needs for each vertex!
                    // See RenderSmoothTriangle.

                    PERF_CHECK
                      (
                       !(doFrontColor && doBackColor),
                       "Two-sided lighting - need both colors!\n"
                       );

                    // ASSERT_FACE
                    // ASSERT_MATERIAL
                    for (face = 1,
                           matMask = POLYARRAY_MATERIAL_BACK,
                           doColor = doBackColor;
                         face >= 0;
                         face--,
                           matMask = POLYARRAY_MATERIAL_FRONT,
                           doColor = doFrontColor
                         )
                    {
                        POLYMATERIAL  *pm;

                        if (!doColor)
                            continue;

                        // If color is not needed, fill in the colors field
                        // with default.

                        if (paNeeds & PANEEDS_SKIP_LIGHTING)
                        {
                            (*gc->procs.paCalcColorSkip)(gc, pa, face);
                            continue;
                        }

                        // Process color ranges that include no material
                        // changes (excluding color material) one at a time.
                        // Color material changes are handled in the color
                        // procs.

                        if (!(pa->flags & matMask))
                        {
                            // process the whole color array
                            (*gc->procs.paCalcColor)(gc, face, pa, pa->pd0,
                                                     pdN - 1);
                            continue;
                        }

                        // There are material changes, we need to recompute
                        // material and light source machine values before
                        // processing the next color range.
                        // Each range below is given by [pd1, pd2-1].
                        //!!! it is possible to fix polyarraycalcrgbcolor to
                        // accept certain material!

                        pm = GLTEB_CLTPOLYMATERIAL();

                        // no need to do this material later
                        pa->flags &= ~matMask;

                        for (pd1 = pa->pd0; pd1 <= pdN; pd1 = pd2)
                        {
                            POLYDATA *pdColor, *pdNormal;

                            // Apply material changes to the current vertex.
                            // It also applies trailing material changes
                            // following the last vertex.
                            if (pd1->flags & matMask)
                                PAApplyMaterial(gc,
                                        *(&pm->pdMaterial0[pd1 -
                                         pa->pdBuffer0].front + face), face);

                            // If this is the trailing material change, we are
                            // done.
                            if (pd1 == pdN)
                                break;

                            // Find next vertex with material changes. We
                            // need to track current color and normal so that
                            // the next color range begins with valid color
                            // and normal. We cannot track current values on
                            // client side because we don't have initial
                            // current values when batching this function.

                            pdColor  = pd1;
                            pdNormal = pd1;
                            for (pd2 = pd1 + 1; pd2 < pdN; pd2++)
                            {
                                // track current color
                                if (pd2->flags & POLYDATA_COLOR_VALID)
                                    pdColor = pd2;

                                // track current normal
                                if (pd2->flags & POLYDATA_NORMAL_VALID)
                                    pdNormal = pd2;

                                if (pd2->flags & matMask)
                                    break;
                            }

                            // Update next vertex's current color and normal
                            // if not given. The paCalcColor proc assumes that
                            // the first vertex contains a valid current color
                            // and normal.  We need to save the current values
                            // before they are modified by the color procs.

                            if (!(pd2->flags & POLYDATA_COLOR_VALID))
                            {
                                pd2->flags |= POLYDATA_COLOR_VALID;
                                pd2->colors[0] = pdColor->colors[0];
                            }

                            if (!(pd2->flags & POLYDATA_NORMAL_VALID))
                            {
                                pd2->flags |= POLYDATA_NORMAL_VALID;
                                pd2->normal.x = pdNormal->normal.x;
                                pd2->normal.y = pdNormal->normal.y;
                                pd2->normal.z = pdNormal->normal.z;
                            }

                            // Compute the colos range [pd1, pd2-1] that
                            // contains no material changes.
                            (*gc->procs.paCalcColor)(gc, face, pa, pd1, pd2-1);
                        }
                    } // for (faces)

                } // Not phong-shading
#ifdef GL_WIN_phong_shading
                else
                {
                    PolyArrayPhongPropagateColorNormal(gc, pa);
                }
#endif //GL_WIN_phong_shading
            } // lighting enabled
        }

        // Update material.
        if ((pa->flags & (POLYARRAY_MATERIAL_FRONT |
                         POLYARRAY_MATERIAL_BACK))
#ifdef GL_WIN_phong_shading
            && ((gc->state.light.shadingModel != GL_PHONG_WIN)
                || (pa->primType <= GL_POINTS))
#endif //GL_WIN_phong_shading
            )
            PolyArrayApplyMaterials(gc, pa);
    } // end of transform, color, and lighting calculations.

// ---------------------------------------------------------
// This is the end of the main pipeline loop.  At this point,
// we need to take care of selection, removal of rejected
// primitives, cheap fog, and edge-flag processing.
// ---------------------------------------------------------


    // In selection, we need only clip and window (and possibly eye values
    // computed above.)  At this point, we have already applied materials as
    // well. But we still need to apply materials and colors.

    if (paNeeds & PANEEDS_CLIP_ONLY)
        goto drawpolyarray_render_primitives;

    // If any of the andClipCodes is nonzero, we may be able to throw away
    // some primitives.

#ifdef POLYARRAY_AND_CLIPCODES
    if (paflagsAll & POLYARRAY_REMOVE_PRIMITIVE)
    {
        pa0 = PolyArrayRemoveClippedPrimitives(pa0);
        if (!pa0)
            goto drawpolyarray_apply_color;
    }
#endif


// ---------------------------------------------------------
// Process cheap fog.
//
// IN:  obj/eye, color
// OUT: eye, fog, color

    // if this is changed, need to fix RasterPos's setup!
    if ((gc->renderMode == GL_RENDER)
        && (enables & __GL_FOG_ENABLE)
        && (gc->polygon.shader.modeFlags & (__GL_SHADE_INTERP_FOG |
                                            __GL_SHADE_CHEAP_FOG)))
    {
        for (pa = pa0; pa; pa = pa->paNext)
        {
            // Note: the eye coordinate has already been computed.

            // compute fog values
            PolyArrayComputeFog(gc, pa);

            if (gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG)
            {
#ifdef GL_WIN_specular_fog
              ASSERTOPENGL (!(gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG), "Cheap fog cannot be done if Specular fog is needed\n");
#endif //GL_WIN_specular_fog


                // Apply fog if it is smooth shading and in render mode.
                // In flat/phong shading, cheap fogging is currently done at
                // render procs we can probably do cheap fog in flat shading
                // here but we will need to compute the provoking colors with
                // z info correctly so we can interpolate in the clipping
                // procs.  It would require rewriting the clipping routines
                // in so_clip.c too!
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT)
                    (*gc->procs.paApplyCheapFog)(gc, pa);
            }
            else
            {
                PERF_CHECK(FALSE, "Uses slow fog\n");
            }
        }
    }

// ---------------------------------------------------------
// Process edge flags.
//
// IN:  edge
// OUT: edge (all vertices)

    if (paNeeds & PANEEDS_EDGEFLAG)
    {
        for (pa = pa0; pa; pa = pa->paNext)
        {
            if (pa->primType == GL_TRIANGLES
                || pa->primType == GL_QUADS
                || pa->primType == GL_POLYGON)
            {
                // If all incoming vertices have valid edgeflags, we are done.
                // When all polydata's are of the same type, there are 2 cases
                // where edge flag processing can be skipped:
                //   1. All edge flags were given.
                //   2. No edge flag was given and the initial edge flag (i.e.
                //      current gc edge flag) is non boundary.  In this case,
                //      all edge flags were set to non boundary in pd->flags
                //      initialization.
              if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
                  && (((pa->pdCurEdgeFlag != pa->pd0) &&
                       // Need to test 2nd vertex because pdCurEdgeFlag may
                       // have been advanced as a result of combining EdgeFlag
                       // command after End
                       ((pa->pd0 + 1)->flags & POLYDATA_EDGEFLAG_VALID))
                      || !(pa->pd0->flags & POLYDATA_EDGEFLAG_BOUNDARY)))
                ;
              else
                  PolyArrayProcessEdgeFlag(pa);
#ifdef NEW_PARTIAL_PRIM
              // For partial begin polygon we have to clear edge flag for first vertex.
              // For partial end polygon we have to clear edge flag for last vertex.
              //
              if (pa->primType == GL_POLYGON)
              {
                    if (pa->flags & POLYARRAY_PARTIAL_END)
                        (pa->pdNextVertex-1)->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
                    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
                        pa->pd0->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
              }
#endif // NEW_PARTIAL_PRIM
            }
        }
    }

// ---------------------------------------------------------
// Process the primitives.

drawpolyarray_render_primitives:

    // Skip the rest if this is a RasterPos
    if (bIsRasterPos)
        goto drawpolyarray_exit;

#ifndef NEW_PARTIAL_PRIM
    for (pa = pa0; pa; pa = pa->paNext)
    {
        ASSERTOPENGL(pa->primType >= GL_POINTS && pa->primType <= GL_POLYGON,
                     "DrawPolyArray: bad primitive type\n");

        (*afnPolyArrayDraw[pa->primType])(gc, pa);
    }
#endif // NEW_PARTIAL_PRIM
// ---------------------------------------------------------
// Update final light source machine.
// The user color was initialized above.

#ifndef GL_WIN_phong_shading
drawpolyarray_apply_color:
    (*gc->procs.applyColor)(gc);
#endif //GL_WIN_phong_shading

// ---------------------------------------------------------
// Flush the primitive chain.

    // To draw primitives, we can let the FPU run in chop (truncation) mode
    // since we have enough precision left to convert to pixel units.

    FPU_CHOP_ON_PREC_LOW();

#if 1
    if (pa0)
        glsrvFlushDrawPolyArray(pa0, bMcdProcessDone);
#endif

drawpolyarray_exit:
    // Out of begin mode.
#ifdef GL_WIN_phong_shading
drawpolyarray_apply_color:
        (*gc->procs.applyColor)(gc);
#endif //GL_WIN_phong_shading
// Out of begin mode.

    FPU_RESTORE_MODE_NO_EXCEPTIONS();

    ASSERTOPENGL(gc->beginMode == __GL_IN_BEGIN, "bad beginMode!");
    gc->beginMode = __GL_NOT_IN_BEGIN;
//
// If we were using object-space lighting, restore the original lighting values:
//

    if (bXformLightToNorm) {
        __GLlightSourceMachine *lsm;

        for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
            lsm->hHat = lsm->tmpHHat;
            lsm->unitVPpli = lsm->tmpUnitVPpli;
        }
    }

    return;
}


#ifdef POLYARRAY_AND_CLIPCODES
// Determine if a clipped primitive can be removed early.
// If the logical AND of vertex clip codes of a primitive is non-zero,
// the primitive is completely clipped and can be removed early.
// However, if a primitive is partially built, we may not be able to
// remove it yet to maintain connectivity between the partial primitives.
// By eliminating a primitive early, we save on lighting and other calculations.
//
// Set POLYARRAY_REMOVE_PRIMITIVE flag if the primitve can be removed early.
// Return new andCodes.

GLuint FASTCALL PolyArrayCheckClippedPrimitive(__GLcontext *gc, POLYARRAY *pa, GLuint andCodes)
{
    ASSERTOPENGL(andCodes, "bad andCodes\n");

    // Don't eliminate RasterPos

    if (pa->flags & POLYARRAY_RASTERPOS)
        return andCodes;

#ifndef NEW_PARTIAL_PRIM

    // If this is a partial begin, include previous clipcode.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        switch (pa->primType)
        {
          case GL_LINE_LOOP:
            // previous vertex
            andCodes &= gc->vertex.pdSaved[0].clipCode;
            // loop vertex
            if (!(pa->flags & POLYARRAY_PARTIAL_END))
                andCodes &= gc->vertex.pdSaved[1].clipCode;
            break;

          case GL_POLYGON:
            andCodes &= gc->vertex.pdSaved[2].clipCode;
            // fall through
          case GL_TRIANGLE_FAN:
          case GL_TRIANGLE_STRIP:
          case GL_QUAD_STRIP:
            andCodes &= gc->vertex.pdSaved[1].clipCode;
            // fall through
          case GL_LINE_STRIP:
            andCodes &= gc->vertex.pdSaved[0].clipCode;
            break;

          case GL_POINTS:
          case GL_LINES:
          case GL_TRIANGLES:
          case GL_QUADS:
          default:
            break;
        }
    }
    if (andCodes
      &&
        (
            !(pa->flags & POLYARRAY_PARTIAL_END) ||
            pa->primType == GL_POINTS    ||
            pa->primType == GL_LINES     ||
            pa->primType == GL_TRIANGLES ||
            pa->primType == GL_QUADS
        )
       )
        pa->flags |= POLYARRAY_REMOVE_PRIMITIVE;
#else
    //
    // If we have partial end primitive we cannot remove line strip, line loop or
    // polygon to preserve stipple pattern. Line loop was converted to line strip.
    //
    if (andCodes &&
        !(pa->flags & POLYARRAY_PARTIAL_END &&
         (pa->primType == GL_LINE_STRIP || pa->primType == GL_POLYGON)))
        pa->flags |= POLYARRAY_REMOVE_PRIMITIVE;
#endif // NEW_PARTIAL_PRIM

    // return new andCodes.

    return andCodes;
}

// Remove completely clipped primitives from the polyarray chain.
POLYARRAY * FASTCALL PolyArrayRemoveClippedPrimitives(POLYARRAY *pa0)
{
    POLYARRAY *pa, *paNext, *pa2First, *pa2Last;

    // Eliminate the trivially clipped primitives and build a new pa chain.

    pa2First = pa2Last = NULL;

    for (pa = pa0; pa; pa = paNext)
    {
        // get next pa first
        paNext = pa->paNext;

        if (pa->flags & POLYARRAY_REMOVE_PRIMITIVE)
        {
            PolyArrayRestoreColorPointer(pa);
        }
        else
        {
            // add to the new pa chain

            if (!pa2First)
                pa2First = pa;
            else
                pa2Last->paNext = pa;
            pa2Last = pa;
            pa2Last->paNext = NULL;
        }
    }

    // Return the new pa chain.

    return pa2First;
}
#endif // POLYARRAY_AND_CLIPCODES

/******************************Public*Routine******************************\
*
* RestoreAfterMcd
*
* Handles final bookkeeping necessary after the MCD has processed
* some or all of a batch.
*
* History:
*  Thu Mar 20 12:04:49 1997     -by-    Drew Bliss [drewb]
*   Split from glsrvFlushDrawPolyArray.
*
\**************************************************************************/

void RestoreAfterMcd(__GLGENcontext *gengc,
                     POLYARRAY *paBegin, POLYARRAY *paEnd)
{
    POLYARRAY *pa, *paNext;

    // Restore color pointer in the vertex buffer (for the POLYARRAYs
    // that have been processed by MCD; leave the unprocessed ones
    // alone).
    //
    // If the driver is using DMA, it must do the reset.  If not DMA,
    // we will do it for the driver.

    if (!(McdDriverInfo.mcdDriverInfo.drvMemFlags & MCDRV_MEM_DMA))
    {
        for (pa = paBegin; pa != paEnd; pa = paNext)
        {
            paNext = pa->paNext;
            PolyArrayRestoreColorPointer(pa);
        }
    }
    else
    {
        // With DMA, the driver must either process the entire batch
        // or reject the entire batch.
        //
        // Therefore, if the MCD call returns success (paEnd == NULL),
        // the POLYARRAY is being sent via DMA to the driver and we
        // need to switch to the other buffer.  Otherwise, we need to
        // drop down into the software implementation.

        if (!paEnd)
        {
            GenMcdSwapBatch(gengc);
        }
    }
}

/******************************Public*Routine******************************\
*
* RescaleVertexColorsToBuffer
*
* Scales vertex colors from vertex (MCD) color range to buffer color
* range for software simulations.
*
* History:
*  Thu Mar 20 16:21:16 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void RescaleVertexColorsToBuffer(__GLcontext *gc, POLYARRAY *pa)
{
    int idx;
    POLYDATA *pd, *pdLast;

    idx = 0;
    if (pa->primType <= GL_LINE_STRIP)
    {
        idx |= 1;
    }
    else
    {
        if (gc->vertex.paNeeds & PANEEDS_FRONT_COLOR)
        {
            idx |= 1;
        }
        if (gc->vertex.paNeeds & PANEEDS_BACK_COLOR)
        {
            idx |= 2;
        }
    }

    pdLast = pa->pdNextVertex-1;

    switch(idx)
    {
    case 1:
        // Front color only.

        if (gc->modes.colorIndexMode)
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
            }
        }
        else
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
                pd->colors[0].g *= gc->greenVertexToBufferScale;
                pd->colors[0].b *= gc->blueVertexToBufferScale;
                pd->colors[0].a *= gc->alphaVertexToBufferScale;
            }
        }
        break;

    case 2:
        // Back color only.

        if (gc->modes.colorIndexMode)
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[1].r *= gc->redVertexToBufferScale;
            }
        }
        else
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[1].r *= gc->redVertexToBufferScale;
                pd->colors[1].g *= gc->greenVertexToBufferScale;
                pd->colors[1].b *= gc->blueVertexToBufferScale;
                pd->colors[1].a *= gc->alphaVertexToBufferScale;
            }
        }
        break;

    case 3:
        // Front and back colors.

        if (gc->modes.colorIndexMode)
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
                pd->colors[1].r *= gc->redVertexToBufferScale;
            }
        }
        else
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
                pd->colors[0].g *= gc->greenVertexToBufferScale;
                pd->colors[0].b *= gc->blueVertexToBufferScale;
                pd->colors[0].a *= gc->alphaVertexToBufferScale;
                pd->colors[1].r *= gc->redVertexToBufferScale;
                pd->colors[1].g *= gc->greenVertexToBufferScale;
                pd->colors[1].b *= gc->blueVertexToBufferScale;
                pd->colors[1].a *= gc->alphaVertexToBufferScale;
            }
        }
    }
}

/******************************Public*Routine******************************\
* glsrvFlushDrawPolyArray
*
* The dispatch code in glsrvAttention links together the POLYARRAY data
* structures of consecutive glim_DrawPolyArray calls.  The front end
* preprocessing of the vertices in each POLYARRAY is executed immediately
* in glim_DrawPolyArray (i.e., PolyArrayDrawXXX), but the actually back end
* rendering (PolyArrayRenderXXX) is delayed until the chain is broken (either
* by a non-DrawPolyArray call, the end of the batch, or a batch timeout).
*
* glsrvFlushDrawPolyArray is the function that is called to flush the
* chained POLYARRAYs by invoking the back end rendering code.  The back end
* may be the generic software-only implementation or the MCD driver.
*
* History:
*  12-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

// Poly array render routines.
// ASSERT_PRIMITIVE
PFN_POLYARRAYRENDER afnPolyArrayRender[] =
{
    (PFN_POLYARRAYRENDER) PolyArrayRenderPoints,
    (PFN_POLYARRAYRENDER) PolyArrayRenderLines,
    (PFN_POLYARRAYRENDER) NULL,         // line loop not required
    (PFN_POLYARRAYRENDER) PolyArrayRenderLStrip,
    (PFN_POLYARRAYRENDER) PolyArrayRenderTriangles,
    (PFN_POLYARRAYRENDER) PolyArrayRenderTStrip,
    (PFN_POLYARRAYRENDER) PolyArrayRenderTFan,
    (PFN_POLYARRAYRENDER) PolyArrayRenderQuads,
    (PFN_POLYARRAYRENDER) PolyArrayRenderQStrip,
    (PFN_POLYARRAYRENDER) PolyArrayRenderPolygon,
};

void APIPRIVATE glsrvFlushDrawPolyArray(POLYARRAY *paBegin,
                                        BOOL bMcdProcessDone)
{
    POLYARRAY *pa, *paNext;
    __GLGENcontext *gengc;
    BOOL bResetViewportAdj = FALSE;
    __GL_SETUP();

//#define FRONT_END_ONLY 1

#if FRONT_END_ONLY

    if (paBegin)
    {
        for (pa = paNext = paBegin; pa = paNext; )
        {
            ASSERTOPENGL(pa->primType >= GL_POINTS &&
                         pa->primType <= GL_POLYGON,
                         "DrawPolyArray: bad primitive type\n");

            // Get next pointer first!
            paNext = pa->paNext;
            // Restore color pointer in the vertex buffer!
            PolyArrayRestoreColorPointer(pa);
        }
    }

    return;
#endif

    gengc = (__GLGENcontext *) gc;

#ifdef _MCD_
#if DBG
    if (gengc->pMcdState && !(glDebugFlags & GLDEBUG_DISABLEPRIM) &&
        (gc->renderMode == GL_RENDER))
#else
    if ((gengc->pMcdState) && (gc->renderMode == GL_RENDER))
#endif
    {
        POLYARRAY *paEnd;

        // If no commands were processed via MCD front-end support
        // then try the rasterization support.
        if (!bMcdProcessDone)
        {
            // Let the MCD driver have first crack.  If the MCD processes
            // the entire batch, then it will return NULL.  Otherwise, it
            // will return a pointer to a chain of unprocessed POLYARRAYs.
            paEnd = GenMcdDrawPrim(gengc, paBegin);
            RestoreAfterMcd(gengc, paBegin, paEnd);
        }
        else
        {
            // MCD has already kicked back so nothing is consumed.
            paEnd = paBegin;
        }

        // Prepare to use generic to provide simulations for the
        // unhandled POLYARRAYs, if any.

        paBegin = paEnd;
        if (paBegin)
        {
            // Check if generic simulations can be used.  If not, we must
            // abandon the rest of the batch.

            if (!(gengc->flags & GENGC_GENERIC_COMPATIBLE_FORMAT) ||
                (gengc->gc.texture.ddtex.levels > 0 &&
                 (gengc->gc.texture.ddtex.flags & DDTEX_GENERIC_FORMAT) == 0))
            {
                goto PA_abandonBatch;
            }

            // If we need to kickback to simulations, now is the time to
            // grab the device lock.  If the lock fails, abandon the rest
            // of the batch.

            {
                __GLbeginMode beginMode = gengc->gc.beginMode;

                // Why save/restore beginMode?
                //
                // The glim_DrawPolyArray function plays with the beginMode
                // value.  However, in delayed locking the MCD state is
                // validated, but the generic state is not properly validated
                // if the lock is not held.  So we need to also play with
                // the beginMode so that the validation code can be called.

                gengc->gc.beginMode = __GL_NOT_IN_BEGIN;

                if (!glsrvLazyGrabSurfaces(gengc, gengc->fsGenLocks))
                {
                    gengc->gc.beginMode = beginMode;
                    goto PA_abandonBatch;
                }

                gengc->gc.beginMode = beginMode;
            }

            // We may need to temporarily reset the viewport adjust values
            // before calling simulations.  If GenMcdResetViewportAdj returns
            // TRUE, the viewport is changed and we need restore later with
            // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }

    if (paBegin)
#endif
    {
        for (pa = paNext = paBegin; pa = paNext; )
        {
            ASSERTOPENGL(/* pa->primType >= GL_POINTS &&  <always true since primType is unsigned> */
                         pa->primType <= GL_POLYGON,
                         "DrawPolyArray: bad primitive type\n");

#ifndef NEW_PARTIAL_PRIM
            if (pa->flags & POLYARRAY_RENDER_PRIMITIVE)
#endif // NEW_PARTIAL_PRIM
            {
                // Rescale colors if necessary.
                if (!gc->vertexToBufferIdentity)
                {
                    RescaleVertexColorsToBuffer(gc, pa);
                }

#ifdef GL_WIN_phong_shading
                if (pa->flags & POLYARRAY_PHONG_DATA_VALID)
                {
                    if (pa->phong->flags & __GL_PHONG_FRONT_FIRST_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_FRONT_FIRST]),
                                        0);
                    if (pa->phong->flags & __GL_PHONG_BACK_FIRST_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_BACK_FIRST]),
                                        1);
                }

                (*afnPolyArrayRender[pa->primType])(gc, pa);

                if (pa->flags & POLYARRAY_PHONG_DATA_VALID)
                {
                    if (pa->phong->flags & __GL_PHONG_FRONT_TRAIL_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_FRONT_TRAIL]),
                                        0);
                    if (pa->phong->flags & __GL_PHONG_BACK_TRAIL_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_BACK_TRAIL]),
                                        1);
                    //Free the pa->phong data-structure
                    GCFREE(gc, pa->phong);
                }
#else
                (*afnPolyArrayRender[pa->primType])(gc, pa);
#endif //GL_WIN_phong_shading
            }

            // Get next pointer first!
            paNext = pa->paNext;
            // Restore color pointer in the vertex buffer!
            PolyArrayRestoreColorPointer(pa);
        }

        // Restore viewport values if needed.
        if (bResetViewportAdj)
        {
            GenMcdResetViewportAdj(gc, VP_NOBIAS);
        }
    }

    return;

PA_abandonBatch:

    if (paBegin)
    {
    // Abandoning the remainder of the batch.  Must reset the color
    // pointers in the remainder of the batch.
    //
    // Note that paBegin must point to the beginning of the chain of
    // unprocessed POLYARRAYs.

        for (pa = paBegin; pa; pa = paNext)
        {
            paNext = pa->paNext;
            PolyArrayRestoreColorPointer(pa);
        }
        __glSetError(GL_OUT_OF_MEMORY);
    }
}

/****************************************************************************/
// Restore color pointer in the vertex buffer!
// However, don't restore the color pointer if it is a RasterPos call.
GLvoid FASTCALL PolyArrayRestoreColorPointer(POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL(!(pa->flags & POLYARRAY_RASTERPOS),
                 "RasterPos unexpected\n");

    // See also glsbResetBuffers.

    // Reset color pointer in output index array
    if (pa->aIndices)
    {
        ASSERTOPENGL((POLYDATA *) pa->aIndices >= pa->pdBuffer0 &&
                     (POLYDATA *) pa->aIndices <= pa->pdBufferMax,
                     "bad index map pointer\n");

        pdLast = (POLYDATA *) (pa->aIndices + pa->nIndices);
        for (pd = (POLYDATA *) pa->aIndices; pd < pdLast; pd++)
            pd->color = &pd->colors[__GL_FRONTFACE];

        ASSERTOPENGL(pd >= pa->pdBuffer0 &&
                     pd <= pa->pdBufferMax + 1,
                     "bad polyarray pointer\n");
    }

    // Reset color pointer in the POLYARRAY structure last!
    ASSERTOPENGL((POLYDATA *) pa >= pa->pdBuffer0 &&
                 (POLYDATA *) pa <= pa->pdBufferMax,
                 "bad polyarray pointer\n");
    ((POLYDATA *) pa)->color = &((POLYDATA *) pa)->colors[__GL_FRONTFACE];
}
/****************************************************************************/
// Compute generic fog value for the poly array.
//
// IN:  eye
// OUT: fog
#ifdef GL_WIN_specular_fog
void FASTCALL PolyArrayComputeFog(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat density, density2neg, end, oneOverEMinusS;
    POLYDATA  *pd, *pdLast;
    __GLfloat fog;
    BOOL bNeedModulate = (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG);

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

    pdLast = pa->pdNextVertex-1;
    switch (gc->state.fog.mode)
    {
    case GL_EXP:
        PERF_CHECK(FALSE, "Uses GL_EXP fog\n");
        density = gc->state.fog.density;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;    // used by clipping code!
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                fog = __GL_POWF(__glE,  density * eyeZ);
            else
                fog = __GL_POWF(__glE, -density * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (fog > __glOne)
                fog = __glOne;

            if (bNeedModulate)
                pd->fog *= fog;
            else
                pd->fog = fog;
        }
        break;
    case GL_EXP2:
        PERF_CHECK(FALSE, "Uses GL_EXP2 fog\n");
        density2neg = gc->state.fog.density2neg;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (fog > __glOne)
                fog = __glOne;

            if (bNeedModulate)
                pd->fog *= fog;
            else
                pd->fog = fog;
        }
        break;
    case GL_LINEAR:
        end = gc->state.fog.end;
        oneOverEMinusS = gc->state.fog.oneOverEMinusS;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                fog = (end + eyeZ) * oneOverEMinusS;
            else
                fog = (end - eyeZ) * oneOverEMinusS;

            // clamp the fog value here
            if (__GL_FLOAT_LTZ(pd->fog))
                fog = __glZero;
            else if (__GL_FLOAT_COMPARE_PONE(pd->fog, >))
                fog = __glOne;

            if (bNeedModulate)
                pd->fog *= fog;
            else
                pd->fog = fog;
        }
        break;
    }
}

#else //GL_WIN_specular_fog

void FASTCALL PolyArrayComputeFog(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat density, density2neg, end, oneOverEMinusS;
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

    pdLast = pa->pdNextVertex-1;
    switch (gc->state.fog.mode)
    {
    case GL_EXP:
        PERF_CHECK(FALSE, "Uses GL_EXP fog\n");
        density = gc->state.fog.density;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;    // used by clipping code!
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                pd->fog = __GL_POWF(__glE,  density * eyeZ);
            else
                pd->fog = __GL_POWF(__glE, -density * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (pd->fog > __glOne)
                pd->fog = __glOne;
        }
        break;
    case GL_EXP2:
        PERF_CHECK(FALSE, "Uses GL_EXP2 fog\n");
        density2neg = gc->state.fog.density2neg;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            pd->fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (pd->fog > __glOne)
                pd->fog = __glOne;
        }
        break;
    case GL_LINEAR:
        end = gc->state.fog.end;
        oneOverEMinusS = gc->state.fog.oneOverEMinusS;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                pd->fog = (end + eyeZ) * oneOverEMinusS;
            else
                pd->fog = (end - eyeZ) * oneOverEMinusS;

            // clamp the fog value here
            if (__GL_FLOAT_LTZ(pd->fog))
                pd->fog = __glZero;
            else if (__GL_FLOAT_COMPARE_PONE(pd->fog, >))
                pd->fog = __glOne;
        }
        break;
    }
}
#endif //GL_WIN_specular_fog

// Apply cheap fog to RGB colors.
//
// IN:  fog, color (front/back)
// OUT: color (front/back)

void FASTCALL PolyArrayCheapFogRGBColor(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat fogColorR, fogColorG, fogColorB;
    POLYDATA  *pd, *pdLast;
    GLboolean bGrayFog;
    GLboolean doFrontColor, doBackColor;

    if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
    {
        ASSERTOPENGL(!(gc->vertex.paNeeds & PANEEDS_BACK_COLOR),
                     "no back color needed when lighting is disabled\n");
    }

    // ASSERT_PRIMITIVE
    if ((unsigned int) pa->primType <= GL_LINE_STRIP)
    {
        doFrontColor = GL_TRUE;
        doBackColor  = GL_FALSE;
    }
    else
    {
        doFrontColor = gc->vertex.paNeeds & PANEEDS_FRONT_COLOR;
        doBackColor  = gc->vertex.paNeeds & PANEEDS_BACK_COLOR;
    }

    pdLast = pa->pdNextVertex-1;
    fogColorR = gc->state.fog.color.r;
    fogColorG = gc->state.fog.color.g;
    fogColorB = gc->state.fog.color.b;
    bGrayFog  = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;

    PERF_CHECK(bGrayFog, "Uses non gray fog color\n");

    if (bGrayFog)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat fog, oneMinusFog, delta;

            /* Get the vertex fog value */
            fog = pd->fog;
            oneMinusFog = __glOne - fog;
            delta = oneMinusFog * fogColorR;

            /* Now whack the color */
            if (doFrontColor)
            {
                pd->colors[0].r = fog * pd->colors[0].r + delta;
                pd->colors[0].g = fog * pd->colors[0].g + delta;
                pd->colors[0].b = fog * pd->colors[0].b + delta;
            }
            if (doBackColor)
            {
                pd->colors[1].r = fog * pd->colors[1].r + delta;
                pd->colors[1].g = fog * pd->colors[1].g + delta;
                pd->colors[1].b = fog * pd->colors[1].b + delta;
            }
        }
    }
    else
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat fog, oneMinusFog;

            /* Get the vertex fog value */
            fog = pd->fog;
            oneMinusFog = __glOne - fog;

            /* Now whack the color */
            if (doFrontColor)
            {
                pd->colors[0].r = fog * pd->colors[0].r + oneMinusFog * fogColorR;
                pd->colors[0].g = fog * pd->colors[0].g + oneMinusFog * fogColorG;
                pd->colors[0].b = fog * pd->colors[0].b + oneMinusFog * fogColorB;
            }
            if (doBackColor)
            {
                pd->colors[1].r = fog * pd->colors[1].r + oneMinusFog * fogColorR;
                pd->colors[1].g = fog * pd->colors[1].g + oneMinusFog * fogColorG;
                pd->colors[1].b = fog * pd->colors[1].b + oneMinusFog * fogColorB;
            }
        }
    }
}


// Apply cheap fog to color index values.
//
// IN:  fog, color.r (front/back)
// OUT: color.r (front/back)

void FASTCALL PolyArrayCheapFogCIColor(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat maxR, fogIndex;
    POLYDATA  *pd, *pdLast;
    GLboolean doFrontColor, doBackColor;

    if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
    {
        ASSERTOPENGL(!(gc->vertex.paNeeds & PANEEDS_BACK_COLOR),
                     "no back color needed when lighting is disabled\n");
    }

    // ASSERT_PRIMITIVE
    if ((unsigned int) pa->primType <= GL_LINE_STRIP)
    {
        doFrontColor = GL_TRUE;
        doBackColor  = GL_FALSE;
    }
    else
    {
        doFrontColor = gc->vertex.paNeeds & PANEEDS_FRONT_COLOR;
        doBackColor  = gc->vertex.paNeeds & PANEEDS_BACK_COLOR;
    }

    fogIndex = gc->state.fog.index;
    maxR = (1 << gc->modes.indexBits) - 1;

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        __GLfloat fogDelta;

        fogDelta = (__glOne - pd->fog) * fogIndex;

        /* Now whack the color */
        if (doFrontColor)
        {
            pd->colors[0].r = pd->colors[0].r + fogDelta;
            if (pd->colors[0].r > maxR)
                pd->colors[0].r = maxR;
        }
        if (doBackColor)
        {
            pd->colors[1].r = pd->colors[1].r + fogDelta;
            if (pd->colors[1].r > maxR)
                pd->colors[1].r = maxR;
        }
    }
}

/****************************************************************************/


/****************************************************************************/
// Compute eye coordinates
//
// IN:  obj
// OUT: eye

void FASTCALL PolyArrayProcessEye(__GLcontext *gc, POLYARRAY *pa)
{
    __GLtransform *trMV;
    __GLmatrix    *m;
    POLYDATA      *pd, *pdLast;

    if (pa->flags & POLYARRAY_EYE_PROCESSED)
        return;

    pa->flags |= POLYARRAY_EYE_PROCESSED;

    trMV = gc->transform.modelView;
    m    = &trMV->matrix;
    pdLast = pa->pdNextVertex-1;

// The primitive may contain a mix of vertex types (2,3,4)!

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
                pd->eye = pd->obj;
    }
    else
    {
        PFN_XFORM     pfnXform;

        // If any incoming coords contains w coord, use xf4.
        if (pa->flags & POLYARRAY_VERTEX4)
                pfnXform = m->xf4;
        else if (pa->flags & POLYARRAY_VERTEX3)
                pfnXform = m->xf3;
        else
                pfnXform = m->xf2;

        for (pd = pa->pd0; pd <= pdLast; pd++)
                (*pfnXform)(&pd->eye, (__GLfloat *) &pd->obj, m);
    }
}

/****************************************************************************/
// Process edge flags.
//
// IN:  edge
// OUT: edge (all vertices)

void FASTCALL PolyArrayProcessEdgeFlag(POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;
    GLuint    prevEdgeFlag;

    PERF_CHECK(FALSE, "Uses edge flags!\n");

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_EDGEFLAG_VALID,
        "need initial edgeflag value\n");

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        if (pd->flags & POLYDATA_EDGEFLAG_VALID)
            prevEdgeFlag = pd->flags & (POLYDATA_EDGEFLAG_VALID | POLYDATA_EDGEFLAG_BOUNDARY);
        else
            pd->flags |= prevEdgeFlag;
    }
}

/****************************************************************************/
// transform texture coordinates
// there is no generated texture coords.
// texture coordinates are modified in place
//
// IN:  texture
// OUT: texture (all vertices are updated)

void FASTCALL PolyArrayCalcTexture(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
                 "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
                 "bad paflags\n");

    m = &gc->transform.texture->matrix;

    pdLast = pa->pdNextVertex-1;
    if (m->matrixType == __GL_MT_IDENTITY)
    {
        // Identity texture xform.
        //Incoming texcoord already has all s,t,q,r values.

        for (pd = pa->pd0; pd <= pdLast; pd++)
            if (!(pd->flags & POLYDATA_TEXTURE_VALID))
                pd->texture = (pd-1)->texture;
    }
    else
    {

        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
            xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
            xf = m->xf3;
        else if (pa->flags & POLYARRAY_TEXTURE2)
            xf = m->xf2;
        else
            xf = m->xf1;

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            // Apply texture matrix
            if (pd->flags & POLYDATA_TEXTURE_VALID)
                (*xf)(&pd->texture, (__GLfloat *) &pd->texture, m);
            else
                pd->texture = (pd-1)->texture;
        }
    }
}

// Generate texture coordinates from object coordinates
// object linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the object linear mode
// both s and t have the SAME plane equation
// texture coordinates are modified in place
//
// IN:  texture, obj
// OUT: texture (all vertices are updated)

void FASTCALL PolyArrayCalcObjectLinearSameST(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

    cs = &gc->state.texture.s.objectPlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (!(pd->flags & POLYDATA_TEXTURE_VALID))
            {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
            }

            // both s and t have the SAME plane equation
            pd->texture.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                            cs->z * pd->obj.z + cs->w * pd->obj.w;
            pd->texture.y = pd->texture.x;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
            xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
            xf = m->xf3;
        else
            xf = m->xf2;        // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (pd->flags & POLYDATA_TEXTURE_VALID)
            {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
            }

            // both s and t have the SAME plane equation
            gen.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                    cs->z * pd->obj.z + cs->w * pd->obj.w;
            gen.y = gen.x;

            // Finally, apply texture matrix
            (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Generate texture coordinates from object coordinates
// object linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the object linear mode
// both s and t have DIFFERENT plane equations
// texture coordinates are modified in place
//
// IN:  texture, obj
// OUT: texture (all vertices are updated)

void FASTCALL PolyArrayCalcObjectLinear(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, *ct, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

    cs = &gc->state.texture.s.objectPlaneEquation;
    ct = &gc->state.texture.t.objectPlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (!(pd->flags & POLYDATA_TEXTURE_VALID))
                {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
                }

                pd->texture.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                                cs->z * pd->obj.z + cs->w * pd->obj.w;
                pd->texture.y = ct->x * pd->obj.x + ct->y * pd->obj.y +
                                ct->z * pd->obj.z + ct->w * pd->obj.w;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
                xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
                xf = m->xf3;
        else
                xf = m->xf2;    // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (pd->flags & POLYDATA_TEXTURE_VALID)
                {
                    gen.z = pd->texture.z;
                    gen.w = pd->texture.w;
                }

                gen.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                        cs->z * pd->obj.z + cs->w * pd->obj.w;
                gen.y = ct->x * pd->obj.x + ct->y * pd->obj.y +
                        ct->z * pd->obj.z + ct->w * pd->obj.w;

                // Finally, apply texture matrix
                (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Generate texture coordinates from eye coordinates
// eye linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the eye linear mode
// both s and t have SAME plane equations
// texture coordinates are modified in place
// we may be able to get away without computing eye coord!
//
// IN:  texture; obj or eye
// OUT: texture and eye (all vertices are updated)

void FASTCALL PolyArrayCalcEyeLinearSameST(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
        PolyArrayProcessEye(gc, pa);

    cs = &gc->state.texture.s.eyePlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (!(pd->flags & POLYDATA_TEXTURE_VALID))
            {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
            }

            // both s and t have the SAME plane equation
            pd->texture.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                            cs->z * pd->eye.z + cs->w * pd->eye.w;
            pd->texture.y = pd->texture.x;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
            xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
            xf = m->xf3;
        else
            xf = m->xf2;        // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (pd->flags & POLYDATA_TEXTURE_VALID)
            {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
            }

            // both s and t have the SAME plane equation
            gen.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                    cs->z * pd->eye.z + cs->w * pd->eye.w;
            gen.y = gen.x;

            // Finally, apply texture matrix
            (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Generate texture coordinates from eye coordinates
// eye linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the eye linear mode
// both s and t have SAME plane equations
// texture coordinates are modified in place
// we may be able to get away without computing eye coord!
//
// IN:  texture; obj or eye
// OUT: texture and eye (all vertices are updated)

void FASTCALL PolyArrayCalcEyeLinear(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, *ct, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
        PolyArrayProcessEye(gc, pa);

    cs = &gc->state.texture.s.eyePlaneEquation;
    ct = &gc->state.texture.t.eyePlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (!(pd->flags & POLYDATA_TEXTURE_VALID))
                {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
                }

                pd->texture.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                                cs->z * pd->eye.z + cs->w * pd->eye.w;
                pd->texture.y = ct->x * pd->eye.x + ct->y * pd->eye.y +
                                ct->z * pd->eye.z + ct->w * pd->eye.w;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
                xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
                xf = m->xf3;
        else
                xf = m->xf2;    // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (pd->flags & POLYDATA_TEXTURE_VALID)
                {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
                }

                gen.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                        cs->z * pd->eye.z + cs->w * pd->eye.w;
                gen.y = ct->x * pd->eye.x + ct->y * pd->eye.y +
                        ct->z * pd->eye.z + ct->w * pd->eye.w;

                // Finally, apply texture matrix
                (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Compute the s & t coordinates for a sphere map.  The s & t values
// are stored in "result" even if both coordinates are not being
// generated.  The caller picks the right values out.
//
// IN:  eye, normal

void FASTCALL PASphereGen(POLYDATA *pd, __GLcoord *result)
{
    __GLcoord u, r;
    __GLfloat m, ndotu;

    // Get unit vector from origin to the vertex in eye coordinates into u
    __glNormalize(&u.x, &pd->eye.x);

    // Dot the normal with the unit position u
    ndotu = pd->normal.x * u.x + pd->normal.y * u.y + pd->normal.z * u.z;

    // Compute r
    r.x = u.x - 2 * pd->normal.x * ndotu;
    r.y = u.y - 2 * pd->normal.y * ndotu;
    r.z = u.z - 2 * pd->normal.z * ndotu;

    // Compute m
    m = 2 * __GL_SQRTF(r.x*r.x + r.y*r.y + (r.z + 1) * (r.z + 1));

    if (m)
    {
        result->x = r.x / m + __glHalf;
        result->y = r.y / m + __glHalf;
    }
    else
    {
        result->x = __glHalf;
        result->y = __glHalf;
    }
}

// Generate texture coordinates for sphere map
// sphere map texture generation
// s and t are enabled but r and q are disabled
// both s and t use the sphere map mode
// texture coordinates are modified in place
// we may be able to get away without computing eye coord!
//
// IN:  texture; obj or eye; normal
// OUT: texture and eye (all vertices are updated)

void FASTCALL PolyArrayCalcSphereMap(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord gen;
    POLYDATA  *pd, *pdLast, *pdNormal;
    PFN_XFORM xf;
    GLboolean bIdentity;

    // this is really okay
    PERF_CHECK(FALSE, "Uses sphere map texture generation!\n");

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_NORMAL_VALID,
        "need initial normal\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
        PolyArrayProcessEye(gc, pa);

    m = &gc->transform.texture->matrix;
    bIdentity = (m->matrixType == __GL_MT_IDENTITY);

    // If any incoming texture coords contains q coord, use xf4.
    if (pa->flags & POLYARRAY_TEXTURE4)
        xf = m->xf4;
    else if (pa->flags & POLYARRAY_TEXTURE3)
        xf = m->xf3;
    else
        xf = m->xf2;    // at least 2 generated values

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        if (pd->flags & POLYDATA_TEXTURE_VALID)
        {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
        }

        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            // track current normal
            pdNormal = pd;
        }
        else
        {
            // pd->flags |= POLYDATA_NORMAL_VALID;
            pd->normal.x = pdNormal->normal.x;
            pd->normal.y = pdNormal->normal.y;
            pd->normal.z = pdNormal->normal.z;
        }

        PASphereGen(pd, &gen);  // compute s, t values

        // Finally, apply texture matrix
        if (!bIdentity)
            (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        else
            pd->texture = gen;
    }
}

// Transform or compute the texture coordinates for the polyarray
// It handles all texture generation modes.  Texture coordinates are
// generated (if necessary) and transformed.
// Note that texture coordinates are modified in place.
//
// IN:  texture (always)
//      obj in GL_OBJECT_LINEAR mode
//      obj or eye in GL_EYE_LINEAR mode
//      obj or eye; normal in GL_SPHERE_MAP mode
// OUT: texture (all vertices are updated)
//      eye in GL_EYE_LINEAR and GL_SPHERE_MAP modes (all vertices
//      are updated)
void FASTCALL PolyArrayCalcMixedTexture(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    GLuint     enables;
    POLYDATA   *pd, *pdLast, *pdNormal;
    PFN_XFORM  xf;
    BOOL       needNormal, didSphereGen;
    __GLcoord  savedTexture, sphereCoord, *c;
    GLboolean  bIdentity;

    enables = gc->state.enables.general;

    PERF_CHECK
    (
        !(enables & (__GL_TEXTURE_GEN_R_ENABLE | __GL_TEXTURE_GEN_Q_ENABLE)),
        "Uses r, q texture generation!\n"
    );

    if ((enables & __GL_TEXTURE_GEN_S_ENABLE)
     && (enables & __GL_TEXTURE_GEN_T_ENABLE)
     && (gc->state.texture.s.mode != gc->state.texture.t.mode))
    {
        PERF_CHECK(FALSE, "Uses different s and t tex gen modes!\n");
    }

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
                 "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
                 "bad paflags\n");

    if ((enables & __GL_TEXTURE_GEN_S_ENABLE) && (gc->state.texture.s.mode == GL_SPHERE_MAP)
     || (enables & __GL_TEXTURE_GEN_T_ENABLE) && (gc->state.texture.t.mode == GL_SPHERE_MAP))
    {
        ASSERTOPENGL(pa->pd0->flags & POLYDATA_NORMAL_VALID,
                     "need initial normal\n");

        needNormal = TRUE;
    }
    else
    {
            needNormal = FALSE;
    }

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
    {
        if ((enables & __GL_TEXTURE_GEN_S_ENABLE)
                && (gc->state.texture.s.mode != GL_OBJECT_LINEAR)
         || (enables & __GL_TEXTURE_GEN_T_ENABLE)
                && (gc->state.texture.t.mode != GL_OBJECT_LINEAR)
         || (enables & __GL_TEXTURE_GEN_R_ENABLE)
                && (gc->state.texture.r.mode != GL_OBJECT_LINEAR)
         || (enables & __GL_TEXTURE_GEN_Q_ENABLE)
                && (gc->state.texture.q.mode != GL_OBJECT_LINEAR))
                PolyArrayProcessEye(gc, pa);
    }

    m = &gc->transform.texture->matrix;
    bIdentity = (m->matrixType == __GL_MT_IDENTITY);

    // If any incoming texture coords contains q coord, use xf4.
    if (pa->flags & POLYARRAY_TEXTURE4 || enables & __GL_TEXTURE_GEN_Q_ENABLE)
        xf = m->xf4;
    else if (pa->flags & POLYARRAY_TEXTURE3 || enables & __GL_TEXTURE_GEN_R_ENABLE)
        xf = m->xf3;
    else if (pa->flags & POLYARRAY_TEXTURE2 || enables & __GL_TEXTURE_GEN_T_ENABLE)
        xf = m->xf2;
    else
        xf = m->xf1;

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        // texture coordinates are modified in place.
        // save the valid values to use for the invalid entries.
        if (pd->flags & POLYDATA_TEXTURE_VALID)
                savedTexture = pd->texture;
        else
                pd->texture = savedTexture;

        if (needNormal)
        {
                if (pd->flags & POLYDATA_NORMAL_VALID)
                {
                // track current normal
                pdNormal = pd;
                }
                else
                {
                // pd->flags |= POLYDATA_NORMAL_VALID;
                pd->normal.x = pdNormal->normal.x;
                pd->normal.y = pdNormal->normal.y;
                pd->normal.z = pdNormal->normal.z;
                }
        }

        didSphereGen = GL_FALSE;

        /* Generate s coordinate */
        if (enables & __GL_TEXTURE_GEN_S_ENABLE)
        {
                if (gc->state.texture.s.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.s.eyePlaneEquation;
                pd->texture.x = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else if (gc->state.texture.s.mode == GL_OBJECT_LINEAR)
                {
                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.s.objectPlaneEquation;
                pd->texture.x = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.s.mode == GL_SPHERE_MAP,
                        "invalide texture s mode");
                PASphereGen(pd, &sphereCoord);  // compute s, t values
                pd->texture.x = sphereCoord.x;
                didSphereGen = GL_TRUE;
                }
        }

        /* Generate t coordinate */
        if (enables & __GL_TEXTURE_GEN_T_ENABLE)
        {
                if (gc->state.texture.t.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.t.eyePlaneEquation;
                pd->texture.y = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else if (gc->state.texture.t.mode == GL_OBJECT_LINEAR)
                {
                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.t.objectPlaneEquation;
                pd->texture.y = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.t.mode == GL_SPHERE_MAP,
                        "invalide texture t mode");
                if (!didSphereGen)
                        PASphereGen(pd, &sphereCoord);  // compute s, t values
                pd->texture.y = sphereCoord.y;
                }
        }

        /* Generate r coordinate */
        if (enables & __GL_TEXTURE_GEN_R_ENABLE)
        {
                if (gc->state.texture.r.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.r.eyePlaneEquation;
                pd->texture.z = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.r.mode == GL_OBJECT_LINEAR,
                        "invalide texture r mode");

                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.r.objectPlaneEquation;
                pd->texture.z = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
        }

        /* Generate q coordinate */
        if (enables & __GL_TEXTURE_GEN_Q_ENABLE)
        {
                if (gc->state.texture.q.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.q.eyePlaneEquation;
                pd->texture.w = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.q.mode == GL_OBJECT_LINEAR,
                        "invalide texture q mode");

                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.q.objectPlaneEquation;
                pd->texture.w = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
        }

        /* Finally, apply texture matrix */
        if (!bIdentity)
                (*xf)(&pd->texture, (__GLfloat *) &pd->texture, m);
    }
}

/****************************************************************************/
// Cache whatever values are possible for the current material and lights.
// This will let us avoid doing these computations for each primitive.
void FASTCALL PolyArrayCalcLightCache(__GLcontext *gc)
{
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLlightSourceMachine *lsm;
    __GLlightSourcePerMaterialMachine *lspmm;
    GLuint face;

    for (face = __GL_FRONTFACE; face <= __GL_BACKFACE; face++) {

        if (face == __GL_FRONTFACE) {
            if (!(gc->vertex.paNeeds & PANEEDS_FRONT_COLOR))
                continue;
            msm = &gc->light.front;
        }
        else {
            if (!(gc->vertex.paNeeds & PANEEDS_BACK_COLOR))
                return;
            msm = &gc->light.back;
        }

        msm->cachedEmissiveAmbient.r = msm->paSceneColor.r;
        msm->cachedEmissiveAmbient.g = msm->paSceneColor.g;
        msm->cachedEmissiveAmbient.b = msm->paSceneColor.b;

        // add invarient per-light per-material cached ambient
        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            lspmm = &lsm->front + face;
            msm->cachedEmissiveAmbient.r += lspmm->ambient.r;
            msm->cachedEmissiveAmbient.g += lspmm->ambient.g;
            msm->cachedEmissiveAmbient.b += lspmm->ambient.b;
        }

        __GL_CLAMP_RGB(msm->cachedNonLit.r,
                       msm->cachedNonLit.g,
                       msm->cachedNonLit.b,
                       gc,
                       msm->cachedEmissiveAmbient.r,
                       msm->cachedEmissiveAmbient.g,
                       msm->cachedEmissiveAmbient.b);
    }
}

/****************************************************************************/
// Apply the accumulated material changes to a vertex
void FASTCALL PAApplyMaterial(__GLcontext *gc, __GLmatChange *mat, GLint face)
{
    __GLmaterialState *ms;
    GLuint changeBits;

    PERF_CHECK(FALSE, "Primitives contain glMaterial calls!\n");

    // Don't modify color materials if they are in effect!

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        changeBits = mat->dirtyBits & ~gc->light.front.colorMaterialChange;
    }
    else
    {
        ms  = &gc->state.light.back;
        changeBits = mat->dirtyBits & ~gc->light.back.colorMaterialChange;
    }

    if (changeBits & __GL_MATERIAL_AMBIENT)
        ms->ambient = mat->ambient;

    if (changeBits & __GL_MATERIAL_DIFFUSE)
        ms->diffuse = mat->diffuse;

    if (changeBits & __GL_MATERIAL_SPECULAR)
        ms->specular = mat->specular;

    if (changeBits & __GL_MATERIAL_EMISSIVE)
    {
        ms->emissive.r = mat->emissive.r * gc->redVertexScale;
        ms->emissive.g = mat->emissive.g * gc->greenVertexScale;
        ms->emissive.b = mat->emissive.b * gc->blueVertexScale;
        ms->emissive.a = mat->emissive.a * gc->alphaVertexScale;
    }

    if (changeBits & __GL_MATERIAL_SHININESS)
        ms->specularExponent = mat->shininess;

    if (changeBits & __GL_MATERIAL_COLORINDEXES)
    {
        ms->cmapa = mat->cmapa;
        ms->cmapd = mat->cmapd;
        ms->cmaps = mat->cmaps;
    }

    // Re-calculate the precomputed values.  This works for RGBA and CI modes.

    if (face == __GL_FRONTFACE)
        __glValidateMaterial(gc, (GLint) changeBits, 0);
    else
        __glValidateMaterial(gc, 0, (GLint) changeBits);

// Recompute cached RGB material values:

    PolyArrayCalcLightCache(gc);
}

void FASTCALL PolyArrayApplyMaterials(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatChange matChange, *pdMat;
    GLuint        matMask;
    POLYDATA      *pd, *pdN;
    GLint         face;
    POLYMATERIAL  *pm;

    pm = GLTEB_CLTPOLYMATERIAL();

    // Need to apply material changes defined after the last vertex!

    pdN = pa->pdNextVertex;

    // ASSERT_FACE
    for (face = __GL_BACKFACE, matMask = POLYARRAY_MATERIAL_BACK;
         face >= 0;
         face--,   matMask = POLYARRAY_MATERIAL_FRONT
        )
    {
        if (!(pa->flags & matMask))
            continue;

        // Accumulate all changes into one material change record
        // We need to process (n + 1) vertices for material changes!

        matChange.dirtyBits = 0;
        for (pd = pa->pd0; pd <= pdN; pd++)
        {
            // ASSERT_MATERIAL
            if (pd->flags & matMask)
            {
                GLuint dirtyBits;

                pdMat = *(&pm->pdMaterial0[pd - pa->pdBuffer0].front + face);
                dirtyBits  = pdMat->dirtyBits;
                matChange.dirtyBits |= dirtyBits;

                if (dirtyBits & __GL_MATERIAL_AMBIENT)
                    matChange.ambient = pdMat->ambient;

                if (dirtyBits & __GL_MATERIAL_DIFFUSE)
                    matChange.diffuse = pdMat->diffuse;

                if (dirtyBits & __GL_MATERIAL_SPECULAR)
                    matChange.specular = pdMat->specular;

                if (dirtyBits & __GL_MATERIAL_EMISSIVE)
                    matChange.emissive = pdMat->emissive;

                if (dirtyBits & __GL_MATERIAL_SHININESS)
                    matChange.shininess = pdMat->shininess;

                if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
                {
                    matChange.cmapa = pdMat->cmapa;
                    matChange.cmapd = pdMat->cmapd;
                    matChange.cmaps = pdMat->cmaps;
                }
            }
        }

        // apply material changes for this face
        PAApplyMaterial(gc, &matChange, face);
    }
}

/****************************************************************************/
#ifndef __GL_ASM_POLYARRAYFILLINDEX0
// Fill the index values with 0
//
// IN:  none
// OUT: colors[face].r (all vertices are updated)

void FASTCALL PolyArrayFillIndex0(__GLcontext *gc, POLYARRAY *pa, GLint face)
{
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL((GLuint) face <= 1, "bad face value\n");

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        pd->colors[face].r = __glZero;
    }
}
#endif // __GL_ASM_POLYARRAYFILLINDEX0

#ifndef __GL_ASM_POLYARRAYFILLCOLOR0
// Fill the color values with 0,0,0,0
//
// IN:  none
// OUT: colors[face] (all vertices are updated)

void FASTCALL PolyArrayFillColor0(__GLcontext *gc, POLYARRAY *pa, GLint face)
{
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL((GLuint) face <= 1, "bad face value\n");

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        pd->colors[face].r = __glZero;
        pd->colors[face].g = __glZero;
        pd->colors[face].b = __glZero;
        pd->colors[face].a = __glZero;
    }
}
#endif // __GL_ASM_POLYARRAYFILLCOLOR0

#ifndef __GL_ASM_POLYARRAYPROPAGATESAMECOLOR
// All vertices have the same color values.
// Clamp and scale the current color using the color buffer scales.
// From here on out the colors in the vertex are in their final form.
//
// Note: The first vertex must have a valid color!
//       Back color is not needed when lighting is disabled.
//
// IN:  color (front)
// OUT: color (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateSameColor(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;
    __GLfloat r, g, b, a;

    pdLast = pa->pdNextVertex-1;
    pd = pa->pd0;
    if (pd > pdLast)
        return;

    ASSERTOPENGL(pd->flags & POLYDATA_COLOR_VALID, "no initial color\n");

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        __GL_CLAMP_RGBA(pd->colors[0].r,
                        pd->colors[0].g,
                        pd->colors[0].b,
                        pd->colors[0].a,
                        gc,
                        pd->colors[0].r,
                        pd->colors[0].g,
                        pd->colors[0].b,
                        pd->colors[0].a);
    }

    r = pd->colors[0].r;
    g = pd->colors[0].g;
    b = pd->colors[0].b;
    a = pd->colors[0].a;

    for (pd = pd + 1 ; pd <= pdLast; pd++)
    {
        pd->colors[0].r = r;
        pd->colors[0].g = g;
        pd->colors[0].b = b;
        pd->colors[0].a = a;
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATESAMECOLOR

#ifndef __GL_ASM_POLYARRAYPROPAGATESAMEINDEX
// All vertices have the same index values.
// Mask the index values befor color clipping
// SGIBUG: The sample implementation fails to do this!
//
// Note: The first vertex must have a valid color index!
//       Back color is not needed when lighting is disabled.
//
// IN:  color.r (front)
// OUT: color.r (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateSameIndex(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;
    __GLfloat index;

    pdLast = pa->pdNextVertex-1;
    pd = pa->pd0;
    if (pd > pdLast)
        return;

    ASSERTOPENGL(pd->flags & POLYDATA_COLOR_VALID, "no initial color index\n");

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        __GL_CLAMP_CI(pd->colors[0].r, gc, pd->colors[0].r);
    }

    index = pd->colors[0].r;

    for (pd = pd + 1; pd <= pdLast; pd++)
    {
        pd->colors[0].r = index;
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATESAMEINDEX

#ifndef __GL_ASM_POLYARRAYPROPAGATEINDEX

// Propagate the valid CI colors through the vertex buffer.
//
// IN:  color.r (front)
// OUT: color.r (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateIndex(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        pdLast = pa->pdNextVertex-1;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (!(pd->flags & POLYDATA_COLOR_VALID))
            {
                // If color has not changed for this vertex,
                // use the previously computed color.

                ASSERTOPENGL(pd != pa->pd0, "no initial color index\n");
                pd->colors[0].r = (pd-1)->colors[0].r;
                continue;
            }

            __GL_CLAMP_CI(pd->colors[0].r, gc, pd->colors[0].r);

        }
    } else {
        // If all incoming vertices have valid colors, we are done.
        if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
            && (pa->pdCurColor != pa->pd0)
            // Need to test 2nd vertex because pdCurColor may have been
            // advanced as a result of combining Color command after End
            && ((pa->pd0 + 1)->flags & POLYDATA_COLOR_VALID))
          ;
        else
        {
            pdLast = pa->pdNextVertex-1;
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                if (!(pd->flags & POLYDATA_COLOR_VALID))
                {
                    // If color has not changed for this vertex,
                    // use the previously computed color.

                    ASSERTOPENGL(pd != pa->pd0, "no initial color index\n");
                    pd->colors[0].r = (pd-1)->colors[0].r;
                }
            }
        }
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATEINDEX

#ifndef __GL_ASM_POLYARRAYPROPAGATECOLOR

// Propagate the valid RGBA colors through the vertex buffer.
//
// IN:  color (front)
// OUT: color (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateColor(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        pdLast = pa->pdNextVertex-1;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {

            if (!(pd->flags & POLYDATA_COLOR_VALID))
            {
                // If color has not changed for this vertex,
                // use the previously computed color.

                ASSERTOPENGL(pd != pa->pd0, "no initial color\n");
                pd->colors[0] = (pd-1)->colors[0];
                continue;
            }

            __GL_CLAMP_RGBA(pd->colors[0].r,
                            pd->colors[0].g,
                            pd->colors[0].b,
                            pd->colors[0].a,
                            gc,
                            pd->colors[0].r,
                            pd->colors[0].g,
                            pd->colors[0].b,
                            pd->colors[0].a);
        }
    } else {
        // If all incoming vertices have valid colors, we are done.
        if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
            && (pa->pdCurColor != pa->pd0)
            // Need to test 2nd vertex because pdCurColor may have been
            // advanced as a result of combining Color command after End
            && ((pa->pd0 + 1)->flags & POLYDATA_COLOR_VALID))
          ;
        else
        {
            pdLast = pa->pdNextVertex-1;
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                if (!(pd->flags & POLYDATA_COLOR_VALID))
                {
                    // If color has not changed for this vertex,
                    // use the previously computed color.

                    ASSERTOPENGL(pd != pa->pd0, "no initial color\n");
                    pd->colors[0] = (pd-1)->colors[0];
                }
            }
        }
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATECOLOR

/****************************************************************************/
#if 0
//!!! remove this
// do we need clip?
// need __GL_HAS_FOG bit for line and polygon clipping!
// The boundaryEdge field is initialized in the calling routine.
#define PA_STORE_PROCESSED_POLYGON_VERTEX(v,pd,bits)                        \
        {                                                                   \
            (v)->clip = (pd)->clip;                                         \
            (v)->window = (pd)->window;                                     \
            (v)->eye.z = (pd)->eye.z; /* needed by slow fog */              \
            (v)->fog = (pd)->fog; /* needed by cheap fog in flat shading */ \
            (v)->texture.x = (pd)->texture.x;                               \
            (v)->texture.y = (pd)->texture.y;                               \
            (v)->texture.z = (pd)->texture.z; /* z is needed by feedback! */\
            (v)->texture.w = (pd)->texture.w;                               \
            (v)->color = &(pd)->color;                                      \
            (v)->clipCode = (pd)->clipCode;                                 \
            (v)->has = bits;                                                \
        }

// need eye if there is eyeClipPlanes
// need texture if there is texture
// need __GL_HAS_FOG bit for line and polygon clipping!
#define PA_STORE_PROCESSED_LINE_VERTEX(v,pd,bits)                           \
        {                                                                   \
            (v)->clip = (pd)->clip;                                         \
            (v)->window = (pd)->window;                                     \
            (v)->eye.z = (pd)->eye.z; /* needed by slow fog */              \
            (v)->fog = (pd)->fog; /* needed by cheap fog in flat shading */ \
            (v)->texture.x = (pd)->texture.x;                               \
            (v)->texture.y = (pd)->texture.y;                               \
            (v)->texture.z = (pd)->texture.z; /* z is needed by feedback! */\
            (v)->texture.w = (pd)->texture.w;                               \
            (v)->colors[__GL_FRONTFACE] = (pd)->color;                      \
            (v)->clipCode = (pd)->clipCode;                                 \
            (v)->has = bits;                                                \
        }

// need eye if antialised is on
// need texture if there is texture
#define PA_STORE_PROCESSED_POINT_VERTEX(v,pd,bits)                          \
        {                                                                   \
            (v)->window = (pd)->window;                                     \
            (v)->eye.z = (pd)->eye.z; /* needed by slow fog */              \
            (v)->fog = (pd)->fog; /* needed by cheap fog in flat shading */ \
            (v)->clip.w = (pd)->clip.w; /* needed by feedback! */           \
            (v)->texture.x = (pd)->texture.x;                               \
            (v)->texture.y = (pd)->texture.y;                               \
            (v)->texture.z = (pd)->texture.z; /* z is needed by feedback! */\
            (v)->texture.w = (pd)->texture.w;                               \
            (v)->color = &(pd)->color;                                      \
            (v)->has = bits;                                                \
        }
#endif // 0

// ---------------------------------------------------------
// The primitive is clipped.
void FASTCALL PARenderPoint(__GLcontext *gc, __GLvertex *v)
{
    if (v->clipCode == 0)
        (*gc->procs.renderPoint)(gc, v);
}

// ---------------------------------------------------------
// The primitive is clipped.
void FASTCALL PARenderLine(__GLcontext *gc, __GLvertex *v0,
                           __GLvertex *v1, GLuint flags)
{
    if (v0->clipCode | v1->clipCode)
    {
        /*
         * The line must be clipped more carefully.  Cannot
         * trivially accept the lines.
         *
         * If anding the codes is non-zero then every vertex
         * in the line is outside of the same set of clipping
         * planes (at least one).  Trivially reject the line.
         */
        if ((v0->clipCode & v1->clipCode) == 0)
            __glClipLine(gc, v0, v1, flags);
    }
    else
    {
        // Line is trivially accepted so render it
        (*gc->procs.renderLine)(gc, v0, v1, flags);
    }
}
// ---------------------------------------------------------
// The primitive is clipped.
void FASTCALL PARenderTriangle(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2)
{
    GLuint orCodes;

    /* Clip check */
    orCodes = v0->clipCode | v1->clipCode | v2->clipCode;
    if (orCodes)
    {
        /* Some kind of clipping is needed.
         *
         * If anding the codes is non-zero then every vertex
         * in the triangle is outside of the same set of
         * clipping planes (at least one).  Trivially reject
         * the triangle.
         */
        if (!(v0->clipCode & v1->clipCode & v2->clipCode))
            (*gc->procs.clipTriangle)(gc, v0, v1, v2, orCodes);
    }
    else
    {
        (*gc->procs.renderTriangle)(gc, v0, v1, v2);
    }
}

// ---------------------------------------------------------
// The primitive is not clipped.
void PARenderQuadFast(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3)
{
    // Vertex ordering is important.  Line stippling uses it.
    // SGIBUG: The sample implementation does it wrong.

    GLuint savedTag;

    /* Render the quad as two triangles */
    savedTag = v2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
    v2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
    (*gc->procs.renderTriangle)(gc, v0, v1, v2);
    v2->has |= savedTag;
    savedTag = v0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
    v0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
    (*gc->procs.renderTriangle)(gc, v2, v3, v0);
    v0->has |= savedTag;
}

// ---------------------------------------------------------
// The primitive is clipped.
void PARenderQuadSlow(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3)
{
    GLuint orCodes;

    orCodes = v0->clipCode | v1->clipCode | v2->clipCode | v3->clipCode;

    if (orCodes)
    {
        /* Some kind of clipping is needed.
         *
         * If anding the codes is non-zero then every vertex
         * in the quad is outside of the same set of
         * clipping planes (at least one).  Trivially reject
         * the quad.
         */
        if (!(v0->clipCode & v1->clipCode & v2->clipCode & v3->clipCode))
        {
            /* Clip the quad as a polygon */
            __GLvertex *iv[4];

            iv[0] = v0;
            iv[1] = v1;
            iv[2] = v2;
            iv[3] = v3;
            __glDoPolygonClip(gc, &iv[0], 4, orCodes);
        }
    }
    else
    {
        PARenderQuadFast(gc, v0, v1, v2, v3);
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM

void FASTCALL PolyArrayDrawPoints(__GLcontext *gc, POLYARRAY *pa)
{
// Index mapping is always identity in Points.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    // Assert that pa->nIndices is correct
    ASSERTOPENGL(pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderPoints later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderPoints(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, nIndices;
    POLYDATA   *pd0;
    void (FASTCALL *rp)(__GLcontext *gc, __GLvertex *v);

// Index mapping is always identity in Points.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    nIndices = pa->nIndices;
    pd0      = pa->pd0;
    rp = pa->orClipCodes ? PARenderPoint : gc->procs.renderPoint;

    // Identity mapping
    for (i = 0; i < nIndices; i++)
        /* Render the point */
        (*rp)(gc, (__GLvertex *) &pd0[i]);
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawLines(__GLcontext *gc, POLYARRAY *pa)
{
    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderLines later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif //NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderLines(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast2;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_LINE rl;
    GLuint     modeFlags;

    iLast2 = pa->nIndices - 2;
    pd0    = pa->pd0;
    rl = pa->orClipCodes ? PARenderLine : gc->procs.renderLine;

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        modeFlags = gc->polygon.shader.modeFlags;
        gc->polygon.shader.modeFlags &= ~__GL_SHADE_SMOOTH;
    }

    (*gc->procs.lineBegin)(gc);

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        for (i = 0; i <= iLast2; i += 2)
        {
            /* setup for rendering this line */
            gc->line.notResetStipple = GL_FALSE;

            (*rl)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1], __GL_LVERT_FIRST);
        }
    }
    else
    {
        for (i = 0; i <= iLast2; i += 2)
        {
            /* setup for rendering this line */
            gc->line.notResetStipple = GL_FALSE;

            (*rl)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]], __GL_LVERT_FIRST);
        }
    }

    (*gc->procs.lineEnd)(gc);

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        gc->polygon.shader.modeFlags = modeFlags;
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawLLoop(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    POLYDATA   *pd, *pd0;

// Index mapping is always identity in Line Loop.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

// A line loop is the same as a line strip except that a final segment is
// added from the final specified vertex to the first vertex.  We will
// convert the line loop into a strip here.

    nIndices = pa->nIndices;

// If we are continuing with a previously decomposed line loop, we need to
// connect the last vertex of the previous primitive and the first vertex
// of the current primitive with a line segment.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_RESET_STIPPLE),
                "bad stipple reset flag!\n");

        // Insert previous end vertex at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
    }
    else
    {
// New line loop.

        ASSERTOPENGL(pa->flags & POLYARRAY_RESET_STIPPLE,
            "bad stipple reset flag!\n");

// At least two vertices must be given for anything to occur.
// An extra vertex was added to close the loop.

        if (nIndices < 3)
        {
                ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                         "Partial end with insufficient vertices\n");
                pa->nIndices--;
                goto DrawLLoop_end;
        }
    }

    pd0 = pa->pd0;

// If the primitive is only partially complete, save the last vertex for
// next batch.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd = &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);

// Save the the original first vertex for closing the loop later.

        if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
                PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd0);

// Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
                goto DrawLLoop_end;
#endif
    }
    else
    {
        POLYDATA *pdOrigin;

// Insert the original first vertex to close the loop and update clip code.

        if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
                pdOrigin = &gc->vertex.pdSaved[1];
        else
                pdOrigin = pd0;

        pd = pa->pdNextVertex++;
        ASSERTOPENGL(pd <= pa->pdBufferMax, "vertex overflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, pdOrigin);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
    }

    // Assert that pa->nIndices is correct
    ASSERTOPENGL(pa->nIndices == pa->pdNextVertex - pa->pd0,
        "bad nIndices\n");

// Render the line strip.

    // Call PolyArrayRenderLStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
DrawLLoop_end:
    // Change primitive type to line strip!
    pa->primType = GL_LINE_STRIP;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderLStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_LINE rl;
    GLuint     modeFlags;

// Render the line strip.

    iLast = pa->nIndices - 1;
    pd0   = pa->pd0;
    rl = pa->orClipCodes ? PARenderLine : gc->procs.renderLine;
    if (iLast <= 0)
        return;

// Reset the line stipple if this is a new strip.

    if (pa->flags & POLYARRAY_RESET_STIPPLE)
        gc->line.notResetStipple = GL_FALSE;

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        modeFlags = gc->polygon.shader.modeFlags;
        gc->polygon.shader.modeFlags &= ~__GL_SHADE_SMOOTH;
    }

    (*gc->procs.lineBegin)(gc);

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Add first line segment (NOTE: 0, 1)
        (*rl)(gc, (__GLvertex *) &pd0[0],
                  (__GLvertex *) &pd0[1], __GL_LVERT_FIRST);

        // Add subsequent line segments (NOTE: i, i+1)
        for (i = 1; i < iLast; i++)
            (*rl)(gc, (__GLvertex *) &pd0[i  ],
                      (__GLvertex *) &pd0[i+1], 0);
    }
    else
    {
        // Add first line segment (NOTE: 0, 1)
        (*rl)(gc, (__GLvertex *) &pd0[aIndices[0]],
                  (__GLvertex *) &pd0[aIndices[1]], __GL_LVERT_FIRST);

        // Add subsequent line segments (NOTE: i, i+1)
        for (i = 1; i < iLast; i++)
            (*rl)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                      (__GLvertex *) &pd0[aIndices[i+1]], 0);
    }

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        gc->polygon.shader.modeFlags = modeFlags;
    }

    (*gc->procs.lineEnd)(gc);
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawLStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

// If we are continuing with a previously decomposed line strip, we need to
// connect the last vertex of the previous primitive and the first vertex
// of the current primitive with a line segment.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_RESET_STIPPLE),
            "bad stipple reset flag!\n");

        // Insert previous end vertex at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0, "bad index mapping\n");
    }
    else
    {
// New line strip.

        ASSERTOPENGL(pa->flags & POLYARRAY_RESET_STIPPLE,
            "bad stipple reset flag!\n");
    }

// At least two vertices must be given for anything to occur.

    if (nIndices < 2)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

// If the primitive is only partially complete, save the last vertex for
// next batch.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);

// Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
                return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
        "bad nIndices\n");

// Render the line strip.

    // Call PolyArrayRenderLStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}

// ---------------------------------------------------------
void FASTCALL PolyArrayDrawTriangles(__GLcontext *gc, POLYARRAY *pa)
{
    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderTriangles later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderTriangles(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast3;
    GLubyte    *aIndices, *aIndicesEnd;
    POLYDATA   *pd0;
    __GLvertex *provoking;
    PFN_RENDER_TRIANGLE rt;

// Vertex ordering is important.  Line stippling uses it.
// SGIBUG: The sample implementation does it wrong.

    iLast3 = pa->nIndices - 3;
    pd0    = pa->pd0;
    rt = pa->orClipCodes ? PARenderTriangle : gc->procs.renderTriangle;

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        for (i = 0; i <= iLast3; i += 3)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+2];

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+2]);
        }
    }
    else
    {
#if 0
        for (i = 0; i <= iLast3; i += 3)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+2]];

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                      (__GLvertex *) &pd0[aIndices[i+1]],
                      (__GLvertex *) &pd0[aIndices[i+2]]);
        }
#else
    aIndicesEnd = aIndices+iLast3;
    while (aIndices <= aIndicesEnd)
    {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            provoking = PD_VERTEX(pd0, aIndices[2]);
            gc->vertex.provoking = provoking;

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, PD_VERTEX(pd0, aIndices[0]),
                      PD_VERTEX(pd0, aIndices[1]),
                      provoking);
            aIndices += 3;
        }
#endif
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawTStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

    // If we are continuing with a previously decomposed triangle strip,
    // we need to start from the last two vertices of the previous primitive.
    //
    // Note that the flush vertex ensures that the continuing triangle strip
    // is in the default orientation so that it can fall through the normal
    // code.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        // Insert previous end vertices at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[1] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[1] == 1, "bad index mapping\n");

        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0, "bad index mapping\n");
    }

// Need at least 3 vertices.

    if (nIndices < 3)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete,
    // save the last two vertices for next batch.
#ifdef GL_WIN_phong_shading
    // !!If phong shaded, also save the current material parameters.
    // No need, since in Phong shading, I am throwing away all glMaterial
    // calls between glBegin/glEnd. If it is a PARTIAL_PRIMITIVE, then
    // there were no material changes (except ColorMaterial) immediately
    // before.
#endif //GL_WIN_phong_shading
    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-2]] : &pd0[nIndices-2];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the triangle strip.

    // Call PolyArrayRenderTStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif //NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderTStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast3;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_TRIANGLE rt;

    iLast3 = pa->nIndices - 3;
    pd0    = pa->pd0;
    rt = pa->orClipCodes ? PARenderTriangle : gc->procs.renderTriangle;
    if (iLast3 < 0)
        return;

    // Vertex ordering is important.  Line stippling uses it.

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Initialize first 2 vertices so we can start rendering the strip
        // below.  The edge flags are not modified by our lower level
        // routines.
        pd0[0].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast3; )
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+2];
            pd0[i+2].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+2]);
            i++;

            if (i > iLast3)
              break;

            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+2];
            pd0[i+2].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i+1, i, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[i+1],
                  (__GLvertex *) &pd0[i  ],
            (__GLvertex *) &pd0[i+2]);
            i++;
        }
    }
    else
    {
        // Initialize first 2 vertices so we can start rendering the strip
        // below.  The edge flags are not modified by our lower level routines.
        pd0[aIndices[0]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[aIndices[1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast3; )
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+2]];
            pd0[aIndices[i+2]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]],
            (__GLvertex *) &pd0[aIndices[i+2]]);
            i++;

            if (i > iLast3)
              break;

            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+2]];
            pd0[aIndices[i+2]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i+1, i, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[aIndices[i+1]],
                  (__GLvertex *) &pd0[aIndices[i  ]],
            (__GLvertex *) &pd0[aIndices[i+2]]);
            i++;
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawTFan(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

    // If we are continuing with a previously decomposed triangle fan,
    // we need to connect the last vertex of the previous primitive and the
    // first vertex of the current primitive with a triangle.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        // Insert previous end vertex at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[1] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[1] == 1, "bad index mapping\n");

        // Insert the origin first vertex at the beginning and update
        // clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0, "bad index mapping\n");
    }

    // Need at least 3 vertices.

    if (nIndices < 3)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete, save the last vertex
    // for next batch.  Also save the original first vertex of the triangle
    // fan.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);

        if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
        {
            pd = aIndices ? &pd0[aIndices[0]] : &pd0[0];
            PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);
        }

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the triangle fan.

    // Call PolyArrayRenderTFan later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderTFan(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast2;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_TRIANGLE rt;

    iLast2 = pa->nIndices - 2;
    pd0    = pa->pd0;
    rt = pa->orClipCodes ? PARenderTriangle : gc->procs.renderTriangle;
    if (iLast2 <= 0)
        return;

    // Vertex ordering is important.  Line stippling uses it.
    // SGIBUG: The sample implementation does it wrong.

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Initialize first 2 vertices so we can start rendering the tfan
        // below.  The edge flags are not modified by our lower level routines.
        pd0[0].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 1; i <= iLast2; i++)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+1];
            pd0[i+1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: 0, i, i+1) */
            (*rt)(gc, (__GLvertex *) &pd0[0  ],
                  (__GLvertex *) &pd0[i  ],
            (__GLvertex *) &pd0[i+1]);
        }
    }
    else
    {
        POLYDATA *pdOrigin;

        // Initialize first 2 vertices so we can start rendering the tfan
        // below.  The edge flags are not modified by our lower level
        // routines.
        pd0[aIndices[0]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[aIndices[1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        pdOrigin = &pd0[aIndices[0]];
        for (i = 1; i <= iLast2; i++)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+1]];
            pd0[aIndices[i+1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: 0, i, i+1) */
            (*rt)(gc, (__GLvertex *) pdOrigin,
                  (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]]);
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawQuads(__GLcontext *gc, POLYARRAY *pa)
{
    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderQuad later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderQuads(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast4;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    void (*rq)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2,
               __GLvertex *v3);

    // Vertex ordering is important.  Line stippling uses it.

    iLast4 = pa->nIndices - 4;
    pd0    = pa->pd0;
    rq = pa->orClipCodes ? PARenderQuadSlow : PARenderQuadFast;

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        for (i = 0; i <= iLast4; i += 4)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+3];

            /* Render the quad (NOTE: i, i+1, i+2, i+3) */
            (*rq)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+2],
                  (__GLvertex *) &pd0[i+3]);
        }
    }
    else
    {
        for (i = 0; i <= iLast4; i += 4)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+3]];

            /* Render the quad (NOTE: i, i+1, i+2, i+3) */
            (*rq)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]],
            (__GLvertex *) &pd0[aIndices[i+2]],
                  (__GLvertex *) &pd0[aIndices[i+3]]);
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawQStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

    // If we are continuing with a previously decomposed quad strip, we need
    // to start from the last two vertices of the previous primitive.
    //
    // Note that the flush vertex ensures that the continuing quad strip
    // starts at an odd vertex so that it can fall through the normal code.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        // Insert previous end vertices at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[1] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[1] == 1,
                     "bad index mapping\n");

        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0,
                     "bad index mapping\n");
    }

    // Need at least 4 vertices.

    if (nIndices < 4)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete, save the last two
    // vertices for next batch.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-2]] : &pd0[nIndices-2];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the quad strip.

    // Call PolyArrayRenderQStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderQStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast4;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    void (*rq)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2,
               __GLvertex *v3);

    iLast4 = pa->nIndices - 4;
    pd0    = pa->pd0;
    rq = pa->orClipCodes ? PARenderQuadSlow : PARenderQuadFast;
    if (iLast4 < 0)
        return;

    // Vertex ordering is important.  Line stippling uses it.

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Initialize first 2 vertices so we can start rendering the quad
        // below. The edge flags are not modified by our lower level routines.
        pd0[0].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast4; i += 2)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+3];
            pd0[i+2].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
            pd0[i+3].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the quad (NOTE: i, i+1, i+3, i+2) */
            (*rq)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+3],
                  (__GLvertex *) &pd0[i+2]);
        }
    }
    else
    {
        // Initialize first 2 vertices so we can start rendering the quad
        // below.  The edge flags are not modified by our lower level routines.
        pd0[aIndices[0]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[aIndices[1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast4; i += 2)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+3]];
            pd0[aIndices[i+2]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
            pd0[aIndices[i+3]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the quad (NOTE: i, i+1, i+3, i+2) */
            (*rq)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]],
            (__GLvertex *) &pd0[aIndices[i+3]],
                  (__GLvertex *) &pd0[aIndices[i+2]]);
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawPolygon(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    POLYDATA   *pd, *pd0;

    // Index mapping is always identity in Polygon.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    nIndices = pa->nIndices;

    // If we are continuing with a previously decomposed polygon, we need to
    // insert the original first vertex and the last two vertices of the
    // previous polygon at the beginning of the current batch(see note below).
    // The decomposer expects the polygon vertices to be in sequential memory
    // order.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_RESET_STIPPLE),
                     "bad stipple reset flag!\n");

        // Insert previous end vertices at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[2]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif

        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif

        // Insert the origin first vertex at the beginning and update clip
        // code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
    }
    else
    {
      // New polygon.

      ASSERTOPENGL(pa->flags & POLYARRAY_RESET_STIPPLE,
                   "bad stipple reset flag!\n");
    }

// Need at least 3 vertices.

    if (nIndices < 3)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_BEGIN),
                     "Partial begin with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete, save the last 2 vertices
    // for next batch.  Also save the original first vertex of the polygon.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        // Since there may be no vertex following this partial primitive, we
        // cannot determine the edge flag of the last vertex in this batch.
        // So we save the last vertex for next batch instead.

        pd0 = pa->pd0;
        pd  = &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[2], pd);

        // Remove the last vertex from this partial primitive
        nIndices = --pa->nIndices;
        pa->pdNextVertex--;

        // Mark the closing edge of this decomposed polygon as non-boundary
        // because we are synthetically generating it.

        pd--;
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);
        pd->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;

        if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
        {
            PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd0);

            // Mark the first polygon vertex's edge tag as non-boundary
            // because when it gets rendered again it will no longer be
            // a boundary edge.
            gc->vertex.pdSaved[0].flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
        }

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // The polygon clipper can only handle this many vertices.
    ASSERTOPENGL(nIndices <= __GL_MAX_POLYGON_CLIP_SIZE,
                 "too many points for the polygon clipper!\n");

    // Assert that pa->nIndices is correct
    ASSERTOPENGL(pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the polygon.

    // Call PolyArrayRenderPolygon later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderPolygon(__GLcontext *gc, POLYARRAY *pa)
{
    // Index mapping is always identity in Polygon.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    // Reset the line stipple if this is a new polygon.

    if (pa->flags & POLYARRAY_RESET_STIPPLE)
        gc->line.notResetStipple = GL_FALSE;

    // Note that the provoking vertex is set to pd0 in clipPolygon

    (*gc->procs.clipPolygon)(gc, (__GLvertex *) pa->pd0, pa->nIndices);
}

/****************************************************************************/
// Note: The first vertex must have a valid normal!
//
// IN:  obj/eye, normal
// OUT: eye, color.r (front or back depending on face) (all vertices are
//      updated)

void FASTCALL PolyArrayCalcCIColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourceMachine *lsm;
    __GLmaterialState *ms;
    __GLmaterialMachine *msm;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat si, di;
    POLYDATA  *pd;
    GLfloat   redMaxF;
    GLint     redMaxI;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog

    PERF_CHECK(FALSE, "Uses slow lights\n");

    zero = __glZero;

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
    }

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    localViewer = gc->state.light.model.localViewer;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;

// Eye coord should have been processed

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

// NOTE: the following values may be re-used in the next iteration:
//       nxi, nyi, nzi

    for (pd = pdFirst; pd <= pdLast; pd++)
    {
        __GLfloat ci;

        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            if (face == __GL_FRONTFACE)
            {
            nxi = pd->normal.x;
            nyi = pd->normal.y;
            nzi = pd->normal.z;
            }
            else
            {
            nxi = -pd->normal.x;
            nyi = -pd->normal.y;
            nzi = -pd->normal.z;
            }
        }
        else
        {
            // use previous normal (nxi, nyi, nzi)!
#ifdef GL_WIN_specular_fog
            // use previous fog (fog)!
#endif  //GL_WIN_specular_fog
            ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
        }

        si = zero;
        di = zero;
        eyeWIsZero = __GL_FLOAT_EQZ(pd->eye.w);
#ifdef GL_WIN_specular_fog
        // Initialize Fog value to 0 here;
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            ASSERTOPENGL (face == __GL_FRONTFACE,
                          "Specular fog works for only GL_FRONT\n");
            fog = __glZero;
        }
#endif //GL_WIN_specular_fog


        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            if (lsm->slowPath || eyeWIsZero)
            {
                __GLfloat n1, n2, att, attSpot;
                __GLcoord vPliHat, vPli, hHat, vPeHat;
                __GLfloat hv[3];

                /* Compute vPli, hi (normalized) */
                __glVecSub4(&vPli, &pd->eye, &lsm->position);
                __glNormalize(&vPliHat.x, &vPli.x);
                if (localViewer)
                {
                    __glVecSub4(&vPeHat, &pd->eye, &Pe);
                    __glNormalize(&vPeHat.x, &vPeHat.x);
                    hv[0] = vPliHat.x + vPeHat.x;
                    hv[1] = vPliHat.y + vPeHat.y;
                    hv[2] = vPliHat.z + vPeHat.z;
                }
                else
                {
                    hv[0] = vPliHat.x;
                    hv[1] = vPliHat.y;
                    hv[2] = vPliHat.z + __glOne;
                }
                __glNormalize(&hHat.x, hv);

                /* Compute attenuation */
                if (__GL_FLOAT_NEZ(lsm->position.w))
                {
                    __GLfloat k0, k1, k2, dist;

                    k0 = lsm->constantAttenuation;
                    k1 = lsm->linearAttenuation;
                    k2 = lsm->quadraticAttenuation;
                    if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                    {
                        /* Use pre-computed 1/k0 */
                        att = lsm->attenuation;
                    }
                    else
                    {

                dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                  + vPli.z*vPli.z);
                att = __glOne / (k0 + k1 * dist + k2 * dist * dist);
                    }
                }
                else
                {
                    att = __glOne;
                }

                /* Compute spot effect if light is a spot light */
                attSpot = att;
                if (lsm->isSpot)
                {
                    __GLfloat dot, px, py, pz;

                    px = -vPliHat.x;
                    py = -vPliHat.y;
                    pz = -vPliHat.z;
                    dot = px * lsm->direction.x + py * lsm->direction.y
                        + pz * lsm->direction.z;
                    if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                    {
                        GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale
                                    + __glHalf);
                        if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                            attSpot = att * lsm->spotTable[ix];
                    }
                    else
                    {
                        attSpot = zero;
                    }
                }

                /* Add in remaining effect of light, if any */
                if (attSpot)
                {
                    n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                    if (__GL_FLOAT_GTZ(n1)) {
                        n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                        n2 -= msm_threshold;
                        if (__GL_FLOAT_GEZ(n2))
                        {
#ifdef NT
                            __GLfloat fx = n2 * msm_scale + __glHalf;
                            if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                                n2 = msm_specTable[(GLint)fx];
                            else
                                n2 = __glOne;
#ifdef GL_WIN_specular_fog
                            if (gc->polygon.shader.modeFlags &
                                __GL_SHADE_SPEC_FOG)
                            {
                                fog += attSpot * n2;
                            }
#endif //GL_WIN_specular_fog
#else
                            GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                            if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                                n2 = msm_specTable[ix];
                            else
                                n2 = __glOne;
#endif
                            si += attSpot * n2 * lsm->sli;
                        }
                        di += attSpot * n1 * lsm->dli;
                    }
                }
            }
            else
            {
                __GLfloat n1, n2;

                /* Compute specular contribution */
                n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                    nzi * lsm->unitVPpli.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
#ifdef NT
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags &
                            __GL_SHADE_SPEC_FOG)
                        {
                            fog += n2;
                        }
#endif //GL_WIN_specular_fog
#else
                        GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                        if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                            n2 = msm_specTable[ix];
                        else
                            n2 = __glOne;
#endif
                        si += n2 * lsm->sli;
                    }
                    di += n1 * lsm->dli;
                }
            }
        }

        /* Compute final color */
        if (si > __glOne)
            si = __glOne;

        ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
            + si * (ms_cmaps - ms_cmapa);
        if (ci > ms_cmaps)
            ci = ms_cmaps;

// need to mask color index before color clipping

        if (ci > redMaxF) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) ci;
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        } else if (ci < 0) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) __GL_FLOORF(ci);
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        }
        pd->colors[face].r = ci;
#ifdef GL_WIN_specular_fog
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            pd->fog = 1.0 - fog;
            if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
        }
#endif //GL_WIN_specular_fog
    }
}


// No slow lights version
// Note: The first vertex must have a valid normal!
//
// IN:  normal
// OUT: color.r (front or back depending on face) (all vertices are updated)

void FASTCALL PolyArrayFastCalcCIColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourceMachine *lsm;
    __GLmaterialState *ms;
    __GLmaterialMachine *msm;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat si, di;
    POLYDATA  *pd;
    GLfloat   redMaxF;
    GLint     redMaxI;
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog

#if LATER
// if eye.w is zero, it should really take the slow path!
// Since the RGB version ignores it, we will also ignore it here.
// Even the original generic implementation may not have computed eye values.
#endif

    zero = __glZero;

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
    }

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;

// NOTE: the following values may be re-used in the next iteration:
//       nxi, nyi, nzi

    for (pd = pdFirst; pd <= pdLast; pd++)
    {
        __GLfloat ci;

        // If normal has not changed for this vertex, use the previously
        // computed color index.

        if (!(pd->flags & POLYDATA_NORMAL_VALID))
        {
            ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
            pd->colors[face].r = (pd-1)->colors[face].r;
#ifdef GL_WIN_specular_fog
            // Initialize Fog value to 0 here;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                ASSERTOPENGL (face == __GL_FRONTFACE,
                              "Specular fog works for only GL_FRONT\n");
                pd->fog = (pd-1)->fog;
            }
#endif //GL_WIN_specular_fog
            continue;
        }

        if (face == __GL_FRONTFACE)
        {
            nxi = pd->normal.x;
            nyi = pd->normal.y;
            nzi = pd->normal.z;
        }
        else
        {
            nxi = -pd->normal.x;
            nyi = -pd->normal.y;
            nzi = -pd->normal.z;
        }

        si = zero;
        di = zero;
#ifdef GL_WIN_specular_fog
        // Initialize Fog value to 0 here;
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            fog = __glZero;
        }
#endif //GL_WIN_specular_fog

        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            __GLfloat n1, n2;

            /* Compute specular contribution */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
            nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
        {
            n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
            n2 -= msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
#ifdef NT
                __GLfloat fx = n2 * msm_scale + __glHalf;
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
#else
                    GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                    if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                        n2 = msm_specTable[ix];
                    else
                        n2 = __glOne;
#endif
                si += n2 * lsm->sli;
#ifdef GL_WIN_specular_fog
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                    {
                        fog += n2;
                    }
#endif //GL_WIN_specular_fog
            }
            di += n1 * lsm->dli;
        }
        }

        /* Compute final color */
        if (si > __glOne)
            si = __glOne;

        ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
            + si * (ms_cmaps - ms_cmapa);
        if (ci > ms_cmaps)
            ci = ms_cmaps;

// need to mask color index before color clipping
// SGIBUG: The sample implementation fails to do this!

        if (ci > redMaxF) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) ci;
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        } else if (ci < 0) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) __GL_FLOORF(ci);
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        }
        pd->colors[face].r = ci;
#ifdef GL_WIN_specular_fog
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            pd->fog = 1.0 - fog;
            if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
        }
#endif //GL_WIN_specular_fog
    }
}


// If both front and back colors are needed, the back colors must be computed
// first!  Otherwise, the front colors can be overwritten prematurely.
// Note: The first vertex must have valid normal and color!
//
// IN:  obj/eye, color (front), normal
// OUT: eye, color (front or back depending on face) (all vertices are updated)

void FASTCALL PolyArrayCalcRGBColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLfloat rsi, gsi, bsi;
    __GLcolor sceneColorI;
    __GLmaterialMachine *msm;
    __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    __GLcolor msm_paSceneColor;
    GLuint    msm_colorMaterialChange;
    POLYDATA  *pd;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog

    PERF_CHECK(FALSE, "Uses slow lights\n");

    zero = __glZero;

    // Eye coord should have been processed

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    lm_ambient.r = gc->state.light.model.ambient.r;
    lm_ambient.g = gc->state.light.model.ambient.g;
    lm_ambient.b = gc->state.light.model.ambient.b;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;
    msm_colorMaterialChange = msm->colorMaterialChange;
    msm_paSceneColor = msm->paSceneColor;

    localViewer = gc->state.light.model.localViewer;

    // Get invarient scene color if there is no ambient or emissive color
    // material.

    sceneColorI.r = msm_paSceneColor.r;
    sceneColorI.g = msm_paSceneColor.g;
    sceneColorI.b = msm_paSceneColor.b;

    // NOTE: the following values may be re-used in the next iteration:
    //       ri, gi, bi, alpha, nxi, nyi, nzi, sceneColorI

    for (pd = pdFirst; pd <= pdLast; pd++)
    {
        if (pd->flags & POLYDATA_COLOR_VALID)
        {
            // Save latest colors normalized to 0..1

            ri = pd->colors[0].r * gc->oneOverRedVertexScale;
            gi = pd->colors[0].g * gc->oneOverGreenVertexScale;
            bi = pd->colors[0].b * gc->oneOverBlueVertexScale;
            alpha = pd->colors[0].a;

            // Compute scene color.
            // If color has not changed, the previous sceneColorI values are
            // used!

            if (msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT |
                                           __GL_MATERIAL_EMISSIVE))
            {
                if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                {
                    sceneColorI.r = msm_paSceneColor.r + ri * lm_ambient.r;
                    sceneColorI.g = msm_paSceneColor.g + gi * lm_ambient.g;
                    sceneColorI.b = msm_paSceneColor.b + bi * lm_ambient.b;
                }
                else
                {
                    sceneColorI.r = msm_paSceneColor.r + pd->colors[0].r;
                    sceneColorI.g = msm_paSceneColor.g + pd->colors[0].g;
                    sceneColorI.b = msm_paSceneColor.b + pd->colors[0].b;
                }
            }
        }
        else
        {
            // use previous ri, gi, bi, alpha, and sceneColorI!
            ASSERTOPENGL(pd != pdFirst, "no initial color\n");
        }

        // Compute the diffuse and specular components for this vertex.

        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            if (face == __GL_FRONTFACE)
            {
                nxi = pd->normal.x;
                nyi = pd->normal.y;
                nzi = pd->normal.z;
            }
            else
            {
                nxi = -pd->normal.x;
                nyi = -pd->normal.y;
                nzi = -pd->normal.z;
            }
#ifdef GL_WIN_specular_fog
            // Initialize Fog value to 0 here;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                ASSERTOPENGL (face == __GL_FRONTFACE,
                              "Specular fog works for only GL_FRONT\n");
                fog = __glZero;
            }
#endif //GL_WIN_specular_fog
        }
        else
        {
            // use previous normal (nxi, nyi, nzi)!
            ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
#ifdef GL_WIN_specular_fog
            // use previous fog (fog)!
#endif //GL_WIN_specular_fog
        }

        rsi = sceneColorI.r;
        gsi = sceneColorI.g;
        bsi = sceneColorI.b;

        eyeWIsZero = __GL_FLOAT_EQZ(pd->eye.w);

        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            __GLfloat n1, n2;

            lss = lsm->state;
            lspmm = &lsm->front + face;

            if (lsm->slowPath || eyeWIsZero)
            {
                __GLcoord hHat, vPli, vPliHat, vPeHat;
                __GLfloat att, attSpot;
                __GLfloat hv[3];

                /* Compute unit h[i] */
                __glVecSub4(&vPli, &pd->eye, &lsm->position);
                __glNormalize(&vPliHat.x, &vPli.x);
                if (localViewer)
                {
                    __glVecSub4(&vPeHat, &pd->eye, &Pe);
                    __glNormalize(&vPeHat.x, &vPeHat.x);
                    hv[0] = vPliHat.x + vPeHat.x;
                    hv[1] = vPliHat.y + vPeHat.y;
                    hv[2] = vPliHat.z + vPeHat.z;
                }
                else
                {
                    hv[0] = vPliHat.x;
                    hv[1] = vPliHat.y;
                    hv[2] = vPliHat.z + __glOne;
                }
                __glNormalize(&hHat.x, hv);

                /* Compute attenuation */
                if (__GL_FLOAT_NEZ(lsm->position.w))
                {
                    __GLfloat k0, k1, k2, dist;

                    k0 = lsm->constantAttenuation;
                    k1 = lsm->linearAttenuation;
                    k2 = lsm->quadraticAttenuation;
                    if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                    {
                        /* Use pre-computed 1/k0 */
                        att = lsm->attenuation;
                    }
                    else
                    {
                        dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                        att = __glOne / (k0 + k1 * dist + k2 * dist * dist);
                    }
                }
                else
                {
                    att = __glOne;
                }

                /* Compute spot effect if light is a spot light */
                attSpot = att;
                if (lsm->isSpot)
                {
                    __GLfloat dot, px, py, pz;

                    px = -vPliHat.x;
                    py = -vPliHat.y;
                    pz = -vPliHat.z;
                    dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                    if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                      {
                        GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale
                                           + __glHalf);
                        if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                          attSpot = att * lsm->spotTable[ix];
                      }
                    else
                      {
                        attSpot = zero;
                      }
                }

                /* Add in remaining effect of light, if any */
                if (attSpot)
                {
                    __GLfloat n1, n2;
                    __GLcolor sum;

                    if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                    {
                        sum.r = ri * lss->ambient.r;
                        sum.g = gi * lss->ambient.g;
                        sum.b = bi * lss->ambient.b;
                    }
                    else
                    {
                        sum.r = lspmm->ambient.r;
                        sum.g = lspmm->ambient.g;
                        sum.b = lspmm->ambient.b;
                    }

                    n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                    if (__GL_FLOAT_GTZ(n1))
                    {
                        n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                        n2 -= msm_threshold;
                        if (__GL_FLOAT_GEZ(n2))
                        {
#ifdef NT
                            __GLfloat fx = n2 * msm_scale + __glHalf;
                            if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                              n2 = msm_specTable[(GLint)fx];
                            else
                              n2 = __glOne;
#ifdef GL_WIN_specular_fog
                            if (gc->polygon.shader.modeFlags &
                                __GL_SHADE_SPEC_FOG)
                            {
                                fog += attSpot * n2;
                            }
#endif //GL_WIN_specular_fog
#else
                            GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                            if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                              n2 = msm_specTable[ix];
                            else
                              n2 = __glOne;
#endif
                            if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                            {
                                /* Recompute per-light per-material cached specular */
                                sum.r += n2 * ri * lss->specular.r;
                                sum.g += n2 * gi * lss->specular.g;
                                sum.b += n2 * bi * lss->specular.b;
                            }
                            else
                            {
                                sum.r += n2 * lspmm->specular.r;
                                sum.g += n2 * lspmm->specular.g;
                                sum.b += n2 * lspmm->specular.b;
                            }
                        }
                        if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                          {
                            /* Recompute per-light per-material cached diffuse */
                            sum.r += n1 * ri * lss->diffuse.r;
                            sum.g += n1 * gi * lss->diffuse.g;
                            sum.b += n1 * bi * lss->diffuse.b;
                          }
                        else
                          {
                            sum.r += n1 * lspmm->diffuse.r;
                            sum.g += n1 * lspmm->diffuse.g;
                            sum.b += n1 * lspmm->diffuse.b;
                          }
                    }

                    rsi += attSpot * sum.r;
                    gsi += attSpot * sum.g;
                    bsi += attSpot * sum.b;
                }
            }
            else
            {
                __GLfloat n1, n2;

                if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                {
                    rsi += ri * lss->ambient.r;
                    gsi += gi * lss->ambient.g;
                    bsi += bi * lss->ambient.b;
                }
                else
                {
                    rsi += lspmm->ambient.r;
                    gsi += lspmm->ambient.g;
                    bsi += lspmm->ambient.b;
                }

                /* Add in specular and diffuse effect of light, if any */
                n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                  nzi * lsm->unitVPpli.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2)) {
#ifdef NT
                      __GLfloat fx = n2 * msm_scale + __glHalf;
                      if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                      else
                        n2 = __glOne;
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags &
                            __GL_SHADE_SPEC_FOG)
                        {
                            fog += n2;
                        }
#endif //GL_WIN_specular_fog
#else
                      GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                      if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                        n2 = msm_specTable[ix];
                      else
                        n2 = __glOne;
#endif
                      if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                        {
                            /* Recompute per-light per-material cached
                               specular */
                          rsi += n2 * ri * lss->specular.r;
                          gsi += n2 * gi * lss->specular.g;
                          bsi += n2 * bi * lss->specular.b;
                        }
                      else
                        {
                          rsi += n2 * lspmm->specular.r;
                          gsi += n2 * lspmm->specular.g;
                          bsi += n2 * lspmm->specular.b;
                        }
                    }
                    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                      {
                        /* Recompute per-light per-material cached diffuse */
                        rsi += n1 * ri * lss->diffuse.r;
                        gsi += n1 * gi * lss->diffuse.g;
                        bsi += n1 * bi * lss->diffuse.b;
                      }
                    else
                      {
                        rsi += n1 * lspmm->diffuse.r;
                        gsi += n1 * lspmm->diffuse.g;
                        bsi += n1 * lspmm->diffuse.b;
                      }
                }
            }
        }

        {
            __GLcolor *pd_color_dst;

            pd_color_dst = &pd->colors[face];

            __GL_CLAMP_RGB(pd_color_dst->r,
                           pd_color_dst->g,
                           pd_color_dst->b,
                           gc, rsi, gsi, bsi);

            if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
            {
                if (pa->flags & POLYARRAY_CLAMP_COLOR)
                {
                    __GL_CLAMP_A(pd_color_dst->a, gc, alpha);
                }
                else
                    pd_color_dst->a = alpha;
            }
            else
            {
                pd_color_dst->a = msm_alpha;
            }
#ifdef GL_WIN_specular_fog
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                  pd->fog = 1.0 - fog;
                  if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
            }
#endif //GL_WIN_specular_fog
        }
    }
}

// If both front and back colors are needed, the back color must be computed
// first!  Otherwise, the front color can be overwritten prematurely.
// Note: The first vertex must have valid normal and color!
//
// IN:  color (front), normal
// OUT: color (front or back depending on face) (all vertices are updated)

#ifndef __GL_ASM_POLYARRAYFASTCALCRGBCOLOR
void FASTCALL PolyArrayFastCalcRGBColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
        // Don't use a structure.  Compiler wants to store it on the stack,
        // even though that's not necessary.
    __GLfloat baseEmissiveAmbient_r, emissiveAmbientI_r, diffuseSpecularI_r;
    __GLfloat baseEmissiveAmbient_g, emissiveAmbientI_g, diffuseSpecularI_g;
    __GLfloat baseEmissiveAmbient_b, emissiveAmbientI_b, diffuseSpecularI_b;
    __GLfloat lm_ambient_r;
        __GLfloat lm_ambient_g;
        __GLfloat lm_ambient_b;
    __GLmaterialMachine *msm, *msm_front, *msm_back;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint    msm_colorMaterialChange;
    POLYDATA  *pd;
        __GLfloat diff_r, diff_g, diff_b;
        __GLfloat spec_r, spec_g, spec_b;
        __GLcolor *lss_diff_color, *lss_spec_color;
        __GLcolor *lspmm_diff_color, *lspmm_spec_color;
        __GLcolor *diff_color, *spec_color;
        GLuint use_material_diffuse, use_material_specular;
        GLuint use_material_ambient, use_material_emissive;
        __GLfloat spec_r_sum, spec_g_sum, spec_b_sum;
        __GLfloat diff_r_sum, diff_g_sum, diff_b_sum;
        __GLfloat ambient_r_sum, ambient_g_sum, ambient_b_sum;
        GLuint pd_flags, normal_valid, color_valid;
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog


#if LATER
        // if eye.w is zero, it should really take the slow path!
        // Since the sample implementation ignores it, we will also ignore it here.
#endif

    PERF_CHECK(FALSE, "Primitives contain glColorMaterial calls\n");

        msm_front = &gc->light.front;
        msm_back = &gc->light.back;
        msm = msm_back;
    if (face == __GL_FRONTFACE)
                msm = msm_front;

        // If there is no color material change for this face, we can call the
        // zippy function!

    msm_colorMaterialChange = msm->colorMaterialChange;
    if (!msm_colorMaterialChange)
    {
                PolyArrayZippyCalcRGBColor(gc, face, pa, pdFirst, pdLast);
                return;
    }

        // Compute invarient emissive and ambient components for this vertex.

    lm_ambient_r = gc->state.light.model.ambient.r;
    lm_ambient_g = gc->state.light.model.ambient.g;
    lm_ambient_b = gc->state.light.model.ambient.b;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;

    use_material_ambient = msm_colorMaterialChange & __GL_MATERIAL_AMBIENT;
    use_material_emissive = msm_colorMaterialChange & __GL_MATERIAL_EMISSIVE;

    if (!use_material_ambient) {
        baseEmissiveAmbient_r = msm->cachedEmissiveAmbient.r;
        baseEmissiveAmbient_g = msm->cachedEmissiveAmbient.g;
        baseEmissiveAmbient_b = msm->cachedEmissiveAmbient.b;
    } else {
        baseEmissiveAmbient_r = msm->paSceneColor.r;
        baseEmissiveAmbient_g = msm->paSceneColor.g;
        baseEmissiveAmbient_b = msm->paSceneColor.b;
    }

        // If there is no emissive or ambient color material change, this
        // will be the emissive and ambient components.

        emissiveAmbientI_r = baseEmissiveAmbient_r;
        emissiveAmbientI_g = baseEmissiveAmbient_g;
        emissiveAmbientI_b = baseEmissiveAmbient_b;

        use_material_diffuse = msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE;
        use_material_specular = msm_colorMaterialChange & __GL_MATERIAL_SPECULAR;

        // NOTE: the following values may be re-used in the next iteration:
        //       ri, gi, bi, alpha, nxi, nyi, nzi, emissiveAmbientI, diffuseSpecularI

        for (pd = pdFirst; pd <= pdLast; pd++)
        {
                // If color and normal have not changed for this vertex, use the previously
                // computed color.

                pd_flags = pd->flags;
                normal_valid = pd_flags & POLYDATA_NORMAL_VALID;
                color_valid = pd_flags & POLYDATA_COLOR_VALID;

                if (!(normal_valid || color_valid))
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal and color\n");
                        pd->colors[face] = (pd-1)->colors[face];
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = (pd-1)->fog;
                        }
#endif //GL_WIN_specular_fog
                        continue;
                }

                if (color_valid)
                {
                        __GLfloat pd_r, pd_g, pd_b;

            // Save latest colors normalized to 0..1

                        pd_r = pd->colors[0].r;
                        pd_g = pd->colors[0].g;
                        pd_b = pd->colors[0].b;
                        ri = pd_r * gc->oneOverRedVertexScale;
                        gi = pd_g * gc->oneOverGreenVertexScale;
                        bi = pd_b * gc->oneOverBlueVertexScale;
                        alpha = pd->colors[0].a;

                        // Compute the emissive and ambient components for this vertex if necessary.
                        // If color has not changed, the previous emissveAmbientI values are used!

                        if (use_material_ambient || use_material_emissive)
                        {
                                if (use_material_ambient)
                                {
                                        ambient_r_sum = lm_ambient_r;
                                        ambient_g_sum = lm_ambient_g;
                                        ambient_b_sum = lm_ambient_b;

                                        // Add per-light per-material ambient
                                        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
                                        {
                                                lss = lsm->state;
                                                ambient_r_sum += lss->ambient.r;
                                                ambient_g_sum += lss->ambient.g;
                                                ambient_b_sum += lss->ambient.b;
                                        }

                                        ambient_r_sum *= ri;
                                        ambient_g_sum *= gi;
                                        ambient_b_sum *= bi;

                                        emissiveAmbientI_r = baseEmissiveAmbient_r + ambient_r_sum;
                                        emissiveAmbientI_g = baseEmissiveAmbient_g + ambient_g_sum;
                                        emissiveAmbientI_b = baseEmissiveAmbient_b + ambient_b_sum;

                                }
                                else
                                {
                                        emissiveAmbientI_r = baseEmissiveAmbient_r + pd_r;
                                        emissiveAmbientI_g = baseEmissiveAmbient_g + pd_g;
                                        emissiveAmbientI_b = baseEmissiveAmbient_b + pd_b;
                                }
                        }
                }
                else
                {
                        // use previous ri, gi, bi, alpha, and emissiveAmbientI!
                        ASSERTOPENGL(pd != pdFirst, "no initial color\n");
                }

                // Compute the diffuse and specular components for this vertex.

                if (normal_valid)
                {
                        nxi = pd->normal.x;
                        nyi = pd->normal.y;
                        nzi = pd->normal.z;
                        if (face != __GL_FRONTFACE)
                        {
                                nxi = -nxi;
                                nyi = -nyi;
                                nzi = -nzi;
                        }
#ifdef GL_WIN_specular_fog
            // Initialize Fog value to 0 here;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                ASSERTOPENGL (face == __GL_FRONTFACE,
                              "Specular fog works for only GL_FRONT\n");
                fog = __glZero;
            }
#endif //GL_WIN_specular_fog

                }
                else
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal\n");

                        // If normal and diffuse and specular components have not changed,
                        // use the previously computed diffuse and specular values.
                        // otherwise, use previous normal (nxi, nyi, nzi) and
                        // diffuseSpecularI!

                        if (!(use_material_diffuse || use_material_specular))
                                goto store_color;
                }

                spec_r_sum = (__GLfloat)0.0;
                spec_g_sum = (__GLfloat)0.0;
                spec_b_sum = (__GLfloat)0.0;
                diff_r_sum = (__GLfloat)0.0;
                diff_g_sum = (__GLfloat)0.0;
                diff_b_sum = (__GLfloat)0.0;

                for (lsm = gc->light.sources; lsm; lsm = lsm->next)
                {
                        __GLfloat n1, n2;

                        lss = lsm->state;
                        lspmm = &lsm->front + face;

                        lss_diff_color = &lss->diffuse;
                        lss_spec_color = &lss->specular;
                        lspmm_diff_color = &lspmm->diffuse;
                        lspmm_spec_color = &lspmm->specular;

                        diff_color = lspmm_diff_color;
                        spec_color = lspmm_spec_color;
                        if (use_material_diffuse)
                                diff_color = lss_diff_color;
                        if (use_material_specular)
                                spec_color = lss_spec_color;

                        /* Add in specular and diffuse effect of light, if any */
                        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                                nzi * lsm->unitVPpli.z;
                        if (n1 > 0.0)
                        {
                                diff_r = diff_color->r;
                                diff_g = diff_color->g;
                                diff_b = diff_color->b;

                                n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                                n2 -= msm_threshold;
                                if (n2 >= 0.0)
                                {
                                        __GLfloat fx = n2 * msm_scale + __glHalf;

                                        spec_r = spec_color->r;
                                        spec_g = spec_color->g;
                                        spec_b = spec_color->b;

                                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE ){
                                                n2 = msm_specTable[(GLint)fx];
                                                spec_r *= n2;
                                                spec_g *= n2;
                                                spec_b *= n2;
                                        }
                                        /* else n2 = 1.0.
                                        Before, we multiplied (spec_r *= n2) in all cases.
                                        But since n2 == 1.0, there's no need to do it in this case.
                                        Thus there is no need to load n2 = 1.0. */

#ifdef GL_WIN_specular_fog
                                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                                        {
                                                pd->fog += n2;
                                        }
#endif //GL_WIN_specular_fog


                                        spec_r_sum += spec_r;
                                        spec_g_sum += spec_g;
                                        spec_b_sum += spec_b;
                                }

                                diff_r *= n1;
                                diff_g *= n1;
                                diff_b *= n1;

                                diff_r_sum += diff_r;
                                diff_g_sum += diff_g;
                                diff_b_sum += diff_b;
                        }
                }

                if (use_material_specular){
                        /* Recompute per-light per-material cached specular */
                        spec_r_sum *= ri;
                        spec_g_sum *= gi;
                        spec_b_sum *= bi;
                }
                if (use_material_diffuse){
                        /* Recompute per-light per-material cached diffuse */
                        diff_r_sum *= ri;
                        diff_g_sum *= gi;
                        diff_b_sum *= bi;
                }

                diffuseSpecularI_r = diff_r_sum + spec_r_sum;
                diffuseSpecularI_g = diff_g_sum + spec_g_sum;
                diffuseSpecularI_b = diff_b_sum + spec_b_sum;


store_color:
                {
                        __GLcolor *pd_color_dst;

                        pd_color_dst = &pd->colors[face];

                        __GL_CLAMP_RGB( pd_color_dst->r,
                                                        pd_color_dst->g,
                                                        pd_color_dst->b,
                                                        gc,
                                                        emissiveAmbientI_r + diffuseSpecularI_r,
                                                        emissiveAmbientI_g + diffuseSpecularI_g,
                                                        emissiveAmbientI_b + diffuseSpecularI_b);

                        if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                        {
                                if (pa->flags & POLYARRAY_CLAMP_COLOR)
                                {
                                    __GL_CLAMP_A(pd_color_dst->a, gc, alpha);
                                }
                                else
                                        pd_color_dst->a = alpha;
                        }
                        else
                        {
                                pd_color_dst->a = msm_alpha;
                        }
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = 1.0 - fog;
                                if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
                        }
#endif //GL_WIN_specular_fog

                }
        }
}
#endif // __GL_ASM_POLYARRAYFASTCALCRGBCOLOR


// This function is called when color material is disabled and there are no
// slow lights.
//
// Note: The first vertex must have a valid normal!
//
// IN:  normal
// OUT: color (front or back depending on face) (all vertices are updated)

#ifndef __GL_ASM_POLYARRAYZIPPYCALCRGBCOLOR
void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    register __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat baseEmissiveAmbient_r, baseEmissiveAmbient_g, baseEmissiveAmbient_b;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    __GLcolor *pd_color_dst;
    GLboolean notBackface = FALSE;
    POLYDATA  *pd;
    ULONG normal_valid, paneeds_valid;
    register GLfloat diff_r, diff_g, diff_b;
    register GLfloat spec_r, spec_g, spec_b;
    GLfloat lsmx, lsmy, lsmz;
    ULONG fast_path = 0;
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog


#if LATER
// if eye.w is zero, it should really take the slow path!
// Since the sample implementation ignores it, we will also ignore it here.
#endif

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    lsm = gc->light.sources;
    if (lsm && !lsm->next)
        fast_path = 1;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;

// Compute invarient emissive and ambient components for this vertex.

    baseEmissiveAmbient_r = msm->cachedEmissiveAmbient.r;
    baseEmissiveAmbient_g = msm->cachedEmissiveAmbient.g;
    baseEmissiveAmbient_b = msm->cachedEmissiveAmbient.b;


// NOTE: the following values may be re-used in the next iteration:
//       nxi, nyi, nzi

#ifdef GL_WIN_specular_fog
    if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
    {
        ASSERTOPENGL (face == __GL_FRONTFACE,
                      "Specular fog works only with GL_FRONT\n");
    }
#endif //GL_WIN_specular_fog


    if (fast_path)
    {
        __GLfloat n1, n2;

        lspmm = &lsm->front + face;
        lss = lsm->state;
        lsmx = lsm->unitVPpli.x;
        lsmy = lsm->unitVPpli.y;
        lsmz = lsm->unitVPpli.z;

        diff_r = lspmm->diffuse.r;
        diff_g = lspmm->diffuse.g;
        diff_b = lspmm->diffuse.b;

        spec_r = lspmm->specular.r;
        spec_g = lspmm->specular.g;
        spec_b = lspmm->specular.b;

        for (pd = pdFirst; pd <= pdLast; pd++)
        {
                __GLfloat rsi, gsi, bsi;

// If normal has not changed for this vertex, use the previously computed color.

                normal_valid = pd->flags & POLYDATA_NORMAL_VALID;
                paneeds_valid = gc->vertex.paNeeds & PANEEDS_NORMAL;

                if (!(normal_valid))
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
                        pd->colors[face] = (pd-1)->colors[face];
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = (pd-1)->fog;
                        }
#endif //GL_WIN_specular_fog
                        continue;
                }

                if (face == __GL_FRONTFACE)
                {
                        nxi = pd->normal.x;
                        nyi = pd->normal.y;
                        nzi = pd->normal.z;
                }
                else
                {
                        nxi = -pd->normal.x;
                        nyi = -pd->normal.y;
                        nzi = -pd->normal.z;
                }

#ifdef GL_WIN_specular_fog
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                {
                        fog = __glZero;
                }
#endif //GL_WIN_specular_fog

                rsi = baseEmissiveAmbient_r;
                gsi = baseEmissiveAmbient_g;
                bsi = baseEmissiveAmbient_b;

// Compute the diffuse and specular components for this vertex.

        /* Add in specular and diffuse effect of light, if any */

                n1 = nxi * lsmx + nyi * lsmy + nzi * lsmz;
                pd_color_dst = &pd->colors[face];
                if (n1 > 0.0)
                {
                        n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
                        - msm_threshold;

                        rsi += n1 * diff_r;
                        gsi += n1 * diff_g;
                        bsi += n1 * diff_b;

                        if (n2 >= 0.0)
                        {
                                GLint ix = (GLint)(n2 * msm_scale + __glHalf);

                                if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                                        n2 = msm_specTable[ix];
                                else
                                        n2 = __glOne;

#ifdef GL_WIN_specular_fog
                                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                                {
                                        fog += n2;
                                }
#endif //GL_WIN_specular_fog


                                rsi += n2 * spec_r;
                                gsi += n2 * spec_g;
                                bsi += n2 * spec_b;
                        }
                        pd_color_dst->r = rsi;
                        pd_color_dst->g = gsi;
                        pd_color_dst->b = bsi;
                        if (__GL_COLOR_CHECK_CLAMP_RGB(gc, rsi, gsi, bsi)) {
                                __GL_CLAMP_RGB(pd_color_dst->r,
                               pd_color_dst->g,
                               pd_color_dst->b,
                               gc, rsi, gsi, bsi);
                        }
                        pd_color_dst->a = msm_alpha;
                }
                else
                {
                        pd_color_dst->r = msm->cachedNonLit.r;
                        pd_color_dst->g = msm->cachedNonLit.g;
                        pd_color_dst->b = msm->cachedNonLit.b;
                        pd_color_dst->a = msm_alpha;
                }
        }
    }
    else
    {
        for (pd = pdFirst; pd <= pdLast; pd++)
        {
                __GLfloat rsi, gsi, bsi;

// If normal has not changed for this vertex, use the previously computed color.

                normal_valid = pd->flags & POLYDATA_NORMAL_VALID;
                paneeds_valid = gc->vertex.paNeeds & PANEEDS_NORMAL;

                if (!(normal_valid))
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
                        pd->colors[face] = (pd-1)->colors[face];
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = (pd-1)->fog;
                        }
#endif //GL_WIN_specular_fog
                        continue;
                }


                if (face == __GL_FRONTFACE)
                {
                        nxi = pd->normal.x;
                        nyi = pd->normal.y;
                        nzi = pd->normal.z;
                }
                else
                {
                        nxi = -pd->normal.x;
                        nyi = -pd->normal.y;
                        nzi = -pd->normal.z;
                }

#ifdef GL_WIN_specular_fog
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                {
                        fog = __glZero;
                }
#endif //GL_WIN_specular_fog

                rsi = baseEmissiveAmbient_r;
                gsi = baseEmissiveAmbient_g;
                bsi = baseEmissiveAmbient_b;

// Compute the diffuse and specular components for this vertex.

                for (lsm = gc->light.sources; lsm; lsm = lsm->next)
                {
                        __GLfloat n1, n2;

                        lspmm = &lsm->front + face;
                        lss = lsm->state;
                        lsmx = lsm->unitVPpli.x;
                        lsmy = lsm->unitVPpli.y;
                        lsmz = lsm->unitVPpli.z;

                        diff_r = lspmm->diffuse.r;
                        diff_g = lspmm->diffuse.g;
                        diff_b = lspmm->diffuse.b;

            /* Add in specular and diffuse effect of light, if any */

                        n1 = nxi * lsmx + nyi * lsmy + nzi * lsmz;

                        if (n1 > 0.0)
                        {
                                notBackface = TRUE;

                                n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
                                - msm_threshold;

                                if (n2 >= 0.0)
                                {
                                        GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                                        spec_r = lspmm->specular.r;
                                        spec_g = lspmm->specular.g;
                                        spec_b = lspmm->specular.b;

                                        if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                                                n2 = msm_specTable[ix];
                                        else
                                        n2 = __glOne;

#ifdef GL_WIN_specular_fog
                                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                                        {
                                                fog += n2;
                                        }
#endif //GL_WIN_specular_fog

                                        rsi += n2 * spec_r;
                                        gsi += n2 * spec_g;
                                        bsi += n2 * spec_b;
                                }
                                rsi += n1 * diff_r;
                                gsi += n1 * diff_g;
                                bsi += n1 * diff_b;
                        }
                }

                pd_color_dst = &pd->colors[face];

#ifdef GL_WIN_specular_fog
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                {
                        pd->fog = 1.0 - fog;
                        if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
                }
#endif //GL_WIN_specular_fog


                if (notBackface)
                {
                        pd_color_dst->r = rsi;
                        pd_color_dst->g = gsi;
                        pd_color_dst->b = bsi;

                        if (__GL_COLOR_CHECK_CLAMP_RGB(gc, rsi, gsi, bsi)) {
                                __GL_CLAMP_RGB(pd_color_dst->r,
                                                pd_color_dst->g,
                                                pd_color_dst->b,
                                                gc, rsi, gsi, bsi);
                        }

                        pd_color_dst->a = msm_alpha;

                }
                else
                {
                        pd_color_dst->r = msm->cachedNonLit.r;
                        pd_color_dst->g = msm->cachedNonLit.g;
                        pd_color_dst->b = msm->cachedNonLit.b;
                        pd_color_dst->a = msm_alpha;
                }
        }
    }

}

#endif // __GL_ASM_POLYARRAYZIPPYCALCRGBCOLOR

#ifdef _X86_

// See comments in xform.asm (NORMALIZE macro) about format of this table
//
#define K 9                         // Number of used mantissa bits
#define MAX_ENTRY  (1 << (K+1))
#define EXPONENT_BIT (1 << K)
#define MANTISSA_MASK (EXPONENT_BIT - 1)
#define FRACTION_VALUE ((float)EXPONENT_BIT)

float invSqrtTable[MAX_ENTRY];      // used by glNormalizeBatch

void initInvSqrtTable()
{
    int i;
    for (i=0; i < MAX_ENTRY; i++)
    {
        if (i & EXPONENT_BIT)
            invSqrtTable[i] = (float)(1.0/sqrt(((i & MANTISSA_MASK)/FRACTION_VALUE+1.0)));
        else
            invSqrtTable[i] = (float)(1.0/sqrt(((i & MANTISSA_MASK)/FRACTION_VALUE+1.0)/2));
    }
}

/*
    __glClipCodes table has precomputed clip codes.
    Index to this table:
    bit 6  - 1 if clipW < 0
    bit 5  - 1 if clipX < 0
    bit 4  - 1 if abs(clipX) < abs(clipW)
    bit 3  - 1 if clipY < 0
    bit 2  - 1 if abs(clipY) < abs(clipW)
    bit 1  - 1 if clipZ < 0
    bit 0  - 1 if abs(clipZ) < abs(clipW)
*/
ULONG __glClipCodes[128];

void initClipCodesTable()
{
    int i, v, w;
    for (i=0; i < 128; i++)
    {
        int code = 0;
        if (i & 0x10)
        { // x < w
           v = 1; w = 2;
        }
        else
        {
           v = 2; w = 1;
        }
        if (i & 0x20) v = -v;
        if (i & 0x40) w = -w;
        if (v >  w) code|= __GL_CLIP_RIGHT;
        if (v < -w) code|= __GL_CLIP_LEFT;

        if (i & 0x04)
        { // y < w
           v = 1; w = 2;
        }
        else
        {
           v = 2; w = 1;
        }
        if (i & 0x08) v = -v;
        if (i & 0x40) w = -w;
        if (v >  w) code|= __GL_CLIP_TOP;
        if (v < -w) code|= __GL_CLIP_BOTTOM;

        if (i & 0x01)
        { // v < w
           v = 1; w = 2;
        }
        else
        {
           v = 2; w = 1;
        }
        if (i & 0x02) v = -v;
        if (i & 0x40) w = -w;
        if (v >  w) code|= __GL_CLIP_FAR;
        if (v < -w) code|= __GL_CLIP_NEAR;

        __glClipCodes[i] = code;
    }
}
#endif // _X86_

#ifndef __GL_ASM_PACLIPCHECKFRUSTUM
/****************************************************************************/
// Clip check the clip coordinates against the frustum planes.
// Compute the window coordinates if not clipped!
//
// IN:  clip
// OUT: window (if not clipped)

GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, invW, negW;
    GLuint code;
    POLYDATA *pd;

    for (pd = pa->pd0; pd <= pdLast; pd++)
    {

        w = pd->clip.w;
        /* Set clip codes */

        /* XXX (mf) prevent divide-by-zero */
        if (__GL_FLOAT_NEZ(w))
        {
                __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, w, invW);
        }
        else
        {
                invW = __glZero;
        }

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;

        code = 0;
        negW = -w;

        __GL_FLOAT_SIMPLE_END_DIVIDE(invW);

        pd->window.w = invW;

        /*
        ** NOTE: it is possible for x to be less than negW and greater
            ** than w (if w is negative).  Otherwise there would be "else"
            ** clauses here.
        */
        if (x < negW) code |= __GL_CLIP_LEFT;
        if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        if (y > w) code |= __GL_CLIP_TOP;
        if (z < negW) code |= __GL_CLIP_NEAR;
        if (z > w) code |= __GL_CLIP_FAR;

        /* Compute window coordinates if not clipped */
        if (!code)
        {
                __GLfloat wx, wy, wz;

                wx = x * gc->state.viewport.xScale * invW +
                    gc->state.viewport.xCenter;
                wy = y * gc->state.viewport.yScale * invW +
                    gc->state.viewport.yCenter;
                wz = z * gc->state.viewport.zScale * invW +
                    gc->state.viewport.zCenter;
                pd->window.x = wx;
                pd->window.y = wy;
                pd->window.z = wz;
        }
        pd->clipCode = code;

        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }
    return pa->andClipCodes;
}

GLuint FASTCALL PAClipCheckFrustumWOne(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, invW, negW;
    GLuint code;
    POLYDATA *pd;

    for (pd = pa->pd0; pd <= pdLast; pd++)
    {

        w = pd->clip.w;
        pd->window.w = __glOne;

        /* Set clip codes */

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;
        code = 0;
        negW = __glMinusOne;
        if (x < negW) code |= __GL_CLIP_LEFT;
        else if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        else if (y > w) code |= __GL_CLIP_TOP;
        if (z < negW) code |= __GL_CLIP_NEAR;
        else if (z > w) code |= __GL_CLIP_FAR;

        /* Compute window coordinates if not clipped */
        if (!code)
        {
            __GLfloat wx, wy, wz;

                wx = x * gc->state.viewport.xScale + gc->state.viewport.xCenter;
                wy = y * gc->state.viewport.yScale + gc->state.viewport.yCenter;
                wz = z * gc->state.viewport.zScale + gc->state.viewport.zCenter;

                pd->window.x = wx;
                pd->window.y = wy;
                pd->window.z = wz;
        }
        pd->clipCode = code;
        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }
    return pa->andClipCodes;
}
#endif // __GL_ASM_PACLIPCHECKFRUSTUM

// Clip check the clip coordinates against the frustum planes.
// Compute the window coordinates if not clipped!
//
// IN:  clip
// OUT: window (if not clipped)

#ifndef __GL_ASM_PACLIPCHECKFRUSTUM2D
GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
                                     POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, negW, invW;
    GLuint code;
    POLYDATA *pd;

    for (pd = pa->pd0; pd <= pdLast; pd++) {

        /* W is 1.0 */

        pd->window.w = __glOne;

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;
        w = pd->clip.w;
        negW = __glMinusOne;

        /* Set clip codes */
        code = 0;

        if (x < negW) code |= __GL_CLIP_LEFT;
        else if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        else if (y > w) code |= __GL_CLIP_TOP;

        /* Compute window coordinates if not clipped */
        if (!code)
        {
            __GLfloat wx, wy, wz;

            wx = x * gc->state.viewport.xScale + gc->state.viewport.xCenter;
                wy = y * gc->state.viewport.yScale + gc->state.viewport.yCenter;
                wz = z * gc->state.viewport.zScale + gc->state.viewport.zCenter;
                pd->window.x = wx;
                pd->window.y = wy;
            pd->window.z = wz;
        }

        pd->clipCode = code;

        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }
    return pa->andClipCodes;
}
#endif // __GL_ASM_PACLIPCHECKFRUSTUM2D

// Clip check against the frustum and user clipping planes.
// Compute the window coordinates if not clipped!
//
// IN:  clip, eye
// OUT: window (if not clipped)

#ifndef __GL_ASM_PACLIPCHECKALL

GLuint FASTCALL PAClipCheckAll(__GLcontext *gc, POLYARRAY *pa,
                               POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, negW, invW;
    GLuint code, bit, clipPlanesMask;
    __GLcoord *plane;
    POLYDATA *pd;

    // We need double precision to do this correctly.  If precision is
    // lowered (as it was in a previous version of this routine), triangles
    // may be clipped incorrectly with user planes (very visible in tlogo)!

    FPU_SAVE_MODE();
    FPU_ROUND_ON_PREC_HI();

    for (pd = pa->pd0; pd <= pdLast; pd++) {

        PERF_CHECK(FALSE, "Performs user plane clipping!\n");

        /*
        ** Do frustum checks.
        **
        ** NOTE: it is possible for x to be less than negW and greater than w
        ** (if w is negative).  Otherwise there would be "else" clauses here.
        */

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;
        w = pd->clip.w;

        /* Set clip codes */

        /* XXX (mf) prevent divide-by-zero */
        if (__GL_FLOAT_NEZ(w))
        {
            __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, w, invW);
            __GL_FLOAT_SIMPLE_END_DIVIDE(invW);
        }
        else
        {
            invW = __glZero;
        }
        pd->window.w = invW;
        negW = -w;
        code = 0;
        if (x < negW) code |= __GL_CLIP_LEFT;
        if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        if (y > w) code |= __GL_CLIP_TOP;
        if (z < negW) code |= __GL_CLIP_NEAR;
        if (z > w) code |= __GL_CLIP_FAR;

        /*
        ** Now do user clip plane checks
        */
        x = pd->eye.x;
        y = pd->eye.y;
        z = pd->eye.z;
        w = pd->eye.w;
        clipPlanesMask = gc->state.enables.clipPlanes;
        plane = &gc->state.transform.eyeClipPlanes[0];
        bit = __GL_CLIP_USER0;
        while (clipPlanesMask)
        {
            if (clipPlanesMask & 1)
                {
                    /*
                    ** Dot the vertex clip coordinate against the clip plane and
                    ** see if the sign is negative.  If so, then the point is out.
                    */

                    if (x * plane->x + y * plane->y + z * plane->z + w * plane->w <
                        __glZero)
                {
                    code |= bit;
                }
                }
                clipPlanesMask >>= 1;
                bit <<= 1;
                plane++;
        }

        /* Compute window coordinates if not clipped */
        if (!code)
        {
            __GLfloat wx, wy, wz;

                x = pd->clip.x;
                y = pd->clip.y;
                z = pd->clip.z;

            wx = x * gc->state.viewport.xScale * invW +
                     gc->state.viewport.xCenter;
            wy = y * gc->state.viewport.yScale * invW +
                     gc->state.viewport.yCenter;
            wz = z * gc->state.viewport.zScale * invW +
                     gc->state.viewport.zCenter;
            pd->window.x = wx;
            pd->window.y = wy;
            pd->window.z = wz;
        }

        pd->clipCode = code;

        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }

    FPU_RESTORE_MODE();
    return pa->andClipCodes;
}

#endif // __GL_ASM_PACLIPCHECKALL

/****************************************************************************/
void APIPRIVATE __glim_EdgeFlag(GLboolean tag)
{
    __GL_SETUP();
    gc->state.current.edgeTag = tag;
}

void APIPRIVATE __glim_TexCoord4fv(const GLfloat x[4])
{
    __GL_SETUP();
    gc->state.current.texture.x = x[0];
    gc->state.current.texture.y = x[1];
    gc->state.current.texture.z = x[2];
    gc->state.current.texture.w = x[3];
}

void APIPRIVATE __glim_Normal3fv(const GLfloat v[3])
{
    __GL_SETUP();
    GLfloat x, y, z;

    x = v[0];
    y = v[1];
    z = v[2];
    gc->state.current.normal.x = x;
    gc->state.current.normal.y = y;
    gc->state.current.normal.z = z;
}

void APIPRIVATE __glim_Color4fv(const GLfloat v[4])
{
    __GL_SETUP();

    gc->state.current.userColor.r = v[0];
    gc->state.current.userColor.g = v[1];
    gc->state.current.userColor.b = v[2];
    gc->state.current.userColor.a = v[3];
    (*gc->procs.applyColor)(gc);
}

void APIPRIVATE __glim_Indexf(GLfloat c)
{
    __GL_SETUP();
    gc->state.current.userColorIndex = c;
}

#if DBG
#define DEBUG_RASTERPOS 1
#endif

// This is not very efficient but it should work fine.
void APIPRIVATE __glim_RasterPos4fv(const GLfloat v[4])
{
    POLYDATA   pd3[3];  // one pa, one pd, followed by one spare.
    POLYARRAY  *pa = (POLYARRAY *) &pd3[0];
    POLYDATA   *pd = &pd3[1];
    __GLvertex *rp;
    GLuint     oldPaNeeds, oldEnables;
#ifdef DEBUG_RASTERPOS
    void (FASTCALL *oldRenderPoint)(__GLcontext *gc, __GLvertex *v);
#endif
    GLuint     pdflags;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

// ASSERT_VERTEX

    if (v[3] == (GLfloat) 1.0)
    {
        if (v[2] == (GLfloat) 0.0)
            pdflags = POLYDATA_VERTEX2;
        else
            pdflags = POLYDATA_VERTEX3;
    }
    else
    {
        pdflags = POLYDATA_VERTEX4;
    }

    rp = &gc->state.current.rasterPos;

// Initialize POLYARRAY structure with one vertex

    pa->flags         = pdflags | POLYARRAY_RASTERPOS;
    pa->pdNextVertex  = pd+1;
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag = NULL;
    pa->pd0           = pd;
    pa->primType      = GL_POINTS;
    pa->nIndices      = 1;
    pa->aIndices      = NULL;   // identity mapping
    pa->paNext        = NULL;

    pd->flags         = pdflags;
    pd->obj           = *(__GLcoord *) &v[0];
    pd->color         = &pd->colors[__GL_FRONTFACE];
    pd->clipCode      = 1;      // set for debugging
    (pd+1)->flags     = 0;
    pa->pdLastEvalColor   =
    pa->pdLastEvalNormal  =
    pa->pdLastEvalTexture = NULL;

// Set up states.

    // need transformed texcoord in all cases
    oldPaNeeds = gc->vertex.paNeeds;
    gc->vertex.paNeeds |= PANEEDS_TEXCOORD;
    // no front-end optimization
    gc->vertex.paNeeds &= ~(PANEEDS_CLIP_ONLY | PANEEDS_SKIP_LIGHTING | PANEEDS_NORMAL);
    // set normal need
    if (gc->vertex.paNeeds & PANEEDS_RASTERPOS_NORMAL)
        gc->vertex.paNeeds |= PANEEDS_NORMAL;
    if (gc->vertex.paNeeds & PANEEDS_RASTERPOS_NORMAL_FOR_TEXTURE)
        gc->vertex.paNeeds |= PANEEDS_NORMAL_FOR_TEXTURE;

    // don't apply cheap fog!
    oldEnables = gc->state.enables.general;
    gc->state.enables.general &= ~__GL_FOG_ENABLE;

#ifdef DEBUG_RASTERPOS
// Debug only!
    // allow DrawPolyArray to perform selection but not feedback and rendering
    oldRenderPoint = gc->procs.renderPoint;
    if (gc->renderMode != GL_SELECT)
        gc->procs.renderPoint = NULL;   // was __glRenderPointNop but set to 0
                                        // for debugging
#endif

// Call DrawPolyArray to 'draw' the point.
// Begin validation has already been done.

    __glim_DrawPolyArray(pa);

// 'Render' the point in selection but not in feedback and render modes.

    if (gc->renderMode == GL_SELECT)
    {
        PARenderPoint(gc, (__GLvertex *)pa->pd0);
    }

// Eye coord should have been processed

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

// Restore states.

    gc->vertex.paNeeds        = oldPaNeeds;
    gc->state.enables.general = oldEnables;
#ifdef DEBUG_RASTERPOS
    gc->procs.renderPoint     = oldRenderPoint;
#endif

// If the point is clipped, the raster position is invalid.

    if (pd->clipCode)
    {
        gc->state.current.validRasterPos = GL_FALSE;
        return;
    }
    gc->state.current.validRasterPos = GL_TRUE;

// Update raster pos data structure!
// Only the following fields are needed.

    rp->window.x = pd->window.x;
    rp->window.y = pd->window.y;
    rp->window.z = pd->window.z;
    rp->clip.w   = pd->clip.w;
    rp->eyeZ     = pd->eye.z;
    rp->colors[__GL_FRONTFACE] = pd->colors[__GL_FRONTFACE];
    rp->texture = pd->texture;
    ASSERTOPENGL(rp->color == &rp->colors[__GL_FRONTFACE],
                 "Color pointer not restored\n");
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/************************************************************************/

void FASTCALL __glNop(void) {}
void FASTCALL __glNopGC(__GLcontext* gc) {}
GLboolean FASTCALL __glNopGCBOOL(__GLcontext* gc) { return FALSE; }
void FASTCALL __glNopGCFRAG(__GLcontext* gc, __GLfragment *frag, __GLtexel *texel) {}
void FASTCALL __glNopGCCOLOR(__GLcontext* gc, __GLcolor *color, __GLtexel *texel) {}
void FASTCALL __glNopLight(__GLcontext*gc, GLint i, __GLvertex*v) {}
void FASTCALL __glNopExtract(__GLmipMapLevel *level, __GLtexture *tex,
                             GLint row, GLint col, __GLtexel *result) {}

void FASTCALL ComputeColorMaterialChange(__GLcontext *gc)
{
    gc->light.front.colorMaterialChange = 0;
    gc->light.back.colorMaterialChange  = 0;

    if (gc->modes.rgbMode
        && gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE)
    {
        GLuint colorMaterialChange;

        switch (gc->state.light.colorMaterialParam)
        {
        case GL_EMISSION:
            colorMaterialChange = __GL_MATERIAL_EMISSIVE;
            break;
        case GL_SPECULAR:
            colorMaterialChange = __GL_MATERIAL_SPECULAR;
            break;
        case GL_AMBIENT:
            colorMaterialChange = __GL_MATERIAL_AMBIENT;
            break;
        case GL_DIFFUSE:
            colorMaterialChange = __GL_MATERIAL_DIFFUSE;
            break;
        case GL_AMBIENT_AND_DIFFUSE:
            colorMaterialChange = __GL_MATERIAL_AMBIENT | __GL_MATERIAL_DIFFUSE;
            break;
        }

        if (gc->state.light.colorMaterialFace == GL_FRONT_AND_BACK
         || gc->state.light.colorMaterialFace == GL_FRONT)
            gc->light.front.colorMaterialChange = colorMaterialChange;

        if (gc->state.light.colorMaterialFace == GL_FRONT_AND_BACK
         || gc->state.light.colorMaterialFace == GL_BACK)
            gc->light.back.colorMaterialChange = colorMaterialChange;
    }
}

void FASTCALL __glGenericPickVertexProcs(__GLcontext *gc)
{
    GLuint enables = gc->state.enables.general;
    GLenum mvpMatrixType;
    __GLmatrix *m;

    m = &(gc->transform.modelView->mvp);
    mvpMatrixType = m->matrixType;

    /* Pick paClipCheck proc */
    //!!! are there better clip procs?
    if (gc->state.enables.clipPlanes)
    {
        gc->procs.paClipCheck  = PAClipCheckAll;
    }
    else
    {
        if (mvpMatrixType >= __GL_MT_IS2D &&
            m->matrix[3][2] >= -1.0f && m->matrix[3][2] <= 1.0f)
            gc->procs.paClipCheck = PAClipCheckFrustum2D;
        else
            gc->procs.paClipCheck = PAClipCheckFrustum;
    }
}

// Allocate the POLYDATA vertex buffer.
// Align the buffer on a cache line boundary

GLboolean FASTCALL PolyArrayAllocBuffer(__GLcontext *gc, GLuint nVertices)
{
    GLuint cjSize;

// Make sure that the vertex buffer holds a minimum number of vertices.

    if (nVertices < MINIMUM_POLYDATA_BUFFER_SIZE)
    {
        ASSERTOPENGL(FALSE, "vertex buffer too small\n");
        return GL_FALSE;
    }

// Allocate the vertex buffer.

    cjSize = (nVertices * sizeof(POLYDATA));

    if (!(gc->vertex.pdBuf = (POLYDATA *)GCALLOCALIGN32(gc, cjSize)))
        return GL_FALSE;

    gc->vertex.pdBufSizeBytes = cjSize;

    // Only (n-1) vertices are available for use.  The last one is reserved
    // by polyarray code.
    gc->vertex.pdBufSize = nVertices - 1;

// Initialize the vertex buffer.

    PolyArrayResetBuffer(gc);

    return GL_TRUE;
}

// Reset the color pointers in vertex buffer.
GLvoid FASTCALL PolyArrayResetBuffer(__GLcontext *gc)
{
    GLuint i;

    for (i = 0; i <= gc->vertex.pdBufSize; i++)
        gc->vertex.pdBuf[i].color = &gc->vertex.pdBuf[i].colors[__GL_FRONTFACE];
}

// Free the POLYDATA vertex buffer.
GLvoid FASTCALL PolyArrayFreeBuffer(__GLcontext *gc)
{
#ifdef _MCD_
    // If MCD, the POLYDATA vertex buffer is freed when the MCD context is
    // destroyed (see GenMcdDestroy).
    if (((__GLGENcontext *) gc)->_pMcdState)
        return;
#endif

    if (gc->vertex.pdBuf)
        GCFREEALIGN32(gc, gc->vertex.pdBuf);
    gc->vertex.pdBufSizeBytes = 0;
    gc->vertex.pdBufSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_texfi.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include <math.h>

/*
** Some math routines that are optimized in assembly
*/

#define __GL_FRAC(f)	        ((f) - __GL_FAST_FLOORF(f))

/************************************************************************/

// Repeats the given float value in float [0, scale) and converts to
// int.  The repeat count is an integer which is a power of two
#define REPEAT_SCALED_VAL(val, scale, repeat)                           \
    (__GL_FLOAT_GEZ(val) ? (FTOL((val) * (scale)) & ((repeat)-1)) :     \
     ((repeat)-1)-(FTOL(-(val) * (scale)) & ((repeat)-1)))
    
// Clamps the given float value to float [0, scale) and converts to int
#define CLAMP_SCALED_VAL(val, scale)                                    \
    (__GL_FLOAT_LEZ(val) ? 0 :                                          \
     __GL_FLOAT_COMPARE_PONE(val, >=) ? (FTOL(scale)-1) :               \
     FTOL((val) * (scale)))

/*
** Return texel nearest the s coordinate.  s is converted to u
** implicitly during this step.
*/
void FASTCALL __glNearestFilter1(__GLcontext *gc, __GLtexture *tex,
			__GLmipMapLevel *lp, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLtexel *result)
{
    GLint col;
    __GLfloat w2f;

    CHOP_ROUND_ON();
    
#ifdef __GL_LINT
    gc = gc;
    color = color;
    t = t;
#endif

    /* Find texel index */
    w2f = lp->width2f;
    if (tex->params.sWrapMode == GL_REPEAT) {
	col = REPEAT_SCALED_VAL(s, w2f, lp->width2);
    } else {
        col = CLAMP_SCALED_VAL(s, w2f);
    }

    CHOP_ROUND_OFF();
    
    /* Lookup texel */
    (*lp->extract)(lp, tex, 0, col, result);
}

/*
** Return texel nearest the s&t coordinates.  s&t are converted to u&v
** implicitly during this step.
*/
void FASTCALL __glNearestFilter2(__GLcontext *gc, __GLtexture *tex,
			__GLmipMapLevel *lp, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLtexel *result)
{
    GLint row, col;
    __GLfloat w2f, h2f;

    CHOP_ROUND_ON();
    
#ifdef __GL_LINT
    gc = gc;
    color = color;
#endif

    /* Find texel column address */
    w2f = lp->width2f;
    if (tex->params.sWrapMode == GL_REPEAT) {
	col = REPEAT_SCALED_VAL(s, w2f, lp->width2);
    } else {
        col = CLAMP_SCALED_VAL(s, w2f);
    }

    /* Find texel row address */
    h2f = lp->height2f;
    if (tex->params.tWrapMode == GL_REPEAT) {
	row = REPEAT_SCALED_VAL(t, h2f, lp->height2);
    } else {
        row = CLAMP_SCALED_VAL(t, h2f);
    }

    CHOP_ROUND_OFF();
    
    /* Lookup texel */
    (*lp->extract)(lp, tex, row, col, result);
}

/*
** Return texel which is a linear combination of texels near s.
*/
void FASTCALL __glLinearFilter1(__GLcontext *gc, __GLtexture *tex,
		       __GLmipMapLevel *lp, __GLcolor *color,
		       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, alpha, omalpha, w2f;
    GLint col0, col1;
    __GLtexel t0, t1;

#ifdef __GL_LINT
    color = color;
    t = t;
#endif

    /* Find col0 and col1 */
    w2f = lp->width2f;
    u = s * w2f;
    if (tex->params.sWrapMode == GL_REPEAT) {
	GLint w2mask = lp->width2 - 1;
	u -= __glHalf;
        col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
        col0 &= w2mask;
	col1 = (col0 + 1) & w2mask;
    } else {
	if (u < __glZero) u = __glZero;
	else if (u > w2f) u = w2f;
	u -= __glHalf;
	col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
	col1 = col0 + 1;
    }

    /* Calculate the final texel value as a combination of the two texels */
    (*lp->extract)(lp, tex, 0, col0, &t0);
    (*lp->extract)(lp, tex, 0, col1, &t1);

    omalpha = __glOne - alpha;
    switch (lp->baseFormat) {
      case GL_LUMINANCE_ALPHA:
	result->alpha = omalpha * t0.alpha + alpha * t1.alpha;
	/* FALLTHROUGH */
      case GL_LUMINANCE:
	result->luminance = omalpha * t0.luminance + alpha * t1.luminance;
	break;
      case GL_RGBA:
	result->alpha = omalpha * t0.alpha + alpha * t1.alpha;
	/* FALLTHROUGH */
      case GL_RGB:
	result->r = omalpha * t0.r + alpha * t1.r;
	result->g = omalpha * t0.g + alpha * t1.g;
	result->b = omalpha * t0.b + alpha * t1.b;
	break;
      case GL_ALPHA:
	result->alpha = omalpha * t0.alpha + alpha * t1.alpha;
	break;
      case GL_INTENSITY:
	result->intensity = omalpha * t0.intensity + alpha * t1.intensity;
	break;
    }
}

/*
** Return texel which is a linear combination of texels near s&t.
*/
void FASTCALL __glLinearFilter2(__GLcontext *gc, __GLtexture *tex,
		       __GLmipMapLevel *lp, __GLcolor *color,
		       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, v, alpha, beta, half, w2f, h2f;
    GLint col0, row0, col1, row1;
    __GLtexel t00, t01, t10, t11;
    __GLfloat omalpha, ombeta, m00, m01, m10, m11;

#ifdef __GL_LINT
    color = color;
#endif

    /* Find col0, col1 */
    w2f = lp->width2f;
    u = s * w2f;
    half = __glHalf;
    if (tex->params.sWrapMode == GL_REPEAT) {
	GLint w2mask = lp->width2 - 1;
	u -= half;
        col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
        col0 &= w2mask;
	col1 = (col0 + 1) & w2mask;
    } else {
	if (u < __glZero) u = __glZero;
	else if (u > w2f) u = w2f;
	u -= half;
	col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
	col1 = col0 + 1;
    }

    /* Find row0, row1 */
    h2f = lp->height2f;
    v = t * h2f;
    if (tex->params.tWrapMode == GL_REPEAT) {
	GLint h2mask = lp->height2 - 1;
	v -= half;
	row0 = (__GL_FAST_FLOORF_I(v));
        beta = v - (__GLfloat) row0; // Get fractional part
        row0 &= h2mask;
	row1 = (row0 + 1) & h2mask;
    } else {
	if (v < __glZero) v = __glZero;
	else if (v > h2f) v = h2f;
	v -= half;
	row0 = __GL_FAST_FLOORF_I(v);
        beta = v - (__GLfloat) row0; // Get fractional part
	row1 = row0 + 1;
    }

    /* Calculate the final texel value as a combination of the square chosen */
    (*lp->extract)(lp, tex, row0, col0, &t00);
    (*lp->extract)(lp, tex, row0, col1, &t10);
    (*lp->extract)(lp, tex, row1, col0, &t01);
    (*lp->extract)(lp, tex, row1, col1, &t11);

    omalpha = __glOne - alpha;
    ombeta = __glOne - beta;

    m00 = omalpha * ombeta;
    m10 = alpha * ombeta;
    m01 = omalpha * beta;
    m11 = alpha * beta;

    switch (lp->baseFormat) {
      case GL_LUMINANCE_ALPHA:
	/* FALLTHROUGH */
	result->alpha = m00*t00.alpha + m10*t10.alpha + m01*t01.alpha
	    + m11*t11.alpha;
      case GL_LUMINANCE:
	result->luminance = m00*t00.luminance + m10*t10.luminance
	    + m01*t01.luminance + m11*t11.luminance;
	break;
      case GL_RGBA:
	/* FALLTHROUGH */
	result->alpha = m00*t00.alpha + m10*t10.alpha + m01*t01.alpha
	    + m11*t11.alpha;
      case GL_RGB:
	result->r = m00*t00.r + m10*t10.r + m01*t01.r + m11*t11.r;
	result->g = m00*t00.g + m10*t10.g + m01*t01.g + m11*t11.g;
	result->b = m00*t00.b + m10*t10.b + m01*t01.b + m11*t11.b;
	break;
      case GL_ALPHA:
	result->alpha = m00*t00.alpha + m10*t10.alpha + m01*t01.alpha
	    + m11*t11.alpha;
	break;
      case GL_INTENSITY:
	result->intensity = m00*t00.intensity + m10*t10.intensity
	    + m01*t01.intensity + m11*t11.intensity;
	break;
    }
}

// Macros to convert unsigned byte rgb{a} to float

#define __glBGRByteToFloat( fdst, bsrc ) \
    (fdst)->b = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->g = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->r = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (bsrc)++;

#define __glBGRAByteToFloat( fdst, bsrc ) \
    (fdst)->b = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->g = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->r = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->a = __GL_UB_TO_FLOAT( *(bsrc)++ );

void FASTCALL __glLinearFilter2_BGR8Repeat(__GLcontext *gc, __GLtexture *tex,
                       __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, v, alpha, beta, half;
    GLint col, row, rowLen;
    __GLcolor t00, t01, t10, t11;
    __GLfloat omalpha, ombeta, m00, m01, m10, m11;
    GLint width2m1, height2m1;
    GLubyte *image, *pData;

#ifdef __GL_LINT
    color = color;
#endif

    half = __glHalf;
    width2m1 = lp->width2 - 1;
    height2m1 = lp->height2 - 1;

    /* Find col, compute alpha */

    u = (s * lp->width2f) - half;
    col = __GL_FAST_FLOORF_I(u);
    alpha = u - (__GLfloat) col; // Get fractional part
    col &= width2m1;

    /* Find row, compute beta */

    v = (t * lp->height2f) - half;
    row = __GL_FAST_FLOORF_I(v);
    beta = v - (__GLfloat) row;  // Get fractional part
    row &= height2m1;

    // Extract first texel at row, col

    pData = image = 
        (GLubyte *)lp->buffer + (((row << lp->widthLog2) + col) << 2);

    __glBGRByteToFloat( &t00, pData );

    // Extract remaining texels

    rowLen = lp->width2 << 2; // row length in bytes

    if( (row < height2m1) &&
        (col < width2m1) )
    {
        // Most common case - the texels are a compact block of 4
        // Next texel along row
        __glBGRByteToFloat( &t10, pData );
        // Up to next row...
        pData += (rowLen-8);
        __glBGRByteToFloat( &t01, pData );
        __glBGRByteToFloat( &t11, pData );
    } else {
        // Exceptional case : one or both of row, col are on edge
        GLint rowInc, colInc; // increments in bytes

        // Calc increments to next texel along row/col

        if( col < width2m1 ) 
            rowInc = 4;
        else
            // increment to left edge
            rowInc = -(rowLen - 4);

        if( row < height2m1 )
            // increment by row length
            colInc = rowLen;
        else
            // increment to lower edge
            colInc = - height2m1 * rowLen;

        // Next texel along row
        pData = image + rowInc;
        __glBGRByteToFloat( &t10, pData );

        // Second row, first texel
        pData = image + colInc;
        __glBGRByteToFloat( &t01, pData );

        // Next texel along row
        pData += (rowInc - 4);
        __glBGRByteToFloat( &t11, pData );
    }
    
    omalpha = __glOne - alpha;
    ombeta = __glOne - beta;

    m00 = omalpha * ombeta;
    m10 = alpha * ombeta;
    m01 = omalpha * beta;
    m11 = alpha * beta;

    result->r = m00*t00.r + m10*t10.r + m01*t01.r + m11*t11.r;
    result->g = m00*t00.g + m10*t10.g + m01*t01.g + m11*t11.g;
    result->b = m00*t00.b + m10*t10.b + m01*t01.b + m11*t11.b;
}

void FASTCALL __glLinearFilter2_BGRA8Repeat(__GLcontext *gc, __GLtexture *tex,
                       __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, v, alpha, beta, half;
    GLint col, row, rowLen;
    __GLcolor t00, t01, t10, t11;
    __GLfloat omalpha, ombeta, m00, m01, m10, m11;
    GLint width2m1, height2m1;
    GLubyte *image, *pData;

#ifdef __GL_LINT
    color = color;
#endif

    half = __glHalf;
    width2m1 = lp->width2 - 1;
    height2m1 = lp->height2 - 1;

    /* Find col, compute alpha */

    u = (s * lp->width2f) - half;
    col = __GL_FAST_FLOORF_I(u);
    alpha = u - (__GLfloat) col; // Get fractional part
    col &= width2m1;

    /* Find row, compute beta */

    v = (t * lp->height2f) - half;
    row = __GL_FAST_FLOORF_I(v);
    beta = v - (__GLfloat) row;  // Get fractional part
    row &= height2m1;

    // Extract first texel

    pData = image = 
        (GLubyte *)lp->buffer + (((row << lp->widthLog2) + col) << 2);

    // Extract the first texel at row, col
    __glBGRAByteToFloat( &t00, pData );

    // Extract remaining texels

    rowLen = lp->width2 << 2; // row length in bytes

    if( (row < height2m1) &&
        (col < width2m1) )
    {
        // Most common case - the texels are a compact block of 4
        // Next texel along row...
        __glBGRAByteToFloat( &t10, pData );
        // Up to next row...
        pData += (rowLen-8);
        __glBGRAByteToFloat( &t01, pData );
        __glBGRAByteToFloat( &t11, pData );
    } else {
        // Exceptional case : one or both of row, col are on edge
        GLint rowInc, colInc; // increments in bytes

        // Calc increments to next texel along row/col

        if( col < width2m1 ) 
            rowInc = 4;
        else
            // increment to left edge
            rowInc = -(rowLen - 4);

        if( row < height2m1 )
            // increment by row length
            colInc = rowLen;
        else
            // increment to lower edge
            colInc = - height2m1 * rowLen;

        // Next texel along row
        pData = image + rowInc;
        __glBGRAByteToFloat( &t10, pData );

        // Second row, first texel
        pData = image + colInc;
        __glBGRAByteToFloat( &t01, pData );

        // Next texel along row
        pData += (rowInc - 4);
        __glBGRAByteToFloat( &t11, pData );
    }
    
    omalpha = __glOne - alpha;
    ombeta = __glOne - beta;

    m00 = omalpha * ombeta;
    m10 = alpha * ombeta;
    m01 = omalpha * beta;
    m11 = alpha * beta;

    result->r = m00*t00.r + m10*t10.r + m01*t01.r + m11*t11.r;
    result->g = m00*t00.g + m10*t10.g + m01*t01.g + m11*t11.g;
    result->b = m00*t00.b + m10*t10.b + m01*t01.b + m11*t11.b;
    result->alpha = m00*t00.a + m10*t10.a + m01*t01.a + m11*t11.a;
}

/*
** Linear min/mag filter
*/
void FASTCALL __glLinearFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		      __GLcolor *color, __GLfloat s, __GLfloat t,
		      __GLtexel *result)
{
#ifdef __GL_LINT
    lod = lod;
#endif
    (*tex->linear)(gc, tex, &tex->level[0], color, s, t, result);
}

/*
** Nearest min/mag filter
*/
void FASTCALL __glNearestFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		       __GLcolor *color, __GLfloat s, __GLfloat t,
		       __GLtexel *result)
{
#ifdef __GL_LINT
    lod = lod;
#endif
    (*tex->nearest)(gc, tex, &tex->level[0], color, s, t, result);
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glNMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;

    if (lod <= ((__GLfloat)0.5)) {
	d = 0;
    } else {
	p = tex->p;
	d = FTOL(lod + ((__GLfloat)0.49995)); /* NOTE: .5 minus epsilon */
	if (d > p) {
	    d = p;
	}
    }
    lp = &tex->level[d];
    (*tex->nearest)(gc, tex, lp, color, s, t, result);
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glLMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;

    if (lod <= ((__GLfloat) 0.5)) {
	d = 0;
    } else {
	p = tex->p;
	d = FTOL(lod + ((__GLfloat) 0.49995)); /* NOTE: .5 minus epsilon */
	if (d > p) {
	    d = p;
	}
    }
    lp = &tex->level[d];
    (*tex->linear)(gc, tex, lp, color, s, t, result);
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glNMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;
    __GLtexel td, td1;
    __GLfloat f, omf;

    p = tex->p;
    d = (FTOL(lod)) + 1;
    if (d > p || d < 0) {
	/* Clamp d to last available mipmap */
	lp = &tex->level[p];
	(*tex->nearest)(gc, tex, lp, color, s, t, result);
    } else {
	(*tex->nearest)(gc, tex, &tex->level[d], color, s, t, &td);
	(*tex->nearest)(gc, tex, &tex->level[d-1], color, s, t, &td1);
	f = __GL_FRAC(lod);
	omf = __glOne - f;
	switch (tex->level[0].baseFormat) {
	  case GL_LUMINANCE_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_LUMINANCE:
	    result->luminance = omf * td1.luminance + f * td.luminance;
	    break;
	  case GL_RGBA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_RGB:
	    result->r = omf * td1.r + f * td.r;
	    result->g = omf * td1.g + f * td.g;
	    result->b = omf * td1.b + f * td.b;
	    break;
	  case GL_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    break;
	  case GL_INTENSITY:
	    result->intensity = omf * td1.intensity + f * td.intensity;
	    break;
	}
    }
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glLMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;
    __GLtexel td, td1;
    __GLfloat f, omf;

    p = tex->p;
    d = (FTOL(lod)) + 1;
    if (d > p || d < 0) {
	/* Clamp d to last available mipmap */
	lp = &tex->level[p];
	(*tex->linear)(gc, tex, lp, color, s, t, result);
    } else {
	(*tex->linear)(gc, tex, &tex->level[d], color, s, t, &td);
	(*tex->linear)(gc, tex, &tex->level[d-1], color, s, t, &td1);
	f = __GL_FRAC(lod);
	omf = __glOne - f;
	switch (tex->level[0].baseFormat) {
	  case GL_LUMINANCE_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_LUMINANCE:
	    result->luminance = omf * td1.luminance + f * td.luminance;
	    break;
	  case GL_RGBA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_RGB:
	    result->r = omf * td1.r + f * td.r;
	    result->g = omf * td1.g + f * td.g;
	    result->b = omf * td1.b + f * td.b;
	    break;
	  case GL_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    break;
	  case GL_INTENSITY:
	    result->intensity = omf * td1.intensity + f * td.intensity;
	    break;
	}
    }
}

/************************************************************************/

__GLfloat __glNopPolygonRho(__GLcontext *gc, const __GLshade *sh,
			    __GLfloat s, __GLfloat t, __GLfloat winv)
{
#ifdef __GL_LINT
    gc = gc;
    sh = sh;
    s = s;
    t = t;
    winv = winv;
#endif
    return __glZero;
}

/*
** Compute the "rho" (level of detail) parameter used by the texturing code.
** Instead of fully computing the derivatives compute nearby texture coordinates
** and discover the derivative.  The incoming s & t arguments have not
** been divided by winv yet.
*/
__GLfloat __glComputePolygonRho(__GLcontext *gc, const __GLshade *sh,
				__GLfloat s, __GLfloat t, __GLfloat qw)
{
    __GLfloat w0, w1, p0, p1;
    __GLfloat pupx, pupy, pvpx, pvpy;
    __GLfloat px, py, one;
    __GLtexture *tex = gc->texture.currentTexture;

    if( qw == (__GLfloat) 0.0 ) {
	return (__GLfloat) 0.0;
    }

    /* Compute partial of u with respect to x */
    one = __glOne;
    w0 = one / (qw - sh->dqwdx);
    w1 = one / (qw + sh->dqwdx);
    p0 = (s - sh->dsdx) * w0;
    p1 = (s + sh->dsdx) * w1;
    pupx = (p1 - p0) * tex->level[0].width2f;

    /* Compute partial of v with repsect to y */
    p0 = (t - sh->dtdx) * w0;
    p1 = (t + sh->dtdx) * w1;
    pvpx = (p1 - p0) * tex->level[0].height2f;

    /* Compute partial of u with respect to y */
    w0 = one / (qw - sh->dqwdy);
    w1 = one / (qw + sh->dqwdy);
    p0 = (s - sh->dsdy) * w0;
    p1 = (s + sh->dsdy) * w1;
    pupy = (p1 - p0) * tex->level[0].width2f;

    /* Figure partial of u&v with repsect to y */
    p0 = (t - sh->dtdy) * w0;
    p1 = (t + sh->dtdy) * w1;
    pvpy = (p1 - p0) * tex->level[0].height2f;

    /* Finally, figure sum of squares */
    px = pupx * pupx + pvpx * pvpx;
    py = pupy * pupy + pvpy * pvpy;

    /* Return largest value as the level of detail */
    if (px > py) {
	return px * ((__GLfloat) 0.25);
    } else {
	return py * ((__GLfloat) 0.25);
    }
}

__GLfloat __glNopLineRho(__GLcontext *gc, __GLfloat s, __GLfloat t, 
			 __GLfloat wInv)
{
#ifdef __GL_LINT
    gc = gc;
    s = s;
    t = t;
    wInv = wInv;
#endif
    return __glZero;
}

__GLfloat __glComputeLineRho(__GLcontext *gc, __GLfloat s, __GLfloat t, 
			     __GLfloat wInv)
{
    __GLfloat pspx, pspy, ptpx, ptpy;
    __GLfloat pupx, pupy, pvpx, pvpy;
    __GLfloat temp, pu, pv;
    __GLfloat magnitude, invMag, invMag2;
    __GLfloat dx, dy;
    __GLfloat s0w0, s1w1, t0w0, t1w1, w1Inv, w0Inv;
    const __GLvertex *v0 = gc->line.options.v0;
    const __GLvertex *v1 = gc->line.options.v1;

    /* Compute the length of the line (its magnitude) */
    dx = v1->window.x - v0->window.x;
    dy = v1->window.y - v0->window.y;
    magnitude = __GL_SQRTF(dx*dx + dy*dy);
    invMag = __glOne / magnitude;
    invMag2 = invMag * invMag;

    w0Inv = v0->window.w;
    w1Inv = v1->window.w;
    s0w0 = v0->texture.x * w0Inv;
    t0w0 = v0->texture.y * w0Inv;
    s1w1 = v1->texture.x * w1Inv;
    t1w1 = v1->texture.y * w1Inv;

    /* Compute s partials */
    temp = ((s1w1 - s0w0) - s * (w1Inv - w0Inv)) / wInv;
    pspx = temp * dx * invMag2;
    pspy = temp * dy * invMag2;

    /* Compute t partials */
    temp = ((t1w1 - t0w0) - t * (w1Inv - w0Inv)) / wInv;
    ptpx = temp * dx * invMag2;
    ptpy = temp * dy * invMag2;

    pupx = pspx * gc->texture.currentTexture->level[0].width2;
    pupy = pspy * gc->texture.currentTexture->level[0].width2;
    pvpx = ptpx * gc->texture.currentTexture->level[0].height2;
    pvpy = ptpy * gc->texture.currentTexture->level[0].height2;

    /* Now compute rho */
    pu = pupx * dx + pupy * dy;
    pu = pu * pu;
    pv = pvpx * dx + pvpy * dy;
    pv = pv * pv;
    return (pu + pv) * invMag2;
}

/************************************************************************/

/*
** Fast texture a fragment assumes that rho is noise - this is true
** when no mipmapping is being done and the min and mag filters are
** the same.
*/
void __glFastTextureFragment(__GLcontext *gc, __GLcolor *color,
			     __GLfloat s, __GLfloat t, __GLfloat rho)
{
    __GLtexture *tex = gc->texture.currentTexture;
    __GLtexel texel;

#ifdef __GL_LINT
    rho = rho;
#endif
    (*tex->magnify)(gc, tex, __glZero, color, s, t, &texel);
    (*tex->env)(gc, color, &texel);
}

/*
** Non-mipmapping texturing function.
*/
void __glTextureFragment(__GLcontext *gc, __GLcolor *color,
			 __GLfloat s, __GLfloat t, __GLfloat rho)
{
    __GLtexture *tex = gc->texture.currentTexture;
    __GLtexel texel;

    if (rho <= tex->c) {
	(*tex->magnify)(gc, tex, __glZero, color, s, t, &texel);
    } else {
	(*tex->minnify)(gc, tex, __glZero, color, s, t, &texel);
    }

    /* Now apply texture environment to get final color */
    (*tex->env)(gc, color, &texel);
}

void __glMipMapFragment(__GLcontext *gc, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLfloat rho)
{
    __GLtexture *tex = gc->texture.currentTexture;
    __GLtexel texel;

    /* In the spec c is given in terms of lambda.
    ** Here c is compared to rho (really rho^2) and adjusted accordingly.
    */
    if (rho <= tex->c) {
	/* NOTE: rho is ignored by magnify proc */
	(*tex->magnify)(gc, tex, rho, color, s, t, &texel);
    } else {
	if (rho) {
	    /* Convert rho to lambda */
	    /* This is an approximation of log base 2 */
            // Note that these approximations are inaccurate for rho < 1.0, but
            // rho is less than tex->c to get here.  Since currently tex->c is
            // a constant 1.0, this is not a problem.
            // This method directly manipulates the floating point binary
            // representation.

#define __GL_FLOAT_EXPONENT_ZERO \
    (__GL_FLOAT_EXPONENT_BIAS << __GL_FLOAT_EXPONENT_SHIFT)

            unsigned int lrho;
            LONG exponent;

            ASSERTOPENGL( rho >= 1.0f, "Log base 2 approximation not accurate");
            // Extract exponent
            lrho = CASTFIX(rho);
            exponent = ( (lrho & __GL_FLOAT_EXPONENT_MASK) 
                         >> __GL_FLOAT_EXPONENT_SHIFT )
                       - __GL_FLOAT_EXPONENT_BIAS;

            // Extract fractional part of the floating point number
            lrho &= ~__GL_FLOAT_EXPONENT_MASK; // dump current exponent
            lrho |= __GL_FLOAT_EXPONENT_ZERO;  // zap in zero exponent
            // Convert back to float, subtract implicit mantissa 1.0, and
            // add the exponent value to yield the approximation.
            rho = (CASTFLOAT(lrho) - 1.0f + (__GLfloat) exponent) * 0.5f;
	} else {
	    rho = __glZero;
	}
	(*tex->minnify)(gc, tex, rho, color, s, t, &texel);
    }

    /* Now apply texture environment to get final color */
    (*tex->env)(gc, color, &texel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_textu.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include <math.h>
#include <glmath.h>

/*
** Some math routines that are optimized in assembly
*/

#define __GL_M_LN2_INV		((__GLfloat) (1.0 / 0.69314718055994530942))
#define __GL_M_SQRT2		((__GLfloat) 1.41421356237309504880)

/************************************************************************/

__GLtextureParamState * FASTCALL __glLookUpTextureParams(__GLcontext *gc, GLenum target)
{
    switch (target) {
      case GL_TEXTURE_1D:
	return &gc->state.texture.texture[2].params;
      case GL_TEXTURE_2D:
	return &gc->state.texture.texture[3].params;
      default:
	return 0;
    }
}

__GLtextureObjectState * FASTCALL __glLookUpTextureTexobjs(__GLcontext *gc, 
						    GLenum target)
{
    switch (target) {
      case GL_TEXTURE_1D:
	return &gc->state.texture.texture[2].texobjs;
      case GL_TEXTURE_2D:
	return &gc->state.texture.texture[3].texobjs;
      default:
	return 0;
    }
}


__GLtexture * FASTCALL __glLookUpTexture(__GLcontext *gc, GLenum target)
{
    switch (target) {
      case GL_PROXY_TEXTURE_1D:
	return &gc->texture.texture[0]->map;
      case GL_PROXY_TEXTURE_2D:
	return &gc->texture.texture[1]->map;
      case GL_TEXTURE_1D:
	return &gc->texture.texture[2]->map;
      case GL_TEXTURE_2D:
        return &gc->texture.texture[3]->map;
      default:
	return 0;
    }
}

__GLtextureObject * FASTCALL __glLookUpTextureObject(__GLcontext *gc, GLenum target)
{
    switch (target) {
      case GL_TEXTURE_1D:
	return gc->texture.boundTextures[2];
      case GL_TEXTURE_2D:
	return gc->texture.boundTextures[3];
      default:
	return 0;
    }
}

/************************************************************************/

/*
 * Set palette subdivision parameters
 */
void FASTCALL __glSetPaletteSubdivision(__GLtexture *tex, GLsizei subdiv)
{
    tex->paletteSize = subdiv;
    tex->paletteDivShift = __glIntLog2(subdiv);
    tex->paletteDivision = (tex->paletteTotalSize >> tex->paletteDivShift)-1;
}

/*
 * Initialize palette portion of a texture
 */
GLboolean FASTCALL __glInitTexturePalette(__GLcontext *gc, __GLtexture *tex)
{
#ifdef GL_EXT_paletted_texture
    tex->paletteBaseFormat = GL_RGBA;
    tex->paletteRequestedFormat = GL_RGBA;
    tex->paletteTotalSize = 1;
    __glSetPaletteSubdivision(tex, tex->paletteTotalSize);
    tex->paletteTotalData = GCALLOC(gc, sizeof(RGBQUAD));
    tex->paletteData = tex->paletteTotalData;
    if (tex->paletteTotalData != NULL)
    {
        *(DWORD *)&tex->paletteTotalData[0] = 0xffffffff;
        return GL_TRUE;
    }
    else
    {
        return GL_FALSE;
    }
#else
    return GL_TRUE;
#endif
}

/*
** Initialize everything in a texture object except the textureMachine.
*/
GLboolean FASTCALL __glInitTextureObject(__GLcontext *gc,
                                         __GLtextureObject *texobj, 
                                         GLuint name, GLuint targetIndex)
{
    ASSERTOPENGL(NULL != texobj, "No texobj\n");
    texobj->targetIndex = targetIndex;
    texobj->resident = GL_FALSE;
    texobj->texture.map.texobjs.name = name;
    texobj->texture.map.texobjs.priority = 1.0;
    texobj->lowerPriority = NULL;
    texobj->higherPriority = NULL;
    texobj->loadKey = 0;
    return __glInitTexturePalette(gc, &texobj->texture.map);
}

void __glCleanupTexture(__GLcontext *gc, __GLtexture *tex,
                        GLboolean freeBuffers)
{
    GLint level, maxLevel;

    if (tex->level != NULL)
    {
        if (freeBuffers)
        {
            maxLevel = gc->constants.maxMipMapLevel;
            for (level = 0; level < maxLevel; level++)
            {
                if (tex->level[level].buffer != NULL)
                {
                    GCFREE(gc, tex->level[level].buffer);
                }
            }
        }
        
        GCFREE(gc, tex->level);
    }
#ifdef GL_EXT_paletted_texture
    if (tex->paletteTotalData != NULL)
    {
        GCFREE(gc, tex->paletteTotalData);
    }
#endif
}

GLvoid FASTCALL __glCleanupTexObj(__GLcontext *gc, void *pData)
{
    __GLtextureObject *texobj = (__GLtextureObject *)pData;

    // The last context to clean up shared state sets shared to NULL
    // so don't depend on it being non-NULL
    if (gc->texture.shared != NULL)
    {
        __glTexPriListRemove(gc, texobj, GL_TRUE);
    }
    __glCleanupTexture(gc, &texobj->texture.map, GL_TRUE);
    GCFREE(gc, texobj);
}

GLvoid WINAPIV __glDisposeTexObj(__GLcontext *gc, void *pData)
{
    __GLtextureObject *texobj = (__GLtextureObject *)pData;

#if DBG
    if (gc->texture.shared != NULL)
    {
        __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    }
#endif
    
    texobj->refcount--;
    ASSERTOPENGL(texobj->refcount >= 0, "Invalid refcount\n");

    if (texobj->refcount == 0) {
        __glCleanupTexObj(gc, pData);
    }
}

static __GLnamesArrayTypeInfo texTypeInfo =
{
    NULL,				/* ptr to empty data struct */
    sizeof(__GLtextureObject),	        /* dataSize */
    __glDisposeTexObj,		        /* free callback */
    NULL				/* alloc callback */
};

void FASTCALL __glEarlyInitTextureState(__GLcontext *gc)
{
    GLint numTextures, numEnvs;
    GLint i,maxMipMapLevel;
    __GLtextureObject *texobj;

    /* XXX Override device dependent values */
    gc->constants.numberOfTextures = 4;
    gc->constants.maxTextureSize = 1 << (gc->constants.maxMipMapLevel - 1);

    /* Allocate memory based on number of textures supported */
    numTextures = gc->constants.numberOfTextures;
    numEnvs = gc->constants.numberOfTextureEnvs;
    gc->state.texture.texture = (__GLperTextureState*)
	GCALLOCZ(gc, numTextures*sizeof(__GLperTextureState));
    gc->texture.texture = (__GLperTextureMachine**)
	GCALLOCZ(gc, numTextures*sizeof(__GLperTextureMachine*));
#ifdef NT
    if (gc->texture.texture == NULL)
    {
        return;
    }
#endif
    gc->state.texture.env = (__GLtextureEnvState*)
	GCALLOCZ(gc, numEnvs*sizeof(__GLtextureEnvState));
    /*
    ** Init texture object structures.
    ** The default textures need to be turned into texture objects
    ** and stored away in the namesArray so they can be retrieved.
    ** Normally a texture object has only one textureMachine allocated
    ** with it because it supports only one object.  The default texture
    ** texture object is special in that its textureMachine is an array
    ** of textureMachines, one for each target.
    */

    gc->texture.shared = GCALLOCZ(gc, sizeof(__GLsharedTextureState));
    if (gc->texture.shared == NULL)
    {
        return;
    }
    
    if (NULL == gc->texture.shared->namesArray) {
	gc->texture.shared->namesArray = __glNamesNewArray(gc, &texTypeInfo);
    }

    maxMipMapLevel = gc->constants.maxMipMapLevel;

    /*
    ** Set up the dummy texture objects for the default textures. 
    ** Because the default textures are not shared, they should
    ** not be hung off of the namesArray structure.
    */
    gc->texture.defaultTextures = (__GLtextureObject *)GCALLOCZ
		    (gc, numTextures*sizeof(__GLtextureObject));
    if (gc->texture.defaultTextures == NULL)
    {
        return;
    }

    /* allocate the boundTextures array */
    gc->texture.boundTextures = (__GLtextureObject **)GCALLOCZ
		    (gc, numTextures*sizeof(__GLtextureObject *));
    if (gc->texture.boundTextures == NULL)
    {
        return;
    }

    // Allocate DirectDraw texture surface pointers
    gc->texture.ddtex.pdds = (LPDIRECTDRAWSURFACE *)GCALLOCZ
        (gc, maxMipMapLevel*sizeof(LPDIRECTDRAWSURFACE));
    if (gc->texture.ddtex.pdds == NULL)
    {
        return;
    }

    if (!__glInitTextureObject(gc, &gc->texture.ddtex.texobj, __GL_TEX_DDRAW,
                               __GL_TEX_TARGET_INDEX_2D))
    {
        return;
    }
    gc->texture.ddtex.texobj.refcount = 1;
    gc->texture.ddtex.texobj.texture.map.level = (__GLmipMapLevel*)
        GCALLOCZ(gc, maxMipMapLevel*sizeof(__GLmipMapLevel));
    
    texobj = gc->texture.defaultTextures;
    for (i=0; i < numTextures; i++, texobj++) {
	__glInitTextureObject(gc, texobj, 0/*name*/, i/*targetIndex*/);
	ASSERTOPENGL(texobj->texture.map.texobjs.name == 0,
                     "Non-default texture at init time\n");
	/*
	** The refcount is unused because default textures aren't
	** shared.
	*/
	texobj->refcount = 1;
	/*
	** Install the default textures into the gc.
	*/
	gc->texture.texture[i] = &(texobj->texture);
	gc->texture.boundTextures[i] = texobj;

	/* Allocate memory based on max mipmap level supported */
	texobj->texture.map.level = (__GLmipMapLevel*)
	    GCALLOCZ(gc, maxMipMapLevel*sizeof(__GLmipMapLevel));
        if (texobj->texture.map.level == NULL)
        {
            return;
        }

        __glTexPriListAdd(gc, texobj, GL_TRUE);
    }
}

/*
** This routine is used to initialize a texture object. 
** Texture objects must be initialized exactly the way the default
** textures are initialized at startup of the library.
*/
void FASTCALL __glInitTextureMachine(__GLcontext *gc, GLuint targetIndex, 
                                     __GLperTextureMachine *ptm,
                                     GLboolean allocLevels)
{
    GLint level, maxMipMapLevel;

    ptm->map.gc = gc;
    /*
    ** Can't copy the params currently in the gc state.texture params,
    ** because they might not be at init conditions.
    */
    ptm->map.params.sWrapMode = GL_REPEAT;
    ptm->map.params.tWrapMode = GL_REPEAT;
    ptm->map.params.minFilter = GL_NEAREST_MIPMAP_LINEAR;
    ptm->map.params.magFilter = GL_LINEAR;
    switch (targetIndex) {
      case 0:
	ptm->map.dim = 1;
	ptm->map.createLevel = __glCreateProxyLevel;
	break;
      case 1:
	ptm->map.dim = 2;
	ptm->map.createLevel = __glCreateProxyLevel;
	break;
      case 2:
	ptm->map.dim = 1;
	ptm->map.createLevel = __glCreateLevel;
	break;
      case 3:
	ptm->map.dim = 2;
	ptm->map.createLevel = __glCreateLevel;
	break;
      default:
	break;
    }

    maxMipMapLevel = gc->constants.maxMipMapLevel;

    if (allocLevels)
    {
        ptm->map.level = (__GLmipMapLevel*)
	    GCALLOCZ(gc, maxMipMapLevel*sizeof(__GLmipMapLevel));
        if (ptm->map.level == NULL)
        {
            return;
        }
    }

    /* Init each texture level */
    for (level = 0; level < maxMipMapLevel; level++) {
	ptm->map.level[level].requestedFormat = 1;
    }

}

void FASTCALL __glInitTextureState(__GLcontext *gc)
{
    __GLperTextureState *pts;
    __GLtextureEnvState *tes;
    __GLperTextureMachine **ptm;
    GLint i, numTextures, numEnvs;

    numTextures = gc->constants.numberOfTextures;
    numEnvs = gc->constants.numberOfTextureEnvs;

    gc->state.current.texture.w = __glOne;

    /* Init each texture environment state */
    tes = &gc->state.texture.env[0];
    for (i = 0; i < numEnvs; i++, tes++) {
	tes->mode = GL_MODULATE;
    }

    /* Init each textures state */
    pts = &gc->state.texture.texture[0];
    ptm = gc->texture.texture;
    for (i = 0; i < numTextures; i++, pts++, ptm++) {
        /* Init client state */
	pts->texobjs.name = 0;
	pts->texobjs.priority = 1.0;

        /* Init machine state */
        __glInitTextureMachine(gc, i, *ptm, GL_FALSE);
	pts->params = (*ptm)->map.params;
    }

    /* Init rest of texture state */
    gc->state.texture.s.mode = GL_EYE_LINEAR;
    gc->state.texture.s.eyePlaneEquation.x = __glOne;
    gc->state.texture.s.objectPlaneEquation.x = __glOne;
    gc->state.texture.t.mode = GL_EYE_LINEAR;
    gc->state.texture.t.eyePlaneEquation.y = __glOne;
    gc->state.texture.t.objectPlaneEquation.y = __glOne;
    gc->state.texture.r.mode = GL_EYE_LINEAR;
    gc->state.texture.q.mode = GL_EYE_LINEAR;

    // Initialize DirectDraw texture
    __glInitTextureMachine(gc, __GL_TEX_TARGET_INDEX_2D,
                           &gc->texture.ddtex.texobj.texture, GL_FALSE);
}

void __glFreeSharedTextureState(__GLcontext *gc)
{
#ifdef NT
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    gc->texture.shared->namesArray->refcount--;
    if (gc->texture.shared->namesArray->refcount == 0)
    {
        __GLsharedTextureState *shared;
        
        __glTexPriListUnloadAll(gc);
        
        // NULL the shared pointer first, preventing its reuse
        // after we unlock it.  We need to unlock before we free it
        // because the critical section will be cleaned up in the
        // free
        shared = gc->texture.shared;
        gc->texture.shared = NULL;
        __glNamesFreeArray(gc, shared->namesArray);
        GCFREE(gc, shared);
    }
    else
    {
        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
        gc->texture.shared = NULL;
    }
#else
    gc->texture.namesArray->refcount--;
    if (gc->texture.namesArray->refcount == 0)
    {
        __glNamesFreeArray(gc, gc->texture.namesArray);
    }
    gc->texture.namesArray = NULL;
#endif
}

void FASTCALL __glFreeTextureState(__GLcontext *gc)
{
    __GLperTextureMachine **ptm;
    GLint i, level, numTextures;

    /*
    ** Clean up all allocs associated with texture objects.
    */

    numTextures = gc->constants.numberOfTextures;
    ptm = gc->texture.texture;
    for (i = 0; i < numTextures; i++, ptm++)
    {
        // If the texture selected is a texture object, unbind it
        // This protects any shared texture objects plus it selects
        // the default texture so it gets cleaned up
        if ( (*ptm) != NULL)
        {
            if ((*ptm)->map.texobjs.name != 0)
            {
                __glBindTexture(gc, i, 0, GL_FALSE);
            }
            ASSERTOPENGL((*ptm)->map.texobjs.name == 0,
                         "Texture object still bound during cleanup");
        }
      
        // Pull the default texture out of the priority list.
        // If we failed partway through initialization we may not
        // have added the texture to the list so we need to check
        // whether it is appropriate to call remove.
        if (gc->texture.defaultTextures != NULL)
        {
            if (gc->texture.defaultTextures[i].texture.map.level != NULL)
            {
                __glTexPriListRemove(gc, gc->texture.defaultTextures+i,
                                     GL_FALSE);
            }
        }
        
        if ( (*ptm) != NULL)
        {
            __glCleanupTexture(gc, &(*ptm)->map, GL_TRUE);
        }
    }
    
    __glFreeSharedTextureState(gc);

    GCFREE(gc, gc->texture.texture);
    GCFREE(gc, gc->texture.boundTextures);
    GCFREE(gc, gc->texture.defaultTextures);
    GCFREE(gc, gc->state.texture.texture);
    GCFREE(gc, gc->state.texture.env);
    gc->texture.texture = NULL;
    gc->texture.boundTextures = NULL;
    gc->texture.defaultTextures = NULL;
    gc->state.texture.texture = NULL;
    gc->state.texture.env = NULL;

    // Free DirectDraw texture state
    GCFREE(gc, gc->texture.ddtex.pdds);
    gc->texture.ddtex.pdds = NULL;
    __glCleanupTexture(gc, &gc->texture.ddtex.texobj.texture.map, GL_FALSE);
}

/************************************************************************/

void APIPRIVATE __glim_TexGenfv(GLenum coord, GLenum pname, const GLfloat pv[])
{
    __GLtextureCoordState *tcs;
    __GLtransform *tr;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S: tcs = &gc->state.texture.s; break;
      case GL_T: tcs = &gc->state.texture.t; break;
      case GL_R: tcs = &gc->state.texture.r; break;
      case GL_Q: tcs = &gc->state.texture.q; break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	switch (((GLenum) FTOL(pv[0]))) {
	  case GL_EYE_LINEAR:
	  case GL_OBJECT_LINEAR:
	    tcs->mode = (GLenum) FTOL(pv[0]);
            break;
	  case GL_SPHERE_MAP:
	    if ((coord == GL_R) || (coord == GL_Q)) {
		__glSetError(GL_INVALID_ENUM);
		return;
	    }
	    tcs->mode = (GLenum) FTOL(pv[0]);
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_OBJECT_PLANE:
	tcs->objectPlaneEquation.x = pv[0];
	tcs->objectPlaneEquation.y = pv[1];
	tcs->objectPlaneEquation.z = pv[2];
	tcs->objectPlaneEquation.w = pv[3];
	break;
      case GL_EYE_PLANE:
#ifdef NT
	tr = gc->transform.modelView;
	if (tr->flags & XFORM_UPDATE_INVERSE)
	    __glComputeInverseTranspose(gc, tr);
	(*tr->inverseTranspose.xf4)(&tcs->eyePlaneEquation, pv,
				    &tr->inverseTranspose);
#else
	/*XXX transform should not be in generic code */
        tcs->eyePlaneSet.x = pv[0];
        tcs->eyePlaneSet.y = pv[1];
        tcs->eyePlaneSet.z = pv[2];
        tcs->eyePlaneSet.w = pv[3];
	tr = gc->transform.modelView;
	if (tr->flags & XFORM_UPDATE_INVERSE) {
	    (*gc->procs.computeInverseTranspose)(gc, tr);
	}
	(*tr->inverseTranspose.xf4)(&tcs->eyePlaneEquation,
                                    &tcs->eyePlaneSet.x,
				    &tr->inverseTranspose);
#endif
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    __GL_DELAY_VALIDATE(gc);
    MCD_STATE_DIRTY(gc, TEXGEN);
}

/************************************************************************/

void APIPRIVATE __glim_TexParameterfv(GLenum target, GLenum pname, const GLfloat pv[])
{
    __GLtextureParamState *pts;
    GLenum e;
    GLboolean bTexState = GL_TRUE;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
      bad_enum:
        bTexState = GL_FALSE;
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	switch (e = (GLenum) FTOL(pv[0])) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->sWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_WRAP_T:
	switch (e = (GLenum) FTOL(pv[0])) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->tWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MIN_FILTER:
	switch (e = (GLenum)FTOL(pv[0])) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	  case GL_NEAREST_MIPMAP_NEAREST:
	  case GL_LINEAR_MIPMAP_NEAREST:
	  case GL_NEAREST_MIPMAP_LINEAR:
	  case GL_LINEAR_MIPMAP_LINEAR:
	    pts->minFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MAG_FILTER:
	switch (e = (GLenum)FTOL(pv[0])) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	    pts->magFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_BORDER_COLOR:
	__glClampColorf(gc, &pts->borderColor, pv);
	break;
      
      case GL_TEXTURE_PRIORITY:
	{
	    __GLtextureObject *texobj;
	    __GLtextureObjectState *ptos;

	    ptos = __glLookUpTextureTexobjs(gc, target);
            ptos->priority = __glClampf(pv[0], __glZero, __glOne);
            
	    texobj = __glLookUpTextureObject(gc, target);
	    texobj->texture.map.texobjs.priority = ptos->priority;
            __glTexPriListChangePriority(gc, texobj, GL_TRUE);
        }
        bTexState = GL_FALSE;
	break;

      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);

#ifdef _MCD_
    if (bTexState &&
        gc->texture.currentTexture &&
        (pts == &gc->texture.currentTexture->params))
    {
        MCD_STATE_DIRTY(gc, TEXTURE);
    }
#endif
}

void APIPRIVATE __glim_TexParameteriv(GLenum target, GLenum pname, const GLint pv[])
{
    __GLtextureParamState *pts;
    GLenum e;
    GLboolean bTexState = GL_TRUE;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
      bad_enum:
        bTexState = GL_FALSE;
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	switch (e = (GLenum) pv[0]) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->sWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_WRAP_T:
	switch (e = (GLenum) pv[0]) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->tWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MIN_FILTER:
	switch (e = (GLenum) pv[0]) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	  case GL_NEAREST_MIPMAP_NEAREST:
	  case GL_LINEAR_MIPMAP_NEAREST:
	  case GL_NEAREST_MIPMAP_LINEAR:
	  case GL_LINEAR_MIPMAP_LINEAR:
	    pts->minFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MAG_FILTER:
	switch (e = (GLenum) pv[0]) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	    pts->magFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_BORDER_COLOR:
	__glClampColori(gc, &pts->borderColor, pv);
	break;
      case GL_TEXTURE_PRIORITY:
	{
	    __GLfloat priority;
	    __GLtextureObjectState *ptos;
	    __GLtextureObject *texobj;
            
	    ptos = __glLookUpTextureTexobjs(gc, target);
	    priority = __glClampf(__GL_I_TO_FLOAT(pv[0]), __glZero, __glOne);
	    ptos->priority = priority;

	    texobj = __glLookUpTextureObject(gc, target);
	    texobj->texture.map.texobjs.priority = priority;
            __glTexPriListChangePriority(gc, texobj, GL_TRUE);
	}
        bTexState = GL_FALSE;
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);

#ifdef _MCD_
    if (bTexState &&
        gc->texture.currentTexture &&
        (pts == &gc->texture.currentTexture->params))
    {
        MCD_STATE_DIRTY(gc, TEXTURE);
    }
#endif
}

/************************************************************************/

void APIPRIVATE __glim_TexEnvfv(GLenum target, GLenum pname, const GLfloat pv[])
{
    __GLtextureEnvState *tes;
    GLenum e;
    __GL_SETUP_NOT_IN_BEGIN();

    
    if(target < GL_TEXTURE_ENV) {
      __glSetError(GL_INVALID_ENUM);
      return;
    }
    target -= GL_TEXTURE_ENV;
#ifdef NT
    // target is unsigned!
    if (target >= (GLenum) gc->constants.numberOfTextureEnvs) {
#else
    if (target >= gc->constants.numberOfTextureEnvs) {
#endif // NT
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    tes = &gc->state.texture.env[target];

    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	switch(e = (GLenum) FTOL(pv[0])) {
	  case GL_MODULATE:
	  case GL_DECAL:
	  case GL_BLEND:
	  case GL_REPLACE:
	    tes->mode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glClampAndScaleColorf(gc, &tes->color, pv);
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);
    MCD_STATE_DIRTY(gc, TEXENV);
}

void APIPRIVATE __glim_TexEnviv(GLenum target, GLenum pname, const GLint pv[])
{
    __GLtextureEnvState *tes;
    GLenum e;
    __GL_SETUP_NOT_IN_BEGIN();


    if(target < GL_TEXTURE_ENV) {
      __glSetError(GL_INVALID_ENUM);
      return;
    }
    target -= GL_TEXTURE_ENV;
#ifdef NT
    // target is unsigned!
    if (target >= (GLenum) gc->constants.numberOfTextureEnvs) {
#else
    if (target >= gc->constants.numberOfTextureEnvs) {
#endif // NT
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    tes = &gc->state.texture.env[target];

    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	switch(e = (GLenum) pv[0]) {
	  case GL_MODULATE:
	  case GL_DECAL:
	  case GL_BLEND:
	  case GL_REPLACE:
	    tes->mode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glClampAndScaleColori(gc, &tes->color, pv);
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);
    MCD_STATE_DIRTY(gc, TEXENV);
}

/************************************************************************/

GLboolean FASTCALL __glIsTextureConsistent(__GLcontext *gc, GLenum name)
{
    __GLtexture *tex = __glLookUpTexture(gc, name);
    __GLtextureParamState *params = __glLookUpTextureParams(gc, name);
    GLint i, width, height;
    GLint maxLevel;
    GLint border;
    GLenum baseFormat;
    GLenum requestedFormat;

    if ((tex->level[0].width == 0) || (tex->level[0].height == 0)) {
	return GL_FALSE;
    }

    border = tex->level[0].border;
    width = tex->level[0].width - border*2;
    height = tex->level[0].height - border*2;
    maxLevel = gc->constants.maxMipMapLevel;
    baseFormat = tex->level[0].baseFormat;
    requestedFormat = tex->level[0].requestedFormat;

    switch(gc->state.texture.env[0].mode) {
      case GL_DECAL:
	if (baseFormat != GL_RGB && baseFormat != GL_RGBA) {
	    return GL_FALSE;
	}
	break;
      default:
	break;
    }

    /* If not-mipmapping, we are ok */
    switch (params->minFilter) {
      case GL_NEAREST:
      case GL_LINEAR:
	return GL_TRUE;
      default:
	break;
    }

    i = 0;
    while (++i < maxLevel) {
	if (width == 1 && height == 1) break;
	width >>= 1;
	if (width == 0) width = 1;
	height >>= 1;
	if (height == 0) height = 1;

	if (tex->level[i].border != border ||
            (GLenum)tex->level[i].requestedFormat != requestedFormat ||
            tex->level[i].width != width + border*2 ||
            tex->level[i].height != height + border*2)
        {
	    return GL_FALSE;
	}
    }

    return GL_TRUE;
}

/***********************************************************************/

#ifdef GL_WIN_multiple_textures
void APIPRIVATE __glim_CurrentTextureIndexWIN(GLuint index)
{
}

void APIPRIVATE __glim_NthTexCombineFuncWIN(GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_texfn.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

/* 1 Component modulate */
void FASTCALL __glTextureModulateL(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->luminance * color->r;
    color->g = texel->luminance * color->g;
    color->b = texel->luminance * color->b;
}

/* 2 Component modulate */
void FASTCALL __glTextureModulateLA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->luminance * color->r;
    color->g = texel->luminance * color->g;
    color->b = texel->luminance * color->b;
    color->a = texel->alpha * color->a;
}

/* 3 Component modulate */
void FASTCALL __glTextureModulateRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->r * color->r;
    color->g = texel->g * color->g;
    color->b = texel->b * color->b;
}

/* 4 Component modulate */
void FASTCALL __glTextureModulateRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->r * color->r;
    color->g = texel->g * color->g;
    color->b = texel->b * color->b;
    color->a = texel->alpha * color->a;
}

/* Alpha modulate */
void FASTCALL __glTextureModulateA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->a = texel->alpha * color->a;
}

/* Intensity modulate */
void FASTCALL __glTextureModulateI(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->intensity * color->r;
    color->g = texel->intensity * color->g;
    color->b = texel->intensity * color->b;
    color->a = texel->intensity * color->a;
}

/***********************************************************************/

/* 3 Component decal */
void FASTCALL __glTextureDecalRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->r * gc->frontBuffer.redScale;
    color->g = texel->g * gc->frontBuffer.greenScale;
    color->b = texel->b * gc->frontBuffer.blueScale;
}

/* 4 Component decal */
void FASTCALL __glTextureDecalRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat a = texel->alpha;
    __GLfloat oma = __glOne - a;

    color->r = oma * color->r
	+ a * texel->r * gc->frontBuffer.redScale;
    color->g = oma * color->g
	+ a * texel->g * gc->frontBuffer.greenScale;
    color->b = oma * color->b
	+ a * texel->b * gc->frontBuffer.blueScale;
}

/***********************************************************************/

/* 1 Component blend */
void FASTCALL __glTextureBlendL(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat l = texel->luminance;
    __GLfloat oml = __glOne - l;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = oml * color->r + l * cc->r;
    color->g = oml * color->g + l * cc->g;
    color->b = oml * color->b + l * cc->b;
}

/* 2 Component blend */
void FASTCALL __glTextureBlendLA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat l = texel->luminance;
    __GLfloat oml = __glOne - l;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = oml * color->r + l * cc->r;
    color->g = oml * color->g + l * cc->g;
    color->b = oml * color->b + l * cc->b;
    color->a = texel->alpha * color->a;
}

/* 3 Component blend */
void FASTCALL __glTextureBlendRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat r = texel->r;
    __GLfloat g = texel->g;
    __GLfloat b = texel->b;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = (__glOne - r) * color->r + r * cc->r;
    color->g = (__glOne - g) * color->g + g * cc->g;
    color->b = (__glOne - b) * color->b + b * cc->b;
}

/* 4 Component blend */
void FASTCALL __glTextureBlendRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat r = texel->r;
    __GLfloat g = texel->g;
    __GLfloat b = texel->b;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = (__glOne - r) * color->r + r * cc->r;
    color->g = (__glOne - g) * color->g + g * cc->g;
    color->b = (__glOne - b) * color->b + b * cc->b;
    color->a = texel->alpha * color->a;
}

/* Alpha blend */
void FASTCALL __glTextureBlendA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->a = texel->alpha * color->a;
}

/* Intensity blend */
void FASTCALL __glTextureBlendI(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat i = texel->intensity;
    __GLfloat omi = __glOne - i;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = omi * color->r + i * cc->r;
    color->g = omi * color->g + i * cc->g;
    color->b = omi * color->b + i * cc->b;
    color->a = omi * color->a + i * cc->a;
}

/***********************************************************************/

/* 1 Component replace */
void FASTCALL __glTextureReplaceL(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->luminance * gc->frontBuffer.redScale;
    color->g = texel->luminance * gc->frontBuffer.greenScale;
    color->b = texel->luminance * gc->frontBuffer.blueScale;
}

/* 2 Component replace */
void FASTCALL __glTextureReplaceLA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->luminance * gc->frontBuffer.redScale;
    color->g = texel->luminance * gc->frontBuffer.greenScale;
    color->b = texel->luminance * gc->frontBuffer.blueScale;
    color->a = texel->alpha * gc->frontBuffer.alphaScale;
}

/* 3 Component replace */
void FASTCALL __glTextureReplaceRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->r * gc->frontBuffer.redScale;
    color->g = texel->g * gc->frontBuffer.greenScale;
    color->b = texel->b * gc->frontBuffer.blueScale;
}

/* 4 Component replace */
void FASTCALL __glTextureReplaceRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->r * gc->frontBuffer.redScale;
    color->g = texel->g * gc->frontBuffer.greenScale;
    color->b = texel->b * gc->frontBuffer.blueScale;
    color->a = texel->alpha * gc->frontBuffer.alphaScale;
}

/* Alpha replace */
void FASTCALL __glTextureReplaceA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->a = texel->alpha * gc->frontBuffer.alphaScale;
}

/* Intensity replace */
void FASTCALL __glTextureReplaceI(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->intensity * gc->frontBuffer.redScale;
    color->g = texel->intensity * gc->frontBuffer.greenScale;
    color->b = texel->intensity * gc->frontBuffer.blueScale;
    color->a = texel->intensity * gc->frontBuffer.alphaScale;
}

/************************************************************************/

/*
** Get a texture element out of the one component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelL(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->luminance = tex->params.borderColor.r;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col);
	result->luminance = image[0];
    }
}

/*
** Get a texture element out of the two component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelLA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->luminance = tex->params.borderColor.r;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col) * 2;
	result->luminance = image[0];
	result->alpha = image[1];
    }
}

/*
** Get a texture element out of the three component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelRGB(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col) * 3;
	result->r = image[0];
	result->g = image[1];
	result->b = image[2];
    }
}

/*
** Get a texture element out of the four component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelRGBA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col) * 4;
	result->r = image[0];
	result->g = image[1];
	result->b = image[2];
	result->alpha = image[3];
    }
}

void FASTCALL __glExtractTexelA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->alpha = tex->params.borderColor.a;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col);
	result->alpha = image[0];
    }
}

void FASTCALL __glExtractTexelI(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->intensity = tex->params.borderColor.r;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col);
	result->intensity = image[0];
    }
}

void FASTCALL __glExtractTexelBGR8(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col) * 4;
	result->r = __GL_UB_TO_FLOAT(image[2]);
	result->g = __GL_UB_TO_FLOAT(image[1]);
	result->b = __GL_UB_TO_FLOAT(image[0]);
    }
}

void FASTCALL __glExtractTexelBGRA8(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col) * 4;
	result->r = __GL_UB_TO_FLOAT(image[2]);
	result->g = __GL_UB_TO_FLOAT(image[1]);
	result->b = __GL_UB_TO_FLOAT(image[0]);
	result->alpha = __GL_UB_TO_FLOAT(image[3]);
    }
}

#ifdef GL_EXT_paletted_texture
void FASTCALL __glExtractTexelPI8BGRA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
	result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
    }
}

void FASTCALL __glExtractTexelPI8BGR(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    }
}

void FASTCALL __glExtractTexelPI16BGRA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = (GLushort *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
	result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
    }
}

void FASTCALL __glExtractTexelPI16BGR(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = (GLushort *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    }
}
#endif // GL_EXT_paletted_texture

/*
** Get a texture element out of the one component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelL_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col);
    result->luminance = image[0];
}

/*
** Get a texture element out of the two component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelLA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = leve