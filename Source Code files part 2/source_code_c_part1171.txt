dwReturnedCount != sizeof(CACHELIST_ITEM))
    {
        dprintf("Size of process memory read != requested(CACHELIST_ITEM\n");

        goto errRtn;
    }

    pCacheListItem = (CACHELIST_ITEM *)blockCacheListItem;

    if (pCacheListItem->lpCacheNode != NULL)
    {
        blockCacheNode = new char[sizeof(CCacheNode)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pCacheListItem->lpCacheNode,
                    blockCacheNode,
                    sizeof(CCacheNode),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CCacheNode \n");
            dprintf("at address %x\n", pCacheListItem->lpCacheNode);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CCacheNode))
        {
            dprintf("Size of process memory read != requested (CCacheNode)\n");

            goto errRtn;
        }

        pCacheListItem->lpCacheNode = (CCacheNode*)blockCacheNode;

        // need to get the OlePresObjs for the CCacheNode
        if (pCacheListItem->lpCacheNode->m_pPresObj != NULL)
        {
            switch (pCacheListItem->lpCacheNode->m_dwPresFlag)
            {
            case CN_PRESOBJ_GEN:
                dwSizeOfPresObj = sizeof(CGenObject);
                break;
            case CN_PRESOBJ_MF:
                dwSizeOfPresObj = sizeof(CMfObject);
                break;
            case CN_PRESOBJ_EMF:
                dwSizeOfPresObj = sizeof(CEMfObject);
                break;
            default:
                dprintf("Error: can not determine size of IOlePresObj\n");
                return;
            }

            blockPresObj = new char[dwSizeOfPresObj];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pCacheListItem->lpCacheNode->m_pPresObj,
                        blockPresObj,
                        dwSizeOfPresObj,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                dprintf("at address %x\n", pCacheListItem->lpCacheNode->m_pPresObj);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != dwSizeOfPresObj)
            {
                dprintf("Size of process memory read != requested (IPresObj)\n");

                goto errRtn;
            }

            pCacheListItem->lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
        }

        if (pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze != NULL)
        {
            switch (pCacheListItem->lpCacheNode->m_dwPresFlag)
            {
            case CN_PRESOBJ_GEN:
                dwSizeOfPresObj = sizeof(CGenObject);
                break;
            case CN_PRESOBJ_MF:
                dwSizeOfPresObj = sizeof(CMfObject);
                break;
            case CN_PRESOBJ_EMF:
                dwSizeOfPresObj = sizeof(CEMfObject);
                break;
            default:
                dprintf("Error: can not determine size of IOlePresObj\n");
                return;
            }

            blockPresObjAF = new char[dwSizeOfPresObj];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze,
                        blockPresObjAF,
                        dwSizeOfPresObj,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                dprintf("at address %x\n", pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != dwSizeOfPresObj)
            {
                dprintf("Size of process memory read != requested (IOlePresObj)\n");

                goto errRtn;
            }

            pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObjAF;
        }
    }

    // dump the structure
    pszCacheListItem = DumpCACHELIST_ITEM(pCacheListItem, NO_PREFIX, 1);

    dprintf("CACHELIST_ITEM @ 0x%x\n", dwAddr);
    dprintfx(pszCacheListItem);

    CoTaskMemFree(pszCacheListItem);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockPresObj;
    delete[] blockPresObjAF;
    delete[] blockCacheNode;
    delete[] blockCacheListItem;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cacheenum, exported
//
//  Synopsis:   dumps CCacheEnum object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cacheenum)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszCE;
    char            *blockCE    = NULL;
    CCacheEnum      *pCE        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CCacheEnum\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCE = new char[sizeof(CCacheEnum)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCE,
                sizeof(CCacheEnum),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CCacheEnum \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CCacheEnum))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCE = (CCacheEnum *)blockCE;

    // dump the structure
    pszCE = DumpCCacheEnum(pCE, NO_PREFIX, 1);

    dprintf("CCacheEnum @ 0x%x\n", dwAddr);
    dprintfx(pszCE);

    CoTaskMemFree(pszCE);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockCE;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cacheenumformatetc, exported
//
//  Synopsis:   dumps CCacheEnumFormatEtc object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cacheenumformatetc)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszCacheEnumFormatEtc;
    char                *blockCacheEnumFormatEtc   = NULL;
    CCacheEnumFormatEtc *pCacheEnumFormatEtc       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CCacheEnumFormatEtc\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCacheEnumFormatEtc = new char[sizeof(CCacheEnumFormatEtc)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCacheEnumFormatEtc,
                sizeof(CCacheEnumFormatEtc),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory CacheEnumFormatEtc");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CCacheEnumFormatEtc))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCacheEnumFormatEtc = (CCacheEnumFormatEtc *)blockCacheEnumFormatEtc;

    // dump the structure
    pszCacheEnumFormatEtc = DumpCCacheEnumFormatEtc(pCacheEnumFormatEtc, NO_PREFIX, 1);

    dprintf("CCacheEnumFormatEtc @ 0x%x\n", dwAddr);
    dprintfx(pszCacheEnumFormatEtc);

    CoTaskMemFree(pszCacheEnumFormatEtc);

errRtn:

    delete[] blockCacheEnumFormatEtc;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cachenode, exported
//
//  Synopsis:   dumps CCacheNode object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cachenode)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount     = 0;
    char            *pszCacheNode       = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    char            *blockPresObjAF     = NULL;
    CCacheNode      *pCacheNode         = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CCacheNode\n");
        return;
    }

    // get the CCacheNode block of mem
    blockCacheNode = new char[sizeof(CCacheNode)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCacheNode,
                sizeof(CCacheNode),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CCacheNode \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CCacheNode))
    {
        dprintf("Size of process memory read != requested (CCacheNode)\n");

        goto errRtn;
    }

    pCacheNode = (CCacheNode*)blockCacheNode;

    // need to get the OlePresObjs for the CCacheNode
    if (pCacheNode->m_pPresObj != NULL)
    {
        switch (pCacheNode->m_dwPresFlag)
        {
        case CN_PRESOBJ_GEN:
            dwSizeOfPresObj = sizeof(CGenObject);
            break;
        case CN_PRESOBJ_MF:
            dwSizeOfPresObj = sizeof(CMfObject);
            break;
        case CN_PRESOBJ_EMF:
            dwSizeOfPresObj = sizeof(CEMfObject);
            break;
        default:
            dprintf("Error: can not determine size of IOlePresObj\n");
            return;
        }

        blockPresObj = new char[dwSizeOfPresObj];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pCacheNode->m_pPresObj,
                    blockPresObj,
                    dwSizeOfPresObj,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: IOlePresObj \n");
            dprintf("at address %x\n", pCacheNode->m_pPresObj);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != dwSizeOfPresObj)
        {
            dprintf("Size of process memory read != requested (IOlePresObj)\n");

            goto errRtn;
        }

        // pass off pointer
        pCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
    }

    if (pCacheNode->m_pPresObjAfterFreeze != NULL)
    {
        switch (pCacheNode->m_dwPresFlag)
        {
        case CN_PRESOBJ_GEN:
            dwSizeOfPresObj = sizeof(CGenObject);
            break;
        case CN_PRESOBJ_MF:
            dwSizeOfPresObj = sizeof(CMfObject);
            break;
        case CN_PRESOBJ_EMF:
            dwSizeOfPresObj = sizeof(CEMfObject);
            break;
        default:
            dprintf("Error: can not determine size of IOlePresObj\n");
            return;
        }

        blockPresObjAF = new char[dwSizeOfPresObj];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pCacheNode->m_pPresObjAfterFreeze,
                    blockPresObjAF,
                    dwSizeOfPresObj,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: IOlePresObj \n");
            dprintf("at address %x\n", pCacheNode->m_pPresObjAfterFreeze);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != dwSizeOfPresObj)
        {
            dprintf("Size of process memory read != requested (IOlePresObj)\n");

            goto errRtn;
        }

        // pass off pointer
        pCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObjAF;
    }

    // dump the structure
    pszCacheNode = DumpCCacheNode(pCacheNode, NO_PREFIX, 1);

    dprintf("CCacheNode @ 0x%x\n", dwAddr);
    dprintfx(pszCacheNode);

    CoTaskMemFree(pszCacheNode);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockPresObj;
    delete[] blockPresObjAF;
    delete[] blockCacheNode;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clipdataobject, exported
//
//  Synopsis:   dumps CClipDataObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clipdataobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszCDO;
    char            *blockCDO    = NULL;
    char            *blockFE     = NULL;
    CClipDataObject *pCDO        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CClipDataObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCDO = new char[sizeof(CClipDataObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCDO,
                sizeof(CClipDataObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CClipDataObject \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CClipDataObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCDO = (CClipDataObject *)blockCDO;

    // read the block of mem for the FORMATETC array
    blockFE = new char[sizeof(FORMATETC)*pCDO->m_cFormats];

    fError = ReadProcessMemory(
                hCurrentProcess,
                pCDO->m_rgFormats,
                blockFE,
                sizeof(FORMATETC)*pCDO->m_cFormats,
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: FORMATETC array \n");
        dprintf("at address %x\n", pCDO->m_rgFormats);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != (sizeof(FORMATETC)*pCDO->m_cFormats))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCDO->m_rgFormats = (FORMATETC *)blockFE;

    // dump the structure
    pszCDO = DumpCClipDataObject(pCDO, NO_PREFIX, 1);

    dprintf("CClipDataObject @ 0x%x\n", dwAddr);
    dprintfx(pszCDO);

    CoTaskMemFree(pszCDO);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockFE;
    delete[] blockCDO;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clipenumformatetc, exported
//
//  Synopsis:   dumps CClipEnumFormatEtc object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clipenumformatetc)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszCEFE;
    char                *blockCEFE    = NULL;
    char                *blockFE      = NULL;
    CClipEnumFormatEtc  *pCEFE        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CClipEnumFormatEtc\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCEFE = new char[sizeof(CClipEnumFormatEtc)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCEFE,
                sizeof(CClipEnumFormatEtc),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CClipEnumFormatEtc \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CClipEnumFormatEtc))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCEFE = (CClipEnumFormatEtc *)blockCEFE;

    // read the block of mem for the FORMATETC array
    blockFE = new char[sizeof(FORMATETC)*pCEFE->m_cTotal];

    fError = ReadProcessMemory(
                hCurrentProcess,
                pCEFE->m_rgFormats,
                blockFE,
                sizeof(FORMATETC)*pCEFE->m_cTotal,
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: FORMATETC array \n");
        dprintf("at address %x\n", pCEFE->m_rgFormats);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != (sizeof(FORMATETC)*pCEFE->m_cTotal))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCEFE->m_rgFormats = (FORMATETC *)blockFE;

    // dump the structure
    pszCEFE = DumpCClipEnumFormatEtc(pCEFE, NO_PREFIX, 1);

    dprintf("CClipEnumFormatEtc @ 0x%x\n", dwAddr);
    dprintfx(pszCEFE);

    CoTaskMemFree(pszCEFE);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockFE;
    delete[] blockCEFE;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_daholder, exported
//
//  Synopsis:   dumps CDAHolder object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_daholder)
{
    DWORD           dwReturnedCount;
    BOOL            fError;
    LPVOID          dwAddr;
    char            *pszDAH;
    char            *blockDAH           = NULL;
    char            *blockStatDataArray = NULL;
    CDAHolder       *pDAH               = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDAHolder\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDAH = new char[sizeof(CDAHolder)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDAH,
                sizeof(CDAHolder),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CDAHolder \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDAHolder))
    {
        dprintf("Size of process memory read != requested (CDAHolder)\n");

        goto errRtn;
    }

    pDAH = (CDAHolder *)blockDAH;

    // read the block of mem for the STATDATA array
    blockStatDataArray = new char[sizeof(STATDATA) * pDAH->m_iSize];

    fError = ReadProcessMemory(
                hCurrentProcess,
                pDAH->m_pSD,
                blockStatDataArray,
                sizeof(STATDATA) * pDAH->m_iSize,
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: STATDATA array \n");
        dprintf("at address %x\n", pDAH->m_pSD);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != (sizeof(STATDATA) * pDAH->m_iSize))
    {
        dprintf("Size of process memory read != requested (STATDATA array)\n");

        goto errRtn;
    }

    pDAH->m_pSD = (STATDATA *)blockStatDataArray;

    // dump the structure
    pszDAH = DumpCDAHolder(pDAH, NO_PREFIX, 1);

    dprintf("CDAHolder @ 0x%x\n", dwAddr);
    dprintfx(pszDAH);

    CoTaskMemFree(pszDAH);

errRtn:

    delete[] blockDAH;
    delete[] blockStatDataArray;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_dataadvisecache, exported
//
//  Synopsis:   dumps CDataAdviseCache object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_dataadvisecache)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszDataAdviseCache;
    char                *blockDataAdviseCache   = NULL;
    char                *blockDAH               = NULL;
    CDataAdviseCache    *pDataAdviseCache       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDataAdviseCache\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDataAdviseCache = new char[sizeof(CDataAdviseCache)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDataAdviseCache,
                sizeof(CDataAdviseCache),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory DataAdviseCache");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDataAdviseCache))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pDataAdviseCache = (CDataAdviseCache *)blockDataAdviseCache;

    // get the mem for CDAHolder
    if (pDataAdviseCache->m_pDAH != NULL)
    {
        blockDAH = new char[sizeof(CDAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDataAdviseCache->m_pDAH,
                    blockDAH,
                    sizeof(CDAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory CDAHolder");
            dprintf("at address %x\n", pDataAdviseCache->m_pDAH);
            dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDAHolder))
        {
            dprintf("Size of process memory read != requested (CDAHolder)\n");

            goto errRtn;
        }

        pDataAdviseCache->m_pDAH = (CDAHolder *)blockDAH;
    }

    // dump the structure
    pszDataAdviseCache = DumpCDataAdviseCache(pDataAdviseCache, NO_PREFIX, 1);

    dprintf("CDataAdviseCache @ 0x%x\n", dwAddr);
    dprintfx(pszDataAdviseCache);

    CoTaskMemFree(pszDataAdviseCache);

errRtn:

    delete[] blockDAH;
    delete[] blockDataAdviseCache;

    return;
}
//+-------------------------------------------------------------------------
//
//  Function:   dump_defclassfactory, exported
//
//  Synopsis:   dumps CDefClassFactory object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_defclassfactory)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszDefClassFactory;
    char                *blockDefClassFactory   = NULL;
    CDefClassFactory    *pDefClassFactory       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDefClassFactory\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDefClassFactory = new char[sizeof(CDefClassFactory)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDefClassFactory,
                sizeof(CDefClassFactory),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory DefClassFactory");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDefClassFactory))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pDefClassFactory = (CDefClassFactory *)blockDefClassFactory;

    // dump the structure
    pszDefClassFactory = DumpCDefClassFactory(pDefClassFactory, NO_PREFIX, 1);

    dprintf("CDefClassFactory @ 0x%x\n", dwAddr);
    dprintfx(pszDefClassFactory);

    CoTaskMemFree(pszDefClassFactory);

errRtn:

    delete[] blockDefClassFactory;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_deflink, exported
//
//  Synopsis:   dumps CDefLink object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_deflink)
{
    unsigned int    ui;
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount     = 0;
    char            *pszDL              = NULL;
    char            *blockDefLink       = NULL;
    char            *blockCOleCache     = NULL;
    char            *blockDataAdvCache  = NULL;
    char            *blockOAHolder      = NULL;
    char            *blockpIAS          = NULL;
    char            *blockDAHolder      = NULL;
    char            *blockSTATDATA      = NULL;
    char            *blockCACHELIST     = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    CDefLink        *pDL                = NULL;
    CDAHolder       *pDAH               = NULL;
    COAHolder       *pOAH               = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDefLink\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDefLink = new char[sizeof(CDefLink)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDefLink,
                sizeof(CDefLink),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CDefLink \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDefLink))
    {
        dprintf("Size of process memory read != requested (CDefLink)\n");

        goto errRtn;
    }

    pDL = (CDefLink *)blockDefLink;

    // we need to NULL the monikers since we can't use GetDisplayName in this process
    pDL->m_pMonikerAbs = NULL;
    pDL->m_pMonikerRel = NULL;

    // get the block of mem for the COAHolder
    if (pDL->m_pCOAHolder != NULL)
    {
        blockOAHolder = new char[sizeof(COAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDL->m_pCOAHolder,
                    blockOAHolder,
                    sizeof(COAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COAHolder \n");
            dprintf("at address %x\n", pDL->m_pCOAHolder);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COAHolder))
        {
            dprintf("Size of process memory read != requested (COAHolder)\n");

            goto errRtn;
        }

        pDL->m_pCOAHolder = (COAHolder *)blockOAHolder;
        pOAH = (COAHolder *)blockOAHolder;

        // need to copy the array of IAdviseSink pointers
        if (pOAH->m_iSize > 0)
        {
            blockpIAS = new char[pOAH->m_iSize * sizeof(IAdviseSink *)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pOAH->m_ppIAS,
                        blockpIAS,
                        sizeof(IAdviseSink *) * pOAH->m_iSize,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IAdviseSink Array \n");
                dprintf("at address %x\n", pOAH->m_ppIAS);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(IAdviseSink *) * pOAH->m_iSize))
            {
                dprintf("Size of process memory read != requested(IAdviseSink Array)\n");

                goto errRtn;
            }

            pOAH->m_ppIAS = (IAdviseSink **)blockpIAS;
        }
    }

    // get block of mem for CDataAdviseCache (only if m_pDataAdvCache != NULL)
    if (pDL->m_pDataAdvCache != NULL)
    {
        blockDataAdvCache = new char[sizeof(CDataAdviseCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDL->m_pDataAdvCache,
                    blockDataAdvCache,
                    sizeof(CDataAdviseCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CDataAdviseCache \n");
            dprintf("at address %x\n", pDL->m_pDataAdvCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDataAdviseCache))
        {
            dprintf("Size of process memory read != requested (CDataAdviseCache)\n");

            goto errRtn;
        }

        pDL->m_pDataAdvCache = (CDataAdviseCache *)blockDataAdvCache;

        if (pDL->m_pDataAdvCache->m_pDAH != NULL)
        {
            blockDAHolder = new char[sizeof(CDAHolder)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDL->m_pDataAdvCache->m_pDAH,
                        blockDAHolder,
                        sizeof(CDAHolder),
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CDAHolder \n");
                dprintf("at address %x\n", pDL->m_pDataAdvCache->m_pDAH);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != sizeof(CDAHolder))
            {
                dprintf("Size of process memory read != requested (CDAHolder)\n");

                goto errRtn;
            }

            pDL->m_pDataAdvCache->m_pDAH = (IDataAdviseHolder *)blockDAHolder;
            pDAH = (CDAHolder *)blockDAHolder;

            if (pDAH->m_pSD != NULL)
            {
                blockSTATDATA = new char[sizeof(STATDATA)*pDAH->m_iSize];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDAH->m_pSD,
                            blockSTATDATA,
                            sizeof(STATDATA)*pDAH->m_iSize,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: STATDATA \n");
                    dprintf("at address %x\n", pDAH->m_pSD);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != (sizeof(STATDATA)*pDAH->m_iSize))
                {
                    dprintf("Size of process memory read != requested (STATDATA)\n");

                    goto errRtn;
                }

                pDAH->m_pSD = (STATDATA *)blockSTATDATA;
            }
        }
    }

    // get block of mem for COleCache (only if m_pCOleCache != NULL)
    if (pDL->m_pCOleCache != NULL)
    {
        blockCOleCache = new char[sizeof(COleCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDL->m_pCOleCache,
                    blockCOleCache,
                    sizeof(COleCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COleCache \n");
            dprintf("at address %x\n", pDL->m_pCOleCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COleCache))
        {
            dprintf("Size of process memory read != requested (COleCache)\n");

            goto errRtn;
        }

        pDL->m_pCOleCache = (COleCache *)blockCOleCache;

        // get block of mem for CACHELIST
        if (pDL->m_pCOleCache->m_pCacheList != NULL)
        {
            blockCACHELIST = new char[sizeof(CACHELIST_ITEM) * pDL->m_pCOleCache->m_uCacheNodeMax];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDL->m_pCOleCache->m_pCacheList,
                        blockCACHELIST,
                        sizeof(CACHELIST_ITEM) * pDL->m_pCOleCache->m_uCacheNodeMax,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CACHELIST \n");
                dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(CACHELIST_ITEM) * pDL->m_pCOleCache->m_uCacheNodeMax))
            {
                dprintf("Size of process memory read != requestedi (CACHELIST)\n");

                goto errRtn;
            }

            pDL->m_pCOleCache->m_pCacheList = (LPCACHELIST) blockCACHELIST;
        }

        // need to copy the memory of the CCacheNode's in the CACHELIST
        for (ui = 0; ui < pDL->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
            if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                blockCacheNode = new char[sizeof(CCacheNode)];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode,
                            blockCacheNode,
                            sizeof(CCacheNode),
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: CCacheNode \n");
                    dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != sizeof(CCacheNode))
                {
                    dprintf("Size of process memory read != requested (CCacheNode)\n");

                    goto errRtn;
                }

                // pass off pointer
                pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode = (CCacheNode*)blockCacheNode;
                blockCacheNode = NULL;

                // need to get the OlePresObjs for the CCacheNode
                if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj != NULL)
                {
                    switch (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }

                if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze != NULL)
                {
                    switch (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }
            }
        }
    }

    // dump the structure
    pszDL = DumpCDefLink(pDL, NO_PREFIX, 1);

    dprintf("CDefLink @ 0x%x\n", dwAddr);
    dprintfx(pszDL);

    CoTaskMemFree(pszDL);

errRtn:

    // delete the blocks and not the pointers
    if ( (pDL != NULL)&&(blockCACHELIST != NULL)&&(blockCOleCache != NULL) )
    {
        for (ui = 0; ui < pDL->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
         if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                delete[] ((char *)pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                delete[] ((char *)pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                delete[] ((char *)pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
            }
        }
    }
    delete[] blockCACHELIST;
    delete[] blockCOleCache;
    delete[] blockDAHolder;
    delete[] blockSTATDATA;
    delete[] blockDataAdvCache;
    delete[] blockpIAS;
    delete[] blockOAHolder;
    delete[] blockDefLink;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_defobject, exported
//
//  Synopsis:   dumps CDefObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_defobject)
{
    unsigned int    ui;
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount     = 0;
    char            *pszDO              = NULL;
    char            *blockDefObject     = NULL;
    char            *blockCOleCache     = NULL;
    char            *blockDataAdvCache  = NULL;
    char            *blockOAHolder      = NULL;
    char            *blockpIAS          = NULL;
    char            *blockDAHolder      = NULL;
    char            *blockSTATDATA      = NULL;
    char            *blockCACHELIST     = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    CDefObject      *pDO                = NULL;
    CDAHolder       *pDAH               = NULL;
    COAHolder       *pOAH               = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDefObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDefObject = new char[sizeof(CDefObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDefObject,
                sizeof(CDefObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CDefObject \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDefObject))
    {
        dprintf("Size of process memory read != requested (CDefObject)\n");

        goto errRtn;
    }

    pDO = (CDefObject *)blockDefObject;

    // get the block of mem for the COAHolder
    if (pDO->m_pOAHolder != NULL)
    {
        blockOAHolder = new char[sizeof(COAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDO->m_pOAHolder,
                    blockOAHolder,
                    sizeof(COAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COAHolder \n");
            dprintf("at address %x\n", pDO->m_pOAHolder);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COAHolder))
        {
            dprintf("Size of process memory read != requested (COAHolder)\n");

            goto errRtn;
        }

        pDO->m_pOAHolder = (COAHolder *)blockOAHolder;
        pOAH = (COAHolder *)blockOAHolder;

        // need to copy the array of IAdviseSink pointers
        if (pOAH->m_iSize > 0)
        {
            blockpIAS = new char[pOAH->m_iSize * sizeof(IAdviseSink *)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pOAH->m_ppIAS,
                        blockpIAS,
                        sizeof(IAdviseSink *) * pOAH->m_iSize,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IAdviseSink Array \n");
                dprintf("at address %x\n", pOAH->m_ppIAS);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(IAdviseSink *) * pOAH->m_iSize))
            {
                dprintf("Size of process memory read != requested(IAdviseSink Array)\n");

                goto errRtn;
            }

            pOAH->m_ppIAS = (IAdviseSink **)blockpIAS;
        }
    }

    // get block of mem for CDataAdviseCache (only if m_pDataAdvCache != NULL)
    if (pDO->m_pDataAdvCache != NULL)
    {
        blockDataAdvCache = new char[sizeof(CDataAdviseCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDO->m_pDataAdvCache,
                    blockDataAdvCache,
                    sizeof(CDataAdviseCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CDataAdviseCache \n");
            dprintf("at address %x\n", pDO->m_pDataAdvCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDataAdviseCache))
        {
            dprintf("Size of process memory read != requested (CDataAdviseCache)\n");

            goto errRtn;
        }

        pDO->m_pDataAdvCache = (CDataAdviseCache *)blockDataAdvCache;

        // get the mem for CDAHolder
        if (pDO->m_pDataAdvCache->m_pDAH != NULL)
        {
            blockDAHolder = new char[sizeof(CDAHolder)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDO->m_pDataAdvCache->m_pDAH,
                        blockDAHolder,
                        sizeof(CDAHolder),
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CDAHolder \n");
                dprintf("at address %x\n", pDO->m_pDataAdvCache->m_pDAH);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != sizeof(CDAHolder))
            {
                dprintf("Size of process memory read != requested (CDAHolder)\n");

                goto errRtn;
            }

            pDO->m_pDataAdvCache->m_pDAH = (IDataAdviseHolder *)blockDAHolder;
            pDAH = (CDAHolder *)blockDAHolder;

            // get the STATDATA array
            if (pDAH->m_pSD != NULL)
            {
                blockSTATDATA = new char[sizeof(STATDATA)*pDAH->m_iSize];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDAH->m_pSD,
                            blockSTATDATA,
                            sizeof(STATDATA)*pDAH->m_iSize,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: STATDATA \n");
                    dprintf("at address %x\n", pDAH->m_pSD);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != (sizeof(STATDATA)*pDAH->m_iSize))
                {
                    dprintf("Size of process memory read != requested (STATDATA)\n");

                    goto errRtn;
                }

                pDAH->m_pSD = (STATDATA *)blockSTATDATA;
            }
        }
    }

    // get block of mem for COleCache (only if m_pCOleCache != NULL)
    if (pDO->m_pCOleCache != NULL)
    {
        blockCOleCache = new char[sizeof(COleCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDO->m_pCOleCache,
                    blockCOleCache,
                    sizeof(COleCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COleCache \n");
            dprintf("at address %x\n", pDO->m_pCOleCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COleCache))
        {
            dprintf("Size of process memory read != requested (COleCache)\n");

            goto errRtn;
        }

        pDO->m_pCOleCache = (COleCache *)blockCOleCache;

        // get block of mem for CACHELIST
        if (pDO->m_pCOleCache->m_pCacheList != NULL)
        {
            blockCACHELIST = new char[sizeof(CACHELIST_ITEM) * pDO->m_pCOleCache->m_uCacheNodeMax];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDO->m_pCOleCache->m_pCacheList,
                        blockCACHELIST,
                        sizeof(CACHELIST_ITEM) * pDO->m_pCOleCache->m_uCacheNodeMax,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CACHELIST \n");
                dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(CACHELIST_ITEM) * pDO->m_pCOleCache->m_uCacheNodeMax))
            {
                dprintf("Size of process memory read != requested(CACHELIST_ITEM\n");

                goto errRtn;
            }

            pDO->m_pCOleCache->m_pCacheList = (LPCACHELIST) blockCACHELIST;
        }

        // need to copy the memory of the CCacheNode's in the CACHELIST
        for (ui = 0; ui < pDO->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
            if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                blockCacheNode = new char[sizeof(CCacheNode)];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode,
                            blockCacheNode,
                            sizeof(CCacheNode),
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: CCacheNode \n");
                    dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != sizeof(CCacheNode))
                {
                    dprintf("Size of process memory read != requested (CCacheNode)\n");

                    goto errRtn;
                }

                // pass off pointer
                pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode = (CCacheNode*)blockCacheNode;
                blockCacheNode = NULL;

                // need to get the OlePresObjs for the CCacheNode
                if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj != NULL)
                {
                    switch (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }

                if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze != NULL)
                {
                    switch (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }
            }
        }
    }

    // dump the structure
    pszDO = DumpCDefObject(pDO, NO_PREFIX, 1);

    dprintf("CDefObject @ 0x%x\n", dwAddr);
    dprintfx(pszDO);

    CoTaskMemFree(pszDO);

errRtn:

    // delete the blocks and not the pointers
    if ( (pDO != NULL)&&(blockCACHELIST != NULL)&&(blockCOleCache != NULL) )
    {
        for (ui = 0; ui < pDO->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
         if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                delete[] ((char *)pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                delete[] ((char *)pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                delete[] ((char *)pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
            }
        }
    }
    delete[] blockCACHELIST;
    delete[] blockCOleCache;
    delete[] blockDAHolder;
    delete[] blockSTATDATA;
    delete[] blockDataAdvCache;
    delete[] blockpIAS;
    delete[] blockOAHolder;
    delete[] blockDefObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_emfobject, exported
//
//  Synopsis:   dumps CEMfObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_emfobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszEMfObject;
    char            *blockEMfObject   = NULL;
    CEMfObject      *pEMfObject       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CEMfObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockEMfObject = new char[sizeof(CEMfObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockEMfObject,
                sizeof(CEMfObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory EMfObject");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CEMfObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pEMfObject = (CEMfObject *)blockEMfObject;

    // dump the structure
    pszEMfObject = DumpCEMfObject(pEMfObject, NO_PREFIX, 1);

    dprintf("CEMfObject @ 0x%x\n", dwAddr);
    dprintfx(pszEMfObject);

    CoTaskMemFree(pszEMfObject);

errRtn:

    delete[] blockEMfObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumfmt, exported
//
//  Synopsis:   dumps CEnumFmt object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumfmt)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_enumfmt not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumfmt10, exported
//
//  Synopsis:   dumps CEnumFmt10 object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumfmt10)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_enumfmt10 not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumstatdata, exported
//
//  Synopsis:   dumps CEnumSTATDATA object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumstatdata)
{
    DWORD           dwReturnedCount;
    BOOL            fError;
    LPVOID          dwAddr;
    char            *pszESD;
    char            *blockEnumStatData  = NULL;
    char            *blockDAH           = NULL;
    char            *blockStatDataArray = NULL;
    CEnumSTATDATA   *pESD               = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CEnumSTATDATA\n");
        return;
    }

    // read the mem for the CEnumSTATDATA
    blockEnumStatData = new char[sizeof(CEnumSTATDATA)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockEnumStatData,
                sizeof(CEnumSTATDATA),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CEnumSTATDATA \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CEnumSTATDATA))
    {
        dprintf("Size of process memory read != requested (CEnumSTATDATA)\n");

        goto errRtn;
    }

    pESD = (CEnumSTATDATA *)blockEnumStatData;

    // read the block of memory for the CDAHolder
    if (pESD->m_pHolder != NULL)
    {
        blockDAH = new char[sizeof(CDAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pESD->m_pHolder,
                    blockDAH,
                    sizeof(CDAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CDAHolder \n");
            dprintf("at address %x\n", pESD->m_pHolder);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDAHolder))
        {
            dprintf("Size of process memory read != requested (CDAHolder)\n");

            goto errRtn;
        }

        pESD->m_pHolder = (CDAHolder *)blockDAH;

        // read the block of mem for the STATDATA array
        if (pESD->m_pHolder->m_pSD != NULL)
        {
            blockStatDataArray = new char[sizeof(STATDATA) * pESD->m_pHolder->m_iSize];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pESD->m_pHolder->m_pSD,
                        blockStatDataArray,
                        sizeof(STATDATA) * pESD->m_pHolder->m_iSize,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: STATDATA array \n");
                dprintf("at address %x\n", pESD->m_pHolder->m_pSD);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(STATDATA) * pESD->m_pHolder->m_iSize))
            {
                dprintf("Size of process memory read != requested (STATDATA array)\n");

                goto errRtn;
            }

            pESD->m_pHolder->m_pSD = (STATDATA *)blockStatDataArray;
        }
    }

    // dump the structure
    pszESD = DumpCEnumSTATDATA(pESD, NO_PREFIX, 1);

    dprintf("CEnumSTATDATA @ 0x%x\n", dwAddr);
    dprintfx(pszESD);

    CoTaskMemFree(pszESD);

errRtn:

    delete[] blockEnumStatData;
    delete[] blockDAH;
    delete[] blockStatDataArray;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumverb, exported
//
//  Synopsis:   dumps CEnumVerb object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumverb)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_enumverb not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_genobject, exported
//
//  Synopsis:   dumps CGenObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_genobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszGenObject;
    char            *blockGenObject   = NULL;
    CGenObject      *pGenObject       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CGenObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockGenObject = new char[sizeof(CGenObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockGenObject,
                sizeof(CGenObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory GenObject");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CGenObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pGenObject = (CGenObject *)blockGenObject;

    // dump the structure
    pszGenObject = DumpCGenObject(pGenObject, NO_PREFIX, 1);

    dprintf("CGenObject @ 0x%x\n", dwAddr);
    dprintfx(pszGenObject);

    CoTaskMemFree(pszGenObject);

errRtn:

    delete[] blockGenObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_membytes, exported
//
//  Synopsis:   dumps CMemBytes object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_membytes)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMB;
    char            *blockMB        = NULL;
    CMemBytes       *pMB            = NULL;
    char            *blockMEMSTM    = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CMemBytes\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMB = new char[sizeof(CMemBytes)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMB,
                sizeof(CMemBytes),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CMemBytes \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CMemBytes))
    {
        dprintf("Size of process memory read != requested(CMemBytes)\n");

        goto errRtn;
    }

    pMB = (CMemBytes *)blockMB;

    // copy the MEMSTM structure
    if (pMB->m_pData != NULL)
    {
        blockMEMSTM = new char[sizeof(MEMSTM)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pMB->m_pData,
                    blockMEMSTM,
                    sizeof(MEMSTM),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: MEMSTM \n");
            dprintf("at address %x\n", pMB->m_pData);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(MEMSTM))
        {
            dprintf("Size of process memory read != requested(MEMSTM)\n");

            goto errRtn;
        }

        pMB->m_pData = (MEMSTM *)blockMEMSTM;
    }

    // dump the structure
    pszMB = DumpCMemBytes(pMB, NO_PREFIX, 1);

    dprintf("CMemBytes @ 0x%x\n", dwAddr);
    dprintfx(pszMB);

    CoTaskMemFree(pszMB);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockMB;
    delete[] blockMEMSTM;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cmemstm, exported
//
//  Synopsis:   dumps CMemStm object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cmemstm)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMS;
    char            *blockMS        = NULL;
    CMemStm         *pMS            = NULL;
    char            *blockMEMSTM    = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CMemStm\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMS = new char[sizeof(CMemStm)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMS,
                sizeof(CMemStm),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CMemStm \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CMemStm))
    {
        dprintf("Size of process memory read != requested(CMemStm)\n");

        goto errRtn;
    }

    pMS = (CMemStm *)blockMS;

    // copy the MEMSTM structure
    if (pMS->m_pData != NULL)
    {
        blockMEMSTM = new char[sizeof(MEMSTM)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pMS->m_pData,
                    blockMEMSTM,
                    sizeof(MEMSTM),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: MEMSTM \n");
            dprintf("at address %x\n", pMS->m_pData);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(MEMSTM))
        {
            dprintf("Size of process memory read != requested(MEMSTM)\n");

            goto errRtn;
        }

        pMS->m_pData = (MEMSTM *)blockMEMSTM;
    }

    // dump the structure
    pszMS = DumpCMemStm(pMS, NO_PREFIX, 1);

    dprintf("CMemStm @ 0x%x\n", dwAddr);
    dprintfx(pszMS);

    CoTaskMemFree(pszMS);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockMS;
    delete[] blockMEMSTM;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_mfobject, exported
//
//  Synopsis:   dumps CMfObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_mfobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMfObject;
    char            *blockMfObject   = NULL;
    CMfObject       *pMfObject       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CMfObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMfObject = new char[sizeof(CMfObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMfObject,
                sizeof(CMfObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory MfObject");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CMfObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pMfObject = (CMfObject *)blockMfObject;

    // dump the structure
    pszMfObject = DumpCMfObject(pMfObject, NO_PREFIX, 1);

    dprintf("CMfObject @ 0x%x\n", dwAddr);
    dprintfx(pszMfObject);

    CoTaskMemFree(pszMfObject);

errRtn:

    delete[] blockMfObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_oaholder, exported
//
//  Synopsis:   dumps COAHolder object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_oaholder)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszOAH;
    char            *blockOAH   = NULL;
    char            *blockpIAS  = NULL;
    COAHolder       *pOAH       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of COAHolder\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockOAH = new char[sizeof(COAHolder)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockOAH,
                sizeof(COAHolder),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: COAHolder \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(COAHolder))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pOAH = (COAHolder *)blockOAH;

    // need to copy the array of IAdviseSink pointers
    if (pOAH->m_iSize > 0)
    {
        blockpIAS = new char[pOAH->m_iSize * sizeof(IAdviseSink *)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pOAH->m_ppIAS,
                    blockpIAS,
                    sizeof(IAdviseSink *) * pOAH->m_iSize,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: IAdviseSink Array \n");
            dprintf("at address %x\n", pOAH->m_ppIAS);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != (sizeof(IAdviseSink *) * pOAH->m_iSize))
        {
            dprintf("Size of process memory read != requested\n");

            goto errRtn;
        }

        pOAH->m_ppIAS = (IAdviseSink **)blockpIAS;
    }

    // dump the structure
    pszOAH = DumpCOAHolder(pOAH, NO_PREFIX, 1);

    dprintf("COAHolder @ 0x%x\n", dwAddr);
    dprintfx(pszOAH);

    CoTaskMemFree(pszOAH);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockOAH;
    delete[] blockpIAS;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_olecache, exported
//
//  Synopsis:   dumps COleCache object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_olecache)
{
    unsigned int    ui;
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszOC;
    char            *blockOC            = NULL;
    COleCache       *pOC                = NULL;
    char            *blockCCacheEnum    = NULL;
    char            *blockCACHELIST     = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of COleCache\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockOC = new char[sizeof(COleCache)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockOC,
                sizeof(COleCache),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: COleCache \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(COleCache))
    {
        dprintf("Size of process memory read != requested (COleCache)\n");

        goto errRtn;
    }

    pOC = (COleCache *)blockOC;

    // get block of mem for CCacheEnum (only if m_pCacheEnum != NULL)
    if (pOC->m_pCacheEnum != NULL)
    {
        blockCCacheEnum = new char[sizeof(CCacheEnum)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pOC->m_pCacheEnum,
                    blockCCacheEnum,
                    sizeof(CCacheEnum),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CCacheEnum \n");
            dprintf("at address %x\n", pOC->m_pCacheEnum);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CCacheEnum))
        {
            dprintf("Size of process memory read != requested (CCacheEnum)\n");

            goto errRtn;
        }

        pOC->m_pCacheEnum = (CCacheEnum *)blockCCacheEnum;
    }

    // get block of mem for CACHELIST
    if (pOC->m_pCacheList != NULL)
    {
        blockCACHELIST = new char[sizeof(CACHELIST_ITEM) * pOC->m_uCacheNodeMax];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pOC->m_pCacheList,
                    blockCACHELIST,
                    sizeof(CACHELIST_ITEM) * pOC->m_uCacheNodeMax,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CACHELIST \n");
            dprintf("at address %x\n", pOC->m_pCacheList);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != (sizeof(CACHELIST_ITEM) * pOC->m_uCacheNodeMax))
        {
            dprintf("Size of process memory read != requested\n");

            goto errRtn;
        }

        pOC->m_pCacheList = (LPCACHELIST) blockCACHELIST;
    }

    // need to copy the memory of the CCacheNode's in the CACHELIST
    for (ui = 0; ui < pOC->m_uCacheNodeMax; ui++)
    {
        if (pOC->m_pCacheList[ui].lpCacheNode != NULL)
        {
            blockCacheNode = new char[sizeof(CCacheNode)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pOC->m_pCacheList[ui].lpCacheNode,
                        blockCacheNode,
                        sizeof(CCacheNode),
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CCacheNode \n");
                dprintf("at address %x\n", pOC->m_pCacheList[ui].lpCacheNode);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != sizeof(CCacheNode))
            {
                dprintf("Size of process memory read != requested (CCacheNode)\n");

                goto errRtn;
            }

            // pass off pointer
            pOC->m_pCacheList[ui].lpCacheNode = (CCacheNode*)blockCacheNode;
            blockCacheNode = NULL;

            // need to get the OlePresObjs for the CCacheNode
            if (pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj != NULL)
            {
                switch (pOC->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                {
                case CN_PRESOBJ_GEN:
                    dwSizeOfPresObj = sizeof(CGenObject);
                    break;
                case CN_PRESOBJ_MF:
                    dwSizeOfPresObj = sizeof(CMfObject);
                    break;
                case CN_PRESOBJ_EMF:
                    dwSizeOfPresObj = sizeof(CEMfObject);
                    break;
                default:
                    dprintf("Error: can not determine size of IOlePresObj\n");
                    return;
                }

                blockPresObj = new char[dwSizeOfPresObj];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj,
                            blockPresObj,
                            dwSizeOfPresObj,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                    dprintf("at address %x\n", pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != dwSizeOfPresObj)
                {
                    dprintf("Size of process memory read != requested (IOlePresObj)\n");

                    goto errRtn;
                }

                // pass off pointer
                pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
                blockPresObj = NULL;
            }

            if (pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze != NULL)
            {
                switch (pOC->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                {
                case CN_PRESOBJ_GEN:
                    dwSizeOfPresObj = sizeof(CGenObject);
                    break;
                case CN_PRESOBJ_MF:
                    dwSizeOfPresObj = sizeof(CMfObject);
                    break;
                case CN_PRESOBJ_EMF:
                    dwSizeOfPresObj = sizeof(CEMfObject);
                    break;
                default:
                    dprintf("Error: can not determine size of IOlePresObj\n");
                    return;
                }

                blockPresObj = new char[dwSizeOfPresObj];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze,
                            blockPresObj,
                            dwSizeOfPresObj,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                    dprintf("at address %x\n", pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != dwSizeOfPresObj)
                {
                    dprintf("Size of process memory read != requested (IOlePresObj)\n");

                    goto errRtn;
                }

                // pass off pointer
                pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObj;
                blockPresObj = NULL;
            }
        }
    }

    // dump the structure
    pszOC = DumpCOleCache(pOC, NO_PREFIX, 1);

    dprintf("COleCache @ 0x%x\n", dwAddr);
    dprintfx(pszOC);

    CoTaskMemFree(pszOC);

errRtn:

    // delete the blocks and not the pointers
    if ( (pOC != NULL) && (blockCACHELIST != NULL))
    {
        for (ui = 0; ui < pOC->m_uCacheNodeMax; ui++)
        {
         if (pOC->m_pCacheList[ui].lpCacheNode != NULL)
            {
                delete[] ((char *)pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                delete[] ((char *)pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                delete[] ((char *)pOC->m_pCacheList[ui].lpCacheNode);
            }
        }
    }
    delete[] blockCACHELIST;
    delete[] blockCCacheEnum;
    delete[] blockOC;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_saferefcount, exported
//
//  Synopsis:   dumps CSafeRefCount object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API( dump_saferefcount )
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszSRC;
    char            *blockSRC   = NULL;
    CSafeRefCount   *pSRC       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CSafeRefCount\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockSRC = new char[sizeof(CSafeRefCount)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockSRC,
                sizeof(CSafeRefCount),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CSafeRefCount))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pSRC = (CSafeRefCount *)blockSRC;

    // dump the structure
    pszSRC = DumpCSafeRefCount(pSRC, NO_PREFIX, 1);

    dprintf("CSafeRefCount @ 0x%x\n", dwAddr);
    dprintfx(pszSRC);

    CoTaskMemFree(pszSRC);

errRtn:

    delete[] blockSRC;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_threadcheck, exported
//
//  Synopsis:   dumps CThreadCheck object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_threadcheck)
{
    DWORD           dwReturnedCount;
    BOOL            fError;
    LPVOID          dwAddr;
    char            *pszTC;
    char            *blockTC    = NULL;
    CThreadCheck    *pTC        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CThreadCheck\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockTC = new char[sizeof(CThreadCheck)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockTC,
                sizeof(CThreadCheck),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CThreadCheck))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pTC = (CThreadCheck *)blockTC;

    // dump the structure
    pszTC = DumpCThreadCheck(pTC, NO_PREFIX, 1);

    dprintf("CThreadCheck @ 0x%x\n", dwAddr);
    dprintfx(pszTC);

    CoTaskMemFree(pszTC);

errRtn:

    delete[] blockTC;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_formatetc, exported
//
//  Synopsis:   dumps FORMATETC object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_formatetc)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszFE;
    char            *blockFE   = NULL;
    FORMATETC       *pFE       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of FORMATETC\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockFE = new char[sizeof(FORMATETC)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockFE,
                sizeof(FORMATETC),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: FORMATETC \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(FORMATETC))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pFE = (FORMATETC *)blockFE;

    // dump the structure
    pszFE = DumpFORMATETC(pFE, NO_PREFIX, 1);

    dprintf("FORMATETC @ 0x%x\n", dwAddr);
    dprintfx(pszFE);

    CoTaskMemFree(pszFE);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockFE;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_memstm, exported
//
//  Synopsis:   dumps MEMSTM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_memstm)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMS;
    char            *blockMS   = NULL;
    MEMSTM          *pMS       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of MEMSTM\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMS = new char[sizeof(MEMSTM)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMS,
                sizeof(MEMSTM),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: MEMSTM \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(MEMSTM))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pMS = (MEMSTM *)blockMS;

    // dump the structure
    pszMS = DumpMEMSTM(pMS, NO_PREFIX, 1);

    dprintf("MEMSTM @ 0x%x\n", dwAddr);
    dprintfx(pszMS);

    CoTaskMemFree(pszMS);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockMS;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_statdata, exported
//
//  Synopsis:   dumps STATDATA object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_statdata)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszSD;
    char            *blockSD   = NULL;
    STATDATA        *pSD       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of STATDATA\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockSD = new char[sizeof(STATDATA)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockSD,
                sizeof(STATDATA),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: STATDATA \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(STATDATA))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pSD = (STATDATA *)blockSD;

    // dump the structure
    pszSD = DumpSTATDATA(pSD, NO_PREFIX, 1);

    dprintf("STATDATA @ 0x%x\n", dwAddr);
    dprintfx(pszSD);

    CoTaskMemFree(pszSD);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockSD;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_stgmedium, exported
//
//  Synopsis:   dumps STGMEDIUM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_stgmedium)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszSTGMEDIUM;
    char            *blockSTGMEDIUM   = NULL;
    STGMEDIUM       *pSTGMEDIUM       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of STGMEDIUM\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockSTGMEDIUM = new char[sizeof(STGMEDIUM)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockSTGMEDIUM,
                sizeof(STGMEDIUM),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory STGMEDIUM");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(STGMEDIUM))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pSTGMEDIUM = (STGMEDIUM *)blockSTGMEDIUM;

    // dump the structure
    pszSTGMEDIUM = DumpSTGMEDIUM(pSTGMEDIUM, NO_PREFIX, 1);

    dprintf("STGMEDIUM @ 0x%x\n", dwAddr);
    dprintfx(pszSTGMEDIUM);

    CoTaskMemFree(pszSTGMEDIUM);

errRtn:

    delete[] blockSTGMEDIUM;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\olebind\widewrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.h
//
//  Contents:   Wrapper functions for Win32c API used by 32-bit OLE 2
//
//  History:    12-27-93   ErikGav   Created
//              06-14-94   KentCe    Various Chicago build fixes.
//
//----------------------------------------------------------------------------

#ifndef _WIDEWRAP_H_
#define _WIDEWRAP_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING WIDEWRAP.H from " __FILE__)
#endif  /* RC_INVOKED */

#ifdef _CHICAGO_

#ifdef __cplusplus
extern "C" {
#endif

#undef  WNDCLASS
#define WNDCLASS WNDCLASSW
#define WNDCLASST WNDCLASSA

#undef  STARTUPINFO
#define STARTUPINFO STARTUPINFOW

#undef  WIN32_FIND_DATA
#define WIN32_FIND_DATA WIN32_FIND_DATAW

HANDLE
WINAPI
CreateFileX(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

#undef  CreateFile
#define CreateFile CreateFileX
#define CreateFileT CreateFileA

BOOL
WINAPI
DeleteFileX(
    LPCWSTR lpFileName
    );

#undef  DeleteFile
#define DeleteFile DeleteFileX
#define DeleteFileT DeleteFileA

UINT
WINAPI
RegisterClipboardFormatX(
    LPCWSTR lpszFormat);

#undef  RegisterClipboardFormat
#define RegisterClipboardFormat RegisterClipboardFormatX
#define RegisterClipboardFormatT RegisterClipboardFormatA

int
WINAPI
GetClipboardFormatNameX(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);

#undef  GetClipboardFormatName
#define GetClipboardFormatName GetClipboardFormatNameX
#define GetClipboardFormatNameT GetClipboardFormatNameA

LONG
APIENTRY
RegOpenKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

#undef  RegOpenKey
#define RegOpenKey RegOpenKeyX
#define RegOpenKeyT RegOpenKeyA

LONG
APIENTRY
RegQueryValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG   lpcbValue
    );

#undef  RegQueryValue
#define RegQueryValue RegQueryValueX
#define RegQueryValueT RegQueryValueA
LONG
APIENTRY
RegSetValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

#undef  RegSetValue
#define RegSetValue RegSetValueX
#define RegSetValueT RegSetValueA

LONG
APIENTRY
RegSetValueExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwReserved,
    DWORD dwType,
    LPBYTE lpData,
    DWORD cbData
    );

#undef  RegSetValueEx
#define RegSetValueEx RegSetValueExX
#define RegSetValueExT RegSetValueExA


UINT
WINAPI
RegisterWindowMessageX(
    LPCWSTR lpString);

#undef  RegisterWindowMessage
#define RegisterWindowMessage RegisterWindowMessageX
#define RegisterWindowMessageT RegisterWindowMessageA

LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

#undef  RegOpenKeyEx
#define RegOpenKeyEx RegOpenKeyExX
#define RegOpenKeyExT RegOpenKeyExA

LONG
APIENTRY
RegQueryValueExX (
    HKEY hKey,
    LPWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

#undef  RegQueryValueEx
#define RegQueryValueEx RegQueryValueExX
#define RegQueryValueExT RegQueryValueExA

HWND
WINAPI
CreateWindowExX(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindowEx
#define CreateWindowEx CreateWindowExX
#define CreateWindowExT CreateWindowExA

ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass);

#undef  RegisterClass
#define RegisterClass RegisterClassX
#define RegisterClassT RegisterClassA

BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);

#undef  UnregisterClass
#define UnregisterClass UnregisterClassX
#define UnregisterClassT UnregisterClassA

int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);

#undef  wsprintf
#define wsprintf wsprintfX
#define wsprintfT wsprintfA

HWND
WINAPI
CreateWindowX(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindow
#define CreateWindow CreateWindowX
#define CreateWindowT CreateWindowA

HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  GetProp
#define GetProp GetPropX
#define GetPropT GetPropA

BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);

#undef  SetProp
#define SetProp SetPropX
#define SetPropT SetPropA

HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  RemoveProp
#define RemoveProp RemovePropX
#define RemovePropT RemovePropA

UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );

#undef  GetProfileInt
#define GetProfileInt GetProfileIntX
#define GetProfileIntT GetProfileIntA

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    );

#undef  GlobalAddAtom
#define GlobalAddAtom GlobalAddAtomX
#define GlobalAddAtomT GlobalAddAtomA

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );

#undef  GlobalGetAtomName
#define GlobalGetAtomName GlobalGetAtomNameX
#define GlobalGetAtomNameT GlobalGetAtomNameA

DWORD
WINAPI
GetModuleFileNameX(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#undef  GetModuleFileName
#define GetModuleFileName GetModuleFileNameX
#define GetModuleFileNameT GetModuleFileNameA

LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);

#undef  CharPrev
#define CharPrev CharPrevX
#define CharPrevT CharPrevA

HFONT   WINAPI CreateFontX(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCWSTR);
#undef  CreateFont
#define CreateFont CreateFontX
#define CreateFontT CreateFontA

HMODULE
WINAPI
LoadLibraryX(
    LPCWSTR lpLibFileName
    );

#undef  LoadLibrary
#define LoadLibrary LoadLibraryX
#define LoadLibraryT LoadLibraryA

HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

#undef  LoadLibraryEx
#define LoadLibraryEx LoadLibraryExX
#define LoadLibraryExT LoadLibraryExA

LONG
APIENTRY
RegDeleteKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey
    );

#undef  RegDeleteKey
#define RegDeleteKey RegDeleteKeyX
#define RegDeleteKeyT RegDeleteKeyA

#undef  RpcStringBindingCompose
#define RpcStringBindingCompose RpcStringBindingComposeW

#undef  RpcBindingFromStringBinding
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW

#undef  RpcStringFree
#define RpcStringFree RpcStringFreeW

BOOL
WINAPI
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

#undef  CreateProcess
#define CreateProcess CreateProcessX
#define CreateProcessT CreateProcessA

LONG
APIENTRY
RegEnumKeyExX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

#undef  RegEnumKeyEx
#define RegEnumKeyEx RegEnumKeyExX
#define RegEnumKeyExT RegEnumKeyExA

#undef  RpcServerUseProtseqEp
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW

BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );

#undef  AppendMenu
#define AppendMenu AppendMenuX
#define AppendMenuT AppendMenuA

HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef  OpenEvent
#define OpenEvent OpenEventX
#define OpenEventT OpenEventA

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

#undef  CreateEvent
#define CreateEvent CreateEventX
#define CreateEventT CreateEventA

UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    );

#undef  GetDriveType
#define GetDriveType GetDriveTypeX
#define GetDriveTypeT GetDriveTypeA

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    );

#undef  GetFileAttributes
#define GetFileAttributes GetFileAttributesX
#define GetFileAttributesT GetFileAttributesA

LONG
APIENTRY
RegEnumKeyX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

#undef  RegEnumKey
#define RegEnumKey RegEnumKeyX
#define RegEnumKeyT RegEnumKeyA

HANDLE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

#undef  FindFirstFile
#define FindFirstFile FindFirstFileX
#define FindFirstFileT FindFirstFileA

#undef  RegisterProtseq
#define RegisterProtseq RegisterProtseqW

#undef  RpcStringBindingParse
#define RpcStringBindingParse RpcStringBindingParseW

#undef  RpcNetworkIsProtseqValid
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW

#undef  RpcBindingToStringBinding
#define RpcBindingToStringBinding RpcBindingToStringBindingW

#undef  RpcServerUseProtseq
#define RpcServerUseProtseq RpcServerUseProtseqW

BOOL
WINAPI
GetComputerNameX (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

#undef  GetComputerName
#define GetComputerName GetComputerNameX
#define GetComputerNameT GetComputerNameA

#undef  Foo
#define Foo FooW

#undef  Foo
#define Foo FooW

#undef  Foo
#define Foo FooW

//The following force Chicago to directly use the ANSI versions

#undef  DefWindowProc
#define DefWindowProc   DefWindowProcA

#undef  CopyMetaFile                       // Currently str ptr is always
#define CopyMetaFile    CopyMetaFileA      // null, write a wrapper if this
                                           // changes
#undef  CreateMetaFile
#define CreateMetaFile  CreateMetaFileA

#undef  PostMessage
#define PostMessage     PostMessageA

#undef  SendMessage
#define SendMessage     SendMessageA

#undef  PeekMessage
#define PeekMessage     PeekMessageA

#undef  DispatchMessage
#define DispatchMessage DispatchMessageA

#undef  GetWindowLong
#define GetWindowLong GetWindowLongA

#undef  SetWindowLong
#define SetWindowLong SetWindowLongA

DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszLongPath,
    LPWSTR lpszShortPath,
    DWORD cchBuffer
    );

#undef  GetShortPathName
#define GetShortPathName GetShortPathNameX
#define GetShortPathNameT GetShortPathNameA

DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef  GetFullPathName
#define GetFullPathName GetFullPathNameX
#define GetFullPathNameT GetFullPathNameA

DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef SearchPath
#define SearchPath SearchPathX
#define SearchPathT SearchPathA

ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    );

#undef GlobalFindAtom
#define GlobalFindAtom GlobalFindAtomX
#define GlobalFindAtomT GlobalFindAtomA

int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount);

#undef GetClassName
#define GetClassName GetClassNameX
#define GetClassNameT GetClassNameA

int
WINAPI
lstrlenX(LPCWSTR lpString);

#undef lstrlen
#define lstrlen lstrlenX
#define lstrlenT lstrlenA

LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2);

#undef lstrcat
#define lstrcat lstrcatX
#define lstrcatT lstrcatA



int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcmp
#define lstrcmp lstrcmpX
#define lstrcmpT lstrcmpA

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcmpi
#define lstrcmpi lstrcmpiX
#define lstrcmpiT lstrcmpiA

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcpy
#define lstrcpy lstrcpyX
#define lstrcpyT lstrcpyA

HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

#undef CreateFileMapping
#define CreateFileMapping CreateFileMappingX
#define CreateFileMappingT CreateFileMappingA

HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef OpenFileMapping
#define OpenFileMapping OpenFileMappingX
#define OpenFileMappingT OpenFileMappingA

#ifdef __cplusplus
}
#endif

#else
//
// These are the definitions for NT
//
#define CreateFileT CreateFileW
#define DeleteFileT DeleteFileW
#define RegisterClipboardFormatT RegisterClipboardFormatW
#define GetClipboardFormatNameT GetClipboardFormatNameW
#define RegOpenKeyT RegOpenKeyW
#define RegQueryValueT RegQueryValueW
#define RegSetValueT RegSetValueW
#define RegSetValueExT RegSetValueExW
#define RegisterWindowMessageT RegisterWindowMessageW
#define RegOpenKeyExT RegOpenKeyExW
#define RegQueryValueExT RegQueryValueExW
#define CreateWindowExT CreateWindowExW
#define RegisterClassT RegisterClassW
#define UnregisterClassT UnregisterClassW
#define wsprintfT wsprintfW
#define CreateWindowT CreateWindowW
#define GetPropT GetPropW
#define SetPropT SetPropW
#define RemovePropT RemovePropW
#define GetProfileIntT GetProfileIntW
#define GlobalAddAtomT GlobalAddAtomW
#define GlobalGetAtomNameT GlobalGetAtomNameW
#define GetModuleFileNameT GetModuleFileNameW
#define CharPrevT CharPrevW
#define CreateFontT CreateFontW
#define LoadLibraryT LoadLibraryW
#define LoadLibraryExT LoadLibraryExW
#define RegDeleteKeyT RegDeleteKeyW
#define CreateProcessT CreateProcessW
#define RegEnumKeyExT RegEnumKeyExW
#define AppendMenuT AppendMenuW
#define OpenEventT OpenEventW
#define CreateEventT CreateEventW
#define GetDriveTypeT GetDriveTypeW
#define GetFileAttributesT GetFileAttributesW
#define RegEnumKeyT RegEnumKeyW
#define FindFirstFileT FindFirstFileW
#define GetComputerNameT GetComputerNameW
#define GetShortPathNameT GetShortPathNameW
#define GetFullPathNameT GetFullPathNameW
#define SearchPathT SearchPathW
#define GlobalFindAtomT GlobalFindAtomW
#define GetClassNameT GetClassNameW
#define lstrlenT lstrlenW
#define lstrcatT lstrcatW
#define lstrcmpT lstrcmpW
#define lstrcmpiT lstrcmpiW
#define lstrcpyT lstrcpyW
#define CreateFileMappingT CreateFileMappingW
#define OpenFileMappingT OpenFileMappingW
#define WNDCLASST WNDCLASSW

#endif  // _CHICAGO_

#endif  // _WIDEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oledll2\oledll2.c ===
//+-------------------------------------------------------------------
//
//  File:       oledll2.c
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      FunctionInAnotherDLL
//
//              This DLL is used to to test loading of in
//              InProcServer that uses another statically linked DLL.  
//              The extra DLL (OleDll2.DLL) should not be on the path 
//              when the test is run.  The entry point FuntionInAnotherDLL
//              is exported by OleDll2.DLL
//
//
//  History:	30-Jun-94      AndyH        Created
//
//---------------------------------------------------------------------

#include    <windows.h>
#include    "oledll2.h"

//+-------------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------



//
//  Entry point to DLL is traditional LibMain
//


BOOL _cdecl LibMain ( HINSTANCE hinst,
                          HANDLE    segDS,
                          UINT      cbHeapSize,
			  LPTSTR    lpCmdLine)
{
    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   FunctionInAnotherDLL
//
//  Synopsis:   Does nothing. 
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    30-Jun-94  AndyH   Created
//
//--------------------------------------------------------------------



//
//  Entry point for testing statically linked DLL.
//


BOOL FunctionInAnotherDLL ( void )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oledll2\oledll2.h ===
//+-------------------------------------------------------------------
//
//  File:       oledll2.h
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      FunctionInAnotherDLL
//
//              This DLL is used to to test loading of in
//              InProcServer that uses another statically linked DLL.  
//              The extra DLL (OleDll2.DLL) should not be on the path 
//              when the test is run.  The entry point FuntionInAnotherDLL
//              is exported by OleDll2.DLL
//
//
//  History:	30-Jun-94      AndyH        Created
//
//---------------------------------------------------------------------

//
//  Entry point for testing statically linked DLL.
//


BOOL FunctionInAnotherDLL ( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oleexts\oleexts.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oleexts.h
//
//  Contents:   macros useful for OLE debugger extensions
//
//  Classes:    none
//
//  Functions:  macros for: dprintf
//                          GetExpression
//                          GetSymbol
//                          Disassm
//                          CheckControlC
//                          DECLARE_API(...)
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#ifndef _OLEEXTS_H_
#define _OLEEXTS_H_

//
//  NTSD_EXTENSION_APIS defined in ntsdexts.h
//
//  typedef struct _NTSD_EXTENSION_APIS {
//      DWORD                   nSize;
//      PNTSD_OUTPUT_ROUTINE    lpOutputRoutine;
//      PNTSD_GET_EXPRESSION    lpGetExpressionRoutine;
//      PNTSD_GET_SYMBOL        lpGetSymbolRoutine;
//      PNTSD_DISASM            lpDisasmRoutine
//      PNTSD_CHECK_CONTROL_C   lpCheckControlCRoutine;
//  }; NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS
//
//  the following macros assume global: NTSD_EXTENSION_APIS ExtensionApis

// formatted print like CRT printf
// void dprintf(char *format [, argument] ...);
#define dprintf         (ExtensionApis.lpOutputRoutine)

// returns value of expression
// DWORD GetExpression(char *expression);
#define GetExpression   (ExtensionApis.lpGetExpressionRoutine)

// locates the nearest symbol
// void GetSymbol(LPVOID address, PUCHAR buffer, LPDWORD lpdwDisplacement);
#define GetSymbol       (ExtensionApis.lpGetSymbolRoutine)

// Disassembles an instruction
// DWORD Disassm(LPDWORD lpdwOffset, LPSTR lpBuffer, BOOL fShowEffectiveAddress);
#define Disassm         (ExtensionApis.lpGetDisasmRoutine)

// did user press CTRL+C
// BOOL CheckControlC(void);
#define CheckControlC   (ExtensionApis.lpCheckControlCRoutine)

//+-------------------------------------------------------------------------
//
//  Function Macro: DECLARE_API(...)
//
//  Synopsis:   definition for an NTSD debugger extension function
//
//  Effects:
//
//  Arguments:  [hCurrentProcess]   - Handle to current process
//              [hCurrentThread]    - Handle to current thread
//              [dwCurrentPc]       - Copy of the program counter
//              [lpExtenisonApis]   - pointer to NTSD_EXTENSION_APIS
//                                    (structure function pointers for NTSD)
//              [args]              - a string of arguments from NTSD cmd line
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              we use a function macro for defining our debugger extensions
//              functions to allow for easy extensibility
//
//              !!!function names MUST be lower case!!!
//
//--------------------------------------------------------------------------

#define DECLARE_API(s)                              \
        VOID                                        \
        s(                                          \
            HANDLE               hCurrentProcess,   \
            HANDLE               hCurrentThread,    \
            DWORD                dwCurrentPc,       \
            PNTSD_EXTENSION_APIS lpExtensionApis,   \
            LPSTR                args               \
            )

#endif // _OLEEXTS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oleexts\daytona\makefile.inc ===
obj\i386\oledbg.def: oledbg.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\assert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	assert.h
//
//  Contents:	Declaraions of assert
//
//  Classes: 	
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author
//
//--------------------------------------------------------------------------

#ifndef _ASSERT_H_
#define _ASSERT_H_

//
// Misc prototypes
//
INT_PTR CALLBACK DlgAssertProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void OleTestAssert(char *, char *, UINT);

//
// Assertion macros
//
#define Assert(x)           assert(x)
#define assert(x)			{if (!(x)) OleTestAssert(#x, __FILE__, __LINE__);}
#define AssertSz(x, exp)	{if (!(x)) OleTestAssert(exp, __FILE__, __LINE__);}

#endif //_ASSERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\app.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	app.h
//
//  Contents:	The class declaration of OleTestApp class..
//
//  Classes: 	OleTestApp
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-93 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _APP_H
#define _APP_H

//+-------------------------------------------------------------------------
//
//  Class:	OleTestApp
//
//  Purpose: 	Stores all global app data for the oletest driver app
//		(such as the to-do stack).
//
//  History:    dd-mmm-yy Author    Comment
// 		06-Feb-93 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

class OleTestApp
{
public:
	// driver information
	HINSTANCE	m_hinst;
	HWND		m_hwndMain;
	HWND		m_hwndEdit;
	TaskStack	m_TaskStack;
	BOOL		m_fInteractive;	//if TRUE, then we should not
					//shut down when tests are
					//completed.

	LPSTR		m_pszDebuggerOption;
	FILE *		m_fpLog;

    // set to TRUE when a test fails, reset after WM_TESTSCOMPLETED
    BOOL        m_fGotErrors;

	// information on running test apps
	void Reset(void);		//zeros all the data below.

	UINT		m_message;
	WPARAM		m_wparam;
	LPARAM		m_lparam;

	// variables that test routines may modify.
	HWND		m_rgTesthwnd[10];
	void *		m_Temp;		//temporary dumping ground for
					//data that spans callback functions.
};

// declaration for the global instance of OleTestApp

extern OleTestApp vApp;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\app.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  	app.cpp
//
//  Contents:	implementation of OleTestApp class methods
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"

//+-------------------------------------------------------------------------
//
//  Member: 	OleTestApp::Reset
//
//  Synopsis:	clears internal variables in the OleTestApp instance
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void OleTestApp::Reset(void)
{
	int i;

	m_message 	= NULL;
	m_wparam 	= NULL;
	m_lparam	= NULL;

	for( i = 0; i < (sizeof(m_rgTesthwnd)/sizeof(m_rgTesthwnd[0])); i++ )
	{
		m_rgTesthwnd[i] = NULL;
	}

	m_Temp = NULL;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\appwin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       appwin.h
//
//  Contents:   constants for the menu items and so forth
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//
//--------------------------------------------------------------------------

#ifndef _APPWIN_H
#define _APPWIN_H

#define IDM_EXIT        100
#define IDM_COPY        103
#define IDM_SAVE        104
#define IDM_RUN_BASE    200

#define IDD_ASSERTIONFAILURE            101

#define IDC_EDIT                        1003
#define IDB_BREAK                       1004

#endif //!_APPWIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\attest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       attest.cpp
//
//  Contents:   upper layer tests to test the apartment thread model
//
//  Classes:    CBareFactory
//              CATTestIPtrs
//
//  Functions:
//              ATTest
//              CreateEHelperQuery
//              LinkObjectQuery
//              GetClipboardQuery
//              CreateEHTest
//              LinkObjectTest
//              GetClipboardTest
//              OleLinkMethods
//              OleObjectMethods
//              PersistStorageMethods
//              DataObjectMethods
//              RunnableObjectMethods
//              ViewObject2Methods
//              OleCache2Methods
//              ExternalConnectionsMethods
//              CHECK_FOR_THREAD_ERROR (macro)
//
//  History:    dd-mmm-yy Author    Comment
//              04-Jan-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "attest.h"

#include "initguid.h"
DEFINE_GUID(CLSID_SimpSvr,
            0xBCF6D4A0,
            0xBE8C,
            0x1068,
            0xB6,
            0xD4,
            0x00,
            0xDD,
            0x01,
            0x0C,
            0x05,
            0x09);

DEFINE_GUID(CLSID_StdOleLink,
            0x00000300,
            0,
            0,
            0xC0,
            0,
            0,
            0,
            0,
            0,
            0,
            0x46);

//+-------------------------------------------------------------------------
//
//  Member:     CATTestIPtrs::CATTestIPtrs(), public
//
//  Synopsis:   constructor
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
CATTestIPtrs::CATTestIPtrs()
{
    _pOleObject         = NULL;
    _pOleCache2         = NULL;
    _pDataObject        = NULL;
    _pPersistStorage    = NULL;
    _pRunnableObject    = NULL;
    _pViewObject2       = NULL;
    _pExternalConnection= NULL;
    _pOleLink           = NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CATTestIPtrs::Reset(), public
//
//  Synopsis:   resets all pointers to NULL
//
//  Effects:    releases all objects
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   releases all objects and NULLs pointer
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CATTestIPtrs::Reset()
{
    if (_pOleObject != NULL)
    {
        _pOleObject->Release();
        _pOleObject = NULL;
    }

    if (_pOleCache2 != NULL)
    {
        _pOleCache2->Release();
        _pOleCache2 = NULL;
    }

    if (_pDataObject != NULL)
    {
        _pDataObject->Release();
        _pDataObject = NULL;
    }

    if (_pPersistStorage != NULL)
    {
        _pPersistStorage->Release();
        _pPersistStorage = NULL;
    }

    if (_pRunnableObject != NULL)
    {
        _pRunnableObject->Release();
        _pRunnableObject = NULL;
    }

    if (_pViewObject2 != NULL)
    {
        _pViewObject2->Release();
        _pViewObject2 = NULL;
    }

    if (_pExternalConnection != NULL)
    {
        _pExternalConnection->Release();
        _pExternalConnection = NULL;
    }

    if (_pOleLink != NULL)
    {
        _pOleLink->Release();
        _pOleLink = NULL;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::CBareFactory, public
//
//  Synopsis:   constructor for the class factory
//
//  Effects:
//
//  Arguments:  none
//
//  Returns:    void
//
//  Modifies:   initializes _cRefs
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
CBareFactory::CBareFactory()
{
    _cRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::QueryInterface, public
//
//  Synopsis:   only IUnknown and IClassFactory are supported
//
//  Effects:
//
//  Arguments:  [iid]   -- the requested interface
//              [ppvObj]-- where to put the interface pointer
//
//  Returns:    HRESULT
//
//  Modifies:   ppvObj
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CBareFactory::QueryInterface (REFIID iid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(iid, IID_IClassFactory) ||
	IsEqualIID(iid, IID_IUnknown) )
    {
	*ppvObj = this;
	AddRef();
	return NOERROR;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::AddRef, public
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  none
//
//  Returns:    ULONG -- the new reference count
//
//  Modifies:
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBareFactory::AddRef (void)
{
    _cRefs++;
    return _cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::Release, public
//
//  Synopsis:   decrements the reference count
//
//  Effects:    deletes object when reference count is zero
//
//  Arguments:  none
//
//  Returns:    ULONG -- the new reference count
//
//  Modifies:
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBareFactory::Release (void)
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::CreateInstance, public
//
//  Synopsis:   does nothing
//
//  Effects:
//
//  Arguments:  [pUnkOuter] --  the controlling unknown for aggregation
//              [iid]       -- the requested interface
//              [ppvObj]    -- where to put the interface pointer
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CBareFactory::CreateInstance (
            LPUNKNOWN pUnkOuter,
            REFIID iid,
	    LPVOID FAR* ppv)
{
    return E_NOTIMPL;;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::LockServer, public
//
//  Synopsis:   does nothing
//
//  Effects:
//
//  Arguments:  [flock] --  specifies the lock count
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CBareFactory::LockServer ( BOOL fLock )
{
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   CHECK_FOR_THREAD_ERROR (macro)
//
//  Synopsis:   make sure that the hresult is RPC_E_WRONG_THREAD
//
//  Effects:    exits thread if hresult != RPC_E_WRONG
//
//  Arguments:  [hresult]   --  error code
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
#define CHECK_FOR_THREAD_ERROR(hresult) \
    if (hresult != RPC_E_WRONG_THREAD) \
    { \
       OutputString("Expected RPC_E_WRONG_THREAD but received %x.\r\n", hresult); \
       assert(hresult == RPC_E_WRONG_THREAD); \
       ExitThread((DWORD)E_UNEXPECTED); \
    }

// globals
CATTestIPtrs g_IPtrs;

//+-------------------------------------------------------------------------
//
//  Function:   ATTest
//
//  Synopsis:   calls the query functions to get pointers to the
//              supported interfaces
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   globals g_IPtrs._pOleObject
//                      g_IPtrs._pPersistStorage
//                      g_IPtrs._pDataObject
//                      g_IPtrs._pRunnableObject
//                      g_IPtrs._pViewObject2
//                      g_IPtrs._pOleCache2
//                      g_IPtrs._pExternalConnection
//                      g_IPtrs._pOleLink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

void ATTest(void)
{
    HRESULT hresult;

    hresult = OleInitialize(NULL);
    assert(hresult == S_OK);

    // the functions CreateEHelperQuery, LinkObjectQuery and
    // GetClipboardQuery return either NOERROR or E_UNEXPECTED.
    // NOERROR is defined as 0
    hresult  = CreateEHelperQuery();

    g_IPtrs.Reset();
    hresult |= LinkObjectQuery();

    g_IPtrs.Reset();
    hresult |= GetClipboardQuery();

    vApp.Reset();
    vApp.m_wparam = (hresult == NOERROR) ? TEST_SUCCESS : TEST_FAILURE;
    vApp.m_lparam = (LPARAM)hresult;
    vApp.m_message = WM_TESTEND;

    HandleTestEnd();

    OleUninitialize();

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetClipboardQuery
//
//  Synopsis:   get a pointer to IDataObject interface, create a new thread
//              to test proper exit/error codes, wait for the thread to
//              complete and return the thread's exit code
//
//  Effects:    creates new thread
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   g_IPtrs._pDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT GetClipboardQuery(void)
{
    HRESULT hresult;
    HANDLE  hTestInterfaceThread;
    DWORD   dwThreadId = 0;
    DWORD   dwThreadExitCode;

    hresult = OleGetClipboard( &g_IPtrs._pDataObject );
    assert(hresult == S_OK );

    hTestInterfaceThread = CreateThread(
                NULL,                                       // security attributes
                0,                                          // stack size (default)
                (LPTHREAD_START_ROUTINE)&GetClipboardTest,  // address of thread function
                NULL,                                       // arguments of thread function
                0,                                          // creation flags
                &dwThreadId );                              // address of new thread ID

    assert(hTestInterfaceThread != NULL); //ensure that we have a valid thread handle

    // wait for the thread object so we can examine the error code
    WaitForSingleObject(hTestInterfaceThread, INFINITE);

    GetExitCodeThread(hTestInterfaceThread, &dwThreadExitCode);

    hresult = (HRESULT)dwThreadExitCode;

    CloseHandle(hTestInterfaceThread);

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   LinkObjectQuery
//
//  Synopsis:   get a pointer to available interfaces, create a new thread
//              to test proper exit/error codes, wait for the thread to
//              complete and return the thread's exit code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   g_IPtrs._pOleObject
//              g_IPtrs._pPersistStorage
//              g_IPtrs._pDataObject
//              g_IPtrs._pRunnableObject
//              g_IPtrs._pViewObject2
//              g_IPtrs._pOleCache2
//              g_IPtrs._pOleLink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT LinkObjectQuery(void)
{
    HRESULT hresult;
    HANDLE  hTestInterfaceThread;
    DWORD   dwThreadId = 0;
    DWORD   dwThreadExitCode;

    hresult = CoCreateInstance(
                CLSID_StdOleLink,               // class ID of the object class
                NULL,                           // controlling unknown fro aggregation
                CLSCTX_INPROC,                  // context to run executables
                IID_IOleObject,                 // the requested interface
                (void **)&g_IPtrs._pOleObject); // where to store pointer to interface
    assert(hresult == S_OK);


    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IPersistStorage, (void **)&g_IPtrs._pPersistStorage);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IDataObject, (void **)&g_IPtrs._pDataObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IRunnableObject, (void **)&g_IPtrs._pRunnableObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IViewObject2, (void **)&g_IPtrs._pViewObject2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IOleCache2, (void **)&g_IPtrs._pOleCache2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IOleLink, (void **)&g_IPtrs._pOleLink);
    assert(hresult == S_OK);

    hTestInterfaceThread = CreateThread(
                NULL,                                   // security attributes
                0,                                      // stack size (default)
                (LPTHREAD_START_ROUTINE)&LinkObjectTest,// address of thread function
                NULL,                                   // arguments of thread function
                0,                                      // creation flags
                &dwThreadId );                          // address of new thread ID

    assert(hTestInterfaceThread != NULL); //ensure that we have a valid thread handle

    // wait for the thread object so we can examine the error code
    WaitForSingleObject(hTestInterfaceThread, INFINITE);

    GetExitCodeThread(hTestInterfaceThread, &dwThreadExitCode);

    hresult = (HRESULT)dwThreadExitCode;

    CloseHandle(hTestInterfaceThread);

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateEHelperQuery
//
//  Synopsis:   get a pointer to available interfaces, create a new thread
//              to test proper exit/error codes, wait for the thread to
//              complete and return the thread's exit code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   g_IPtrs._pOleObject
//              g_IPtrs._pPersistStorage
//              g_IPtrs._pDataObject
//              g_IPtrs._pRunnableObject
//              g_IPtrs._pViewObject2
//              g_IPtrs._pOleCache2
//              g_IPtrs._pExternalConnection
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT CreateEHelperQuery(void)
{
    HRESULT         hresult;
    HANDLE          hTestInterfaceThread;
    DWORD           dwThreadId = 0;
    DWORD           dwThreadExitCode;
    CBareFactory   *pCF = new CBareFactory;

    // must use EMBDHLP_DELAYCREATE flag otherwise API will try pCF->CreateInstance
    // and verify pointer. CBareFactory::CreateInstance is not implemented!
    hresult = OleCreateEmbeddingHelper(
                CLSID_SimpSvr,                              // class ID of the server
                NULL,                                       // controlling unknown for aggregation
                EMBDHLP_INPROC_SERVER | EMBDHLP_DELAYCREATE,// flags
                pCF,                                        // pointer to server's class factory
                IID_IOleObject,                             // the requested interface
                (void **)&g_IPtrs._pOleObject );            // where to store pointer to interface
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IPersistStorage, (void **)&g_IPtrs._pPersistStorage);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IDataObject, (void **)&g_IPtrs._pDataObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IRunnableObject, (void **)&g_IPtrs._pRunnableObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IViewObject2, (void **)&g_IPtrs._pViewObject2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IOleCache2, (void **)&g_IPtrs._pOleCache2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IExternalConnection, (void **)&g_IPtrs._pExternalConnection);
    assert(hresult == S_OK);

    hTestInterfaceThread = CreateThread(
                NULL,                                   // security attributes
                0,                                      // stack size (default)
                (LPTHREAD_START_ROUTINE)&CreateEHTest,  // address of thread function
                NULL,                                   // arguments of thread function
                0,                                      // creation flags
                &dwThreadId );                          // address of new thread ID

    assert(hTestInterfaceThread != NULL); //ensure that we have a valid thread handle

    // wait for the thread object so we can examine the exit/error code
    WaitForSingleObject(hTestInterfaceThread, INFINITE);

    GetExitCodeThread(hTestInterfaceThread, &dwThreadExitCode);

    hresult = (HRESULT)dwThreadExitCode;

    CloseHandle(hTestInterfaceThread);

    pCF->Release();

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetClipBoardTest
//
//  Synopsis:   calls interface method functions and exits thread
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      all the interface methods are being called from a thread
//              which is not the owner. The methods should return
//              RPC_E_WRONG_THREAD error. If an interface method does not
//              return such error message, it is asserted and the
//              thread is exited with an E_UNEXPECTED exit code.
//
//--------------------------------------------------------------------------
void GetClipboardTest(void)
{
    DataObjectMethods();

    ExitThread((DWORD)NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   LinkObjectTest
//
//  Synopsis:   calls interface method functions and exits thread
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      all the interface methods are being called from a thread
//              which is not the owner. The methods should return
//              RPC_E_WRONG_THREAD error. If an interface method does not
//              return such error message, it is asserted and the
//              thread is exited with an E_UNEXPECTED exit code.
//
//--------------------------------------------------------------------------
void LinkObjectTest(void)
{
    OleObjectMethods();

    PersistStorageMethods();

    DataObjectMethods();

    RunnableObjectMethods();

    OleCache2Methods();

    ViewObject2Methods();

    OleLinkMethods();

    ExitThread((DWORD)NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateEHTest
//
//  Synopsis:   calls interface method functions and exits thread
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      all the interface methods are being called from a thread
//              which is not the owner. The methods should return
//              RPC_E_WRONG_THREAD error. If an interface method does not
//              return such error message, it is asserted and the
//              thread is exited with an E_UNEXPECTED exit code.
//
//--------------------------------------------------------------------------
void CreateEHTest(void)
{
    ExternalConnectionsMethods();

    OleObjectMethods();

    PersistStorageMethods();

    DataObjectMethods();

    RunnableObjectMethods();

    ViewObject2Methods();

    OleCache2Methods();

    ExitThread((DWORD)NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleLinkMethods
//
//  Synopsis:   Calls all public IOleLink interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void OleLinkMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pOleLink->SetUpdateOptions(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetUpdateOptions(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->SetSourceMoniker(NULL, CLSID_NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetSourceMoniker(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->SetSourceDisplayName(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetSourceDisplayName(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->BindToSource(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->BindIfRunning();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetBoundSource(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->UnbindSource();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->Update(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   ExternalConnectionsMethods
//
//  Synopsis:   Calls all public IExternalConnection interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void ExternalConnectionsMethods(void)
{
    HRESULT hresult;

    hresult = (HRESULT)g_IPtrs._pExternalConnection->AddConnection(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = (HRESULT)g_IPtrs._pExternalConnection->ReleaseConnection(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleObjectMethods
//
//  Synopsis:   Calls all public IOleObject interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void OleObjectMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pOleObject->SetClientSite(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetClientSite(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetHostNames(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Close(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetMoniker(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetMoniker(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->InitFromData(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetClipboardData(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->DoVerb(NULL, NULL, NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->EnumVerbs(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Update();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->IsUpToDate();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetUserClassID(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetUserType(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetExtent(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetExtent(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Advise(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Unadvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->EnumAdvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetMiscStatus(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetColorScheme(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   PersistStorageMethods
//
//  Synopsis:   Calls all public IPersistStorage interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void PersistStorageMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pPersistStorage->GetClassID(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->IsDirty();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->InitNew(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->Load(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->Save(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->SaveCompleted(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->HandsOffStorage();
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   DataObjectMethods
//
//  Synopsis:   Calls all public IDataObject interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void DataObjectMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pDataObject->GetData(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->GetDataHere(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->QueryGetData(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->GetCanonicalFormatEtc(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->SetData(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->EnumFormatEtc(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->DAdvise(NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->DUnadvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->EnumDAdvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunnableObjectMethods
//
//  Synopsis:   Calls all public IRunnableObject interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void RunnableObjectMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pRunnableObject->GetRunningClass(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->Run(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->IsRunning();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->LockRunning(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->SetContainedObject(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   ViewObject2Methods
//
//  Synopsis:   Calls all public IViewObject2 interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void ViewObject2Methods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pViewObject2->Draw(NULL, NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->GetColorSet(NULL, NULL, NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->Freeze(NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->Unfreeze(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->SetAdvise(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->GetAdvise(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->GetExtent(NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleCache2Methods
//
//  Synopsis:   Calls all public IOleCache2 interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void OleCache2Methods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pOleCache2->Cache(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->Uncache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->EnumCache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->InitCache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->SetData(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->UpdateCache(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->DiscardCache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\assert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   assert.cpp
//
//  Contents:   Assertion handling code for OleTest
//
//  Classes:
//
//  Functions:  OleTestAssert
//              DlgAssertProc
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author              
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "appwin.h"

//+-------------------------------------------------------------------------
//
//  Function:   OleTestAssert
//
//  Synopsis:   Reports assertion failures to the user
//
//  Effects:
//
//  Arguments:  [pszMessage]    -- the assertion message
//              [pszFile]       -- the file it occured in
//              [uLine]         -- the line it occured at
//
//  Requires:   
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Format the message and then put up a dialog box for the user.
//              They can then choose to abort the test, break to the debugger,
//              or ignore the assertion.
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

void OleTestAssert(char *pszMessage, char *pszFile, UINT uLine)
{
    char        szErrorMessage[3 * 80];         // room for 3 lines of info
    int         cch;
    int         nAction;

    OutputDebugString("OleTest -- Assertion Failure\r\n");

    //
    // format the message
    //
        
    cch = _snprintf(szErrorMessage,
            sizeof(szErrorMessage),
            "%s\r\nIn file: %s\r\nAt line: %u",
            pszMessage,
            pszFile,
            uLine);

    if (cch < 0)
    {
        //
        // the whole assertion message doesn't fit in the buffer so
        // just worry about the file name and line number
        //

        OutputDebugString(pszMessage);  // send original text to the debugger
        OutputDebugString("\r\n");
                
        _snprintf(szErrorMessage,
                sizeof(szErrorMessage),
                "In file: %s\r\nAt line: %d",
                pszFile, 
                uLine);

        szErrorMessage[sizeof(szErrorMessage) - 1] = '\0';  // just in case
    }

    OutputDebugString(szErrorMessage);
    OutputDebugString("\r\n");

    nAction = DialogBoxParam(vApp.m_hinst,          // get the users choice
            MAKEINTRESOURCE(IDD_ASSERTIONFAILURE), 
            vApp.m_hwndMain, 
            DlgAssertProc,
            (LPARAM) szErrorMessage);
          
    switch (nAction)
    {
    case IDABORT:                                   // abort the test
        RaiseException(E_ABORT, 0, 0, NULL);

    case IDB_BREAK:                                 // break into the debugger
        DebugBreak();
        break;

    case IDIGNORE:                                  // ignore the assertion
        break;

    default:                                        // whoops
        RaiseException(E_UNEXPECTED, 0, 0, NULL);
    }
}   


//+-------------------------------------------------------------------------
//
//  Function:   DlgAssertProc
//
//  Synopsis:   Window procedure for the assertion dialog box
//
//  Effects:
//
//  Arguments:  [hWnd]      -- dialog window
//              [uMsg]      -- message
//              [wParam]    -- wParam
//              [lParam]    -- lParam (for INITDIALOG it points to assert text)
//
//  Requires:   
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Just wait for a button to be pressed
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK DlgAssertProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        DeleteMenu(GetSystemMenu(hWnd, FALSE), SC_CLOSE, MF_BYCOMMAND);
        DrawMenuBar(hWnd);

        SetDlgItemText(hWnd, IDC_EDIT, (LPCSTR) lParam);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDABORT:
            case IDB_BREAK:
            case IDIGNORE:
                EndDialog(hWnd, LOWORD(wParam));
                return TRUE;
                            
            default:
                return FALSE;
        }

    default:
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\attest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       attest.h
//
//  Contents:   declarations for upper layer apartment thread test
//
//  Classes:    CBareFactory
//              CATTestIPtrs
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Jan-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#ifndef _ATTEST_H
#define _ATTEST_H

//+-------------------------------------------------------------------------
//
//  Class:
//
//  Purpose:
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//
//--------------------------------------------------------------------------

class CATTestIPtrs
{

public:
    CATTestIPtrs();

    STDMETHOD(Reset)();

    IOleObject          *_pOleObject;
    IOleCache2          *_pOleCache2;
    IDataObject         *_pDataObject;
    IPersistStorage     *_pPersistStorage;
    IRunnableObject     *_pRunnableObject;
    IViewObject2        *_pViewObject2;
    IExternalConnection *_pExternalConnection;
    IOleLink            *_pOleLink;
};

//+-------------------------------------------------------------------------
//
//  Class:      CBareFactory
//
//  Purpose:    use as a class factory which doesn't do anything in
//              OleCreateEmbeddingHelper API
//
//  Interface:  IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CBareFactory : public IClassFactory
{

public:
    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);
    STDMETHOD(CreateInstance) (LPUNKNOWN pUnkOuter, REFIID iid,
				    LPVOID FAR* ppv);
    STDMETHOD(LockServer) ( BOOL fLock );

    CBareFactory();

private:
    ULONG		_cRefs;
};

// runs 3 test routines and returns results
void    ATTest(void);

// get pointers to interfaces and creates thread to ensure
// interface methods return RPC_E_WRONG_ERROR
HRESULT CreateEHelperQuery(void);

HRESULT LinkObjectQuery(void);

HRESULT GetClipboardQuery(void);

// new thread functions to try interface methods
void    LinkObjectTest(void);

void    CreateEHTest(void);

void    GetClipboardTest(void);

// interface methods with NULL parameters
void    OleLinkMethods(void);

void    OleObjectMethods(void);

void    PersistStorageMethods(void);

void    DataObjectMethods(void);

void    RunnableObjectMethods(void);

void    ViewObject2Methods(void);

void    OleCache2Methods(void);

void    ExternalConnectionsMethods(void);

#endif  //!ATTEST_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\cotest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cotest.h
//
//  Contents:   declarations for all compobj test routines
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-94 ricksa    author
//
//--------------------------------------------------------------------------

#ifndef _COTEST_H
#define _COTEST_H

HRESULT ThreadUnitTest(void);


#endif // _COTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\cliptest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	cliptest.cpp
//
//  Contents: 	Clipboard Unit tests
//
//  Classes:
//
//  Functions:	LEClipTest1
//
//  History:    dd-mmm-yy Author    Comment
//		23-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "gendata.h"
#include "genenum.h"
#include "letest.h"

SLETestInfo letiClipTest = { "cntroutl", WM_TEST1 };

//
// functions local to this file
//

void	DumpClipboardFormats(FILE *fp);
HRESULT LEOle1ClipTest2Callback( void );
HRESULT	StressOleFlushClipboard(void);
HRESULT	StressOleGetClipboard(void);
HRESULT	StressOleIsCurrentClipboard(void);
HRESULT	StressOleSetClipboard(void);


class CClipEnumeratorTest : public CEnumeratorTest
{
public:

        CClipEnumeratorTest(
            IEnumFORMATETC *penum,
            LONG clEntries,
            HRESULT& rhr);

        BOOL Verify(void *);
};



CClipEnumeratorTest::CClipEnumeratorTest(
    IEnumFORMATETC *penum,
    LONG clEntries,
    HRESULT& rhr)
        : CEnumeratorTest(penum, sizeof(FORMATETC), clEntries, rhr)
{
    // Header does all the work
}


BOOL CClipEnumeratorTest::Verify(void *)
{
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: 	DumpClipboardFormats
//
//  Synopsis:	dumps the formats currently on the clipboard to a file
//
//  Effects:
//
//  Arguments:	[fp]	-- the file to print the current formats
//
//  Requires:	
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		11-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpClipboardFormats( FILE *fp )
{
	char	szBuf[256];
	UINT	cf = 0;

	fprintf(fp, "==================================================\n\n");

	OpenClipboard(NULL);

	while( (cf = EnumClipboardFormats(cf)) != 0)
	{
		GetClipboardFormatName(cf, szBuf, sizeof(szBuf));

		fprintf(fp, "%s\n", szBuf);
	}

	fprintf(fp, "\n==================================================\n");

	CloseClipboard();

	return;
}

//+-------------------------------------------------------------------------
//
//  Function: 	LEClipTest1
//
//  Synopsis: 	runs the clipboard through a series of tests
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Tests basic OLE32 functionality of the apis:
//			OleSetClipboard
//			OleGetClipboard
//			OleIsCurrentClipboard
//			OleFlushClipboard
//		downlevel format and clipboard data object testing is *not*
//		done by this routine
//
//  History:    dd-mmm-yy Author    Comment
//	 	23-Mar-94 alexgo    author
//              22-Jul-94 AlexT     Add OleInit/OleUninit call
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEClipTest1( void )
{
	HRESULT		hresult = NOERROR;
	CGenDataObject *pDO;
	ULONG		cRefs;
	IDataObject *	pIDO;

	pDO = new CGenDataObject;

	assert(pDO);

	cRefs = pDO->AddRef();

	// if cRefs != 1, then somebody modified this test code; the tests
	// below will be invalid.

	assert(cRefs==1);

	//
	//	Basic Tests
	//

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// the data object should have been AddRef'ed

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Wrong reference count!! Should be 3, "
			"was %lu\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

        //  Calling OleInitialize & OleUninitialize should not disturb the
        //  clipboard

        hresult = OleInitialize(NULL);
        if (FAILED(hresult))
        {
	    OutputString("LEClipTest1: OleInitialize failed - hr = %lx\n",
			 hresult);
	    return ResultFromScode(E_FAIL);
        }

        OleUninitialize();

	hresult = OleGetClipboard(&pIDO);

	if( hresult != NOERROR )
	{
		OutputString("OleGetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	if( pIDO == NULL )
	{
		OutputString("OleGetClipboard returned NULL IDO\r\n");
		return ResultFromScode(E_FAIL);
	}

	// the reference count on the clipboard data object should have gone up
	// by one (to be 2). Remember this is not our data object but
        // the clipboard's.

	cRefs = pIDO->AddRef();

	if( cRefs != 2 )
	{
		OutputString("Wrong ref count!! Should be 2, was %lu\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

        // Release the clipboard data object's extra add ref.

	pIDO->Release();

        // Release the clipboard's data object entirely.

	pIDO->Release();

        // the reference count on our data object should be 2 still

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Wrong ref count!! Should be 3, was %lu\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	// now check to see if the we are the current clipboard

	hresult = OleIsCurrentClipboard( pDO );

	if( hresult != NOERROR )
	{
		OutputString("OleIsCurrentClipboard failed! (%lx)\r\n",
			hresult);
		return hresult;
	}

	// now flush the clipboard, removing the data object

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("OleFlushClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// Flush should have released the data object (ref count should
	// be 1)

	cRefs = pDO->AddRef();

	if( cRefs != 2 )
	{
		OutputString("Wrong ref count!! Should be 2, was %lu\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();		// take it down to 1
	cRefs = pDO->Release();	// should be zero now

	if(cRefs != 0 )
	{
		OutputString("Wrong ref count on data transfer object! "
			"Unable to delete\r\n");
		return ResultFromScode(E_FAIL);
	}

	// if we got this far, basic clipboard tests passed

	OutputString("Basic Clipboard tests passed\r\n");

	// now stress individual API's

	OutputString("Now stressing clipboard API's\r\n");

	if( (hresult = StressOleFlushClipboard()) != NOERROR )
	{
		return hresult;
	}

	if( (hresult = StressOleGetClipboard()) != NOERROR )
	{
		return hresult;
	}

	if( (hresult = StressOleIsCurrentClipboard()) != NOERROR )
	{
		return hresult;
	}

	if( (hresult = StressOleSetClipboard()) != NOERROR )
	{
		return hresult;
	}

	OutputString("Clipoard API stress passed!\r\n");

	return NOERROR;
	
}

//+-------------------------------------------------------------------------
//
//  Function:	LEClipTest2
//
//  Synopsis:	Tests the clipboard data object
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEClipTest2( void )
{
	CGenDataObject *	pGenData;
	IDataObject *		pDataObj;
	HRESULT			hresult;
	IEnumFORMATETC * 	penum;
	FORMATETC		formatetc;
	STGMEDIUM		medium;
	ULONG			cRefs;

	pGenData = new CGenDataObject();

	assert(pGenData);

	cRefs = pGenData->AddRef();

	// ref count should be 1

	assert(cRefs == 1);

	hresult = OleSetClipboard(pGenData);

	if( hresult != NOERROR )
	{
		OutputString("Clip2: OleSetClipboard failed! (%lx)\r\n",
			hresult);
		goto errRtn2;
	}

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("Clip2: OleFlushClipboard failed! (%lx)\r\n",
			hresult);
		goto errRtn2;
	}

	// get the fake clipboard data object

	hresult = OleGetClipboard(&pDataObj);

	if( hresult != NOERROR )
	{
		OutputString("Clip2: OleGetClipboard failed! (%lx)\r\n",
			hresult);
		goto errRtn2;
	}

	hresult = pDataObj->EnumFormatEtc(DATADIR_GET, &penum);

	if( hresult != NOERROR )
	{
		OutputString("Clip2: EnumFormatEtc failed! (%lx)\r\n",
			hresult);
		goto errRtn;
	}

	while( penum->Next( 1, &formatetc, NULL ) == NOERROR )
	{
		if( formatetc.cfFormat == pGenData->m_cfTestStorage ||
			formatetc.cfFormat == pGenData->m_cfEmbeddedObject )
		{
			// we should be told IStorage

			if( !(formatetc.tymed & TYMED_ISTORAGE) )
			{
				hresult = ResultFromScode(E_FAIL);
				OutputString("medium mismatch, ISTORAGE");
				break;
			}
		}

		hresult = pDataObj->GetData(&formatetc, &medium);

		if( hresult != NOERROR )
		{
			break;
  		}

		// verify the data

		if( !pGenData->VerifyFormatAndMedium(&formatetc, &medium) )
		{
      			hresult = ResultFromScode(E_FAIL);
			OutputString("Clip2: retrieved data doesn't match! "
				"cf == %d\r\n", formatetc.cfFormat);
			break;
		}

		ReleaseStgMedium(&medium);

		memset(&medium, 0, sizeof(STGMEDIUM));

	}

        {
                CClipEnumeratorTest cet(penum, -1, hresult);

	        if (hresult == S_OK)
	        {
		        hresult = cet.TestAll();
	        }
        }

	penum->Release();
		

errRtn:
	pDataObj->Release();

errRtn2:
	pGenData->Release();

	if( hresult == NOERROR )
	{
		OutputString("Clipboard data object tests Passed!\r\n");
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	LEOle1ClipTest1
//
//  Synopsis: 	Simple tests of OLE1 clipboard compatibility (copy from
//		and OLE1 server)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Run through 15 combinations of OLE1 support and verify
//		everything came out OK
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEOle1ClipTest1( void )
{
	HRESULT			hresult;
	DWORD			flags;
	CGenDataObject *	pGenData = NULL;
	IDataObject *		pDataObj = NULL;
	IEnumFORMATETC *	penum = NULL;
	FORMATETC		formatetc;
	STGMEDIUM		medium;

	// we are going to take advantage of the fact that the interesting
	// OLE1 bit flags for this test are the bottom 4 bits.

	pGenData = new CGenDataObject();

	assert(pGenData);

	for( flags = 1; flags < 16; flags++ )
	{
		// test #8 is not interesting (because no ole1
		// formats are offered on the clipboard

		if( (Ole1TestFlags)flags == OLE1_OWNERLINK_PRECEDES_NATIVE )
		{
			continue;
		}

		// setup the OLE1 mode desired

		pGenData->SetupOle1Mode((Ole1TestFlags)flags);

	
		hresult = pGenData->SetOle1ToClipboard();

		if( hresult != NOERROR )
		{
			goto errRtn;
		}

		// log the formats that are currently on the clipboard
		DumpClipboardFormats(vApp.m_fpLog);

		// get the fake clipboard data object
	
		hresult = OleGetClipboard(&pDataObj);
	
		if( hresult != NOERROR )
		{
			OutputString("Ole1Clip1: OleGetClipboard failed! "
				"(%lx)\r\n", hresult);
			goto errRtn;
		}
	
		hresult = pDataObj->EnumFormatEtc(DATADIR_GET, &penum);
	
		if( hresult != NOERROR )
		{
			OutputString("Ole1Clip1: EnumFormatEtc failed! "
				"(%lx)\r\n", hresult);
			goto errRtn;
		}
	
		while( penum->Next( 1, &formatetc, NULL ) == NOERROR )
		{
			DumpFormatetc(&formatetc, vApp.m_fpLog);

#ifdef WIN32
			hresult = pDataObj->GetData(&formatetc, &medium);
	
			if( hresult != NOERROR )
			{
				goto errRtn;
			}
	
			// verify the data
	
			if( !pGenData->VerifyFormatAndMedium(&formatetc,
				&medium) )
			{
				hresult = ResultFromScode(E_FAIL);
				OutputString("Ole1Clip1: retrieved data "
					"doesn't match! cf == %d\r\n",
					formatetc.cfFormat);
				goto errRtn;
			}
	
			ReleaseStgMedium(&medium);
	
			memset(&medium, 0, sizeof(STGMEDIUM));

#endif // WIN32
		}

		// now release everything

		penum->Release();
		penum = NULL;
		pDataObj->Release();
		pDataObj = NULL;
	}

errRtn:

	if( penum )
	{
		penum->Release();
	}

	if( pDataObj )
	{
		pDataObj->Release();
	}

	if( pGenData )
	{
		pGenData->Release();
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	LEOle1ClipTest2
//
//  Synopsis: 	Tests OLE1 container support via the clipboard
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Start cntroutl, tell it to copy a simpsvr object to the
//		clipboard.  Check the clipboard to make sure OLE1 formats
//		are available.
//
//		We do this by sheduling a function to check the clipboard
//		after we've launched the standard copy-to-clipboard
//		routines.
//
//  History:    dd-mmm-yy Author    Comment
//  		16-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void LEOle1ClipTest2( void *pv )
{
	// this will get triggered by the return of WM_TEST1 from
	// container outline

	vApp.m_TaskStack.Push(RunApi, (void *)LEOle1ClipTest2Callback);

	vApp.m_TaskStack.Push(LETest1, (void *)&letiClipTest);

	// now post a message to ourselves to get things rollling

	PostMessage(vApp.m_hwndMain, WM_TEST1, 0, 0);

	return;
}

//+-------------------------------------------------------------------------
//
//  Function:	LEOle1ClipTest2Callback
//
//  Synopsis: 	checks the clipboard for OLE1 formats
//
//  Effects:
//
//  Arguments:	[pv]	-- unused
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		20-Aug-94 alexgo    updated to cfObjectLink test
//		16-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEOle1ClipTest2Callback( void )
{
	HRESULT		hresult;
	IDataObject *	pDO;
	IEnumFORMATETC *penum;
	FORMATETC	formatetc;
	BOOL		fGotNative = FALSE,
			fGotOwnerLink = FALSE,
			fGotObjectLink = FALSE;
	UINT		cfNative,
			cfOwnerLink,
			cfObjectLink;

	cfNative = RegisterClipboardFormat("Native");
	cfOwnerLink = RegisterClipboardFormat("OwnerLink");
	cfObjectLink = RegisterClipboardFormat("ObjectLink");

	assert(vApp.m_message == WM_TEST1);

	hresult = (HRESULT)vApp.m_wparam;

	if( hresult != NOERROR )
	{
		return hresult;
	}

	// we need to wait for cntroutl to shut down before
	// fetching the clipboard

	while( (hresult = OleGetClipboard(&pDO)) != NOERROR )
	{
		if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
		{
			return hresult;
		}
	}

	hresult = pDO->EnumFormatEtc(DATADIR_GET, &penum);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	while( penum->Next(1, &formatetc, NULL) == NOERROR )
	{
		if( formatetc.cfFormat == cfNative )
		{
			fGotNative = TRUE;
		}
		else if( formatetc.cfFormat == cfOwnerLink )
		{
			fGotOwnerLink = TRUE;
		}
		else if( formatetc.cfFormat == cfObjectLink )
		{
			fGotObjectLink = TRUE;
		}
	}

	penum->Release();
	pDO->Release();

	// the OLE1 container compatibility code should put
	// OLE1 formats on the clipboard.  However, they should NOT
	// be in the enumerator since the stuff was copied from
	// an OLE2 container.

	if( (fGotNative || fGotOwnerLink || fGotObjectLink) )
	{
		hresult = ResultFromScode(E_FAIL);
		return hresult;
	}

	if( IsClipboardFormatAvailable(cfNative) )
	{
		fGotNative = TRUE;
	}

	if( IsClipboardFormatAvailable(cfOwnerLink) )
	{
		fGotOwnerLink = TRUE;
	}

	if( IsClipboardFormatAvailable(cfObjectLink) )
	{
		fGotObjectLink = TRUE;
	}

	// NB!!  only Native and OwnerLink should be on the clipboard
	// this test puts an OLE2 *embedding* on the clipbaord, which
	// an OLE1 container cannot link to.  So ObjectLink should not
	// be available

	if( !(fGotNative && fGotOwnerLink && !fGotObjectLink) )
	{
		hresult = ResultFromScode(E_FAIL);

	}

	return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:	StressOleFlushClipboard
//
//  Synopsis: 	
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	stresses the following cases:
//		1.  Caller is not the clipboard owner (somebody else put
//			data on the clipboard)
//		2.  somebody else has the clipboard open
//		3.  OleFlushClipboard is called twice (second attempt should
//			not fail).
//
//  History:    dd-mmm-yy Author    Comment
//		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT StressOleFlushClipboard(void)
{
	HRESULT		hresult;
	CGenDataObject *pDO;
	ULONG		cRefs;

	OutputString("Now stressing OleFlushClipboard() \r\n");

	pDO = new CGenDataObject();

	assert(pDO);

	pDO->AddRef();		//initial count of 1

	//take ownership of the clipboard

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	if( !EmptyClipboard() )
	{
		OutputString("Can't EmptyClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_EMPTY);
	}

	if( !CloseClipboard() )
	{
		OutputString("Can't CloseClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_CLOSE);
	}

	// now to flush the clipboard; we should get E_FAIL

	hresult = OleFlushClipboard();

	if( hresult != ResultFromScode(E_FAIL) )
	{
		OutputString("Unexpected hresult:(%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// now put something on the clipboard so we can flush it

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// open the clipboard with us

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	// OleFlushClipboard should return with CLIPBRD_E_CANT_OPEN
	// since another window has the clipboard open

	hresult = OleFlushClipboard();

	if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
	{
		OutputString("Unexpected hresult:(%lx)\r\n", hresult);
		return (hresult)? hresult :ResultFromScode(E_UNEXPECTED);
	}

	cRefs = pDO->AddRef();

	// cRefs should be 3 (one from beginning, one from OleSetClipboard
	// and 1 from above.  OleFlushClipboard should *not* remove the
	// count for the above failure case)

	if( cRefs != 3 )
	{
		OutputString("Bad ref count, was %lu, should be 3\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

	// undo the most recent addref above
	pDO->Release();

	// close the clipboard

	if( !CloseClipboard() )
	{
		OutputString("Can't CloseClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_CLOSE);
	}

	// now call OleFlushClipboard for real

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("OleFlushClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// now call it once more

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("Second call to OleFlushClipboard should not"
			"have failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// there should have only been 1 release from the first
	// OleFlushClipboard call.  This next release should nuke the object

	cRefs = pDO->Release();

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	StressOleGetClipboard
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tests the following cases:
//		1. somebody else has the clipboard open
//
//  History:    dd-mmm-yy Author    Comment
// 		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT StressOleGetClipboard(void)
{
	HRESULT		hresult;
	IDataObject *	pIDO;
	CGenDataObject *pDO;
	ULONG		cRefs;

	OutputString("Stressing OleGetClipboard()\r\n");

	pDO = new CGenDataObject();

	assert(pDO);

	pDO->AddRef();

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	hresult = OleGetClipboard(&pIDO);

	if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// the ref count should not have gone up

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Bad ref count, was %lu, should be 3\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	// now clear stuff out and go home

	if( !CloseClipboard() )
	{
		OutputString("CloseClipboard failed!\r\n");
		return ResultFromScode(E_FAIL);
	}

	// this should clear the clipboard

	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// this should be the final release on the object

	cRefs = pDO->Release();

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	StressOleIsCurrentClipboard
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	tests the following cases
//		1. the caller is not the clipboard owner
//		2. somebody else has the clipboard open
//		2. the data object is NULL
//		3. the data object is not the data object put on the clipboard
//
//  History:    dd-mmm-yy Author    Comment
//		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT StressOleIsCurrentClipboard(void)
{
	HRESULT         hresult;
	CGenDataObject *pDO, *pDO2;
	ULONG		cRefs;

	OutputString("Stressing OleIsCurrentClipboard()\r\n");

	pDO = new CGenDataObject();
	pDO2 = new CGenDataObject();

	assert(pDO);
	assert(pDO2);

	pDO->AddRef();
	pDO2->AddRef();

	//take ownership of the clipboard

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	if( !EmptyClipboard() )
	{
		OutputString("Can't EmptyClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_EMPTY);
	}

	if( !CloseClipboard() )
	{
		OutputString("Can't CloseClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_CLOSE);
	}

	// now to flush the clipboard; we should get S_FALSE

	hresult = OleIsCurrentClipboard(pDO);

	if( hresult != ResultFromScode(S_FALSE) )
	{
		OutputString("Unexpected hresult:(%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}


	// now set the clipboard and test w/ the clipboard open
	// we should not fail in this case

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	hresult = OleIsCurrentClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// the ref count should not have gone up

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Bad ref count, was %lu, should be 3\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	// now close the clipboard

	if( !CloseClipboard() )
	{
		OutputString("CloseClipboard failed!\r\n");
		return ResultFromScode(E_FAIL);
	}

	// now test for passing NULL

	hresult = OleIsCurrentClipboard(NULL);

	if( hresult != ResultFromScode(S_FALSE) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult)? hresult : ResultFromScode(E_FAIL);
	}

	// now test for passign other pointer

         hresult = OleIsCurrentClipboard(pDO2);

	if( hresult != ResultFromScode(S_FALSE) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult)? hresult : ResultFromScode(E_FAIL);
	}

	// now clean stuff up and go home

	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard(NULL) failed!! (%lx)\r\n",
			hresult);
		return hresult;
	}

	cRefs = pDO->Release();

	// cRefs should be 0 now

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}


	pDO2->Release();

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	StressOleSetClipboard
//
//  Synopsis: 	
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//	     	
//  Returns:  	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tests the following cases:
//		1. somebody else has the clipboard open
//		2. Do OleSetClipboard with data and then
//			OleSetClipboard(NULL) to clear it out
//
//  History:    dd-mmm-yy Author    Comment
//		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT StressOleSetClipboard(void)
{
	HRESULT		hresult;
	CGenDataObject *pDO;
	ULONG		cRefs;

	OutputString("Stressing OleGetClipboard()\r\n");

	pDO = new CGenDataObject();

	assert(pDO);

	pDO->AddRef();


	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	hresult = OleSetClipboard(pDO);

	if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// the ref count should not have gone up

	cRefs = pDO->AddRef();

	if( cRefs != 2 )
	{
		OutputString("Bad ref count, was %lu, should be 2\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	if( !CloseClipboard() )
	{
		OutputString("CloseClipboard failed!\r\n");
		return ResultFromScode(E_FAIL);
	}

	// now really set the clipboard so we can try to clear it

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// this should clear the clipboard

	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// this should be the final release on the object

	cRefs = pDO->Release();

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	TestOleQueryCreateFromDataMFCHack
//
//  Synopsis: 	tests the MFC hack put into OleQueryCreateFromData
//
//  Effects:
//
//  Arguments:	void
//
//  Requires: 	
//
//  Returns:  	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	create a data object that offers private data
//		put on the clipboard and then retrieve the clipboard data
//		object.
//		Call OleQueryCreateFromData on clipboard data object--
//			QI for IPS should not be called
//		Call OleQueryCreateFromData on generic data object
//			QI for IPS should be called
//		set EmbeddedObject on the generic data object
//		Call OleQueryCreateFromData; should return S_OK
//
//  History:    dd-mmm-yy Author    Comment
//		23-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT TestOleQueryCreateFromDataMFCHack( void )
{
	CGenDataObject *	pgendata;
	IDataObject *		pdataobj;
	HRESULT			hresult;


	pgendata = new CGenDataObject();

	assert(pgendata);

	pgendata->AddRef();

	pgendata->SetDataFormats(OFFER_TESTSTORAGE);

	hresult = OleSetClipboard(pgendata);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	hresult = OleGetClipboard(&pdataobj);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	hresult = OleQueryCreateFromData(pdataobj);

	// for a clipboard data object, we should not call QueryInterface
	// for IPersistStorage.


	if( hresult != S_FALSE || pgendata->HasQIBeenCalled() == TRUE )
	{
		return ResultFromScode(E_FAIL);
	}

	// for other data objects, if there are no OLE2 formats, then
	// we should call QI for IPersistStorage

	hresult = OleQueryCreateFromData(pgendata);

	if( hresult != S_FALSE || pgendata->HasQIBeenCalled() == FALSE )
	{
		return ResultFromScode(E_FAIL);
	}

	// now clear the clipboard and continue testing
	
	pdataobj->Release();
	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	pgendata->SetDataFormats(OFFER_EMBEDDEDOBJECT);

	hresult = OleQueryCreateFromData(pgendata);

	// we just set OLE2 data on the data object.  OQCFD should return
	// S_OK

	if( hresult != NOERROR )
	{
		return ResultFromScode(E_FAIL);
	}

	if( pgendata->Release() == 0 )
	{
		return NOERROR;
	}
	else
	{
		return ResultFromScode(E_FAIL);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\dataadv.cpp ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	cliptest.cpp
//
//  Contents:   Data Advise Holder tests
//
//  Classes:    CDataAdviseTestFormatEtc
//              CTestAdviseSink
//              CTestDaHolder
//
//  Functions:  TestPrimeFirstOnlyOnceNoData
//              TestPrimeFirstOnlyOnceData
//              DoRegisterNotifyDeregister
//              TestRegisterNotifyDegister
//              TestRegisterNotifyDegisterNoData
//              TestNotifyOnStop
//              TestNotifyOnce
//              CreateMassRegistration
//              DoMassUnadvise
//              TestEnumerator
//              LEDataAdviseHolderTest
//
//  History:    dd-mmm-yy Author    Comment
//		25-May-94 ricksa    author
//
//--------------------------------------------------------------------------

#include    "oletest.h"
#include    "gendata.h"
#include    "genenum.h"



//+-------------------------------------------------------------------------
//
//  Class:      CDataAdviseTestFormatEtc
//
//  Purpose:    Hold FORMATETC used by the data advise holder unit tests
//
//  Interface:  GetFormatEtc - get a pointer to the FORMATETC
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
class CDataAdviseTestFormatEtc
{
public:
                        CDataAdviseTestFormatEtc(void);

    FORMATETC *         GetFormatEtc(void);

private:

    FORMATETC           _formatetc;
};




//+-------------------------------------------------------------------------
//
//  Member:     CDataAdviseTestFormatEtc::CDataAdviseTestFormatEtc
//
//  Synopsis:   Initialize object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CDataAdviseTestFormatEtc::CDataAdviseTestFormatEtc(void)
{
    _formatetc.cfFormat = RegisterClipboardFormat("OleTest Storage Format");
    _formatetc.ptd = NULL;
    _formatetc.dwAspect = DVASPECT_CONTENT;
    _formatetc.lindex = -1;
    _formatetc.tymed = TYMED_ISTORAGE;
}




//+-------------------------------------------------------------------------
//
//  Member:     CDataAdviseTestFormatEtc::GetFormatEtc
//
//  Synopsis:   Get pointer to standard format etc
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
FORMATETC *CDataAdviseTestFormatEtc::GetFormatEtc(void)
{
    return &_formatetc;
}




// Global Formatec for all the data advise tests
CDataAdviseTestFormatEtc g_datfeDaTest;




//+-------------------------------------------------------------------------
//
//  Class:      CTestAdviseSink
//
//  Purpose:    Advise sink used to verify data advise holder
//
//  Interface:  QueryInterface - get new interface pointer
//              AddRef - bump reference count
//              Release - decrement reference count
//              OnDataChange - data change notification
//              OnViewChange - not implemented
//              OnRename - not implemented
//              OnSave - not implemented
//              OnClose - not implemented
//              ValidOnDataChange - verify all expected data change notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We only implement interface methods required for
//              test of data advise holder.
//
//--------------------------------------------------------------------------
class CTestAdviseSink : public IAdviseSink
{
public:
                        CTestAdviseSink(CGenDataObject *pgdo);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef)(void);

    STDMETHOD_(ULONG, Release)(void);

    // IAdviseSink methods
    STDMETHOD_(void, OnDataChange)(FORMATETC *pFormatetc, STGMEDIUM *pStgmed);

    STDMETHOD_(void, OnViewChange)(
                            DWORD dwAspect,
                            LONG lindex);

    STDMETHOD_(void, OnRename)(IMoniker *pmk);

    STDMETHOD_(void, OnSave)(void);

    STDMETHOD_(void, OnClose)(void);

    // Test methods used for verification
    BOOL                ValidOnDataChange(void);

private:

    LONG                _lRefs;

    CGenDataObject *    _pgdo;

    BOOL                _fValidOnDataChange;

};



//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::CTestAdviseSink
//
//  Synopsis:   Initialize object
//
//  Arguments:  [pgdo] - generic data object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      pgdo being NULL means we don't expect a STGMEDIUM when
//              the OnDataChange notification occurs.
//
//--------------------------------------------------------------------------
CTestAdviseSink::CTestAdviseSink(CGenDataObject *pgdo)
    : _lRefs(1), _fValidOnDataChange(FALSE)
{
    _pgdo = pgdo;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::QueryInterface
//
//  Synopsis:   Return a new interface
//
//  Arguments:  [riid] - interface id requested
//              [ppvObj] - where to put the interface
//
//  Returns:    S_OK - we are returning an interface
//              E_NOINTERFACE - we do not support the requested interface
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CTestAdviseSink::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IAdviseSink, riid))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    *ppvObj = NULL;

    return E_NOINTERFACE;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::AddRef
//
//  Synopsis:   Bump reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTestAdviseSink::AddRef(void)
{
    return _lRefs++;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::Release
//
//  Synopsis:   Decrement reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTestAdviseSink::Release(void)
{
    assert(_lRefs >= 1);

    return --_lRefs;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnDataChange
//
//  Synopsis:   Notify of change in data
//
//  Arguments:  [pFormatetc] - FORMATETC of data
//              [pStgmed] - storage medium for data
//
//  Algorithm:  Verify that the we recieved the expected FORMATEC. Then
//              verify that we recieved the expected STGMEDIUM.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnDataChange(
    FORMATETC *pFormatetc,
    STGMEDIUM *pStgmed)
{
    // Verify the format
    if (memcmp(g_datfeDaTest.GetFormatEtc(), pFormatetc, sizeof(FORMATETC))
        == 0)
    {
        if (_pgdo != NULL)
        {
            // We have a data object that we can use to verify the format
            // so we do.
            _fValidOnDataChange =
                _pgdo->VerifyFormatAndMedium(pFormatetc, pStgmed);
        }
        // We are expecting an empty STGMEDIUM so verify that it is
        else if ((pStgmed->tymed == TYMED_NULL)
            && (pStgmed->pUnkForRelease == NULL))
        {
            _fValidOnDataChange = TRUE;
        }
    }
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnViewChange
//
//  Synopsis:   Notify that view should change
//
//  Arguments:  [dwAspect] - specifies view of the object
//              [lindex] -  which piece of view changed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnViewChange(
    DWORD dwAspect,
    LONG lindex)
{
    OutputString("CTestAdviseSink::OnViewChange Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnRename
//
//  Synopsis:   Notifies of rename operation
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnRename(IMoniker *pmk)
{
    OutputString("CTestAdviseSink::OnRename Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnSave
//
//  Synopsis:   Notify that object was saved
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnSave(void)
{
    OutputString("CTestAdviseSink::OnSave Unexpectedly Called!\r\n");
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnClose
//
//  Synopsis:   Notify object closed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnClose(void)
{
    OutputString("CTestAdviseSink::OnClose Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::ValidOnDataChange
//
//  Synopsis:   Verify that we recieved the expected OnDataChange notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestAdviseSink::ValidOnDataChange(void)
{
    BOOL fResult = _fValidOnDataChange;
    _fValidOnDataChange = FALSE;
    return fResult;
}


// Preallocated structure used to mass advise registration testing
#define MAX_REGISTER 100
struct
{
    CTestAdviseSink *   ptas;
    DWORD               dwConnection;
} aMassAdvise[MAX_REGISTER];




//+-------------------------------------------------------------------------
//
//  Class:      CTestDaHolder
//
//  Purpose:    Test enumerator for data advise holder
//
//  Interface:  Verify - verify particular entry being enumerated
//              VerifyAllEnmerated - verify all entries were enumerated once
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
class CTestDaHolder : public CEnumeratorTest
{
public:

                        CTestDaHolder(IEnumSTATDATA *penumAdvise, HRESULT& rhr);

    BOOL                Verify(void *);

    BOOL                VerifyAllEnmerated(void);

    BOOL                VerifyAll(void *, LONG);

private:

    DWORD               _cdwFound[MAX_REGISTER];
};




//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::CTestDaHolder
//
//  Synopsis:   Initialize object
//
//  Arguments:  [penumAdvise] - data advise holder enumerator
//              [rhr] - HRESULT reference thorugh which to return an error
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CTestDaHolder::CTestDaHolder(IEnumSTATDATA *penumAdvise, HRESULT& rhr)
    : CEnumeratorTest(penumAdvise, sizeof(STATDATA), MAX_REGISTER, rhr)
{
    // Zero out our table of counts
    memset(&_cdwFound[0], 0, sizeof(_cdwFound));
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::VerifyAllEnmerated
//
//  Synopsis:   Verify all objects got enumerated
//
//  Returns:    TRUE - all objects enumerated
//              FALSE - error in enumeration
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestDaHolder::VerifyAllEnmerated(void)
{
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        if (_cdwFound[i] != 1)
        {
            OutputString("Entry %d enumerated %d times\r\n", i, _cdwFound[i]);
            return FALSE;
        }

        // Reset for another test
        _cdwFound[i] = 0;
    }

    return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::Verify
//
//  Synopsis:   Verify an enumeration entry
//
//  Arguments:  [pvEntry] - entry enumerated
//
//  Returns:    TRUE - enumerated entry is valid
//              FALSE - obvious error in enumeration
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestDaHolder::Verify(void *pvEntry)
{
    STATDATA *pstatdata = (STATDATA *) pvEntry;

    // Verify the advf field
    if ((pstatdata->advf == 0)
        && (memcmp(g_datfeDaTest.GetFormatEtc(), &pstatdata->formatetc,
            sizeof(FORMATETC)) == 0))
    {
        // Can we find the connection?
        for (int i = 0; i < MAX_REGISTER; i++)
        {
            if (pstatdata->dwConnection == aMassAdvise[i].dwConnection)
            {
                // Bump found count
                _cdwFound[i]++;

                // Everything is OK so tell the caller
                return TRUE;
            }
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::VerifyAll
//
//  Synopsis:   Verify that an array of all entries is valid
//
//  Arguments:  [pvEntries] - array of enumerated data
//              [clEntries] - number of enumerated entries
//
//  Returns:    TRUE - enumerated entry is valid
//              FALSE - obvious error in enumeration
//
//  History:    dd-mmm-yy Author    Comment
//              02-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestDaHolder::VerifyAll(void *pvEntries, LONG clEntries)
{
    // Verify that the count is as expected.
    if (clEntries != MAX_REGISTER)
    {
        return FALSE;
    }

    // Verify each entry in the array is reasonable
    STATDATA *pstatdata = (STATDATA *) pvEntries;

    for (int i = 0; i < MAX_REGISTER; i++, pstatdata++)
    {
        if (!Verify(pstatdata))
        {
            return FALSE;
        }
    }

    // Verify that each entry was only referred to once
    return VerifyAllEnmerated();
}





//+-------------------------------------------------------------------------
//
//  Function:   TestPrimeFirstOnlyOnceNoData
//
//  Synopsis:   Test one notification of
//              ADVF_NODATA | ADVF_PRIMEFIRST | ADVF_ONLYONCE
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create an test advise sink object. Register it with the
//              advise holder which should cause the notification. Verify
//              that the advise was notified and that no connection was
//              returned.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestPrimeFirstOnlyOnceNoData(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Create an advise sink - the NULL means we don't want to validate
    // the STGMEDIUM.
    CTestAdviseSink tas(NULL);

    DWORD dwConnection = 0;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_NODATA | ADVF_PRIMEFIRST | ADVF_ONLYONCE, &tas, &dwConnection);

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("TestPrimeFirstOnlyOnceNoData OnDataChange invalid!\r\n");
        return E_FAIL;
    }

    // Make sure the advise was not registered
    if (dwConnection != 0)
    {
        OutputString("TestPrimeFirstOnlyOnceNoData got Connection!\r\n");
        return E_FAIL;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   TestPrimeFirstOnlyOnceData
//
//  Synopsis:   Test one notification of
//              ADVF_PRIMEFIRST | ADVF_ONLYONCE
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create an test advise sink object. Register it with the
//              advise holder which should cause the notification. Verify
//              that the advise was notified and that no connection was
//              returned.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestPrimeFirstOnlyOnceData(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection = 0;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_PRIMEFIRST | ADVF_ONLYONCE, &tas, &dwConnection);

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("TestPrimeFirstOnlyOnceData OnDataChange invalid!\r\n");
        return E_FAIL;
    }

    // Make sure the advise was not registered
    if (dwConnection != 0)
    {
        OutputString("TestPrimeFirstOnlyOnceData got Connection!\r\n");
        return E_FAIL;
    }

    return NOERROR;
}



//+-------------------------------------------------------------------------
//
//  Function:   DoRegisterNotifyDeregister
//
//  Synopsis:
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pdo] - IDataObject interface
//              [pgdo] - generic data object
//              [advf] - advise flags to use
//              [pszCaller] - name of test
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a test advise sink object. Register for an notification
//              with the data advise holder. Confirm that the prime first
//              notification worked. Confirm that the object did get
//              registered. Tell the advise holder to notify all registered
//              advises that the data changed. Confirm that the appropriate
//              notification was sent. Then deregister the advise. Do it
//              again to make sure the connection is no longer valid.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT DoRegisterNotifyDeregister(
    IDataAdviseHolder *pdahTest,
    IDataObject *pdo,
    CGenDataObject *pgdo,
    DWORD advf,
    char *pszCaller)
{
    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_PRIMEFIRST | advf, &tas, &dwConnection);

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s First OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Make sure the advise is registered
    if (dwConnection == 0)
    {
        OutputString("%s did not get Connection!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test regular data change
    hr = pdahTest->SendOnDataChange(pdo, 0, 0);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnDataChange unexpected HRESULT = %lx!\r\n",
            pszCaller, hr);
        return E_FAIL;
    }

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s Second OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test unadvise
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != NOERROR)
    {
        OutputString("%s Unadvise unexpected HRESULT = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Test second unadvise on the same connection
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second Unadvise Bad Hresult = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   TestRegisterNotifyDegister
//
//  Synopsis:   Test a simple register/notify/deregister sequence
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestRegisterNotifyDegister(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    return DoRegisterNotifyDeregister(pdahTest, pgdo, pgdo, 0,
        "TestRegisterNotifyDegister");
}



//+-------------------------------------------------------------------------
//
//  Function:   TestRegisterNotifyDegisterNoData
//
//  Synopsis:   Test a simple register/notify/deregister sequence with
//              no data being returned.
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestRegisterNotifyDegisterNoData(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    return DoRegisterNotifyDeregister(pdahTest, pgdo, NULL, ADVF_NODATA,
        "TestRegisterNotifyDegisterNoData");
}




//+-------------------------------------------------------------------------
//
//  Function:   TestNotifyOnStop
//
//  Synopsis:   Test a registration with a call of notify on stop
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a test object. Register it with the advise holder.
//              Confirm that the connection was returned and that no
//              notification occurred. Then tell the data advise holder
//              to notify its registrations of a data change. Make sure
//              that the advise was correctly notified. Finally, verify
//              that we can deregister the advise and that its connection
//              becomes invalid.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT  TestNotifyOnStop(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Routine name for messages
    char *pszCaller = "TestNotifyOnStop";

    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_DATAONSTOP, &tas, &dwConnection);

    // Make sure the advise is registered
    if (dwConnection == 0)
    {
        OutputString("%s did not get Connection!\r\n", pszCaller);
        return E_FAIL;
    }

    // Confirm that the data object was not notified
    if (tas.ValidOnDataChange())
    {
        OutputString("%s Registration caused notification!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test regular data change
    hr = pdahTest->SendOnDataChange(pgdo, 0, ADVF_DATAONSTOP);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnDataChange unexpected HRESULT = %lx!\r\n",
            pszCaller, hr);
        return E_FAIL;
    }

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s Second OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test unadvise
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != NOERROR)
    {
        OutputString("%s Unadvise unexpected HRESULT = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Test second unadvise on the same connection
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second Unadvise Bad Hresult = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestNotifyOnce
//
//  Synopsis:   Test a notify once advise
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a test advise object. Register it to be advised only
//              once of a change. Confirm that we got a registration. Then
//              tell the advise holder to notify its advises of a data
//              change. Confirm that the correct notification occurred. Finally,
//              confirm that we are no longer registered with the advise
//              holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT  TestNotifyOnce(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Routine name for messages
    char *pszCaller = "TestNotifyOnce";

    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_ONLYONCE, &tas, &dwConnection);

    // Make sure the advise is registered
    if (dwConnection == 0)
    {
        OutputString("%s did not get Connection!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test regular data change
    hr = pdahTest->SendOnDataChange(pgdo, 0, 0);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnDataChange unexpected HRESULT = %lx!\r\n",
            pszCaller, hr);
        return E_FAIL;
    }

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s Send OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Try a second notify
    hr = pdahTest->SendOnDataChange(pgdo, 0, 0);


    // Confirm that the advise is *not* notified
    if (tas.ValidOnDataChange())
    {
        OutputString("%s Second OnDataChange unexpectedly succeeded!\r\n",
            pszCaller);
        return E_FAIL;
    }

    // Test unadvise - should fail since we requested to be notified
    // only once.
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second Unadvise Bad Hresult = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   CreateMassRegistration
//
//  Synopsis:   Register a large number of advise objects with a holder
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//              [pszCaller] - name of test
//
//  Returns:    NOERROR - all advises were registered
//              E_FAIL - error in registration
//
//  Algorithm:  Create a MAX_REGISTER number of test advise objects and
//              store them in the aMassAdvise array. Then register them
//              all with the input advise holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CreateMassRegistration(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo,
    char *pszCaller)
{
    // Create the advise sinks for the test for the test
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        aMassAdvise[i].ptas = new CTestAdviseSink(pgdo);

        if (aMassAdvise[i].ptas == NULL)
        {
            OutputString(
                "%s Advise create of test advise failed on %d!\r\n", pszCaller,
                    i);
            return E_FAIL;
        }

        aMassAdvise[i].dwConnection = 0;
    }

    HRESULT hr;

    // Register the advise sinks
    for (i = 0; i < MAX_REGISTER; i++)
    {
        // Register the advise
        hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
            0, aMassAdvise[i].ptas, &aMassAdvise[i].dwConnection);

        if (hr != NOERROR)
        {
            OutputString(
                "%s Advise unexpected HRESULT = %lx on %d!\r\n", pszCaller,
                    hr, i);
            return E_FAIL;
        }
    }

    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   DoMassUnadvise
//
//  Synopsis:   Deregister all entries in the aMassAdvise array
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pszCaller] - name of test
//
//  Returns:    NOERROR - deregistration worked
//              E_FAIL - error in deregistration
//
//  Algorithm:  For each entry in the aMassAdvise array, deregister it
//              from the holder. Then confirm that its connection is
//              no longer valid.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT DoMassUnadvise(
    IDataAdviseHolder *pdahTest,
    char *pszCaller)
{
    HRESULT hr;

    // Unadvise them
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        // Test unadvise
        hr = pdahTest->Unadvise(aMassAdvise[i].dwConnection);

        if (hr != NOERROR)
        {
            OutputString(
                "%s Unadvise unexpected HRESULT = %lx on %d!\r\n", pszCaller,
                    hr, i);
            return E_FAIL;
        }

        // Test second unadvise on the same connection
        hr = pdahTest->Unadvise(aMassAdvise[i].dwConnection);

        if (hr != OLE_E_NOCONNECTION)
        {
            OutputString(
                "%s Second Unadvise Bad Hresult = %lx on %d!\r\n", pszCaller,
                    hr, i);
            return E_FAIL;
        }
    }

    // Delete the advise sinks for the test
    for (i = 0; i < MAX_REGISTER; i++)
    {
        delete aMassAdvise[i].ptas ;
    }

    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestMassRegister
//
//  Synopsis:   Test registering a large number of advises with a holder
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Register a large number of test advises with the data advise
//              holder. Then tell the advise holder to notify them of
//              a change. Confirm that all registered entries were notified.
//              Finally, deregister all the test advises.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestMassRegister(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    char *pszCaller = "TestMassRegister";

    HRESULT hr = CreateMassRegistration(pdahTest, pgdo, "TestMassRegister");

    if (hr != NOERROR)
    {
        return hr;
    }

    // Notify them of a change
    hr = pdahTest->SendOnDataChange(pgdo, 0, 0);

    // Verify that each was notified
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        if (!aMassAdvise[i].ptas->ValidOnDataChange())
        {
            OutputString(
                "%s OnDataChange invalid for entry %d!\r\n", pszCaller, i);
            return E_FAIL;
        }
    }

    // Unadvise them and free the memory
    return DoMassUnadvise(pdahTest, "TestMassRegister");
}




//+-------------------------------------------------------------------------
//
//  Function:   TestEnumerator
//
//  Synopsis:   Test the data advise holder enumerator
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a large number of test advises and register them
//              with the advise holder. Get an advise enumerator. Create
//              a test enumerator object. Tell the test enumerator object
//              to enumerate all the object in the holder. Verify that
//              all objects were correctly enumerated. Then release the
//              advise holder enumerator. Finally, deregister all the
//              test advises from the advise holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT  TestEnumerator(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    char *pszCaller = "TestEnumerator";

    // Do a mass register
    HRESULT hr = CreateMassRegistration(pdahTest, pgdo, pszCaller);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Get an enumerator for this registration
    IEnumSTATDATA *penumAdvise;

    hr = pdahTest->EnumAdvise(&penumAdvise);

    if (hr != NOERROR)
    {
        OutputString("%s EnumAdvise failed %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Create a test enumerator object
    CTestDaHolder tdh(penumAdvise, hr);

    if (hr != NOERROR)
    {
        OutputString(
            "%s Failed creating  CTestDaHolder %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Enmerate all 1 by 1
    if (tdh.TestNext() != NOERROR)
    {
        OutputString(
            "%s tdh.TestNext failed during enumeration\r\n", pszCaller);
        return E_FAIL;
    }

    // Verify that all entries were enumerated
    if (!tdh.VerifyAllEnmerated())
    {
        OutputString(
            "%s tdh.VerifyAllEnmerated failed verification pass\r\n", pszCaller);
        return E_FAIL;
    }

    // Do a test all
    if (tdh.TestAll() != NOERROR)
    {
        OutputString(
            "%s tdh.TestAll failed during enumeration\r\n", pszCaller);
        return E_FAIL;
    }

    // Release the advise enumerator
    if (penumAdvise->Release() != 0)
    {
        OutputString(
            "%s Failed freeing advise enumerator %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Release the registrations
    return DoMassUnadvise(pdahTest, pszCaller);
}




//+-------------------------------------------------------------------------
//
//  Function:   LEDataAdviseHolderTest
//
//  Synopsis:   Unit test for the data advise holder.
//
//  Returns:    NOERROR - test passed
//              E_FAIL - test failed.
//
//  Algorithm:  Create an advise holder object. Run through all the test
//              cases. Return NOERROR if they succeed or stop with the first
//              that fails.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT LEDataAdviseHolderTest(void)
{
    // Create a data object for use in the test
    CGenDataObject *pgdo = new CGenDataObject;

    assert(pgdo);

    // Create a data advise holder
    IDataAdviseHolder *pdahTest;

    HRESULT hr = CreateDataAdviseHolder(&pdahTest);

    if (hr != NOERROR)
    {
        OutputString(
            "LEDataAdviseHolderTest CreateDataAdviseHolder Faild hr = %lx", hr);
        return hr;
    }

    // Case 1: ADVF_PRIMEFIRST & ADVF_ONLYONCE & ADVF_NODATA
    if ((hr = TestPrimeFirstOnlyOnceNoData(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 2: ADVF_PRIMEFIRST
    if ((hr = TestPrimeFirstOnlyOnceNoData(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 3: Register/Notify/Deregister
    if ((hr = TestRegisterNotifyDegister(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 4: Register/Notify/Deregister with no data returned
    if ((hr = TestRegisterNotifyDegisterNoData(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 5: Test notify on stop
    if ((hr = TestNotifyOnStop(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 6: Test notify only once
    if ((hr = TestNotifyOnce(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 7: Test mass Register/Notify/Deregister
    if ((hr = TestMassRegister(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 8: Test Enumerator
    if ((hr = TestEnumerator(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // We are done
    DWORD dwFinalRefs = pdahTest->Release();

    if (dwFinalRefs != 0)
    {
        OutputString(
            "LEDataAdviseHolderTest Final Release is = %d", dwFinalRefs);
        return E_FAIL;
    }

    pgdo->Release();

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\gendata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	gendata.cpp
//
//  Contents: 	implementation of CGenDataObject
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added support for OLE1 tests
//    		24-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "gendata.h"

static const CLSID CLSID_TestCLSID = {0xaabbccee, 0x1122, 0x3344, { 0x55, 0x66,
    0x77, 0x88, 0x99, 0x00, 0xaa, 0xbb }};

static const char szTestString[] = "A carefully chosen test string";
static const OLECHAR wszTestStream[] = OLESTR("TestStream");
static const char szNativeData[] = "Ole1Test NATIVE data";
static const char szOwnerLinkData[] = "PBrush\0foo.bmp\00 0 200 160\0\0";


//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::CGenDataObject
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added OLE1 support
//		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CGenDataObject::CGenDataObject( )
{
	m_refs = 0;
	m_fQICalled = FALSE;

	// now set up the formats that we support

	m_cfTestStorage = RegisterClipboardFormat("OleTest Storage Format");
        m_cfEmbeddedObject = RegisterClipboardFormat("Embedded Object");
	m_cfEmbedSource = RegisterClipboardFormat("Embed Source");
	m_cfLinkSource = RegisterClipboardFormat("Link Source");
	m_cfObjectDescriptor = RegisterClipboardFormat("Object Descriptor");
	m_cfLinkSrcDescriptor = RegisterClipboardFormat("Link Source "
					"Descriptor");
	m_cfOwnerLink = RegisterClipboardFormat("OwnerLink");
	m_cfNative = RegisterClipboardFormat("Native");
	m_cfObjectLink = RegisterClipboardFormat("ObjectLink");

	// now set up the array of formatetc's.  SetupOle1Mode must be
	// called if you want OLE1 formats

	m_rgFormats = new FORMATETC[2];

	assert(m_rgFormats);

	m_rgFormats[0].cfFormat = m_cfTestStorage;
	m_rgFormats[0].ptd = NULL;
	m_rgFormats[0].dwAspect = DVASPECT_CONTENT;
	m_rgFormats[0].lindex = -1;
	m_rgFormats[0].tymed = TYMED_ISTORAGE;

	m_rgFormats[1].cfFormat = m_cfEmbeddedObject;
	m_rgFormats[1].ptd = NULL;
	m_rgFormats[1].dwAspect = DVASPECT_CONTENT;
	m_rgFormats[1].lindex = -1;
	m_rgFormats[1].tymed = TYMED_ISTORAGE;

	m_cFormats = 2;

}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::QueryInterface
//
//  Synopsis: 	returns requested interfaces
//
//  Effects:
//
//  Arguments: 	[riid]		-- the requested interface
//		[ppvObj]	-- where to put the interface pointer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	HRESULT		hresult = NOERROR;

	m_fQICalled = TRUE;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IDataObject) )
	{
		*ppvObj = this;
		AddRef();
	}
	else
	{
		*ppvObj = NULL;
		hresult = ResultFromScode(E_NOINTERFACE);
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::AddRef
//
//  Synopsis:	increments the reference count
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	ULONG-- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenDataObject::AddRef( )
{
	return ++m_refs;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CGenDataObject::Release
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenDataObject::Release( )
{
	ULONG cRefs;

	if( (cRefs = --m_refs ) == 0 )
	{
		delete this;
	}
	return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetData
//
//  Synopsis:	retrieves data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pmedium]	-- where to put the data
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added OLE1 support
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::GetData( LPFORMATETC pformatetc, LPSTGMEDIUM
		pmedium)
{
	HRESULT		hresult = NOERROR;

	if( (pformatetc->cfFormat == m_cfTestStorage ||
                pformatetc->cfFormat == m_cfEmbeddedObject ) &&
		(pformatetc->tymed & TYMED_ISTORAGE) )
	{
		pmedium->tymed = TYMED_ISTORAGE;
		pmedium->pstg = GetTestStorage();
		assert(pmedium->pstg);
	}

	// test for OLE1 formats

	else if( pformatetc->cfFormat == m_cfOwnerLink &&
		(m_fOle1 & OLE1_OFFER_OWNERLINK ) &&
		(pformatetc->tymed & TYMED_HGLOBAL) )
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GetOwnerOrObjectLink();
		assert(pmedium->hGlobal);
	}
	else if( pformatetc->cfFormat == m_cfObjectLink &&
		(m_fOle1 & OLE1_OFFER_OBJECTLINK ) &&
		(pformatetc->tymed & TYMED_HGLOBAL) )
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GetOwnerOrObjectLink();
		assert(pmedium->hGlobal);
	}
	else if( pformatetc->cfFormat == m_cfNative &&
		(m_fOle1 & OLE1_OFFER_NATIVE ) &&
		(pformatetc->tymed &TYMED_HGLOBAL ) )
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GetNativeData();
	}
	else
	{
		hresult = ResultFromScode(E_FAIL);
	}
		
	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetDataHere
//
//  Synopsis:	retrieves data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pmedium]	-- where to put the data
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::GetDataHere( LPFORMATETC pformatetc, LPSTGMEDIUM
		pmedium)
{
	(void)pformatetc;
	(void)pmedium;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::QueryGetData
//
//  Synopsis:	queries whether a GetData call would succeed
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::QueryGetData( LPFORMATETC pformatetc )
{			
	(void)pformatetc;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetCanonicalFormatEtc
//
//  Synopsis:	retrieve the canonical format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pformatetcOut]	-- the canonical format
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::GetCanonicalFormatEtc( LPFORMATETC pformatetc,
	LPFORMATETC pformatetcOut)
{
	(void)pformatetc;
	(void)pformatetcOut;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::SetData
//
//  Synopsis:	sets data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the format of the data
//		[pmedium]	-- the data
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::SetData( LPFORMATETC pformatetc, LPSTGMEDIUM
		pmedium, BOOL fRelease)
{
	(void)pformatetc;
	(void)pmedium;
	(void)fRelease;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::EnumFormatEtc
//
//  Synopsis:	return an enumerator for the available data formats
//
//  Effects:
//
//  Arguments:	[dwDirection]	-- the direction (GET or SET)
//		[ppenum]	-- where to put the enumerator
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::EnumFormatEtc( DWORD dwDirection,
	LPENUMFORMATETC * ppenum )
{
	HRESULT		hresult;

	if( dwDirection == DATADIR_GET )
	{
		hresult = CGenEnumFormatEtc::Create( ppenum, m_rgFormats,
				m_cFormats);
		assert(hresult == NOERROR);

		return hresult;
	}
	else
	{
		return ResultFromScode(E_NOTIMPL);
	}
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::DAdvise
//
//  Synopsis:	register a data advise
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[dwAdvf]	-- advise flags
//		[pAdvSink]	-- the advise sink
//		[pdwConnection]	-- where to put the connection ID
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::DAdvise( LPFORMATETC pformatetc, DWORD dwAdvf,
	IAdviseSink * pAdvSink, DWORD *pdwConnection )
{
	(void)pformatetc;
	(void)dwAdvf;
	(void)pAdvSink;
	(void)pdwConnection;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::DUnadvise
//
//  Synopsis:	unadvises an advise connection
//
//  Effects:
//
//  Arguments:	[dwConnection]	-- the connection to remove
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::DUnadvise(DWORD dwConnection)
{
	(void)dwConnection;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::EnumDAdvise
//
//  Synopsis:  	enumerates data advises
//
//  Effects:
//
//  Arguments:	[ppenum]	-- where to put the enumerator
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::EnumDAdvise( LPENUMSTATDATA *ppenum)
{
	(void)ppenum;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyMedium
//
//  Synopsis:	verifies the contents of the given medium
//
//  Effects:
//
//  Arguments: 	[pmedium]	-- the medium to verify
//
//  Requires:
//
//  Returns:  	BOOL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	For OLE1 formats, the following must be true:
//		cfEmbeddedObject:
//			must have OWNERLINK and !NATIVE
//			or OWNERLINK precedes NATIVE
//		cfEmbedSource:
//			must have NATIVE && OWNERLINK and
//			OWNERLINK must not precede NATIVE
//		cfObjectDescriptor:
//			same as EmbedSource
//		cfLinkSource:
//			must have either OBJECTLINK or
//			OWNERLINK must precede NATIVE
//		cfLinkSrcDescriptor:
//			same as LinkSource
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added OLE1 support
//	 	15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyFormatAndMedium( FORMATETC *pformatetc,
			STGMEDIUM *pmedium )
{
	// if any of these flags are set, then we were offering OLE1
	// data.  Do relevant tests.

	if( (m_fOle1 & (OLE1_OFFER_OWNERLINK | OLE1_OFFER_OBJECTLINK |
		OLE1_OFFER_NATIVE) ) )
	{
		// now do individual tests for formats
		if( pformatetc->cfFormat == m_cfEmbedSource ||
			pformatetc->cfFormat == m_cfObjectDescriptor)
		{
			if( (m_fOle1 & OLE1_OFFER_NATIVE) &&
				(m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				!(m_fOle1 & OLE1_OWNERLINK_PRECEDES_NATIVE) )
			{
				return TRUE;
			}
		}
		else if( pformatetc->cfFormat == m_cfLinkSource ||
			pformatetc->cfFormat == m_cfLinkSrcDescriptor)
		{
			if( (m_fOle1 & OLE1_OFFER_OBJECTLINK) ||
				((m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				(m_fOle1 & OLE1_OFFER_NATIVE) &&
				(m_fOle1 & OLE1_OWNERLINK_PRECEDES_NATIVE)))
			{
				return TRUE;
			}
		}

		// no 'else' so we check for cfObjectDescriptor again
		if( pformatetc->cfFormat == m_cfEmbeddedObject ||
			pformatetc->cfFormat == m_cfObjectDescriptor )
		{
			if( ((m_fOle1 & OLE1_OFFER_NATIVE) &&
				(m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				(m_fOle1 & OLE1_OWNERLINK_PRECEDES_NATIVE)) ||
				((m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				!(m_fOle1 & OLE1_OFFER_NATIVE)) )
			{
				return TRUE;
			}

		}

		// fall through and do rest of testing, in case we didn't
		// hit one of the synthesized formats.
	}

	if( pformatetc->cfFormat == m_cfTestStorage ||
               pformatetc->cfFormat == m_cfEmbeddedObject )
	{
		return VerifyTestStorage( pformatetc, pmedium );
	}
	else if( pformatetc->cfFormat == m_cfOwnerLink ||
		pformatetc->cfFormat == m_cfObjectLink )
	{
		return VerifyOwnerOrObjectLink(pformatetc, pmedium);
	}
	else if( pformatetc->cfFormat == m_cfNative )
	{
		return VerifyNativeData(pformatetc, pmedium);
	}

	return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyTestStorage
//
//  Synopsis: 	verifies the test storage format
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//	     	
//  Returns: 	BOOL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		15-Apr-94 alexgo    author; tax day :-(
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyTestStorage( FORMATETC *pformatetc,
		STGMEDIUM *pmedium)
{
	IStream *	pstm;
	STATSTG		statstg;
	char 		szBuf[sizeof(szTestString)];
	HRESULT		hresult;

	if( pmedium->tymed != TYMED_ISTORAGE )
	{
		//REVIEW: we may want to convert and test different
		//mediums at a later date

		return FALSE;
	}

	
	// check the class ID

	pmedium->pstg->Stat(&statstg, STATFLAG_NONAME);

	if( !IsEqualCLSID(statstg.clsid, CLSID_TestCLSID) )
	{
		OutputString("Failed CLSID check on storage in "
			"VerifyTestStorage!!\r\n");
		return FALSE;
	}

	// now open the test stream

	hresult = pmedium->pstg->OpenStream(wszTestStream, NULL, (STGM_READ |
		STGM_SHARE_EXCLUSIVE), 0, &pstm);

	if( hresult != NOERROR )
	{
		OutputString("OpenStream in VerifyTestStorage failed! (%lx)"
			"\r\n", hresult);
		return FALSE;
	}

	hresult = pstm->Read((void *)szBuf, sizeof(szTestString), NULL);

	if( hresult != NOERROR )
	{
		OutputString("Stream->Read failed in VerifyTestStorage (%lx)"
			"\r\n", hresult);
		pstm->Release();
		return FALSE;
	}

	if( strcmp(szBuf, szTestString) != 0 )
	{
		OutputString("'%s' != '%s'\r\n", szBuf, szTestString);
		return FALSE;
	}

	pstm->Release();

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenDataObject::GetTestStorage (private)
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: 	a new storage
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

IStorage * CGenDataObject::GetTestStorage( void )
{
	IStorage *	pstg;
	IStream *	pstm;
	HRESULT		hresult;


	// create the docfile

	hresult = StgCreateDocfile(NULL, (STGM_READWRITE | STGM_DIRECT |
                        STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE), NULL,
                        &pstg);

	if( hresult != NOERROR )
	{
		OutputString("GetTestStorage: CreateDocfile failed!! (%lx)"
			"\r\n", hresult);
		return NULL;
	}

        // set the class ID

        hresult = pstg->SetClass(CLSID_TestCLSID);

	// now create the stream

	hresult = pstg->CreateStream(wszTestStream, (STGM_READWRITE |
			STGM_SHARE_EXCLUSIVE ), 0, 0, &pstm);

	if( hresult != NOERROR )
	{
		OutputString("GetTestStorage: CreateStream failed! (%lx)\r\n",
			hresult);
		pstg->Release();
		return NULL;
	}

	hresult = pstm->Write((void *)szTestString, sizeof(szTestString),
			NULL);

	if( hresult != NOERROR )
	{
		OutputString("GetTestStorage: Stream->Write failed! (%lx)\r\n",
			hresult);
		pstm->Release();
		pstg->Release();
		return NULL;
	}

	pstm->Release();

	return pstg;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenDataObject::GetOwnerOrObjectLink (private)
//
//  Synopsis:  	Creates either cfOwnerLink or cfObjectLink for a dummy
//		Paintbrush (ole1) object
//
//  Effects: 	allocates an HGLOBAL
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HGLOBAL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGenDataObject::GetOwnerOrObjectLink( void )
{
	HGLOBAL hglobal;
	char *pdata;

	hglobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(szOwnerLinkData));

	assert(hglobal);

	pdata = (char *)GlobalLock(hglobal);

	assert(pdata);

	memcpy(pdata, szOwnerLinkData, sizeof(szOwnerLinkData));

	GlobalUnlock(hglobal);

	return hglobal;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetNativeData (private)
//
//  Synopsis: 	Creates OLE1 Native data
//
//  Effects:  	allocates an hglobal
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HGLOBAL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGenDataObject::GetNativeData( void )
{
	HGLOBAL	hglobal;
	char *pdata;

	hglobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(szNativeData) + 1);

	assert(hglobal);

	pdata = (char *)GlobalLock(hglobal);

	assert(pdata);

	memcpy(pdata, szNativeData, sizeof(szNativeData)+1);

	GlobalUnlock(hglobal);

	return hglobal;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyOwnerOrObjectLink
//
//  Synopsis: 	verifies that the owner or object link data is correct
//
//  Effects:
//
//  Arguments: 	[pformatetc]	-- the formatetc describing the data
//		[pmedium]	-- the data
//
//  Requires:	pformatetc must be for OwnerLink or ObjectLink
//
//  Returns:	BOOL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//		NB!!: must be expanded to cover container-side cases
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyOwnerOrObjectLink( FORMATETC *pformatetc,
	STGMEDIUM *pmedium )
{
	char *	pdata;
	BOOL	fRet = FALSE;
	

	assert(pformatetc->cfFormat == m_cfOwnerLink ||
		pformatetc->cfFormat == m_cfObjectLink );

	// check standard stuff
	if( !(pformatetc->tymed & TYMED_HGLOBAL ) ||
		pformatetc->dwAspect != DVASPECT_CONTENT ||
		pformatetc->ptd != NULL ||
		pformatetc->lindex != -1 ||
		pmedium->tymed != TYMED_HGLOBAL )
	{
		return FALSE;
	}

	// if we offered the data natively from OLE1, then
	// check the contents.

	// this conditional tests to see if the format in question
	// was originally offered by us

	if( ((m_fOle1 & OLE1_OFFER_OWNERLINK) &&
		pformatetc->cfFormat == m_cfOwnerLink) ||
		((m_fOle1 & OLE1_OFFER_OBJECTLINK) &&
		pformatetc->cfFormat == m_cfObjectLink) )
	{
			
		pdata = (char *)GlobalLock(pmedium->hGlobal);
	
		if( memcmp(pdata, szOwnerLinkData,
			sizeof(szOwnerLinkData)) == 0 )
		{
			fRet = TRUE;
		}

		GlobalUnlock(pmedium->hGlobal);
	}
	// else CHECK SYNTHESIZED OLE1 FORMATS WHEN IMPLEMENTED


	return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyNativeData (private)
//
//  Synopsis:	verifies OLE1 Native data
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- formatetc for the data
//		[pmedium]	-- location of the native data
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-95 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyNativeData( FORMATETC *pformatetc,
		STGMEDIUM *pmedium )
{
	char *	pdata;
	BOOL	fRet = FALSE;
	

	assert(pformatetc->cfFormat == m_cfNative );

	// check standard stuff
	if( !(pformatetc->tymed & TYMED_HGLOBAL) ||
		pformatetc->dwAspect != DVASPECT_CONTENT ||
		pformatetc->ptd != NULL ||
		pformatetc->lindex != -1 ||
		pmedium->tymed != TYMED_HGLOBAL )
	{
		return FALSE;
	}

	// if we offered the data natively from OLE1, then
	// check the contents.

	// this conditional tests to see if the format in question
	// was originally offered by us

	if( (m_fOle1 & OLE1_OFFER_NATIVE) )
	{
			
		pdata = (char *)GlobalLock(pmedium->hGlobal);
	
		if( memcmp(pdata, szNativeData,
			sizeof(szNativeData)) == 0 )
		{
			fRet = TRUE;
		}

		GlobalUnlock(pmedium->hGlobal);
	}
	// else CHECK SYNTHESIZED OLE1 FORMATS WHEN IMPLEMENTED


	return fRet;
}
	
//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::SetupOle1Mode (public)
//
//  Synopsis:	Sets the data object up for OLE1 compatibility mode
//
//  Effects:
//
//  Arguments:	[fFlags]	-- specifies various OLE1 options
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//		The default test information in the data object will be
//		lost by this call.  Simply create a new data object if
//		it is needed again.
//
//--------------------------------------------------------------------------

void CGenDataObject::SetupOle1Mode( Ole1TestFlags fFlags )
{
	DWORD	count = 0, i = 0;
	UINT	cfFormats[3];		// OLE1 formats offered

	if( fFlags == 0 )
	{
		// don't need to do anything
		return;
	}

	// the formats we had previously

	delete m_rgFormats;


	// first figure out how many formats we need

	if( (fFlags & OLE1_OFFER_NATIVE) )
	{
		if( !((fFlags & OLE1_OWNERLINK_PRECEDES_NATIVE) &&
			(fFlags & OLE1_OFFER_OWNERLINK)) )
		{
			cfFormats[i] = m_cfNative;
			i++;
		}
		count++;
	}

	if( (fFlags & OLE1_OFFER_OWNERLINK) )
	{
		cfFormats[i] = m_cfOwnerLink;
		i++;

		if( (fFlags & OLE1_OWNERLINK_PRECEDES_NATIVE) &&
			(fFlags & OLE1_OFFER_NATIVE) )
		{
			cfFormats[i] = m_cfNative;
			i++;
		}
		
		count++;
	}

	if( (fFlags & OLE1_OFFER_OBJECTLINK) )
	{

		cfFormats[i] = m_cfObjectLink;
		
		count++;
	}

	m_rgFormats = new FORMATETC[count];

	assert(m_rgFormats);

	for(i = 0; i < count; i++ )
	{
		m_rgFormats[i].cfFormat = cfFormats[i];
		m_rgFormats[i].ptd = NULL;
		m_rgFormats[i].dwAspect = DVASPECT_CONTENT;
		m_rgFormats[i].lindex = -1;
		m_rgFormats[i].tymed = TYMED_HGLOBAL;
	}

	m_cFormats = count;

	m_fOle1 = fFlags;

	return;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::SetOle1ToClipboard
//
//  Synopsis:	stuffs available OLE1 formats to the clipboard
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires: 	SetOle1Mode *must* have been called
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CGenDataObject::SetOle1ToClipboard( void )
{
	HRESULT	hresult = NOERROR;
	DWORD	i;
	HGLOBAL	hglobal;

	assert((m_fOle1 & (OLE1_OFFER_OWNERLINK | OLE1_OFFER_OBJECTLINK |
		OLE1_OFFER_NATIVE)));

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	if( !EmptyClipboard() )
	{
		CloseClipboard();
		return ResultFromScode(CLIPBRD_E_CANT_EMPTY);
	}

	for( i = 0 ; i < m_cFormats; i++ )
	{
		if( m_rgFormats[i].cfFormat == m_cfNative )
		{
			hglobal = GetNativeData();
			SetClipboardData(m_cfNative, hglobal);
		}
		else if( m_rgFormats[i].cfFormat == m_cfOwnerLink )
		{
			hglobal = GetOwnerOrObjectLink();
			SetClipboardData(m_cfOwnerLink, hglobal);
		}
		else if( m_rgFormats[i].cfFormat == m_cfObjectLink )
		{
			hglobal = GetOwnerOrObjectLink();
			SetClipboardData(m_cfObjectLink, hglobal);
		}
		else
		{
			hresult = ResultFromScode(E_UNEXPECTED);
		}
	}

	CloseClipboard();

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenDataObject::HasQIBeenCalled (public)
//
//  Synopsis:	returns wether or not QueryInterface has been called on
//		this data object.  Used in testing OleQueryCreateFromData
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns: 	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		23-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::HasQIBeenCalled()
{
	return m_fQICalled;	
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::SetDatFormats
//
//  Synopsis:  	sets the formats that the data object will offer
//
//  Effects:
//
//  Arguments: 	[fFlags]	-- formats to offer
//
//  Requires:
//
//  Returns: 	void
//	     	
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		23-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGenDataObject::SetDataFormats( DataFlags fFlags )
{
	DWORD 		cFormats = 0;
	DWORD	 	flags = (DWORD)fFlags;
	DWORD 		i =0;

	if( m_rgFormats )
	{
		delete m_rgFormats;
		m_rgFormats = NULL;
	}

	if( flags == 0 )
	{
		return;
	}

	// count the number of formats to offer

	cFormats++;

	while( flags &= (flags -1) )
	{
		cFormats++;
	}

   	m_rgFormats = new FORMATETC[cFormats];

	assert(m_rgFormats);

	memset(m_rgFormats, 0, sizeof(FORMATETC)*cFormats);

	if( fFlags & OFFER_TESTSTORAGE )
	{
		m_rgFormats[i].cfFormat = m_cfTestStorage;
		m_rgFormats[i].ptd = NULL;
		m_rgFormats[i].dwAspect = DVASPECT_CONTENT;
		m_rgFormats[i].lindex = -1;
		m_rgFormats[i].tymed = TYMED_ISTORAGE;

		i++;
	}

	if( fFlags & OFFER_EMBEDDEDOBJECT )
	{
		m_rgFormats[i].cfFormat = m_cfEmbeddedObject;
		m_rgFormats[i].ptd = NULL;
		m_rgFormats[i].dwAspect = DVASPECT_CONTENT;
		m_rgFormats[i].lindex = -1;
		m_rgFormats[i].tymed = TYMED_ISTORAGE;
		i++;
	}

	m_cFormats = i;
}

//
// Generic Data Object formatetc enumerator
//

//+-------------------------------------------------------------------------
//
//  Member: 	CGenEnumFormatEtc::QueryInterface
//
//  Synopsis: 	returns requested interfaces
//
//  Effects:
//
//  Arguments: 	[riid]		-- the requested interface
//		[ppvObj]	-- where to put the interface pointer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	HRESULT		hresult = NOERROR;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IEnumFORMATETC) )
	{
		*ppvObj = this;
		AddRef();
	}
	else
	{
		*ppvObj = NULL;
		hresult = ResultFromScode(E_NOINTERFACE);
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenEnumFormatEtc::AddRef
//
//  Synopsis:	increments the reference count
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	ULONG-- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenEnumFormatEtc::AddRef( )
{
	return ++m_refs;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CGenEnumFormatEtc::Release
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenEnumFormatEtc::Release( )
{
	ULONG cRefs;

	if( (cRefs = --m_refs ) == 0 )
	{
		delete this;
	}
	return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Next
//
//  Synopsis:	gets the next [celt] formats
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of elements to fetch
//		[rgelt]		-- where to put them
//		[pceltFetched]	-- the number of formats actually fetched
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
		ULONG *pceltFetched)
{
	HRESULT		hresult = NOERROR;
	ULONG		cFetched;

	if( celt > m_cTotal - m_iCurrent )
	{
		cFetched = m_cTotal - m_iCurrent;
		hresult = ResultFromScode(S_FALSE);
	}
	else
	{
		cFetched = celt;
	}

	memcpy( rgelt, m_rgFormats + m_iCurrent,
			cFetched * sizeof(FORMATETC) );

	m_iCurrent += cFetched;

	if( pceltFetched )
	{
		*pceltFetched = cFetched;
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Skip
//
//  Synopsis:	skips the next [celt] formats
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of elements to skip
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Skip( ULONG celt )
{
	HRESULT		hresult = NOERROR;

	m_iCurrent += celt;

	if( m_iCurrent > m_cTotal )
	{
		// whoops, skipped to far ahead.  Set us to the max limit.
		m_iCurrent = m_cTotal;
		hresult = ResultFromScode(S_FALSE);
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Reset
//
//  Synopsis:	resets the seek pointer to zero
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Reset( void )
{
	m_iCurrent = 0;

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Clone
//
//  Synopsis:	clones the enumerator
//
//  Effects:
//
//  Arguments:	[ppIEnum]	-- where to put the cloned enumerator
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
	HRESULT			hresult = ResultFromScode(E_OUTOFMEMORY);
	CGenEnumFormatEtc *	pClipEnum;	

	*ppIEnum = NULL;

	pClipEnum = new CGenEnumFormatEtc();

	// ref count will be 1 and m_iCurrent will be zero.

	if( pClipEnum )
	{
		pClipEnum->m_cTotal = m_cTotal;
		pClipEnum->m_rgFormats = new FORMATETC[m_cTotal];
		pClipEnum->m_iCurrent = m_iCurrent;

		assert(pClipEnum->m_rgFormats);

		if( pClipEnum->m_rgFormats )
		{
			// copy our formatetc's into the cloned enumerator's
			// array
			memcpy(pClipEnum->m_rgFormats, m_rgFormats,
				m_cTotal * sizeof(FORMATETC) );

			*ppIEnum = pClipEnum;
	
			hresult = NOERROR;
		}
		else
		{
			
			delete pClipEnum;
		}
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenEnumFormatEtc::CGenEnumFormatEtc, private
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	 	15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CGenEnumFormatEtc::CGenEnumFormatEtc( void )
{
	m_refs 		= 1;	// give the intial reference
	m_rgFormats 	= NULL;
	m_iCurrent	= 0;
	m_cTotal	= 0;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenEnumFormatEtc::~CGenEnumFormatEtc, private
//
//  Synopsis:	destructor
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	 	15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CGenEnumFormatEtc::~CGenEnumFormatEtc( void )
{
	if( m_rgFormats )
	{
		delete m_rgFormats;
	}
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenEnumFormatEtc::Create, static, public
//
//  Synopsis:	Creates a clipboard formatetc enumerator
//	      	
//  Effects:
//
//  Arguments: 	[ppIEnum]	-- where to put the enumerator
//
//  Requires:	the clipboard must be open
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CGenEnumFormatEtc::Create( IEnumFORMATETC **ppIEnum,
		FORMATETC *prgFormats, DWORD cFormats )
{
	HRESULT			hresult = ResultFromScode(E_OUTOFMEMORY);
	CGenEnumFormatEtc *	pClipEnum;


	*ppIEnum = NULL;

	pClipEnum = new CGenEnumFormatEtc();

	assert(pClipEnum);

	// now allocate memory for the array

	pClipEnum->m_rgFormats = new FORMATETC[cFormats];

	assert(pClipEnum->m_rgFormats);

	pClipEnum->m_cTotal = cFormats;

	memcpy(pClipEnum->m_rgFormats, prgFormats,
		cFormats * sizeof(FORMATETC));

	*ppIEnum = pClipEnum;

	return NOERROR;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\gendata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	gendata.h
//
//  Contents: 	Declaration of a generic data object.
//
//  Classes:	CGenDataObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
// 		24-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _GENDATA_H
#define _GENDATA_H

// flags used by OLE1 compatibilty mode

typedef enum
{
	OLE1_OFFER_OWNERLINK	= 1,
	OLE1_OFFER_OBJECTLINK	= 2,
	OLE1_OFFER_NATIVE	= 4,
	OLE1_OWNERLINK_PRECEDES_NATIVE = 8
} Ole1TestFlags;

// more flags used to control what formats are offered

typedef enum
{
	OFFER_TESTSTORAGE	= 1,
	OFFER_EMBEDDEDOBJECT	= 2
} DataFlags;


//+-------------------------------------------------------------------------
//
//  Class:	CGenDataObject
//
//  Purpose: 	generic data object (for clipboard data transfers, etc)
//
//  Interface: 	IDataObject
//
//  History:    dd-mmm-yy Author    Comment
// 		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CGenDataObject : public IDataObject
{
public:
	// IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);
	
	// IDataObject methods
	STDMETHOD(GetData)(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
	STDMETHOD(GetDataHere)(THIS_ LPFORMATETC pformatetc,
	    LPSTGMEDIUM pmedium);
	STDMETHOD(QueryGetData)(THIS_ LPFORMATETC pformatetc);
	STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC pformatetc,
	    LPFORMATETC pformatetcOut);
	STDMETHOD(SetData)(LPFORMATETC pformatetc,
			STGMEDIUM FAR* pmedium, BOOL fRelease);
	STDMETHOD(EnumFormatEtc)(DWORD dwDirection,
	    LPENUMFORMATETC FAR* ppenumFormatEtc);
	STDMETHOD(DAdvise)(FORMATETC FAR* pFormatetc, DWORD advf,
	    IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection);
	STDMETHOD(DUnadvise)(DWORD dwConnection);
	STDMETHOD(EnumDAdvise)(LPENUMSTATDATA FAR* ppenumAdvise);

	// constructor
	CGenDataObject();

	// test functions

	BOOL VerifyFormatAndMedium(FORMATETC *pformatetc, STGMEDIUM *pmedium);

	// OLE1 compatibility test functions

	void SetupOle1Mode( Ole1TestFlags fFlags );
	HRESULT SetOle1ToClipboard( void );

       	// Used by various tests, controls what formats are offered by
	// the data object

	void SetDataFormats( DataFlags fFlags );

	// Indicates whether or not QueryInterface was called.  Used by
	// OleQueryXXX tests.

	BOOL HasQIBeenCalled();

	// test clipboard formats

	UINT		m_cfTestStorage;
	UINT		m_cfEmbeddedObject;
	UINT		m_cfEmbedSource;
	UINT		m_cfObjectDescriptor;
	UINT		m_cfLinkSource;
	UINT		m_cfLinkSrcDescriptor;
	UINT		m_cfOwnerLink;
	UINT		m_cfObjectLink;
	UINT		m_cfNative;

private:
	IStorage * 	GetTestStorage(void);

	BOOL		VerifyTestStorage(FORMATETC *pformatetc,
				STGMEDIUM *pmedium);

	ULONG 		m_refs; 	// reference count
	DWORD 		m_cFormats;	// number of formats supported
	FORMATETC *	m_rgFormats;	// the formats

	// OLE1 support functions and data
	HGLOBAL		GetOwnerOrObjectLink(void);
	HGLOBAL		GetNativeData(void);

	BOOL		VerifyOwnerOrObjectLink( FORMATETC *pformatec,
				STGMEDIUM *pmedium);
	BOOL		VerifyNativeData( FORMATETC *pformatetc,
				STGMEDIUM *pmedium);

	Ole1TestFlags	m_fOle1;	// OLE1 configuration flags
	BOOL		m_fQICalled;

};

//+-------------------------------------------------------------------------
//
//  Class: 	CGenEnumFormatEtc
//
//  Purpose:	Enumerator for the formats available on the generic data
//		object
//
//  Interface: 	IEnumFORMATETC
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CGenEnumFormatEtc :public IEnumFORMATETC
{
public:
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	STDMETHOD(Next) (ULONG celt, FORMATETC *rgelt,
			ULONG *pceltFetched);
	STDMETHOD(Skip) (ULONG celt);
	STDMETHOD(Reset) (void);
	STDMETHOD(Clone) (IEnumFORMATETC **ppenum);

	static HRESULT Create(IEnumFORMATETC **ppIEnum, FORMATETC *prgFormats,
			DWORD cFormats);

private:
	CGenEnumFormatEtc();	// constructor
	~CGenEnumFormatEtc();	// destructor

	ULONG		m_refs;		// reference count
	ULONG		m_iCurrent;	// current clipboard format
	ULONG		m_cTotal;	// total number of formats
	FORMATETC *	m_rgFormats;	// array of available formats
};


#endif // !_GENDATA_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\genenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	genenum.cpp
//
//  Contents: 	implementation of CGenDataObject
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "genenum.h"

//+-------------------------------------------------------------------------
//
//  Member:     CEnumeratorTest::CEnumeratorTest
//
//  Synopsis:   Constructor
//
//  Effects:
//
//  Arguments:  [penum]		-- Enumerator Interface cast to void*
//		[ElementSize]	-- Size of elements return from next
//		[ElementCount]	-- Numer of elements that should be in the enumeration,
//				   -1 if unknown.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

CEnumeratorTest::CEnumeratorTest(
		void *penum,
		size_t ElementSize,
		LONG ElementCount,
                HRESULT& rhr)
{
	assert(penum);

	m_pEnumTest = (IGenEnum*)penum;

	m_ElementSize = ElementSize;
	m_ElementCount = ElementCount;

	rhr = m_pEnumTest->Reset();

	if (rhr != S_OK)
	{
		OutputStr(("IEnumnX: Reset failed (%lx)\r\n", rhr));
	}
}



//+-------------------------------------------------------------------------
//
//  Function: 	CEnumeratorTest::GetNext
//
//  Synopsis:	Internal Next Implementation. Does some basic checks on the	
//		return values.
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of items to fetch
//		[pceltFetched]	-- the number of items fetched
//		[phresult]	-- the return from next
//
//  Requires:
//
//  Returns:	True if the basic tests passed, false if they didn't
//		The result of the next call itself is passed in param 3.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Checks:
//		That if s_ok is returned celt and pceltFetched are ==
//		If a verify is provided it is called
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTest::GetNext(	ULONG   celt,
		ULONG*  pceltFetched,
		HRESULT* phresult
		)
{
	void* 	prgelt;
	ULONG  	ul;
	BOOL	fRet = TRUE;

	// Allocate memory for the return elements

	prgelt = new char[m_ElementSize * celt];

	assert(prgelt);

	// Call next

	*phresult = m_pEnumTest->Next(celt, prgelt, pceltFetched);

	// If the return result is S_OK make sure the numbers match

	if (*phresult == S_OK)
	{
		if ((pceltFetched) && (celt != *pceltFetched))
		{
			OutputStr(("IEnumX::Next return S_OK but celt"
					" and pceltFetch mismatch.\r\n"));
			return(FALSE);
		}
	}

	// Call verify to make sure the elements are ok.

	if ((*phresult == NOERROR) || (*phresult == ResultFromScode(S_FALSE)))
	{
		// loop through every returned element

		for (ul=0; ul < *pceltFetched ; ul++)
		{
			if (!Verify(prgelt))
			{
				OutputStr(("Data elment %d returned by IEnumX::Next is bad.\r\n",
						ul));

				fRet = FALSE;
				// we keep looping anyway just to
				// free up resources.
			}

			// If the user supplied a cleanup function there is additional
			// memory that needs to be freed

			CleanUp(prgelt);
		}

	}

	free (prgelt);

	return fRet;
}

//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::TestNext
//
//  Synopsis:	Test the next enumerator methods
//
//  Effects:
//
//  Arguments:	None.
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestNext(void)
{
	ULONG	celtFetched;
	LONG	InternalCount = 0;
	HRESULT	hresult;

	// First we want to count the element by doing a next on each one.

	do {
		if (!GetNext(1, &celtFetched, &hresult))
		{
			return ResultFromScode(E_FAIL);
		}
		if (hresult == S_OK)
		{
			InternalCount++;
		}

	} while ( hresult == S_OK );

	// If the user passed in an ammount make sure it matches what we got

	if ((m_ElementCount != -1) && (InternalCount != m_ElementCount))
	{
		OutputStr(("IEnumX: enumerated count and passed count do not match!\r\n"));
		return ResultFromScode(E_FAIL);
	}

	m_pEnumTest->Reset();

	// Make sure we fail on ...Next(celt>1, ...,NULL)

	/* BUGBUG: clipboard enumerator fails on this test

	if (GetNext(2, NULL, &hresult))
	{
		if ((hresult == S_OK ) || (hresult == S_FALSE))
		{
			(("IEnumX: celt>1 pceltFetched==NULL returned S_OK\r\n"));
			return(E_FAIL);
		}
	}
	else
	{
		return(E_FAIL);
	}

	*/

	return(S_OK);

}

//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::TestAll
//
//  Synopsis:	This function calls all the tests
//
//  Effects:
//
//  Arguments:	None
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestAll(void)
{
	return(TestNext());


}




//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::VerifyAll
//
//  Synopsis:   Verify entire array of returned results.
//
//  Arguments:	None
//
//  Returns:	HRESULT
//
//  Algorithm:  Just default to saying everything is ok
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 ricksa    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTest::VerifyAll(void *pv, LONG cl)
{
	return TRUE;
}




//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::CleanUp
//
//  Synopsis:   Default implementation of cleanup
//
//  Arguments:  [pv] - pointer to entry enumerated
//
//  Algorithm:  If there is nothing special to free this implementation
//              can be used.
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 ricksa    author
//
//--------------------------------------------------------------------------

void  CEnumeratorTest::CleanUp(void *pv)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\genenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	genenum.h
//
//  Contents: 	Declaration of a generic enum object and test object.
//
//  Classes:	CGenEnumObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author! author!
//
//--------------------------------------------------------------------------

#ifndef _GENENUM_H
#define _GENENUM_H

//
// This macro allows the code to use a different outputstring function.
//

#define OutputStr(a) OutputString a

//+-------------------------------------------------------------------------
//
//  Class:	IGenEnum
//
//  Purpose: 	generic enumerator
//
//  Interface: 	Abstract class
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class IGenEnum
{
public:
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	STDMETHOD(Next) (ULONG celt, void *rgelt,
			ULONG *pceltFetched) = 0;
	STDMETHOD(Skip) (ULONG celt) = 0;
	STDMETHOD(Reset) (void) = 0;
	STDMETHOD(Clone) (void **ppenum) = 0;
};

//+-------------------------------------------------------------------------
//
//  Class:	CEnumeratorTest
//
//  Purpose: 	enumerator test class
//
//  Interface: 	
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CEnumeratorTest
{
public:	
	// Constructor

	CEnumeratorTest(
			void *penum,
			size_t ElementSize,
			LONG ElementCount,
                        HRESULT& rhr);

	// Test for each enumerator object

	HRESULT TestAll(void);
	HRESULT TestNext(void);
// NYI!	HRESULT TestSkip(void);
//	HRESULT TestClone(void);
//	HRESULT TestRelease(void);

        // For derived classes which know what we are enumerating
        virtual BOOL Verify(void *) = 0;
        virtual BOOL VerifyAll(void *, LONG);
        virtual void CleanUp(void *);

private:	

	BOOL GetNext(ULONG celt, ULONG* pceltFetched, HRESULT* phresult);

	IGenEnum *	m_pEnumTest;
	size_t		m_ElementSize;
	LONG		m_ElementCount;
};

#endif // !_GENENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\oleadv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	oleadv.cpp
//
//  Contents: 	implementation of unit test for Ole Advise Holder
//
//  Classes:    CTestPretendMoniker
//              COaTestAdviseSink
//              COaTestObj
//
//  Functions:  NotifyOfChanges
//              TestSingleOleAdvise
//              TestMassOleAdvise
//              TestOleAdviseHolderEnumerator
//              LEOleAdviseHolderTest
//
//  History:    dd-mmm-yy Author    Comment
//              27-May-94 ricksa    author
//
//--------------------------------------------------------------------------
#include    "oletest.h"


#define MAX_OA_TO_REGISTER 100




//+-------------------------------------------------------------------------
//
//  Class:      CTestPretendMoniker
//
//  Purpose:    Use where we need a moniker to confirm reciept of OnRename
//
//  Interface:  QueryInterface - get a new interface
//              AddRef - add a reference
//              Release - remove a reference
//              VerifySig - verify signiture is correct
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      This only supports IUnknown
//
//--------------------------------------------------------------------------
class CTestPretendMoniker : public IUnknown
{
public:
                        CTestPretendMoniker(void);

    // IUnknown methods
    HRESULT __stdcall  QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    ULONG __stdcall     AddRef(void);

    ULONG __stdcall     Release(void);

    BOOL                VerifySig(void);

private:

    enum Sigs { SIG1 = 0x01020304, SIG2 = 0x04030201 };

    LONG                _lRefs;

    Sigs                _sig1;

    Sigs                _sig2;

};



//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::CTestPretendMoniker
//
//  Synopsis:   Initialize object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CTestPretendMoniker::CTestPretendMoniker(void)
    : _lRefs(0), _sig1(SIG1), _sig2(SIG2)
{
    // Header does all the work
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::VerifySig
//
//  Synopsis:   Verify signiture is as expected
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestPretendMoniker::VerifySig(void)
{
    return (_sig1 == SIG1 && _sig2 == SIG2);
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::QueryInterface
//
//  Synopsis:   Return a supported interface
//
//  Arguments:  [riid] - interface id requested
//              [ppvObj] - where to put the interface
//
//  Returns:    S_OK - we are returning an interface
//              E_NOINTERFACE - we do not support the requested interface
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT __stdcall CTestPretendMoniker::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IMoniker, riid))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::AddRef
//
//  Synopsis:   Bump reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall CTestPretendMoniker::AddRef(void)
{
    return _lRefs++;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::Release
//
//  Synopsis:   Decrement the reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall CTestPretendMoniker::Release(void)
{
    assert(_lRefs >= 1);

    return --_lRefs;
}




//+-------------------------------------------------------------------------
//
//  Class:      COaTestAdviseSink
//
//  Purpose:    Advise sink for use in testing the Ole Advise Holder
//
//  Interface:  QueryInterface - get supported interface pointer
//              AddRef - bump reference count
//              Release - decrement reference count
//              OnDataChange - not implemented
//              OnViewChange - not implemented
//              OnRename - rename notification
//              OnSave - save notification
//              OnClose - close notification
//              VerifyNotifications - verify all expected notifications arrived
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We only support parts of advise sink we need to test the
//              advise holder.
//
//--------------------------------------------------------------------------
class COaTestAdviseSink : public IAdviseSink
{
public:
                        COaTestAdviseSink(void);

    // IUnknown methods
    HRESULT __stdcall  QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    ULONG __stdcall     AddRef(void);

    ULONG __stdcall     Release(void);

    // IAdviseSink methods
    void __stdcall      OnDataChange(FORMATETC *pFormatetc, STGMEDIUM *pStgmed);

    void __stdcall      OnViewChange(
                            DWORD dwAspect,
                            LONG lindex);

    void __stdcall      OnRename(IMoniker *pmk);

    void __stdcall      OnSave(void);

    void __stdcall      OnClose(void);

    // Test methods used for verification
    BOOL                VerifyNotifications(void);

private:

    LONG                _lRefs;

    BOOL                _fOnCloseNotify;

    BOOL                _fOnSaveNotify;

    BOOL                _fOnRenameNotify;
};



//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::COaTestAdviseSink
//
//  Synopsis:   Initialize advise sink
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
COaTestAdviseSink::COaTestAdviseSink(void)
    : _lRefs(1), _fOnCloseNotify(FALSE), _fOnSaveNotify(FALSE),
        _fOnRenameNotify(FALSE)
{
    // Header does all the work
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::QueryInterface
//
//  Synopsis:   Return requested interface pointer
//
//  Arguments:  [riid] - interface id requested
//              [ppvObj] - where to put the interface
//
//  Returns:    S_OK - we are returning an interface
//              E_NOINTERFACE - we do not support the requested interface
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT __stdcall COaTestAdviseSink::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IAdviseSink, riid))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::AddRef
//
//  Synopsis:   Bump reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall COaTestAdviseSink::AddRef(void)
{
    return _lRefs++;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::Release
//
//  Synopsis:   Decrement reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall COaTestAdviseSink::Release(void)
{
    assert(_lRefs >= 1);

    return --_lRefs;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnDataChange
//
//  Synopsis:   Notify of change in data
//
//  Arguments:  [pFormatetc] - FORMATETC of data
//              [pStgmed] - storage medium for data
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnDataChange(
    FORMATETC *pFormatetc,
    STGMEDIUM *pStgmed)
{
    OutputString("COaTestAdviseSink::OnDataChange Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnViewChange
//
//  Synopsis:   Notify that view should change
//
//  Arguments:  [dwAspect] - specifies view of the object
//              [lindex] -  which piece of view changed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnViewChange(
    DWORD dwAspect,
    LONG lindex)
{
    OutputString("COaTestAdviseSink::OnViewChange Unexpectedly Called!\r\n");
}



//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnRename
//
//  Synopsis:   Notifies of rename operation
//
//  Arguments:  [pmk] - new full name of the object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnRename(IMoniker *pmk)
{
    // Verify that we get the pretend moniker
    CTestPretendMoniker *ptpm = (CTestPretendMoniker *) pmk;

    if (ptpm->VerifySig())
    {
        _fOnCloseNotify = TRUE;
    }
    else
    {
        OutputString("OnRename got a bad moniker\r\n");
    }
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnSave
//
//  Synopsis:   Notifies that object has been saved
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnSave(void)
{
    _fOnSaveNotify = TRUE;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnClose
//
//  Synopsis:   Notifies that object has been closed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnClose(void)
{
    _fOnRenameNotify = TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::VerifyNotifications
//
//  Synopsis:   Verify that we recieved expected notifications
//
//  Returns:    TRUE - we recieved expected notification
//              FALSE - we didn't receive expected notifications
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      This resets the values after returning the result
//
//--------------------------------------------------------------------------
BOOL COaTestAdviseSink::VerifyNotifications(void)
{
    // Save the result of all the notifications
    BOOL fResult = _fOnCloseNotify && _fOnSaveNotify && _fOnRenameNotify;

    // Reset the notifications
    _fOnCloseNotify = FALSE;
    _fOnSaveNotify = FALSE;
    _fOnRenameNotify = FALSE;

    // Let caller know the result of the notifications
    return fResult;
}




//+-------------------------------------------------------------------------
//
//  Class:      COaTestObj
//
//  Purpose:    Provides place to keep information related to an advise
//
//  Interface:  Register - register advise with holder
//              VerifyNotified - verify that object was notified by holder
//              Revoke - revoke registration with holder
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
class COaTestObj
{
public:
                        COaTestObj(void);

    HRESULT             Register(IOleAdviseHolder *poah, char *pszCaller);

    HRESULT             VerifyNotified(void);

    HRESULT             Revoke(void);

private:

    COaTestAdviseSink   _otas;

    DWORD               _dwConnection;

    IOleAdviseHolder *  _poah;

    char *              _pszTest;
};



//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::COaTestObj
//
//  Synopsis:   Initialize object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
COaTestObj::COaTestObj(void) : _dwConnection(0)
{
    // Header does all the work
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::Register
//
//  Synopsis:   Register advise with the holder
//
//  Arguments:  [poah] - pointer to the advise holder
//              [pszTest] - name of the test
//
//  Returns:    S_OK - registration was successful
//              E_FAIL - registration failed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT COaTestObj::Register(IOleAdviseHolder *poah, char *pszTest)
{
    // Register the advise
    HRESULT hr = poah->Advise(&_otas, &_dwConnection);

    // Make sure results are sensible
    if (hr != NOERROR)
    {
        OutputString("%s Registration failed hr = %lx\r\n", pszTest, hr);
        return E_FAIL;
    }

    if (_dwConnection == 0)
    {
        OutputString("%s Connection not updated\r\n", pszTest);
        return E_FAIL;
    }

    // Save these for the revoke
    _pszTest = pszTest;
    _poah = poah;

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::VerifyNotified
//
//  Synopsis:   Verify that our advise was notified of changes
//
//  Returns:    S_OK - advise was notified of changes
//              E_FAIL - object was not notified.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT COaTestObj::VerifyNotified(void)
{
    if (!_otas.VerifyNotifications())
    {
        OutputString("%s Object not correctly notified\r\n", _pszTest);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::Revoke
//
//  Synopsis:   Revoke our advise registration with advise holder
//
//  Returns:    S_OK - advise was successfully deregistered
//              E_FAIL - revokation experience unexpected result
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT COaTestObj::Revoke(void)
{
    // Remove the advise registration
    HRESULT hr = _poah->Unadvise(_dwConnection);

    if (hr != NOERROR)
    {
        OutputString("%s Revoke failed hr = %lx\r\n", _pszTest, hr);
        return E_FAIL;
    }

    // Try the unadvise one more time to make sure it took
    hr = _poah->Unadvise(_dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second revoke bad hr = %lx\r\n", _pszTest, hr);
        return E_FAIL;
    }

    return NOERROR;
}



//+-------------------------------------------------------------------------
//
//  Function:   NotifyOfChanges
//
//  Synopsis:   Run through list of possible notifications for advise
//
//  Arguments:  [poahForTest] - advise holder we are testing
//              [pszTest] - test description
//
//  Returns:    NOERROR - all notifications reported success
//              Any Other - error occurred during notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We currently only do the public notifications
//
//--------------------------------------------------------------------------
HRESULT NotifyOfChanges(IOleAdviseHolder *poahForTest, char *pszTest)
{
    // Notify Renamed
    CTestPretendMoniker tpm;

    HRESULT hr = poahForTest->SendOnRename((IMoniker *) &tpm);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnRename failed hr = %lx\r\n", pszTest);
        return hr;
    }

    // Notify of save
    hr =  poahForTest->SendOnSave();

    if (hr != NOERROR)
    {
        OutputString("%s SendOnSave failed hr = %lx\r\n", pszTest);
        return hr;
    }

    // Notify of close
    hr =  poahForTest->SendOnClose();

    if (hr != NOERROR)
    {
        OutputString("%s SendOnClose failed hr = %lx\r\n", pszTest);
        return hr;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestSingleOleAdvise
//
//  Synopsis:   Test advise holder with only a single advise
//
//  Arguments:  [poahForTest] - advise holder we are testing
//
//  Returns:    NOERROR - test was successfully passed
//              Any Other - test failed
//
//  Algorithm:  Create a test object. Register that test object with the
//              advise holder. Tell adviser holder to notify all its objects
//              of changes. Verify that test object was notified. Revoke
//              the registration of the test object with the advise holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestSingleOleAdvise(IOleAdviseHolder *poahForTest)
{
    char *pszTest = "TestSingleOleAdvise";
    COaTestObj oto;

    // Register a single advise
    HRESULT hr = oto.Register(poahForTest, pszTest);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Notifiy it of changes
    hr = NotifyOfChanges(poahForTest, pszTest);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Verify that notifications occurred
    hr = oto.VerifyNotified();

    if (hr != NOERROR)
    {
        return hr;
    }

    // Revoke all advises
    return oto.Revoke();
}




//+-------------------------------------------------------------------------
//
//  Function:   TestMassOleAdvise
//
//  Synopsis:   Test registering a very large number of advises
//
//  Arguments:  [poahForTest] - advise holder we are testing
//
//  Returns:    NOERROR - test was successfully passed
//              Any Other - test failed
//
//  Algorithm:  Create a large number of test objects. Then register all
//              those with the advise holder for changes. Tell advise holder
//              to notify all its registered objects of changes. Verify that
//              each of the test objects recieved a notification. Finally,
//              revoke all the test object registrations.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestMassOleAdvise(IOleAdviseHolder *poahForTest)
{
    char *pszTest = "TestMassOleAdviseHolder";

    // Create a large number of advises
    COaTestObj aoto[MAX_OA_TO_REGISTER];

    HRESULT hr;

    // Register all the advises
    for (int i = 0; i < MAX_OA_TO_REGISTER; i++)
    {
        hr = aoto[i].Register(poahForTest, pszTest);

        if (hr != NOERROR)
        {
            OutputString("%s Failed on Loop %d\r\n", pszTest, i);
            return hr;
        }
    }

    // Notify all the advises of changes
    hr = NotifyOfChanges(poahForTest, pszTest);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Verify all objects were notified
    for (i = 0; i < MAX_OA_TO_REGISTER; i++)
    {
        hr = aoto[i].VerifyNotified();

        if (hr != NOERROR)
        {
            OutputString("%s Failed on Loop %d\r\n", pszTest, i);
            return hr;
        }
    }

    // Revoke all registrations
    for (i = 0; i < MAX_OA_TO_REGISTER; i++)
    {
        hr = aoto[i].Revoke();

        if (hr != NOERROR)
        {
            OutputString("%s Failed on Loop %d\r\n", pszTest, i);
            return hr;
        }
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestOleAdviseHolderEnumerator
//
//  Synopsis:   Test the OLE Advise Holder enumerator
//
//  Arguments:  [poahForTest] - OLE advise holder we are testing
//
//  Returns:    NOERROR - test passed
//              Any Other - test failed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We currently just verify that the enumerator is not implemented
//
//--------------------------------------------------------------------------
HRESULT TestOleAdviseHolderEnumerator(IOleAdviseHolder *poahForTest)
{
    char *pszCaller = "TestOleAdviseHolderEnumerator";

    // Confirm no enumerator
    IEnumSTATDATA *penumAdvise;

    HRESULT hr = poahForTest->EnumAdvise(&penumAdvise);

    if (hr != E_NOTIMPL)
    {
        OutputString("%s EnumAdvise Hresult = %lx\r\n", pszCaller, hr);
        return E_FAIL;
    }

    if (penumAdvise != NULL)
    {
        OutputString("%s EnumAdvise returned advise not NULL\r\n", pszCaller);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   LEOleAdviseHolderTest
//
//  Synopsis:   Unit test for advise holders
//
//  Returns:    NOERROR - test passed
//              Any Other - test failed
//
//  Algorithm:  First we verify that a large number of verification work. Then
//              we verify that a large number of registrations work. Finally,
//              we verify that the enumerator for the OLE advise holder
//              behaves as expected.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT LEOleAdviseHolderTest(void)
{
    IOleAdviseHolder *poahForTest;

    HRESULT hr = CreateOleAdviseHolder(&poahForTest);

    // Test a single registration
    if ((hr = TestSingleOleAdvise(poahForTest)) != NOERROR)
    {
        return hr;
    }


    // Test a large number of registrations
    if ((hr = TestMassOleAdvise(poahForTest)) != NOERROR)
    {
        return hr;
    }


    // Test Enumerator
    if ((hr = TestOleAdviseHolderEnumerator(poahForTest)) != NOERROR)
    {
        return hr;
    }

    // Release the advise holder
    DWORD dwFinalRefs = poahForTest->Release();

    if (dwFinalRefs != 0)
    {
        OutputString(
            "LEOleAdviseHolderTest Final Release is = %d", dwFinalRefs);
        return E_FAIL;
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\oletest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	oletest.h
//
//  Contents:	include all other headers needed for oletest
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-93 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _OLETEST_H
#define _OLETEST_H

//system includes
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <ole2.h>

// define the OLECHAR stuff
#ifndef WIN32

#define OLECHAR char
#define LPOLESTR LPSTR
#define OLESTR(x) x

#include <toolhelp.h>

#endif // !WIN32

//app includes
#include "assert.h"
#include "task.h"
#include "stack.h"
#include "app.h"
#include "output.h"
#include "utils.h"

#include <testmess.h>

#else
	Error!  Oletest.h included multiple times.
#endif //!_OLETEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\letest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       letest.h
//
//  Contents:   declarations for all upper-layer test routines
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _LETEST_H
#define _LETEST_H

struct SLETestInfo
{
    char *pszPgm;
    UINT dwMsgId;
};

extern SLETestInfo letiInsertObjectTest1;
extern SLETestInfo letiInsertObjectTest2;

extern SLETestInfo letiInplaceTest1;

extern SLETestInfo letiOle1Test1;
extern SLETestInfo letiOle1Test2;
extern SLETestInfo letiClipTest;

void LETest1( void * );
HRESULT LEClipTest1( void );
HRESULT LEClipTest2( void );
HRESULT LEOle1ClipTest1( void );
void LEOle1ClipTest2( void *);

HRESULT LEDataAdviseHolderTest( void );
HRESULT LEOleAdviseHolderTest( void );

HRESULT TestOleQueryCreateFromDataMFCHack( void );


#endif  //!_LETEST_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\oletest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oletest.cpp
//
//  Contents:   WinMain and the main message filter for oletest
//
//  Classes:
//
//  Functions:  WinMain
//              InitApplication
//              InitInstance
//              MainWndProc
//
//
//  History:    dd-mmm-yy Author    Comment
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "appwin.h"

#define MAX_WM_USER 0x7FFF

// Global instance of the app class.  All interesting app-wide
// data is contained within this instance.

OleTestApp vApp;


// Constant used to identify the edit window

static const int EDITID=1;

//
// Misc internal prototypes
//

void ListAllTests();
void PrintHelp();


//+-------------------------------------------------------------------------
//
//  Function:   MainWndProc
//
//  Synopsis:   main window message filter
//
//  Effects:
//
//  Arguments:  hWnd
//              message
//              wParam
//              lParam
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     Allow running of single tests from menu
//              22-Mar-94 alexgo    added an edit window for displaying text
//                                  output.
//              07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef WIN32
LONG APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam)
#else
LONG FAR PASCAL _export MainWndProc(HWND hWnd, UINT message, WPARAM wParam,
                LPARAM lParam)
#endif

{
        //set global variables

        if( (message > WM_USER) && (message <= MAX_WM_USER) )
        {
                vApp.m_message  = message;
                vApp.m_wparam   = wParam;
                vApp.m_lparam   = lParam;
        }

        switch (message)
        {
        case WM_CREATE:
                //create the edit window

                vApp.m_hwndEdit = CreateWindow( "edit", NULL,
                        WS_CHILD | WS_VISIBLE | WS_HSCROLL |
                        WS_VSCROLL | WS_BORDER | ES_LEFT |
                        ES_MULTILINE | ES_NOHIDESEL | ES_AUTOHSCROLL |
                        ES_AUTOVSCROLL | ES_READONLY | ES_WANTRETURN,
                        0,0,0,0,
                        hWnd,(HMENU) EDITID, vApp.m_hinst, NULL );

                // Reset the error status

                vApp.m_fGotErrors = FALSE;

                // start the task stack running
                // note that if we are running interactive, and no
                // tasks were specified on the command line, nothing
                // will happen.

                PostMessage(hWnd, WM_TESTSTART, 0,0);
                break;

        case WM_SETFOCUS:
                SetFocus(vApp.m_hwndEdit);
                break;

        case WM_SIZE:
                MoveWindow( vApp.m_hwndEdit, 0, 0, LOWORD(lParam),
                        HIWORD(lParam), TRUE);
                break;

        case WM_DESTROY:
                PostQuitMessage(0);
                break;
        case WM_TESTEND:
                HandleTestEnd();
                break;
        case WM_TESTSCOMPLETED:
                HandleTestsCompleted();
                //if we are not in interactive mode, then
                //quit the app.
                if (!vApp.m_fInteractive)
                {
                        PostQuitMessage(0);
                }
                else
                {
                        //cleanup
                        vApp.Reset();
                }
                break;

        case WM_COMMAND:
                switch( wParam )
                {
                case IDM_EXIT:
                        SendMessage(hWnd, WM_CLOSE, 0, 0L);
                        break;
                case IDM_COPY:
                        SendMessage(vApp.m_hwndEdit, WM_COPY, 0, 0L);
                        break;
                case IDM_SAVE:
                        SaveToFile();
                        break;
                }

                //
                // if the user picked a test, run it
                // > 100 tests wouldn't fit on the menu anyway
                //

                if (wParam >= IDM_RUN_BASE && wParam < IDM_RUN_BASE + 100)
                {
                    vApp.m_TaskStack.Push(&vrgTaskList[wParam - IDM_RUN_BASE]);
                    vApp.m_TaskStack.PopAndExecute(NULL);
                }

                break;

        default:
                //test to see if it's a message the driver
                //may understand

                if( (message > WM_USER) && (message <= MAX_WM_USER)
                        && (!vApp.m_TaskStack.IsEmpty()) )
                {
                        vApp.m_TaskStack.PopAndExecute(NULL);
                }
                else
                {
                        return DefWindowProc(hWnd, message, wParam,
                                lParam);
                }
                break;
        }
        return (0);
}

//+-------------------------------------------------------------------------
//
//  Function:   InitApplication
//
//  Synopsis:   initializes and registers the application class
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-93 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;

    wc.style = 0;
    wc.lpfnWndProc = (WNDPROC) MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(hInstance, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  "OleTestMenu";
    wc.lpszClassName = "OleTestWClass";

    return (RegisterClass(&wc));
}

//+-------------------------------------------------------------------------
//
//  Function:   InitInstance
//
//  Synopsis:   creates the app window
//
//  Effects:
//
//  Arguments:  hInstance
//              nCmdShow
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//              09-Dec-94 MikeW     add tests to the run menu
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL InitInstance(
    HINSTANCE          hInstance,
    UINT             nCmdShow)
{
    int         nTask;
    HMENU       hMenu;

    vApp.m_hinst = hInstance;

    vApp.m_hwndMain = CreateWindow(
        "OleTestWClass",
        "OleTest Driver",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (!vApp.m_hwndMain)
        return (FALSE);

    hMenu = GetSubMenu(GetMenu(vApp.m_hwndMain), 2);
    if (!hMenu)
        return (FALSE);

    //
    // Add all of the tests to the "Run" menu
    //

    for (nTask = 0; vrgTaskList[nTask].szName != (LPSTR) 0; nTask++)
    {
        AppendMenu(hMenu,
                MF_STRING,
                IDM_RUN_BASE + nTask,
                vrgTaskList[nTask].szName);
    }

    ShowWindow(vApp.m_hwndMain, nCmdShow);
    UpdateWindow(vApp.m_hwndMain);
    return (TRUE);
}


//+-------------------------------------------------------------------------
//
//  Table:      regConfig
//
//  Synopsis:   Table of registry settings required to run OleTest.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-94 KentCe    Created.
//
//  Notes:      The registry template contains embedded "%s" to permit
//              the insertion of the full path of test binaries when the
//              registry is updated.
//
//              The registry template is passed to wsprintf as an argument
//              so verify that changes are wsprintf safe (ie, use %% when
//              you want a single %, etc).
//
//--------------------------------------------------------------------------

char * regConfig[] =
{
    ".ut1", "ProgID49",
    ".ut2", "ProgID48",
    ".ut3", "ProgID47",
    ".ut4", "ProgID50",
    "ProgID49", "test app 1",
    "ProgID49\\CLSID", "{99999999-0000-0008-C000-000000000049}",
    "ProgID48", "test app 2",
    "ProgID48\\CLSID", "{99999999-0000-0008-C000-000000000048}",
    "ProgID47", "test app 3",
    "ProgID47\\CLSID", "{99999999-0000-0008-C000-000000000047}",
    "ProgID50", "test app 4",
    "ProgID50\\CLSID", "{99999999-0000-0008-C000-000000000050}",
    "CLSID\\{00000009-0000-0008-C000-000000000047}", "BasicSrv",
    "CLSID\\{00000009-0000-0008-C000-000000000047}\\LocalServer32", "%s\\testsrv.exe",
    "CLSID\\{00000009-0000-0008-C000-000000000048}", "BasicBnd2",
    "CLSID\\{00000009-0000-0008-C000-000000000048}\\LocalServer32", "%s\\olesrv.exe",
    "CLSID\\{00000009-0000-0008-C000-000000000049}", "BasicBnd",
    "CLSID\\{00000009-0000-0008-C000-000000000049}\\InprocServer32", "%s\\oleimpl.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000048}", "BasicBnd2",
    "CLSID\\{99999999-0000-0008-C000-000000000048}\\LocalServer32", "%s\\olesrv.exe",
    "CLSID\\{99999999-0000-0008-C000-000000000049}", "BasicBnd",
    "CLSID\\{99999999-0000-0008-C000-000000000049}\\InprocServer32", "%s\\oleimpl.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000047}", "TestEmbed",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\InprocHandler32", "ole32.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\InprocServer32", "ole32.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\LocalServer32", "%s\\testsrv.exe",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\protocol\\StdFileEditing", "",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\protocol\\StdFileEditing\\server", "testsrv.exe",
    "CLSID\\{99999999-0000-0008-C000-000000000050}", "TestFail",
    "CLSID\\{99999999-0000-0008-C000-000000000050}\\LocalServer32", "%s\\fail.exe",
    "SIMPSVR", "Simple OLE 2.0 Server",
    "SIMPSVR\\protocol\\StdFileEditing\\server", "simpsvr.exe",
    "SIMPSVR\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "SIMPSVR\\protocol\\StdFileEditing\\verb\\1", "&Open",
    "SIMPSVR\\Insertable", "",
    "SIMPSVR\\CLSID", "{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}", "Simple OLE 2.0 Server",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\Insertable", "",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\MiscStatus", "0",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\DefaultIcon", "simpsvr.exe,0",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\AuxUserType\\2", "Simple Server",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\AuxUserType\\3", "Simple OLE 2.0 Server",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\Verb\\0", "&Play,0,2",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\Verb\\1", "&Open,0,2",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\LocalServer32", "%s\\simpsvr.exe",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\InprocHandler32", "ole32.dll",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\ProgID", "SIMPSVR",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\DataFormats\\GetSet\\0", "3,1,32,1",
    ".svr", "SIMPSVR",
    "SPSVR16", "Simple 16 Bit OLE 2.0 Server",
    "SPSVR16\\protocol\\StdFileEditing\\server", "spsvr16.exe",
    "SPSVR16\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "SPSVR16\\protocol\\StdFileEditing\\verb\\1", "&Open",
    "SPSVR16\\Insertable", "",
    "SPSVR16\\CLSID", "{9fb878d0-6f88-101b-bc65-00000b65c7a6}",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}", "Simple 16 Bit OLE 2.0 Server",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\Insertable", "",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\MiscStatus", "0",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\DefaultIcon", "spsvr16.exe,0",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\AuxUserType\\2", "Simple Server",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\AuxUserType\\3", "Simple 16 Bit OLE 2.0 Server",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\Verb\\0", "&Play,0,2",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\Verb\\1", "&Open,0,2",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\LocalServer", "%s\\spsvr16.exe",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\InprocHandler", "ole2.dll",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\ProgID", "SPSVR16",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\DataFormats\\GetSet\\0", "3,1,32,1",
    ".svr", "SPSVR16",
    "OLEOutline", "Ole 2.0 In-Place Server Outline",
    "OLEOutline\\CLSID", "{00000402-0000-0000-C000-000000000046}",
    "OLEOutline\\CurVer", "OLE2ISvrOtl",
    "OLEOutline\\CurVer\\Insertable", "",
    "OLE2SvrOutl", "Ole 2.0 Server Sample Outline",
    "OLE2SvrOutl\\CLSID", "{00000400-0000-0000-C000-000000000046}",
    "OLE2SvrOutl\\Insertable", "",
    "OLE2SvrOutl\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "OLE2SvrOutl\\protocol\\StdFileEditing\\server", "svroutl.exe",
    "OLE2SvrOutl\\Shell\\Print\\Command", "svroutl.exe %%1",
    "OLE2SvrOutl\\Shell\\Open\\Command", "svroutl.exe %%1",
    "CLSID\\{00000400-0000-0000-C000-000000000046}", "Ole 2.0 Server Sample Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\ProgID", "OLE2SvrOutl",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\LocalServer32", "%s\\svroutl.exe",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Verb\\0", "&Edit,0,2",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Insertable", "",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\AuxUserType\\2", "Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\AuxUserType\\3", "Ole 2.0 Outline Server",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DefaultIcon", "svroutl.exe,0",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\DefaultFile", "Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\0", "Outline,1,1,3",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\1", "1,1,1,3",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\2", "3,1,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\3", "3,4,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\MiscStatus", "512",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Conversion\\Readable\\Main", "Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Conversion\\Readwritable\\Main", "Outline",
    "OLE2CntrOutl", "Ole 2.0 Container Sample Outline",
    "OLE2CntrOutl\\Clsid", "{00000401-0000-0000-C000-000000000046}",
    "OLE2CntrOutl\\Shell\\Print\\Command", "cntroutl.exe %%1",
    "OLE2CntrOutl\\Shell\\Open\\Command", "cntroutl.exe %%1",
    "CLSID\\{00000401-0000-0000-C000-000000000046}", "Ole 2.0 Container Sample Outline",
    "CLSID\\{00000401-0000-0000-C000-000000000046}\\ProgID", "OLE2CntrOutl",
    "CLSID\\{00000401-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000401-0000-0000-C000-000000000046}\\LocalServer32", "%s\\cntroutl.exe",
    "OLE2ISvrOtl", "Ole 2.0 In-Place Server Outline",
    "OLE2ISvrOtl\\CLSID", "{00000402-0000-0000-C000-000000000046}",
    "OLE2ISvrOtl\\Insertable", "",
    "OLE2ISvrOtl\\protocol\\StdFileEditing\\verb\\1", "&Open",
    "OLE2ISvrOtl\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "OLE2ISvrOtl\\protocol\\StdFileEditing\\server", "isvrotl.exe",
    "OLE2ISvrOtl\\Shell\\Print\\Command", "isvrotl.exe %%1",
    "OLE2ISvrOtl\\Shell\\Open\\Command", "isvrotl.exe %%1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}", "Ole 2.0 In-Place Server Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\ProgID", "OLE2ISvrOtl",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\ProgID", "OLE2ISvrOtl",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\LocalServer32", "%s\\isvrotl.exe",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Verb\\1", "&Open,0,2",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Verb\\0", "&Edit,0,2",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Insertable", "",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\AuxUserType\\2", "Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\AuxUserType\\3", "Ole 2.0 In-Place Outline Server",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DefaultIcon", "isvrotl.exe,0",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\DefaultFile", "Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\0", "Outline,1,1,3",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\1", "1,1,1,3",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\2", "3,1,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\3", "3,4,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\MiscStatus", "512",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\MiscStatus\\1", "896",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Conversion\\Readable\\Main", "Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Conversion\\Readwritable\\Main", "Outline",
    "OLE2ICtrOtl", "Ole 2.0 In-Place Container Outline",
    "OLE2ICtrOtl\\Clsid", "{00000403-0000-0000-C000-000000000046}",
    "OLE2ICtrOtl\\Shell\\Print\\Command", "icntrotl.exe %%1",
    "OLE2ICtrOtl\\Shell\\Open\\Command", "icntrotl.exe %%1",
    ".olc", "OLE2ICtrOtl",
    "CLSID\\{00000403-0000-0000-C000-000000000046}", "Ole 2.0 In-Place Container Outline",
    "CLSID\\{00000403-0000-0000-C000-000000000046}\\ProgID", "OLE2ICtrOtl",
    "CLSID\\{00000403-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000403-0000-0000-C000-000000000046}\\LocalServer32", "%s\\icntrotl.exe",
    NULL
};


//+-------------------------------------------------------------------------
//
//  Function:   InitializeRegistry
//
//  Synopsis:   Initialize the registry for oletest.
//
//  Effects:
//
//  Arguments:  None.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-94 KentCe    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void InitializeRegistry( void )
{
    char szBuf[MAX_PATH * 2];
    char szPath[MAX_PATH];
    int  i;


    //
    //  Assume all the oletest components are in the current directory.
    //
    if (!GetCurrentDirectory(sizeof(szPath), szPath))
    {
        assert(0);
    }

    //
    //  Loop thru string key/value pairs and update the registry.
    //
    for (i = 0; regConfig[i] != NULL; i += 2)
    {
        //
        //  The registry template contains embedded "%s" to permit
        //  the insertion of the full path of test binaries.
        //
        wsprintf(szBuf, regConfig[i+1], szPath);

        if (RegSetValue(HKEY_CLASSES_ROOT, regConfig[i+0], REG_SZ,
                szBuf, strlen(szBuf)) != ERROR_SUCCESS)
        {
            assert(0);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   TestSetup
//
//  Synopsis:   process the command line and setup the tests that need to
//              be run.
//
//  Effects:
//
//  Arguments:  lpszCmdLine
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  We scan the command line for the following information
//
//              NULL or empty cmdline, assume running task 0
//                      (usually run all tasks)
//              otherwise scan for n numbers, adding each to the end of
//                      the stack (so the tasks are run in order).
//
//  History:    dd-mmm-yy Author    Comment
//              12-Dec-94 MikeW     restructured parse algorithm, added -? & l
//              07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TestSetup( LPSTR lpszCmdLine )
{
    LPSTR   pszArg;
    int     nTest, cTests;

    // initialize debugger options to nothing.

    vApp.m_pszDebuggerOption = "";

    //
    // count up the number of tests available
    //

    for (cTests = 0; vrgTaskList[cTests].szName != (LPSTR) 0; cTests++)
    {
        ;
    }

    //
    // make sure the registery is set up correctly.
    //

    InitializeRegistry();

    //
    // if the command line is empty, run all tests
    // (assumed to be task 0)
    //

    pszArg = strtok(lpszCmdLine, " ");

    if (NULL == pszArg)
    {
        vApp.m_TaskStack.Push(&vrgTaskList[0]);
        vApp.m_fInteractive = FALSE;
    }

    //
    // otherwise, look for options & test numbers
    //

    while (NULL != pszArg)
    {
        if ('-' == *pszArg)
        {
            while ('\0' != *(++pszArg))     // it's an option
            {
                switch (*pszArg)
                {
                case 'r':       // 'r' flag is obsolete
                    break;

		case 'R':
                    OutputString("Warning: 'R' flag to oletest is obsolete.\n");
                    vApp.m_fInteractive = FALSE;
                    vApp.m_TaskStack.Push(&vrgTaskList[0]);
                    break;

                case 'i':                           // run in interactive mode
                    vApp.m_fInteractive = TRUE;
                    break;

                case 'n':                           // start apps in debugger
                    vApp.m_fInteractive = TRUE;
                    vApp.m_pszDebuggerOption = "ntsd ";
                    break;

                case 'l':                           // list tests & test nums
                    ListAllTests();
                    vApp.m_fInteractive = TRUE;
                    break;

                case '?':                           // output the option list
                    PrintHelp();
                    vApp.m_fInteractive = TRUE;
                    break;
                }
            }
        }
        else    // it's not a option, maybe it's a test number
        {
            if (isdigit(*pszArg))
            {
                nTest = atoi(pszArg);

                if (nTest < 0 || nTest > cTests - 1)
                {
                    OutputString("Ignoring invalid test #%d", nTest);
                }
                else
                {
                    vApp.m_TaskStack.AddToEnd(&vrgTaskList[nTest]);
                }
            }
        }

        pszArg = strtok(NULL, " ");     // fetch the next argument
    }

    vApp.m_fpLog = fopen("clip.log", "w+");
    assert(vApp.m_fpLog);
}


//+-------------------------------------------------------------------------
//
//  Function:   ListAllTests
//
//  Synopsis:   List all available tests and the corresponding test number
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Iterate through vrgTaskList
//
//  History:    dd-mmm-yy Author    Comment
//              12-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

void ListAllTests()
{
    int     nTask;

    for (nTask = 0; vrgTaskList[nTask].szName != (LPSTR) 0; nTask++)
    {
        OutputString("%2d -- %s\r\n", nTask, vrgTaskList[nTask].szName);
    }

    OutputString("\r\n");
}


//+-------------------------------------------------------------------------
//
//  Function:   PrintHelp
//
//  Synopsis:   Print the program options & tests
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

void PrintHelp()
{
    OutputString("OleTest [options] [test numbers] -\r\n");
    OutputString("\r\n");
    OutputString("    -r  -  Autoregister test apps\r\n");
    OutputString("    -R  -  Autoregister and Run All Tests\r\n");
    OutputString("    -i  -  Run in interactive mode\r\n");
    OutputString("    -n  -  Run test apps using ntsd and run interactive\r\n");
    OutputString("    -l  -  List tests & test numbers and run interactive\r\n");
    OutputString("    -?  -  Print this help\r\n");
    OutputString("\r\n");

    ListAllTests();
}


//+-------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   main window procedure
//
//  Effects:
//
//  Arguments:  hInstance
//              hPrevInstance
//              lpCmdLine
//              nCmdShow
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
#ifdef WIN32
int APIENTRY WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
#else
int PASCAL WinMain(
        HANDLE hInstance,
        HANDLE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
#endif

{
        MSG             msg;

        if (!hPrevInstance)
        {
                if (!InitApplication(hInstance))
                {
                        return FALSE;
                }
        }

        if (!InitInstance(hInstance, nCmdShow))
        {
                return FALSE;
        }

        TestSetup(lpCmdLine);

        OleInitialize(NULL);

        while (GetMessage(&msg, NULL, 0, 0))
        {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
        }

        OleUninitialize();

        fclose(vApp.m_fpLog);
        return (msg.wParam);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\output.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	output.cpp
//
//  Contents:	String output functions for displaying text on the main
//		edit window
//
//  Classes:
//
//  Functions: 	OutputString
//		SaveToFile
//
//  History:    dd-mmm-yy Author    Comment
//		22-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include <commdlg.h>

#ifndef WIN32
#include <stdarg.h>
#endif

//
// handle to memory where the text is stored
//
// Please note this is really burfy (having all these globals).  But for
// the purposes of a simple driver app, it is the easiest.
//
static HGLOBAL	hText;		// handle to the Text
static ULONG	cbText;
static ULONG	iText;

//+-------------------------------------------------------------------------
//
//  Function:	OutputString
//
//  Synopsis:	Dumps the string in printf format to the screen
//
//  Effects:
//
//  Arguments:	[szFormat]	-- the format string
//		[...]		-- variable arguments
//
//  Requires:
//
//  Returns:	int, the number of characters written (returned by sprintf)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//
//--------------------------------------------------------------------------

int OutputString( char *szFormat, ... )
{
	LPSTR	psz;
	va_list	ap;
	int	cbWritten;

	va_start(ap, szFormat);

	if( !hText )
	{
		hText = GlobalAlloc( GMEM_MOVEABLE , 2048 );
		assert(hText);
		cbText = 2048;
	}

	// double the size of the array if we need to

	if( iText > cbText / 2 )
	{
		hText = GlobalReAlloc(hText, cbText * 2, GMEM_MOVEABLE );
		assert(hText);
		cbText *= 2;
	}

	psz = (LPSTR)GlobalLock(hText);

	assert(psz);

	cbWritten = wvsprintf( psz + iText, szFormat, ap);

	iText += cbWritten;

	va_end(ap);

	SetWindowText(vApp.m_hwndEdit, psz);

	GlobalUnlock(hText);


	return cbWritten;

}

//+-------------------------------------------------------------------------
//
//  Function: 	SaveToFile
//
//  Synopsis: 	Gets a filename from the user and save the text buffer into it
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void SaveToFile( void )
{
	char 		szFileName[MAX_PATH];
	OPENFILENAME	ofn;
	static char *	szFilter[] = { "Log Files (*.log)", "*.log",
				"All Files (*.*)", "*.*", ""};
	FILE *		fp;
	LPSTR		psz;


	memset(&ofn, 0, sizeof(OPENFILENAME));
	
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = vApp.m_hwndMain;
	ofn.lpstrFilter = szFilter[0];
	ofn.nFilterIndex = 0;
	
	szFileName[0] = '\0';
	
	ofn.lpstrFile = szFileName;
	ofn.nMaxFile = MAX_PATH;
	
	ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
	
	//
	// Get the file
	//
	
	if (GetSaveFileName(&ofn) == FALSE)
	{
		// user hit cancel
	       return;
	}

	// the 'b' specifies binary mode, so \n --> \r\n translations are
	// not done.
	if( !(fp = fopen( szFileName, "wb")) )
	{
		MessageBox( NULL, "Can't open file!", "OleTest Driver",
			MB_ICONEXCLAMATION );
		return;
	}

	psz = (LPSTR)GlobalLock(hText);

	assert(psz);

	fwrite(psz, iText, sizeof(char), fp);

	fclose(fp);

	GlobalUnlock(hText);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\letests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       letests.cpp
//
//  Contents:   upper layer tests
//
//  Classes:
//
//  Functions:  LETest1
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "letest.h"

// Test1 information
SLETestInfo letiInsertObjectTest1 = { "simpdnd", WM_TEST1 };

SLETestInfo letiInplaceTest1 = { "simpcntr", WM_TEST1 };
SLETestInfo letiOle1Test1 = { "simpdnd", WM_TEST2 };

// Test2 information
SLETestInfo letiInsertObjectTest2 = { "spdnd16", WM_TEST1 };

SLETestInfo letiOle1Test2 = { "spdnd16", WM_TEST2 };



//+-------------------------------------------------------------------------
//
//  Function:   LETestCallback
//
//  Synopsis:   generic callback function for running L&E tests.
//
//  Effects:
//
//  Arguments:  pvArg           -- the test message to send to the app
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Create the process and wait for it to finish.  The exit
//              status is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

void LETestCallback( void *pvArg )
{
        //the test app (simpdnd) should have just sent us a WM_TESTREG message.

        assert(vApp.m_message == WM_TESTREG);

        vApp.m_rgTesthwnd[0] = (HWND)vApp.m_wparam;

        //now tell the app to start the requested test
        OutputString( "Tell LETest to Start\r\n");

        PostMessage(vApp.m_rgTesthwnd[0], (UINT)pvArg, 0, 0);

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   LETest1
//
//  Synopsis:   Runs the app specified in the argument
//
//  Effects:
//
//  Arguments:  pvArg           -- unused
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Create the process and wait for it to finish.  The exit
//              status is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

void LETest1( void *pvArg )
{
        SLETestInfo *pleti = (SLETestInfo *) pvArg;

#ifdef WIN32

        PROCESS_INFORMATION     procinfo;
        static STARTUPINFO      startinfo;      //to make it all zero
        char szBuf[128];

        //initialize the command line

        sprintf(szBuf, "%s%s -driver %lu",
                       vApp.m_pszDebuggerOption,
                       pleti->pszPgm,
                       vApp.m_hwndMain);

        startinfo.cb = sizeof(startinfo);

        if( CreateProcess(NULL, szBuf, NULL, NULL, NULL, NULL, NULL,
                NULL, &startinfo, &procinfo) )
        {
                //simpdnd launched, stuff a callback function in the stack
                vApp.m_TaskStack.Push(LETestCallback,
                        (void *)((ULONG)pleti->dwMsgId));
        }
        else
        {
                vApp.m_wparam = TEST_FAILURE;
                vApp.m_lparam = (LPARAM)GetLastError();
                vApp.m_message = WM_TESTEND;

                HandleTestEnd();
        }

        return;
        
#else
	// 16bit Version!!
	
	vApp.m_wparam = TEST_SUCCESS;
	vApp.m_lparam = 0;
	vApp.m_message = WM_TESTEND;
	
	HandleTestEnd();
	
	return;
	
#endif // WIN32

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\output.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	output.h
//
//  Contents:	Declarations for String output functions.
//
//  Classes:
//
//  Functions:	OutputInitialize()
//		OutputString()
//
//  History:    dd-mmm-yy Author    Comment
// 		22-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _OUTPUT_H
#define _OUTPUT_H

int OutputString( char *szFormat, ... );
void SaveToFile( void );

#endif // !_OUTPUT_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\stack.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	stack.cpp	
//
//  Contents: 	Implementation of the TaskStack
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::TaskStack
//
//  Synopsis: 	Constructor
//
//  Arguments: 	
//
//  Returns:	void
//
//  History:    dd-mmm-yy Author    Comment
// 		06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

TaskStack::TaskStack( void )
{
	m_pNodes	= NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:	TaskStack::AddToEnd
//
//  Synopsis: 	adds a function and it's argument to the bottom of the stack
//
//  Effects:
//
//  Arguments:	ti	-- the task item to add to the end of the stack
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//  Notes:	The task item is copied into the stack.
//
//--------------------------------------------------------------------------

void TaskStack::AddToEnd( const TaskItem *pti )
{
	TaskNode **ppNode;
	TaskNode *pNode = new TaskNode;

	assert(pNode);

	pNode->ti = *pti;
	pNode->pNext = NULL;

	for( ppNode = &m_pNodes; *ppNode != NULL;
		ppNode = &(*ppNode)->pNext)
	{
		;
	}
	
	*ppNode = pNode;

	return;
}

//+-------------------------------------------------------------------------
//
//  Member:	TaskStack::AddToEnd
//
//  Synopsis: 	adds a function and it's argument to the bottom of the stack
//
//  Effects:
//
//  Arguments:	fnCall		-- the function to call
//		pvArg		-- the closure argument for the function
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::AddToEnd( void (*fnCall)(void *), void *pvArg)
{
	TaskItem ti	= vzTaskItem; 	//clear it to zero

	ti.fnCall 	= fnCall;
	ti.pvArg 	= pvArg;

	AddToEnd(&ti);
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Empty
//
//  Synopsis:	Empties the stack, ignoring the function call
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	NULL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Empty( void )
{
	while( m_pNodes )
	{
		Pop(NULL);
	}
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::IsEmpty
//
//  Synopsis:	returns TRUE if the stack is empty, false otherwise
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL TaskStack::IsEmpty(void)
{
	if( m_pNodes )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Pop
//
//  Synopsis:	Pops the stack, ignoring the function call
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	the task item that was popped.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Pop( TaskItem *pti )
{
	TaskNode *pTemp;

	if( m_pNodes )
	{
		if( pti )
		{
			*pti = m_pNodes->ti;
		}
		pTemp = m_pNodes;
		m_pNodes = m_pNodes->pNext;

		//now free the memory
		delete pTemp;
	}

	return;
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::PopAndExecute
//
//  Synopsis: 	pops the stack and executes the function call
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	the task item that was popped.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  Pop the stack and then execute the function call
//		in the just removed stack node.
//
//  History:    dd-mmm-yy Author    Comment
//	 	06-Feb-94 alexgo    author
//              09-Dec-94 MikeW     Added exception handling
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::PopAndExecute( TaskItem *pti )
{
	TaskItem ti;

	if( pti == NULL )
	{
		pti = &ti;
	}

	Pop(pti);

 	//if there's a function to execute, do it.
	//if the stack is empty, Pop will return a zero-filled TaskItem

	if( pti->fnCall )
	{
		if( pti->szName )
		{
			OutputString("Starting: %s\r\n", pti->szName);
		}
		//call the function

        __try
        {            
		    (*pti->fnCall)(pti->pvArg);
        }
        __except ((GetExceptionCode() == E_ABORT) 
                ? EXCEPTION_EXECUTE_HANDLER 
                : EXCEPTION_CONTINUE_SEARCH)
        {
            //
            // there was an assertion and the user hit abort
            //

            PostMessage(vApp.m_hwndMain, WM_TESTEND, TEST_FAILURE, 0);
        }
	}

	return;
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Push
//
//  Synopsis:	pushes a function onto the stack
//
//  Effects:
//
//  Arguments:	ti	-- the task item to push onto the stack
//
//  Requires:
//
//  Returns:  	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Push( const TaskItem *pti )
{
	TaskNode *pNode = new TaskNode;

	assert(pNode);

	pNode->ti = *pti;
	pNode->pNext = m_pNodes;
	m_pNodes = pNode;

	return;
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Push
//
//  Synopsis:	pushes a function onto the stack
//
//  Effects:
//
//  Arguments:	fnCall		-- the function to call
//		pvArg		-- the closure argument for the function
//
//  Requires:
//
//  Returns:  	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Push( void (*fnCall)(void *), void * pvArg)
{
	TaskItem ti = vzTaskItem;

	ti.fnCall = fnCall;
	ti.pvArg = pvArg;

	Push(&ti);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\task.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	task.h
//
//  Contents:	declarations for task-related functions and data structures
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jan-95 t-ScottH  added RunTestOnThread
//		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _TASK_H
#define _TASK_H

typedef struct TaskItem
{
	LPSTR	szName;
	void (*fnCall)(void *);
	void *pvArg;
} TaskItem;

// global list of all available tests
extern const TaskItem vrgTaskList[];
// global zero'ed task list
extern TaskItem vzTaskItem;

// generic callback function for test apps that register a window handle
void GenericRegCallback(void *);

// run the given api (which must be HRESULT api ( void ))
void RunApi(void *);

// runs the given app
void RunApp(void *);

// runs the app and inserts a callback function so the app can register
// its window handle for communication
void RunAppWithCallback(void *);

// runs the given test by sending a message to the currently running test
// app.
void RunTest(void *);

// runs all the tests currently built into the driver program
void RunAllTests(void *);

// run the given test function as a new thread
void    RunTestOnThread(void *pvArg);

// handles the test completion message
void HandleTestEnd(void);

// handles the tests completed message
void HandleTestsCompleted(void);

#endif //!_TASK_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf\idl\makefile.inc ===
CPP_CMD=cl

!if $(386)
CPP_CMD=cl386
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

iperf.h: iperf.idl
      midl iperf.idl               \
          -Zp8                     \
          -I$(INCLUDES)            \
          -ms_ext		   \
          -c_ext		   \
          -out ..\proxy		   \
          -header ..\idl\iperf.h   \
          -iid ..\perfuuid\iperf_i.c   \
          $(C_DEFINES)             \
	  -cpp_cmd $(CPP_CMD)	   \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"

#
# This target compiles all .idl files into their corresponding _?.c?? and
# .h components
#
allidl:   iperf.h


clean:
          erase iperf.h  >NUL 2>NUL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\stack.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	stack.h
//
//  Contents:	The class declaration of the task stack.
//
//  Classes: 	TaskStack
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-93 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _STACK_H
#define _STACK_H

typedef struct TaskNode
{
	TaskItem ti;
	struct TaskNode *pNext;
} TaskNode;

//+-------------------------------------------------------------------------
//
//  Class:	TaskStack
//
//  Purpose: 	Stores the task list of tests to be run.
//
//  History:    dd-mmm-yy Author    Comment
// 		06-Feb-93 alexgo    author
//
//  Notes:	TaskItems are passed in and returned from methods
//		as structure copies.  This is done to simply memory
//		management (since the overriding design goal of the
//		driver app is simplicity over efficiency).
//
//--------------------------------------------------------------------------

class TaskStack
{
public:
	TaskStack( void );	//constructor

 	void AddToEnd( void (*)(void *), void *);
	void AddToEnd( const TaskItem *);
	void Empty(void);
	BOOL IsEmpty(void);
	void Pop( TaskItem * );
	void PopAndExecute( TaskItem * );
	void Push( void (*)(void *), void *);
	void Push( const TaskItem *);


private:
	TaskNode	*m_pNodes;
};

#endif	//!_STACK_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\utils.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	utils.cpp
//
//  Contents: 	various utility functions for oletest
//
//  Classes:
//
//  Functions:	DumpFormatetc
//
//  History:    dd-mmm-yy Author    Comment
//		11-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"


//+-------------------------------------------------------------------------
//
//  Function: 	DumpFormatetc
//
//  Synopsis: 	prints the contents of the formatetc to the given file
//
//  Effects:
//
//  Arguments: 	[pformatetc]	-- the formatetc
//		[fp]		-- the file pointer
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		11-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpFormatetc( FORMATETC *pformatetc, FILE *fp)
{
	char szBuf[256];

	fprintf(fp, "\n\n");

	// clipboard format
	GetClipboardFormatName(pformatetc->cfFormat, szBuf, sizeof(szBuf));
	fprintf(fp, "cfFormat:  %s\n", szBuf);

	// target device
	fprintf(fp, "ptd:       %p\n", pformatetc->ptd);

	// aspect
	if( pformatetc->dwAspect == DVASPECT_CONTENT )
	{
		sprintf(szBuf, "DVASPECT_CONTENT");
	}
	else if( pformatetc->dwAspect == DVASPECT_ICON )
	{
		sprintf(szBuf, "DVASPECT_ICON");
	}
	else if( pformatetc->dwAspect == DVASPECT_THUMBNAIL )
	{
		sprintf(szBuf, "DVASPECT_THUMBNAIL");
	}
	else if( pformatetc->dwAspect == DVASPECT_DOCPRINT )
	{
		sprintf(szBuf, "DVASPECT_DOCPRINT");
	}
	else
	{
		sprintf(szBuf, "UNKNOWN ASPECT");
	}

	fprintf(fp, "dwAspect:  %s\n", szBuf);

	// lindex

	fprintf(fp, "lindex:    %lx\n", pformatetc->lindex);

	// medium

	szBuf[0] = '\0';

	if( pformatetc->tymed & TYMED_HGLOBAL )	
	{
		strcat(szBuf, "TYMED_HGLOBAL ");
	}

	if( pformatetc->tymed & TYMED_FILE )
	{
		strcat(szBuf, "TYMED_FILE");
	}

	if( pformatetc->tymed & TYMED_ISTREAM )
	{
		strcat(szBuf, "TYMED_ISTREAM");
	}

	if( pformatetc->tymed & TYMED_ISTORAGE )
	{
		strcat(szBuf, "TYMED_ISTORAGE");
	}

	if( pformatetc->tymed & TYMED_GDI )
	{
		strcat(szBuf, "TYMED_GDI");
	}

	if( pformatetc->tymed & TYMED_MFPICT )
	{
		strcat(szBuf, "TYMED_MFPICT");
	}

	// TYMED_EMFPICT (not in 16bit)
	if( (ULONG)pformatetc->tymed & (ULONG)64L )
	{
		strcat(szBuf, "TYMED_ENHMF");
	}

	fprintf(fp, "tymed:     %s\n\n", szBuf);
}
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\task.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       task.cpp
//
//  Contents:   The global task list and helper function implementations
//
//  Classes:
//
//  Functions:  HandleTestEnd
//              RunAllTests
//              RunApp
//              RunTestOnThread
//
//  History:    dd-mmm-yy Author    Comment
//              06-Jan-95 t-scotth  added apartment thread test and RunTestOnThread
//              06-Feb-94 alexgo    author
//
//  Notes:
//              Folks adding new tests will need to insert their test
//              into the global array.
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "cotest.h"
#include "letest.h"
#include "attest.h"

// global, zero'ed task item
TaskItem vzTaskItem;

// the global task list array.
// Multi-test entries go first, followed by individual tests.

#ifdef WIN32

const TaskItem vrgTaskList[] =
{
        // the constant should be the index at which individual tests
        // begin.  RunAllTests will run every test in this list after
        // that index.
        { "Run All Tests", RunAllTests, (void *)2},
        // the constant below should be the index at which individual
        // upper layer unit tests exist.  All tests at that index and
        // beyond will be run
        { "Run All Upper Layer Tests", RunAllTests, (void *)5 },
        { "OleBind", RunApp, (void *)"olebind.exe"},
        { "Threads", RunApi, (void *) ThreadUnitTest },
        { "Storage DRT", RunApp, (void *)"stgdrt.exe"},
        { "LE: Insert Object Test 1", LETest1, &letiInsertObjectTest1 },
        { "LE: Clipboard Test 1", RunApi, (void *)LEClipTest1},
        { "LE: Clipboard Test 2 (clipboard data object)", RunApi,
                (void *)LEClipTest2 },
        { "LE: Inplace Test 1", LETest1, &letiInplaceTest1 },
        { "LE: Data Advise Holder Test", RunApi,
                (void *) LEDataAdviseHolderTest},
        { "LE: OLE Advise Holder Test", RunApi, (void *) LEOleAdviseHolderTest},
	{ "LE: OLE1 Clipboard Test 1", RunApi, (void *)LEOle1ClipTest1},
        { "LE: Insert Object Test 2", LETest1, &letiInsertObjectTest2 },
	{ "LE: OLE1 Clipboard Test 2", LEOle1ClipTest2, NULL },
	{ "LE: OleQueryCreateFromData Test 1", RunApi,
		(void *)TestOleQueryCreateFromDataMFCHack },
        { "LE: Apartment Thread Test", RunTestOnThread, (void *)ATTest },
	{ 0, 0, 0 }
};

#else

// Win16 tests

const TaskItem vrgTaskList[] =
{
        // the constant should be the index at which individual tests
        // begin.  RunAllTests will run every test in this list after
        // that index.
        { "Run All Tests", RunAllTests, (void *)1},	
        { "LE: Clipboard Test 1", RunApi, (void *)LEClipTest1},
        { "LE: Clipboard Test 2 (clipboard data object)", RunApi,
                (void *)LEClipTest2 },
	{ "LE: OLE1 Clipboard Test 1", RunApi, (void *)LEOle1ClipTest1},
	{ 0, 0, 0 }
};

#endif
	


//+-------------------------------------------------------------------------
//
//  Function:   HandleTestEnd
//
//  Synopsis:   Handles processing for the WM_TESTEND message.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  execute the next task in the task stack or sends
//              a TESTSCOMPLETED message back the message queue
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//              13-Dec-94 MikeW     Allow testing to continue after failures
//
//  Notes:      vApp must be initialized correctly for this function to
//              work properly.
//
//              BUGBUG::Need to add output routines in here.
//
//--------------------------------------------------------------------------
void HandleTestEnd( void )
{
        assert(vApp.m_message == WM_TESTEND);

        switch( vApp.m_wparam )
        {
                case TEST_UNKNOWN:
                        //we usually get this message from a test run
                        //by RunApp (i.e. one that does not communicate
                        //with us via windows messages).  We'll check
                        //the exit code and decide what to do.

                        if( vApp.m_lparam != 0 )
                        {
                                //presumably an error
                                OutputString("Test End, Status Unknown "
                                        "( %lx )\r\n\r\n", vApp.m_lparam);

                                vApp.m_fGotErrors = TRUE;
                                break;
                        }
                        // otherwise we fall through to the success case.
                case TEST_SUCCESS:
                        OutputString("Test Success ( %lx )!\r\n\r\n",
                                vApp.m_lparam);
                        break;

                case TEST_FAILURE:
                        OutputString("Test FAILED! ( %lx )\r\n\r\n", vApp.m_lparam);
                        vApp.m_fGotErrors = TRUE;
                        break;

                default:
                        assert(0);      //we should never get here
                        break;
        }

        vApp.Reset();

        //
        // Now check to see if there are any more tests
        //

        while (!vApp.m_TaskStack.IsEmpty())
        {
            TaskItem    ti;

            vApp.m_TaskStack.Pop(&ti);

            if (ti.szName != (LPSTR) 0)
            {
                vApp.m_TaskStack.Push(&ti);
                break;
            }
        }


        if (vApp.m_TaskStack.IsEmpty())
        {
                PostMessage(vApp.m_hwndMain,
                        WM_TESTSCOMPLETED,
                        vApp.m_wparam, vApp.m_lparam);
        }
        else
        {
                //if the stack is not empty, run
                //the next task
                PostMessage(vApp.m_hwndMain,
                        WM_TESTSTART,
                        0, 0);
        }

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   HandleTestsCompleted
//
//  Synopsis:   Handles processing for the WM_TESTSCOMPLETED message.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:      vApp must be initialized correctly for this function to
//              work properly.
//
//              BUGBUG::Need to add more output routines in here.
//
//--------------------------------------------------------------------------
void HandleTestsCompleted( void )
{
        char szBuf[128];

        assert(vApp.m_message == WM_TESTSCOMPLETED);

        //temporary output

        switch(vApp.m_fGotErrors)
        {
                case FALSE:
                        OutputString("Tests PASSED!!\n");
                        break;
                case TRUE:
                        sprintf(szBuf, "Tests FAILED, code %lx",
                                vApp.m_lparam);
                        MessageBox(vApp.m_hwndMain, szBuf, "Ole Test Driver",
                                MB_ICONEXCLAMATION | MB_OK);
                        break;
                default:
                        assert(0);
        }

        //
        // Reset the got error status
        //

        vApp.m_fGotErrors = FALSE;

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunAllTests
//
//  Synopsis:   Runs all the individual tests in the global list
//
//  Effects:
//
//  Arguments:  pvArg           -- the index at which individual tests
//                                 start in the global list.
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:
//              Tests will be run in the order they appear in the global
//              list.
//
//--------------------------------------------------------------------------

void RunAllTests( void *pvArg )
{
        ULONG index = (ULONG)pvArg;
        ULONG i;

        //find the number of tasks in the list (so we can push
        //them in reverse order).

        for (i = 0; vrgTaskList[i].szName != 0; i++ )
        {
                ;
        }

        assert( i > 1 );

        //now push the tasks onto the stack in reverse order.

        for (i--; i >= index; i-- )
        {
                vApp.m_TaskStack.Push(vrgTaskList + i);
        }

        //start the first one.

        vApp.m_TaskStack.PopAndExecute(NULL);

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunApi
//
//  Synopsis:   Runs the specified Api
//
//  Effects:
//
//  Arguments:  [pvArg] -- the api to run
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void RunApi( void *pvArg )
{
        HRESULT         hresult;


        hresult = (*((HRESULT (*)(void))pvArg))();

        vApp.Reset();
        vApp.m_wparam = (hresult == NOERROR) ? TEST_SUCCESS : TEST_FAILURE;
        vApp.m_lparam = (LPARAM)hresult;
        vApp.m_message = WM_TESTEND;

        HandleTestEnd();
}

//+-------------------------------------------------------------------------
//
//  Function:   RunApp
//
//  Synopsis:   Runs the app specified in the argument
//
//  Effects:
//
//  Arguments:  pvArg           -- a string with the app to execute
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Create the process and wait for it to finish.  The exit
//              status is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void RunApp( void *pvArg )
{
        WPARAM                  wparam = 0;
        DWORD                   error = 0;

#ifdef WIN32

       	PROCESS_INFORMATION     procinfo;
        static STARTUPINFO      startinfo;      //to make it all zero

        assert(pvArg);  //should be a valid ANSI string.

        startinfo.cb = sizeof(startinfo);

        if( CreateProcess(NULL, (LPTSTR)pvArg, NULL, NULL, NULL, NULL, NULL,
                NULL, &startinfo, &procinfo) )
        {
                //the process started, now wait for it to finish.
                WaitForSingleObject(procinfo.hProcess, INFINITE);

                //now get the return code of the process.

                GetExitCodeProcess(procinfo.hProcess, &error);
                wparam = TEST_UNKNOWN;
        }
        else
        {
                wparam = TEST_FAILURE;
                error = GetLastError();
        }

#endif // WIN32

        // since there will be no WM_TESTEND message, we must do the
        // test end processing ourselves.
        vApp.Reset();
        vApp.m_wparam = wparam;
        vApp.m_lparam = error;
        vApp.m_message = WM_TESTEND;

        HandleTestEnd();


        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunTestOnThread
//
//  Synopsis:   creates a thread to run a test function
//
//  Effects:    creates a new thread
//
//  Arguments:  [pvArg] -- a function pointer to the test function
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
void RunTestOnThread(void *pvArg)
{
    HANDLE      hMainTestThread;
    DWORD       dwThreadId = 0;

    hMainTestThread = CreateThread(
                NULL,                                   // security attributes
                0,                                      // stack size (default)
                (LPTHREAD_START_ROUTINE)pvArg,          // address of thread function
                NULL,                                   // arguments of thread function
                0,                                      // creation flags
                &dwThreadId );                          // address of new thread ID

    assert(hMainTestThread);

    CloseHandle(hMainTestThread);

    return;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\utils.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	utils.h
//
//  Contents:	declarations for utility functions
//
//  Classes:
//
//  Functions:	DumpFormatetc
//
//  History:    dd-mmm-yy Author    Comment
// 		11-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _UTILS_H

void DumpFormatetc(FORMATETC *pformatetc, FILE *fp);

#endif // _UTILS_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oletest\uthread.cpp ===
//+-------------------------------------------------------------------
//
//  File:       uthread.cpp
//
//  Contents:   Unit test for various OLE threading model features
//
//  Classes:    SSTParamBlock
//              SSTParamBlock
//              SBTParamBlock
//
//  Functions:  CreateTestThread
//              VerifyTestObject
//              CheckForDllExistence
//              GetDllDirectory
//              SetRegForDll
//              SetSingleThreadRegEntry
//              SetAptThreadRegEntry
//              SetBothThreadRegEntry
//              SingleThreadTestThread
//              AptTestThread
//              BothTestThread
//              SetUpRegistry
//              TestSingleThread
//              TestAptThread
//              TestBothDll
//              TestFreeAllLibraries
//              ThreadUnitTest
//
//  History:    31-Oct-94   Ricksa
//
//--------------------------------------------------------------------
#include    <windows.h>
#include    <ole2.h>
#include    <uthread.h>
#include    <cotest.h>

// Test single threaded DLL - all operations s/b executed on the main thread.
// Pointers between threads s/b different. Test loading class object from
// different than the main thread.

// Test apartment model - all operations should occur on the thread the
// object was created on. This should also test the helper APIs. Pointers
// between threads s/b different. This tests helper APIs.

// Both model DLL. We want to make sure that the marshaling works between
// threads so that you get the same pointer. This tests new marshal context.

// Test Free Unused Libraries from non-main thread. Test FreeUnused libraries
// from main thread.



//+-------------------------------------------------------------------------
//
//  Class:      SSTParamBlock
//
//  Purpose:    Parameter block for single threaded dll test.
//
//  Interface:
//
//  History:    01-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SSTParamBlock
{
    HANDLE              hEvent;
    BOOL                fResult;
    IClassFactory *     pcf;
};




//+-------------------------------------------------------------------------
//
//  Class:      SSTParamBlock
//
//  Purpose:    Parameter block for apt model threaded dll test.
//
//  Interface:
//
//  History:    01-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SATParamBlock
{
    HANDLE              hEvent;
    BOOL                fResult;
    IClassFactory *     pcf;
    IStream *           pstrm;
};




//+-------------------------------------------------------------------------
//
//  Class:      SBTParamBlock
//
//  Purpose:    Parameter block for both model dll test.
//
//  Interface:
//
//  History:    02-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SBTParamBlock
{
    HANDLE              hEvent;
    BOOL                fResult;
    IClassFactory *     pcf;
    IStream *           pstrm;
};




const TCHAR *pszRegValThreadModel = TEXT("ThreadingModel");
const TCHAR *pszApartmentModel = TEXT("Apartment");
const TCHAR *pszBoth = TEXT("Both");

//+-------------------------------------------------------------------
//
//  Function:   ThreadWaitForEvent, private
//
//  Synopsis:   Process messages until event becomes signaled
//
//  Arguments:  [lphObject] - handle to become signaled
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
void ThreadWaitForEvent(HANDLE hObject)
{
    // message loop lasts until we get a WM_QUIT message
    // upon which we shall return from the function
    while (TRUE)
    {
        // wait for any message sent or posted to this queue
        // or for one of the passed handles to become signaled
        DWORD result = MsgWaitForMultipleObjects(1, &hObject,
            FALSE, INFINITE, QS_ALLINPUT);

        // result tells us the type of event we have:
        // a message or a signaled handle

        // if there are one or more messages in the queue ...
        if (result == (WAIT_OBJECT_0 + 1))
        {
            // block-local variable
            MSG msg;

            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {

                // if it's a quit message we're out of here
                if (msg.message == WM_QUIT)
                {
                    return;
                }

                // otherwise dispatch it
                DispatchMessage(&msg);

            }

            continue;
        }

        // Event got signaled so we are done.
        break;
    }

}



//+-------------------------------------------------------------------
//
//  Function:   CreateTestThread, private
//
//  Synopsis:   Create a test thread in standard way
//
//  Arguments:  [lpStartAddr] - start routine address
//              [pvThreadArg] - argument to pass to the thread
//
//  Returns:    TRUE - Thread created successfully
//              FALSE - Thread could not be created.
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL CreateTestThread(
    LPTHREAD_START_ROUTINE lpStartAddr,
    void *pvThreadArg)
{
    // Where to put the thread ID that we don't care about
    DWORD dwThreadId;

    // Create thread to load single threaded object
    HANDLE hThread = CreateThread(
        NULL,                       // Default security descriptor
        0,                          // Default stack
        lpStartAddr,                // Start routine
        pvThreadArg,                // Parameters to pass to the thread
        0,                          // Thread runs immediately after creation
        &dwThreadId);               // Where to return thread id (unused).

    CloseHandle(hThread);

    return hThread != NULL;
}



//+-------------------------------------------------------------------
//
//  Function:   VerifyTestObject, private
//
//  Synopsis:   Create a test DLL object in standard way
//
//  Arguments:  [pcf] - start routine address
//              [rclsid] - clsid to check
//
//  Returns:    TRUE - Object behaved as expected
//              FALSE - Object did not behave
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL VerifyTestObject(
    IClassFactory *pcf,
    REFCLSID rclsid)
{
    // Result from test
    BOOL fResult = FALSE;

    // Pointer to unknown for the object
    IUnknown *punk = NULL;

    // Pointer to IPersist interface
    IPersist *pIPersist = NULL;

    // Create an instance of an object
    if (pcf->CreateInstance(NULL, IID_IUnknown, (void **) &punk) == NOERROR)
    {
        // Do a QI to confirm object behaves correctly
        if (punk->QueryInterface(IID_IPersist, (void **) &pIPersist) == NOERROR)
        {
            CLSID clsidTest;

            // Make sure we can actually call through to the proxy object.
            if ((pIPersist->GetClassID(&clsidTest) == NOERROR)
                && IsEqualCLSID(clsidTest, rclsid))
            {
                fResult = TRUE;
            }
        }
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    if (pIPersist != NULL)
    {
        pIPersist->Release();
    }

    return fResult;
}





//+-------------------------------------------------------------------
//
//  Function:   GetFullDllName, private
//
//  Synopsis:   Get the directory for the registration for the test.
//
//  Arguments:  [pszDllName] - DLL name
//              [pszFullDllName] - output buffer for DLL path
//
//  Returns:    TRUE - we could get the path for the DLL
//              FALSE - we couldn't figure out what to use.
//
//  History:    31-Oct-94   Ricksa       Created
//
//  Notes:
//
//--------------------------------------------------------------------
BOOL GetFullDllName(const TCHAR *pszDllName, TCHAR *pszFullDllName)
{
    // Use windows to tell us what DLL we would load.
    HINSTANCE hinstDll = LoadLibraryEx(pszDllName, NULL,
        DONT_RESOLVE_DLL_REFERENCES | LOAD_WITH_ALTERED_SEARCH_PATH);

    if (hinstDll == NULL)
    {
        // We could not find the DLL so there isn't much purpose in
        // continuing the test.
        MessageBox(NULL, TEXT("LoadLibraryEx Failed!"),
            TEXT("FATAL ERROR"), MB_OK);
        return FALSE;
    }

    // Get the DLLs path name
    if (!GetModuleFileName(hinstDll, pszFullDllName, MAX_PATH))
    {
        // How can this fail?? -- anyway we better tell someone.
        MessageBox(NULL, TEXT("Threading Test GetModuleFileName Failed!"),
            TEXT("FATAL ERROR"), MB_OK);
        return FALSE;
    }

    FreeLibrary(hinstDll);

    return TRUE;
}



//+-------------------------------------------------------------------
//
//  Function:   SetRegForDll, private
//
//  Synopsis:   Set registry entry for a DLL
//
//  Arguments:  [rclsid] - clsid for reg entry
//              [pszDir] - directory for DLL path
//              [pszDllName] - name to use for DLL
//              [pszThreadModel] - threading model can be NULL.
//
//  Returns:    TRUE - Registry entry set successfully.
//              FALSE - Registry entry set successfully.
//
//  History:    01-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL SetRegForDll(
    REFCLSID rclsid,
    const TCHAR *pszDllName,
    const TCHAR *pszThreadModel)
{
    // Result returned by function
    BOOL fResult = FALSE;

    // String buffer used for various purposes
    TCHAR aszWkBuf[MAX_PATH];

    // Key to class
    HKEY hKeyClass = NULL;

    // Key to DLL entry
    HKEY hKeyDll = NULL;

    // Build clsid registry key
    wsprintf(aszWkBuf,
        TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
        rclsid.Data1, rclsid.Data2, rclsid.Data3,
        rclsid.Data4[0], rclsid.Data4[1],
        rclsid.Data4[2], rclsid.Data4[3],
        rclsid.Data4[4], rclsid.Data4[5],
        rclsid.Data4[6], rclsid.Data4[7]);

    // Create the key for the class
    if (ERROR_SUCCESS != RegCreateKey(HKEY_CLASSES_ROOT, aszWkBuf, &hKeyClass))
    {
        goto SetSingleThreadRegEntryExit;
    }

    // Create the key for the DLL

    if (ERROR_SUCCESS != RegCreateKey(hKeyClass, TEXT("InprocServer32"),
        &hKeyDll))
    {
        goto SetSingleThreadRegEntryExit;
    }

    // Build the DLL name
    if (!GetFullDllName(pszDllName, &aszWkBuf[0]))
    {
        goto SetSingleThreadRegEntryExit;
    }

    OutputDebugString(&aszWkBuf[0]);

    // Set the value for the DLL name
    if (ERROR_SUCCESS != RegSetValue(hKeyDll, NULL, REG_SZ, aszWkBuf,
        lstrlen(aszWkBuf)))
    {
        goto SetSingleThreadRegEntryExit;
    }

    // Set the threading model if there is one
    if (pszThreadModel != NULL)
    {
        // Set the value for the DLL name
        if (ERROR_SUCCESS != RegSetValueEx(hKeyDll, pszRegValThreadModel, 0,
            REG_SZ, (const unsigned char*) pszThreadModel,
                lstrlen(pszThreadModel) + 1))
        {
            goto SetSingleThreadRegEntryExit;
        }
    }

    fResult = TRUE;

SetSingleThreadRegEntryExit:

    if (hKeyClass != NULL)
    {
        RegCloseKey(hKeyClass);
    }

    if (hKeyDll != NULL)
    {
        RegCloseKey(hKeyDll);
    }

    if (!fResult)
    {
        wsprintf(aszWkBuf, TEXT("Registry Setup For %s Failed"), pszDllName);

        MessageBox(NULL, aszWkBuf, TEXT("FATAL ERROR"), MB_OK);
    }

    return fResult;
}



//+-------------------------------------------------------------------
//
//  Function:   SingleThreadTestThread, private
//
//  Synopsis:   Verify single threaded object call correctly from non
//              main thread.
//
//  Arguments:  [pvCtrlData] - control data for the thread
//
//  Returns:    0 - interesting values returned through pvCtrlData.
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
DWORD SingleThreadTestThread(void *pvCtrlData)
{
    // Data shared with main thread
    SSTParamBlock *psstp = (SSTParamBlock *) pvCtrlData;

    psstp->fResult = FALSE;

    // Local class factory object.
    IClassFactory *pcf = NULL;

    // IUnknown ptrs used for multiple purposes
    IUnknown *punk = NULL;

    // Initialize thread
    if (CoInitialize(NULL) != NOERROR)
    {
        goto SingleThreadTestThreadExit;
    }

    // Get the class object
    if (CoGetClassObject(clsidSingleThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &pcf) != NOERROR)
    {
        goto SingleThreadTestThreadExit;
    }

    // Make sure main thread's ptr is not the same as this thread's ptr.
    if (pcf == psstp->pcf)
    {
        goto SingleThreadTestThreadExit;
    }

    // Confirm that class object is a proxy
    if (pcf->QueryInterface(IID_IProxyManager, (void **) &punk) == NOERROR)
    {
        // Verify that we can play with an object.
        psstp->fResult = VerifyTestObject(pcf, clsidSingleThreadedDll);
    }

SingleThreadTestThreadExit:

    if (pcf != NULL)
    {
        pcf->Release();
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    // Exit the thread.
    SetEvent(psstp->hEvent);

    return 0;
}




//+-------------------------------------------------------------------
//
//  Function:   AptTestThread, private
//
//  Synopsis:   Verify apt threaded object call correctly from thread
//              if was not created on.
//
//  Arguments:  [pvCtrlData] - control data for the thread
//
//  Returns:    0 - interesting values returned through pvCtrlData.
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
DWORD AptTestThread(void *pvCtrlData)
{
    // Data shared with main thread
    SATParamBlock *psatpb = (SATParamBlock *) pvCtrlData;

    psatpb->fResult = FALSE;

    // Class factory object unmarshaled from other thread.
    IClassFactory *pcfUnmarshal = NULL;

    // Class factory gotten from this thread
    IClassFactory *pcfThisThread = NULL;

    // IUnknown ptrs used for multiple purposes
    IUnknown *punk = NULL;

    // Initialize thread
    if (CoInitialize(NULL) != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Get the class object from the marshaled stream
    if (CoGetInterfaceAndReleaseStream(psatpb->pstrm, IID_IClassFactory,
        (void **) &pcfUnmarshal) != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Caller doesn't have to release this now.
    psatpb->pstrm = NULL;

    // Make sure main thread's ptr is not the same as this thread's ptr.
    if (pcfUnmarshal == psatpb->pcf)
    {
        goto AptTestThreadExit;
    }

    // Confirm that class object is a proxy
    if (pcfUnmarshal->QueryInterface(IID_IProxyManager, (void **) &punk)
        != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Release the interface we got back and NULL it let the exit routine
    // known that it does not have to clean this object up.
    punk->Release();
    punk = NULL;

    if (!VerifyTestObject(pcfUnmarshal, clsidAptThreadedDll))
    {
        goto AptTestThreadExit;
    }

    // Get the class factory for this thread
    if (CoGetClassObject(clsidAptThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &pcfThisThread) != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Make sure that it isn't the same as the one we unmarshaled
    if (pcfUnmarshal == pcfThisThread)
    {
        goto AptTestThreadExit;
    }

    // Make sure the one we got for this not a proxy.
    if (pcfThisThread->QueryInterface(IID_IProxyManager, (void **) &punk)
        != NOERROR)
    {
        psatpb->fResult = VerifyTestObject(pcfThisThread, clsidAptThreadedDll);
    }

AptTestThreadExit:

    if (pcfUnmarshal != NULL)
    {
        pcfUnmarshal->Release();
    }

    if (pcfThisThread != NULL)
    {
        pcfThisThread->Release();
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    // Exit the thread.
    SetEvent(psatpb->hEvent);

    return 0;
}




//+-------------------------------------------------------------------
//
//  Function:   BothTestThread, private
//
//  Synopsis:   Verify a DLL that supports both models is marshaled
//              correctly.
//
//  Arguments:  [pvCtrlData] - control data for the thread
//
//  Returns:    0 - interesting values returned through pvCtrlData.
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
DWORD BothTestThread(void *pvCtrlData)
{
    // Data shared with main thread
    SBTParamBlock *psbtpb = (SBTParamBlock *) pvCtrlData;

    psbtpb->fResult = FALSE;

    // Class factory object unmarshaled from other thread.
    IClassFactory *pcfUnmarshal = NULL;

    // IUnknown ptrs used for multiple purposes
    IUnknown *punk = NULL;
    IUnknown *pIPersist = NULL;

    // Initialize thread
    if (CoInitialize(NULL) != NOERROR)
    {
        goto BothTestThreadExit;
    }

    // Get the class object from the marshaled stream
    if (CoGetInterfaceAndReleaseStream(psbtpb->pstrm, IID_IClassFactory,
        (void **) &pcfUnmarshal) != NOERROR)
    {
        goto BothTestThreadExit;
    }

    // Caller doesn't have to release this now.
    psbtpb->pstrm = NULL;

    // Make sure main thread's ptr is not the same as this thread's ptr.
    if (pcfUnmarshal != psbtpb->pcf)
    {
        goto BothTestThreadExit;
    }

    // Confirm that class object is a proxy
    if (pcfUnmarshal->QueryInterface(IID_IProxyManager, (void **) &punk)
        != NOERROR)
    {
        // Make sure object created by the class works as expected
        psbtpb->fResult = VerifyTestObject(pcfUnmarshal, clsidBothThreadedDll);
    }

BothTestThreadExit:

    if (pcfUnmarshal != NULL)
    {
        pcfUnmarshal->Release();
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    // Exit the thread.
    SetEvent(psbtpb->hEvent);

    return 0;
}




//+-------------------------------------------------------------------
//
//  Function:   SetUpRegistry, private
//
//  Synopsis:   Make sure registry is set up appropriately for the test
//
//  Returns:    TRUE - Registry set up successfully
//              FALSE - Registry could not be set up
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL SetUpRegistry(void)
{
    BOOL fRet = FALSE;

    // Update the registry with the correct information
    fRet = SetRegForDll(clsidSingleThreadedDll, pszSingleThreadedDll, NULL)
        && SetRegForDll(clsidAptThreadedDll, pszAptThreadedDll,
                pszApartmentModel)
        && SetRegForDll(clsidBothThreadedDll, pszBothThreadedDll, pszBoth);

    // Give Registry a chance to get updated
    Sleep(1000);

    return fRet;
}



//+-------------------------------------------------------------------
//
//  Function:   TestSingleThread, private
//
//  Synopsis:   Driver to verify testing of single threaded behavior
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestSingleThread(void)
{
    // Result of test - default to FALSE.
    BOOL fResult = FALSE;

    // Create an event for test to wait for completion of test.
    SSTParamBlock sstp;

    sstp.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    sstp.pcf = NULL;

    if (sstp.hEvent == NULL)
    {
        goto TestSingleThreadExit;
    }

    // Create a class object and put in a parameter block
    if (CoGetClassObject(clsidSingleThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &sstp.pcf) != NOERROR)
    {
        goto TestSingleThreadExit;
    }

    // Create the thread.
    if (CreateTestThread(SingleThreadTestThread, &sstp))
    {
        // Wait for test to complete - ignore deadlock for now at least. The
        // test thread is simple enough that it should not be a problem.
        ThreadWaitForEvent(sstp.hEvent);

        // Get result from thread
        fResult = sstp.fResult;
    }

TestSingleThreadExit:

    if (sstp.hEvent != NULL)
    {
        CloseHandle(sstp.hEvent);
    }

    if (sstp.pcf != NULL)
    {
        sstp.pcf->Release();
    }

    // Let user know this didn't work
    if (!fResult)
    {
        MessageBox(NULL, TEXT("Single Threaded Test Failed"),
            TEXT("FATAL ERROR"), MB_OK);
    }

    // Return results of test
    return fResult;
}





//+-------------------------------------------------------------------
//
//  Function:   TestAptThread, private
//
//  Synopsis:   Test an apartment model object. The most important
//              aspect of this is that it tests the helper APIs.
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestAptThread(void)
{
    // Return result for test
    BOOL fResult = FALSE;

    // Block for passing parameters to the test thread
    SATParamBlock satpb;

    satpb.pstrm = NULL;
    satpb.pcf = NULL;

    // Create an event for test to wait for completion of test.
    satpb.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (satpb.hEvent == NULL)
    {
        goto TestAptThreadExit;
    }
    satpb.pcf = NULL;
    // Create a class object and put in parameter block
    if (CoGetClassObject(clsidAptThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &satpb.pcf) != NOERROR)
    {
        goto TestAptThreadExit;
    }

    // Create stream using helper API
    if (CoMarshalInterThreadInterfaceInStream(IID_IClassFactory,
        satpb.pcf, &satpb.pstrm) != NOERROR)
    {
        goto TestAptThreadExit;
    }

    // Create thread to do apartment model test
    if (CreateTestThread(AptTestThread, &satpb))
    {
        // Wait for test to complete - ignore deadlock for now at least. The
        // test thread is simple enough that it should not be a problem.
        ThreadWaitForEvent(satpb.hEvent);

        // Get result from thread
        fResult = satpb.fResult;
    }

TestAptThreadExit:

    // Clean up any resources
    if (satpb.hEvent != NULL)
    {
        CloseHandle(satpb.hEvent);
    }

    if (satpb.pcf != NULL)
    {
        satpb.pcf->Release();
    }

    if (satpb.pstrm != NULL)
    {
        satpb.pstrm->Release();
    }

    // Let user know this didn't work
    if (!fResult)
    {
        MessageBox(NULL, TEXT("Apartment Threaded Test Failed"),
            TEXT("FATAL ERROR"), MB_OK);
    }

    // Return results of test
    return fResult;
}





//+-------------------------------------------------------------------
//
//  Function:   TestBothDll, private
//
//  Synopsis:   Test using DLL that purports to support both free
//              threading and apt model. The most important aspect
//              of this test is that it tests the marshal context.
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestBothDll(void)
{
    // Return result for test
    BOOL fResult = FALSE;

    // Block for passing parameters to the test thread
    SBTParamBlock sbtpb;

    sbtpb.pstrm = NULL;
    sbtpb.pcf = NULL;

    IClassFactory *pcfFromMarshal = NULL;
    IStream *pstmForMarshal = NULL;
    HGLOBAL hglobForStream = NULL;

    // Create an event for test to wait for completion of test.
    sbtpb.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (sbtpb.hEvent == NULL)
    {
        goto TestBothDllExit;
    }

    // Create a class object and put in parameter block
    if (CoGetClassObject(clsidBothThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &sbtpb.pcf) != NOERROR)
    {
        goto TestBothDllExit;
    }

    // Marshal this for the local context and unmarshal it and
    // see if we get the same result.

    if ((hglobForStream = GlobalAlloc(GMEM_MOVEABLE, 100)) == NULL)
    {
        GetLastError();
        goto TestBothDllExit;
    }

    if (CreateStreamOnHGlobal(hglobForStream, TRUE, &pstmForMarshal) != NOERROR)
    {
        goto TestBothDllExit;
    }

    if (CoMarshalInterface(pstmForMarshal, IID_IClassFactory, sbtpb.pcf,
        MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL) != NOERROR)
    {
        goto TestBothDllExit;
    }

    // Reset the stream to the begining
    {
        LARGE_INTEGER li;
        LISet32(li, 0);
        pstmForMarshal->Seek(li, STREAM_SEEK_SET, NULL);
    }

    if (CoUnmarshalInterface(pstmForMarshal, IID_IClassFactory,
        (void **) &pcfFromMarshal) != NOERROR)
    {
        goto TestBothDllExit;
    }

    if (sbtpb.pcf != pcfFromMarshal)
    {
        goto TestBothDllExit;
    }

    // Create stream using helper API
    if (CoMarshalInterThreadInterfaceInStream(IID_IClassFactory,
        sbtpb.pcf, &sbtpb.pstrm) != NOERROR)
    {
        goto TestBothDllExit;
    }

    // Create thread to do apartment model test
    if (CreateTestThread(BothTestThread, &sbtpb))
    {
        // Wait for test to complete - ignore deadlock for now at least. The
        // test thread is simple enough that it should not be a problem.
        WaitForSingleObject(sbtpb.hEvent, INFINITE);

        // Get result from thread
        fResult = sbtpb.fResult;
    }

TestBothDllExit:

    // Clean up any resources
    if (sbtpb.hEvent != NULL)
    {
        CloseHandle(sbtpb.hEvent);
    }

    if (sbtpb.pcf != NULL)
    {
        sbtpb.pcf->Release();
    }

    if (sbtpb.pstrm != NULL)
    {
        sbtpb.pstrm->Release();
    }

    if (pcfFromMarshal != NULL)
    {
        pcfFromMarshal->Release();
    }

    if (pstmForMarshal != NULL)
    {
        pstmForMarshal->Release();
    }
    else if (hglobForStream != NULL)
    {
        GlobalFree(hglobForStream);
    }

    // Let user know this didn't work
    if (!fResult)
    {
        MessageBox(NULL, TEXT("Both Threaded Test Failed"),
            TEXT("FATAL ERROR"), MB_OK);
    }

    // Return results of test
    return fResult;
}




//+-------------------------------------------------------------------
//
//  Function:   TestFreeAllLibraries, private
//
//  Synopsis:   Test free from non-main thread. This is really to
//              just make sure that nothing really bad happens when
//              we do this.
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestFreeAllLibraries(void)
{
    CoFreeUnusedLibraries();

    return TRUE;
}




//+-------------------------------------------------------------------
//
//  Function:   ThreadUnitTest, public
//
//  Synopsis:   Test various messaging enhancements to OLE
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
HRESULT ThreadUnitTest(void)
{
    HRESULT hr = E_FAIL;

    // Make sure OLE is initialized
    HRESULT hrInit = OleInitialize(NULL);

    if (FAILED(hrInit))
    {
        MessageBox(NULL, TEXT("ThreadUnitTest: OleInitialize FAILED"),
            TEXT("FATAL ERROR"), MB_OK);
        goto ThreadUnitTestExit;
    }

    // Set up the registry
    if (!SetUpRegistry())
    {
        goto ThreadUnitTestExit;
    }

    // Test Single Threaded DLL
    if (!TestSingleThread())
    {
        goto ThreadUnitTestExit;
    }

    // Test an aparment model DLL
    if (!TestAptThread())
    {
        goto ThreadUnitTestExit;
    }

    // Test a both DLL
    if (!TestBothDll())
    {
        goto ThreadUnitTestExit;
    }

    // Test CoFreeAllLibraries
    if (TestFreeAllLibraries())
    {
        hr = NOERROR;
    }

ThreadUnitTestExit:

    OleUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf\perfuuid\perfsrvi.c ===
#pragma warning(disable:4101)    // Ignore variable not use warning

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: iperf_i.c
//
//  Contents: IID_IPerf
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.83
//
//--------------------------------------------------------------------------
typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;


const IID CLSID_IPerf = {0x1AFDBB80, 0xAA32, 0x101A, {0xB4, 0xAD, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf\perfsrv\wterm.h ===
#ifndef __WTERM__
#define __WTERM__

// Message to print a line on the window
#define WM_PRINT_LINE (WM_USER + 1)

// Message to print a character on the window
#define WM_PUTC (WM_USER + 2)

// Message used to terminate this window
#define WM_TERM_WND (WM_USER + 3)

//
//  Typedefs for call back functions for the window
//
typedef long (*MFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*CFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*TFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);

// Register the terminal window class
BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR ICON);

// Create a window for the terminal
BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData);

#endif // __WTERM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf\perfcli\perfcli.cxx ===
//+-------------------------------------------------------------
//
// File:        perfcli.cxx
//
// Contents:    First attempt at getting perfcliing to work
//
// This is the client side
//
//
//---------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>

#include <ole2.h>
#include "iperf.h"
#include "..\perfsrv\perfsrv.hxx"
#include <memalloc.h>

#pragma hdrstop

#define TEST_FILE L"\\tmp\\test"

void QueryMsg( void );

// These are Cairo symbols.  Just define them here so I don't have to rip
// out or conditionally compile all references to them.
#define COINIT_MULTITHREADED  0
#define COINIT_SINGLETHREADED 1

DWORD thread_mode    = COINIT_SINGLETHREADED;
int   num_objects    = 1;
int   num_iterations = 1000;
HANDLE helper_wait;
HANDLE main_wait;

/*************************************************************************/
int DoTest()
{
    IPerf   **perf;
    HRESULT  result;
    DWORD    time_first;
    DWORD    waste;
    int      i;
    int      j;
    BOOL     success;
    LARGE_INTEGER frequency;
    LARGE_INTEGER count_first;
    LARGE_INTEGER count_last;
    LARGE_INTEGER dummy;

    // Allocate memory to hold the object and interface pointers.
    perf = (IPerf **) malloc( sizeof(void *) * num_objects );
    if (perf == NULL)
    {
      printf( "Could not get memory.\n" );
      return 1;
    }

    // Get a test object.
    result = CoCreateInstance( CLSID_IPerf, NULL, CLSCTX_LOCAL_SERVER, IID_IPerf,
                               (void **) &perf[0] );
    if (!SUCCEEDED(result))
    {
      printf( "Could not create instance of performance server: %x\n", result );
      return 1;
    }

    // Create the required number of objects.
    for (i = 1; i < num_objects; i++)
    {
      result = perf[0]->GetAnotherObject( &perf[i] );
      if (!SUCCEEDED(result))
      {
        printf( "Could not get enough objects: 0x%x\n", result );
        return 1;
      }
      perf[i]->NullCall();
    }

    // Prompt to start when the user is ready.
    // printf( "Ready? " );
    // gets( s );

    // Compute the time spent just looping.
    waste = GetTickCount();
    for (i = 0; i < num_iterations; i++)
      ;
    waste = GetTickCount() - waste;

    // Repeatedly call the first object to time it.
    time_first = GetTickCount();
    for (i = 0; i < num_iterations; i++)
      perf[0]->NullCall();
    time_first = GetTickCount() - time_first - waste;

    // Print the results.
    printf( "%d uS/Call\n", time_first*1000/num_iterations );

/*
    // Measure the same thing using the performance counter.
    success = QueryPerformanceFrequency( &frequency );
    if (!success)
    {
      printf( "Could not query performance frequency.\n" );
      goto free;
    }
    success = QueryPerformanceCounter( &count_first );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    perf[0]->NullCall();
    success = QueryPerformanceCounter( &count_last );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    if (count_last.HighPart != count_first.HighPart ||
        frequency.HighPart != 0)
      printf( "\n\n***** Overflow *****\n\n\n" );
    count_last.LowPart = (count_last.LowPart - count_first.LowPart) * 1000000 /
                         frequency.LowPart;
    printf( "\nFrequency %d\n", frequency.LowPart );
    printf( "%d uS/Call\n", count_last.LowPart );

    // How long does it take to query the performance counter?
    success = QueryPerformanceCounter( &count_first );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    for (i = 0; i < num_iterations; i++)
      QueryPerformanceCounter( &dummy );
    success = QueryPerformanceCounter( &count_last );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    if (count_last.HighPart != count_first.HighPart ||
        frequency.HighPart != 0)
      printf( "\n\n***** Overflow *****\n\n\n" );
    count_last.LowPart = (count_last.LowPart - count_first.LowPart) /
                         num_iterations * 1000000 / frequency.LowPart;
    printf( "%d uS/Query\n", count_last.LowPart );
*/

    // Prompt to let the user peruse the results.
    // printf( "Done? " );
    // gets( s );

    // Free the objects.
free:
    for (i = 0; i < num_objects; i++)
      perf[i]->Release();
    return 0;
}

/*************************************************************************/
void EventTest()
{
  DWORD    time_first;
  DWORD    waste;
  int      i;
  HANDLE   helper;

  // Measure how long it takes to loop.
  waste = GetTickCount();
  for (i = 0; i < num_iterations; i++)
    ;
  waste = GetTickCount() - waste;

  // Measure how long it takes to get an event
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
  {
    helper = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (helper == NULL)
    {
      printf( "Could not create event %d.\n", i );
      return;
    }
    CloseHandle( helper );
  }
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/CreateEvent\n", time_first*1000/num_iterations );

  // Don't bother cleaning up.
}

/*************************************************************************/
/* Parse the arguments. */
BOOL parse( int argc, char *argv[] )
{
  int i;
  int len;
  TCHAR buffer[80];

#if 0
  // Look up the thread mode from the win.ini file.
  len = GetProfileString( L"My Section", L"ThreadMode", L"MultiThreaded", buffer,
                          sizeof(buffer) );
  if (lstrcmp(buffer, L"SingleThreaded") == 0)
    thread_mode = COINIT_SINGLETHREADED;
  else if (lstrcmp(buffer, L"MultiThreaded") == 0)
    thread_mode = COINIT_MULTITHREADED;
#endif

  // Parse each item, skip the command name
  for (i = 1; i < argc; i++)
  {
    if (strcmp( argv[i], "Single" ) == 0)
      thread_mode = COINIT_SINGLETHREADED;
    else if (strcmp( argv[i], "Multi" ) == 0)
      thread_mode = COINIT_MULTITHREADED;
    else if (strcmp( argv[i], "-o" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an object count after the -o option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &num_objects );
    }
    else if (strcmp( argv[i], "-i" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an object count after the -i option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &num_iterations );
    }
    else
    {
      printf( "You don't know what you are doing!\n" );
    }
  }

  return TRUE;
}

/*************************************************************************/
void MarshalTest()
{
  HANDLE    file;
  HRESULT   result;
  IMoniker *moniker;
  IBindCtx *bindctx;
  WCHAR    *wide_name;
  unsigned char *name;
  int            i;
  IPerf         *perf;

  // Initialize OLE.
  result = OleInitialize(NULL);
  if (FAILED(result))
  {
    printf( "Could not initialize OLE: 0x%x\n", result );
    return;
  }

  // Create file.
  file = CreateFile( TEST_FILE, 0, 0, NULL, CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL, NULL );
  if (file == INVALID_HANDLE_VALUE)
  {
    printf( "Could not create file." );
    return;
  }

  // Create file moniker.
  result = CreateFileMoniker( TEST_FILE, &moniker );
  if (FAILED(result))
  {
    printf( "Could not create file moniker: 0x%x\n", result );
    return;
  }

  // Get a bind context.
  result = CreateBindCtx( NULL, &bindctx );
  if (FAILED(result))
  {
    printf( "Could not create bind context: 0x%x\n", result );
    return;
  }

  // Display name.
  result = moniker->GetDisplayName( bindctx, NULL, &wide_name );
  if (FAILED(result))
  {
    printf( "Could not get display name: 0x%x\n", result );
    return;
  }

  // Convert the string to ascii and print it.
  name = (unsigned char *) wide_name;
  i = 0;
  while (wide_name[i] != 0)
    name[i] = wide_name[i++];
  name[i] = 0;
  printf( "The moniker is called <%s>\n", name );

  // Free string.
  CoTaskMemFree( wide_name );

  // Get a test object.
  result = CoCreateInstance( CLSID_IPerf, NULL, CLSCTX_LOCAL_SERVER, IID_IPerf,
                               (void **) &perf );
  if (!SUCCEEDED(result))
  {
    printf( "Could not create instance of performance server: %x\n", result );
    return;
  }

  // Pass moniker to server.
  result = perf->PassMoniker( moniker );
  if (FAILED(result))
  {
    printf( "Could not give moniker to server: 0x%x\n", result );
    return;
  }

  // Release everything.
  CloseHandle( file );
  moniker->Release();
  bindctx->Release();
  perf->Release();
  OleUninitialize();
}


//+--------------------------------------------------------------
// Function:    Main
//
// Synopsis:    Executes the BasicBnd test
//
// Effects:     None
//
//
// Returns:     Exits with exit code 0 if success, 1 otherwise
//
// History:     05-Mar-92   Sarahj   Created
//
//---------------------------------------------------------------

int _cdecl main(int argc, char *argv[])
{
  BOOL    initialized = FALSE;
  HRESULT hresult = S_OK;
  BOOL    fFailed = FALSE;

  // Parse the command line arguments.
  if (!parse( argc, argv ))
    return 0;

  // Print the process id.
  printf( "Hi, I am %x.\n", GetCurrentProcessId() );

  // Time event creation.
//  EventTest();
//  return 1;

  // Pass around monikers.
//  MarshalTest();

  // Measure message queue APIs.
//  QueryMsg();


  // Print the thread mode.
  if (thread_mode == COINIT_SINGLETHREADED)
  {
    printf( "Measuring performance for the single threaded mode.\n" );
  }
  else
  {
    printf( "Measuring performance for the multithreaded mode.\n" );
  }

  // must be called before any other OLE API
  hresult = OleInitialize(NULL);

  if (FAILED(hresult))
  {
      printf("OleInitialize Failed with %lx\n", hresult);
      goto exit_main;
  }
  initialized = TRUE;

  if (fFailed = DoTest())
    goto exit_main;

/*
  // Uninitialize and rerun in the other thread mode.
  OleUninitialize();
  if (thread_mode == COINIT_SINGLETHREADED)
    thread_mode = COINIT_MULTITHREADED;
  else
    thread_mode = COINIT_SINGLETHREADED;

  // Print the thread mode.
  if (thread_mode == COINIT_SINGLETHREADED)
    printf( "Measuring performance for the single threaded mode.\n" );
  else
    printf( "Measuring performance for the multithreaded mode.\n" );

  // must be called before any other OLE API
  hresult = OleInitialize(NULL);

  if (FAILED(hresult))
  {
      printf("OleInitialize Failed with %lx\n", hresult);
      goto exit_main;
  }

  if (fFailed = DoTest())
    goto exit_main;
*/

exit_main:

  if (initialized)
    OleUninitialize();

  if (!fFailed)
  {
      printf("\nCairole: PASSED\n");
  }
  else
  {
      printf("\nCairole: FAILED\n");
  }

  return fFailed;
}

/*************************************************************************/
DWORD _stdcall MsgHelper( void *param )
{
  int    i;

  // Alternately signal and wait on an event.  Do it one time too many
  // because the main thread calls once to let us get set up.
  for (i = 0; i < num_iterations+1; i++)
  {
    WaitForSingleObject( helper_wait, INFINITE );
    SetEvent( main_wait );
  }

#define must_return_a_value return 0
  must_return_a_value;
}

/*************************************************************************/
void QueryMsg()
{
  DWORD    time_first;
  DWORD    waste;
  int      i;
  HANDLE   helper;
  DWORD    thread_id;

  // Create an event.
  helper_wait = CreateEvent( NULL, FALSE, FALSE, NULL );
  if (helper_wait == NULL)
  {
    printf( "Could not create event.\n" );
    return;
  }
  main_wait = CreateEvent( NULL, FALSE, FALSE, NULL );
  if (main_wait == NULL)
  {
    printf( "Could not create event.\n" );
    return;
  }

  // Measure how long it takes to loop.
  waste = GetTickCount();
  for (i = 0; i < num_iterations; i++)
    ;
  waste = GetTickCount() - waste;

  // Measure how long it takes to query the message queue.
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
    GetQueueStatus( QS_ALLINPUT );
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/GetQueueStatus\n", time_first*1000/num_iterations );

  // Start a thread to wake up this one.
  helper = CreateThread( NULL, 0, MsgHelper, 0, 0,
                           &thread_id );
  if (helper == NULL)
  {
    printf( "Could not create helper thread.\n" );
    return;
  }

  // Call MsgWaitForMultipleObjects once to let the thread get started.
  SetEvent( helper_wait );
  MsgWaitForMultipleObjects( 1, &main_wait, FALSE,
                             INFINITE, QS_ALLINPUT );

  // Measure how long it takes to call MsgWaitForMultipleObjects.
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
  {
    SetEvent( helper_wait );
    MsgWaitForMultipleObjects( 1, &main_wait, FALSE,
                               INFINITE, QS_ALLINPUT );
  }
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/MsgWaitForMultipleObjects\n", time_first*1000/num_iterations );

  // Start a thread to wake up this one.
  helper = CreateThread( NULL, 0, MsgHelper, 0, 0,
                           &thread_id );
  if (helper == NULL)
  {
    printf( "Could not create helper thread.\n" );
    return;
  }

  // Let the thread get started.
  SetEvent( helper_wait );
  WaitForSingleObject( main_wait, INFINITE );

  // Measure how long it takes to switch threads just using events.
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
  {
    SetEvent( helper_wait );
    WaitForSingleObject( main_wait, INFINITE );
  }
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/MsgWaitForMultipleObjects\n", time_first*1000/num_iterations );

  // Don't bother cleaning up.
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf\perfsrv\perfsrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:       perfsrv.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//			CPerfCF (class factory)
//			CPerf   (actual class implementation)
//
//  Classes:	CPerfCF, CPerf
//
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------

// Turn off ole Cairol IUnknown
#define __IUNKNOWN_TMP__


#include    <windows.h>
#include    <ole2.h>
#include    "perfsrv.hxx"
extern "C" {
#include    <stdio.h>
#include    <stdarg.h>
#include    "wterm.h"
}

// These are Cairo symbols.  Just define them here so I don't have to rip
// out or conditionally compile all references to them.
#define COINIT_MULTITHREADED  0
#define COINIT_SINGLETHREADED 1

#define IDM_DEBUG 0x100

// Count of objects we have instantiated. When we detect 0, we quit.
ULONG g_cUsage = 0;

const TCHAR *szAppName = L"Performance Server";

HWND g_hMain;
DWORD thread_mode = COINIT_SINGLETHREADED;
DWORD MainThread;
DWORD junk;


void Display(TCHAR *pszFmt, ...)
{
    va_list marker;
    TCHAR szBuffer[256];

    va_start(marker, pszFmt);

    int iLen = vswprintf(szBuffer, pszFmt, marker);

    va_end(marker);

    // Display the message on terminal window
    SendMessage(g_hMain, WM_PRINT_LINE, iLen, (LONG) szBuffer);
}




//+-------------------------------------------------------------------------
//
//  Function:	ProcessMenu
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessMenu(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    if ((uiMessage == WM_SYSCOMMAND) && (wParam == IDM_DEBUG))
    {
	// Request for a debug breakpoint!
	DebugBreak();
    }


    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessChar
//
//  Synopsis:	Gets called when a WM_CHAR message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessChar(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessClose
//
//  Synopsis:	Gets called when a NC_DESTROY message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessClose(
    HWND hWindow,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    void *pvCallBackData)
{
    // Take default action with message
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    char *lpCmdLine,
    int nCmdShow)
{
    // For windows message
    MSG   msg;
    DWORD dwRegistration;
    int   len;
    TCHAR buffer[80];
    MainThread = GetCurrentThreadId();

    // Look up the thread mode from the win.ini file.
#if 0
    len = GetProfileString( L"My Section", L"ThreadMode", L"MultiThreaded", buffer,
                            sizeof(buffer) );
    if (lstrcmp(buffer, L"SingleThreaded") == 0)
      thread_mode = COINIT_SINGLETHREADED;
    else if (lstrcmp(buffer, L"MultiThreaded") == 0)
      thread_mode = COINIT_MULTITHREADED;
#endif

    // Initialize the OLE libraries
    OleInitialize(NULL);

    // Create our class factory
    CPerfCF *perf_cf = new CPerfCF();

    // Register our class with OLE
    CoRegisterClassObject(CLSID_IPerf, perf_cf, CLSCTX_LOCAL_SERVER,
	REGCLS_MULTIPLEUSE, &dwRegistration);

    // CoRegister bumps reference count so we don't have to!
    perf_cf->Release();

    // Register the window class
    TermRegisterClass(hInstance, (LPTSTR) szAppName,
	 (LPTSTR) szAppName, (LPTSTR) (1));

    // Create the server window
    TermCreateWindow(
	(LPTSTR) szAppName,
	(LPTSTR) szAppName,
	NULL,
	ProcessMenu,
	ProcessChar,
	ProcessClose,
	SW_SHOWNORMAL,
	&g_hMain,
	NULL);

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hMain, FALSE);

    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, L"Debug");

    // Print the process id.
    Display( L"Hi, I am %x.\n", GetCurrentProcessId() );

    // Echo the mode.
    if (thread_mode == COINIT_SINGLETHREADED)
      Display(L"Server running in single threaded mode.\n");
    else
      Display(L"Server running in multithreaded mode.\n");

    // Message processing loop
    while (GetMessage (&msg, NULL, 0, 0))
    {
	TranslateMessage (&msg);
	DispatchMessage (&msg);
    }

    // Deregister out class - should release object as well
    CoRevokeClassObject(dwRegistration);

    // Tell OLE we are going away.
    OleUninitialize();

    return (msg.wParam);	   /* Returns the value from PostQuitMessage */
}



/***************************************************************************/
void CheckThread( TCHAR *name )
{
  if (thread_mode == COINIT_SINGLETHREADED)
  {
    if (GetCurrentThreadId() != MainThread)
      goto complain;
  }
  else
  {
    if (GetCurrentThreadId() == MainThread)
      goto complain;
  }
  return;

complain:
  Display( L"*********************************************************\n" );
  Display( L"*                                                       *\n" );
  Display( L"*                      Error                            *\n" );
  Display( L"*                                                       *\n" );
  Display( L"* Method called on wrong thread.                        *\n" );
  Display( name );
  Display( L"*                                                       *\n" );
  Display( L"*********************************************************\n" );
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerf::AddRef( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerf::AddRef( THIS )");
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CPerf::CPerf()
{
  ref_count = 1;
  g_cUsage++;
}

/***************************************************************************/
CPerf::~CPerf()
{
    if (--g_cUsage == 0)
    {
	SendMessage(g_hMain, WM_TERM_WND, 0, 0);
    }
}

/***************************************************************************/
STDMETHODIMP CPerf::GetAnotherObject( IPerf **another )
{
  CheckThread(L"STDMETHODIMP CPerf::GetAnotherObject( IPerf **another )");
  *another = NULL;
  CPerf *perf = new FAR CPerf();

  if (perf == NULL)
  {
    return E_OUTOFMEMORY;
  }

  *another = perf;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::HResultCall()
{
  CheckThread(L"STDMETHODIMP CPerf::HResultCall()");
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::NullCall()
{
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::PassMoniker( IMoniker *moniker )
{
  HRESULT        result;
  IBindCtx      *bindctx;
  WCHAR         *wide_name;

  // Get a bind context.
  result = CreateBindCtx( NULL, &bindctx );
  if (FAILED(result))
  {
    Display( L"Could not create bind context: 0x%x\n", result );
    return E_FAIL;
  }

  // Display name.
  result = moniker->GetDisplayName( bindctx, NULL, &wide_name );
  if (FAILED(result))
  {
    Display( L"Could not get display name: 0x%x\n", result );
    return E_FAIL;
  }

  // Display the name.
  Display( L"The moniker is called <%s>\n", wide_name );

  // Free string.
  CoTaskMemFree( wide_name );

  // Release everything.
  moniker->Release();
  bindctx->Release();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  CheckThread(L"STDMETHODIMP CPerf::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)" );
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IPerf))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerf::Release( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerf::Release( THIS )");
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerfCF::AddRef( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerfCF::AddRef( THIS )");
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CPerfCF::CPerfCF()
{
  ref_count = 1;
}

/***************************************************************************/
CPerfCF::~CPerfCF()
{
}

/***************************************************************************/
STDMETHODIMP CPerfCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
  CheckThread(L"STDMETHODIMP CPerfCF::CreateInstance(" );
    Display(L"CPerfCF::CreateInstance called\n");

    *ppv = NULL;
    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    if (!IsEqualIID( iidInterface, IID_IPerf ))
      return E_NOINTERFACE;

    CPerf *perf = new FAR CPerf();

    if (perf == NULL)
    {
	return E_OUTOFMEMORY;
    }

    *ppv = perf;
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerfCF::LockServer(BOOL fLock)
{
  CheckThread( L"STDMETHODIMP CPerfCF::LockServer(BOOL fLock)" );
    return E_FAIL;
}


/***************************************************************************/
STDMETHODIMP CPerfCF::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  CheckThread(L"STDMETHODIMP CPerfCF::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)");
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IClassFactory))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }

  *ppvObj = NULL;
  return E_NOINTERFACE;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerfCF::Release( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerfCF::Release( THIS )");
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf\proxy\dllentry.c ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dllentry.c
//
//  Contents:   Dll Entry point code.  Calls the appropriate run-time
//              init/term code and then defers to LibMain for further
//              processing.
//
//  Classes:    <none>
//
//  Functions:  DllEntryPoint - Called by loader
//
//  History:    10-May-92  BryanT    Created
//              22-Jul-92  BryanT    Switch to calling _cexit/_mtdeletelocks
//                                    on cleanup.
//              06-Oct-92  BryanT    Call RegisterWithCommnot on entry
//                                   and DeRegisterWithCommnot on exit.
//                                   This should fix the heap dump code.
//              12-23-93   TerryRu   Replace LockExit, and UnLockExit
//                                   with critial sections for Daytona.
//              12-28-93   TerryRu   Place Regiter/DeRegister WinCommnot apis
//                                   Inside WIN32 endifs for Daytona builds.
//
//--------------------------------------------------------------------
#include <windows.h>
//#include <win4p.h>
#include <process.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>


BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

void __cdecl _mtdeletelocks(void);

DWORD WINAPI
GetModuleFileNameCtC(
        HMODULE hModule,
        LPWSTR  pwszFilename,
        DWORD   nSize);

#ifdef USE_CRTDLL

#define _RT_ONEXIT      24

/*
 * routine in DLL to do initialization (in this case, C++ constructors)
 */

typedef void (__cdecl *PF)(void);

/*
 * pointers to initialization sections
 */

PF *__onexitbegin;
PF *__onexitend;

/*
 * Define increment (in entries) for growing the _onexit/atexit table
 */
#define ONEXITTBLINCR   4

static void __cdecl _onexitinit ( void );
extern void __cdecl _initterm(PF *, PF *);
extern void __cdecl _amsg_exit(int);
extern void __cdecl _lockexit(void);
extern void __cdecl _unlockexit(void);

#endif

// BUGBUG: defined in $(COMMON)\src\except\memory.cxx

void RegisterWithCommnot(void);
void DeRegisterWithCommnot(void);

CRITICAL_SECTION __gCriticalSection;

BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRc = FALSE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

#ifdef USE_CRTDLL
            //
            // Assumption: The run-time is sufficiantly up and running to
            //             support malloc that _onexitinit will perform.
            //
            _onexitinit();
            InitializeCriticalSection(&__gCriticalSection );
#endif

            _CRT_INIT(hDll, dwReason, lpReserved);
#if WIN32==300
            RegisterWithCommnot();
#endif

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);
            break;

        case DLL_PROCESS_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);

            //
            // BUGBUG: What a hack.  In order to make sure we don't kill
            //         commnot's objects while still in use (_cexit will do
            //         the atexit list processing where the compiler stores
            //         pointers to all the static destructors), test the
            //         module name.  If not commnot, call _cexit().
            //         DeRegisterWithCommnot will call it for commnot...
            //

#ifdef USE_CRTDLL

            {
                wchar_t pwszModName[512];
                GetModuleFileName(hDll, pwszModName, 512);

                if (!wcswcs(wcsupr(pwszModName), L"COMMNOT"))
                    if (__onexitbegin)
                        _initterm(__onexitbegin, __onexitend);
            }

            DeleteCriticalSection( & __gCriticalSection );
#else

            {
                wchar_t pwszModName[512];
                GetModuleFileName(hDll, pwszModName, 512);

                if (!wcswcs(wcsupr(pwszModName), L"COMMNOT"))
                    _cexit();
            }

            _mtdeletelocks();
#endif
#if WIN32==300
            DeRegisterWithCommnot();
#endif
            break;
    }

    return(fRc);
}

#ifdef USE_CRTDLL

_onexit_t __cdecl _onexit ( _onexit_t func )
{
        PF      *p;

        EnterCriticalSection( &__gCriticalSection );                    /* lock the exit code */

        /*
         * First, make sure the table has room for a new entry
         */
        if ( _msize(__onexitbegin) <= (unsigned)((char *)__onexitend -
            (char *)__onexitbegin) ) {
                /*
                 * not enough room, try to grow the table
                 */
                if ( (p = (PF *) realloc(__onexitbegin, _msize(__onexitbegin) +
                    ONEXITTBLINCR * sizeof(PF))) == NULL ) {
                        /*
                         * didn't work. don't do anything rash, just fail
                         */
                        LeaveCriticalSection(&__gCriticalSection );

                        return NULL;
                }

                /*
                 * update __onexitend and __onexitbegin
                 */

                __onexitend = p + (__onexitend - __onexitbegin);
                __onexitbegin = p;
        }

        /*
         * Put the new entry into the table and update the end-of-table
         * pointer.
         */

         *(__onexitend++) = (PF)func;

        LeaveCriticalSection( &__gCriticalSection );

        return func;

}

int __cdecl atexit ( PF func )
{
        return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}

static void __cdecl _onexitinit ( void )
{
        if ( (__onexitbegin = (PF *)malloc(32 * sizeof(PF))) == NULL )
                /*
                 * cannot allocate minimal required size. generate
                 * fatal runtime error.
                 */
                _amsg_exit(_RT_ONEXIT);

        *(__onexitbegin) = (PF) NULL;
        __onexitend = __onexitbegin;
}

#endif  // USE_CRTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf\perfsrv\wterm.c ===
/****************************************************************************

    PROGRAM: wterm.c

    PURPOSE: Implementation of TermWClass Windows

    FUNCTIONS:


    COMMENTS:


****************************************************************************/

#include "windows.h"
#include "stdlib.h"
#include "memory.h"
#include "wterm.h"

#define MAX_ROWS 24
#define MAX_COLS 80

typedef struct WData
{
    // Function to execute for processing a menu
    MFUNCP pMenuProc;

    // Function to execute for processing a single character
    CFUNCP pCharProc;

    // Function to execute when window is closed (terminated)
    TFUNCP pCloseProc;

    // Pass on callback
    void *pvCallBackData;

    BOOL fGotFocus;

    BOOL fCaretHidden;

    // Rows on the screen
    int cRows;

    // Columns on the screen
    int cCols;

    // Row at top of screen
    int iTopRow;

    // Row at bottom of the screen
    int iBottomRow;

    // First Column on screen
    int iFirstCol;

    // Column at bottom of the screen
    int iBottomCol;

    // Row for next character
    int iNextRow;

    // Row for next column
    int iNextCol;

    // Width of character
    int cxChar;

    // Height of character
    int cyChar;

    // Memory image of screen this is treated as a circular buffer
    TCHAR aImage[MAX_ROWS] [MAX_COLS];

    // First row in circular screen buffer
    int iBufferTop;
} WData;

static HANDLE hInst = 0;
TCHAR BlankLine[80];

static int
row_diff(
    int row1,
    int row2)
{
    return (row2 > row1)
        ? MAX_ROWS - (row2 - row1)
        : row1 - row2;
}

static void
set_vscroll_pos(
    HWND hwnd,
    WData *pwdata)
{
    if (pwdata->cRows != 0)
    {
        // Save a few indirections by caching cRows
        register int cRows = pwdata->cRows;

        // calculate distance bottom of screen from top of data buffer
        register int top_from_row = row_diff(pwdata->iBottomRow,
            pwdata->iBufferTop);

        // Output position of scroll bar
        int new_pos = 0;

        if (top_from_row >= cRows)
        {
            // Calculate number of screens to display entire buffer
            int screens_for_data = MAX_ROWS / cRows
               + ((MAX_ROWS % cRows != 0) ? 1 : 0);

            // Figure out which screen the row falls in
            int screen_loc = top_from_row / cRows
                + ((top_from_row % cRows != 0) ? 1 : 0);

            // If the screen is in the last one set box to max
            new_pos = (screen_loc == screens_for_data)
                ? MAX_ROWS : screen_loc * cRows;
        }

        SetScrollPos(hwnd, SB_VERT, new_pos, TRUE);
    }
}

static int
calc_row(
    register int row,
    WData *pwdata)
{
    register int top = pwdata->iTopRow;
    static int boopa = 0;

    if (top > row)
        boopa++;

    return (row >= top) ? row - top : (MAX_ROWS - (top - row));
}

static void
display_text(
    HWND hwnd,
    int row,
    int col,
    LPTSTR text,
    int text_len,
    WData *pWData)
{
    // Get the DC to display the text
    HDC hdc = GetDC(hwnd);

    // Select Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Hide caret while we are printing
    HideCaret(hwnd);

    // Update the screen
    TextOut(hdc, (col - pWData->iFirstCol) * pWData->cxChar,
        calc_row(row, pWData) * pWData->cyChar, text, text_len);

    // Done with DC
    ReleaseDC(hwnd, hdc);

    // Put the caret back now that we are done
    ShowCaret(hwnd);
}

static void
display_char(
    HWND hwnd,
    TCHAR char_to_display,
    WData *pWData)
{
    // Update image buffer
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = char_to_display;

    display_text(hwnd, pWData->iNextRow, pWData->iNextCol,
      &char_to_display, 1, pWData);
}

static void
do_backspace(
    HWND hwnd,
    WData *pWData)
{
    // Point to the previous character in the line
    if (--pWData->iNextCol < 0)
    {
        // Can't backspace beyond the current line
        pWData->iNextCol = 0;
        return;
    }

    display_char(hwnd, ' ', pWData);

    // Null character for repaint
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';
}

static int
inc_row(
    int row,
    int increment)
{
    row += increment;

    if (row >= MAX_ROWS)
    {
        row -= MAX_ROWS;
    }
    else if (row < 0)
    {
        row += MAX_ROWS;
    }

    return row;
}

void
inc_next_row(
    HWND hwnd,
    WData *pWData)
{
    if (pWData->iNextRow == pWData->iBottomRow)
    {
        // Line is at bottom -- scroll the client area one row
        ScrollWindow(hwnd, 0, -pWData->cyChar, NULL, NULL);

        // Increment the top & bottom of the screen
        pWData->iTopRow = inc_row(pWData->iTopRow, 1);
        pWData->iBottomRow = inc_row(pWData->iBottomRow, 1);
    }

    // Increment the row
    pWData->iNextRow = inc_row(pWData->iNextRow, 1);

    if (pWData->iNextRow == pWData->iBufferTop)
    {
        // Have to reset circular buffer to next
        pWData->iBufferTop = inc_row(pWData->iBufferTop, 1);

        // Reset line to nulls for repaint
        memset(&pWData->aImage[pWData->iNextRow][0], '\0', MAX_COLS);
    }

    pWData->iNextCol = 0;
}

static void
do_cr(
    HWND hwnd,
    WData *pWData)
{
    // Set position to next row
    inc_next_row(hwnd, pWData);
    pWData->iNextCol = 0;

    // Make sure next character is null for repaint of line
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';

    // Update the vertical scroll bar's position
    set_vscroll_pos(hwnd, pWData);
}

static void
do_char(
    HWND hwnd,
    WPARAM wParam,
    WData *pWData)
{
    display_char(hwnd, (TCHAR) wParam, pWData);

    // Point to the next character in the line
    if (++pWData->iNextCol > MAX_COLS)
    {
        // Handle switch to next line
        inc_next_row(hwnd, pWData);
    }
}

static void
do_tab(
    HWND hwnd,
    WData *pWData)
{
    int c = pWData->iNextCol % 8;

    if ((pWData->iNextCol + c) <= MAX_COLS)
    {
        for ( ; c; c--)
        {
            do_char(hwnd, ' ', pWData);
        }
    }
    else
    {
        do_cr(hwnd, pWData);
    }
}

static void
EchoChar(
    HWND hwnd,
    WORD cRepeats,
    WPARAM wParam,
    WData *pWData)
{
    for ( ; cRepeats; cRepeats--)
    {
        switch (wParam)
        {
        // Backspace
        case '\b':
            do_backspace(hwnd, pWData);
            break;

        // Carriage return
        case '\n':
        case '\r':
            do_cr(hwnd, pWData);
            break;

        // Tab
        case '\t':
            do_tab(hwnd, pWData);
            break;

        // Regular characters
        default:
            do_char(hwnd, wParam, pWData);
        }
    }

    // The row is guaranteed to be on the screen because we will
    // scroll on a CR. However, the next column for input may be
    // beyond the window we are working in.
    if (pWData->iNextCol > pWData->iBottomCol)
    {
        // We are out of the window so scroll the window one
        // column to the right.
        SendMessage(hwnd, WM_HSCROLL, SB_LINEDOWN, 0L);
    }
    else if (pWData->iNextCol < pWData->iFirstCol)
    {
        // We are out of the window so repaint the window using
        // iNextCol as the first column for the screen.
        pWData->iFirstCol = pWData->iNextCol;
        pWData->iBottomCol = pWData->iFirstCol + pWData->cCols - 1;

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pWData->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
    else
    {
        // Reset Caret's position
        SetCaretPos((pWData->iNextCol - pWData->iFirstCol) * pWData->cxChar,
            calc_row(pWData->iNextRow, pWData) * pWData->cyChar);
    }
}

/****************************************************************************

    FUNCTION: WmCreate(HWND)

    PURPOSE:  Initializes control structures for a TermWClass Window

    MESSAGES:
              WM_CREATE

    COMMENTS:

            This prepares a window for processing character based
            I/O. In particular it does stuff like calculate the
            size of the window needed.

****************************************************************************/
static void
WmCreate(
    HWND hwnd,
    CREATESTRUCT *pInit)
{
    WData *pData = (WData *) (pInit->lpCreateParams);
    HDC hdc = GetDC(hwnd);
    TEXTMETRIC tm;

    // Store pointer to window data
    SetWindowLong(hwnd, 0, (LONG) pData);

    // Set font to system fixed font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Calculate size of a character
    GetTextMetrics(hdc, &tm);
    pData->cxChar = tm.tmAveCharWidth;
    pData->cyChar = tm.tmHeight;
    ReleaseDC(hwnd, hdc);

    // Set up vertical scroll bars
    SetScrollRange(hwnd, SB_VERT, 0, MAX_ROWS, TRUE);
    SetScrollPos(hwnd, SB_VERT, 0, TRUE);

    // Set up horizontal scroll bars
    SetScrollRange(hwnd, SB_HORZ, 0, MAX_COLS, TRUE);
    SetScrollPos(hwnd, SB_HORZ, 0, TRUE);
}

/****************************************************************************

    FUNCTION: WmSize(HWND, WORD, LONG)

    PURPOSE:  Processes a size message

    MESSAGES:

    COMMENTS:

****************************************************************************/
static void
WmSize(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    // Get the new size of the window
    int cxClient;
    int cyClient;
    int cRowChange = pwdata->cRows;
    RECT rect;

    // Get size of client area
    GetClientRect(hwnd, &rect);

    // Calculate size of client area
    cxClient = rect.right - rect.left;
    cyClient = rect.bottom - rect.top;

    // Calculate size of area in rows
    pwdata->cCols = cxClient / pwdata->cxChar;
    pwdata->cRows = min(MAX_ROWS, cyClient / pwdata->cyChar);
    pwdata->iBottomCol = min(pwdata->iFirstCol + pwdata->cCols, MAX_COLS);
    cRowChange = pwdata->cRows - cRowChange;

    // Keep input line toward bottom of screen
    if (cRowChange < 0)
    {
        // Screen has shrunk in size.
        if (pwdata->iNextRow != pwdata->iTopRow)
        {
            // Has input row moved out of screen?
            if (row_diff(pwdata->iNextRow, pwdata->iTopRow) >= pwdata->cRows)
            {
                // Yes -- Calculate top new top that puts input line on
                // the bottom.
                pwdata->iTopRow =
                    inc_row(pwdata->iNextRow, 1 - pwdata->cRows);
            }
        }
    }
    else
    {
        // Screen has gotten bigger -- Display more text if possible
        if (pwdata->iTopRow != pwdata->iBufferTop)
        {
            pwdata->iTopRow = inc_row(pwdata->iTopRow,
                -(min(row_diff(pwdata->iTopRow, pwdata->iBufferTop),
                    cRowChange)));
        }
    }

    // Calculate new bottom
    pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows - 1);

    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);
}

static void
WmSetFocus(
    HWND hwnd,
    WData *pwdata)
{
    // save indirections
    register int cxchar = pwdata->cxChar;
    register int cychar = pwdata->cyChar;
    pwdata->fGotFocus = TRUE;
    CreateCaret(hwnd, NULL, cxchar, cychar);

    if (!pwdata->fCaretHidden)
    {
        SetCaretPos(pwdata->iNextCol * cxchar,
            calc_row(pwdata->iNextRow, pwdata) * cychar);
    }

    ShowCaret(hwnd);
}

static void
WmKillFocus(
    HWND hwnd,
    WData *pwdata)
{
    pwdata->fGotFocus = FALSE;

    if (!pwdata->fCaretHidden)
    {
        HideCaret(hwnd);
    }

    DestroyCaret();
}

static void
WmVscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    int cVscrollInc = 0;
    register int top_diff = row_diff(pwdata->iTopRow, pwdata->iBufferTop);
    register int bottom_diff = MAX_ROWS - (top_diff + pwdata->cRows);

    switch(wParam)
    {
    case SB_TOP:

        if (top_diff != 0)
        {
            cVscrollInc = -top_diff;
        }

        break;

    case SB_BOTTOM:

        if (bottom_diff != 0)
        {
            cVscrollInc = bottom_diff;
        }

        break;

    case SB_LINEUP:

        if (top_diff != 0)
        {
            cVscrollInc = -1;
        }

        break;

    case SB_LINEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = 1;
        }

        break;

    case SB_PAGEUP:

        if (top_diff != 0)
        {
            cVscrollInc = - ((top_diff > pwdata->cRows)
                ? pwdata->cRows : top_diff);
        }

        break;

    case SB_PAGEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = (bottom_diff > pwdata->cRows)
                ? pwdata->cRows : bottom_diff;
        }

        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cVscrollInc = LOWORD(lParam)
                - row_diff(pwdata->iTopRow, pwdata->iBufferTop);
        }
    }

    // Cacluate new top row
    if (cVscrollInc != 0)
    {
        // Calculate new top and bottom
        pwdata->iTopRow = inc_row(pwdata->iTopRow, cVscrollInc);
        pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows);

        // Scroll window
        ScrollWindow(hwnd, 0, pwdata->cyChar * cVscrollInc, NULL, NULL);

        // Reset scroll bar
        set_vscroll_pos(hwnd, pwdata);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmHscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    register int cHscrollInc = 0;

    switch(wParam)
    {
    case SB_LINEUP:

        cHscrollInc = -1;
        break;

    case SB_LINEDOWN:

        cHscrollInc = 1;
        break;

    case SB_PAGEUP:

        cHscrollInc = -8;
        break;

    case SB_PAGEDOWN:

        cHscrollInc = 8;
        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cHscrollInc = LOWORD(lParam) - pwdata->iFirstCol;
        }
    }

    if (cHscrollInc != 0)
    {
        // Cacluate new first column
        register int NormalizedScrollInc = cHscrollInc + pwdata->iFirstCol;

        if (NormalizedScrollInc < 0)
        {
            cHscrollInc = -pwdata->iFirstCol;
        }
        else if (NormalizedScrollInc > MAX_COLS - pwdata->cCols)
        {
            cHscrollInc = (MAX_COLS - pwdata->cCols) - pwdata->iFirstCol;
        }

        pwdata->iFirstCol += cHscrollInc;
        pwdata->iBottomCol = pwdata->iFirstCol + pwdata->cCols - 1;

        // Scroll window
        ScrollWindow(hwnd, -(pwdata->cxChar * cHscrollInc), 0, NULL, NULL);

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pwdata->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmPaint(
    HWND hwnd,
    WData *pwdata)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    register int row = pwdata->iTopRow;
    register int col = pwdata->iFirstCol;
    int bottom_row = pwdata->iBottomRow;
    int cxChar = pwdata->cxChar;
    int cyChar = pwdata->cyChar;
    int y;

    // Select System Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    while (TRUE)
    {
	int len = lstrlen(&pwdata->aImage[row][col]);

        if (len != 0)
        {
            y = calc_row(row, pwdata) * cyChar;
	    TextOut(hdc, 0, y, &pwdata->aImage[row][col], len);
        }

        if (row == bottom_row)
        {
            break;
        }

        row = inc_row(row, 1);
    }

    if (pwdata->fGotFocus)
    {
        if ((pwdata->iNextCol >= pwdata->iFirstCol)
            && (row_diff(pwdata->iNextRow, pwdata->iTopRow) < pwdata->cRows))
        {
            if (pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = FALSE;
                ShowCaret(hwnd);
            }

            SetCaretPos(
                (pwdata->iNextCol - pwdata->iFirstCol) * pwdata->cxChar,
                calc_row(pwdata->iNextRow, pwdata) * pwdata->cyChar);
        }
        else
        {
            if (!pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = TRUE;
                HideCaret(hwnd);
            }
        }
    }

    EndPaint(hwnd, &ps);
}





//
//  FUNCTION:   WmPrintLine
//
//  PURPOSE:    Print a line on the screen.
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPrintLine(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pTermData)
{
    TCHAR *pBuf = (TCHAR *) lParam;

    // MessageBox(hwnd, L"WmPrintLine", L"Debug", MB_OK);

    // DebugBreak();

    while (wParam--)
    {
        // Is character a lf?
        if (*pBuf == '\n')
        {
            // Convert to cr since that is what this window uses
            *pBuf = '\r';
        }

        // Write the character to the window
        EchoChar(hwnd, 1, *pBuf++, pTermData);
    }

}

//
//  FUNCTION:   WmPutc
//
//  PURPOSE:    Print a single character on the screen
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPutc(
    HWND hwnd,
    WPARAM wParam,
    WData *pTermData)
{
    // Is character a lf?
    if (wParam == '\n')
    {
        // Convert to cr since that is what this window uses
        wParam = '\r';
    }

    // Write the character to the window
    EchoChar(hwnd, 1, wParam, pTermData);
}


/****************************************************************************

    FUNCTION: TermWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    COMMENTS:

****************************************************************************/

long TermWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    WData *pTerm = (WData *) GetWindowLong(hWnd, 0);

    switch (message)
    {
        case WM_CREATE:
            WmCreate(hWnd, (CREATESTRUCT *) lParam);
            break;

        case WM_COMMAND:
        case WM_SYSCOMMAND:
            // Call procedure that processes the menus
            return (*(pTerm->pMenuProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_SIZE:
            WmSize(hWnd, wParam, lParam, pTerm);
            break;

        case WM_SETFOCUS:
            WmSetFocus(hWnd, pTerm);
            break;

        case WM_KILLFOCUS:
            WmKillFocus(hWnd, pTerm);
            break;

        case WM_VSCROLL:
            WmVscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_HSCROLL:
            WmHscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_CHAR:
            // Character message echo and put in buffer
            return (*(pTerm->pCharProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PAINT:
            WmPaint(hWnd, pTerm);
            break;

        case WM_CLOSE:
	    DestroyWindow(hWnd);
            break;

        case WM_NCDESTROY:
            // Call close notification procedure
            return (*(pTerm->pCloseProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PRINT_LINE:
            WmPrintLine(hWnd, wParam, lParam, pTerm);
            break;

        case WM_PUTC:
            WmPutc(hWnd, wParam, pTerm);
	    break;

	case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

	case WM_TERM_WND:
	    DestroyWindow(hWnd);
	    break;

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return 0;
}


/****************************************************************************

    FUNCTION: TermRegisterClass(HANDLE)

    PURPOSE:  Register a class for a terminal window

    COMMENTS:


****************************************************************************/

BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR Icon)
{
    WNDCLASS  wc;
    BOOL retVal;

    // Make sure blank line is blank
    memset(BlankLine, ' ', 80);

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;
    wc.lpfnWndProc = TermWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(WData *);
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, Icon);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  MenuName;
    wc.lpszClassName = ClassName;

    /* Register the window class and return success/failure code. */
    if (retVal = RegisterClass(&wc))
    {
        // Class got registered -- so finish set up
        hInst = hInstance;
    }

    return retVal;
}


/****************************************************************************

    FUNCTION:  TermCreateWindow(LPWSTR, LPWSTR, HMENU, void *, void *, int)

    PURPOSE:   Create a window of a previously registered window class

    COMMENTS:


****************************************************************************/

BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData)
{
    HWND            hWnd;               // Main window handle.
    WData           *pTermData;

    // Allocate control structure for the window
    if ((pTermData = malloc(sizeof(WData))) == NULL)
    {
        return FALSE;
    }

    // Set entire structure to nulls
    memset((TCHAR *) pTermData, '\0', sizeof(WData));

    // Initialize function pointers
    pTermData->pMenuProc = MenuProc;
    pTermData->pCharProc = CharProc;
    pTermData->pCloseProc = CloseProc;

    // Initialize callback data
    pTermData->pvCallBackData = pvCallBackData;

    // Create a main window for this application instance.
    hWnd = CreateWindow(
        lpClassName,
        lpWindowName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        hMenu,
        hInst,
	(LPTSTR) pTermData
    );

    // If window could not be created, return "failure"

    if (!hWnd)
    {
        free(pTermData);
        return FALSE;
    }

    SetFocus(hWnd);

    // Make the window visible; update its client area; and return "success"

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
    *phNewWindow = hWnd;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\bookpart.h ===
#define SETDefFormatEtc(fe, cf, med)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=DVASPECT_CONTENT;\
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    };

#define DATASIZE_FROM_INDEX(i)  ((i) * 1024)


//Types that OLE2.H et. al. leave out
#ifndef LPLPVOID
typedef LPVOID FAR * LPLPVOID;
#endif  //LPLPVOID

#ifndef PPVOID  //Large model version
typedef LPVOID * PPVOID;
#endif  //PPVOID


EXTERN_C const GUID CDECL FAR CLSID_DataObjectTest32;
EXTERN_C const GUID CDECL FAR CLSID_DataObjectTest16;

#ifdef INIT_MY_GUIDS

    EXTERN_C const GUID CDECL
    CLSID_DataObjectTest32 = { /* ad562fd0-ac40-11ce-9d69-00aa0060f944 */
        0xad562fd0,
        0xac40,
        0x11ce,
        {0x9d, 0x69, 0x00, 0xaa, 0x00, 0x60, 0xf9, 0x44}
      };

    EXTERN_C const GUID CDECL
    CLSID_DataObjectTest16 = { /* ad562fd1-ac40-11ce-9d69-00aa0060f944 */
        0xad562fd1,
        0xac40,
        0x11ce,
        {0x9d, 0x69, 0x00, 0xaa, 0x00, 0x60, 0xf9, 0x44}
    };

#endif /* INITGUID */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\my3216.h ===
#ifndef MY3216_H
#define MY3216_H

#ifndef WIN32
    #define lstrcmpiA   lstrcmpi
    #define TEXT(a) (a)
    typedef TCHAR FAR * LPTSTR;
#endif

#endif // MY3216_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\syshead.h ===
#ifndef __SYSHEAD_H
#define __SYSHEAD_H

#define INC_OLE2
#include <windows.h>
#include <ole2.h>
#include <ole2ver.h>

#endif // __SYSHEAD_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\datausr.cpp ===
/*
 * DATAUSER.CPP
 * Data Object User Chapter 6
 *
 * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#define INIT_MY_GUIDS
#include "datausr.h"
#include "perror.h"
#include <stdio.h>

#ifdef WIN32
#define APP_TITLE TEXT("32 Bit IDataObject User")
#else
#define APP_TITLE TEXT("16 Bit IDataObject User")
#endif

//These are for displaying clipboard formats textually.
static TCHAR * rgszCF[13]={TEXT("Unknown"), TEXT("CF_TEXT")
                 , TEXT("CF_BITMAP"), TEXT("CF_METAFILEPICT")
                 , TEXT("CF_SYLK"), TEXT("CF_DIF"), TEXT("CF_TIFF")
                 , TEXT("CF_OEMTEXT"), TEXT("CF_DIB")
                 , TEXT("CF_PALETTE"), TEXT("CF_PENDATA")
                 , TEXT("CF_RIFF"), TEXT("CF_WAVE")};


static TCHAR szSuccess[]    =TEXT("succeeded");
static TCHAR szFailed[]     =TEXT("failed");
static TCHAR szExpected[]   =TEXT("expected");
static TCHAR szUnexpected[] =TEXT("unexpected!");

TCHAR tcMessageBuf[4096]; // Misc use buffer for messages.
int cKSizes[NUM_POINTS] = { 1,  2,  4,  6,  8,
                           10, 12, 16, 20, 24,
                           28, 32, 40, 48, 56 };

/*
 * WinMain
 *
 * Purpose:
 *  Main entry point of application.
 */

int PASCAL WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR pszCmdLine,
    int nCmdShow)
{
    MSG         msg;
    PAPPVARS    pAV;

#ifndef WIN32
    int         cMsg=96;

    while (!SetMessageQueue(cMsg) && (cMsg-=8));
#endif

    pAV=new CAppVars(hInst, hInstPrev, nCmdShow);

    if (NULL==pAV)
        return -1;

    if (pAV->FInit())
    {
        while (GetMessage(&msg, NULL, 0,0 ))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    delete pAV;
    return msg.wParam;
}




/*
 * DataUserWndProc
 *
 * Purpose:
 *  Window class procedure.  Standard callback.
 */

LRESULT API_ENTRY DataUserWndProc(HWND hWnd, UINT iMsg
    , WPARAM wParam, LPARAM lParam)
    {
    HRESULT         hr;
    PAPPVARS        pAV;
    HMENU           hMenu;
    FORMATETC       fe;
    WORD            wID;
    int             i;

    pAV=(PAPPVARS)GetWindowLong(hWnd, DATAUSERWL_STRUCTURE);

    switch (iMsg)
        {
        case WM_NCCREATE:
            pAV=(PAPPVARS)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLong(hWnd, DATAUSERWL_STRUCTURE, (LONG)pAV);
            return (DefWindowProc(hWnd, iMsg, wParam, lParam));

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_PAINT:
            pAV->Paint();
            break;

        case WM_COMMAND:
            SETDefFormatEtc(fe, 0, TYMED_HGLOBAL | TYMED_GDI| TYMED_MFPICT);

            hMenu=GetMenu(hWnd);
            wID=LOWORD(wParam);

            if(wID >= IDM_OBJECTSETDATA && wID <= IDM_OBJECTSETDATA+64)
            {
                // Blast all possible SetData menu items. Some don't exist.
                for(i=IDM_OBJECTSETDATA; i<=IDM_OBJECTSETDATA+64; i++)
                    CheckMenuItem(hMenu,i, MF_UNCHECKED);
                CheckMenuItem(hMenu, wID, MF_CHECKED);

                pAV->m_SetData_SetSize(wID-IDM_OBJECTSETDATA);
                break;
            }

            switch (wID)
            {
            case IDM_USE16BITSERVER:
                if (pAV->m_f16Bit)
                    break;
                pAV->m_f16Bit = TRUE;
                pAV->FReloadDataObjects(TRUE);
                break;

            case IDM_USE32BITSERVER:
                if (!pAV->m_f16Bit)
                    break;
                pAV->m_f16Bit = FALSE;
                pAV->FReloadDataObjects(TRUE);
                break;

            case IDM_OBJECTQUERYGETDATA:
                if (NULL==pAV->m_pIDataObject)
                    break;

                fe.tymed=TYMED_HGLOBAL | TYMED_GDI
                     | TYMED_MFPICT;

                pAV->TryQueryGetData(&fe, CF_TEXT, TRUE, 0);
                pAV->TryQueryGetData(&fe, CF_BITMAP, TRUE, 1);
#ifdef NOT_SIMPLE
                pAV->TryQueryGetData(&fe, CF_DIB, FALSE, 2);
                pAV->TryQueryGetData(&fe, CF_METAFILEPICT, TRUE, 3);
                pAV->TryQueryGetData(&fe, CF_WAVE, FALSE, 4);
#endif /* NOT_SIMPLE */
                break;


            case IDM_OBJECTGETDATA_TEXT:
            case IDM_OBJECTGETDATA_BITMAP:
#ifdef NOT_SIMPLE
            case IDM_OBJECTGETDATA_METAFILEPICT:
#endif /* NOT_SIMPLE */
                if (pAV->m_GetData(wID) )
                {
                    InvalidateRect(hWnd, NULL, TRUE);
                    UpdateWindow(hWnd);
                }

                if(pAV->m_fDisplayTime)
                    pAV->m_DisplayTimerResults();
                break;

            case IDM_OBJECTGETDATAHERE_TEXT:
            case IDM_OBJECTGETDATAHERE_NULLTEXT:
            case IDM_OBJECTGETDATAHERE_BITMAP:
            case IDM_OBJECTGETDATAHERE_NULLBITMAP:
                if (pAV->m_GetDataHere(wID) )
                {
                    InvalidateRect(hWnd, NULL, TRUE);
                    UpdateWindow(hWnd);
                }

                if(pAV->m_fDisplayTime)
                    pAV->m_DisplayTimerResults();
                break;

            case IDM_OBJECTSETDATAPUNK_TEXT:
            case IDM_OBJECTSETDATAPUNK_BITMAP:
                pAV->m_SetData_WithPUnk(wID);
                break;

            case IDM_MEASUREMENT_1:
            case IDM_MEASUREMENT_50:
            case IDM_MEASUREMENT_300:
            case IDM_MEASUREMENT_OFF:
            case IDM_MEASUREMENT_ON:
            case IDM_MEASUREMENT_TEST:
                pAV->m_SetMeasurement(wID);
                break;

            case IDM_BATCH_GETDATA:
                pAV->m_MeasureAllSizes(IDM_OBJECTGETDATA_TEXT,
                                    TEXT("GetData w/HGLOBAL"),
                                    NULL);
                break;

            case IDM_BATCH_GETDATAHERE:
                pAV->m_MeasureAllSizes(IDM_OBJECTGETDATAHERE_TEXT,
                                    TEXT("GetDataHere w/HGLOBAL"),
                                    NULL);
                break;

            case IDM_BATCHTOFILE:
                pAV->m_BatchToFile();
                break;

            case IDM_OBJECTEXIT:
                PostMessage(hWnd, WM_CLOSE, 0, 0L);
                break;

#ifdef NOT_SIMPLE
            case IDM_ADVISETEXT:
            case IDM_ADVISEBITMAP:
            case IDM_ADVISEMETAFILEPICT:
                if (NULL==pAV->m_pIDataObject)
                    break;

                //Terminate the old connection
                if (0!=pAV->m_dwConn)
                    {
                    pAV->m_pIDataObject->DUnadvise(pAV
                        ->m_dwConn);
                    }

                CheckMenuItem(hMenu, pAV->m_cfAdvise
                    +IDM_ADVISEMIN, MF_UNCHECKED);
                CheckMenuItem(hMenu, wID, MF_CHECKED);

                //New format is wID-IDM_ADVISEMIN
                pAV->m_cfAdvise=(UINT)(wID-IDM_ADVISEMIN);
                fe.cfFormat=pAV->m_cfAdvise;
                pAV->m_pIDataObject->DAdvise(&fe, ADVF_NODATA
                    , pAV->m_pIAdviseSink, &pAV->m_dwConn);

                break;

            case IDM_ADVISEGETDATA:
                pAV->m_fGetData=!pAV->m_fGetData;
                CheckMenuItem(hMenu, wID, pAV->m_fGetData
                    ? MF_CHECKED : MF_UNCHECKED);
                break;

            case IDM_ADVISEREPAINT:
                pAV->m_fRepaint=!pAV->m_fRepaint;
                CheckMenuItem(hMenu, wID, pAV->m_fRepaint
                    ? MF_CHECKED : MF_UNCHECKED);
                break;
#endif /* NOT_SIMPLE*/
            default:
                break;
            }
            break;

        default:
            return (DefWindowProc(hWnd, iMsg, wParam, lParam));
        }

    return 0L;
    }


/*
 * CAppVars::CAppVars
 * CAppVars::~CAppVars
 *
 * Constructor Parameters: (from WinMain)
 *  hInst           HINSTANCE of the application.
 *  hInstPrev       HINSTANCE of a previous instance.
 *  nCmdShow        UINT specifying how to show the app window.
 */

CAppVars::CAppVars(HINSTANCE hInst, HINSTANCE hInstPrev
    , UINT nCmdShow)
    {
    m_hInst       =hInst;
    m_hInstPrev   =hInstPrev;
    m_nCmdShow    =nCmdShow;

    m_hWnd        =NULL;
#ifdef NOT_SIMPLE
    m_fEXE        =FALSE;

    m_pIAdviseSink =NULL;
    m_dwConn       =0;
    m_cfAdvise     =0;
    m_fGetData     =FALSE;
    m_fRepaint     =FALSE;

    m_pIDataSmall =NULL;
    m_pIDataMedium=NULL;
    m_pIDataLarge =NULL;
#endif /* NOT_SIMPLE */
    m_pIDataObject=NULL;
    m_f16Bit=FALSE;
    m_cfFormat=0;
    m_stm.tymed=TYMED_NULL;
    m_stm.lpszFileName=NULL;      //Initializes union to NULL
    m_stm.pUnkForRelease=NULL;

    m_HereAllocCount=0; // For debugging

    m_fInitialized=FALSE;
    return;
    }



CAppVars::~CAppVars(void)
    {
    //This releases the data object interfaces and advises
    FReloadDataObjects(FALSE);

    ReleaseStgMedium(&m_stm);

#ifdef NOT_SIMPLE
    if (NULL!=m_pIAdviseSink)
        m_pIAdviseSink->Release();
#endif /* NOT_SIMPLE */

    if (IsWindow(m_hWnd))
        DestroyWindow(m_hWnd);

    if (m_fInitialized)
        CoUninitialize();

    return;
    }



/*
 * CAppVars::FInit
 *
 * Purpose:
 *  Initializes an CAppVars object by registering window classes,
 *  creating the main window, and doing anything else prone to
 *  failure such as calling CoInitialize.  If this function fails
 *  the caller should insure that the destructor is called.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 */

BOOL CAppVars::FInit(void)
    {
    WNDCLASS    wc;
    DWORD       dwVer;
    BOOL        fRet;

    dwVer=CoBuildVersion();

    if (rmm!=HIWORD(dwVer))
        return FALSE;

    if (FAILED(CoInitialize(NULL)))
        return FALSE;

    m_fInitialized=TRUE;

    //Register our window classes.
    if (!m_hInstPrev)
        {
        wc.style          = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc    = DataUserWndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = CBWNDEXTRA;
        wc.hInstance      = m_hInst;
        wc.hIcon          = LoadIcon(m_hInst, TEXT("Icon"));
        wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU);
        wc.lpszClassName  = TEXT("DATAUSER");

        if (!RegisterClass(&wc))
            return FALSE;
        }

    //Create the main window.
    m_hWnd=CreateWindow(TEXT("DATAUSER"),
                        APP_TITLE,
                        WS_OVERLAPPEDWINDOW,
                        35, 35, 350, 250,
                        NULL, NULL,
                        m_hInst, this);

    if (NULL==m_hWnd)
        return FALSE;

    ShowWindow(m_hWnd, m_nCmdShow);
    UpdateWindow(m_hWnd);

    m_iDataSizeIndex=1;
    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTSETDATA+1, MF_CHECKED);
    for(int i=0; i<64; i++)
        m_hgHereBuffers[i] = NULL;

    m_cIterations = 1;
    CheckMenuItem(GetMenu(m_hWnd), IDM_MEASUREMENT_1,   MF_CHECKED);

    m_fDisplayTime = FALSE;
    CheckMenuItem(GetMenu(m_hWnd), IDM_MEASUREMENT_OFF, MF_CHECKED);

#ifdef NOT_SIMPLE
    m_pIAdviseSink=new CImpIAdviseSink(this);

    if (NULL==m_pIAdviseSink)
        return FALSE;

    m_pIAdviseSink->AddRef();

    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTUSEDLL, MF_CHECKED);
    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTDATASIZESMALL
        , MF_CHECKED);
#endif /* NOT_SIMPLE */

    //Load the initial objects
    fRet=FReloadDataObjects(TRUE);
#ifdef NOT_SIMPLE
    m_pIDataObject=m_pIDataSmall;
#endif /* NOT_SIMPLE */

    m_swTimer.m_ClassInit();

    return fRet;
    }


/*
 * CAppVars::FReloadDataObjects
 *
 * Purpose:
 *  Releases the old data objects we're holding on to and reloads
 *  the new ones from either EXE or DLL depending on m_fEXE.
 *
 * Parameters:
 *  fReload         BOOL indicating if we are to recreate everything
 *                  or just release the old ones (so we can use this
 *                  from the destructor).
 *
 * Return Value:
 *  BOOL            TRUE if there are usable objects in us now.
 */

BOOL CAppVars::FReloadDataObjects(BOOL fReload)
    {
    HCURSOR     hCur, hCurT;

    //Clean out any data we're holding
    m_cfFormat=0;
    ReleaseStgMedium(&m_stm);

    //Turn off whatever data connection we have
#ifdef NOT_SIMPLE
    if (NULL!=m_pIDataObject && 0!=m_dwConn)
        m_pIDataObject->DUnadvise(m_dwConn);

    if (NULL!=m_pIDataLarge)
        m_pIDataLarge->Release();

    if (NULL!=m_pIDataMedium)
        m_pIDataMedium->Release();

    if (NULL!=m_pIDataSmall)
        m_pIDataSmall->Release();
#else /* IS SIMPLE */
    if (NULL != m_pIDataObject)
        m_pIDataObject->Release();
#endif /* NOT_SIMPLE */

    m_pIDataObject=NULL;
    CoFreeUnusedLibraries();

    //Exit if we just wanted to free.
    if (!fReload)
        return FALSE;


    hCur=LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
    hCurT=SetCursor(hCur);
    ShowCursor(TRUE);

#ifdef NOT_SIMPLE
    HRESULT     hr1, hr2, hr3;
    DWORD       dwClsCtx;

    dwClsCtx=(m_fEXE) ? CLSCTX_LOCAL_SERVER : CLSCTX_INPROC_SERVER;

    hr1=CoCreateInstance(CLSID_DataObjectSmall, NULL, dwClsCtx
        , IID_IDataObject, (PPVOID)&m_pIDataSmall);

    hr2=CoCreateInstance(CLSID_DataObjectMedium, NULL, dwClsCtx
        , IID_IDataObject, (PPVOID)&m_pIDataMedium);

    hr3=CoCreateInstance(CLSID_DataObjectLarge, NULL, dwClsCtx
        , IID_IDataObject, (PPVOID)&m_pIDataLarge);
#else /* IS SIMPLE */
    HRESULT     hr;

    if(m_f16Bit)
    {
        hr = CoCreateInstance(CLSID_DataObjectTest16,
                                NULL,
                                CLSCTX_LOCAL_SERVER,
                                IID_IDataObject,
                                (PPVOID)&m_pIDataObject);
    }else
    {
        hr = CoCreateInstance(CLSID_DataObjectTest32,
                                NULL,
                                CLSCTX_LOCAL_SERVER,
                                IID_IDataObject,
                                (PPVOID)&m_pIDataObject);
    }

#endif /* NOT_SIMPLE */

    ShowCursor(FALSE);
    SetCursor(hCurT);

    //If anything fails, recurse to clean up...
#ifdef NOT_SIMPLE
    if (FAILED(hr1) || FAILED(hr2) || FAILED(hr3))
#else /* IS SIMPLE */
    if (FAILED(hr))
#endif /* NOT_SIMPLE */
    {
        perror_OKBox(0, TEXT("CoCreateInstance Failed: "), hr);
        return FReloadDataObjects(FALSE);
    }

    HMENU hMenu = GetMenu(m_hWnd);
    UINT        uTempD, uTempE;

    if(m_f16Bit)
    {
        CheckMenuItem(hMenu, IDM_USE16BITSERVER, MF_CHECKED);
        CheckMenuItem(hMenu, IDM_USE32BITSERVER, MF_UNCHECKED);
    }
    else
    {
        CheckMenuItem(hMenu, IDM_USE16BITSERVER, MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_USE32BITSERVER, MF_CHECKED);
    }


    hMenu=GetMenu(m_hWnd);
    for(int i=IDM_OBJECTSETDATA; i<=IDM_OBJECTSETDATA+64; i++)
    {
        CheckMenuItem(hMenu, i, MF_UNCHECKED);
    }
    m_iDataSizeIndex = 1;
    CheckMenuItem(hMenu,
                  IDM_OBJECTSETDATA + m_iDataSizeIndex,
                  MF_CHECKED);

    //Reset the state of the menus for Small, no advise, no options.
#ifdef NOT_SIMPLE
    CheckMenuItem(hMenu, IDM_OBJECTDATASIZESMALL,  MF_CHECKED);
    CheckMenuItem(hMenu, IDM_OBJECTDATASIZEMEDIUM, MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_OBJECTDATASIZELARGE,  MF_UNCHECKED);

    m_pIDataObject=m_pIDataSmall;
    CheckMenuItem(hMenu, m_cfAdvise+IDM_ADVISEMIN, MF_UNCHECKED);

    uTempE=m_fEXE  ? MF_CHECKED : MF_UNCHECKED;
    uTempD=!m_fEXE ? MF_CHECKED : MF_UNCHECKED;

    CheckMenuItem(hMenu, IDM_OBJECTUSEDLL, uTempD);
    CheckMenuItem(hMenu, IDM_OBJECTUSEEXE, uTempE);

    CheckMenuItem(hMenu, IDM_ADVISEGETDATA, MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_ADVISEREPAINT, MF_UNCHECKED);

    m_fGetData=FALSE;
    m_fRepaint=FALSE;

    //Cannot request data using async advises, so disable these.
    uTempE=m_fEXE  ? MF_DISABLED | MF_GRAYED : MF_ENABLED;
    EnableMenuItem(hMenu,  IDM_ADVISEGETDATA, uTempE);
    EnableMenuItem(hMenu, IDM_ADVISEREPAINT, uTempE);
#endif /* NOT_SIMPLE */
    return TRUE;
    }



/*
 * CAppVars::TryQueryGetData
 *
 * Purpose:
 *  Centralized function call and output code for displaying results
 *  of various IDataObject::QueryGetData calls.
 *
 * Parameters:
 *  pFE             LPFORMATETC to test.
 *  cf              UINT specific clipboard format to stuff in pFE
 *                  before calling.  If zero, use whatever is
 *                  already in pFE.
 *  fExpect         BOOL indicating expected results
 *  y               UINT line on which to print results.
 *
 * Return Value:
 *  None
 */

void CAppVars::TryQueryGetData(LPFORMATETC pFE, UINT cf
    , BOOL fExpect, UINT y)
    {
    TCHAR       szTemp[80];
    LPTSTR      psz1;
    LPTSTR      psz2;
    UINT        cch;
    HRESULT     hr;
    HDC         hDC;

    if (0!=cf)
        pFE->cfFormat=cf;

    hr=m_pIDataObject->QueryGetData(pFE);
    psz1=(NOERROR==hr) ? szSuccess : szFailed;
    psz2=((NOERROR==hr)==fExpect) ? szExpected : szUnexpected;

    hDC=GetDC(m_hWnd);
    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hDC, GetSysColor(COLOR_WINDOW));

    if (CF_WAVE < cf || 0==cf)
        {
        cch=wsprintf(szTemp, TEXT("QueryGetData on %d %s (%s).")
            , cf, psz1, psz2);
        }
    else
        {
        cch=wsprintf(szTemp, TEXT("QueryGetData on %s %s (%s).")
            , (LPTSTR)rgszCF[cf], psz1, psz2);
        }

    //Don't overwrite other painted display.
    SetBkMode(hDC, TRANSPARENT);
    TextOut(hDC, 0, 16*y, szTemp, cch);

    ReleaseDC(m_hWnd, hDC);

    return;
    }


int
CAppVars::m_GetData(WORD wID)
{
    FORMATETC   fe;
    HRESULT     hr;

    if (NULL == m_pIDataObject)
        return(0);  // Don't redraw.

    //Clean up whatever we currently have.
    m_cfFormat = 0;
    ReleaseStgMedium(&m_stm);

    switch (wID)
    {
    case IDM_OBJECTGETDATA_TEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);
        break;

#ifdef NOT_SIMPLE
    case IDM_OBJECTGETDATA_BITMAP:
        SETDefFormatEtc(fe, CF_BITMAP, TYMED_GDI);
        break;

    case IDM_OBJECTGETDATA_METAFILEPICT:
        SETDefFormatEtc(fe, CF_METAFILEPICT, TYMED_MFPICT);
        break;
#endif /* NOT_SIMPLE */

    default:
        MessageBox(0,
                   TEXT("Type is Unsupported in the Client"),
                   TEXT("GetData"),
                   MB_OK);
        return(0);
    }

    m_swTimer.m_Start();
    HRESULT didfail = NOERROR;

    for(int i=0; i<m_cIterations; i++)
    {
        hr = m_pIDataObject->GetData(&fe, &m_stm);
        if (SUCCEEDED(hr))
        {
            // If we are just whacking off for the benchmark.
            // Then release all but the last one we recieve.
            if(i < m_cIterations-1)
                ReleaseStgMedium(&m_stm);
        }
        else
            didfail = hr;
    }
    m_swTimer.m_Stop();

    if (SUCCEEDED(didfail))
        m_cfFormat=fe.cfFormat;
    else
    {
        perror_OKBox(0,
                     TEXT("GetData Failed"),
                     didfail);
    }

    return(1);  // Do redraw even if it failed (draw blank).
}


int
CAppVars::m_GetDataHere(WORD wID)
{
    FORMATETC   fe;
    HRESULT     hr;

    if(NULL == m_pIDataObject)
        return(0);      // Don't redraw

    m_cfFormat = 0;

    // Don't Release the STGMedium.  We recycle them!

    switch(wID)
    {
    case IDM_OBJECTGETDATAHERE_TEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);
        break;

    case IDM_OBJECTGETDATAHERE_NULLTEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_NULL);
        break;

        /* Other cases go here....  */

    default:
        MessageBox(0,
                   TEXT("Type is Unsupported in the Client"),
                   TEXT("GetDataHere"),
                   MB_OK);
        return(0);
    }

    HGLOBAL* phg = &m_hgHereBuffers[m_iDataSizeIndex];
    if(NULL == *phg)
    {
        ++m_HereAllocCount;
        *phg = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                           DATASIZE_FROM_INDEX(m_iDataSizeIndex) );
        if(NULL == *phg)
        {
            MessageBox(0,
                       TEXT("GlobalAlloc Return NULL"),
                       TEXT("Failure"),
                       MB_OK);
            PostQuitMessage(0);
            return(0);      // Don't redraw
        }
    }

    m_stm.hGlobal=*phg;
    m_stm.tymed=TYMED_HGLOBAL;
    m_stm.pUnkForRelease=NULL;

    // The TYMED_NULL case tests code in olethk where it is written:
    // "If tymed == TYMED_NULL then GetDataHere should behave like GetData."
    // I can't find this in any manual (OLE2 or Ole).  I wanted to see what
    // good that code was.  (there is also bug #15974) Aug 8th 1995 BChapman.

    if (IDM_OBJECTGETDATAHERE_NULLTEXT == wID)
    {
        m_stm.hGlobal=NULL;
        m_stm.tymed=TYMED_NULL;
    }

    // The other side "knows" the size of the data.
    // (It is told via. SetData)

    HRESULT didfail = NOERROR;
    m_swTimer.m_Start();
    for(int i=0; i<m_cIterations; i++)
    {
        hr = m_pIDataObject->GetDataHere(&fe, &m_stm);
        if (FAILED(hr))
            didfail = hr;
        // We don't ReleaseSTGMedium because this
        // is GetDataHere !
    }
    m_swTimer.m_Stop();

    if (SUCCEEDED(didfail))
        m_cfFormat=fe.cfFormat;
    else
    {
        perror_OKBox(0,
                     TEXT("GetDataHere Failed"),
                     didfail);
    }
    return(1);  // redraw (if FAILED(hr) then draw blank)
}


int
CAppVars::m_SetData_SetSize(long iSizeIndex)
{
    FORMATETC   fe;
    HRESULT     hr;

    if (NULL == m_pIDataObject)
        return 0;

    SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);

    m_iDataSizeIndex = iSizeIndex;

    HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(ULONG) );
    if(NULL == hMem)
    {
        MessageBox(0,
                   TEXT("GlobalAlloc Return NULL"),
                   TEXT("Failure"),
                   MB_OK);
        PostQuitMessage(0);
        return 0;
    }

    long* pl=(long*)GlobalLock(hMem);       // Lock
    *((long*)pl) = DATASIZE_FROM_INDEX(m_iDataSizeIndex);
    GlobalUnlock(hMem);                     // Unlock

    m_stm.hGlobal=hMem;
    m_stm.tymed=TYMED_HGLOBAL;
    m_stm.pUnkForRelease=NULL;

    hr = m_pIDataObject->SetData(&fe, &m_stm, FALSE);   // Keep Ownership.
    if (FAILED(hr))
    {
        perror_OKBox(0,
                     TEXT("SetData Failed"),
                     hr);
        return 0;
    }
    return 1;;
    // release the hMem HGLOBAL perhaps ???
}


int
CAppVars::m_SetData_WithPUnk(WORD wID)
{
    FORMATETC   fe;
    HRESULT     hr;

    if(NULL == m_pIDataObject)
        return 0;

    switch(wID)
    {
    case IDM_OBJECTSETDATAPUNK_TEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);
        break;

        /* Other cases go here....  */

    default:
        MessageBox(0,
                   TEXT("Type is Unsupported in the Client"),
                   TEXT("SetData"),
                   MB_OK);
        return(0);
    }

    HGLOBAL hMem=GlobalAlloc( GMEM_SHARE | GMEM_MOVEABLE, sizeof(ULONG) );
    if(NULL == hMem)
    {
        MessageBox(0,
                   TEXT("GlobalAlloc Return NULL"),
                   TEXT("Failure"),
                   MB_OK);
        PostQuitMessage(0);
        return 0;
    }

    long* pl=(long*)GlobalLock(hMem);   // Lock
    *((long*)pl) = 0xffffffff;          // Use
    GlobalUnlock(hMem);                 // Unlock


    m_stm.hGlobal=hMem;
    m_stm.tymed=TYMED_HGLOBAL;
    hr = GetStgMedpUnkForRelease(&m_stm.pUnkForRelease);
    if(NOERROR != hr)
    {
        perror_OKBox(0, TEXT("Can't get pUnk For Release"), hr);
    }

    hr = m_pIDataObject->SetData(&fe, &m_stm, TRUE);   // Pass Ownership.
    // We passed ownership so SetData took the HGLOBAL from us.
    if (FAILED(hr))
    {
        perror_OKBox(0,
                     TEXT("SetData Failed"),
                     hr);
        return 0;
    }
    return 1;
}

#define NUM_RUNS 5


void
CAppVars::m_BatchToFile()
{
    dataset_t dsGetDataText;
    dataset_t dsGetDataHereText;

    pm_ClearDataset(&dsGetDataText);
    pm_ClearDataset(&dsGetDataHereText);

    int iRun;
    for(iRun=0; iRun < NUM_RUNS; iRun++)
    {
        m_MeasureAllSizes(IDM_OBJECTGETDATA_TEXT,
                          NULL,
                          &dsGetDataText);
        m_MeasureAllSizes(IDM_OBJECTGETDATAHERE_TEXT,
                          NULL,
                          &dsGetDataHereText);
    }

    FILE *fp;
    int i;
    if(NULL == (fp = fopen(FILENAME, "w")))
    {
        MessageBox(0, TEXT("Cannot Open Output File"),
                      TEXT(FILENAME),
                      MB_OK | MB_ICONSTOP);
        return;
    }

    fprintf(fp, "           GetData w/ HGLOBAL    GetDataHere w/ HGLOBAL\n");
    fprintf(fp, " Size      Best   Worst Average   Best    Worst Average\n");
    for (i=0; i<NUM_POINTS; i++)
    {
        fprintf(fp, "%5d\t", cKSizes[i]);
#define PR_TIME(fp, v)    (fprintf(fp, "%3lu.%03lu\t", (v)/1000, (v)%1000))

        PR_TIME(fp, dsGetDataText.cBest[i]);
        PR_TIME(fp, dsGetDataText.cWorst[i]);
        PR_TIME(fp, dsGetDataText.cTotal[i]/NUM_RUNS);
        PR_TIME(fp, dsGetDataHereText.cBest[i]);
        PR_TIME(fp, dsGetDataHereText.cWorst[i]);
        PR_TIME(fp, dsGetDataHereText.cTotal[i]/NUM_RUNS);
        fprintf(fp, "\n");
    }
    fclose(fp);

    MessageBox(0, TEXT("Output Written to file.dat!"),
                  TEXT("Done"), MB_OK);
}

void
CAppVars::pm_ClearDataset(dataset_t *ds)
{
    int i;
    for(i=0; i<NUM_POINTS; i++)
    {
        ds->cTotal[i] = 0;
        ds->cBest[i] = 0xFFFFFFFF;
        ds->cWorst[i] = 0;
    }
}


void
CAppVars::m_MeasureAllSizes(
    WORD wID,
    LPTSTR tstrTitle,
    dataset_t *ds)
{
    int i;
    ULONG cUSecs[NUM_POINTS];

    // Save some state.
    ULONG iOldDataSizeIndex = m_iDataSizeIndex;

    for (i=0; i<NUM_POINTS; i++)
    {
        m_SetData_SetSize(cKSizes[i]);

        switch(wID)
        {
            case IDM_OBJECTGETDATA_TEXT:
            case IDM_OBJECTGETDATA_BITMAP:
                m_GetData(wID);
                break;

            case IDM_OBJECTGETDATAHERE_TEXT:
            case IDM_OBJECTGETDATAHERE_BITMAP:
                m_GetDataHere(wID);
                break;
        }
        m_swTimer.m_Read(&cUSecs[i]);
        cUSecs[i] /= m_cIterations;
    }

    // Restore save state.
    m_iDataSizeIndex = iOldDataSizeIndex;
    m_SetData_SetSize(m_iDataSizeIndex);


    // If the caller provided memory then return the data in it.
    if(NULL != ds)
    {
        for (i=0; i<NUM_POINTS; i++)
        {
            ds->cData[i] = cUSecs[i];
            ds->cTotal[i] += cUSecs[i];

            if(ds->cBest[i] > cUSecs[i])
                ds->cBest[i] = cUSecs[i];
            if( ds->cWorst[i] < cUSecs[i])
                ds->cWorst[i] = cUSecs[i];
        }
    }

    // If the caller passed a NULL Title then no message box.
    if(NULL == tstrTitle)
        return;

    // Render Results.
    LPTSTR tstr = &tcMessageBuf[0];
    for (i=0; i<NUM_POINTS; i++)
    {
        wsprintf(tstr, TEXT("%dK: %lu.%03lu%c"),
                        cKSizes[i], cUSecs[i]/1000, cUSecs[i]%1000,
                        (i%4==3)? TEXT('\n'):TEXT('\t') );
        tstr += lstrlen(tstr);
    }
    MessageBox(0, tcMessageBuf, tstrTitle, MB_OK);
}



void
CAppVars::m_SetMeasurement(WORD wID)
{
    HMENU hMenu=GetMenu(m_hWnd);
    switch (wID)
    {
    case IDM_MEASUREMENT_ON:
        m_fDisplayTime = TRUE;
        CheckMenuItem(hMenu, IDM_MEASUREMENT_ON,  MF_CHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_OFF, MF_UNCHECKED);
        break;

    case IDM_MEASUREMENT_OFF:
        m_fDisplayTime = FALSE;
        CheckMenuItem(hMenu, IDM_MEASUREMENT_ON,  MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_OFF, MF_CHECKED);
        break;


    case IDM_MEASUREMENT_1:
        m_cIterations = 1;
        goto set_menu;
    case IDM_MEASUREMENT_50:
        m_cIterations = 50;
        goto set_menu;
    case IDM_MEASUREMENT_300:
        m_cIterations = 300;
        goto set_menu;
set_menu:
        CheckMenuItem(hMenu, IDM_MEASUREMENT_1,   MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_50,  MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_300, MF_UNCHECKED);
        CheckMenuItem(hMenu, wID, MF_CHECKED);
        break;


    case IDM_MEASUREMENT_TEST:
        m_swTimer.m_Start();
        m_swTimer.m_Sleep(777);
        m_swTimer.m_Stop();
        m_DisplayTimerResults();
        break;
    }
}

void
CAppVars::m_DisplayTimerResults()
{
    ULONG usecs;
    m_swTimer.m_Read(&usecs);
    usecs /= m_cIterations;
    wprintf_OKBox(0, TEXT("MilliSeconds"),
                     TEXT("%lu.%03lu"),
                     usecs/1000, usecs%1000);
}


/*
 * CAppVars::Paint
 *
 * Purpose:
 *  Handles WM_PAINT for the main window by drawing whatever
 *  data we have sitting in the STGMEDIUM at this time.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CAppVars::Paint(void)
    {
    PAINTSTRUCT     ps;
    HDC             hDC;
#ifdef NOT_SIMPLE
    HDC             hMemDC;
    LPMETAFILEPICT  pMF;
#endif /* NOT_SIMPLE */
    LPTSTR          psz;
    RECT            rc;
    FORMATETC       fe;

    GetClientRect(m_hWnd, &rc);

    hDC=BeginPaint(m_hWnd, &ps);

    //May need to retrieve the data with EXE objects
#ifdef NOT_SIMPLE
    if (m_fEXE)
        {
        if (TYMED_NULL==m_stm.tymed && 0!=m_cfFormat)
            {
            SETDefFormatEtc(fe, m_cfFormat, TYMED_HGLOBAL
                | TYMED_MFPICT | TYMED_GDI);

            if (NULL!=m_pIDataObject)
                m_pIDataObject->GetData(&fe, &m_stm);
            }
        }
#endif /* NOT_SIMPLE */

    switch (m_cfFormat)
        {
        case CF_TEXT:
            psz=(LPTSTR)GlobalLock(m_stm.hGlobal);

            if (NULL==psz)
                break;

            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(hDC, GetSysColor(COLOR_WINDOW));

            pm_DrawText(hDC, psz, &rc, DT_LEFT | DT_WORDBREAK);

            GlobalUnlock(m_stm.hGlobal);
            break;

#ifdef NOT_SIMPLE
        case CF_BITMAP:
            hMemDC=CreateCompatibleDC(hDC);

            if (NULL!=SelectObject(hMemDC, (HGDIOBJ)m_stm.hGlobal))
                {
                BitBlt(hDC, 0, 0, rc.right-rc.left, rc.bottom-rc.top
                    , hMemDC, 0, 0, SRCCOPY);
                }

            DeleteDC(hMemDC);
            break;

        case CF_METAFILEPICT:
            pMF=(LPMETAFILEPICT)GlobalLock(m_stm.hGlobal);

            if (NULL==pMF)
                break;

            SetMapMode(hDC, pMF->mm);
            SetWindowOrgEx(hDC, 0, 0, NULL);
            SetWindowExtEx(hDC, pMF->xExt, pMF->yExt, NULL);

            SetViewportExtEx(hDC, rc.right-rc.left
                , rc.bottom-rc.top, NULL);

            PlayMetaFile(hDC, pMF->hMF);
            GlobalUnlock(m_stm.hGlobal);
            break;

#else /* IS SIMPLE */
        case CF_BITMAP:
        case CF_METAFILEPICT:
            DebugBreak();
            break;

#endif /* NOT_SIMPLE */

        default:
            break;
        }

    EndPaint(m_hWnd, &ps);
    return;
    }


void
CAppVars::pm_DrawText(
    HDC hDC,
    LPTSTR psz,
    RECT* prc,
    UINT flags)
{
    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hDC, GetSysColor(COLOR_WINDOW));

// If we are WIN32 and the server is 16 bits this must be ASCII.
#ifdef WIN32
    if(m_f16Bit)
        DrawTextA(hDC, (char*)psz, -1, prc, flags);
    else
#endif
        DrawText(hDC, psz, -1, prc, flags);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\datausr.h ===
/*
 * DATAUSER.H
 * Data Object User Chapter 6
 *
 * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#ifndef _DATAUSER_H_
#define _DATAUSER_H_

#include "../syshead.h"
#include "../my3216.h"
#include "../bookpart.h"
#include "stpwatch.h"


//Menu Resource ID and Commands
#define IDR_MENU                    1


// #define IDM_OBJECTUSEDLL                100
// #define IDM_OBJECTUSEEXE                101
// #define IDM_OBJECTDATASIZESMALL         102
// #define IDM_OBJECTDATASIZEMEDIUM        103
// #define IDM_OBJECTDATASIZELARGE         104
#define IDM_OBJECTQUERYGETDATA          105
#define IDM_OBJECTGETDATA_TEXT           106
#define IDM_OBJECTGETDATA_BITMAP         107
// #define IDM_OBJECTGETDATA_METAFILEPICT   108
#define IDM_OBJECTEXIT                  109

#define IDM_OBJECTGETDATAHERE_TEXT         110
#define IDM_OBJECTGETDATAHERE_BITMAP       111
#define IDM_OBJECTGETDATAHERE_NULLTEXT         112
#define IDM_OBJECTGETDATAHERE_NULLBITMAP       113

#define IDM_USE16BITSERVER              120
#define IDM_USE32BITSERVER              121

#define IDM_OBJECTGETCANON              122

// Reserve Range..
#define IDM_OBJECTSETDATA             400
//      ....
// reserved through 464

#define IDM_OBJECTSETDATAPUNK_TEXT       500
#define IDM_OBJECTSETDATAPUNK_BITMAP     501


#define IDM_MEASUREMENT_1               140
#define IDM_MEASUREMENT_50              141
#define IDM_MEASUREMENT_300             142

#define IDM_MEASUREMENT_OFF             145
#define IDM_MEASUREMENT_ON              146
#define IDM_MEASUREMENT_TEST            147

#define IDM_BATCHTOFILE                 150
#define IDM_BATCH_GETDATA               151
#define IDM_BATCH_GETDATAHERE           152

// #define IDM_ADVISEMIN                   200
// #define IDM_ADVISETEXT                  (IDM_ADVISEMIN+CF_TEXT)
// #define IDM_ADVISEBITMAP                (IDM_ADVISEMIN+CF_BITMAP)
// #define IDM_ADVISEMETAFILEPICT          (IDM_ADVISEMIN+CF_METAFILEPICT)
// #define IDM_ADVISEGETDATA               300
// #define IDM_ADVISEREPAINT               301


#ifdef WIN32
 #define API_ENTRY  APIENTRY
#else
 #define API_ENTRY  FAR PASCAL _export
#endif

//DATAUSER.CPP
LRESULT API_ENTRY DataUserWndProc(HWND, UINT, WPARAM, LPARAM);


class CImpIAdviseSink;
typedef class CImpIAdviseSink *PIMPIADVISESINK;



#define FILENAME "time.dat"
#define NUM_POINTS  15

typedef struct {
    ULONG cData[NUM_POINTS];
    ULONG cBest[NUM_POINTS];
    ULONG cWorst[NUM_POINTS];
    ULONG cTotal[NUM_POINTS];
} dataset_t;




/*
 * Application-defined classes and types.
 */

class CAppVars
    {
    friend LRESULT API_ENTRY DataUserWndProc(HWND, UINT, WPARAM, LPARAM);

    friend class CImpIAdviseSink;

    protected:
        HINSTANCE       m_hInst;            //WinMain parameters
        HINSTANCE       m_hInstPrev;
        UINT            m_nCmdShow;

        HWND            m_hWnd;             //Main window handle
//        BOOL            m_fEXE;             //For tracking menu

//        PIMPIADVISESINK m_pIAdviseSink;     //Our CImpIAdviseSink
//        DWORD           m_dwConn;           //Advise connection
//        UINT            m_cfAdvise;         //Advise format
//        BOOL            m_fGetData;         //GetData on data change?
//        BOOL            m_fRepaint;         //Repaint on data change?

//        LPDATAOBJECT    m_pIDataSmall;
//        LPDATAOBJECT    m_pIDataMedium;
//        LPDATAOBJECT    m_pIDataLarge;

        LPDATAOBJECT    m_pIDataObject;     //Current selection
        UINT            m_f16Bit;
        UINT            m_cfFormat;
        STGMEDIUM       m_stm;              //Current rendering

        BOOL            m_fInitialized;     //Did CoInitialize work?

        ULONG           m_iDataSizeIndex;
        HGLOBAL         m_hgHereBuffers[64];
        BOOL            m_fDisplayTime;
        LONG            m_cIterations;
        StopWatch_cl    m_swTimer;

        int             m_HereAllocCount; // For debugging.

    public:
        CAppVars(HINSTANCE, HINSTANCE, UINT);
        ~CAppVars(void);
        BOOL FInit(void);
        BOOL FReloadDataObjects(BOOL);
        void TryQueryGetData(LPFORMATETC, UINT, BOOL, UINT);
        void Paint(void);

        int  m_GetDataHere(WORD wID);
        int  m_GetData(WORD wID);
        int  m_SetData_SetSize(long iSizeIndex);
        int  m_SetData_WithPUnk(WORD wID);
        void m_SetMeasurement(WORD wID);
        void m_MeasureAllSizes(WORD wID, LPTSTR title, dataset_t *);

        void m_BatchToFile();
        void m_DisplayTimerResults();

    private:
        void pm_DrawText(HDC hDc, LPTSTR psz, RECT* prc, UINT flags);
        void pm_ClearDataset(dataset_t *);

    };


typedef CAppVars *PAPPVARS;

#define CBWNDEXTRA               sizeof(PAPPVARS)
#define DATAUSERWL_STRUCTURE     0


//This lives with the app to get OnDataChange notifications.

class CImpIAdviseSink : public IAdviseSink
    {
    protected:
        ULONG               m_cRef;
        PAPPVARS            m_pAV;

    public:
        CImpIAdviseSink(PAPPVARS);
        ~CImpIAdviseSink(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //We only implement OnDataChange for now.
        STDMETHODIMP_(void)  OnDataChange(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP_(void)  OnViewChange(DWORD, LONG);
        STDMETHODIMP_(void)  OnRename(LPMONIKER);
        STDMETHODIMP_(void)  OnSave(void);
        STDMETHODIMP_(void)  OnClose(void);
    };



//////////////////////////////////////////////////////////////////////////////
// Storage Medium IUnknown interface for pUnkForRelease.
//

class CStgMedIf: public IUnknown {
private:
    ULONG m_cRef;
public:
    CStgMedIf();
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
};

//////////////////////////
// API for getting a pUnkForRelease.
//

HRESULT GetStgMedpUnkForRelease(IUnknown **pp_unk);

#endif //_DATAUSER_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\perror.h ===
#include "../my3216.h"

/*
 * winErrorString: Write the text of an HRESULT into a supplied buffer.
 */
LPTSTR
winErrorString(
    HRESULT hrErrorCode,
    LPTSTR  sBuf,
    int     cBufSize);

/*
 * print_error:  Print a mesage and the text of an HRESULT .
 */
void
print_error(
    LPTSTR  sMessage,
    HRESULT hrErrorCode);

/*
 * perror_OKBox: Write the text of an HRESULT in a MessageBox.
 */
void
perror_OKBox(
    HWND    hwnd,
    LPTSTR  sTitle,
    HRESULT hrErrorCode);
/*
 * wprintf_OKBox: printf into a MessageBox.
 */
void
wprintf_OKBox(
    HWND   hwnd,
    LPTSTR sTitle,
    LPTSTR sFormat,
    ...);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\stgmedif.cpp ===
#include "datausr.h"

HRESULT
GetStgMedpUnkForRelease(IUnknown **pp_unk)
{
    CStgMedIf *p_smi = new CStgMedIf();
    HRESULT hr = p_smi->QueryInterface(IID_IUnknown, (PPVOID)pp_unk);
    return hr;
}

CStgMedIf::CStgMedIf()
{
    m_cRef = 0;
}


STDMETHODIMP
CStgMedIf::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPVOID)this;
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CStgMedIf::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CStgMedIf::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0==cRefT)
    {
        TCHAR chBuf[80];

        wsprintf(chBuf, TEXT("Reference Count is %d"), cRefT);
        MessageBox(0,
                   chBuf,
                   TEXT("STGMED pUnkForRelease"),
                   MB_OK);
        delete this;
    }
    return cRefT;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\perror.cpp ===
// This is functions used by both the
// the client and the server programs

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdarg.h>
#include "perror.h"

LPTSTR
winErrorString(
    HRESULT hrErrorCode,
    LPTSTR sBuf,
    int cBufSize)
{
#ifdef WIN32
    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  hrErrorCode,
                  GetSystemDefaultLangID(),
                  sBuf,
                  cBufSize,
                  NULL);
#else
    wsprintf(sBuf, "\"0x%08x\"\n", hrErrorCode);
#endif // WIN32
    return sBuf;
}

#define PBUF_LEN    200

#if 0 // I'm not linking with "printf" currently.
void
print_error(
    LPTSTR sMessage,
    HRESULT hrErrorCode)
{
    TCHAR sBuf[PBUF_LEN];

    winErrorString(hrErrorCode, sMessage, PBUF_LEN);
#ifdef WIN32
    printf("%s(0x%x)%s", sMessage, hrErrorCode, sBuf);
#else
    printf("%s%s", sMessage, sBuf);
#endif
}
#endif

void
perror_OKBox(
    HWND hwnd,
    LPTSTR sTitle,
    HRESULT hrErrorCode)
{
    TCHAR sBuf[PBUF_LEN];
    TCHAR sBuf2[PBUF_LEN];

    winErrorString(hrErrorCode, sBuf, PBUF_LEN);
    wsprintf(sBuf2, TEXT("%s(%08x)"), sBuf, hrErrorCode);
    MessageBox(hwnd, sBuf2, sTitle, MB_OK);
}

void
wprintf_OKBox(
    HWND hwnd,
    LPTSTR sTitle,
    LPTSTR sFormat,
    ...)
{
    TCHAR sBuf[PBUF_LEN];
    va_list vaMarker;

    va_start( vaMarker, sFormat );
    wvsprintf(sBuf, sFormat, vaMarker);
    MessageBox(hwnd, sBuf, sTitle, MB_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\stpwatch.cpp ===
#include "stpwatch.h"

StopWatch_cl::StopWatch_cl()
{
    m_Zero();
}

ULONG StopWatch_cl::sm_TicksPerSecond;

//
// Init global/static state of the StopWatch class.
//
BOOL
StopWatch_cl::m_ClassInit()
{
    LARGE_INTEGER liTPS;
#ifdef WIN32
    if(!QueryPerformanceFrequency(&liTPS) )
    {
        MessageBox(0,
                    TEXT("Can't read frequency"),
                    TEXT("QueryPerformanceFrequency"),
                    MB_OK);
        return FALSE;
    }
    if (liTPS.HighPart != 0)
    {
        MessageBox(0,
                    TEXT("Ticks Per Second is to great"),
                    TEXT("QueryPerformanceFrequency"),
                    MB_OK);
        return FALSE;
    }
    sm_TicksPerSecond = liTPS.LowPart;
#else
    sm_TicksPerSecond = 1000;
#endif
    return TRUE;
}

void
StopWatch_cl::m_Zero()
{
    LISet32(m_liStart, 0);
    LISet32(m_liStop, 0);
    m_State = ZEROED;
}


BOOL
StopWatch_cl::m_Start()
{
#ifdef WIN32
    if(!QueryPerformanceCounter(&m_liStart))
    {
        MessageBox(0,
                    TEXT("Get Start Time Failure"),
                    TEXT("QueryPerformancecounter Failed"),
                    MB_OK);
        return FALSE;
    }
#else
    m_liStart.LowPart = GetTickCount();
    m_liStart.HighPart = 0;
#endif
    m_State = RUNNING;
    return TRUE;
}

// m_MeasureStop()
// Returns microseconds per single iteration.
//
BOOL
StopWatch_cl::m_Stop()
{
#ifdef WIN32
    if(!QueryPerformanceCounter(&m_liStop))
    {
        MessageBox(0,
                    TEXT("Get Stop Time Failure"),
                    TEXT("QueryPerformancecounter Failed"),
                    MB_OK);
        return FALSE;
    }
#else
    m_liStop.LowPart = GetTickCount();
    m_liStop.HighPart = 0;
#endif
    m_State = STOPPED;
    return TRUE;
}

BOOL
StopWatch_cl::m_Sleep(UINT msecs)
{
#ifdef WIN32
    Sleep(msecs);
#else
    UINT start, elapsed;
    start = GetTickCount();
    do
    {
        elapsed = GetTickCount() - start;
    } while ( msecs > elapsed );
#endif
    return TRUE;
}


//
//  Return a ULONG count of the number of Microseconds on the timer.
// I would return LARGE_INTEGER but there doesn't seem to be facilities
// to user them easily under 16 bit.
//
BOOL
StopWatch_cl::m_Read(ULONG *p_cMicroSeconds)
{
    LARGE_INTEGER liTicks;

    int borrow = 0;
    if(m_liStart.LowPart > m_liStop.LowPart)
        borrow = 1;
    liTicks.LowPart  = m_liStop.LowPart  - m_liStart.LowPart;
    liTicks.HighPart = m_liStop.HighPart - m_liStart.HighPart - borrow;

    if(0 != liTicks.HighPart)
    {
        MessageBox(0,
                    TEXT("Time interval was too great"),
                    TEXT("Failure"),
                    MB_OK);
        return(FALSE);
    }

    // result has units of (ticks/ loop of iterations).  Where the ticks
    // are timer specific.  This will convert result into:
    // (Milli_ticks) / (single iteration)

#ifdef WIN32
    *p_cMicroSeconds = MulDiv(liTicks.LowPart, 1000000, sm_TicksPerSecond);
#else
    *p_cMicroSeconds = liTicks.LowPart * 1000;
#endif
    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\stpwatch.h ===
#ifndef __STOPWATCH_H
#define __STOPWATCH_H

#include "../syshead.h"
#include "../my3216.h"

class StopWatch_cl {
    private:
        static ULONG sm_TicksPerSecond;
        LARGE_INTEGER m_liStart;
        LARGE_INTEGER m_liStop;

        enum em_STATES { ZEROED, RUNNING, STOPPED };
        em_STATES  m_State;

    public:
        StopWatch_cl();
        void m_Zero();
        BOOL m_ClassInit();
        BOOL m_Start();
        BOOL m_Stop();
        BOOL m_Read(ULONG *);
        BOOL m_ShowWindow(HWND);
        BOOL m_Sleep(UINT);
};

#endif // __STOPWATCH_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\client\make16.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif

OUTNUL= 1>nul 2>nul

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"
OBJDIR = obj16d
!else
OBJDIR = obj16r
!endif

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR

!if "$(OBJDIR)" == "obj16d"
OBJFILES = $(OBJFILES:.\=obj16d\)
RESFILES = $(RESFILES:.\=obj16d\)

!elseif "$(OBJDIR)" == "obj16r"
OBJFILES = $(OBJFILES:.\=obj16r\)
RESFILES = $(RESFILES:.\=obj16r\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif

OLETHUNK= $(_NTDRIVE)$(_NTROOT)\private\ole32\olethunk
OLE16= $(OLETHUNK)\ole16

RCINC = $(RCINC) -i$(OLE16)\inc
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(_NTDRIVE)$(_NTROOT)\private\cinc


PATH     = $(OLE16)\tools;$(PATH)
LINK    = link16
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -AL $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if "$(NTDEBUGTYPE)" == "windbg"
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip /FA
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RC)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RC) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\make16.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif

OUTNUL= 1>nul 2>nul

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"
OBJDIR = obj16d
!else
OBJDIR = obj16r
!endif

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR

!if "$(OBJDIR)" == "obj16d"
OBJFILES = $(OBJFILES:.\=obj16d\)
RESFILES = $(RESFILES:.\=obj16d\)

!elseif "$(OBJDIR)" == "obj16r"
OBJFILES = $(OBJFILES:.\=obj16r\)
RESFILES = $(RESFILES:.\=obj16r\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif

OLETHUNK= $(_NTDRIVE)$(_NTROOT)\private\ole32\olethunk
OLE16= $(OLETHUNK)\ole16

RCINC = $(RCINC) -i$(OLE16)\inc
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(_NTDRIVE)$(_NTROOT)\private\cinc


PATH     = $(OLE16)\tools;$(PATH)
LINK    = link16
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -AL $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if "$(NTDEBUGTYPE)" == "windbg"
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip /FA
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RC)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RC) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\dataobj.cpp ===
#include "dataobj.h"

extern HINSTANCE g_hInstance;

DWORD   g_dwID=0;
DWORD   g_foobar;

CDataObject::CDataObject(
    LPUNKNOWN  pUnkOuter,
    PFNDESTROYED  pfnDestroy
)
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pfnDestroy = pfnDestroy;

    m_hWndAdvise = NULL;
    m_dwAdvFlags = ADVF_NODATA;

    m_pIDataObject = NULL;
    m_pIDataAdviseHolder = NULL;

    m_cfeGet = CFORMATETCGET;
    SETDefFormatEtc(m_rgfeGet[0], CF_TEXT, TYMED_HGLOBAL);

    m_dataText = NULL;
    m_cDataSize = DATASIZE_FROM_INDEX(1);

    return;
}

CDataObject::~CDataObject(void)
{
    if (NULL != m_dataText)
        delete m_dataText;

    if (NULL != m_pIDataAdviseHolder)
        m_pIDataAdviseHolder->Release();

    if (NULL != m_pIDataObject)
        delete m_pIDataObject;

    if (NULL != m_hWndAdvise)
        DestroyWindow(m_hWndAdvise);
}

BOOL
CDataObject::FInit(void)
{
    LPUNKNOWN   pIUnknown = (LPUNKNOWN)this;

    // Create the contained "IDataObject" interface and
    // pass it the correct containing IUnknown.
    if (NULL != m_pUnkOuter)
        pIUnknown = m_pUnkOuter;

    m_pIDataObject = new CImpIDataObject(this, pIUnknown);

    if (NULL == m_pIDataObject)
        return FALSE;

    // [ Code for "Advise Window" goes here. ]

    return TRUE;
}

STDMETHODIMP
CDataObject::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (LPVOID)this;

    if (IsEqualIID(riid, IID_IDataObject))
        *ppv = (LPVOID) m_pIDataObject;

    if(NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG)
CDataObject::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CDataObject::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0==m_cRef)
    {
        if (NULL != m_pfnDestroy)
            (*m_pfnDestroy)();
        delete this;
    }
    return cRefT;
}

#ifdef NOT_SIMPLE
LRESULT APIENTRY
AdvisorWndProc(
    HWND hWnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    PCDataObject   pDO;

    pDO = (PCDataObject)(GetWindowLong)(hWnd, 0);

    switch (iMsg)
    {
    case WM_NCCREATE:
        pDO = (PCDataObject) ((LONG)((LPCREATESTRUCT)lParam)
                                                ->lpCreateParams);
        SetWindowLong(hWnd, 0, (LONG)pDO);
        return (DefWindowProc(hWnd, iMsg, wParam, lParam));

#ifdef FINISHED
    case WM_CLOSE:
        // Forbid the Task Manager from closing us.
        return 0L;
#endif /* Finished */

    case WM_COMMAND:
        // [ Code for "Advise Window" goes here. ]
        break;

    default:
        return (DefWindowProc(hWnd, iMsg, wParam, lParam));
    }
    return 0L;
}
#endif  /* NOT_SIMPLE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\dataobj.h ===
/*
 * DATAOBJ.H
 * Data Object Chapter 6
 *
 * Classes that implement the Data Object independent of whether
 * we live in a DLL or EXE.
 *
 * Copyright (c)1993-1995 Microsoft Corporation, All Right Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

#define INC_OLE2
#include <windows.h>
#include <ole2.h>

#include "../my3216.h"
#include "../bookpart.h"

//Type for an object-destroyed callback
typedef void (PASCAL *PFNDESTROYED)(void);


/*
 * The DataObject object is implemented in its own class with its
 * own IUnknown to support aggregation.  It contains one
 * CImpIDataObject object that we use to implement the externally
 * exposed interfaces.
 */


//DATAOBJ.CPP
#ifdef NOT_SIMPLE
LRESULT APIENTRY
AdvisorWndProc(HWND, UINT, WPARAM, LPARAM);
#endif /* NOT_SIMPLE */

class CImpIDataObject;
typedef class CImpIDataObject *PIMPIDATAOBJECT;


class CDataObject : public IUnknown
{
    friend class CImpIDataObject;
#ifdef NOT_SIMPLE
    friend LRESULT APIENTRY AdvisorWndProc(HWND, UINT
                                            , WPARAM, LPARAM);
#endif /* NOT_SIMPLE */

    protected:
        ULONG               m_cRef;
        LPUNKNOWN           m_pUnkOuter;
        PFNDESTROYED        m_pfnDestroy;

        HWND                m_hWndAdvise;   //Popup with Advise menu
        DWORD               m_dwAdvFlags;   //Notification flags

        //Contained interface implemetation
        PIMPIDATAOBJECT     m_pIDataObject;

        //Other interfaces used, implemented elsewhere
        LPDATAADVISEHOLDER  m_pIDataAdviseHolder;

        //Arrays for IDataObject::EnumFormatEtc
#define CFORMATETCGET 1
        ULONG               m_cfeGet;
        FORMATETC           m_rgfeGet[CFORMATETCGET];

        LPSTR               m_dataText;
        ULONG               m_cDataSize;

    protected:
        //Functions for use from IDataObject::GetData
#define FL_MAKE_ITEM   0x01    // StgMedium item must be created.
#define FL_USE_ITEM    0x00    // StgMedium item is allocated, use that.
#define FL_PASS_PUNK   0x02    // put a pUnk in the StgMedium.
        HRESULT     RenderText(LPSTGMEDIUM, LPTSTR, DWORD flags);
        HRESULT     RenderBitmap(LPSTGMEDIUM);
        HRESULT     RenderMetafilePict(LPSTGMEDIUM);

    public:
        CDataObject(LPUNKNOWN, PFNDESTROYED);
        ~CDataObject(void);

        BOOL FInit(void);

        //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
};

typedef CDataObject *PCDataObject;



/*
 * Interface implementations for the CDataObject object.
 */

class CImpIDataObject : public IDataObject
    {
    private:
        ULONG           m_cRef;
        PCDataObject    m_pObj;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpIDataObject(PCDataObject, LPUNKNOWN);
        ~CImpIDataObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDataObject members
        STDMETHODIMP GetData(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP GetDataHere(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP QueryGetData(LPFORMATETC);
        STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC,LPFORMATETC);
        STDMETHODIMP SetData(LPFORMATETC, LPSTGMEDIUM, BOOL);
        STDMETHODIMP EnumFormatEtc(DWORD, LPENUMFORMATETC *);
        STDMETHODIMP DAdvise(LPFORMATETC, DWORD,  LPADVISESINK
            , DWORD *);
        STDMETHODIMP DUnadvise(DWORD);
        STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *);
    };

/*
 * IEnumFORMATETC object that is created from
 * IDataObject::EnumFormatEtc.  This object lives on its own.
 */


class CEnumFormatEtc : public IEnumFORMATETC
    {
    private:
        ULONG           m_cRef;         //Object reference count
        LPUNKNOWN       m_pUnkRef;      //For reference counting
        ULONG           m_iCur;         //Current element.
        ULONG           m_cfe;          //Number of FORMATETCs in us
        LPFORMATETC     m_prgfe;        //Source of FORMATETCs

    public:
        CEnumFormatEtc(LPUNKNOWN, ULONG, LPFORMATETC);
        ~CEnumFormatEtc(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumFORMATETC members
        STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumFORMATETC **);
    };


typedef CEnumFormatEtc *PCEnumFormatEtc;

//////////////////////////////////////////////////////////////////////////////
// Storage Medium IUnknown interface for pUnkForRelease.
//

class CStgMedIf: public IUnknown {
private:
    ULONG m_cRef;
    LPSTGMEDIUM m_pSTM;

public:
    CStgMedIf(LPSTGMEDIUM);

    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
};

//////////////////////////
// API for getting a pUnkForRelease.
//

HRESULT
GetStgMedpUnkForRelease(LPSTGMEDIUM pSTM, IUnknown **pp_unk);

#endif //_DATAOBJ_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\edataobj.cpp ===
#define INIT_MY_GUIDS
#include <ole2ver.h>
#include "edataobj.h"


// Count of the number of objects and number of locks.
ULONG       g_cObj=0;
ULONG       g_cLock=0;

//Make window handle global so other code can cause a shutdown
HWND        g_hWnd=NULL;
HINSTANCE   g_hInst=NULL;


/*
 * WinMain
 *
 * Purpose:
 *  Main entry point of application.
 */

int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR pszCmdLine,
    int nCmdShow)
{
    MSG         msg;
    PAPPVARS    pAV;

#ifndef WIN32
    int cMsg = 96;
    while (!SetMessageQueue(cMsg) && (cMsg -= 9))
        ;
#endif
    g_hInst=hInst;

    pAV=new CAppVars(hInst, hInstPrev, pszCmdLine, nCmdShow);

    if (NULL==pAV)
        return -1;

    if (pAV->FInit())
    {
        while (GetMessage(&msg, NULL, 0,0 ))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    delete pAV;
    return msg.wParam;
}


LRESULT WINAPI
DataObjectWndProc(
    HWND hWnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (iMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return (DefWindowProc(hWnd, iMsg, wParam, lParam));
    }

    return 0L;
}


void PASCAL
ObjectDestroyed(void)
{
    g_cObj--;

    //No more objects and no locks, shut the app down.
    if (0L==g_cObj && 0L==g_cLock && IsWindow(g_hWnd))
        PostMessage(g_hWnd, WM_CLOSE, 0, 0L);

    return;
}


CAppVars::CAppVars(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR pszCmdLine,
    UINT nCmdShow)
{
    m_hInst     =hInst;
    m_hInstPrev =hInstPrev;
    m_pszCmdLine=pszCmdLine;

    m_nCmdShow  = nCmdShow;

    m_hWnd=NULL;

#if 0
    for (i=0; i < DOSIZE_CSIZES; i++)
    {
        m_rgdwRegCO[i]=0;
        m_rgpIClassFactory[i]=NULL;
    }
#else
    m_dwRegCO = 0;
    m_pIClassFactory = NULL;
#endif

    m_fInitialized=FALSE;
    return;
}


CAppVars::~CAppVars(void)
{
#if 0
    UINT        i;

    //Revoke and destroy the class factories of all sizes
    for (i=0; i < DOSIZE_CSIZES; i++)
    {
        if (0L!=m_rgdwRegCO[i])
            CoRevokeClassObject(m_rgdwRegCO[i]);

        if (NULL!=m_rgpIClassFactory[i])
            m_rgpIClassFactory[i]->Release();
    }
#else
    if (0L != m_dwRegCO)
        CoRevokeClassObject(m_dwRegCO);

    if (NULL != m_pIClassFactory)
        m_pIClassFactory->Release();
#endif

    if (m_fInitialized)
        CoUninitialize();

    return;
}

/*
 * CAppVars::FInit
 *
 * Purpose:
 *  Initializes an CAppVars object by registering window classes,
 *  etc...  If this function fails the caller should guarantee
 *  that the destructor is called.
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 */

BOOL
CAppVars::FInit(void)
{
    WNDCLASS        wc;
    HRESULT         hr;
    DWORD           dwVer;
#ifdef WIN32
    static TCHAR    szClass[] = TEXT("IdataSvr32");
#else
    static TCHAR    szClass[] = TEXT("IdataSvr16");
#endif

    //Check command line for -Embedding
    if (lstrcmpiA(m_pszCmdLine, "-Embedding"))
        return FALSE;

    dwVer=CoBuildVersion();

    if (rmm!=HIWORD(dwVer))
        return FALSE;

    if (FAILED(CoInitialize(NULL)))
        return FALSE;

    m_fInitialized=TRUE;

    if (!m_hInstPrev)
    {
        wc.style          = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc    = DataObjectWndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;
        wc.hInstance      = m_hInst;
        wc.hIcon          = NULL;
        wc.hCursor        = NULL;
        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = szClass;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    m_hWnd=CreateWindow(szClass,
                        szClass,
                        WS_OVERLAPPEDWINDOW,
                        135, 135, 350, 250,
                        NULL, NULL, m_hInst, NULL);

    if (NULL==m_hWnd)
        return FALSE;

    g_hWnd=m_hWnd;

    //ShowWindow(m_hWnd, m_nCmdShow);
    //UpdateWindow(m_hWnd);


#if 0
    /*
     * This code supplies three different classes, one for each type
     * of data object that handles a different size of data. All the
     * class factories share the same implementation, but their
     * instantiations differ by the type passed in the constructor.
     * When the class factories create objects, they pass that size
     * to the CDataObject contstructor as well.
     */

    UINT            i;
    HRESULT         hr2, hr3;

    for (i=0; i < DOSIZE_CSIZES; i++)
        {
        m_rgpIClassFactory[i]=new CDataObjectClassFactory(i);

        if (NULL==m_rgpIClassFactory[i])
            return FALSE;

        m_rgpIClassFactory[i]->AddRef();
        }

    hr=CoRegisterClassObject(CLSID_DataObjectSmall
        , m_rgpIClassFactory[0], CLSCTX_LOCAL_SERVER
        , REGCLS_MULTIPLEUSE, &m_rgdwRegCO[0]);

    hr2=CoRegisterClassObject(CLSID_DataObjectMedium
        , m_rgpIClassFactory[1], CLSCTX_LOCAL_SERVER
        , REGCLS_MULTIPLEUSE, &m_rgdwRegCO[1]);

    hr3=CoRegisterClassObject(CLSID_DataObjectLarge
        , m_rgpIClassFactory[2], CLSCTX_LOCAL_SERVER
        , REGCLS_MULTIPLEUSE, &m_rgdwRegCO[2]);

    if (FAILED(hr) || FAILED(hr2) || FAILED(hr3))
        return FALSE;
#else
    m_pIClassFactory = new CDataObjectClassFactory();
    if (NULL == m_pIClassFactory)
        return FALSE;
    m_pIClassFactory->AddRef();
#ifdef WIN32
    hr = CoRegisterClassObject( CLSID_DataObjectTest32,
                                m_pIClassFactory,
                                CLSCTX_LOCAL_SERVER,
                                REGCLS_MULTIPLEUSE,
                                &m_dwRegCO );
#else
    hr = CoRegisterClassObject( CLSID_DataObjectTest16,
                                m_pIClassFactory,
                                CLSCTX_LOCAL_SERVER,
                                REGCLS_MULTIPLEUSE,
                                &m_dwRegCO );
#endif // WIN32
    if (FAILED(hr))
        return FALSE;
#endif

    return TRUE;
}


/*
 * CDataObjectClassFactory::CDataObjectClassFactory
 * CDataObjectClassFactory::~CDataObjectClassFactory
 *
 * Constructor Parameters:
 *  iSize           UINT specifying the data size for this class.
 */

CDataObjectClassFactory::CDataObjectClassFactory()
{
    m_cRef=0L;
    return;
}


CDataObjectClassFactory::~CDataObjectClassFactory(void)
{
    return;
}


STDMETHODIMP
CDataObjectClassFactory::QueryInterface(
    REFIID riid,
    PPVOID ppv)
{
    *ppv=NULL;

    //Any interface on this object is the object pointer.
#ifdef ORIGINAL_CODE_LOOKS_WRONG
    if (IID_IUnknown==riid || IID_IClassFactory==riid)
#else
    if (IsEqualIID(IID_IUnknown, riid)|| IsEqualIID(IID_IClassFactory, riid))
#endif
        *ppv = this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CDataObjectClassFactory::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CDataObjectClassFactory::Release(void)
{
    ULONG           cRefT;

    cRefT=--m_cRef;

    if (0L==m_cRef)
        delete this;

    return cRefT;
}


/*
 * CDataObjectClassFactory::CreateInstance
 *
 * Purpose:
 *  Instantiates a CDataObject object that supports the IDataObject
 *  and IUnknown interfaces.  If the caller asks for a different
 *  interface than these two then we fail.
 *
 * Parameters:
 *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
 *                  being used in an aggregation.
 *  riid            REFIID identifying the interface the caller
 *                  desires to have for the new object.
 *  ppvObj          PPVOID in which to store the desired interface
 *                  pointer for the new object.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise contains
 *                  E_NOINTERFACE if we cannot support the
 *                  requested interface.
 */

STDMETHODIMP
CDataObjectClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    PPVOID ppvObj)
{
    PCDataObject        pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

#ifdef ORIGINAL_CODE_LOOKS_WRONG
    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
#else
    if (NULL!=pUnkOuter && (! IsEqualIID(IID_IUnknown, riid) ) )
#endif
        return ResultFromScode(E_NOINTERFACE);

    //Create the object telling it the data size to work with
    pObj=new CDataObject(pUnkOuter, ObjectDestroyed);

    if (NULL==pObj)
        return hr;

    if (pObj->FInit())
        hr=pObj->QueryInterface(riid, ppvObj);

    g_cObj++;

    if (FAILED(hr))
    {
        delete pObj;
        ObjectDestroyed();  //Decrements g_cObj
    }

    return hr;
}


/*
 * CDataObjectClassFactory::LockServer
 *
 * Purpose:
 *  Increments or decrements the lock count of the serving
 *  IClassFactory object.  When the number of locks goes to
 *  zero and the number of objects is zero, we shut down the
 *  application.
 *
 * Parameters:
 *  fLock           BOOL specifying whether to increment or
 *                  decrement the lock count.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */

STDMETHODIMP
CDataObjectClassFactory::LockServer(
    BOOL fLock)
{
    if (fLock)
        g_cLock++;
    else
    {
        g_cLock--;

        //No more objects and no locks, shut the app down.
        if (0L==g_cObj && 0L==g_cLock && IsWindow(g_hWnd))
            PostMessage(g_hWnd, WM_CLOSE, 0, 0L);
    }

    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\edataobj.h ===
#ifndef _EDATAOBJ_H_
#define _EDATAOBJ_H_

#include "dataobj.h"


//EDATAOBJ.CPP
LRESULT WINAPI DataObjectWndProc(HWND, UINT, WPARAM, LPARAM);


class CAppVars
{
    friend LRESULT WINAPI DataObjectWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    HINSTANCE       m_hInst;            //WinMain parameters
    HINSTANCE       m_hInstPrev;
    LPSTR           m_pszCmdLine;
    UINT            m_nCmdShow;

    HWND            m_hWnd;             //Main window handle
    BOOL            m_fInitialized;     //Did CoInitialize work?

    //We have multiple classes, one for each data size.
    // DWORD           m_rgdwRegCO[DOSIZE_CSIZES];
    // LPCLASSFACTORY  m_rgpIClassFactory[DOSIZE_CSIZES];
    DWORD           m_dwRegCO;
    LPCLASSFACTORY  m_pIClassFactory;

public:
    CAppVars(HINSTANCE, HINSTANCE, LPSTR, UINT);
    ~CAppVars(void);
    BOOL FInit(void);
};

typedef CAppVars *PAPPVARS;

void PASCAL ObjectDestroyed(void);

//This class factory object creates Data Objects.

class CDataObjectClassFactory : public IClassFactory
{
protected:
    ULONG           m_cRef;

public:
    CDataObjectClassFactory();
    ~CDataObjectClassFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};

typedef CDataObjectClassFactory *PCDataObjectClassFactory;

#endif //_EDATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\ienumfe.cpp ===
#include "dataobj.h"

CEnumFormatEtc::CEnumFormatEtc(
    LPUNKNOWN pUnkRef,
    ULONG cFE,
    LPFORMATETC prgFE
)
{
    UINT    i;

    m_cRef = 0;
    m_pUnkRef = pUnkRef;

    m_iCur = 0;
    m_cfe = cFE;
    m_prgfe = new FORMATETC[ (UINT) cFE ];

    if (NULL != m_prgfe)
    {
        for(i=0; i<cFE; i++)
            m_prgfe[i] = prgFE[i];
    }
    return;
}

CEnumFormatEtc::~CEnumFormatEtc(void)
{
    if (NULL != m_prgfe)
        delete [] m_prgfe;
    return;
}

STDMETHODIMP
CEnumFormatEtc::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if(IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IEnumFORMATETC))
    {
        *ppv = (LPVOID) this;
    }
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG)
CEnumFormatEtc::AddRef(void)
{
    ++m_cRef;
    m_pUnkRef->AddRef();
    return m_cRef;
}

STDMETHODIMP_(ULONG)
CEnumFormatEtc::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0 == m_cRef)
        delete this;

    return cRefT;
}

STDMETHODIMP
CEnumFormatEtc::Next(
    ULONG   cFE,
    LPFORMATETC pFE,
    ULONG FAR   *pulFE
)
{
    ULONG   cReturn = 0L;

    if (NULL == m_prgfe)
        return ResultFromScode(S_FALSE);

    if (NULL == pulFE)
    {
        if (1L != cFE)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulFE = 0L;

    if (NULL == pFE || m_iCur >= m_cfe)
        return ResultFromScode(S_FALSE);

    while ( (m_iCur < m_cfe) && (cFE > 0) )
    {
        *pFE++ = m_prgfe[m_iCur++];
        ++cReturn;
        --cFE;
    }

    if (NULL != pulFE)
        *pulFE = cReturn;

    return NOERROR;
}

STDMETHODIMP
CEnumFormatEtc::Skip(
    ULONG   cSkip
)
{
    if ( ( (m_iCur+cSkip) > m_cfe) || (NULL == m_prgfe) )
        return ResultFromScode(S_FALSE);

    m_iCur += cSkip;
    return NOERROR;
}

STDMETHODIMP
CEnumFormatEtc::Reset(void)
{
    m_iCur = 0;
    return NOERROR;
}

STDMETHODIMP
CEnumFormatEtc::Clone(
    LPENUMFORMATETC FAR *ppEnum
)
{
    PCEnumFormatEtc    pNew;

    *ppEnum = NULL;

    pNew = new CEnumFormatEtc(m_pUnkRef, m_cfe, m_prgfe);
    if (NULL == pNew)
        return ResultFromScode(E_OUTOFMEMORY);
    pNew->AddRef();
    pNew->m_iCur = m_iCur;

    *ppEnum = pNew;
    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\idataobj.cpp ===
#include "dataobj.h"
#include <stdlib.h>

CImpIDataObject::CImpIDataObject(
    PCDataObject pObj,
    LPUNKNOWN pUnkOuter
)
{
    m_cRef = 0;
    m_pObj = pObj;
    m_pUnkOuter = pUnkOuter;
    return;
}


CImpIDataObject::~CImpIDataObject(void)
{
    return;
}

STDMETHODIMP
CImpIDataObject::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CImpIDataObject::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG)
CImpIDataObject::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}

STDMETHODIMP
CImpIDataObject::GetData(
    LPFORMATETC pFE,
    LPSTGMEDIUM pSTM
)
{
    UINT    cf = pFE->cfFormat;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        if (!(TYMED_HGLOBAL & pFE->tymed))
            break;
        return m_pObj->RenderText(pSTM, TEXT("Getdata"),
                                                FL_MAKE_ITEM | FL_PASS_PUNK);

    default:
        break;
    }
    return ResultFromScode(DATA_E_FORMATETC);
}



STDMETHODIMP
CImpIDataObject::GetDataHere(
    LPFORMATETC pFE,
    LPSTGMEDIUM pSTM
)
{
    UINT    cf = pFE->cfFormat;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        if (!(TYMED_HGLOBAL & pFE->tymed))
            break;

        if(TYMED_NULL == pSTM->tymed)
            return ResultFromScode(S_OK);

        if(TYMED_HGLOBAL != pSTM->tymed)
            return ResultFromScode(E_INVALIDARG);

        return m_pObj->RenderText(pSTM, TEXT("GetDataHere"), FL_USE_ITEM);

    default:
        return ResultFromScode( DATA_E_FORMATETC );

    }
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP
CImpIDataObject::QueryGetData(
    LPFORMATETC pFE
)
{
    UINT    cf = pFE->cfFormat;
    BOOL    fRet = FALSE;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        fRet = (BOOL) (pFE->tymed & TYMED_HGLOBAL);
        break;

    default:
        fRet = FALSE;
        break;
    }
    return fRet ? NOERROR : ResultFromScode(S_FALSE);
}

STDMETHODIMP
CImpIDataObject::GetCanonicalFormatEtc(
    LPFORMATETC pFEIn,
    LPFORMATETC pFEOut
)
{
    if (NULL==pFEOut)
        return ResultFromScode(E_INVALIDARG);

    pFEOut->ptd = NULL;
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

STDMETHODIMP
CImpIDataObject::SetData(
    LPFORMATETC pFE,
    STGMEDIUM FAR *pST,
    BOOL fRelease
)
{
    UINT    cf = pFE->cfFormat;
    int iArg;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        if (!(TYMED_HGLOBAL & pFE->tymed))
            break;

        if(TYMED_HGLOBAL != pST->tymed)
            return ResultFromScode(E_INVALIDARG);

        LPTSTR psz=(LPTSTR)GlobalLock(pST->hGlobal);        // Lock
        iArg = *((long*)psz);                               // Use
        GlobalUnlock(pST->hGlobal);                         // Unlock

        if(iArg > 0)
        {
            m_pObj->m_cDataSize = iArg;
            return NOERROR;
        }
    }
    if(-1 == iArg && fRelease)
    {
        ReleaseStgMedium(pST);
        return NOERROR;
    }
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP
CImpIDataObject::EnumFormatEtc(
    DWORD dwDir,
    LPENUMFORMATETC FAR *ppEnum
)
{
    switch (dwDir)
    {
    case DATADIR_GET:
        *ppEnum = (LPENUMFORMATETC) new CEnumFormatEtc(
                                        m_pUnkOuter,
                                        m_pObj->m_cfeGet,
                                        m_pObj->m_rgfeGet );
        break;

    case DATADIR_SET:
        *ppEnum = NULL;
        break;

    default:
        *ppEnum = NULL;
        break;
    }
    if (NULL == *ppEnum)
        return ResultFromScode(E_FAIL);
    else
        (*ppEnum)->AddRef();

    return NOERROR;
}

STDMETHODIMP
CImpIDataObject::DAdvise(
    LPFORMATETC pFE,
    DWORD   dwFlags,
    LPADVISESINK    pIAdviseSink,
    LPDWORD pdwConn
)
{
    HRESULT hr;

    if (NULL == m_pObj->m_pIDataAdviseHolder)
    {
        hr = CreateDataAdviseHolder(&m_pObj->m_pIDataAdviseHolder);
        if(FAILED(hr))
            return ResultFromScode(E_OUTOFMEMORY);
    }
    hr = m_pObj->m_pIDataAdviseHolder->Advise(
                    (LPDATAOBJECT)this,
                    pFE,
                    dwFlags,
                    pIAdviseSink,
                    pdwConn );
    return hr;
}

STDMETHODIMP
CImpIDataObject::DUnadvise(
    DWORD dwConn
)
{
    HRESULT hr;

    if (NULL==m_pObj->m_pIDataAdviseHolder)
        return ResultFromScode(E_FAIL);
    hr = m_pObj->m_pIDataAdviseHolder->Unadvise(dwConn);
    return hr;
}

STDMETHODIMP
CImpIDataObject::EnumDAdvise(
    LPENUMSTATDATA FAR *ppEnum
)
{
    HRESULT hr;

    if (NULL==m_pObj->m_pIDataAdviseHolder)
        return ResultFromScode(E_FAIL);

    hr = m_pObj->m_pIDataAdviseHolder->EnumAdvise(ppEnum);
    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    daytona.inc

Abstract:

    common root include file for daytona version of performance
    project build.  This gets included by all sources files under
    this directory.

!ENDIF

MAJORCOMP   = cairole
MINORCOMP   = perform

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEPERFDIR=   $(OLEUTESTDIR)\perform

INCLUDES=     ;..;$(OLEPERFDIR)\common;$(OLEPERFDIR)\cairole\tests
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\daytona
INCLUDES=     $(INCLUDES);$(OLEDIR)\ih;$(OLEDIR)\common\daytona

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\stgmedif.cpp ===
#include "dataobj.h"

HRESULT
GetStgMedpUnkForRelease(LPSTGMEDIUM pSTM, IUnknown **pp_unk)
{
    CStgMedIf *p_smi = new CStgMedIf(pSTM);
    HRESULT hr = p_smi->QueryInterface(IID_IUnknown, (PPVOID)pp_unk);
    return hr;
}

CStgMedIf::CStgMedIf(LPSTGMEDIUM pSTM)
{
    m_pSTM = pSTM;
    m_cRef = 0;
}


STDMETHODIMP
CStgMedIf::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPVOID)this;
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CStgMedIf::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CStgMedIf::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0==m_cRef)
    {
        m_pSTM->pUnkForRelease = 0;
        ReleaseStgMedium(m_pSTM);
        delete this;
    }
    return cRefT;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\dll\oletest.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    oletest.cxx
//
//  Contents:	Simple OLE test object
//
//  Classes:	COleTestClass
//
//  Functions:	
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------


#include <oletest.hxx>



ULONG objCount = 0, lockCount = 0;
COleTestClassFactory theFactory;


COleTestClass::COleTestClass ()
{
	refCount = 1;
	objCount++;
}



COleTestClass::~COleTestClass ()
{                        
	objCount--;
}		



SCODE COleTestClass::QueryInterface (THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
	if (IsEqualIID (riid, IID_IUnknown))
		*ppvObj = (LPVOID FAR)(IUnknown*)this;
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}



ULONG COleTestClass::AddRef (THIS)
{
	return (refCount++);
}
    
    
ULONG COleTestClass::Release (THIS)
{
	refCount--;
	if (refCount == 0)
	{
		delete this;
		return 0;
	}
	return refCount;
}


	

SCODE COleTestClassFactory::QueryInterface (THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
	if (IsEqualIID (riid, IID_IUnknown))
		*ppvObj = (LPVOID FAR)(IUnknown*)this;
	else
	{
		if (IsEqualIID (riid, IID_IClassFactory))
			*ppvObj = (LPVOID FAR)(IClassFactory*)this;
		else
		{
			*ppvObj = NULL;
			return E_NOINTERFACE;
		}
	}
	return S_OK;
}



ULONG COleTestClassFactory::AddRef (THIS)
{
	return 1;
}
    
    
ULONG COleTestClassFactory::Release (THIS)
{
	return 1;
}

    
SCODE COleTestClassFactory::CreateInstance (THIS_ LPUNKNOWN pUnkOuter,
	REFIID riid, LPVOID FAR* ppvObject)
{
	*ppvObject = (LPVOID FAR*)(IStream*)new COleTestClass;
	return S_OK;
}

    
    
SCODE COleTestClassFactory::LockServer (THIS_ BOOL fLock)
{
	if (fLock)
		lockCount++;
	else
		lockCount--;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairo.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cairo.inc

Abstract:

    common root include file for daytona version of performance
    project build.  This gets included by all sources files under
    this directory.

!ENDIF

MAJORCOMP   = cairole
MINORCOMP   = perform

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEPERFDIR=   $(OLEUTESTDIR)\perform

INCLUDES=     ;..;$(OLEPERFDIR)\common;$(OLEPERFDIR)\cairole\tests
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\cairo
INCLUDES=     $(INCLUDES);$(OLEDIR)\ih;$(OLEDIR)\common\cairo

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
	      -DWIN32=300	    \
	      -D_CAIRO_=300	    \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
	      -DNOEXCEPTIONS	    \
	      -D_DCOM_		    \
	      -DCOM_THREADING_SUPPORT \
	      -DOLE_THREADING_SUPPORT

CAIRO_PRODUCT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perf16\idata\server\render.cpp ===
#include "dataobj.h"
#include <string.h>



HRESULT
CDataObject::RenderText(
    LPSTGMEDIUM pSTM,
    LPTSTR      lptstr,
    DWORD       flags)
{
    DWORD       cch;
    HGLOBAL     hMem;
    LPTSTR      psz;
    UINT        i;

    if(!(FL_MAKE_ITEM & flags))
        hMem = pSTM->hGlobal;
    else
        hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, m_cDataSize);

    if (NULL==hMem)
        return ResultFromScode(STG_E_MEDIUMFULL);

    cch = 64 / sizeof(TCHAR);
    psz=(LPTSTR)GlobalLock(hMem);

    wsprintf(psz, TEXT("%ld:"), m_cDataSize);

    for (i=lstrlen(psz); i<cch-1, '\0'!=*lptstr; i++, lptstr++)
        *(psz+i) = *lptstr;

    for ( ; i < cch-1; i++)
        *(psz+i)=TEXT(' ') + (i % 32);

    *(psz+i)=0;

    GlobalUnlock(hMem);

    if(FL_MAKE_ITEM & flags)
    {
        pSTM->hGlobal=hMem;
        pSTM->tymed=TYMED_HGLOBAL;
        pSTM->pUnkForRelease=NULL;
    }
    if(FL_PASS_PUNK & flags)
        GetStgMedpUnkForRelease(pSTM, &pSTM->pUnkForRelease);

    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\dll\daytona\makefile.inc ===
obj\i386\oletest.def: oletest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\dll\cairo\makefile.inc ===
obj\i386\oletest.def: oletest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\dll\testdllx.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    testdllx.cxx
//
//  Contents:	DLL extensions
//
//  Classes:	
//
//  Functions:	DllGetClassObject
//				DllCanUnloadNow
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------


#include "oletest.hxx"


extern ULONG objCount, lockCount;
extern COleTestClassFactory theFactory;


STDAPI DllGetClassObject (REFCLSID classId, REFIID riid, VOID **ppv)
{
	if (IsEqualGUID (classId, CLSID_COleTestClass))
		return theFactory.QueryInterface (riid, ppv);
	return E_UNEXPECTED;
}



STDAPI DllCanUnloadNow ()
{
	return (objCount==0 && lockCount==0) ? S_OK : E_UNEXPECTED;
}


extern "C"
BOOL _cdecl LibMain (HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\dll\chicago\makefile.inc ===
obj\i386\oletest.def: oletest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\svr\bmtstsvr.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    bmtstsvr.cxx
//
//  Contents:	Test server for benchmark test
//
//  Classes:	
//
//  Functions:	WinMain
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------


#include <oletest.hxx>


extern COleTestClassFactory theFactory;
extern ULONG objCount, lockCount;


int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
	DWORD reg;
	objCount = lockCount = 0;

	OleInitialize (NULL);
	CoRegisterClassObject (CLSID_COleTestClass, (IClassFactory *)&theFactory, 
		CLSCTX_LOCAL_SERVER,0, &reg);

	while (objCount==0 && lockCount==0)
	    Sleep (1000);
	while (objCount || lockCount)
	{
	    Sleep (3000);
	}

	CoRevokeClassObject (reg);

	OleUninitialize ();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bmp_stg2.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//					
//  File:	bmp_stg2.cxx
//
//  Contents:	Generic Storage parser based test file 2
//
//  Classes:	CStorageParser
//
//  Functions:	Parse and Execute functions for each instruction.
//
//  History:    20-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <bmp_stg.hxx>
#include <tchar.h>

#define STGTY_ANY	0		// any storage element, stream or storage

//
// Static array of info for each instruction
//
SInstrInfo CStorageParser::m_aInstructions[] =
   { { TEXT("StgIsStorageFile"),
       TEXT("StgIsStorageFile     "),
       Parse_StgIsStorageFile,
       Execute_StgIsStorageFile,
       NULL },

     { TEXT("StgCreateDocFile"), 			
       TEXT("StgCreateDocFile     "),
       Parse_StgCreateDocFile,
       Execute_StgCreateDocFile,
       NULL },

     { TEXT("OpenStorage"),
       TEXT("StgOpenStorage       "),
       Parse_StgOpenStorage,
       Execute_StgOpenStorage ,
       NULL },

     { TEXT("CExposedDocFile::AddRef"),
       TEXT("IStorage::AddRef     "),
       Parse_IStorageAddRef,
       Execute_IStorageAddRef ,
       NULL },

     { TEXT("CExposedDocFile::Release"),
       TEXT("IStorage::Release    "),
       Parse_IStorageRelease,
       Execute_IStorageRelease ,
       NULL },

     { TEXT("CExposedDocFile::Commit"),
       TEXT("IStorage::Commit     "),
       Parse_IStorageCommit,
       Execute_IStorageCommit ,
       NULL },

     { TEXT("CExposedDocFile::Revert"),
       TEXT("IStorage::Revert     "),
       Parse_IStorageRelease,
       Execute_IStorageRelease ,
       NULL },

     { TEXT("CExposedDocFile::CreateStream"),
       TEXT("IStorage::CreateStream"),
       Parse_IStorageCreateStream,
       Execute_IStorageCreateStream ,
       NULL },

     { TEXT("CExposedDocFile::OpenStream"),	
       TEXT("IStorage::OpenStream "),
       Parse_IStorageOpenStream,
       Execute_IStorageOpenStream ,
       NULL },

     { TEXT("CExposedDocFile::CreateStorage"),	
       TEXT("IStorage::CreateStorage"),
       Parse_IStorageCreateStorage,
       Execute_IStorageCreateStorage ,
       NULL },

     { TEXT("CExposedDocFile::OpenStorage"),	
       TEXT("IStorage::OpenStorage"),
       Parse_IStorageOpenStorage,
       Execute_IStorageOpenStorage ,
       NULL },

     { TEXT("CExposedDocFile::DestroyElement"),	
       TEXT("IStorage::DestroyElement"),
       Parse_IStorageDestroyElement,
       Execute_IStorageDestroyElement ,
       NULL },

     { TEXT("CExposedDocFile::RenameElement"),	
       TEXT("IStorage::RenameElement"),
       Parse_IStorageRenameElement,
       Execute_IStorageRenameElement ,
       NULL },

     { TEXT("CExposedDocFile::SetStateBits"),	
       TEXT("IStorage::SetStateBits"),
       Parse_IStorageSetStateBits,
       Execute_IStorageSetStateBits ,
       NULL },

     { TEXT("CExposedDocFile::SetElementTimes"),	
       TEXT("IStorage::SetElementTimes"),
       Parse_IStorageSetElementTimes,
       Execute_IStorageSetElementTimes ,
       NULL },

     { TEXT("CExposedDocFile::SetClass"),	
       TEXT("IStorage::SetClass   "),
       Parse_IStorageSetClass,
       Execute_IStorageSetClass ,
       NULL },

     { TEXT("CExposedDocFile::Stat"),	
       TEXT("IStorage::Stat       "),
       Parse_IStorageStat,
       Execute_IStorageStat ,
       NULL },

     { TEXT("CExposedStream::AddRef"),	
       TEXT("IStream::AddRef      "),
       Parse_IStreamAddRef,
       Execute_IStreamAddRef ,
       NULL },

     { TEXT("CExposedStream::Release"),	
       TEXT("IStream::Release     "),
       Parse_IStreamRelease,
       Execute_IStreamRelease ,
       NULL },

     { TEXT("CExposedStream::Commit"),	
       TEXT("IStream::Commit      "),
       Parse_IStreamCommit,
       Execute_IStreamCommit ,
       NULL },

     { TEXT("CExposedStream::Clone"),	
       TEXT("IStream::Clone       "),
       Parse_IStreamClone,
       Execute_IStreamClone ,
       NULL },

    { TEXT("CExposedStream::Revert"),	
       TEXT("IStream::Revert      "),
       Parse_IStreamRevert,
       Execute_IStreamRevert ,
       NULL },

     { TEXT("CExposedStream::SetSize"),	
       TEXT("IStream::SetSize    "),
       Parse_IStreamSetSize,
       Execute_IStreamSetSize ,
       NULL },

     { TEXT("CExposedStream::Write"),	
       TEXT("IStream::Write        "),
       Parse_IStreamWrite,
       Execute_IStreamWrite ,
       GetName_IStreamWrite },

     { TEXT("CExposedStream::Read"),	
       TEXT("IStream::Read        "),
       Parse_IStreamRead,
       Execute_IStreamRead ,
       GetName_IStreamRead },

     { TEXT("CExposedStream::Seek"),	
       TEXT("IStream::Seek        "),
       Parse_IStreamSeek,
       Execute_IStreamSeek ,
       GetName_IStreamSeek },

     { TEXT("CExposedStream::Stat"),	
       TEXT("IStream::Stat       "),
       Parse_IStreamStat,
       Execute_IStreamStat ,
       NULL }
  };


//
//  Number of instructions in the above array
//
ULONG CStorageParser::m_iMaxInstruction =
	sizeof(CStorageParser::m_aInstructions) /
	sizeof(CStorageParser::m_aInstructions[0]);


//
// Tries to find an "almost" matching name in the storage.
// Used to get around bug of loging functions, that print a '.' instead of unprintable
// characters.
SCODE CStorageParser::CheckForElementName(LPINSTRDATA pInstrData, DWORD dwType)
{
    HRESULT 		hr;
    LPENUMSTATSTG 	pEnum;
    STATSTG		StatStg;
    BOOL		bFound = FALSE;


    hr = m_apStorages[pInstrData->ThisID]->EnumElements(0, NULL, 0, &pEnum);

    while (!bFound && pEnum->Next(1, &StatStg, NULL) == S_OK)
    {
        if (StatStg.type == dwType || dwType == STGTY_ANY)
	{
	    // if the names are the same except for the first letter, copy that letter.
	    if (wcscmp(StatStg.pwcsName + 1, pInstrData->wszParam + 1) == 0)
	    {
	    	pInstrData->wszParam[0] = StatStg.pwcsName[0];
		bFound = TRUE;
	    }

	}
	m_piMalloc->Free(StatStg.pwcsName);
    }

    pEnum->Release();
    return bFound ? S_OK : E_FAIL;
}


/*
--------::In  StgIsStorageFile(stgtest.bm)
--------::Out StgIsStorageFile().  ret == 1
*/
SCODE CStorageParser::Parse_StgIsStorageFile(LPINSTRDATA pInstrData,
						LPTSTR pszPart1,
						LPTSTR pszPart2)
{
#ifdef UNICODE
    swscanf(pszPart1 + 31, L"%[^)]",pInstrData->wszParam);
#else
    TCHAR szName[MAX_PATH];
    sscanf(pszPart1 + 31, "%[^)]", szName);
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    return S_OK;
}


ULONG CStorageParser::Execute_StgIsStorageFile(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    sw.Reset();
    hr = StgIsStorageFile(pInstrData->wszParam);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
--------::In  OpenStorage(stgtest.bm, 00000000, 10, 00000000, 0, 0012F540, 0012F4F8)
--------::Out OpenStorage().  *ppstgOpen == 00000000, ret == 80030050
*/
SCODE CStorageParser::Parse_StgOpenStorage(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

   _stscanf(pszPart1 + 26, TEXT("%[^,], %*x, %lx"), szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 + 44, TEXT("%lx"), &ulStorageID);

    pInstrData->OutID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_StgOpenStorage(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    sw.Reset();
    hr = StgOpenStorage(pInstrData->wszParam, NULL, pInstrData->dwParam1,
    			NULL, 0, &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
--------::In  StgCreateDocFile(stgtest.bm, 1011, 0, 0012F53C)
--------::Out StgCreateDocFile().  *ppstgOpen == 50000A5C, ret == 0
*/
SCODE CStorageParser::Parse_StgCreateDocFile(LPINSTRDATA pInstrData,
						LPTSTR pszPart1,
						LPTSTR pszPart2)
{
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1 + 31, TEXT("%[^,], %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 + 49, TEXT("%lx"), &ulStorageID);

    pInstrData->OutID = FindStorageID(ulStorageID);

    return S_OK;
}


ULONG CStorageParser::Execute_StgCreateDocFile(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    OLECHAR	*pwszName;

    pwszName = pInstrData->wszParam;

    if (wcscmp(pwszName, L"(null)") == 0)
    	pwszName = NULL;

    sw.Reset();
    hr = StgCreateDocfile(pwszName, pInstrData->dwParam1,
    			  0, &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::AddRef()
50000A5C::Out CExposedDocFile::AddRef().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageAddRef(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageAddRef(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    m_apStorages[pInstrData->ThisID]->AddRef();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::Release()
50000A5C::Out CExposedDocFile::Release().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageRelease(LPINSTRDATA pInstrData,
					       LPTSTR pszPart1,
					       LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageRelease(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    m_apStorages[pInstrData->ThisID]->Release();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::Revert()
50000A5C::Out CExposedDocFile::Revert().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageRevert(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageRevert(LPINSTRDATA pInstrData)
{					
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT 	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->Revert();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::Commit(0)
50000A5C::Out CExposedDocFile::Commit().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageCommit(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 38, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageCommit(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->Commit(pInstrData->dwParam1);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::CreateStream(CONTENTS, 1011, 0, 0, 0012F54C)
50000A5C::Out CExposedDocFile::CreateStream().  *ppstm == 500008F4, ret == 0
*/
SCODE CStorageParser::Parse_IStorageCreateStream(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStreamID;
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 44, TEXT("%[^,], %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	58, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    pInstrData->OutID = FindStreamID(ulStreamID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageCreateStream(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->CreateStream(pInstrData->wszParam,
    						   pInstrData->dwParam1,
						   0, 0,
						   &m_apStreams[pInstrData->OutID]);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::OpenStream(CONTENTS, 0 12, 0, 0012F54C)
50000A5C::Out CExposedDocFile::OpenStream().  *ppstm == 500008F4, ret == 0
*/
SCODE CStorageParser::Parse_IStorageOpenStream(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStreamID;
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 42, TEXT("%[^,], %*x %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	56, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart2 + 73, TEXT("%lx"), &pInstrData->dwParam2);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    pInstrData->OutID = FindStreamID(ulStreamID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageOpenStream(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->OpenStream(pInstrData->wszParam, 0,
    						   pInstrData->dwParam1, 0,
						   &m_apStreams[pInstrData->OutID]);
    ulTime = sw.Read();

    // check if we failed but script indicated succes, which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam2))
    {
    	sc = CheckForElementName(pInstrData, STGTY_STREAM);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->OpenStream(pInstrData->wszParam, 0,
    						   pInstrData->dwParam1, 0,
						   &m_apStreams[pInstrData->OutID]);
	    ulTime = sw.Read();
	}
    }

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;			
}

/*
50000A5C::In  CExposedDocFile::CreateStorage(STORAGE1, 1011, 0, 0, 0012F54C)
50000A5C::Out CExposedDocFile::CreateStorage().  *ppstm == 500008F4, ret == 0
*/
SCODE CStorageParser::Parse_IStorageCreateStorage(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID1;
    ULONG ulStorageID2;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID1);
    _stscanf(pszPart1 + 45, TEXT("%[^,], %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	59, TEXT("%lx"), &ulStorageID2);

    pInstrData->ThisID = FindStorageID(ulStorageID1);
    pInstrData->OutID = FindStorageID(ulStorageID2);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageCreateStorage(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->CreateStorage(pInstrData->wszParam,
    						   pInstrData->dwParam1,
						   0, 0,
						   &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::OpenStorage(CONTENTS, 00000000, 1011, 00000000, 0, 0012F54C)
50000A5C::Out CExposedDocFile::OpenStorage().  *ppstm == 500008F4, ret == 0
*/					
SCODE CStorageParser::Parse_IStorageOpenStorage(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID1;
    ULONG ulStorageID2;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID1);
    _stscanf(pszPart1 + 43, TEXT("%[^,], %*lx, %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	57, TEXT("%lx"), &ulStorageID2);
    _stscanf(pszPart2 + 74, TEXT("%lx"), &pInstrData->dwParam2);

    pInstrData->ThisID = FindStorageID(ulStorageID1);
    pInstrData->OutID = FindStorageID(ulStorageID2);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageOpenStorage(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->OpenStorage(pInstrData->wszParam,
    		   				   NULL,
    						   pInstrData->dwParam1,
						   NULL, 0,
						   &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    // check if we failed but script indicated succes, which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam2))
    {
    	sc = CheckForElementName(pInstrData, STGTY_STORAGE);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->OpenStorage(pInstrData->wszParam, NULL,
    						   pInstrData->dwParam1, NULL, 0,
						   &m_apStorages[pInstrData->OutID]);
	    ulTime = sw.Read();
	}
    }
    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::DestroyElement(CONTENTS)
50000A5C::Out CExposedDocFile::DestroyElement().  ret == 0
*/					
SCODE CStorageParser::Parse_IStorageDestroyElement(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
#ifdef UNICODE
    swscanf(pszPart1 + 46, L"%[^,]", pInstrData->wszParam);
#else
    TCHAR szName[MAX_PATH];
    sscanf(pszPart1 + 46, "%[^,]", szName);
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 + 57, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageDestroyElement(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->DestroyElement(pInstrData->wszParam);
    ulTime = sw.Read();

        // check if we failed but script indicated succes, which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam1))
    {
    	sc = CheckForElementName(pInstrData, STGTY_ANY);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->DestroyElement(pInstrData->wszParam);
	    ulTime = sw.Read();
	}
    }
    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::SetStateBits(%lu, %lu)
50000A5C::Out CExposedDocFile::SetStateBits().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageSetStateBits(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 44, TEXT("%lu, %lu"),
    	    &pInstrData->dwParam1, &pInstrData->dwParam2);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageSetStateBits(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->SetStateBits(pInstrData->dwParam1, pInstrData->dwParam2);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::SetClass(?)
50000A5C::Out CExposedDocFile::SetClass().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageSetClass(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageSetClass(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
static const CLSID  ClsID =
    {0x0000013a,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->SetClass(ClsID);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
5000A0FC::In  CExposedDocFile::SetElementTimes(contents, 0012F518, 0012F518, 00000000)
5000A0FC::Out CExposedDocFile::SetElementTimes().  ret == 80030005
*/					
SCODE CStorageParser::Parse_IStorageSetElementTimes(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 47, TEXT("%[^,], %lx, %lx, %lx"),
    	    szName, &pInstrData->dwParam1,
    	    &pInstrData->dwParam2, &pInstrData->dwParam3);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageSetElementTimes(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    FILETIME	ft;
    SYSTEMTIME	st;
    LPFILETIME  pft1, pft2, pft3;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    // get current time
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    pft1 =  pInstrData->dwParam1 ? &ft : NULL;
    pft2 =  pInstrData->dwParam2 ? &ft : NULL;
    pft3 =  pInstrData->dwParam3 ? &ft : NULL;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->SetElementTimes(pInstrData->wszParam,
    							   pft1, pft2, pft3);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}



/*
50000A5C::In  CExposedDocFile::RenameElement(Name1, Name2)
50000A5C::Out CExposedDocFile::RenameElement().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageRenameElement(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    pInstrData->wszParam2 = (OLECHAR *)m_piMalloc->Alloc(MAX_PATH * sizeof(OLECHAR));
    if (pInstrData->wszParam2 == NULL)
    {
    	Log(TEXT("Can't allocate memory in for RenameElement"), E_OUTOFMEMORY);
	return E_FAIL;
    }
    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
#ifdef UNICODE
    swscanf(pszPart1 + 45, L"%[^,], %[^)]",
            pInstrData->wszParam, pInstrData->wszParam2);
#else
    TCHAR szName[MAX_PATH], szName2[MAX_PATH];
    _stscanf(pszPart1 + 45, "%[^,], %[^)]",
            szName, szName2);
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
    mbstowcs(pInstrData->wszParam2, szName2, strlen(szName2)+1);
#endif
    _stscanf(pszPart2 + 56, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageRenameElement(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->RenameElement(pInstrData->wszParam,
    							 pInstrData->wszParam2);
    ulTime = sw.Read();

    // check if we failed but script indicated succes,
    // which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam1))
    {
    	sc = CheckForElementName(pInstrData, STGTY_ANY);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->RenameElement(pInstrData->wszParam,
    							 	 pInstrData->wszParam2);
	    ulTime = sw.Read();
	}
    }

    m_piMalloc->Free(pInstrData->wszParam2);
    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::Stat(xxxxxxxx)
50000A5C::Out CExposedDocFile::Stat().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageStat(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageStat(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    STATSTG	StatStg;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
       	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->Stat(&StatStg, STATFLAG_NONAME);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::AddRef()
50000A5C::Out CExposedStream::AddRef().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamAddRef(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamAddRef(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    ULONG	ulRes;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;
    sw.Reset();
    ulRes = m_apStreams[pInstrData->ThisID]->AddRef();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}


/*
50000A5C::In  CExposedStream::Release()
50000A5C::Out CExposedStream::Release().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamRelease(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamRelease(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    m_apStreams[pInstrData->ThisID]->Release();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::Revert()
50000A5C::Out CExposedStream::Revert().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamRevert(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamRevert(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Revert();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::Commit(0)
50000A5C::Out CExposedStream::Commit().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamCommit(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 37, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamCommit(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Commit(pInstrData->dwParam1);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::SetSize(10)
50000A5C::Out CExposedStream::SetSize().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamSetSize(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 38, TEXT("%lu"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamSetSize(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    ULARGE_INTEGER liSize;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    LISet32(liSize, pInstrData->dwParam1);

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->SetSize(liSize);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::Write(xxxxxxxx, 1234, xxxxxxxx)
50000A5C::Out CExposedStream::Write().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamWrite(LPINSTRDATA pInstrData,
					    LPTSTR pszPart1,
					    LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 46, TEXT("%lu"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamWrite(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    BYTE	*pData;

    pData = (BYTE *) m_piMalloc->Alloc(pInstrData->dwParam1);
    if (pData == NULL)
    {
    	Log(TEXT("Can't allocate memory for write"), E_OUTOFMEMORY);
	return TEST_FAILED;
    }

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Write(pData, pInstrData->dwParam1, NULL);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    m_piMalloc->Free(pData);

    return ulTime;
}


TCHAR *CStorageParser::GetName_IStreamWrite(LPINSTRDATA pInstrData)
{
    _stscanf(m_szBuffer, TEXT("IStream::Write %-8lu"), pInstrData->dwParam1);
    return m_szBuffer;
}


/*
50000A5C::In  CExposedStream::Read(xxxxxxxx, 1234, xxxxxxxx)
50000A5C::Out CExposedStream::Read().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamRead(LPINSTRDATA pInstrData,
					   LPTSTR pszPart1,
					   LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 45, TEXT("%lu"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamRead(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    BYTE	*pData;

    pData = (BYTE *) m_piMalloc->Alloc(pInstrData->dwParam1);
    if (pData == NULL)
    {
    	Log(TEXT("Can't allocate memory for read"), E_OUTOFMEMORY);
	return TEST_FAILED;
    }

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Read(pData, pInstrData->dwParam1, NULL);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    m_piMalloc->Free(pData);

    return ulTime;
}

TCHAR *CStorageParser::GetName_IStreamRead(LPINSTRDATA pInstrData)
{
    _stscanf(m_szBuffer, TEXT("IStream::Read %-8lu"), pInstrData->dwParam1);
    return m_szBuffer;
}

/*
50000A5C::In  CExposedStream::Seek(0, 1234, xxxxxxxx)
50000A5C::Out CExposedStream::Seek().  ulPos == %lu,  ret == 0
*/
SCODE CStorageParser::Parse_IStreamSeek(LPINSTRDATA pInstrData,
					   LPTSTR pszPart1,
					   LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 35, TEXT("%ld, %lu"),
    	    &pInstrData->dwParam1, &pInstrData->dwParam2);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamSeek(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    LARGE_INTEGER liSize;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    LISet32(liSize, pInstrData->dwParam1);

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Seek(liSize,
    					       pInstrData->dwParam2,
    					       NULL);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

TCHAR *CStorageParser::GetName_IStreamSeek(LPINSTRDATA pInstrData)
{
    _stscanf(m_szBuffer, TEXT("IStream::Seek %lu %lu"),
        pInstrData->dwParam1, pInstrData->dwParam2);

    return m_szBuffer;
}


/*
500074A4::In  CExposedStream::Clone(0012DCE8)
500074A4::Out CExposedStream::Clone().  *ppstm == 50007324, ret == 0
*/
SCODE CStorageParser::Parse_IStreamClone(LPINSTRDATA pInstrData,
					 LPTSTR pszPart1,
					 LPTSTR pszPart2)
{
    ULONG ulStreamID1;
    ULONG ulStreamID2;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID1);
    _stscanf(pszPart2 +	50, TEXT("%lx"), &ulStreamID2);

    pInstrData->ThisID = FindStreamID(ulStreamID1);
    pInstrData->OutID = FindStreamID(ulStreamID2);

    return S_OK;
}

ULONG CStorageParser::Execute_IStreamClone(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Clone(&m_apStreams[pInstrData->OutID]);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}

/*
50000A5C::In  CExposedStream::Stat(xxxxxxxx)
50000A5C::Out CExposedStream::Stat).  ret == 0
*/
SCODE CStorageParser::Parse_IStreamStat(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamStat(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    STATSTG	StatStg;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;


    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Stat(&StatStg, STATFLAG_NONAME);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bmguid.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmguid.cxx
//
//  Contents:	OLE test guids
//
//  Classes:	
//
//  Functions:	
//
//  History:    12-August-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <oletest.hxx>

const GUID CLSID_COleTestClass =
       {0x20730701,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass1 =
       {0x20730711,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass2 =
       {0x20730712,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass3 =
       {0x20730713,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass4 =
       {0x20730714,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass5 =
       {0x20730715,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass6 =
       {0x20730716,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass7 =
       {0x20730717,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass8 =
       {0x20730718,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


const GUID CLSID_TestProp =
       {0x20730722,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bmp_test.cxx ===
//
// A very simple test based on parser base classes
// It understands only two commands 1 and 2 in first column.
// 2's are simply ignored.
// on execution of 1's I just loop for the id of current command
// which is increased by 1 with every command encounterd, starting with 0.
//
//
//   t-vadims
//

#include <headers.cxx>
#pragma hdrstop

#include <bmp_test.hxx>	


SCODE CSimpleTest::SetParserObject ()
{
    m_pParser = new CParserTest;
    return S_OK;
}

SCODE CSimpleTest::DeleteParserObject ()
{
    delete m_pParser;
    return S_OK;
}


WCHAR* CSimpleTest::Name ()
{
    return L"ParserTest";
}

WCHAR* CSimpleTest::SectionHeader()
{
    return L"Simple test of interpreting files";
}


SCODE CParserTest::Setup (CTestInput *pInput)
{
   /* do any neccessary setup staff */
   m_iInstrID = 0;
   return S_OK;
}

SCODE CParserTest::Cleanup ()
{
   /* do any neccessary clean up */
   return S_OK;
}

ULONG CParserTest::ParseNewInstruction(LPWSTR pwszInstr)
{
    ULONG ulID;

    if (pwszInstr[0] == L'1')
    {
   	m_iInstrID ++;
   	ulID = m_iInstrID;
    }
    else if (pwszInstr[0] == L'2')
   	ulID = NOT_INSTRUCTION;
    else
    	ulID = INVALID_INSTRUCTION;

    return ulID;   		
}

ULONG CParserTest::ExecuteInstruction(ULONG ulID)
{
    CStopWatch sw;

    sw.Reset();
    for (ULONG i =0; i <=ulID; i++)
       /* empty loop */;
    return sw.Read();
}


WCHAR* CParserTest::InstructionName(ULONG ulID)
{
    wsprintf(m_wszBuf, L"Instruction %ld", ulID);
    return m_wszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bmp_stg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//					 
//  File:	bmp_stg.cxx
//
//  Contents:	Generic Storage parser based test
//
//  Classes:	CStorageParserTest, CStorageParser
//
//  Functions:	
//
//  History:    15-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <valid.h>
#include <tchar.h>
#include <bmp_stg.hxx>	

//+------------------------------------------------------------------------
//
//  Class:	CStorageParserTest
//
//  Functions:	
//
//  History:    15-June-94 t-vadims    Created
//      
//--------------------------------------------------------------------------

SCODE CStorageParserTest::SetParserObject ()
{
    m_pParser = new CStorageParser;
    return S_OK;
}


SCODE CStorageParserTest::DeleteParserObject ()
{
    delete m_pParser;
    return S_OK;
}


TCHAR* CStorageParserTest::Name ()
{
    return TEXT("StorageParserTest");
}


TCHAR *CStorageParserTest::SectionHeader()
{
    return TEXT("Storage test from log");
}



//+------------------------------------------------------------------------
//
//  Class:	CStorageParser
//
//  Functions:	
//
//  History:    15-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------

#define  STATE_OFFSET	      10	  // location of "In"/"Out" in log string
#define  NAME_OFFSET	      14	  // location of command name in log string

#define  MAX_NAME 	      50	  

#define DEF_ARRAYSIZE	      10


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::Setup, public
//
//  Synopsis:	Makes all neccessary initializations.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CStorageParser::Setup (CTestInput *pInput)
{
    SCODE sc;


    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
   	return sc;

    m_iStreamCount = 0;
    m_iStreamArraySize = DEF_ARRAYSIZE;
    m_aulStreamID = (ULONG *)m_piMalloc->Alloc(m_iStreamArraySize * 
   					      sizeof(ULONG));
    m_apStreams = (LPSTREAM *)m_piMalloc->Alloc(m_iStreamArraySize * 
   					      sizeof(LPSTREAM));

    m_iStorageCount = 0;
    m_iStorageArraySize = DEF_ARRAYSIZE;
    m_aulStorageID = (ULONG *)m_piMalloc->Alloc(m_iStorageArraySize * 
   					      sizeof(ULONG));
    m_apStorages = (LPSTORAGE *)m_piMalloc->Alloc(m_iStorageArraySize * 
   					      sizeof(LPSTORAGE));

    m_iInstrCount = 0;
    m_iInstrArraySize = DEF_ARRAYSIZE;
    m_apInstrData = (LPINSTRDATA *)m_piMalloc->Alloc(m_iInstrArraySize * 
   					      sizeof(LPINSTRDATA));


    m_bGotFirstPart = FALSE;

    if (m_apInstrData == NULL || m_aulStorageID == NULL ||
       	m_apStorages == NULL || m_aulStreamID == NULL ||
	m_apStreams == NULL )
    {
    	Cleanup();
	Log(TEXT("Setup can't allocate memory"), E_OUTOFMEMORY);
	return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::Cleanup, public
//
//  Synopsis:	Makes all neccessary cleanup
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CStorageParser::Cleanup ()
{
    /* do any neccessary clean up */
    if(m_piMalloc)
    {
    	if (m_aulStreamID)
   	    m_piMalloc->Free(m_aulStreamID);
	if (m_apStreams)
   	    m_piMalloc->Free(m_apStreams);
	if (m_aulStorageID)
   	    m_piMalloc->Free(m_aulStorageID);
	if (m_apStorages)
   	    m_piMalloc->Free(m_apStorages); 


	for (ULONG i = 0; i < m_iInstrCount; i++)
	   delete m_apInstrData[i];

	if (m_apInstrData)
   	    m_piMalloc->Free(m_apInstrData);

	m_piMalloc->Release();
	m_piMalloc = NULL;
    }
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::AddInstruction, public
//
//  Synopsis:	Parse new instruction and add it to array if it is valid
//
//  Return:	ID of instruction
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::AddInstruction(LPTSTR pszFirstPart, LPTSTR pszSecondPart)
{
    ULONG  ulInstrID;
    SCODE  sc;

    TCHAR  szInstrName[MAX_NAME];
    TCHAR  szSecondName[MAX_NAME];

    if (_tcsncmp(pszFirstPart + STATE_OFFSET, TEXT("In"), 2) != 0)
   	return INVALID_INSTRUCTION;

    if (_tcsncmp(pszSecondPart + STATE_OFFSET, TEXT("Out"), 3) != 0)
   	return INVALID_INSTRUCTION;

   
    // check if the same instruction name;
    GetInstructionName(szInstrName, pszFirstPart);
    GetInstructionName(szSecondName, pszSecondPart);

    if(_tcscmp(szInstrName, szSecondName) != 0)
   	return INVALID_INSTRUCTION;


    // determine the instruction 
    ulInstrID = INVALID_INSTRUCTION;
    for (ULONG i = 0; i < m_iMaxInstruction; i++)
       	if (_tcscmp(szInstrName, m_aInstructions[i].szLogName) == 0)
	{
	    ulInstrID = i;
	    break;
	}

   if(ulInstrID == INVALID_INSTRUCTION)
   	return INVALID_INSTRUCTION;

    // fill appropriate structure fields
    SInstrData *pInstrData = new SInstrData;
    pInstrData->ulInstrID = ulInstrID;

    sc = (this->*m_aInstructions[ulInstrID].Parse)(pInstrData, 
    						      pszFirstPart, 
    						      pszSecondPart);

    if (FAILED(sc))
    {
    	delete pInstrData;
    	return INVALID_INSTRUCTION;
    }

    return AddNewInstrData(pInstrData);
}			   

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::IgnoreInstruction, private
//
//  Synopsis:	Check if this instruction should be ignored.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
BOOL CStorageParser::IgnoreInstruction(LPTSTR pszInstr)
{
    TCHAR szName[MAX_NAME];

    // We Ignore those instructions that are completely implemented
    // in terms of other instructions that are also logged.

    GetInstructionName(szName, pszInstr);

    if (_tcscmp (szName, TEXT("CExposedStream::QueryInterface")) == 0 ||
   	_tcscmp (szName, TEXT("CExposedDocFile::QueryInterface")) == 0 ||
   	_tcscmp (szName, TEXT("CExposedStream::CopyTo")) == 0  ||
   	_tcscmp (szName, TEXT("CExposedDocFile::MoveElementTo")) == 0 ||
   	_tcscmp (szName, TEXT("CExposedDocFile::CopyTo")) == 0 ||
   	_tcscmp (szName, TEXT("ExposedDocFile::CopyTo")) == 0 
	)
    {
 	return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::ParseNewInstruction, public
//
//  Synopsis:	Parse new line of file, and return its id.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::ParseNewInstruction(LPTSTR pszInstr)
{
    ULONG ulID;

    if (IgnoreInstruction(pszInstr))
    	return  NOT_INSTRUCTION;

    if (m_bGotFirstPart)     
    {
    	// out part of instruction. We can now add it.
   	ulID = AddInstruction(m_szBuffer, pszInstr);
	m_bGotFirstPart = FALSE;
    }
    else
    {
    	// save In part of instruction, and fake CTimerBase into
	// thinking that this wasn't an instruction.	   
   	_tcscpy(m_szBuffer, pszInstr);
	ulID = NOT_INSTRUCTION;
	m_bGotFirstPart = TRUE;
    }

    return ulID;   		
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::ExecuteInstruction, public
//
//  Synopsis:	Execute instruction with given id.
//
//  Return:	time taken to execute it.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::ExecuteInstruction(ULONG ulID)
{
    SInstrData  *pInstrData = m_apInstrData[ulID];

    return (this->*m_aInstructions[pInstrData->ulInstrID].Execute)(pInstrData);
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::InstructionName, public
//
//  Synopsis:	Return name of instruction.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
TCHAR * CStorageParser::InstructionName(ULONG ulID)
{
    SInstrData  *pInstrData = m_apInstrData[ulID];

    if (m_aInstructions[pInstrData->ulInstrID].GetName != NULL)
    	return (this->*m_aInstructions[pInstrData->ulInstrID].GetName)(pInstrData);
    else
    	return m_aInstructions[pInstrData->ulInstrID].szPrintName;
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::GetInstructionName, public
//
//  Synopsis:	Extract instruction name from the instruction.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CStorageParser::GetInstructionName (LPTSTR pszName, LPTSTR pszInstruction)
{
    _stscanf(pszInstruction + NAME_OFFSET, TEXT("%[^(]"), pszName);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::AddNewInstrData, public
//
//  Synopsis:	Adds new instruction to instrData array.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::AddNewInstrData (LPINSTRDATA pInstrData)
{
    if (m_iInstrCount >= m_iInstrArraySize)
    {
    	m_iInstrArraySize *= 2;
	m_apInstrData = (LPINSTRDATA *)m_piMalloc->Realloc(m_apInstrData,
				  m_iInstrArraySize * sizeof(LPINSTRDATA));
    }

    m_apInstrData[m_iInstrCount] = pInstrData;

    return m_iInstrCount++;
}
					           
//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::FindStorageID, public
//
//  Synopsis:	finds or creates new storage, based on ID.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::FindStorageID (ULONG ulStgID)
{
    for (ULONG i = 0; i < m_iStorageCount; i++)
    	if (m_aulStorageID[i] == ulStgID)
	    return i;

    if (m_iStorageCount >= m_iStorageArraySize)
    {
    	m_iStorageArraySize *= 2;
	m_aulStorageID = (ULONG *)m_piMalloc->Realloc(m_aulStorageID, 
				  m_iStorageArraySize * sizeof(ULONG));

	m_apStorages = (LPSTORAGE *)m_piMalloc->Realloc(m_apStorages,
				  m_iStorageArraySize * sizeof(LPSTORAGE));
				
    }
    m_aulStorageID[m_iStorageCount] = ulStgID;
    m_apStorages[m_iStorageCount] = NULL;

    return m_iStorageCount++;
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::FindStreamID, public
//
//  Synopsis:	finds or creates new stream, based on ID.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::FindStreamID (ULONG ulStreamID)
{
    for (ULONG i = 0; i < m_iStreamCount; i++)
    	if (m_aulStreamID[i] == ulStreamID)
	    return i;

    if (m_iStreamCount >= m_iStreamArraySize)
    {
    	m_iStreamArraySize *=2;
	m_aulStreamID = (ULONG *)m_piMalloc->Realloc(m_aulStreamID, 
				  m_iStreamArraySize * sizeof(ULONG));

	m_apStreams = (LPSTREAM *)m_piMalloc->Realloc(m_apStreams,
				  m_iStreamArraySize * sizeof(LPSTREAM));
				
    }
    m_aulStreamID[m_iStreamCount] = ulStreamID;
    m_apStreams[m_iStreamCount] = NULL;

    return m_iStreamCount++;
}

//+-------------------------------------------------------------------
//
//  Members:	CStorageParser::CheckThisStorageID, public
//		CStorageParser::CheckThisStreamID, public
//
//  Synopsis:	Check if storage/stream with given id can be dereferenced.
//		(must be non null).
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------

SCODE CStorageParser::CheckThisStorageID(ULONG ulStorageID)
{
    if(m_apStorages[ulStorageID] == NULL || 
       ! IsValidInterface(m_apStorages[ulStorageID]))
    {					       
    	Log(TEXT("Trying to dereference an unassigned Storage"), E_FAIL);
	return E_FAIL;
    }
    return S_OK;
}


SCODE CStorageParser::CheckThisStreamID(ULONG ulStreamID)
{
    if(m_apStreams[ulStreamID] == NULL ||
       ! IsValidInterface(m_apStreams[ulStreamID]))
    {
    	Log(TEXT("Trying to dereference an unassigned Stream"), E_FAIL);
	return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_alloc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_alloc.cxx
//
//  Contents:	IMalloc test
//
//  Classes:	COleAllocTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_alloc.hxx>


TCHAR *COleAllocTest::Name ()
{
    return TEXT("IMalloc");
}


SCODE COleAllocTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    SCODE sc;

    // Get number of iterations
    m_ulIterations = pInput->GetIterations(Name());
    m_ulSize = 32;

    INIT_RESULTS (m_ulAllocTime);
    INIT_RESULTS (m_ulFreeTime);
    INIT_RESULTS (m_ulReallocTime);
    INIT_RESULTS (m_ulGetSizeTime);
    INIT_RESULTS (m_ulDidAllocTime);
    INIT_RESULTS (m_ulHeapMinimizeTime);

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    //	create an instance of the object to marshal
    m_pMalloc = NULL;

    sc = CoGetMalloc(MEMCTX_TASK, &m_pMalloc);

    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoGetMalloc failed"), sc);
	return sc;
    }

    return sc;
}


SCODE COleAllocTest::Cleanup ()
{
    //	release objects
    if (m_pMalloc)
	m_pMalloc->Release();

    UninitCOM();
    return S_OK;
}


SCODE COleAllocTest::Run ()
{
	CStopWatch sw;
	LPVOID FAR pv;

	//  make the various IMalloc calls
	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    pv = m_pMalloc->Alloc(m_ulSize);
	    m_ulAllocTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::Alloc"), (pv) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    pv = m_pMalloc->Realloc(pv, m_ulSize*2);
	    m_ulReallocTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::Realloc"), (pv) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    ULONG ulSize = m_pMalloc->GetSize(pv);
	    m_ulGetSizeTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::GetSize"), (ulSize > 0) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    INT fRes = m_pMalloc->DidAlloc(pv);
	    m_ulDidAllocTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::DidAlloc"), (fRes) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    m_pMalloc->Free(pv);
	    m_ulFreeTime[iIter] = sw.Read();
	}

	//  loop through all the sizes.  starting with a size of 8,
	//  we double it each time for MAX_SIZE_CNT times.

	ULONG ulSize = 8;
	for (ULONG iSize = 0; iSize <MAX_SIZE_CNT; iSize++)
	{
	    //	loop through all the number of iterations
	    for (iIter=0; iIter<m_ulIterations; iIter++)
	    {
		VOID *pv[TEST_MAX_ITERATIONS];

		sw.Reset();
		for (ULONG iCnt=0; iCnt<iIter+1; iCnt++)
		{
		    pv[iCnt] = m_pMalloc->Alloc(ulSize);
		}
		m_ulAllocSizeTime[iSize][iIter] = sw.Read();

		sw.Reset();
		for (iCnt=0; iCnt<iIter+1; iCnt++)
		{
		    m_pMalloc->Free(pv[iCnt]);
		}
		m_ulFreeSizeTime[iSize][iIter] = sw.Read();

		for (iCnt=0; iCnt<iIter+1; iCnt++)
		{
		    if (pv[iCnt] == NULL)
		    {
			Log(TEXT("IMalloc::Alloc failed."), E_OUTOFMEMORY);

			//  an allocation failed, correct the times
			m_ulAllocSizeTime[iSize][iIter] = NOTAVAIL;
			m_ulFreeSizeTime[iSize][iIter] = NOTAVAIL;
		    }
		}


	    }

	    //	double the allocation size
	    ulSize *= 2;
	}

	return S_OK;
}


SCODE COleAllocTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(),
			   TEXT("OLE20 IMalloc MEMCTX_TASK"),
			   *m_pInput);

    output.WriteString	(TEXT("\n"));
    output.WriteResults (TEXT("IMalloc->Alloc     32:"), m_ulIterations, m_ulAllocTime);
    output.WriteResults (TEXT("IMalloc->Realloc   64:"), m_ulIterations, m_ulReallocTime);
    output.WriteResults (TEXT("IMalloc->GetSize      "), m_ulIterations, m_ulGetSizeTime);
    output.WriteResults (TEXT("IMalloc->DidAlloc     "), m_ulIterations, m_ulDidAllocTime);
    output.WriteResults (TEXT("IMalloc->Free         "), m_ulIterations, m_ulFreeTime);
    output.WriteString	(TEXT("\n"));

    output.WriteString	(TEXT("N consecutive allocations of the same size:\n"));
    ULONG ulSize = 8;
    for (ULONG iSize = 0; iSize<MAX_SIZE_CNT; iSize++)
    {
	//  format output string containing allocation size
	TCHAR	szBuf[80];
	wsprintf(szBuf, TEXT("IMalloc->Alloc %6d:"), ulSize);

	output.WriteResults (szBuf, m_ulIterations, m_ulAllocSizeTime[iSize]);
	output.WriteResults (TEXT("IMalloc->Free       "), m_ulIterations, m_ulFreeSizeTime[iSize]);

	//  double the size
	ulSize *= 2;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_activ.cxx ===
//+- -----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_activ.cxx
//
//  Contents:	Ole object activation test
//
//  Classes:	COleActivationTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_activ.hxx>
#include <oletest.hxx>


TCHAR *COleActivationTest::Name ()
{
    return TEXT("ObjActivation");
}


SCODE COleActivationTest::Setup (CTestInput *pInput)
{
    SCODE sc;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	INIT_RESULTS(m_ulGetClassObjectTime[iCtx]);
	INIT_RESULTS(m_ulCreateInstanceTime[iCtx]);
	INIT_RESULTS(m_ulLoadTime[iCtx]);
	INIT_RESULTS(m_ulPunkReleaseTime[iCtx]);
	INIT_RESULTS(m_ulCFReleaseTime[iCtx]);
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - InitCOM failed."), sc);
        return	sc;
    }

    return S_OK;
}


SCODE COleActivationTest::Cleanup ()
{	
    UninitCOM();
    return S_OK;
}


SCODE COleActivationTest::Run ()
{
    CStopWatch	  sw;
    IPersistFile  *pIPF = NULL;
    IClassFactory *pICF = NULL;

    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset ();
	    SCODE sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				    IID_IClassFactory, (void **)&pICF);
	    m_ulGetClassObjectTime[iCtx][iIter] = sw.Read ();
	    Log (TEXT("CoGetClassObject"), sc);

	    if (SUCCEEDED(sc))
	    {
		sw.Reset();
		sc = pICF->CreateInstance(NULL, IID_IPersistFile, (void **)&pIPF);
		m_ulCreateInstanceTime[iCtx][iIter] = sw.Read ();
		Log (TEXT("CreateInstance"), sc);

		sw.Reset();
		pICF->Release();
		m_ulCFReleaseTime[iCtx][iIter] = sw.Read();

		if (SUCCEEDED(sc))
		{
		    //	load the data
		    sw.Reset();
		    pIPF->Load(apszPerstName[iCtx], 0);
		    m_ulLoadTime[iCtx][iIter] = sw.Read();

		    sw.Reset();
		    pIPF->Release ();
		    m_ulPunkReleaseTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulCreateInstanceTime[iCtx][iIter] = NOTAVAIL;
		}
	    }
	    else
	    {
		m_ulGetClassObjectTime[iCtx][iIter] = NOTAVAIL;
	    }
	}
    }

    return S_OK;
}					  



SCODE COleActivationTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("CoGetClassObject"), *m_pInput);

    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	output.WriteString(TEXT("\n"));
	output.WriteClassID (&m_ClsID[iCtx]);
	output.WriteString(apszClsCtx[iCtx]);
	output.WriteString(TEXT("\n"));

	output.WriteResults (TEXT("CoGetClassObject"), m_ulIterations,
			     m_ulGetClassObjectTime[iCtx]);

	output.WriteResults (TEXT("CreateInstance  "), m_ulIterations,
			     m_ulCreateInstanceTime[iCtx]);

	output.WriteResults (TEXT("pICF->Release   "), m_ulIterations,
			     m_ulCFReleaseTime[iCtx]);

	output.WriteResults (TEXT("pIPF->Load      "), m_ulIterations,
			     m_ulLoadTime[iCtx]);

	output.WriteResults (TEXT("pIPF->Release   "), m_ulIterations,
			     m_ulPunkReleaseTime[iCtx]);

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_api.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_api.cxx
//
//  Contents:	Miscellaneous OLE API tests
//
//  Classes:	CApiTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_api.hxx>


const GUID CLSID_Balls =
    {0x0000013a,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_Dummy =
    {0x00000142,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



TCHAR *CApiTest::Name ()
{
    return TEXT("ApiTest");
}


SCODE CApiTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays
    INIT_RESULTS(m_ulCoBuildVersion);
    INIT_RESULTS(m_ulOleBuildVersion);

    INIT_RESULTS(m_ulCoGetCurrentProcess);
    INIT_RESULTS(m_ulCoGetMalloc);


    //	time APIs

    INIT_RESULTS(m_ulCoFileTimeNow);
    INIT_RESULTS(m_ulCoFileTimeToDosDateTime);
    INIT_RESULTS(m_ulCoDosDateTimeToFileTime);


    //	registry & class APIs

    INIT_RESULTS(m_ulCoCreateGuid);
    INIT_RESULTS(m_ulCoTreatAsClass);
    INIT_RESULTS(m_ulCoGetTreatAsClass);
    INIT_RESULTS(m_ulCoIsOle1Class);
    INIT_RESULTS(m_ulGetClassFile);

    INIT_RESULTS(m_ulStringFromCLSID);
    INIT_RESULTS(m_ulCLSIDFromString);
    INIT_RESULTS(m_ulProgIDFromCLSID);
    INIT_RESULTS(m_ulStringFromIID);
    INIT_RESULTS(m_ulIIDFromString);

    INIT_RESULTS(m_ulCLSIDFromProgID);
    INIT_RESULTS(m_ulStringFromGUID2);


    // Get ClsID for this Ctx from the .ini file
    CLSID ClsID;

    HRESULT sc = pInput->GetGUID(&ClsID, Name(), apszClsIDName[1]);
    if (FAILED(sc))
    {
	Log (TEXT("Setup - GetClassID failed."), sc);
	return sc;
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
	return	sc;
    }


    // Create an instance
    IClassFactory *pICF = NULL;

    sc = CoGetClassObject(ClsID, dwaClsCtx[1], NULL,
			  IID_IClassFactory, (void **)&pICF);
    if (SUCCEEDED(sc))
    {
	IPersistFile *pIPF = NULL;

	sc = pICF->CreateInstance(NULL, IID_IPersistFile,
				  (void **)&pIPF);
	pICF->Release();
	if (SUCCEEDED(sc))
	{
	    //	save the class instance in the storage
	    sc = pIPF->Save(apszPerstName[1], FALSE);
	    pIPF->Release();

	    if (FAILED(sc))
	    {
		Log (TEXT("Setup - pIPF->Save failed."), sc);
	    }
	}
	else
	{
	    Log (TEXT("Setup - CreateInstance failed"), sc);
	}
    }
    else
    {
	Log (TEXT("Setup - CoGetClassObject failed"), sc);
    }

    return sc;
}


SCODE CApiTest::Cleanup ()
{
    UninitCOM();

    //	delete the file
    CHAR    szPerstName[MAX_PATH];
    wcstombs(szPerstName, apszPerstName[1], wcslen(apszPerstName[1])+1);
    _unlink (szPerstName);

    return S_OK;
}


SCODE CApiTest::Run ()
{
	CStopWatch  sw;
	SCODE	    sc;

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    DWORD bldver = CoBuildVersion();
	    m_ulCoBuildVersion[iIter] = sw.Read();
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    DWORD bldver = OleBuildVersion();
	    m_ulOleBuildVersion[iIter] = sw.Read();
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    DWORD pid = CoGetCurrentProcess();
	    m_ulCoGetCurrentProcess[iIter] = sw.Read();
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    IMalloc *pMalloc = NULL;
	    sw.Reset();
	    sc = CoGetMalloc(MEMCTX_TASK, &pMalloc);
	    if (SUCCEEDED(sc))
	    {
		pMalloc->Release();
	    }
	    m_ulCoGetMalloc[iIter] = sw.Read();
	    Log (TEXT("CoGetMalloc"), sc);
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    FILETIME ft;
	    WORD wDosDate, wDosTime;

	    sw.Reset();
	    sc = CoFileTimeNow(&ft);
	    m_ulCoFileTimeNow[iIter] = sw.Read();
	    Log (TEXT("CoFileTimeNow"), sc);

	    sw.Reset();
	    sc = CoFileTimeToDosDateTime(&ft, &wDosDate, &wDosTime);
	    m_ulCoFileTimeToDosDateTime[iIter] = sw.Read();
	    Log (TEXT("CoFileTimeToDosDateTime"), sc);

	    sw.Reset();
	    sc = CoDosDateTimeToFileTime(wDosDate, wDosTime, &ft);
	    m_ulCoDosDateTimeToFileTime[iIter] = sw.Read();
	    Log (TEXT("CoDosDateTimeToFileTime"), sc);
	}


	IMalloc	*pMalloc = NULL;
	sc = CoGetMalloc(MEMCTX_TASK, &pMalloc);
	if (FAILED(sc))
	{
	    return sc;
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    GUID	Guid, GuidNew;
	    LPOLESTR	pwsz = NULL;
	    OLECHAR	awsz[50];

	    sw.Reset();
	    sc = CoCreateGuid(&Guid);
	    m_ulCoCreateGuid[iIter] = sw.Read();
	    if (FAILED(sc))
		m_ulCoCreateGuid[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CoTreatAsClass(CLSID_Dummy, Guid);
	    m_ulCoTreatAsClass[iIter] = sw.Read();
	    Log (TEXT("CoTreatAsClass"), sc);
	    if (FAILED(sc))
		m_ulCoTreatAsClass[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CoGetTreatAsClass(CLSID_Dummy, &GuidNew);
	    m_ulCoGetTreatAsClass[iIter] = sw.Read();
	    Log (TEXT("CoGetTreatAsClass"), sc);
	    if (FAILED(sc))
		m_ulCoGetTreatAsClass[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = GetClassFile(apszPerstName[1], &Guid);
	    m_ulGetClassFile[iIter] = sw.Read();
	    Log (TEXT("GetClassFile"), sc);
	    if (FAILED(sc))
		m_ulGetClassFile[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = StringFromCLSID(Guid, &pwsz);
	    m_ulStringFromCLSID[iIter] = sw.Read();
	    Log (TEXT("StringFromCLSID"), sc);
	    if (FAILED(sc))
		m_ulStringFromCLSID[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CLSIDFromString(pwsz, &GuidNew);
	    m_ulCLSIDFromString[iIter] = sw.Read();
	    Log (TEXT("CLSIDFromString"), sc);
	    if (FAILED(sc))
		m_ulCLSIDFromString[iIter] = NOTAVAIL;

	    pMalloc->Free((void *)pwsz);


	    sw.Reset();
	    sc = StringFromIID(Guid, &pwsz);
	    m_ulStringFromIID[iIter] = sw.Read();
	    Log (TEXT("StringFromIID"), sc);
	    if (FAILED(sc))
		m_ulStringFromIID[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = IIDFromString(pwsz, &GuidNew);
	    m_ulIIDFromString[iIter] = sw.Read();
	    Log (TEXT("IIDFromString"), sc);
	    if (FAILED(sc))
		m_ulIIDFromString[iIter] = NOTAVAIL;

	    pMalloc->Free((void *)pwsz);

	    sw.Reset();
	    sc = StringFromGUID2(Guid, awsz, 50);
	    m_ulStringFromGUID2[iIter] = sw.Read();
	    Log (TEXT("StringFromGUID2"), sc);
	    if (FAILED(sc))
		m_ulStringFromGUID2[iIter] = NOTAVAIL;
	}


	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    GUID     Guid;
	    LPOLESTR pwsz = NULL;

	    sw.Reset();
	    sc = ProgIDFromCLSID(CLSID_Balls, &pwsz);
	    m_ulProgIDFromCLSID[iIter] = sw.Read();
	    Log (TEXT("ProgIDFromCLSID"), sc);
	    if (FAILED(sc))
		m_ulProgIDFromCLSID[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CLSIDFromProgID(pwsz, &Guid);
	    m_ulCLSIDFromProgID[iIter] = sw.Read();
	    Log (TEXT("CLSIDFromProgID"), sc);
	    if (FAILED(sc))
		m_ulCLSIDFromProgID[iIter] = NOTAVAIL;

	    pMalloc->Free((void *)pwsz);
	}

	if (pMalloc)
	    pMalloc->Release();

	// INIT_RESULTS(m_ulCoIsOle1Class);

	return S_OK;
}					



SCODE CApiTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Misc COM Apis"), *m_pInput);

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("CoBuildVersion     "), m_ulIterations, m_ulCoBuildVersion);
    output.WriteResults (TEXT("OleBuildVersion    "), m_ulIterations, m_ulOleBuildVersion);
    output.WriteResults (TEXT("CoGetCurrentProcess"), m_ulIterations, m_ulCoGetCurrentProcess);
    output.WriteResults (TEXT("CoGetMalloc        "), m_ulIterations, m_ulCoGetMalloc);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CoFileTimeNow          "), m_ulIterations, m_ulCoFileTimeNow);
    output.WriteResults (TEXT("CoFileTimeToDosDateTime"), m_ulIterations, m_ulCoFileTimeToDosDateTime);
    output.WriteResults (TEXT("CoDosDateTimeToFileTime"), m_ulIterations, m_ulCoDosDateTimeToFileTime);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CoCreateGuid       "), m_ulIterations, m_ulCoCreateGuid);
    output.WriteResults (TEXT("CoTreatAsClass     "), m_ulIterations, m_ulCoTreatAsClass);
    output.WriteResults (TEXT("CoGetTreatAsClass  "), m_ulIterations, m_ulCoGetTreatAsClass);
    output.WriteResults (TEXT("CoIsOle1Class      "), m_ulIterations, m_ulCoIsOle1Class);
    output.WriteResults (TEXT("GetClassFile       "), m_ulIterations, m_ulGetClassFile);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StringFromCLSID    "), m_ulIterations, m_ulStringFromCLSID);
    output.WriteResults (TEXT("CLSIDFromString    "), m_ulIterations, m_ulCLSIDFromString);
    output.WriteResults (TEXT("ProgIDFromCLSID    "), m_ulIterations, m_ulProgIDFromCLSID);
    output.WriteResults (TEXT("StringFromIID      "), m_ulIterations, m_ulStringFromIID);
    output.WriteResults (TEXT("IIDFromString      "), m_ulIterations, m_ulIIDFromString);
    output.WriteResults (TEXT("StringFromGUID2    "), m_ulIterations, m_ulStringFromGUID2);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_init.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_init.cxx
//
//  Contents:	OleInitialize/OleUninitialize tests
//
//  Classes:	COleInitializeTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_init.hxx>
#include <oletest.hxx>


DWORD dwInitFlag = 0;

TCHAR *COleInitializeTest::Name ()
{
    return TEXT("OleInitialize");
}


SCODE COleInitializeTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    INIT_RESULTS(m_ulOleInitializeTime);
    INIT_RESULTS(m_ulOleUninitializeTime);
    INIT_RESULTS(m_ulRepOleInitializeTime);
    INIT_RESULTS(m_ulRepOleUninitializeTime);

    INIT_RESULTS(m_ulCoInitializeTime);
    INIT_RESULTS(m_ulCoUninitializeTime);
    INIT_RESULTS(m_ulRepCoInitializeTime);
    INIT_RESULTS(m_ulRepCoUninitializeTime);

    return S_OK;
}


SCODE COleInitializeTest::Cleanup ()
{	
    return S_OK;
}


SCODE COleInitializeTest::Run ()
{
    CStopWatch	sw;
    SCODE	sc;

    //	compute times for OleInit, OleUninit.
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
#ifdef OLE_THREADING_SUPPORT
	sc = OleInitializeEx(NULL, dwInitFlag);
#else
	sc = OleInitialize(NULL);
#endif
	m_ulOleInitializeTime[iIter] = sw.Read();
	Log (TEXT("OleInitialize"), sc);

	if (SUCCEEDED(sc))
	{
	    sw.Reset();
	    OleUninitialize();
	    m_ulOleUninitializeTime[iIter] = sw.Read();
	    Log (TEXT("OleUninitialize"), sc);
	}
	else
	{
	    m_ulOleInitializeTime[iIter] = NOTAVAIL;
	}

	sw.Reset();
#ifdef COM_THREADING_SUPPORT
	sc = CoInitializeEx(NULL, dwInitFlag);
#else
	sc = CoInitialize(NULL);
#endif
	m_ulCoInitializeTime[iIter] = sw.Read();
	Log (TEXT("CoInitialize"), sc);

	if (SUCCEEDED(sc))
	{
	    sw.Reset();
	    CoUninitialize();
	    m_ulCoUninitializeTime[iIter] = sw.Read();
	    Log (TEXT("CoUninitialize"), sc);
	}
	else
	{
	    m_ulCoInitializeTime[iIter] = NOTAVAIL;
	}

    }

    //	first, compute times for repetitive OleInit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
#ifdef OLE_THREADING_SUPPORT
	sc = OleInitializeEx(NULL, dwInitFlag);
#else
	sc = OleInitialize(NULL);
#endif
	m_ulRepOleInitializeTime[iIter] = sw.Read();
	Log (TEXT("OleInitialize"), sc);

	if (FAILED(sc))
	{
	    m_ulRepOleInitializeTime[iIter] = NOTAVAIL;
	}
    }

    //	second, compute times for repetitive OleUninit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
	OleUninitialize();
	m_ulRepOleUninitializeTime[iIter] = sw.Read();
	Log (TEXT("OleUninitialize"), sc);
    }


    //	first, compute times for repetitive CoInit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
#ifdef COM_THREADING_SUPPORT
	sc = CoInitializeEx(NULL, dwInitFlag);
#else
	sc = CoInitialize(NULL);
#endif
	m_ulRepCoInitializeTime[iIter] = sw.Read();
	Log (TEXT("CoInitialize"), sc);

	if (FAILED(sc))
	{
	    m_ulRepCoInitializeTime[iIter] = NOTAVAIL;
	}
    }

    //	second, compute times for repetitive CoUninit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
	CoUninitialize();
	m_ulRepCoUninitializeTime[iIter] = sw.Read();
	Log (TEXT("CoUninitialize"), sc);
    }

    return S_OK;
}					  



SCODE COleInitializeTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("OleInitialize / OleUninitialize"), *m_pInput);

    output.WriteResults (TEXT("\nOleInitialize     "), m_ulIterations,
			 m_ulOleInitializeTime);

    output.WriteResults (TEXT("OleUninitialize   "), m_ulIterations,
			 m_ulOleUninitializeTime);

    output.WriteResults (TEXT("\nRepOleInitialize  "), m_ulIterations,
			 m_ulRepOleInitializeTime);

    output.WriteResults (TEXT("RepOleUninitialize"), m_ulIterations,
			 m_ulRepOleUninitializeTime);

    output.WriteResults (TEXT("\nCoInitialize     "), m_ulIterations,
			 m_ulCoInitializeTime);

    output.WriteResults (TEXT("CoUninitialize   "), m_ulIterations,
			 m_ulCoUninitializeTime);

    output.WriteResults (TEXT("\nRepCoInitialize  "), m_ulIterations,
			 m_ulRepCoInitializeTime);

    output.WriteResults (TEXT("RepCoUninitialize"), m_ulIterations,
			 m_ulRepCoUninitializeTime);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_iid.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_iid.cxx
//
//  Contents:	compare inline vs function call for guid compares
//
//  Classes:	CGuidCompareTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_iid.hxx>
#include <oletest.hxx>


TCHAR *CGuidCompareTest::Name ()
{
    return TEXT("GuidCompare");
}


SCODE CGuidCompareTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    INIT_RESULTS(m_ulRepFunctionNEQTime);
    INIT_RESULTS(m_ulRepFunctionEQTime);
    INIT_RESULTS(m_ulRepInlineNEQTime);
    INIT_RESULTS(m_ulRepInlineEQTime);

    return S_OK;
}


SCODE CGuidCompareTest::Cleanup ()
{	
    return S_OK;
}


SCODE CGuidCompareTest::Run ()
{
	CStopWatch  sw;
	BOOL	    fRslt;

	//  compute times for the function version
	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = IsEqualIID(IID_IUnknown, IID_IClassFactory);
	    m_ulRepFunctionNEQTime[iIter] = sw.Read();
	}
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = IsEqualIID(IID_IUnknown, IID_IUnknown);
	    m_ulRepFunctionEQTime[iIter] = sw.Read();
	}

	//  compute the time for the inline
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = !memcmp((void *)&IID_IUnknown,
				(void *)&IID_IClassFactory, sizeof(GUID));
	    m_ulRepInlineNEQTime[iIter] = sw.Read();
	}
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = !memcmp((void *)&IID_IUnknown,
				(void *)&IID_IUnknown, sizeof(GUID));
	    m_ulRepInlineEQTime[iIter] = sw.Read();
	}

	return S_OK;
}					  



SCODE CGuidCompareTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("GUID Compare"), *m_pInput);

    output.WriteResults (TEXT("\nIsEqualGUID Not Equal x 1000 "),
		m_ulIterations, m_ulRepFunctionNEQTime);
    output.WriteResults (TEXT("\nIsEqualGUID Equal x 1000 "),
                m_ulIterations, m_ulRepFunctionEQTime);

    output.WriteResults (TEXT("memcmp Not Equal x 1000        "),
		m_ulIterations, m_ulRepInlineNEQTime);
    output.WriteResults (TEXT("memcmp Equal x 1000        "),
                m_ulIterations, m_ulRepInlineEQTime);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_mrsh2.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_marsh.cxx
//
//  Contents:	Mashalling test
//
//  Classes:	COleMarshalTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_mrsh2.hxx>
#include <oletest.hxx>
#include <rpc.h>
#include <rpcdce.h>

// funciton prototype
DWORD _stdcall FnThread2(void *param);


ULARGE_INTEGER	ulSeekStart[REPS];	// stream starts
LARGE_INTEGER	libMove[REPS];


const IID *iid2[] = {&IID_IUnknown,	 &IID_IUnknown,
		 &IID_IAdviseSink,	 &IID_IAdviseSink,
		 &IID_IDataObject,	 &IID_IDataObject,
		 &IID_IOleObject,	 &IID_IOleObject,
		 &IID_IOleClientSite,	 &IID_IOleClientSite,
		 &IID_IParseDisplayName, &IID_IParseDisplayName,
		 &IID_IPersistStorage,	 &IID_IPersistStorage,
		 &IID_IPersistFile,	 &IID_IPersistFile,
		 &IID_IStorage, 	 &IID_IStorage,
		 &IID_IOleContainer,	 &IID_IOleContainer,
		 &IID_IOleItemContainer, &IID_IOleItemContainer,
		 &IID_IOleInPlaceSite,	 &IID_IOleInPlaceActiveObject,
		 &IID_IOleInPlaceObject, &IID_IOleInPlaceUIWindow,
		 &IID_IOleInPlaceFrame,	 &IID_IOleWindow};


TCHAR *COleMarshalTest2::Name ()
{
    return TEXT("Marshalling2");
}

SCODE COleMarshalTest2::Setup (CTestInput *pInput)
{
    SCODE sc;

    m_hThrd = NULL;
    m_dwTID1 = GetCurrentThreadId();

    for (ULONG i=0; i<REPS; i++)
	m_pStm[i] = NULL;

    CTestBase::Setup(pInput);

    // Get number of iterations
    m_ulIterations = pInput->GetIterations(Name());

    // set NULL in case of error
    for (i=0; i<m_ulIterations; i++)
	m_punk[i] = NULL;


    // Get custom ClsID from .ini file
    pInput->GetClassID(&m_ClsID, Name());

    // Get class activation context from .ini file
    m_dwClsCtx = pInput->GetClassCtx(Name());

    for (i=0; i<REPS; i++)
    {
	INIT_RESULTS (m_ulMarshalTime[i]);
	INIT_RESULTS (m_ulUnmarshalTime[i]);
	INIT_RESULTS (m_ulReleaseTime[i]);

	INIT_RESULTS (m_ulMarshalTime2[i]);
	INIT_RESULTS (m_ulUnmarshalTime2[i]);
	INIT_RESULTS (m_ulReleaseTime2[i]);
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    for (i=0; i<m_ulIterations; i++)
    {
	//	create an instance of the object to marshal
	sc = CoCreateInstance(m_ClsID, NULL, m_dwClsCtx,
				  IID_IUnknown, (void **)&m_punk[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance failed"), sc);
	    return sc;
	}
    }


    for (i=0; i<REPS; i++)
    {
	//	create a stream to marshal the interface into
	SCODE sc = CreateStreamOnHGlobal(NULL, 0, &m_pStm[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CreateStreamOnHGlobal failed"), sc);
	}
	else
	{
	    // write some data to init the stream
	    DWORD	dwTemp;
	    m_pStm[i]->Write(&dwTemp, sizeof(DWORD), NULL);
	}
    }

    m_hThrd = CreateThread(NULL, 0, FnThread2, (void *)this, 0, &m_dwTID2);
    if (m_hThrd == NULL)
    {
	Log (TEXT("Setup - CreateThread failed"), sc);
    }

    Sleep(50);	// let the other thread initialize
    return S_OK;
}


SCODE COleMarshalTest2::Cleanup ()
{
    //	release objects
    for (ULONG i=0; i<m_ulIterations; i++)
    {
	if (m_punk[i])
	    m_punk[i]->Release();
    }

    for (i=0; i<REPS; i++)
    {
	if (m_pStm[i])
	    m_pStm[i]->Release();
    }

    UninitCOM();

    // close all the handles
    CloseHandle(m_hThrd);

    return S_OK;
}

DWORD _stdcall FnThread2(void *param)
{
    COleMarshalTest2 *pMrshlTst = (COleMarshalTest2 *)param;
    return pMrshlTst->Run2();
}

SCODE COleMarshalTest2::Run ()
{
    CStopWatch sw;
    LPVOID FAR pv[REPS];

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	SCODE		sc[REPS];

	// settle down before running
	Sleep(100);

	// first, marshal the interface REPS times.
	for (ULONG i=0; i<REPS; i++)
	{
	    //	save current stream seek pointer
	    LISet32(libMove[i], 0x00000000);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_CUR, &ulSeekStart[i]);

	    //	marshal the interface into the stream
	    sw.Reset();
	    sc[i] = CoMarshalInterface(m_pStm[i], *iid2[i], m_punk[iIter],
				   0, 0, MSHLFLAGS_NORMAL);
	    m_ulMarshalTime[i][iIter] = sw.Read ();
	    Log (TEXT("CoMarshalInterface"), sc[i]);

	    if (FAILED(sc[i]))
	    {
		m_ulMarshalTime[i][iIter] = NOTAVAIL;
	    }
	}

	// reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}



	// kick the other thread alive
	PostThreadMessage(m_dwTID2, WM_QUIT, NULL, NULL);

	// enter modal loop to dispatch ORPC messages
	MSG msg;
	while (GetMessage(&msg, NULL, WM_NULL, WM_NULL))
	{
	    DispatchMessage(&msg);
	}



	// reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}

	Sleep(100);

	// unmarshal the interface ptrs
	for (i=0; i<REPS; i++)
	{
	    //	unmarshal the interface from the stream
	    sw.Reset ();
	    sc[i] = CoUnmarshalInterface(m_pStm[i], *iid2[i], &pv[i]);
	    m_ulUnmarshalTime2[i][iIter] = sw.Read ();
	    Log (TEXT("CoUnmarshalInterface"), sc[i]);
	}

	Sleep(100);

	// release all the interface ptrs we got
	for (i=0; i<REPS; i++)
	{
	    if (SUCCEEDED(sc[i]))
	    {
		sw.Reset ();
		((IUnknown *)pv[i])->Release ();
		m_ulReleaseTime2[i][iIter] = sw.Read ();
		Log (TEXT("Release"), sc[i]);
	    }
	    else
	    {
		m_ulReleaseTime2[i][iIter] = NOTAVAIL;
		m_ulUnmarshalTime2[i][iIter] = NOTAVAIL;
	    }
	}

	// reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}
    }

    return S_OK;
}


SCODE COleMarshalTest2::Run2 ()
{
    SCODE sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Thread2 - CoInitialize failed."), sc);
        return	sc;
    }

    CStopWatch sw;
    LPVOID FAR pv[REPS];

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	SCODE		sc[REPS];

	// enter modal loop to dispatch ORPC messages
	MSG msg;
	while (GetMessage(&msg, NULL, WM_NULL, WM_NULL))
	{
	    DispatchMessage(&msg);
	}

	Sleep(100);

	// UnmarshalInterface the interfaces from the stream
	for (ULONG i=0; i<REPS; i++)
	{
	    //	unmarshal the interface from the stream
	    sw.Reset ();
	    sc[i] = CoUnmarshalInterface(m_pStm[i], *iid2[i], &pv[i]);
	    m_ulUnmarshalTime[i][iIter] = sw.Read ();
	    Log (TEXT("CoUnmarshalInterface"), sc[i]);
	}

	// now reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}

	Sleep(100);

	// remarshal the interface proxies
	for (i=0; i<REPS; i++)
	{
	    sw.Reset();
	    sc[i] = CoMarshalInterface(m_pStm[i], *iid2[i], (IUnknown *)pv[i],
					   0, 0, MSHLFLAGS_NORMAL);
	    m_ulMarshalTime2[i][iIter] = sw.Read ();
	    Log (TEXT("CoMarshalInterface"), sc[i]);

	    if (FAILED(sc[i]))
	    {
		m_ulMarshalTime2[i][iIter] = NOTAVAIL;
	    }
	}

	Sleep(100);

	// release all the interface ptrs we got
	for (i=0; i<REPS; i++)
	{
	    if (SUCCEEDED(sc[i]))
	    {
		sw.Reset ();
		((IUnknown *)pv[i])->Release ();
		m_ulReleaseTime[i][iIter] = sw.Read ();
		Log (TEXT("Release"), sc[i]);
	    }
	    else
	    {
		m_ulReleaseTime[i][iIter] = NOTAVAIL;
		m_ulUnmarshalTime[i][iIter] = NOTAVAIL;
	    }
	}

	// signal the other thread it is OK to go.
	PostThreadMessage(m_dwTID1, WM_QUIT, NULL, NULL);
    }

    UninitCOM();
    return S_OK;
}


SCODE COleMarshalTest2::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(),
			   TEXT("Interface Marshalling2"),
			   *m_pInput);

    for (ULONG iCtx=0; iCtx<1; iCtx++)
    {
	output.WriteString  (TEXT("\n"));
	output.WriteClassID (&m_ClsID);
	output.WriteString  (apszClsCtx[0]);
	output.WriteString  (TEXT("\n"));

	for (ULONG i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoMarshalInterface  "), m_ulIterations, m_ulMarshalTime[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoUnmarshalInterface"), m_ulIterations, m_ulUnmarshalTime[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("Release Interface   "), m_ulIterations, m_ulReleaseTime[i]);
	}
	output.WriteString	(TEXT("\n"));



	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoMarshalInterface2  "), m_ulIterations, m_ulMarshalTime2[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoUnmarshalInterface2"), m_ulIterations, m_ulUnmarshalTime2[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("Release Interface2   "), m_ulIterations, m_ulReleaseTime2[i]);
	}
	output.WriteString	(TEXT("\n"));

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_nest.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_nest.cxx
//
//  Contents:	Nested Object Rpc Method Invocation tests
//
//  Classes:	CNestTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_nest.hxx>
#include <oletest.hxx>
#include <tracelog.hxx>


TCHAR *CNestTest::Name ()
{
	return TEXT("Nested");
}


SCODE CNestTest::Setup (CTestInput *pInput)
{
	CTestBase::Setup(pInput);

	//  get iteration count
	m_ulIterations = pInput->GetIterations(Name());

	//  get CLSID of server
	SCODE sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Local"));
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	//  initialize timing arrays
	INIT_RESULTS(m_ulNest2Time);
	INIT_RESULTS(m_ulNest3Time);
	INIT_RESULTS(m_ulNest4Time);
	INIT_RESULTS(m_ulNest5Time);


	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return  sc;
	}

	m_pILoop1=NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_ILoop, (void **)&m_pILoop1);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance of first Server failed."), sc);
	    return sc;
	}

	m_pILoop2=NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_ILoop, (void **)&m_pILoop2);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance of second Server failed."), sc);
	    return sc;
	}

	//  pass the pointers to each other
	sc = m_pILoop1->Init(m_pILoop2);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - Initialization of first Server failed."), sc);
	    return sc;
	}

	sc = m_pILoop2->Init(m_pILoop1);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - Initialization of second Server failed."), sc);
	    return sc;
	}


	return S_OK;
}


SCODE CNestTest::Cleanup ()
{
	if (m_pILoop1)
	{
	    m_pILoop1->Uninit();
	    m_pILoop1->Release();
	}

	if (m_pILoop2)
	{
	    m_pILoop2->Uninit();
	    m_pILoop2->Release();
	}

	UninitCOM();
	return S_OK;
}


SCODE CNestTest::Run ()
{
	CStopWatch  sw;
	SCODE sc;

	//
	//  nesting 2 levels. Note we pass in 3 not 2, since the server
	//  subtracts 1 from the passed in value and then stops the nesting
	//  if the count is zero.
	//
	//  a value of 3 represents a single nested call.
	//

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc = m_pILoop1->Loop(3);
	    m_ulNest2Time[iIter] = sw.Read();
	    Log (TEXT("Loop (2)"), sc);
	}

	//
	//  nesting 3 levels
	//

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc= m_pILoop1->Loop(4);
	    m_ulNest3Time[iIter] = sw.Read();
	    Log (TEXT("Loop (3)"), sc);
	}

	//
	//  nesting 4 levels
	//

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc = m_pILoop1->Loop(5);
	    m_ulNest4Time[iIter] = sw.Read();
	    Log (TEXT("Loop (4)"), sc);
	}

	//
	//  nesting 5 levels
	//

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc = m_pILoop1->Loop(6);
	    m_ulNest5Time[iIter] = sw.Read();
	    Log (TEXT("Loop (5)"), sc);
	}

	return S_OK;
}					  



SCODE CNestTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Nested ORpc Calls"), *m_pInput);

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("Nesting 2    "), m_ulIterations, m_ulNest2Time);
    output.WriteResults (TEXT("Nesting 3    "), m_ulIterations, m_ulNest3Time);
    output.WriteResults (TEXT("Nesting 4    "), m_ulIterations, m_ulNest4Time);
    output.WriteResults (TEXT("Nesting 5    "), m_ulIterations, m_ulNest5Time);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_cgps.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_cgps.cxx
//
//  Contents:	test CoGetPSClsid
//
//  Classes:	CCGPSTest
//
//  History:	07-Oct-95   Rickhi	Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop
#include <bm_cgps.hxx>


extern const IID *iid[];



TCHAR *CCGPSTest::Name ()
{
    return TEXT("CoGetPSClsidTest");
}


SCODE CCGPSTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays
    INIT_RESULTS(m_ulCoGetPSClsid);


    SCODE sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
    }

    return sc;
}


SCODE CCGPSTest::Cleanup ()
{
    UninitCOM();
    return S_OK;
}


SCODE CCGPSTest::Run ()
{
    CStopWatch	sw;
    CLSID	clsid;

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
	SCODE sc = CoGetPSClsid(*iid[iIter], &clsid);
	m_ulCoGetPSClsid[iIter] = sw.Read();

	if (FAILED(sc))
	{
	    Log (TEXT("CoGetPSClsid failed."), sc);
	}
    }

    return S_OK;
}					


SCODE CCGPSTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("CoGetPSClsid"), *m_pInput);

    output.WriteString	(TEXT("\n"));
    output.WriteResults (TEXT("CoGetPSClsid "), m_ulIterations, m_ulCoGetPSClsid);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_marsh.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_marsh.cxx
//
//  Contents:	Mashalling test
//
//  Classes:	COleMarshalTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_marsh.hxx>
#include <oletest.hxx>

#include <rpc.h>
#include <rpcdce.h>
// extern "C" RPC_STATUS UuidCreate(GUID *pguid);


TCHAR *COleMarshalTest::Name ()
{
    return TEXT("Marshalling");
}


SCODE COleMarshalTest::Setup (CTestInput *pInput)
{
    SCODE sc;

    for (ULONG i=0; i<REPS; i++)
	m_pStm[i] = NULL;

    CTestBase::Setup(pInput);

    // Get number of iterations
    m_ulIterations = pInput->GetIterations(Name());

    // set NULL in case of error
    for (i=0; i<m_ulIterations; i++)
	m_punk[i] = NULL;


    // Get custom ClsID from .ini file
    pInput->GetClassID(&m_ClsID, Name());

    // Get class activation context from .ini file
    m_dwClsCtx = pInput->GetClassCtx(Name());

    INIT_RESULTS (m_ulUuidCreateTime);

    for (i=0; i<REPS; i++)
    {
	INIT_RESULTS (m_ulMarshalTime[i]);
	INIT_RESULTS (m_ulUnmarshalTime[i]);
	INIT_RESULTS (m_ulLockObjectTime[i]);
	INIT_RESULTS (m_ulGetStdMarshalTime[i]);
	INIT_RESULTS (m_ulGetMarshalSizeTime[i]);
	INIT_RESULTS (m_ulDisconnectTime[i]);
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    for (i=0; i<m_ulIterations; i++)
    {
	//	create an instance of the object to marshal
	sc = CoCreateInstance(m_ClsID, NULL, m_dwClsCtx,
			  IID_IUnknown, (void **)&m_punk[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance failed"), sc);
	    return sc;
	}
    }


    for (i=0; i<REPS; i++)
    {
	// create a stream to marshal the interface into
	SCODE sc = CreateStreamOnHGlobal(NULL, 0, &m_pStm[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CreateStreamOnHGlobal failed"), sc);
	}
	else
	{
	    //	write some data to init the stream
	    DWORD dwTemp;
	    m_pStm[i]->Write(&dwTemp, sizeof(DWORD), NULL);
	}
    }

    return S_OK;
}


SCODE COleMarshalTest::Cleanup ()
{
    //	release objects
    for (ULONG i=0; i<m_ulIterations; i++)
    {
	if (m_punk[i])
	    m_punk[i]->Release();
    }

    for (i=0; i<REPS; i++)
    {
	if (m_pStm[i])
	    m_pStm[i]->Release();
    }

    UninitCOM();
    return S_OK;
}


SCODE COleMarshalTest::Run ()
{
	CStopWatch sw;
	LPVOID FAR pv;

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    SCODE		sc[REPS];
	    ULARGE_INTEGER	ulSeekStart[REPS];
	    LARGE_INTEGER	libMove[REPS];

	    //	create Uuid's
	    GUID    guid;
	    sw.Reset();
	    sc[0] = UuidCreate(&guid);
	    m_ulUuidCreateTime[iIter] = sw.Read();
	    Log (TEXT("UuidCreate"), sc[0]);


	    //	first, marshal the interface REPS times.
	    for (ULONG i=0; i<REPS; i++)
	    {
		//  save current stream seek pointer
		LISet32(libMove[i], 0x00000000);
		m_pStm[i]->Seek(libMove[i], STREAM_SEEK_CUR, &ulSeekStart[i]);

		//  marshal the interface into the stream
		sw.Reset();
		sc[i] = CoMarshalInterface(m_pStm[i], IID_IUnknown, m_punk[iIter],
					   0, 0, MSHLFLAGS_NORMAL);
		m_ulMarshalTime[i][iIter] = sw.Read ();
		Log (TEXT("CoMarshalInterface"), sc[i]);

		if (FAILED(sc[i]))
		{
		    m_ulMarshalTime[i][iIter] = NOTAVAIL;
		}
	    }


	    //	now ReleaseMarshalData once
	    i = 0;
	    {
		// set stream ptr back to the starting position
		LISet32(libMove[i], ulSeekStart[i].LowPart);
		m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);

		// unmarshal the interface from the stream
		sw.Reset ();
		sc[i] = CoReleaseMarshalData(m_pStm[i]);
		m_ulUnmarshalTime[i][iIter] = sw.Read ();
		Log (TEXT("CoReleaseMarshalData"), sc[i]);
	    }


	    //	now UnmarshalInterface the remaining times
	    for (i=1; i<REPS; i++)
	    {
		if (FAILED(sc[i]))
		    continue;

		//  set stream ptr back to the starting position
		LISet32(libMove[i], ulSeekStart[i].LowPart);
		m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);

		//  unmarshal the interface from the stream
		sw.Reset ();
		sc[i] = CoUnmarshalInterface(m_pStm[i], IID_IUnknown, &pv);
		m_ulUnmarshalTime[i][iIter] = sw.Read ();
		Log (TEXT("CoUnmarshalInterface"), sc[i]);

		if (SUCCEEDED(sc[i]))
		{
		    ((IUnknown *)pv)->Release ();  // Unmarshal called AddRef
		}
		else
		{
		    m_ulUnmarshalTime[i][iIter] = NOTAVAIL;
		}
	    }


	    //	call CoLockObjectExternal
	    sw.Reset();
	    sc[0] = CoLockObjectExternal(m_punk[iIter], TRUE, FALSE);
	    m_ulLockObjectTime[0][iIter] = sw.Read();
	    Log (TEXT("CoLockObjectExternal"), sc[0]);

	    sw.Reset();
	    sc[1] = CoLockObjectExternal(m_punk[iIter], FALSE, FALSE);
	    m_ulLockObjectTime[1][iIter] = sw.Read();
	    Log (TEXT("CoLockObjectExternal"), sc[1]);


	    //	call CoGetStdMarshal
	    IMarshal *pIM = NULL;
	    sw.Reset();
	    sc[0] = CoGetStandardMarshal(IID_IUnknown, m_punk[iIter], 0, NULL,
					 MSHLFLAGS_NORMAL, &pIM);
	    m_ulGetStdMarshalTime[0][iIter] = sw.Read();
	    Log (TEXT("CoGetStandardMarshal"), sc[0]);

	    sw.Reset();
	    pIM->Release();
	    m_ulGetStdMarshalTime[1][iIter] = sw.Read();
	    Log (TEXT("Release StdMarshal"), sc[1]);


	    //	call CoGetMarshalSizeMax
	    ULONG ulSize = 0;
	    sw.Reset();
	    sc[0] = CoGetMarshalSizeMax(&ulSize, IID_IUnknown, m_punk[iIter],
					 0, NULL,MSHLFLAGS_NORMAL);
	    m_ulGetMarshalSizeTime[0][iIter] = sw.Read();
	    Log (TEXT("CoGetMarshalSizeMax"), sc[0]);


	    //	call CoDisconnectObject
	    sc[0] = CoLockObjectExternal(m_punk[iIter], TRUE, FALSE);

	    sw.Reset();
	    sc[0] = CoDisconnectObject(m_punk[iIter], 0);
	    m_ulDisconnectTime[0][iIter] = sw.Read();
	    Log (TEXT("CoDisconnectObject"), sc[0]);
	    sc[0] = CoLockObjectExternal(m_punk[iIter], FALSE, FALSE);
	}

	return S_OK;
}


SCODE COleMarshalTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(),
				   TEXT("Interface Marshalling"),
				   *m_pInput);

	for (ULONG iCtx=0; iCtx<1; iCtx++)
	{
	    output.WriteString	(TEXT("\n"));
	    output.WriteClassID (&m_ClsID);
	    output.WriteString	(apszClsCtx[0]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("UuidCreate            "), m_ulIterations, m_ulUuidCreateTime);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoMarshalInterface   1"), m_ulIterations, m_ulMarshalTime[0]);
	    output.WriteResults (TEXT("CoMarshalInterface   2"), m_ulIterations, m_ulMarshalTime[1]);
	    output.WriteResults (TEXT("CoMarshalInterface   3"), m_ulIterations, m_ulMarshalTime[2]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoReleaseMarshalData 3"), m_ulIterations, m_ulUnmarshalTime[0]);
	    output.WriteResults (TEXT("CoUnmarshalInterface 2"), m_ulIterations, m_ulUnmarshalTime[1]);
	    output.WriteResults (TEXT("CoUnmarshalInterface 1"), m_ulIterations, m_ulUnmarshalTime[2]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoLockObjectExternal L"), m_ulIterations, m_ulLockObjectTime[0]);
	    output.WriteResults (TEXT("CoLockObjectExternal U"), m_ulIterations, m_ulLockObjectTime[1]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoGetStandardMarshal  "), m_ulIterations, m_ulGetStdMarshalTime[0]);
	    output.WriteResults (TEXT("pIMarshal->Release    "), m_ulIterations, m_ulGetStdMarshalTime[1]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoDisconnectObject    "), m_ulIterations, m_ulDisconnectTime[0]);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_filio.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//					
//  File:	bm_filio.cxx
//
//  Contents:	Basic File IO test
//
//  Classes:	CFileIOTest
//
//  History:    04-Aug-94 t-vadims    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_filio.hxx>
#include <memory.h>

#define DEF_DATASIZE    16384

TCHAR *CFileIOTest::Name ()
{
    return TEXT("FileIOTest");
}

SCODE CFileIOTest::Setup (CTestInput *pInput)
{
    SCODE sc;
    TCHAR pszValue[16];
    ULONG i;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    // get malloc interface for this task
    m_piMalloc = NULL;
    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
    {
    	Log (TEXT("Setup - CoGetMalloc"), sc);
	Cleanup();
    	return sc;
    }

    // get values of various paremeters from ini file

    m_iStartSize = pInput->GetConfigInt(Name(), TEXT("StartSize"), 16);
    if(m_iStartSize <= 0)
    	m_iStartSize = 16;

    m_iEndSize = pInput->GetConfigInt(Name(), TEXT("EndSize"), DEF_DATASIZE);

    // initialize array to be written to the file.
    m_pbData = (BYTE *)m_piMalloc->Alloc(m_iEndSize);
    if(m_pbData == NULL)
    {
    	Log (TEXT("Setup - Cannot allocate memory"), E_OUTOFMEMORY);
	Cleanup();
	return E_OUTOFMEMORY;
    }

    for (i=0; i < m_iEndSize; i++)
        m_pbData[i] = (BYTE)i;


    m_iRepeatFactor = pInput->GetConfigInt(Name(), TEXT("RepeatFactor"), 1);

    if (m_iRepeatFactor > MAX_REPS)
    	m_iRepeatFactor = MAX_REPS;

    // Figure out how many different sizes we're going to write.
    // and the size of the final file.
    m_ulTotalSize = 0;
    for(m_ulNumSizes = 0, i = m_iStartSize; i <= m_iEndSize; i *=2, m_ulNumSizes++)
	m_ulTotalSize += i * m_iRepeatFactor;


    if (m_iRepeatFactor * m_ulNumSizes > MAX_READS)
    {
    	Log(TEXT("Too many different sizes and/or repeat factor is too big"), E_FAIL);
	Cleanup();
	return E_FAIL;
    }

    m_flStandardCreateFlags = 0;
    // get file name to be used and values of other parameters
    pInput->GetConfigString(Name(), TEXT("FileName"), TEXT("stgtest.bm"),
    			    m_pszFile, MAX_PATH);

    pInput->GetConfigString(Name(), TEXT("WriteThrough"), TEXT("OFF"), pszValue, 15);

    if (lstrcmpi(pszValue, TEXT("ON")) == 0)
    	m_flStandardCreateFlags |= FILE_FLAG_WRITE_THROUGH;

    pInput->GetConfigString(Name(), TEXT("AccessMode"), TEXT("NORMAL"), m_pszAccessMode, 15);

    if (lstrcmpi(m_pszAccessMode, TEXT("ASYNC")) == 0)
    {
    	m_flAccessMode = AM_ASYNC;
	m_flStandardCreateFlags |= FILE_FLAG_OVERLAPPED;
    }
    else if (lstrcmpi(m_pszAccessMode, TEXT("MAPPED")) == 0)
    {
    	m_flAccessMode = AM_MAPPED;
    }
    else
    	m_flAccessMode = AM_NORMAL;

    pInput->GetConfigString(Name(), TEXT("Flush"), TEXT("OFF"), pszValue, 15);

    if (lstrcmpi(pszValue, TEXT("ON")) == 0)
    	m_bFlush = TRUE;
    else
    	m_bFlush = FALSE;

    pInput->GetConfigString(Name(), TEXT("ReadMode"), TEXT("SEQUENTIAL"),
    			    m_pszReadMode, 15);

    if(lstrcmpi(m_pszReadMode, TEXT("SEQUENTIAL")) == 0)
    	m_bSequentialRead = TRUE;
    else
    	m_bSequentialRead = FALSE;


    InitTimings();

    return S_OK;
}


void CFileIOTest::InitTimings()
{
    ULONG i;

    //	initialize timing arrays

    INIT_RESULTS(m_ulOpenFileW);
    INIT_RESULTS(m_ulClose1);
    INIT_RESULTS(m_ulOpenFileR);
    INIT_RESULTS(m_ulClose2);

    ZERO_RESULTS(m_ulWriteTotal);
    ZERO_RESULTS(m_ulReadTotal);
    ZERO_RESULTS(m_ulSeekTotal);

    INIT_RESULTS(m_ulCreateFileMappingW);
    INIT_RESULTS(m_ulMapViewW);
    INIT_RESULTS(m_ulCloseMap1);
    INIT_RESULTS(m_ulUnmapView1);
    ZERO_RESULTS(m_ulFlush1);

    INIT_RESULTS(m_ulCreateFileMappingR);
    INIT_RESULTS(m_ulMapViewR);
    INIT_RESULTS(m_ulCloseMap2);
    INIT_RESULTS(m_ulUnmapView2);
    ZERO_RESULTS(m_ulFlush2);



    for (i = 0; i < MAX_READS; i++)
    {
    	INIT_RESULTS(m_ulWrite[i]);
    	INIT_RESULTS(m_ulRead[i]);
	INIT_RESULTS(m_ulSeek[i]);
    }

    for (i = 0; i < 2; i++ )
    	ZERO_RESULTS(m_ulTotal[i]);

}


SCODE CFileIOTest::Cleanup ()
{
    //	delete the file
    DeleteFile (m_pszFile);
    if(m_piMalloc)
    {
    	if (m_pbData)
    	    m_piMalloc->Free(m_pbData);

	m_pbData = NULL;

	m_piMalloc->Release();
	m_piMalloc = NULL;

    }

    UninitCOM();

    return S_OK;
}

SCODE CFileIOTest::Run ()
{
	CStopWatch  sw;
	ULONG       iIter;
	HANDLE      hFile;
	ULONG       cb;
	ULONG       iSize;
	ULONG	    i, iCount;
	ULONG	    cbCurOffset;

        // Async mode variables
	OVERLAPPED  ov;
	LPOVERLAPPED lpov;
	BOOL        fRes;

	// file-mapped mode variables
        LPBYTE	    lpbFileData;
	HANDLE	    hMap;


	ov.Offset = 0;
	ov.OffsetHigh = 0;
	ov.hEvent = NULL;

	if (IsAsyncMode())
	    lpov = &ov;
	else
	    lpov = NULL;


	// create normal file and write some data to it
	for (iIter = 0; iIter < m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hFile = CreateFile(m_pszFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
	    		       m_flStandardCreateFlags | FILE_ATTRIBUTE_NORMAL, NULL);
	    m_ulOpenFileW[iIter] = sw.Read();
	    Log(TEXT("CreateFile for writing"),
	    	(hFile != INVALID_HANDLE_VALUE) ? S_OK : E_FAIL);
	    if(hFile == INVALID_HANDLE_VALUE)
	        return E_FAIL;

	    if (IsMappedMode())  // create file mapping
	    {

	        sw.Reset();
	        hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, m_ulTotalSize, NULL);
		m_ulCreateFileMappingW[iIter] = sw.Read();

		Log(TEXT("CreateFileMapping"), (hMap != NULL) ? S_OK : E_FAIL);
		if(hMap == NULL)
		{
		    TCHAR szBuf[80];
		    wsprintf(szBuf, TEXT("GetLastError = %ld , FileSize = %ld"), GetLastError(), m_ulTotalSize);
		    Log(szBuf, E_FAIL);
		    CloseHandle(hFile);
		    return E_FAIL;
		}

		sw.Reset();
		lpbFileData = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
		m_ulMapViewW[iIter] = sw.Read();

		Log(TEXT("MapViewOfFile"), (lpbFileData != NULL) ? S_OK : E_FAIL);
		if(lpbFileData == NULL)
		{
		    TCHAR szBuf[80];
		    wsprintf(szBuf, TEXT("GetLastError = %ld"), GetLastError());
		    Log(szBuf, E_FAIL);
		    CloseHandle(hMap);
		    CloseHandle(hFile);
		    return E_FAIL;
		}

	    }

	    cbCurOffset = 0;
	    iCount = 0;
	    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    {

	      for (i = 0; i < m_iRepeatFactor; i++)
	      {
	
	 	if (IsMappedMode())
		{
		    sw.Reset();
		    memcpy(lpbFileData + cbCurOffset, m_pbData, iSize);
	     	    m_ulWrite[iCount][iIter] = sw.Read();
		    cb = iSize; // force correct cb for error check
		}
		else
		{
		    ov.Offset = cbCurOffset;
		    sw.Reset();
	    	    fRes = WriteFile(hFile, (LPSTR)m_pbData, iSize, &cb, lpov);
	     	    m_ulWrite[iCount][iIter] = sw.Read();
		}
		m_ulWriteTotal[iIter] += m_ulWrite[iCount][iIter];

		if (IsAsyncMode())	// if in async mode wait for result
		{
		     if(!fRes)
		     {
		     	Log(TEXT("Doing Actual Async call"), S_OK);
			GetOverlappedResult(hFile, lpov, &cb, TRUE);
		     }

		}

		Log(TEXT("Writing data"), cb == iSize ? S_OK : E_FAIL);

		cbCurOffset += iSize;
		iCount++;
	      }
	    }
	    Log(TEXT("WriteFile X bytes"), S_OK );

            if (IsMappedMode())
	    {
	    	if (m_bFlush)
		{
		    sw.Reset();
		    fRes = FlushViewOfFile((LPVOID) lpbFileData, 0);
		    m_ulFlush1[iIter] = sw.Read();
		    Log(TEXT("FlushViewOfFile"), fRes ? S_OK : E_FAIL);
		}	

	    	sw.Reset();
		fRes = UnmapViewOfFile((LPVOID) lpbFileData);
		m_ulUnmapView1[iIter] = sw.Read();
		Log(TEXT("UnmapViewOfFile"), fRes ? S_OK : E_FAIL);
	
	    	sw.Reset();
		CloseHandle(hMap);
		m_ulCloseMap1[iIter] = sw.Read();
		Log(TEXT("CloseHandle of file-mapping"), S_OK);
	    }
            else if (m_bFlush)
	    {
	    	sw.Reset();
		fRes = FlushFileBuffers(hFile);
		m_ulFlush1[iIter] = sw.Read();
	        Log(TEXT("FlushFileBuffers"), fRes ? S_OK : E_FAIL);
	    }

	    sw.Reset();
	    CloseHandle(hFile);
	    m_ulClose1[iIter] = sw.Read();

	    m_ulTotal[0][iIter] = m_ulOpenFileW[iIter] +
	                    	  m_ulWriteTotal[iIter] +
				  m_ulFlush1[iIter] +
	                    	  m_ulClose1[iIter];

	    if (IsMappedMode())
	    {
	    	m_ulTotal[0][iIter] +=  m_ulCreateFileMappingW[iIter] +
					m_ulMapViewW[iIter] +
					m_ulUnmapView1[iIter] +
					m_ulCloseMap1[iIter];
	    }

	}

	// try to read from that file
	for (iIter = 0; iIter < m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hFile = CreateFile(m_pszFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
	    		       m_flStandardCreateFlags | FILE_ATTRIBUTE_NORMAL, NULL);
	    m_ulOpenFileR[iIter] = sw.Read();
	    Log(TEXT("CreateFile for reading"),
	    	(hFile != INVALID_HANDLE_VALUE) ? S_OK : E_FAIL);
	    if(hFile == INVALID_HANDLE_VALUE)
	        return E_FAIL;

	    if (IsMappedMode())  // create file mapping
	    {
	        sw.Reset();
	        hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
		m_ulCreateFileMappingR[iIter] = sw.Read();

		Log(TEXT("CreateFileMapping"), (hMap != NULL) ? S_OK : E_FAIL);
		if(hMap == NULL)
		{
		    CloseHandle(hFile);
		    return E_FAIL;
		}

		sw.Reset();
		lpbFileData = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
		m_ulMapViewR[iIter] = sw.Read();

		Log(TEXT("MapViewOfFile"), (lpbFileData != NULL) ? S_OK : E_FAIL);
		if(lpbFileData == NULL)
		{
		    CloseHandle(hMap);
		    CloseHandle(hFile);
		    return E_FAIL;
		}

	    }

	    cbCurOffset = 0;
	    iCount = 0;

	    if (m_bSequentialRead)
	    {
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
		  for (i =0; i < m_iRepeatFactor; i++)
		  {
	
	            if (IsMappedMode())
		    {
		    	sw.Reset();
		    	memcpy(m_pbData, lpbFileData + cbCurOffset, iSize);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
			cb = iSize;	 // force correct cb for error check
	    	    }
		    else
		    {
		    	ov.Offset = cbCurOffset;
	 	    	sw.Reset();
	   	    	fRes = ReadFile(hFile, (LPSTR)m_pbData, iSize, &cb, lpov);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
		    }
	    	    m_ulReadTotal[iIter] += m_ulRead[iCount][iIter];

		    if (IsAsyncMode())   // in async mode wait for result
		    {
		     	if(!fRes)
		     	{
		     	    Log(TEXT("Doing Actual Async call"), S_OK);
			    GetOverlappedResult(hFile, lpov, &cb, TRUE);
		        }

		    }

		    Log(TEXT("Reading data"),  cb == iSize ? S_OK : E_FAIL);

		    cbCurOffset += iSize;
		    iCount++;
		  }
	    	}

	    	Log(TEXT("ReadFile Sequential"), S_OK);
	    }
	    else
	    {
	        cbCurOffset = m_ulTotalSize;
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
	    	  for ( i =0; i< m_iRepeatFactor; i++)
		  {
		    cbCurOffset -= iSize;
		    ov.Offset = cbCurOffset;

		    if (IsNormalMode())
		    {
	    	    	sw.Reset();
	    	    	SetFilePointer(hFile, cbCurOffset, NULL, FILE_BEGIN);
	     	    	m_ulSeek[iCount][iIter] = sw.Read();
	     	    	m_ulSeekTotal[iIter] += m_ulSeek[iCount][iIter];
		    }
	    	
	 	    if (IsMappedMode())
		    {
		    	sw.Reset();
		    	memcpy(m_pbData, lpbFileData + cbCurOffset, iSize);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
			cb = iSize;  // force correct cb for error check.
		    }
		    else
		    {
		    	sw.Reset();
  	    		fRes = ReadFile(hFile, (LPSTR)m_pbData, iSize, &cb, lpov);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
		    }
	     	    m_ulReadTotal[iIter] = m_ulRead[iCount][iIter];

		    if (IsAsyncMode())
		    {
		     	if(!fRes)
		     	{
		     	    Log(TEXT("Doing Actual Async call"), S_OK);
			    GetOverlappedResult(hFile, lpov, &cb, TRUE);
		        }
		    }
		    Log(TEXT("Reading data"),  cb == iSize ? S_OK : E_FAIL);
		    iCount++;
	    	  }
		}
	    	Log(TEXT("ReadFile Random"), S_OK);
	    }


            if (IsMappedMode())
	    {
	    	if (m_bFlush)
		{
		    sw.Reset();
		    fRes = FlushViewOfFile((LPVOID) lpbFileData, 0);
		    m_ulFlush2[iIter] = sw.Read();
		    Log(TEXT("FlushViewOfFile"), fRes ? S_OK : E_FAIL);
		}	

	    	sw.Reset();
		fRes = UnmapViewOfFile((LPVOID) lpbFileData);
		m_ulUnmapView2[iIter] = sw.Read();
		Log(TEXT("UnmapViewOfFile"), fRes ? S_OK : E_FAIL);
	
	    	sw.Reset();
		CloseHandle(hMap);
		m_ulCloseMap2[iIter] = sw.Read();
		Log(TEXT("CloseHandle of file-mapping"), S_OK);
	    }
	    else if ( m_bFlush)
	    {
	    	sw.Reset();
		fRes = FlushFileBuffers(hFile);
		m_ulFlush2[iIter] = sw.Read();
	        Log(TEXT("FlushFileBuffers"), fRes ? S_OK : E_FAIL);
	    }

	    sw.Reset();
	    CloseHandle(hFile);
	    m_ulClose2[iIter] = sw.Read();
	    Log(TEXT("CloseHandle of File"), S_OK);

	    m_ulTotal[1][iIter] = m_ulOpenFileR[iIter] +
	    			  m_ulSeekTotal[iIter] +
	    	                  m_ulReadTotal[iIter] +
				  m_ulFlush2[iIter] +
	        	          m_ulClose2[iIter];
	    if (IsMappedMode())
	    {
	    	m_ulTotal[1][iIter] +=  m_ulCreateFileMappingR[iIter] +
					m_ulMapViewR[iIter] +
					m_ulUnmapView2[iIter] +
					m_ulCloseMap2[iIter];
	    }
    	}


    	return S_OK;
}


SCODE CFileIOTest::Report (CTestOutput &output)
{
    TCHAR pszBuf[80];
    ULONG i, iSize, iCount;

    wsprintf(pszBuf, TEXT("File IO in %s Mode with %s Read/Writes"),
    	      m_pszAccessMode, m_pszReadMode);
    output.WriteSectionHeader (Name(), pszBuf, *m_pInput);

    wsprintf(pszBuf, TEXT("WriteThrough is %s\n"),
    		(m_flStandardCreateFlags & FILE_FLAG_WRITE_THROUGH) ? TEXT("ON") : TEXT("OFF"));
    output.WriteString (pszBuf);

    wsprintf(pszBuf, TEXT("Flush is %s\n\n"), m_bFlush ? TEXT("ON") : TEXT("OFF"));
    output.WriteString (pszBuf);


    output.WriteResults (TEXT("CreateFile   WRITE "), m_ulIterations,
    			 m_ulOpenFileW);

    if (IsMappedMode())
    {
    	output.WriteResults(TEXT("CreateFileMapping"), m_ulIterations,
    			    m_ulCreateFileMappingW);

	output.WriteResults(TEXT("MapViewOfFile    "), m_ulIterations,
			    m_ulMapViewW);
    }

    output.WriteString (TEXT("\n"));

    iCount = 0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i = 0; i < m_iRepeatFactor; i++)
	{

    	     wsprintf(pszBuf, TEXT("WriteFile %-9d"), iSize);

    	     output.WriteResults (pszBuf, m_ulIterations, m_ulWrite[iCount]);
	     iCount++;
	}
    }

    output.WriteResults (TEXT("Write     Total    "), m_ulIterations, m_ulWriteTotal);

    output.WriteString (TEXT("\n"));

    if (IsMappedMode())
    {
    	if (m_bFlush)
	    output.WriteResults(TEXT("FlushViewOfFile  "), m_ulIterations,
			    m_ulFlush1);
		
	output.WriteResults(TEXT("UnmapViewOfFile  "), m_ulIterations,
			    m_ulUnmapView1);

    	output.WriteResults(TEXT("CloseMapping     "), m_ulIterations,
    			    m_ulCloseMap1);
    }

    else if (m_bFlush)
	    output.WriteResults(TEXT("FlushFileBuffers "), m_ulIterations,
			    m_ulFlush1);

    output.WriteResults (TEXT("CloseHandle         "), m_ulIterations,
    			 m_ulClose1);

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[0]);
    output.WriteString (TEXT("\n\n"));

    output.WriteResults (TEXT("CreateFile    READ  "), m_ulIterations,
    			 m_ulOpenFileR);

    if (IsMappedMode())
    {
    	output.WriteResults(TEXT("CreateFileMapping"), m_ulIterations,
    			    m_ulCreateFileMappingR);

	output.WriteResults(TEXT("MapViewOfFile    "), m_ulIterations,
			    m_ulMapViewR);
    }

    output.WriteString (TEXT("\n"));

    iCount =0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i=0; i < m_iRepeatFactor; i++)
	{
    	    if (!m_bSequentialRead && IsNormalMode())
	    {
    	    	wsprintf(pszBuf, TEXT("SetFilePosition %-9d"), m_iEndSize - iSize);
    	    	output.WriteResults (pszBuf, m_ulIterations, m_ulSeek[iCount]);
	    }
    	    wsprintf(pszBuf, TEXT("ReadFile  %-9d"), iSize);
    	    output.WriteResults (pszBuf, m_ulIterations, m_ulRead[iCount]);
	    iCount++;
	}
    }

    if (!m_bSequentialRead && IsNormalMode())
        output.WriteResults (TEXT("Seek      Total  "), m_ulIterations, m_ulSeekTotal);

    output.WriteResults (TEXT("Read      Total  "), m_ulIterations, m_ulReadTotal);

    output.WriteString (TEXT("\n"));

    if (IsMappedMode())
    {
    	if (m_bFlush)
	    output.WriteResults(TEXT("FlushViewOfFile  "), m_ulIterations,
			    m_ulFlush2);

	output.WriteResults(TEXT("UnmapViewOfFile  "), m_ulIterations,
			    m_ulUnmapView2);

    	output.WriteResults(TEXT("CloseMapping     "), m_ulIterations,
    			    m_ulCloseMap2);

    }
    else if ( m_bFlush)
	    output.WriteResults(TEXT("FlushFileBuffers "), m_ulIterations,
			    m_ulFlush2);

    output.WriteResults (TEXT("CloseHandle         "), m_ulIterations,
    			 m_ulClose2);

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[1]);

    output.WriteString (TEXT("\n"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_noise.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    bm_noise.cxx
//
//  Contents:	output class for benchmark results
//
//  Classes:	CNoiseTest
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_noise.hxx>



TCHAR *CNoiseTest::Name ()
{
    return TEXT("Noise Test");
}


SCODE CNoiseTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name(), TEST_MAX_ITERATIONS);
    INIT_RESULTS(m_ulNoiseTime);
    return S_OK;
}


SCODE CNoiseTest::Run ()
{
	CStopWatch sw;
	int n;
	FILE *pfDump;
	char buffer[100];
	int i;

	m_ulResolution = sw.Resolution();

	sw.Reset();
	Sleep (1000);
	m_ulSleep = sw.Read();

	sw.Reset();
	for (n=0; n<10000; n++);
	m_ulIdle = sw.Read();

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
        sw.Reset();
        m_ulNoiseTime[iIter] = sw.Read();
	}

	pfDump = fopen ("C:\\DUMP.BM", "wb");
	if (pfDump)
	{
		sw.Reset();
		for (i=0; i<1000; i++)
			fwrite (&buffer, 1, 100, pfDump);
		m_ulDumpWrite = sw.Read();
		fclose (pfDump);

		pfDump = fopen ("C:\\DUMP.BM", "rb");
		if (pfDump)
		{
			sw.Reset();
			for (i=0; i<1000; i++)
				fread (&buffer, 1, 100, pfDump);
			m_ulDumpRead = sw.Read();
			fclose (pfDump);
		}
		else
			m_ulDumpRead = 0xffffffff;
		
		_unlink ("C:\\DUMP.BM");
	}
	else
		m_ulDumpWrite = 0xffffffff;

	return S_OK;
}					



SCODE CNoiseTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), NULL, *m_pInput);

    output.WriteResult (TEXT("Resolution"), m_ulResolution);
    output.WriteResult (TEXT("Sleep 1000ms"), m_ulSleep);
    output.WriteResult (TEXT("Idle 10000 loops"), m_ulIdle);
    output.WriteResults (TEXT("Noise"), m_ulIterations, m_ulNoiseTime);
    output.WriteResult (TEXT("Write 100k to disk"), m_ulDumpWrite);
    output.WriteResult (TEXT("Read 100k from disk"), m_ulDumpRead);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_obind.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_obind.cxx
//
//  Contents:	Ole moniker binding test (BindToObject)
//
//  Classes:	CFileMonikerObjBindTest
//
//  History:    9-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_obind.hxx>


TCHAR *CFileMonikerObjBindTest::Name ()
{
    return TEXT("BindToObject");
}


SCODE CFileMonikerObjBindTest::Setup (CTestInput *pInput)
{
    IClassFactory	*pICF = NULL;
    IPersistFile	*pIPF = NULL;
    SCODE		 sc = S_OK, scRet = S_OK;


    CTestBase::Setup(pInput);

    // get the iteration count from the ini file
    m_ulIterations = pInput->GetIterations(Name());

    //	for each class ctx, get the classid, and init internal state
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	// Get ClsID for this Ctx from the .ini file
	sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	INIT_RESULTS(m_ulCreateMkrTime[iCtx]);
	INIT_RESULTS(m_ulCreateBndCtxTime[iCtx]);
	INIT_RESULTS(m_ulBindTime[iCtx]);
    }


    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }


    //	for each class ctx, create a persistent instance on disk
    for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	// Create an instance
	sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				  IID_IClassFactory, (void **)&pICF);
	if (SUCCEEDED(sc))
	{
	    sc = pICF->CreateInstance(NULL, IID_IPersistFile,
					  (void **)&pIPF);
	    pICF->Release();
	    if (SUCCEEDED(sc))
	    {
		// save the class instance in the storage
		sc = pIPF->Save(apszPerstName[iCtx], FALSE);
		pIPF->Release();

		if (FAILED(sc))
		{
		    Log (TEXT("Setup - pIPF->Save failed."), sc);
		    scRet = sc;
		}
	    }
	    else
	    {
		Log (TEXT("Setup - CreateInstance failed"), sc);
		scRet = sc;
	    }
	}
	else
	{
	    Log (TEXT("Setup - CoGetClassObject failed"), sc);
	    scRet = sc;
	}
    }

    return scRet;
}


SCODE CFileMonikerObjBindTest::Cleanup ()
{	
	UninitCOM();

	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete original
	    wcstombs(szPerstName, apszPerstName[iCtx],
		     wcslen(apszPerstName[iCtx])+1);
	    _unlink (szPerstName);
	}

	return S_OK;
}


SCODE CFileMonikerObjBindTest::Run ()
{
	CStopWatch   sw;
	IMoniker     *pmk = NULL;
	IBindCtx     *pbc = NULL;
	IPersistFile *pIPF = NULL;
	SCODE	     sc;

	//  for each class context
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = CreateFileMoniker (apszPerstName[iCtx], &pmk);
		m_ulCreateMkrTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("CreateFileMoniker"), sc))
		{
		    m_ulCreateMkrTime[iCtx][iIter] = NOTAVAIL;
		}

		sw.Reset();
		sc = CreateBindCtx(0, &pbc);
		m_ulCreateBndCtxTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("CreateBindCtx"), sc))
		{
		    m_ulCreateBndCtxTime[iCtx][iIter] = NOTAVAIL;
		}

		sw.Reset();
		sc = pmk->BindToObject(pbc, NULL, IID_IPersistFile, (void**)&pIPF);
		m_ulBindTime[iCtx][iIter]=sw.Read ();

		pmk->Release();
		pbc->Release();

		if (Log (TEXT("BindToObject"), sc))
		{
		    m_ulBindTime[iCtx][iIter] = NOTAVAIL;
		}
		else
		{
		    sw.Reset();
		    pIPF->Release();
		    m_ulReleaseTime[iCtx][iIter]=sw.Read ();
		}
	    }
	}

	return S_OK;
}		



SCODE CFileMonikerObjBindTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("BindToObject via FileMoniker"), *m_pInput);

	//  for each clsctx, write the results
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(TEXT("\n"));
	    output.WriteClassID(&m_ClsID[iCtx]);
	    output.WriteString(apszClsCtx[iCtx]);
	    output.WriteString(TEXT("\n"));

	    output.WriteResults(TEXT("CreateMoniker"), m_ulIterations, m_ulCreateMkrTime[iCtx]);
	    output.WriteResults(TEXT("CreateBindCtx"), m_ulIterations, m_ulCreateBndCtxTime[iCtx]);
	    output.WriteResults(TEXT("Bind         "), m_ulIterations, m_ulBindTime[iCtx]);
	    output.WriteResults(TEXT("Release      "), m_ulIterations, m_ulReleaseTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_piact.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_piact.cxx
//
//  Contents:	Persistant instance activation test
//
//  Classes:	COlePersistActivationTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_piact.hxx>


WCHAR *COlePersistActivationTest::Name ()
{
	return L"PersistActivation";
}


SCODE COlePersistActivationTest::Setup (CTestInput *pInput)
{
	IPersistFile   *pIPF = NULL;
	IClassFactory  *pICF = NULL;
	SCODE		sc = S_OK, scRet = S_OK;

	CTestBase::Setup (pInput);

	// Get number of iterations
	m_ulIterations = pInput->GetIterations(Name());

	//  for each class ctx, get the classid, and init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Get ClsID for this Ctx from the .ini file
	    sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apwszClsIDName[iCtx]);
	    if (FAILED(sc))
	    {
		Log (L"Setup - GetGUID failed", sc);
		return sc;
	    }

	    INIT_RESULTS (m_ulNewTime[iCtx]);
	    INIT_RESULTS (m_ulGetTime[iCtx]);
	}


    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }


	//  for each class ctx, create a persistent instance on disk
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Create an instance
	    sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				  IID_IClassFactory, (void **)&pICF);
	    if (SUCCEEDED(sc))
	    {
		sc = pICF->CreateInstance(NULL, IID_IPersistFile, (void **)&pIPF);
		pICF->Release();
		if (SUCCEEDED(sc))
		{
		    //	save the instance in a file
		    sc = pIPF->Save (apwszPerstName[iCtx], TRUE);
		    pIPF->Release();

		    if (FAILED(sc))
		    {
			Log (L"Setup - IPersistFile::Save failed", sc);
			scRet = sc;
		    }
		}
		else
		{
		    Log (L"Setup - CreateInstance failed", sc);
		    scRet = sc;
		}

	    }
	    else
	    {
		Log (L"Setup - CoGetClassObject failed", sc);
		scRet = sc;
	    }
	}

	// _pInput = pInput;
	return scRet;
}


SCODE COlePersistActivationTest::Cleanup ()
{
	UninitCOM();

	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete original
	    wcstombs(szPerstName, apwszPerstName[iCtx],
		     wcslen(apwszPerstName[iCtx])+1);
	    _unlink (szPerstName);

	    //	delete new instance
	    wcstombs(szPerstName, apwszPerstNameNew[iCtx],
		     wcslen(apwszPerstNameNew[iCtx])+1);
	    _unlink (szPerstName);
	}

	return S_OK;
}


SCODE COlePersistActivationTest::Run ()
{
	CStopWatch  sw;
	IUnknown   *punk = NULL;
	SCODE	    sc;

	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = CoGetPersistentInstance(IID_IUnknown,
					dwaClsCtx[iCtx],
					STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
					apwszPerstName[iCtx],
					NULL,
					CLSID_NULL,
					NULL,
					(void**)&punk);

		m_ulGetTime[iCtx][iIter] = sw.Read();
		Log (L"CoGetPersistentInstance", sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    punk->Release();
		    m_ulGetReleaseTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulGetTime[iCtx][iIter] = NOTAVAIL;
		}

		// _pInput->Pause(IP_ITERPAUSE);

		sw.Reset();
		sc = CoNewPersistentInstance(m_ClsID[iCtx],
					IID_IUnknown,
					dwaClsCtx[iCtx],
					STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
					apwszPerstName[iCtx],
					NULL,
					apwszPerstNameNew[iCtx],
					(void**)&punk);
		m_ulNewTime[iCtx][iIter] = sw.Read();
		Log (L"CoNewPersistentInstance", sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    punk->Release();
		    m_ulNewReleaseTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulNewTime[iCtx][iIter] = NOTAVAIL;
		}

		CHAR	szPerstName[80];
		wcstombs(szPerstName, apwszPerstNameNew[iCtx],
			  wcslen(apwszPerstNameNew[iCtx])+1);
		_unlink(szPerstName);

		// _pInput->Pause(IP_ITERPAUSE);
	    }
	}

	return S_OK;
}



SCODE COlePersistActivationTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(),
			   L"CoGetPersistentInstance / CoNewPersistentInstance",
			   *m_pInput);

	//  for each clsctx, write the results
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(L"\n");
	    output.WriteClassID (&m_ClsID[iCtx]);
	    output.WriteString (apwszClsCtx[iCtx]);
	    output.WriteString(L"\n");

	    output.WriteResults (L"CoGetPI", m_ulIterations, m_ulGetTime[iCtx]);
	    output.WriteResults (L"Release", m_ulIterations, m_ulGetReleaseTime[iCtx]);
	    output.WriteResults (L"CoNewPI", m_ulIterations, m_ulNewTime[iCtx]);
	    output.WriteResults (L"Release", m_ulIterations, m_ulNewReleaseTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_nstg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_nstg.cxx
//
//  Contents:	Nested Storage test
//
//  Classes:	CNestedStorageTest
//
//  History:    09-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_nstg.hxx>

#define  DEF_DATASIZE    4096
#define  INFINITY	 0xffffffff	// max value of 32-bit ulong
			        
TCHAR *CNestedStorageTest::Name ()
{
    return TEXT("NestedStorageTest");
}


SCODE CNestedStorageTest::Setup (CTestInput *pInput)
{
    SCODE sc;
    ULONG iIndex;
    TCHAR pszBuf[15];
    
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays   
    INIT_RESULTS(m_ulStgCreateDocfile);
    INIT_RESULTS(m_ulFinalStorageCommit);
    INIT_RESULTS(m_ulFinalStorageRelease);

    for(iIndex = 0; iIndex <TEST_MAX_ITERATIONS; iIndex++)
    {
	m_ulCreateStorageTotal[iIndex] = 0;
	m_ulCreateStreamTotal[iIndex] = 0;
	m_ulStreamWriteTotal[iIndex] = 0;
	m_ulStreamReleaseTotal[iIndex] = 0;
	m_ulDestroyElementTotal[iIndex] = 0;
	m_ulStorageCommitTotal[iIndex] = 0;
	m_ulStorageReleaseTotal[iIndex] = 0;
	m_ulTotal[iIndex] = 0;

	m_ulCreateStreamMin[iIndex] = INFINITY;
	m_ulStreamWriteMin[iIndex] = INFINITY;
	m_ulStreamReleaseMin[iIndex] = INFINITY;
	m_ulDestroyElementMin[iIndex] = INFINITY;

	m_ulCreateStreamMax[iIndex] = 0;
	m_ulStreamWriteMax[iIndex] = 0;
	m_ulStreamReleaseMax[iIndex] = 0;
	m_ulDestroyElementMax[iIndex] = 0;

	for (ULONG iLevel =0; iLevel < MAX_NESTING; iLevel++)
	{
	    m_ulStorageCommitMin[iLevel][iIndex] = INFINITY;
	    m_ulStorageReleaseMin[iLevel][iIndex] = INFINITY;
	    m_ulCreateStorageMin[iLevel][iIndex] = INFINITY;

	    m_ulCreateStorageMax[iLevel][iIndex] = 0;
	    m_ulStorageCommitMax[iLevel][iIndex] = 0;
	    m_ulStorageReleaseMax[iLevel][iIndex] = 0;
    	}
    }



    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    // get malloc interface for this task
    m_piMalloc = NULL;
    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
    {
    	Log (TEXT("Setup - CoGetMalloc"), sc);
    	return sc;
    }

    m_cbSize = pInput->GetConfigInt(Name(), TEXT("DataSize"), DEF_DATASIZE);
 
    // initialize array to be written to the file.  
    m_pbData = (BYTE *)m_piMalloc->Alloc(m_cbSize);
    if(m_pbData == NULL)
    {
    	Log (TEXT("Setup - Cannot allocate memory"), E_OUTOFMEMORY);
	return E_OUTOFMEMORY;
    }

    for (iIndex=0; iIndex < m_cbSize; iIndex++)
        m_pbData[iIndex] = (BYTE)iIndex;


    // get file name to be used and values of other parameters
    pInput->GetConfigString(Name(), TEXT("FileName"), TEXT("stgtest.bm"),
    			    m_pszFile, MAX_PATH);
#ifdef UNICODE
    wcscpy(m_pwszFile, m_pszFile);
#else
    mbstowcs(m_pwszFile, m_pszFile, strlen(m_pszFile)+1);
#endif

    pInput->GetConfigString(Name(), TEXT("FileMode"), TEXT("DIRECT"), m_pszFileMode, 15);

    if(lstrcmpi(m_pszFileMode, TEXT("DIRECT")) == 0)
       	m_flCreateFlags = STGM_DIRECT;
    else 
       	m_flCreateFlags = STGM_TRANSACTED; 	

    // get the nesting factor
    m_cNesting = pInput->GetConfigInt(Name(), TEXT("Nesting"), 3);

    if(m_cNesting > MAX_NESTING)
    	m_cNesting = MAX_NESTING;
    
    if(m_cNesting == 0)
    	m_cNesting = 1;
    	 
    // get the branching factor
    m_cBranching = pInput->GetConfigInt(Name(), TEXT("Branching"), 3);

    if(m_cBranching > MAX_BRANCHING)
    	m_cBranching = MAX_BRANCHING;
    
    if(m_cBranching == 0)
    	m_cBranching = 1;

    // get the value of Delete element option
    pInput->GetConfigString(Name(), TEXT("Delete"), TEXT("OFF"), pszBuf, 15);
    
    if( lstrcmpi(pszBuf, TEXT("OFF")) == 0 ||
        lstrcmpi(pszBuf, TEXT("FALSE")) == 0)
    	m_bDelete = FALSE;
    else
    	m_bDelete = TRUE; 

    // now compute number of streams and storages, depeding on 
    // the nesting and branching factors.  Formulas are as follows:
    // Nesting = n;
    // Branching = b;
    //    	       n
    // Streams    =   b
    //
    //		       n
    //		      b	  - 1 
    // Storages   =  ---------
    //		      b   - 1
    //
    //		        n-1
    //		       b   - 1
    // ParentFactor = ---------
    //                 b   - 1
    //
    // Parent factor is used to determine the parent storage of the stream
    //
    m_cStreams = 1;
    ULONG n = m_cNesting;
    while(n-- > 0)                   // compute b^n
        m_cStreams *= m_cBranching;

    m_cStorages = (m_cStreams - 1) / (m_cBranching - 1);

    m_cParentFactor = (m_cStreams / m_cBranching - 1) / 
    		      (m_cBranching - 1);


    // allocate arrays for storages
    m_piStorages = (LPSTORAGE *)m_piMalloc->Alloc(m_cStorages * 
    						sizeof(LPSTORAGE));
    if (m_piStorages == NULL)
    {
    	Log(TEXT("Cannot allocate memory"), E_OUTOFMEMORY);
	return E_OUTOFMEMORY;
    }

    return S_OK;
}


SCODE CNestedStorageTest::Cleanup ()
{
    //	delete the file
    DeleteFile (m_pszFile);

    // free all memory
    if(m_piMalloc)
    {
    	if (m_pbData)
    	    m_piMalloc->Free(m_pbData);

	if (m_piStorages)
    	    m_piMalloc->Free(m_piStorages);

	m_piMalloc->Release();
	m_piMalloc = NULL;
    }

    UninitCOM();

    return S_OK;
}


// Some macros that are used only in Run() function.

#define  STG_PARENT(iIndex)    ((iIndex - 1) / m_cBranching )
#define  STREAM_PARENT(iIndex) (iIndex / m_cBranching + m_cParentFactor )

// STG_NAME and STREAM_NAME macros are very ugly, but they save
// doing a bunch of allocations and name generation in the beginning.

#define  STG_NAME(iIndex)      (swprintf(pwszBuf, L"Storage%d", iIndex), pwszBuf)
#define  STREAM_NAME(iIndex)   (swprintf(pwszBuf, L"Stream%d", iIndex), pwszBuf)


SCODE CNestedStorageTest::Run ()
{
    CStopWatch   sw;
    HRESULT	 hr;
    ULONG	 cb;
    ULONG        iCurStream;
    LONG	 iCurStg;    // has to be long, not ulong, for looping down to zero.
    LPSTREAM	 piStream;
    ULONG	 iIter;
    OLECHAR	 pwszBuf[20];
    ULONG	 ulTime;
    ULONG	 iLevel;
    ULONG	 iParent;
 

    for (iIter =0; iIter < m_ulIterations; iIter++)
    {

        sw.Reset();
    	hr = StgCreateDocfile(m_pwszFile,  m_flCreateFlags  | STGM_WRITE
           	| STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &m_piStorages[0]);
	m_ulStgCreateDocfile[iIter] = sw.Read();
  	Log(TEXT("StgCreateDocfile"), hr);
	if (FAILED(hr))
	    return hr;

	// Create a complete tree of storages 
    	for (iCurStg = 1; iCurStg < (LONG)m_cStorages; iCurStg++)
    	{
	    // determine level of curent storage.
	    iLevel = 0;
	    iParent = STG_PARENT(iCurStg);
	    while(iParent > 0)
	    {
	    	iParent = STG_PARENT(iParent);
		iLevel++;
	    }

	    sw.Reset();
 	    hr = m_piStorages[STG_PARENT(iCurStg)]->
 		      CreateStorage(STG_NAME(iCurStg), 
 			      m_flCreateFlags | STGM_WRITE | 
 			      STGM_CREATE | STGM_SHARE_EXCLUSIVE,
 			      0, 0, &m_piStorages[iCurStg]);
	    ulTime = sw.Read();
	    m_ulCreateStorageTotal[iIter] += ulTime;

	    if(ulTime < m_ulCreateStorageMin[iLevel][iIter])
	    	m_ulCreateStorageMin[iLevel][iIter] = ulTime;

	    if(ulTime > m_ulCreateStorageMax[iLevel][iIter])
	    	m_ulCreateStorageMax[iLevel][iIter] = ulTime;

	    if (FAILED(hr))
	    {
	        Log(TEXT("CreateStorage"), hr);
	    	return hr;
	    }
    	}
        Log(TEXT("CreateStorage"), S_OK);
  	// For each storage in final level, open several streams,
	// write some data to them, and release them
	for (iCurStream = 0; iCurStream < m_cStreams; iCurStream++)
    	{
	    sw.Reset();
 	    hr = m_piStorages[STREAM_PARENT(iCurStream)]->
 	               CreateStream(STREAM_NAME(iCurStream), 
 	         	     STGM_DIRECT | STGM_WRITE | 
 	         	     STGM_CREATE | STGM_SHARE_EXCLUSIVE,
 			     0, 0, &piStream);
	    ulTime = sw.Read();
	    m_ulCreateStreamTotal[iIter] += ulTime;

	    if(ulTime < m_ulCreateStreamMin[iIter])
	    	m_ulCreateStreamMin[iIter] = ulTime;

	    if(ulTime > m_ulCreateStreamMax[iIter])
	    	m_ulCreateStreamMax[iIter] = ulTime;

	    if (FAILED(hr))
	    {
	    	Log(TEXT("CreateStream"), hr);
	    	return hr;
	    }

	    sw.Reset();
	    piStream->Write((LPVOID)m_pbData, m_cbSize, &cb);
	    ulTime = sw.Read();
	    m_ulStreamWriteTotal[iIter] += ulTime;

	    if(ulTime < m_ulStreamWriteMin[iIter])
	    	m_ulStreamWriteMin[iIter] = ulTime;

	    if(ulTime > m_ulStreamWriteMax[iIter])
	    	m_ulStreamWriteMax[iIter] = ulTime;

	    sw.Reset();
	    piStream->Release();
	    ulTime = sw.Read();
	    m_ulStreamReleaseTotal[iIter] += ulTime;

	    if(ulTime < m_ulStreamReleaseMin[iIter])
	    	m_ulStreamReleaseMin[iIter] = ulTime;

	    if(ulTime > m_ulStreamReleaseMax[iIter])
	    	m_ulStreamReleaseMax[iIter] = ulTime;
  	}
	Log(TEXT("CreateStream"), S_OK);
	Log(TEXT("StreamWrite"), S_OK);	    
	Log(TEXT("StreamRelease"), S_OK);	    

        if (m_bDelete)
	{
	    // delete 1 stream from every branch.
	    for (iCurStream = 1; iCurStream < m_cStreams; iCurStream += m_cBranching)
    	    {
	    	sw.Reset();
 	    	hr = m_piStorages[STREAM_PARENT(iCurStream)]->
 	               		DestroyElement(STREAM_NAME(iCurStream));
	    	ulTime = sw.Read();
	    	m_ulDestroyElementTotal[iIter] += ulTime;

	    	if (ulTime < m_ulDestroyElementMin[iIter])
	    	    m_ulDestroyElementMin[iIter] = ulTime;

	    	if (ulTime > m_ulDestroyElementMax[iIter])
	    	    m_ulDestroyElementMax[iIter] = ulTime;

	    	if (FAILED(hr))
		{
	    	    Log(TEXT("DestroyElement"), hr);
	    	    return hr;
		}
             }
	     Log( TEXT("DestroyElement"), S_OK);

	     m_ulDestroyElementAverage[iIter] = m_ulDestroyElementTotal[iIter] / 
	     					 (m_cStreams / m_cBranching);
	}
        // for each storage, do commit if in transacted mode
	// and release the storage.
    	for (iCurStg = m_cStorages-1 ; iCurStg >= 0 ; iCurStg--)
    	{
	    // determine level of curent storage.
	    iLevel = 0;
	    iParent = STG_PARENT(iCurStg);
	    while(iParent > 0)
	    {
	    	iParent = STG_PARENT(iParent);
		iLevel++;
	    }

    	    if (m_flCreateFlags == STGM_TRANSACTED)
	    {
	     	sw.Reset();
    	    	m_piStorages[iCurStg]->Commit(STGC_DEFAULT);
	    	ulTime = sw.Read();
	    	m_ulStorageCommitTotal[iIter] += ulTime;

		if (iCurStg != 0)
		{
	    	    if (ulTime < m_ulStorageCommitMin[iLevel][iIter])
	    	    	m_ulStorageCommitMin[iLevel][iIter] = ulTime;

	    	    if (ulTime > m_ulStorageCommitMax[iLevel][iIter])
	    	    	m_ulStorageCommitMax[iLevel][iIter] = ulTime;
		}
		else
		{
		    m_ulFinalStorageCommit[iIter] = ulTime; 
		}
	    }

	    sw.Reset();
    	    m_piStorages[iCurStg]->Release();
	    ulTime = sw.Read();
	    m_ulStorageReleaseTotal[iIter] += ulTime;

	    if (iCurStg != 0)
	    {
	    	if (ulTime < m_ulStorageReleaseMin[iLevel][iIter])
	            m_ulStorageReleaseMin[iLevel][iIter] = ulTime;

	    	if (ulTime > m_ulStorageReleaseMax[iLevel][iIter])
	            m_ulStorageReleaseMax[iLevel][iIter] = ulTime;
	    }
	    else
	    {
		m_ulFinalStorageRelease[iIter] = ulTime; 
	    }
	}

	Log(TEXT("StorageCommit"), S_OK);
	Log(TEXT("StorageRelease"), S_OK);


	m_ulCreateStorageAverage[iIter] = m_ulCreateStorageTotal[iIter] / m_cStorages;
	m_ulCreateStreamAverage[iIter]  = m_ulCreateStreamTotal[iIter]  / m_cStreams;
	m_ulStreamWriteAverage[iIter]   = m_ulStreamWriteTotal[iIter]   / m_cStreams;
	m_ulStreamReleaseAverage[iIter] = m_ulStreamReleaseTotal[iIter] / m_cStreams;
	m_ulStorageCommitAverage[iIter] = m_ulStorageCommitTotal[iIter] / m_cStorages;
	m_ulStorageReleaseAverage[iIter] = m_ulStorageReleaseTotal[iIter] / m_cStorages;

	m_ulTotal[iIter] = m_ulStgCreateDocfile[iIter] +
			   m_ulCreateStorageTotal[iIter] + 
			   m_ulCreateStreamTotal[iIter] +
			   m_ulStreamWriteTotal[iIter] +
			   m_ulStreamReleaseTotal[iIter] +
			   m_ulDestroyElementTotal[iIter] +
			   m_ulStorageCommitTotal[iIter] +
			   m_ulStorageReleaseTotal[iIter];
			      	
    }

    return S_OK;
}


SCODE CNestedStorageTest::Report (CTestOutput &output)
{	       
    TCHAR pszBuf[80];

    wsprintf(pszBuf, TEXT("Nested Storage Test in %s Mode writing %d bytes"),
    	      m_pszFileMode, m_cbSize);

    output.WriteSectionHeader (Name(), pszBuf, *m_pInput);
    output.WriteString (TEXT("\n"));

    for ( ULONG iLevel = 0; iLevel < m_cNesting - 1; iLevel++)
    {
    	wsprintf(pszBuf, TEXT("\nLevel %d\n"), iLevel + 1);
    	output.WriteString (pszBuf);   
    	output.WriteResults (TEXT("CreateStorage    Min"), m_ulIterations, 
    			     m_ulCreateStorageMin[iLevel]);
    	output.WriteResults (TEXT("CreateStorage    Max"), m_ulIterations, 
    			     m_ulCreateStorageMax[iLevel]);

    	if (m_flCreateFlags == STGM_TRANSACTED)
	{
            output.WriteResults (TEXT("StorageCommit    Min"), m_ulIterations, 
            			 m_ulStorageCommitMin[iLevel] );
            output.WriteResults (TEXT("StorageCommit    Max"), m_ulIterations, 
            			 m_ulStorageCommitMax[iLevel] );
	}

    	output.WriteResults (TEXT("StorageRelease   Min"), m_ulIterations, 
    			     m_ulStorageReleaseMin[iLevel]);
    	output.WriteResults (TEXT("StorageRelease   Max"), m_ulIterations, 
    			     m_ulStorageReleaseMax[iLevel]);
    }

    output.WriteString (TEXT("\nOverall\n"));

    output.WriteResults (TEXT("StgCreateDocfile    "), m_ulIterations, 
    			 m_ulStgCreateDocfile);

    if (m_flCreateFlags == STGM_TRANSACTED)
    	output.WriteResults (TEXT("Final Storage Commit"), m_ulIterations, 
    			     m_ulFinalStorageCommit);

    output.WriteResults (TEXT("Final Storage Release"), m_ulIterations, 
    			 m_ulFinalStorageRelease);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CreateStorage Average"), m_ulIterations, 
    			 m_ulCreateStorageAverage );
    output.WriteResults (TEXT("CreateStorage  Total"), m_ulIterations, 
    			 m_ulCreateStorageTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CreateStream     Min"), m_ulIterations, 
    			 m_ulCreateStreamMin);
    output.WriteResults (TEXT("CreateStream     Max"), m_ulIterations, 
    			 m_ulCreateStreamMax);
    output.WriteResults (TEXT("CreateStream Average"), m_ulIterations, 
    			 m_ulCreateStreamAverage);
    output.WriteResults (TEXT("CreateStream   Total"), m_ulIterations, 
    			 m_ulCreateStreamTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamWrite      Min"), m_ulIterations, 
    			 m_ulStreamWriteMin );
    output.WriteResults (TEXT("StreamWrite      Max"), m_ulIterations,
    			 m_ulStreamWriteMax );
    output.WriteResults (TEXT("StreamWrite  Average"), m_ulIterations,
    			 m_ulStreamWriteAverage );
    output.WriteResults (TEXT("StreamWrite    Total"), m_ulIterations,
    			 m_ulStreamWriteTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamRelease    Min"), m_ulIterations,
    			 m_ulStreamReleaseMin );
    output.WriteResults (TEXT("StreamRelease    Max"), m_ulIterations,
    			 m_ulStreamReleaseMax );
    output.WriteResults (TEXT("StreamRelease Average"), m_ulIterations, 
    			 m_ulStreamReleaseAverage );
    output.WriteResults (TEXT("StreamRelease  Total"), m_ulIterations,
    			 m_ulStreamReleaseTotal );
    output.WriteString (TEXT("\n"));

    if(m_bDelete)		       
    {
    	output.WriteResults (TEXT("DestroyElement   Min"), m_ulIterations,
    			     m_ulDestroyElementMin );
    	output.WriteResults (TEXT("DestroyElement   Max"), m_ulIterations, 
    			     m_ulDestroyElementMax );
    	output.WriteResults (TEXT("DestroyElement Average"), m_ulIterations, 
    			     m_ulDestroyElementAverage );
    	output.WriteResults (TEXT("DestroyElement Total"), m_ulIterations, 
    			     m_ulDestroyElementTotal );
    	output.WriteString (TEXT("\n"));
    }

    if (m_flCreateFlags == STGM_TRANSACTED)
    {
        output.WriteResults (TEXT("StorageCommit Average"), m_ulIterations, 
        		     m_ulStorageCommitAverage );
        output.WriteResults (TEXT("StorageCommit   Total"), m_ulIterations, 
        		     m_ulStorageCommitTotal );
    	output.WriteString (TEXT("\n"));
    }

    output.WriteResults (TEXT("StorageRelease Average"), m_ulIterations, 
    			 m_ulStorageReleaseAverage );
    output.WriteResults (TEXT("StorageRelease  Total"), m_ulIterations, 
    			 m_ulStorageReleaseTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("Overall Total       "), m_ulIterations, m_ulTotal );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_regis.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_regis.cxx
//
//  Contents:	Ole object registration test
//
//  Classes:	COleRegistrationTest
//
//  History:    12-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_regis.hxx>
#include <oletest.hxx>

extern COleTestClassFactory theFactory;


const CLSID *apClsid[] = {&CLSID_COleTestClass1,
			  &CLSID_COleTestClass2,
			  &CLSID_COleTestClass3,
			  &CLSID_COleTestClass4,
			  &CLSID_COleTestClass5,
			  &CLSID_COleTestClass6,
			  &CLSID_COleTestClass7,
			  &CLSID_COleTestClass8};


TCHAR *COleRegistrationTest::Name ()
{
	return	TEXT("ObjRegistration");
}


SCODE COleRegistrationTest::Setup (CTestInput *pInput)
{
	HRESULT sc;

	CTestBase::Setup(pInput);

	//  get the iteration count
	m_ulIterations = pInput->GetIterations(Name());

	//  for the inproc case. load a class factory object to register.
	//  this is temporary to fix a problem (ambiguity) in inproc
	//  registration.

	sc = pInput->GetGUID(&m_Clsid[0], Name(), apszClsIDName[0]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	sc = pInput->GetGUID(&m_Clsid[1], Name(), apszClsIDName[1]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return sc;
	}

	//  get the class factory
	sc = CoGetClassObject(m_Clsid[0], dwaClsCtx[0], NULL,
			  IID_IClassFactory, (void **)&m_apICF[0]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoGetClassObject failed."), sc);
	    return sc;
	}


	//  for local server, register an internal class.
	m_apICF[1] = (IClassFactory *)&theFactory;

	//  init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    INIT_RESULTS(m_ulRegisterCtx[iCtx]);
	    INIT_RESULTS(m_ulRevokeCtx[iCtx]);
	}

	// _pInput = pInput;
	return S_OK;
}


SCODE COleRegistrationTest::Cleanup ()
{
	m_apICF[0]->Release();

	UninitCOM();
	
	return S_OK;
}

SCODE COleRegistrationTest::Run ()
{
	CStopWatch sw;
	DWORD dwReg;

	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset ();
		SCODE sc = CoRegisterClassObject(m_Clsid[iCtx],
						 m_apICF[iCtx],
						 dwaClsCtx[iCtx],
						 REGCLS_MULTIPLEUSE, &dwReg);
		m_ulRegisterCtx[iCtx][iIter] = sw.Read ();
		Log (TEXT("CoRegisterClassObject"),sc);

		//  NOTE: Revoke has different behaviour depending on
		//  whether single use or multiuse is specified in the
		//  registration.

		if (SUCCEEDED(sc))
		{
		    // Revoke
		    sw.Reset ();
		    sc = CoRevokeClassObject(dwReg);
		    m_ulRevokeCtx[iCtx][iIter] = sw.Read();
		    if (Log (TEXT("CoRevokeClassObject"), sc))
			m_ulRevokeCtx[iCtx][iIter] = NOTAVAIL;
		}
		else
		{
		    m_ulRegisterCtx[iCtx][iIter] = NOTAVAIL;
		}

		// _pInput->Pause(IP_ITERPAUSE);
	    }
	}

	return S_OK;
}



SCODE COleRegistrationTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(),
		    TEXT("CoRegisterClassObject / CoRevokeClassObject"), *m_pInput);

	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString (TEXT("\n"));
	    output.WriteClassID(&m_Clsid[iCtx]);
	    output.WriteString (apszClsCtx[iCtx]);
	    output.WriteString (TEXT("\n"));

	    output.WriteResults (TEXT("Register"), m_ulIterations,
				 m_ulRegisterCtx[iCtx]);

	    output.WriteResults (TEXT("Revoke  "), m_ulIterations,
				 m_ulRevokeCtx[iCtx]);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_rot.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rot.cxx
//
//  Contents:	Ole running object table test (ROT)
//
//  Classes:	CROTTest
//
//  History:    9-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_rot.hxx>
#include <cact.hxx>		//  CTestAct


//  function used by CTestAct. need not do anything for our usage.
void GlobalRefs(BOOL fAdd)
{
}


TCHAR *CROTTest::Name ()
{
	return TEXT("ROT");
}


SCODE CROTTest::Setup (CTestInput *pInput)
{
	IClassFactory	*pICF = NULL;
	IPersistFile	*pIPF = NULL;
	SCODE		 sc = S_OK, scRet = S_OK;


	CTestBase::Setup(pInput);

	// get the iteration count from the ini file
	m_ulIterations = pInput->GetIterations(Name());
	m_ulEntries = 1;

	//  for each class ctx, get the classid, and init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Get ClsID for this Ctx from the .ini file
	    sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	    if (FAILED(sc))
	    {
		Log (TEXT("Setup - GetClassID failed."), sc);
		return sc;
	    }

	    INIT_RESULTS(m_ulGetROTTime[iCtx]);
	    INIT_RESULTS(m_ulReleaseTime[iCtx]);
	    INIT_RESULTS(m_ulRegisterTime[iCtx]);
	    INIT_RESULTS(m_ulRevokeTime[iCtx]);
	    INIT_RESULTS(m_ulNoteChangeTime[iCtx]);
	    INIT_RESULTS(m_ulGetChangeTime[iCtx]);
	    INIT_RESULTS(m_ulIsRunningTime[iCtx]);
	    INIT_RESULTS(m_ulGetObjectTime[iCtx]);
	    INIT_RESULTS(m_ulEnumRunningTime[iCtx]);
	}


	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return sc;
	}


	//  for each class ctx, create a persistent instance on disk
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    m_punkObj[iCtx] = NULL;
	    m_pmkObj[iCtx]  = NULL;

	    if (dwaClsCtx[iCtx] == CLSCTX_INPROC_SERVER)
	    {
		// create an inprocess instance
		m_punkObj[iCtx] = (IPersistFile *) new CTestAct(m_ClsID[iCtx]);
		sc = (m_punkObj[iCtx] != NULL) ? S_OK : E_OUTOFMEMORY;
	    }
	    else
	    {
		// Create an instance
		sc = CoCreateInstance(m_ClsID[iCtx], NULL, dwaClsCtx[iCtx],
				      IID_IUnknown, (void **)&m_punkObj[iCtx]);
	    }

	    if (SUCCEEDED(sc))
	    {
		//  Create a moniker
		sc = CreateFileMoniker(apszPerstName[iCtx], &m_pmkObj[iCtx]);

		if (SUCCEEDED(sc))
		{
		    //	get the IPersistFile interface
		    IPersistFile *pIPF = NULL;

		    sc = m_punkObj[iCtx]->QueryInterface(IID_IPersistFile,
							 (void **)&pIPF);

		    if (SUCCEEDED(sc))
		    {
			//  save the class instance in the file.
			//  NOTE: we assume the server's implementation of
			//  this method does not do any ROT operations. We
			//  know this to be true of CTestAct.

			sc = pIPF->Save(apszPerstName[iCtx], FALSE);
			pIPF->Release();

			if (FAILED(sc))
			{
			    Log (TEXT("Setup - pIPF->Save failed."), sc);
			    scRet = sc;
			}
		    }
		    else
		    {
			Log (TEXT("Setup - QueryInterface failed"), sc);
			scRet = sc;
		    }
		}
		else
		{
		    Log (TEXT("Setup - CreateFileMoniker failed"), sc);
		    scRet = sc;
		}
	    }
	    else
	    {
		Log (TEXT("Setup - CreateInstance failed"), sc);
		scRet = sc;
	    }
	}

	if (FAILED(scRet))
	{
	    Cleanup();
	}

	return scRet;
}


SCODE CROTTest::Cleanup ()
{	
	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete files
	    wcstombs(szPerstName, apszPerstName[iCtx],
		     wcslen(apszPerstName[iCtx])+1);
	    _unlink (szPerstName);

	    if (m_punkObj[iCtx])
		m_punkObj[iCtx]->Release();

	    if (m_pmkObj[iCtx])
		m_pmkObj[iCtx]->Release();
	}


	UninitCOM();
	return S_OK;
}


SCODE CROTTest::Run ()
{
	IRunningObjectTable *pROT = NULL;
	CStopWatch   sw;
	SCODE	     sc;


	//  do the server side ROT operations.
	//  this makes sense only for inprocess objects.

	ULONG iCtx=0;
	{
	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = GetRunningObjectTable(NULL, &pROT);
		m_ulGetROTTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("GetRunningObjectTable"), sc))
		{
		    m_ulGetROTTime[iCtx][iIter] = NOTAVAIL;
		}

		DWORD	dwRegister = 0;

		sw.Reset();
		sc = pROT->Register(0, m_punkObj[iCtx], m_pmkObj[iCtx], &dwRegister);
		m_ulRegisterTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->Register"), sc))
		{
		    m_ulRegisterTime[iCtx][iIter] = NOTAVAIL;
		}


		FILETIME    ft;
		SYSTEMTIME  st;

		GetSystemTime(&st);
		SystemTimeToFileTime(&st, &ft);

		sw.Reset();
		sc = pROT->NoteChangeTime(dwRegister, &ft);
		m_ulNoteChangeTime[iCtx][iIter]=sw.Read ();
		if (Log (TEXT("pROT->NoteChangeTime"), sc))
		{
		    m_ulNoteChangeTime[iCtx][iIter] = NOTAVAIL;
		}


		sw.Reset();
		sc = pROT->Revoke(dwRegister);
		m_ulRevokeTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->Revoke"), sc))
		{
		    m_ulRevokeTime[iCtx][iIter] = NOTAVAIL;
		}


		sw.Reset();
		pROT->Release();
		m_ulReleaseTime[iCtx][iIter]=sw.Read ();
		pROT = NULL;
		if (Log (TEXT("pROT->Release"), sc))
		{
		    m_ulReleaseTime[iCtx][iIter] = NOTAVAIL;
		}
	    }
	}


	//  do the client side ROT operations
	//  this makes sense for both class contexts

	pROT = NULL;
	sc = GetRunningObjectTable(NULL, &pROT);
	if (Log (TEXT("GetRunningObjectTable"), sc))
	{
	    return sc;
	}


	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	put the object into the loaded state. this will cause it to
	    //	register itself in the ROT.
	    IPersistFile *pIPF = NULL;

	    sc = m_punkObj[iCtx]->QueryInterface(IID_IPersistFile, (void **)&pIPF);
	    if (SUCCEEDED(sc))
	    {
		pIPF->Load(apszPerstName[iCtx], STGM_READ | STGM_SHARE_DENY_NONE);
		pIPF->Release();
	    }

	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		IEnumMoniker	*pEnumMk = NULL;

		sw.Reset();
		sc = pROT->EnumRunning(&pEnumMk);
		m_ulEnumRunningTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->EnumRunning"), sc))
		{
		    m_ulEnumRunningTime[iCtx][iIter] = NOTAVAIL;
		}

		if (pEnumMk)
		{
		    pEnumMk->Release();
		}


		sw.Reset();
		sc = pROT->IsRunning(m_pmkObj[iCtx]);
		m_ulIsRunningTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->IsRunning"), sc))
		{
		    m_ulIsRunningTime[iCtx][iIter] = NOTAVAIL;
		}


		FILETIME    ft;

		sw.Reset();
		sc = pROT->GetTimeOfLastChange(m_pmkObj[iCtx], &ft);
		m_ulGetChangeTime[iCtx][iIter]=sw.Read ();
		if (Log (TEXT("pROT->GetTimeOfLastChange"), sc))
		{
		    m_ulGetChangeTime[iCtx][iIter] = NOTAVAIL;
		}


		IUnknown *pUnk = NULL;

		sw.Reset();
		sc = pROT->GetObject(m_pmkObj[iCtx], &pUnk);
		m_ulGetObjectTime[iCtx][iIter]=sw.Read ();
		if (Log (TEXT("pROT->GetObject"), sc))
		{
		    m_ulGetObjectTime[iCtx][iIter] = NOTAVAIL;
		}

		if (pUnk)
		{
		    pUnk->Release();
		}
	    }
	}

	return S_OK;
}		



SCODE CROTTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("RunningObjectTable"), *m_pInput);

	//  write out the server side results
	ULONG iCtx=0;
	output.WriteString(TEXT("\nServer Side\n\n"));
	output.WriteResults(TEXT("GetRunningObjTbl"), m_ulIterations, m_ulGetROTTime[iCtx]);
	output.WriteResults(TEXT("Register        "), m_ulIterations, m_ulRegisterTime[iCtx]);
	output.WriteResults(TEXT("NoteChangeTime  "), m_ulIterations, m_ulNoteChangeTime[iCtx]);
	output.WriteResults(TEXT("Revoke          "), m_ulIterations, m_ulRevokeTime[iCtx]);
	output.WriteResults(TEXT("pROT->Release   "), m_ulIterations, m_ulReleaseTime[iCtx]);


	//  write out the client side results
	output.WriteString(TEXT("\nClient Side\n"));

	//  for each clsctx, write the results
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(TEXT("\n"));
	    output.WriteClassID(&m_ClsID[iCtx]);
	    output.WriteString(apszClsCtx[iCtx]);
	    output.WriteString(TEXT("\n"));

	    output.WriteResults(TEXT("EnumRunning     "), m_ulIterations, m_ulEnumRunningTime[iCtx]);
	    output.WriteResults(TEXT("IsRunning       "), m_ulIterations, m_ulIsRunningTime[iCtx]);
	    output.WriteResults(TEXT("GetChangeTime   "), m_ulIterations, m_ulGetChangeTime[iCtx]);
	    output.WriteResults(TEXT("GetObject       "), m_ulIterations, m_ulGetObjectTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_qi.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_qi.cxx
//
//  Contents:	Ole QueryInterface test
//
//  Classes:	CQueryInterfaceTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_qi.hxx>


//  this is just an array of random interface iids. The qi server object
//  answers YES to any QI, although the only valid methods on each interface
//  are the methods of IUnknown.
//
//  the code will answer NO to the following IIDs in order to prevent
//  custom marshalling problems...
//
//	IID_IMarshal, IID_IStdMarshalInfo, IID_IStdIdentity,
//	IID_IPersist, IID_IProxyManager

const IID *iid[] = {&IID_IAdviseSink,	 &IID_IDataObject,
		 &IID_IOleObject,	 &IID_IOleClientSite,
		 &IID_IParseDisplayName, &IID_IPersistStorage,
		 &IID_IPersistFile,	 &IID_IStorage,
		 &IID_IOleContainer,	 &IID_IOleItemContainer,
		 &IID_IOleInPlaceSite,	 &IID_IOleInPlaceActiveObject,
		 &IID_IOleInPlaceObject, &IID_IOleInPlaceUIWindow,
		 &IID_IOleInPlaceFrame,	 &IID_IOleWindow};



TCHAR *CQueryInterfaceTest::Name ()
{
    return TEXT("QueryInterface");
}


SCODE CQueryInterfaceTest::Setup (CTestInput *pInput)
{
    SCODE sc;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	INIT_RESULTS(m_ulQueryInterfaceSameTime[iCtx]);
	INIT_RESULTS(m_ulPunkReleaseSameTime[iCtx]);
	INIT_RESULTS(m_ulQueryInterfaceNewTime[iCtx]);
	INIT_RESULTS(m_ulPunkReleaseNewTime[iCtx]);

	_pUnk[iCtx] = NULL;
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    //	create an instance of each qi server object
    for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	sc = CoCreateInstance(m_ClsID[iCtx], NULL, dwaClsCtx[iCtx],
		      IID_IUnknown, (void **)&_pUnk[iCtx]);

	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance failed"), sc);
	}
    }

    return S_OK;
}


SCODE CQueryInterfaceTest::Cleanup ()
{
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	if (_pUnk[iCtx])
	{
	    _pUnk[iCtx]->Release();
	}
    }

    UninitCOM();
    return S_OK;
}


SCODE CQueryInterfaceTest::Run ()
{
	CStopWatch    sw;
	IUnknown      *pUnk = NULL;


	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    if (!_pUnk[iCtx])
		continue;

	    //	same interface each time, releasing after each query
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset ();
		SCODE sc = _pUnk[iCtx]->QueryInterface(IID_IStorage, (void **)&pUnk);
		m_ulQueryInterfaceSameTime[iCtx][iIter] = sw.Read ();
		Log (TEXT("QueryInterface"), sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    pUnk->Release ();
		    m_ulPunkReleaseSameTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulPunkReleaseSameTime[iCtx][iIter] = NOTAVAIL;
		}
	    }

	    //	different interface each time, releasing after each query
	    for (iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset ();
		SCODE sc = _pUnk[iCtx]->QueryInterface(*(iid[iIter]), (void **)&pUnk);
		m_ulQueryInterfaceNewTime[iCtx][iIter] = sw.Read ();
		Log (TEXT("QueryInterface"), sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    pUnk->Release ();
		    m_ulPunkReleaseNewTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulPunkReleaseNewTime[iCtx][iIter] = NOTAVAIL;
		}
	    }

	}

	return S_OK;
}					  



SCODE CQueryInterfaceTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("QueryInterface"), *m_pInput);

    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	output.WriteString(TEXT("\n"));
	output.WriteClassID (&m_ClsID[iCtx]);
	output.WriteString(apszClsCtx[iCtx]);
	output.WriteString(TEXT("\n"));

	output.WriteResults (TEXT("QuerySameInterface"), m_ulIterations,
			      m_ulQueryInterfaceSameTime[iCtx]);

	output.WriteResults (TEXT("Release           "), m_ulIterations,
			     m_ulPunkReleaseSameTime[iCtx]);

	output.WriteResults (TEXT("QueryNewInterface "), m_ulIterations,
			     m_ulQueryInterfaceNewTime[iCtx]);

	output.WriteResults (TEXT("Release           "), m_ulIterations,
			     m_ulPunkReleaseNewTime[iCtx]);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_props.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_props.cxx
//
//  Contents:	Ole properties test
//
//  Classes:	COlePropertyTest
//
//  History:    22-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_props.hxx>
#include <oletest.hxx>


DEFINE_OLEGUID(CLSID_TestProp,  0x20730722, 1, 8);	    // CT Test GUID


TCHAR *COlePropertyTest::Name ()
{
    return TEXT("Properties");
}


SCODE COlePropertyTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    SCODE sc = InitOLE();
    if (FAILED(sc))
    {
        Log (TEXT("Setup - OleInitialize failed."), sc);
        return	sc;
    }
	
    m_ulIterations = 0;
    return S_OK;
}


SCODE COlePropertyTest::Cleanup ()
{	
    UninitOLE();
    return S_OK;
}



SCODE COlePropertyTest::Run ()
{
/****	BUGBUG: these tests currently do nothing

	CStopWatch sw;
	IStorage *pIS;
	IDispatch *pID;
	COleTestClass unk;
	VARIANTARG avararg[2];
	DISPPARAMS dispparams = {avararg, NULL, 2, 0};
	VARIANT	varResult;
	EXCEPINFO excepinfo;
	UINT ierr;

	// Create storage

	if (FAILED(StgCreateDocfile (TEXT("C:\\DUMP.BM"), STGM_CREATE |
		STGM_DELETEONRELEASE, 0, &pIS)))
		return E_FAIL;

	sw.Reset ();

	if (FAILED(CoCreatePropSetStg (pIS, CLSID_TestProp, &unk, STGM_READWRITE |
		STGM_SHARE_EXCLUSIVE, NULL, (IUnknown**)&pID)))
	{
		pIS->Release ();
		return E_FAIL;
	}
	ulCreate = sw.Read ();

	pID->QueryInterface (IID_IDispatch, (void**)&pID);

	VariantInit(avararg + 1);
	avararg[1].vt = VT_LPWSTR;
	avararg[1].pwszVal = L"CairOLE";

	VariantInit(avararg + 0);
	avararg[0].vt = VT_LPWSTR;
	avararg[0].pwszVal = L"TooSlow";

	sw.Reset ();
	if (FAILED(pID->Invoke(DISPID_ADDPROP, CLSID_TestProp, 0,
	    DISPATCH_METHOD, &dispparams, &varResult, &excepinfo, &ierr)))
	{
		pIS->Release ();
		return E_FAIL;
	}

	ulAdd = sw.Read ();
	pIS->Release ();
****/
	return S_OK;
}



SCODE COlePropertyTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("Properties"), *m_pInput);
/****	BUGBUG: disable
	output.WriteResult (TEXT("Create property set"), ulCreate);
	output.WriteResult (TEXT("Add property"), ulAdd);
	output.WriteResult (TEXT("Set property"), ulSet);
	output.WriteResult (TEXT("Get property"), ulGet);
	output.WriteResult (TEXT("Delete property"), ulDelete);
****/
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_rpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rpc.cxx
//
//  Contents:	Rpc Method Invocation tests
//
//  Classes:	CRpcTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_rpc.hxx>
#include <oletest.hxx>
#include <tracelog.hxx>


TCHAR *CRpcTest::Name ()
{
	return TEXT("RpcTest");
}


SCODE CRpcTest::Setup (CTestInput *pInput)
{
	CTestBase::Setup(pInput);

	SCODE sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Local"));
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	// get flag indicating whether to keep all values or
	// only average values.
	TCHAR	szAverage[5];
	pInput->GetConfigString(Name(), TEXT("Average"), TEXT("Y"),
                            szAverage, sizeof(szAverage)/sizeof(TCHAR));
        if (szAverage[0] == 'n' || szAverage[0] == 'N')
	    m_fAverage = FALSE;
	else
	    m_fAverage = TRUE;

	//  get iteration count
	if (m_fAverage)
	    m_ulIterations = pInput->GetRealIterations(Name());
	else
	    m_ulIterations = pInput->GetIterations(Name());

	//  initialize timing arrays
	INIT_RESULTS(m_ulVoidTime);
	INIT_RESULTS(m_ulVoidRCTime);

	INIT_RESULTS(m_ulDwordInTime);
	INIT_RESULTS(m_ulDwordOutTime);
	INIT_RESULTS(m_ulDwordInOutTime);

	INIT_RESULTS(m_ulStringInTime);
	INIT_RESULTS(m_ulStringOutTime);
	INIT_RESULTS(m_ulStringInOutTime);

	INIT_RESULTS(m_ulGuidInTime);
	INIT_RESULTS(m_ulGuidOutTime);

	INIT_RESULTS(m_ulIUnknownInprocInTime);
	INIT_RESULTS(m_ulIUnknownInprocOutTime);
	INIT_RESULTS(m_ulIUnknownLocalInTime);
	INIT_RESULTS(m_ulIUnknownLocalOutTime);

	INIT_RESULTS(m_ulIUnknownKeepInTime);
	INIT_RESULTS(m_ulIUnknownKeepOutTime);

	INIT_RESULTS(m_ulInterfaceInprocInTime);
	INIT_RESULTS(m_ulInterfaceLocalInTime);


	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return  sc;
	}

	m_pRPC=NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_IRpcTest, (void **)&m_pRPC);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance IRpcTest failed."), sc);
	    return sc;
	}


	//  get the inprocess object for the IUnknown marshalling test
	sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Inproc"));
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID Inproc failed."), sc);
	    return sc;
	}

	m_punkInproc = NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_INPROC_SERVER,
			      IID_IUnknown, (void **)&m_punkInproc);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance IUnknown Inproc failed."), sc);
	    return sc;
	}


	//  get the out of process object for the IUnknown marshalling test

	m_punkLocal = NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_IUnknown, (void **)&m_punkLocal);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance IUnknown LocalSrv failed."), sc);
	    return sc;
	}

	return S_OK;
}


SCODE CRpcTest::Cleanup ()
{
	if (m_pRPC)
	    m_pRPC->Release();

	if (m_punkInproc)
	    m_punkInproc->Release();

	if (m_punkLocal)
	    m_punkLocal->Release();

	UninitCOM();
	return S_OK;
}


SCODE CRpcTest::Run ()
{
    CStopWatch  sw;
    SCODE       sc;
    ULONG       iIter;

    //
    // void passing tests
    //

    // STARTTRACE("CRpcTest");

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
        // TRACECALL(TRACE_APP, "m_pRPC->Void()");

	ResetNotAverage( m_fAverage, sw );
        m_pRPC->Void();
	ReadNotAverage( m_fAverage, sw, m_ulVoidTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulVoidTime[0], m_ulIterations );

    // STOPTRACE("CRpcTest");


    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
        // TRACECALL(TRACE_APP, "m_pRPC->VoidRC()");

	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->VoidRC();
        ReadNotAverage( m_fAverage, sw, m_ulVoidRCTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulVoidRCTime[0], m_ulIterations );

    //
    //  dword passing tests
    //

    DWORD dwTmp = 1;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->DwordIn(dwTmp);
        ReadNotAverage( m_fAverage, sw, m_ulDwordInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulDwordInTime[0], m_ulIterations );

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->DwordOut(&dwTmp);
        ReadNotAverage( m_fAverage, sw, m_ulDwordOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulDwordOutTime[0], m_ulIterations );

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->DwordInOut(&dwTmp);
        ReadNotAverage( m_fAverage, sw, m_ulDwordInOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulDwordInOutTime[0], m_ulIterations );

    //
    //  string passing tests
    //

    OLECHAR wszHello[] = L"C:\\FOOFOO\\FOOBAR\\FOOBAK\\FOOBAZ\\FOOTYPICAL\\PATH\\HELLO";
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->StringIn(wszHello);
        ReadNotAverage( m_fAverage, sw, m_ulStringInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulStringInTime[0], m_ulIterations );

    LPOLESTR pwszOut = NULL;
#ifdef STRINGOUT
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
        pwszOut = NULL;
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->StringOut(&pwszOut);
        ReadNotAverage( m_fAverage, sw, m_ulStringOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulStringOutTime[0], m_ulIterations );
#endif
    pwszOut = wszHello;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->StringInOut(pwszOut);
        ReadNotAverage( m_fAverage, sw, m_ulStringInOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulStringInOutTime[0], m_ulIterations );

    //
    //  guid passing tests
    //

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->GuidIn(IID_IRpcTest);
        ReadNotAverage( m_fAverage, sw, m_ulGuidInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulGuidInTime[0], m_ulIterations );

    GUID    guid;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->GuidOut(&guid);
        ReadNotAverage( m_fAverage, sw, m_ulGuidOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulGuidOutTime[0], m_ulIterations );


    //
    //  IUnknown passing tests
    //

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->IUnknownIn(m_punkInproc);
        ReadNotAverage( m_fAverage, sw, m_ulIUnknownInprocInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulIUnknownInprocInTime[0], m_ulIterations );

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->IUnknownIn(m_punkLocal);
        ReadNotAverage( m_fAverage, sw, m_ulIUnknownLocalInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulIUnknownLocalInTime[0], m_ulIterations );

    IUnknown *punk = NULL;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->IUnknownOut(&punk);
        punk->Release();
        punk = NULL;
        ReadNotAverage( m_fAverage, sw, m_ulIUnknownInprocOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulIUnknownInprocOutTime[0], m_ulIterations );

    //
    //  interface passing tests
    //

#ifdef  NOTYET

    IStream *pIStm = NULL;
    sc = m_punkInproc->QueryInterface(IID_IStream, (void **)&pIStm);
    if (SUCCEEDED(sc) && pIStm)
    {
        ResetAverage( m_fAverage, sw );
        for (iIter=0; iIter<m_ulIterations; iIter++)
        {
	    ResetNotAverage( m_fAverage, sw );
            sc = m_pRPC->InterfaceIn(IID_IStream, pIStm);
            ReadNotAverage( m_fAverage, sw, m_ulInterfaceInprocInTime[iIter] );
        }
        ReadAverage( m_fAverage, sw, m_ulInterfaceInprocInTime[0], m_ulIterations );
        pIStm->Release();
    }

    pIStm = NULL;
    sc = m_punkLocal->QueryInterface(IID_IStream, (void **)&pIStm);
    if (SUCCEEDED(sc) && pIStm)
    {
        ResetAverage( m_fAverage, sw );
        for (iIter=0; iIter<m_ulIterations; iIter++)
        {
	    ResetNotAverage( m_fAverage, sw );
            sc = m_pRPC->InterfaceIn(IID_IStream, pIStm);
            ReadNotAverage( m_fAverage, sw, m_ulInterfaceLocalInTime[iIter] );
        }
        ReadAverage( m_fAverage, sw, m_ulInterfaceLocalInTime[0], m_ulIterations );
        pIStm->Release();
    }
#endif


    return S_OK;
}					



SCODE CRpcTest::Report (CTestOutput &output)
{
    if (m_fAverage)
    {
	output.WriteSectionHeader (Name(), TEXT("Object Rpc"), *m_pInput);

	output.WriteString (TEXT("\n"));
	output.WriteString (TEXT("Average times\n"));
	output.WriteString (TEXT("\n"));
	output.WriteResult (TEXT("Void         "), m_ulVoidTime[0]);
	output.WriteResult (TEXT("VoidRC       "), m_ulVoidRCTime[0]);

	output.WriteResult (TEXT("DwordIn      "), m_ulDwordInTime[0]);
	output.WriteResult (TEXT("DwordOut     "), m_ulDwordOutTime[0]);
	output.WriteResult (TEXT("DwordInOut   "), m_ulDwordInOutTime[0]);

	output.WriteResult (TEXT("StringIn     "), m_ulStringInTime[0]);
#ifdef STRINGOUT
	output.WriteResult (TEXT("StringOut    "), m_ulStringOutTime[0]);
#endif
	output.WriteResult (TEXT("StringInOut  "), m_ulStringInOutTime[0]);

	output.WriteResult (TEXT("GuidIn       "), m_ulGuidInTime[0]);
	output.WriteResult (TEXT("GuidOut      "), m_ulGuidOutTime[0]);

	output.WriteResult (TEXT("IUnknownIp   "), m_ulIUnknownInprocInTime[0]);
	output.WriteResult (TEXT("IUnknownLcl  "), m_ulIUnknownLocalInTime[0]);
	output.WriteResult (TEXT("IUnknownOut  "), m_ulIUnknownInprocOutTime[0]);
    //  output.WriteResult (TEXT("IUnknownKpIn "), m_ulIUnknownKeepInTime[0]);
    //  output.WriteResult (TEXT("IUnknownKpOut"), m_ulIUnknownKeepOutTime[0]);

#ifdef	NOTYET
	output.WriteResult (TEXT("InterfaceIn "), m_ulInterfaceInprocInTime[0]);
	output.WriteResult (TEXT("InterfaceLcl"), m_ulInterfaceLocalInTime[0]);
#endif
    }
    else
    {
	output.WriteSectionHeader (Name(), TEXT("Object Rpc"), *m_pInput);
	output.WriteString (TEXT("\n"));

	output.WriteResults (TEXT("Void         "), m_ulIterations, m_ulVoidTime);
	output.WriteResults (TEXT("VoidRC       "), m_ulIterations, m_ulVoidRCTime);

	output.WriteResults (TEXT("DwordIn      "), m_ulIterations, m_ulDwordInTime);
	output.WriteResults (TEXT("DwordOut     "), m_ulIterations, m_ulDwordOutTime);
	output.WriteResults (TEXT("DwordInOut   "), m_ulIterations, m_ulDwordInOutTime);

	output.WriteResults (TEXT("StringIn     "), m_ulIterations, m_ulStringInTime);
#ifdef STRINGOUT
	output.WriteResults (TEXT("StringOut    "), m_ulIterations, m_ulStringOutTime);
#endif
	output.WriteResults (TEXT("StringInOut  "), m_ulIterations, m_ulStringInOutTime);

	output.WriteResults (TEXT("GuidIn       "), m_ulIterations, m_ulGuidInTime);
	output.WriteResults (TEXT("GuidOut      "), m_ulIterations, m_ulGuidOutTime);

	output.WriteResults (TEXT("IUnknownIp   "), m_ulIterations, m_ulIUnknownInprocInTime);
	output.WriteResults (TEXT("IUnknownLcl  "), m_ulIterations, m_ulIUnknownLocalInTime);
	output.WriteResults (TEXT("IUnknownOut  "), m_ulIterations, m_ulIUnknownInprocOutTime);
    //  output.WriteResults (TEXT("IUnknownKpIn "), m_ulIterations, m_ulIUnknownKeepInTime);
    //  output.WriteResults (TEXT("IUnknownKpOut"), m_ulIterations, m_ulIUnknownKeepOutTime);

#ifdef	NOTYET
	output.WriteResults (TEXT("InterfaceIn "), m_ulIterations, m_ulInterfaceInprocInTime);
	output.WriteResults (TEXT("InterfaceLcl"), m_ulIterations, m_ulInterfaceLocalInTime);
#endif
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	headers.cxx
//
//  Contents:	remote2/new precompiled headers
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <benchmrk.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_rpc2.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rpc2.cxx
//
//  Contents:	ORPC Method Invocation tests
//
//  Classes:	CRpcTest22
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_rpc2.hxx>
#include <stream.hxx>
#include <oletest.hxx>
#include <tracelog.hxx>
#include <cqi.hxx>


TCHAR *CRpcTest2::Name ()
{
    return TEXT("RpcTest2");
}


SCODE CRpcTest2::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    SCODE sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Local"));
    if (FAILED(sc))
    {
	Log (TEXT("Setup - GetClassID failed."), sc);
	return sc;
    }

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays
    INIT_RESULTS(m_ulNULLTime);

    INIT_RESULTS(m_ulIUnknownBestInTime);
    INIT_RESULTS(m_ulIUnknownWorstInTime);

    INIT_RESULTS(m_ulIUnknownBestOutTime);
    INIT_RESULTS(m_ulIUnknownWorstOutTime);


    m_pRPC = NULL;
    m_pStm = NULL;

    // get the stream of data to unmarshal from the file.
    TCHAR	szFile[MAX_PATH];
    pInput->GetConfigString(Name(), TEXT("File"), TEXT(" "),
			    szFile, sizeof(szFile)/sizeof(TCHAR));

    if (!wcscmp(szFile,L" "))
    {
	sc = E_INVALIDARG;
	Log (TEXT("Setup - Get FileName failed."), sc);
	return sc;
    }

    // now make a stream on file
    m_pStm = (IStream *) new CStreamOnFile(szFile, sc, TRUE);

    if (FAILED(sc))
    {
	Log (TEXT("Setup - new CStreamOnFile failed."), sc);
	return sc;
    }

    m_punkInproc = (IUnknown *) new CQI(CLSID_QI);

    return S_OK;
}


SCODE CRpcTest2::Cleanup ()
{
    if (m_pRPC)
	m_pRPC->Release();

    if (m_punkInproc)
	m_punkInproc->Release();

    return S_OK;
}

SCODE CRpcTest2::PrepareForRun()
{
    SCODE sc = InitCOM();

    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
	return	sc;
    }

    // get the interface to call on

    // reset the stream to the beginning
    LARGE_INTEGER libMove;
    LISet32(libMove, 0x00000000);
    m_pStm->Seek(libMove, STREAM_SEEK_SET, NULL);

    // unmarshal the interface
    sc = CoUnmarshalInterface(m_pStm, IID_IRpcTest, (void **)&m_pRPC);

    if (FAILED(sc))
    {
	Log (TEXT("PrepareForRun - CoUnmarshalInteface failed."), sc);
	UninitCOM();
    }

    Sleep(500);
    return sc;
}

void CRpcTest2::CleanupFromRun()
{
    if (m_pRPC)
    {
	m_pRPC->Release();
	m_pRPC = NULL;
    }

    UninitCOM();

    Sleep(500);
}


SCODE CRpcTest2::Run ()
{
    CStopWatch  sw;
    SCODE       sc;
    ULONG       iIter;

    //
    // NULL call tests
    //

    if (FAILED(sc = PrepareForRun()))
    {
	return sc;
    }

    Sleep(2000);

    for (iIter=0; iIter<TEST_MAX_ITERATIONS_PRIVATE; iIter++)
    {
	sw.Reset();
        m_pRPC->Void();
	m_ulNULLTime[iIter] = sw.Read();
    }

    CleanupFromRun();




    //
    //	IUnknown [in] Best Case - The other side already has
    //	the interface we are passing in.
    //

    if (FAILED(sc = PrepareForRun()))
    {
	return sc;
    }

    // give the other side the interface to keep
    sc = m_pRPC->IUnknownInKeep(m_punkInproc);


    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
        sc = m_pRPC->IUnknownIn(m_punkInproc);
	m_ulIUnknownBestInTime[iIter] = sw.Read();
    }

    sc = m_pRPC->IUnknownInRelease();

    CleanupFromRun();





    //
    //	IUnknown [out] Best Case - We already have the interface being
    //	passed back to us.
    //

    if (FAILED(sc = PrepareForRun()))
    {
	return sc;
    }

    // get the interface from the other side, and hang onto it.
    IUnknown *punkOut = NULL;
    sc = m_pRPC->IUnknownOut(&punkOut);


    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	IUnknown *punkOut2 = NULL;

	sw.Reset();
	sc = m_pRPC->IUnknownOut(&punkOut2);
	m_ulIUnknownBestOutTime[iIter] = sw.Read();

	if (SUCCEEDED(sc))
	{
	    // release 1 reference
	    punkOut2->Release();
	}
    }

    // release the ptr we are holding, should be final release.
    punkOut->Release();

    CleanupFromRun();





    //
    //	IUnknown [in] Worst Case - the other side does not have
    //	the interface we are passing in, nor have we ever marshaled
    //	an interface before in this process. The other side does not
    //	keep the interface we hand it.	We loop several times, each time
    //	we do OleInit, OleUninit.
    //

    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	if (FAILED(sc = PrepareForRun()))
	{
	    return sc;
	}

	sw.Reset();
	sc = m_pRPC->IUnknownIn(m_punkInproc);
	m_ulIUnknownWorstInTime[iIter] = sw.Read();

	CleanupFromRun();
    }





    //
    //	IUnknown [out] Worst Case - the other side is giving us a brand
    //	new object, that it has never marshaled before. We do not hold onto
    //	the interface.	We loop several times, each time
    //	we do OleInit, OleUninit.
    //

    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	if (FAILED(sc = PrepareForRun()))
	{
	    return sc;
	}

	sw.Reset();

	// BUGBUG sc = m_pRPC->IUnknownNewOut(&punkOut);
	sc = m_pRPC->IUnknownOut(&punkOut);

	m_ulIUnknownWorstOutTime[iIter] = sw.Read();

	if (SUCCEEDED(sc))
	{
	    punkOut->Release();
	}

	CleanupFromRun();
    }

    return S_OK;
}					


SCODE CRpcTest2::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Object Rpc2"), *m_pInput);

    output.WriteString(TEXT("\n"));

    output.WriteResults(TEXT("NULL              "), TEST_MAX_ITERATIONS_PRIVATE, m_ulNULLTime);
    output.WriteResults(TEXT("IUnknown In  Best "), m_ulIterations, m_ulIUnknownBestInTime);
    output.WriteResults(TEXT("IUnknown In  Worst"), m_ulIterations, m_ulIUnknownWorstInTime);
    output.WriteResults(TEXT("IUnknown Out Best "), m_ulIterations, m_ulIUnknownBestOutTime);
    output.WriteResults(TEXT("IUnknown Out Worst"), m_ulIterations, m_ulIUnknownWorstOutTime);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\rawrpc_c.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
static handle_t AutoBindHandle;
extern RPC_DISPATCH_TABLE IRawRpc_DispatchTable;

static RPC_CLIENT_INTERFACE ___RpcClientInterface =  {
  sizeof(RPC_CLIENT_INTERFACE),
  {{0x00000145,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}},
  {0,0}},
    {
    {0x8A885D04L,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},
    {2,0}
    }
  ,
  0,0,0,
  0
  }
;
RPC_IF_HANDLE IRawRpc_ClientIfHandle = (RPC_IF_HANDLE) &___RpcClientInterface;
SCODE Quit(
	handle_t hRpc)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 0 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
void Void(
	handle_t hRpc)
  {
  unsigned char * _packet;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 1 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _status = I_RpcFreeBuffer(&_message);
  if (_status) RpcRaiseException(_status);

  }
SCODE VoidRC(
	handle_t hRpc)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 2 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE VoidPtrIn(
	handle_t hRpc,
	ULONG cb,
	void *pv)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 8;
  if (pv ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
  _prpcmsg->BufferLength += 4;
  _prpcmsg->BufferLength += (unsigned int)(cb);
  _message.ProcNum = ( 3 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  /* send data from cb */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)cb;
  // send total number of elements
  *(*(long **)&_prpcmsg->Buffer)++ = cb;
  /* send data from pv */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) ((unsigned char *)pv+0), (unsigned int)(cb));
  *(unsigned long *)&_prpcmsg->Buffer += cb;
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE VoidPtrOut(
	handle_t hRpc,
	ULONG cb,
	ULONG *pcb,
	void *pv)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 4;
  _message.ProcNum = ( 4 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from cb */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)cb;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pcb ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    /* receive data into pcb */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)pcb);
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pv ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    // recv valid range
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_valid_lower);
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_valid_total);
    byte_array_from_ndr ((PRPC_MESSAGE)_prpcmsg, _valid_lower, _valid_lower + _valid_total, pv);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE DwordIn(
	handle_t hRpc,
	DWORD dw)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 4;
  _message.ProcNum = ( 5 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from dw */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)dw;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE DwordOut(
	handle_t hRpc,
	DWORD *pdw)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 6 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pdw ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    /* receive data into pdw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)pdw);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE DwordInOut(
	handle_t hRpc,
	DWORD *pdw)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 4;
  _message.ProcNum = ( 7 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  /* send data from *pdw */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)*pdw;
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pdw ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    /* receive data into pdw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)pdw);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE LiIn(
	handle_t hRpc,
	LARGE_INTEGER li)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 8;
  _message.ProcNum = ( 8 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from &li */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&li), (unsigned int)(8));
  *(unsigned long *)&_prpcmsg->Buffer += 8;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE LiOut(
	handle_t hRpc,
	LARGE_INTEGER *pli)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 9 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pli ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pli), "4ll", 8);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE ULiIn(
	handle_t hRpc,
	ULARGE_INTEGER uli)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 8;
  _message.ProcNum = ( 10 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from &uli */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&uli), (unsigned int)(8));
  *(unsigned long *)&_prpcmsg->Buffer += 8;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE ULiOut(
	handle_t hRpc,
	ULARGE_INTEGER *puli)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 11 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (puli ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (puli), "4ll", 8);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE StringIn(
	handle_t hRpc,
	LPWSTR pwsz)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
  tree_size_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _message.ProcNum = ( 12 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  tree_into_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE StringOut(
	handle_t hRpc,
	LPWSTR *ppwsz)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 13 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    if (ppwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    if (*(*(unsigned long **)&_prpcmsg->Buffer)++)
      {
      // recv total number of elements
      long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
      if ((*ppwsz) ==0)
        {
        (*ppwsz) = (WCHAR *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(WCHAR)));
        }
      data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) ((*ppwsz)), "s2", 1);
      }
    else
      {
      (*ppwsz) = 0;
      }
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE StringInOut(
	handle_t hRpc,
	LPWSTR pwsz)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
  tree_size_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _message.ProcNum = ( 14 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  tree_into_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pwsz), "s2", 1);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE GuidIn(
	handle_t hRpc,
	GUID guid)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 16;
  _message.ProcNum = ( 15 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from &guid */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&guid), (unsigned int)(16));
  *(unsigned long *)&_prpcmsg->Buffer += 16;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE GuidOut(
	handle_t hRpc,
	GUID *pguid)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 16 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pguid ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    _gns__GUID ((GUID *)pguid, (PRPC_MESSAGE)_prpcmsg);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_stg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//					
//  File:	bm_stg.cxx
//
//  Contents:	Basic Storage test
//
//  Classes:	CStorageTest
//
//  History:    7-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_stg.hxx>

#define DEF_DATASIZE    16384

//#define TIME_FILEIO	// define this macro to do timing of ole32.dll internal file io
			// requires special ole32.dll

#ifdef TIME_FILEIO
#include <extimeio.hxx>
#endif

TCHAR *CStorageTest::Name ()
{
    return TEXT("StorageTest");
}


SCODE CStorageTest::Setup (CTestInput *pInput)
{
    SCODE sc;
    TCHAR pszValue[16];
    ULONG i;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    // get malloc interface for this task
    m_piMalloc = NULL;
    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
    {
    	Log (TEXT("Setup - CoGetMalloc"), sc);
	Cleanup();
    	return sc;
    }

    // get values of various paremeters from ini file

    m_iStartSize = pInput->GetConfigInt(Name(), TEXT("StartSize"), 16);
    if(m_iStartSize <= 0)
    	m_iStartSize = 16;

    m_iEndSize = pInput->GetConfigInt(Name(), TEXT("EndSize"), DEF_DATASIZE);

    // initialize array to be written to the file.
    m_pbData = (BYTE *)m_piMalloc->Alloc(m_iEndSize);
    if(m_pbData == NULL)
    {
    	Log (TEXT("Setup - Cannot allocate memory"), E_OUTOFMEMORY);
	Cleanup();
	return E_OUTOFMEMORY;
    }

    for (i=0; i < m_iEndSize; i++)
        m_pbData[i] = (BYTE)i;


    m_iRepeatFactor = pInput->GetConfigInt(Name(), TEXT("RepeatFactor"), 1);

    if (m_iRepeatFactor > MAX_REPS)
    	m_iRepeatFactor = MAX_REPS;

    // Figure out how many different sizes we're going to write.
    // and the size of the final file.
    m_ulTotalSize = 0;
    for(m_ulNumSizes = 0, i = m_iStartSize; i <= m_iEndSize; i *=2, m_ulNumSizes++)
	m_ulTotalSize += i * m_iRepeatFactor;


    if (m_iRepeatFactor * m_ulNumSizes > MAX_READS)
    {
    	Log(TEXT("Too many different sizes and/or repeat factor is too big"), E_FAIL);
	Cleanup();
	return E_FAIL;
    }

    m_flStgCreateFlags = 0;
    // get file name to be used and values of other parameters
    pInput->GetConfigString(Name(), TEXT("FileName"), TEXT("stgtest.bm"),
    			    m_pszFile, MAX_PATH);
#ifdef UNICODE
    wcscpy(m_pwszFile, m_pszFile);
#else
    mbstowcs(m_pwszFile, m_pszFile, strlen(m_pszFile)+1);
#endif

    pInput->GetConfigString(Name(), TEXT("FileMode"), TEXT("DIRECT"),
    			    m_pszFileMode, 15);

    if(lstrcmpi(m_pszFileMode, TEXT("DIRECT")) == 0)
       	m_flStgCreateFlags |= STGM_DIRECT;
    else
       	m_flStgCreateFlags |= STGM_TRANSACTED; 	


    pInput->GetConfigString(Name(), TEXT("SetSize"), TEXT("OFF"), pszValue, 15);

    if (lstrcmpi(pszValue, TEXT("ON")) == 0)
    	m_bDoSetSize = TRUE;
    else
    	m_bDoSetSize = FALSE;

    pInput->GetConfigString(Name(), TEXT("ReadMode"), TEXT("SEQUENTIAL"),
    			    m_pszReadMode, 15);

    if(lstrcmpi(m_pszReadMode, TEXT("SEQUENTIAL")) == 0)
    	m_bSequentialRead = TRUE;
    else
    	m_bSequentialRead = FALSE;


    InitTimings();

    return S_OK;
}


void CStorageTest::InitTimings()
{
    ULONG i;

    //	initialize timing arrays

    INIT_RESULTS(m_ulIsStorageFileYES);
    INIT_RESULTS(m_ulIsStorageFileNO);
    INIT_RESULTS(m_ulStgOpenStorageDRFAIL);


    INIT_RESULTS(m_ulStgCreateDocfile);
    INIT_RESULTS(m_ulCreateStream);
    ZERO_RESULTS(m_ulSetSize);
    INIT_RESULTS(m_ulStreamRelease1);
    ZERO_RESULTS(m_ulStorageCommit);
    INIT_RESULTS(m_ulStorageRelease1);

    INIT_RESULTS(m_ulStgOpenStorage);
    INIT_RESULTS(m_ulOpenStream);
    INIT_RESULTS(m_ulStreamRelease2);
    INIT_RESULTS(m_ulStorageRelease2);

    ZERO_RESULTS(m_ulStreamWriteTotal);
    ZERO_RESULTS(m_ulStreamReadTotal);
    ZERO_RESULTS(m_ulStreamSeekTotal);


    for (i = 0; i < MAX_READS; i++)
    {
    	INIT_RESULTS(m_ulStreamWrite[i]);
    	INIT_RESULTS(m_ulStreamRead[i]);
    	INIT_RESULTS(m_ulStreamSeek[i]);
#ifdef TIME_FILEIO
    	INIT_RESULTS(m_ulActualWrite[i]);
    	INIT_RESULTS(m_ulActualRead[i]);
#endif
    }

#ifdef TIME_FILEIO
    INIT_RESULTS(m_ulActualFlush1);
    INIT_RESULTS(m_ulActualFlush2);
    INIT_RESULTS(m_ulActualCommitW);
#endif

    for (i = 0; i < 2; i++ )
    	ZERO_RESULTS(m_ulTotal[i]);

}


SCODE CStorageTest::Cleanup ()
{
    //	delete the file
    DeleteFile (m_pszFile);
    if(m_piMalloc)
    {
    	if (m_pbData)
    	    m_piMalloc->Free(m_pbData);

	m_pbData = NULL;

	m_piMalloc->Release();
	m_piMalloc = NULL;

    }

    UninitCOM();

    return S_OK;
}


SCODE CStorageTest::Run ()
{
        CStopWatch  sw;
	HRESULT     hr;
        LPSTORAGE   piStorage;
        LPSTREAM    piStream;
        ULONG       cb;
        ULONG       iIter;
	ULONG	    iSize;
	ULONG	    i, iCount;
    	ULARGE_INTEGER  li;

#ifdef TIME_FILEIO
	ULONG	    ulTempTime;
#endif
        //Create and then write to docfile in selected mode
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hr = StgCreateDocfile(m_pwszFile, m_flStgCreateFlags | STGM_WRITE
	          | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &piStorage);
	    m_ulStgCreateDocfile[iIter] = sw.Read();
            Log(TEXT("StgCreateDocfile for writing"), hr);
            if(FAILED(hr))
                return hr;

            sw.Reset();
            hr = piStorage->CreateStream(L"CONTENTS", STGM_DIRECT |
            		STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,
            		0, 0, &piStream);
            m_ulCreateStream[iIter] = sw.Read();
            Log(TEXT("CreateStream"), hr);


	    if (m_bDoSetSize)
	    {
		ULISet32(li, m_ulTotalSize);
	    	sw.Reset();
	    	hr = piStream->SetSize(li);
	    	m_ulSetSize[iIter] = sw.Read();
		Log(TEXT("IStream::SetSize"), hr);
	    }

#ifdef TIME_FILEIO
	    // reset all timings
	    GetFlushTiming(NULL, TRUE);
	    GetWriteTiming(NULL, TRUE);
	    GetReadTiming(NULL, TRUE);
	    GetSetFileTiming(NULL, TRUE);
#endif
	    iCount = 0;
	    for ( iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    {
	    	for ( i = 0; i < m_iRepeatFactor; i++)
	    	{
   		    sw.Reset();
		    hr = piStream->Write((LPVOID)m_pbData, iSize, &cb);
         	    m_ulStreamWrite[iCount][iIter] = sw.Read();
     		    m_ulStreamWriteTotal[iIter] += m_ulStreamWrite[iCount][iIter];
#ifdef TIME_FILEIO
		    GetWriteTiming(&m_ulActualWrite[iCount][iIter], TRUE);
            	    GetSetFileTiming(&ulTempTime, TRUE);
		    m_ulActualWrite[iCount][iIter] += ulTempTime;
#endif
		    iCount++;
	    	}
	    }
	    Log(TEXT("IStream->Write X bytes"), hr);
	

            sw.Reset();
            piStream->Release();
            m_ulStreamRelease1[iIter] = sw.Read();

	    if(m_flStgCreateFlags == STGM_TRANSACTED)
	    {
            	sw.Reset();
            	piStorage->Commit(STGC_DEFAULT);
            	m_ulStorageCommit[iIter] = sw.Read();
 	    }

            sw.Reset();
            piStorage->Release();
            m_ulStorageRelease1[iIter] = sw.Read();
#ifdef TIME_FILEIO
	    GetFlushTiming(&m_ulActualFlush1[iIter], TRUE);
	    GetWriteTiming(&m_ulActualCommitW[iIter], TRUE);
#endif

            m_ulTotal[0][iIter] = m_ulStgCreateDocfile[iIter] +
                            	m_ulCreateStream[iIter] +
				m_ulSetSize[iIter] +
                            	m_ulStreamWriteTotal[iIter] +
                            	m_ulStreamRelease1[iIter] +
                            	m_ulStorageCommit[iIter] +
                            	m_ulStorageRelease1[iIter];
        }


        // now try reading from the file.
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hr = StgOpenStorage(m_pwszFile, NULL, m_flStgCreateFlags | STGM_READ
	          | STGM_SHARE_EXCLUSIVE, NULL, 0, &piStorage);
	    m_ulStgOpenStorage[iIter] = sw.Read();
            Log(TEXT("StgOpenStorage for reading"), hr);

            sw.Reset();
            hr = piStorage->OpenStream(L"CONTENTS", NULL, STGM_DIRECT | STGM_READ
                   | STGM_SHARE_EXCLUSIVE, 0, &piStream);
            m_ulOpenStream[iIter] = sw.Read();
            Log(TEXT("IStorage->OpenStream"), hr);


#ifdef TIME_FILEIO
    	    GetReadTiming(NULL, TRUE);
	    GetSetFileTiming(NULL, TRUE);
#endif

	    iCount = 0;
    	    if (m_bSequentialRead)
	    {
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
		     for (i = 0; i < m_iRepeatFactor; i++)
		     {
   			sw.Reset();
	        	hr = piStream->Read((LPVOID)m_pbData, iSize, &cb);
         		m_ulStreamRead[iCount][iIter] = sw.Read();
         		m_ulStreamReadTotal[iIter] += m_ulStreamRead[iCount][iIter];
#ifdef TIME_FILEIO
	    	    	GetReadTiming(&m_ulActualRead[iCount][iIter], TRUE);
	    	    	GetSetFileTiming(&ulTempTime, TRUE);
       			m_ulActualRead[iCount][iIter] += ulTempTime;
#endif
   			iCount++;
		     }
	    	}
            	Log(TEXT("IStorage->Read Sequential"), hr);
	    }
	    else
	    {
		LARGE_INTEGER liSeekSize;
	        ULONG 	      cbCurOffset = m_ulTotalSize;

		iCount = 0;
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
	    	  for ( i =0; i< m_iRepeatFactor; i++)
		  {
		    cbCurOffset -= iSize;
		    LISet32(liSeekSize, cbCurOffset);

		    sw.Reset();
            	    hr = piStream->Seek(liSeekSize, STREAM_SEEK_SET, NULL);
            	    m_ulStreamSeek[iCount][iIter] = sw.Read();
         	    m_ulStreamSeekTotal[iIter] += m_ulStreamSeek[iCount][iIter];

		    sw.Reset();
            	    hr = piStream->Read((LPVOID)m_pbData, iSize, &cb);
            	    m_ulStreamRead[iCount][iIter] = sw.Read();
         	    m_ulStreamReadTotal[iIter] += m_ulStreamRead[i][iIter];
#ifdef TIME_FILEIO
	    	    GetReadTiming(&m_ulActualRead[iCount][iIter], TRUE);
	    	    GetSetFileTiming(&ulTempTime, TRUE);
       		    m_ulActualRead[iCount][iIter] += ulTempTime;
#endif		
		    iCount++;
		  }
	    	}

            	Log(TEXT("IStorage->Read Random"), hr);
	    }

            sw.Reset();
            piStream->Release();
            m_ulStreamRelease2[iIter] = sw.Read();

            sw.Reset();
            piStorage->Release();
            m_ulStorageRelease2[iIter] = sw.Read();

#ifdef TIME_FILEIO
	    GetFlushTiming(&m_ulActualFlush2[iIter], TRUE);
#endif

            m_ulTotal[1][iIter] = m_ulStgOpenStorage[iIter] +
                            	  m_ulOpenStream[iIter] +
				  m_ulStreamSeekTotal[iIter] +
                            	  m_ulStreamReadTotal[iIter] +
                         	  m_ulStreamRelease2[iIter] +
                            	  m_ulStorageRelease2[iIter];
        }


        // test if its a storage file (should be yes).
 	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
            hr = StgIsStorageFile(m_pwszFile);
            m_ulIsStorageFileYES[iIter] = sw.Read();
            Log(TEXT("StgIsStorageFile on storage file"), hr);
        }

        // create a non-storage file and check if it is storage file
	HANDLE hFile = CreateFile(m_pszFile, GENERIC_READ | GENERIC_WRITE, 0, NULL,
				 CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
	    Log(TEXT("Creation of non storage file"), E_FAIL);
	    return E_FAIL;
	}
        WriteFile(hFile, (LPSTR)m_pbData, m_iEndSize, &cb, NULL);
	CloseHandle(hFile);

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    LPSTORAGE piStorage;

	    sw.Reset();
	    hr = StgIsStorageFile(m_pwszFile);
	    m_ulIsStorageFileNO[iIter] = sw.Read();
	    Log(TEXT("StgIsStorageFile on Non-storage file"),
	    	(hr != S_OK) ? S_OK : E_FAIL);

	    sw.Reset();
	    hr =StgOpenStorage(m_pwszFile, NULL, STGM_DIRECT | STGM_READ
	        | STGM_SHARE_EXCLUSIVE, NULL, 0, &piStorage);
	    m_ulStgOpenStorageDRFAIL[iIter] = sw.Read();
	    Log(TEXT("StgOpenStorage on Non-storage file"),
	    	(hr != S_OK) ? S_OK : E_FAIL);
	}



        return S_OK;
}



SCODE CStorageTest::Report (CTestOutput &output)
{
    TCHAR pszBuf[80];
    ULONG i, iSize, iCount;
#ifdef TIME_FILEIO
    ULONG ulActualTotal[TEST_MAX_ITERATIONS];
#endif

    wsprintf(pszBuf, TEXT("Storage Test in %s Mode with %s Read/Writes"),
    	      m_pszFileMode, m_pszReadMode);

    output.WriteSectionHeader (Name(), pszBuf, *m_pInput);

    wsprintf(pszBuf, TEXT("SetSize is %s\n\n"), m_bDoSetSize ? TEXT("ON") : TEXT("OFF"));
    output.WriteString (pszBuf);

    output.WriteResults (TEXT("IsStorageFile - YES"), m_ulIterations,
    			 m_ulIsStorageFileYES);
    output.WriteResults (TEXT("IsStorageFile - NO "), m_ulIterations,
    			 m_ulIsStorageFileNO);
    output.WriteResults (TEXT("StgOpenStorage D/R/FAIL"), m_ulIterations,
    			 m_ulStgOpenStorageDRFAIL);
    output.WriteString (TEXT("\n"));


    output.WriteResults (TEXT("StgCreateDocfile    "), m_ulIterations,
    			 m_ulStgCreateDocfile);
    output.WriteResults (TEXT("CreateStream        "), m_ulIterations,
    			 m_ulCreateStream);

    output.WriteString (TEXT("\n"));

    if (m_bDoSetSize)
    	output.WriteResults (TEXT("Stream SetSize      "), m_ulIterations,
    			 m_ulSetSize);

#ifdef TIME_FILEIO
    ZERO_RESULTS(ulActualTotal);
#endif

    iCount = 0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i = 0; i < m_iRepeatFactor; i++)
	{
    	     wsprintf(pszBuf, TEXT("StreamWrite %-9d"), iSize);

    	     output.WriteResults (pszBuf, m_ulIterations, m_ulStreamWrite[iCount]);

#ifdef TIME_FILEIO
	output.WriteResults (TEXT("Disk-hit time     "), m_ulIterations, m_ulActualWrite[iCount]);
	
	for ( ULONG xx = 0; xx < m_ulIterations; xx++)
		ulActualTotal[xx] += m_ulActualWrite[iCount][xx];
#endif
	     iCount++;
        }

    }

    output.WriteResults (TEXT("StreamWrite Total   "), m_ulIterations,
    			 m_ulStreamWriteTotal);
#ifdef TIME_FILEIO

    output.WriteResults (TEXT("Actual Write Total  "), m_ulIterations,
    			 ulActualTotal);

#endif



    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamRelease       "), m_ulIterations,
    			 m_ulStreamRelease1);

    if (m_flStgCreateFlags == STGM_TRANSACTED)
    {
        output.WriteResults (TEXT("StorageCommit       "), m_ulIterations,
        		     m_ulStorageCommit);

#ifdef TIME_FILEIO
        output.WriteResults (TEXT("Disk hit time       "), m_ulIterations,
        		     m_ulActualCommitW);
#endif
    }

    output.WriteResults (TEXT("StorageRelease      "), m_ulIterations,
    			 m_ulStorageRelease1);

#ifdef TIME_FILEIO
    output.WriteResults (TEXT("Actual Flush time   "), m_ulIterations,
        		     m_ulActualFlush1);
#endif

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[0]);
    output.WriteString (TEXT("\n\n"));

    output.WriteResults (TEXT("StgOpenStorage      "), m_ulIterations,
    			 m_ulStgOpenStorage);
    output.WriteResults (TEXT("OpenStream          "), m_ulIterations,
    			 m_ulOpenStream);

    output.WriteString (TEXT("\n"));

#ifdef TIME_FILEIO
    ZERO_RESULTS(ulActualTotal);
#endif

    iCount = 0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i = 0; i < m_iRepeatFactor; i++)
	{
    	    if (!m_bSequentialRead)
	    {
    	    	wsprintf(pszBuf, TEXT("StreamSeek %-9d"), m_iEndSize - iSize);
    	    	output.WriteResults (pszBuf, m_ulIterations, m_ulStreamSeek[iCount]);
	    }

    	    wsprintf(pszBuf, TEXT("StreamRead %-9d"), iSize);
    	    output.WriteResults (pszBuf, m_ulIterations, m_ulStreamRead[iCount]);

#ifdef TIME_FILEIO
	    output.WriteResults (TEXT("Disk-hit time     "), m_ulIterations, m_ulActualRead[iCount]);
	
	    for ( ULONG xx = 0; xx < m_ulIterations; xx++)
		ulActualTotal[xx] += m_ulActualRead[iCount][xx];
#endif
            iCount++;
	}
    }

    if (!m_bSequentialRead)
    	output.WriteResults (TEXT("StreamSeek Total "), m_ulIterations,
    			 m_ulStreamSeekTotal);

    output.WriteResults (TEXT("StreamRead Total "), m_ulIterations,
    			 m_ulStreamReadTotal);


#ifdef TIME_FILEIO
    output.WriteResults (TEXT("Actual Read  Total  "), m_ulIterations,
    			 ulActualTotal);
#endif


    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamRelease       "), m_ulIterations,
    			 m_ulStreamRelease2);
    output.WriteResults (TEXT("StorageRelease      "), m_ulIterations,
    			 m_ulStorageRelease2);
#ifdef TIME_FILEIO
    output.WriteResults (TEXT("Actual Flush time   "), m_ulIterations,
        		     m_ulActualFlush2);
#endif

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[1]);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_sbind.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_sbind.cxx
//
//  Contents:	Ole moniker binding test (BindToObject)
//
//  Classes:	CFileMonikerStorageBindTest
//
//  History:    9-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_sbind.hxx>


TCHAR *CFileMonikerStorageBindTest::Name ()
{
	return TEXT("BindToStorage");
}


SCODE CFileMonikerStorageBindTest::Setup (CTestInput *pInput)
{
	IClassFactory	*pICF = NULL;
	IStorage	*pStg = NULL;
	IPersistStorage *pIPS = NULL;
	SCODE		 sc;

	CTestBase::Setup(pInput);

	// get the iteration count from the ini file
	m_ulIterations = pInput->GetIterations(Name());

	//  for each class ctx, get the classid, and init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Get ClsID for this Ctx from the .ini file
	    sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	    if (FAILED(sc))
	    {
		Log (TEXT("Setup - GetClassID failed."), sc);
		return sc;
	    }

	    INIT_RESULTS(m_ulCreateMkrTime[iCtx]);
	    INIT_RESULTS(m_ulCreateBndCtxTime[iCtx]);
	    INIT_RESULTS(m_ulBindTime[iCtx]);
	}

	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return	sc;
	}

	//  for each class ctx, create a persistent instance on disk
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Create an instance
	    sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				  IID_IClassFactory, (void **)&pICF);
	    if (SUCCEEDED(sc))
	    {
		sc = pICF->CreateInstance(NULL, IID_IPersistStorage,
					  (void **)&pIPS);
		pICF->Release();
		if (SUCCEEDED(sc))
		{
		    // create instance of the storage
		    sc = StgCreateDocfile(apszPerstName[iCtx],
					  STGM_READWRITE | STGM_CREATE |
					  STGM_SHARE_EXCLUSIVE,
					  0, &pStg);
		    if (SUCCEEDED(sc))
		    {
			//	save the class instance in the storage
			sc = pIPS->Save(pStg, FALSE);
			pStg->Release();

			if (FAILED(sc))
			{
			    Log (TEXT("Setup - pIPS->Save failed."), sc);
			}
		    }
		    else
		    {
			Log (TEXT("Setup - StgCreateDocfile failed."), sc);
		    }

		    pIPS->Release();
		}
		else
		{
		    Log (TEXT("Setup - CreateInstance failed"), sc);
		}
	    }
	    else
	    {
		Log (TEXT("Setup - CoGetClassObject failed"), sc);
	    }
	}

	return S_OK;
}


SCODE CFileMonikerStorageBindTest::Cleanup ()
{
	UninitCOM();

	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete original
	    wcstombs(szPerstName, apszPerstName[iCtx],
		     wcslen(apszPerstName[iCtx])+1);
	    _unlink(szPerstName);
	}

	return S_OK;
}


SCODE CFileMonikerStorageBindTest::Run ()
{
	CStopWatch  sw;
	IMoniker   *pmk  = NULL;
	IBindCtx   *pbc  = NULL;
	IStorage   *pStg = NULL;
	SCODE	    sc;

	//  for each class context
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = CreateFileMoniker (apszPerstName[iCtx], &pmk);
		m_ulCreateMkrTime[iCtx][iIter] = sw.Read();

		if (!Log (TEXT("CreateFileMoniker"), sc))
		{
		    BIND_OPTS	bindopts;
		    bindopts.cbStruct = sizeof(BIND_OPTS);

		    sw.Reset();
		    sc = CreateBindCtx(0, &pbc);
		    if (SUCCEEDED(sc))
		    {
			sc = pbc->GetBindOptions(&bindopts);
			bindopts.grfMode |= STGM_SHARE_EXCLUSIVE | STGM_DIRECT;
			sc = pbc->SetBindOptions(&bindopts);
		    }
		    m_ulCreateBndCtxTime[iCtx][iIter] = sw.Read();

		    if (!Log (TEXT("CreateBindCtx"), sc))
		    {
			sw.Reset();
			sc = pmk->BindToStorage(pbc, NULL, IID_IStorage, (void**)&pStg);
			m_ulBindTime[iCtx][iIter]=sw.Read();

			if (!Log (TEXT("BindToStorage"), sc))
			{
			    sw.Reset();
			    pStg->Release();
			    m_ulReleaseTime[iCtx][iIter]=sw.Read();
			}
			else
			{
			    m_ulBindTime[iCtx][iIter] = NOTAVAIL;
			}

			pbc->Release();
		    }
		    else
		    {
			m_ulCreateBndCtxTime[iCtx][iIter] = NOTAVAIL;
		    }

		    pmk->Release();
		}
		else
		{
		    m_ulCreateMkrTime[iCtx][iIter] = NOTAVAIL;
		}
	    }
	}

	return S_OK;
}		



SCODE CFileMonikerStorageBindTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("BindToStorage via FileMoniker"), *m_pInput);

	//  for each clsctx, write the results
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(TEXT("\n"));
	    output.WriteClassID(&m_ClsID[iCtx]);
	    output.WriteString(apszClsCtx[iCtx]);
	    output.WriteString(TEXT("\n"));

	    output.WriteResults(TEXT("CreateMoniker"), m_ulIterations, m_ulCreateMkrTime[iCtx]);
	    output.WriteResults(TEXT("CreateBindCtx"), m_ulIterations, m_ulCreateBndCtxTime[iCtx]);
	    output.WriteResults(TEXT("Bind         "), m_ulIterations, m_ulBindTime[iCtx]);
	    output.WriteResults(TEXT("Release      "), m_ulIterations, m_ulReleaseTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\rawrpc_x.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\tests\bm_rrpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rrpc.cxx
//
//  Contents:	Raw Rpc function call tests
//
//  Classes:	CRawRpc
//
//  History:	1-Jul-93    t-martig	Created
//		2-Feb-94    rickhi	Modified from above for Raw Rpc
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <bm_rrpc.hxx>


HRESULT StartServer(BOOL _fDebug, LPTSTR _pszPath);


extern "C" const GUID IID_IRawRpc;


TCHAR *CRawRpc::Name ()
{
	return TEXT("RawRpc");
}


SCODE CRawRpc::Setup (CTestInput *pInput)
{
	CTestBase::Setup(pInput);

	// get flag indicating whether to keep all values or
	// only average values.
	TCHAR	szAverage[5];
	pInput->GetConfigString(Name(), TEXT("Average"), TEXT("Y"),
                            szAverage, sizeof(szAverage)/sizeof(TCHAR));
        if (szAverage[0] == 'n' || szAverage[0] == 'N')
	    m_fAverage = FALSE;
	else
	    m_fAverage = TRUE;

	//  get iteration count
	if (m_fAverage)
	    m_ulIterations = pInput->GetRealIterations(Name());
	else
	    m_ulIterations = pInput->GetIterations(Name());
	m_pszStringBinding	 = NULL;
	m_hRpc			 = NULL;

	//  initialize timing arrays
	INIT_RESULTS(m_ulVoidTime);
	INIT_RESULTS(m_ulVoidRCTime);

	INIT_RESULTS(m_ulDwordInTime);
	INIT_RESULTS(m_ulDwordOutTime);
	INIT_RESULTS(m_ulDwordInOutTime);

	INIT_RESULTS(m_ulStringInTime);
	INIT_RESULTS(m_ulStringOutTime);
	INIT_RESULTS(m_ulStringInOutTime);

	INIT_RESULTS(m_ulGuidInTime);
	INIT_RESULTS(m_ulGuidOutTime);



	//  get the server exe name and debug flag out of the ini file, then
	//  start the server and wait for it.

	TCHAR	szServer[15];
	pInput->GetConfigString(Name(), TEXT("Server"), TEXT("rawrpc.exe"),
                            szServer, sizeof(szServer)/sizeof(TCHAR));

	//  get input
	TCHAR	szValue[40];

	pInput->GetConfigString(Name(), TEXT("Debug"), TEXT("N"),
                            szValue, sizeof(szValue)/sizeof(TCHAR));

	BOOL fDebug = !lstrcmpi(szValue, TEXT("Y"));

	DWORD dwTimeout = pInput->GetConfigInt(Name(), TEXT("Timeout"), 60000);

	HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE,
                                    TEXT("OleBenchRawRpcServerStarted"));
	if (NULL == hEvent)
	{
	    Log (TEXT("Setup - Event Creation failed."), GetLastError());
	    return E_FAIL;
	}

	//  start the server application and wait for it.
	HRESULT sc = StartServer(fDebug, szServer);

	if (FAILED(sc))
	{
	    Log (TEXT("Setup - Start Server failed."), sc);
            CloseHandle(hEvent);
	    return sc;
	}


	if (WAIT_OBJECT_0 != WaitForSingleObject(hEvent, dwTimeout))
	{
    	    Log (TEXT("Setup - Server never signaled."), GetLastError());
            CloseHandle(hEvent);
    	    return E_FAIL;
	}
	CloseHandle(hEvent);

	//  bind to the server application
	TCHAR	szProtseq[20];
	TCHAR	szNetworkAddr[20];

	pInput->GetConfigString(Name(), TEXT("Protseq"),
#ifdef USE_MSWMSG
                            TEXT("mswmsg"),
#else
                            TEXT("ncalrpc"),
#endif
                            szProtseq, 20);

	pInput->GetConfigString(Name(), TEXT("NetworkAddr"), TEXT(""),
                            szNetworkAddr, 20);

	LPTSTR pszEndPoint	 = TEXT("99999.99999");
	RPC_STATUS rc;

#ifdef UNICODE
	rc = RpcStringBindingCompose(NULL,
				     szProtseq,
				     szNetworkAddr,
				     pszEndPoint,
				     NULL,
				     &m_pszStringBinding);
#else
    //
    // Can't just use TCHAR here because RpcString*() take unsigned
    // chars
    //
	rc = RpcStringBindingCompose(NULL,
				     (unsigned char *)szProtseq,
				     (unsigned char *)szNetworkAddr,
				     (unsigned char *)pszEndPoint,
				     NULL,
				     (unsigned char **)&m_pszStringBinding);
#endif
	if (rc != S_OK)
	{
	    Log(TEXT("Setup - RpcStringBindingCompose failed."), rc);
	    return rc;
	}

#ifdef UNICODE
	rc = RpcBindingFromStringBinding(m_pszStringBinding, &m_hRpc);
#else
	rc = RpcBindingFromStringBinding((unsigned char *)m_pszStringBinding,
                    &m_hRpc);
#endif

	if (rc != S_OK)
	{
	    Log(TEXT("Setup - RpcBindingFromStringBinding failed."), rc);
	    return rc;
	}

	//  all done.
	return S_OK;
}


SCODE CRawRpc::Cleanup ()
{
	if (m_hRpc)
	{
	    RpcBindingFree(&m_hRpc);
	}

	if (m_pszStringBinding)
	{
#ifdef UNICODE
	    RpcStringFree(&m_pszStringBinding);
#else
	    RpcStringFree((unsigned char **)&m_pszStringBinding);
#endif
	}

	return S_OK;
}


SCODE CRawRpc::Run ()
{
	CStopWatch  sw;
	SCODE	    sc;
	ULONG       iIter;

	//
	// void passing tests
	//

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    Void(m_hRpc);
	    ReadNotAverage( m_fAverage, sw, m_ulVoidTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulVoidTime[0], m_ulIterations );

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc = VoidRC(m_hRpc);
	    ReadNotAverage( m_fAverage, sw, m_ulVoidRCTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulVoidRCTime[0], m_ulIterations );

	//
	//  dword passing tests
	//

	DWORD dwTmp = 1;
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  DwordIn(m_hRpc, dwTmp);
	    ReadNotAverage( m_fAverage, sw, m_ulDwordInTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulDwordInTime[0], m_ulIterations );

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  DwordOut(m_hRpc, &dwTmp);
	    ReadNotAverage( m_fAverage, sw, m_ulDwordOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulDwordOutTime[0], m_ulIterations );

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  DwordInOut(m_hRpc, &dwTmp);
	    ReadNotAverage( m_fAverage, sw, m_ulDwordInOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulDwordInOutTime[0], m_ulIterations );

	//
	//  string passing tests
	//

	WCHAR szHello[] = L"C:\\FOOFOO\\FOOBAR\\FOOBAK\\FOOBAZ\\FOOTYPICAL\\PATH\\HELLO";
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  StringIn(m_hRpc, szHello);
	    ReadNotAverage( m_fAverage, sw, m_ulStringInTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulStringInTime[0], m_ulIterations );

	LPWSTR pwszOut = NULL;
#ifdef STRINGOUT
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    pwszOut = NULL;
	    sc =  StringOut(m_hRpc, &pwszOut);
	    ReadNotAverage( m_fAverage, sw, m_ulStringOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulStringOutTime[0], m_ulIterations );
#endif
	pwszOut = szHello;
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  StringInOut(m_hRpc, pwszOut);
	    ReadNotAverage( m_fAverage, sw, m_ulStringInOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulStringInOutTime[0], m_ulIterations );


	//
	//  guid passing tests
	//

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  GuidIn(m_hRpc, IID_IRawRpc);
	    ReadNotAverage( m_fAverage, sw, m_ulGuidInTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulGuidInTime[0], m_ulIterations );

	GUID	guid;
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  GuidOut(m_hRpc, &guid);
	    ReadNotAverage( m_fAverage, sw, m_ulGuidOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulGuidOutTime[0], m_ulIterations );

	//  tell the server to quit.
	sc = Quit(m_hRpc);

	return S_OK;
}					



SCODE CRawRpc::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Raw Rpc"), *m_pInput);

    if (m_fAverage)
    {
	output.WriteString (TEXT("\n"));
	output.WriteString (TEXT("Average Times\n"));
	output.WriteString (TEXT("\n"));
	output.WriteResult (TEXT("Void         "), m_ulVoidTime[0]);
	output.WriteResult (TEXT("VoidRC       "), m_ulVoidRCTime[0]);

	output.WriteResult (TEXT("DwordIn      "), m_ulDwordInTime[0]);
	output.WriteResult (TEXT("DwordOut     "), m_ulDwordOutTime[0]);
	output.WriteResult (TEXT("DwordInOut   "), m_ulDwordInOutTime[0]);

	output.WriteResult (TEXT("StringIn     "), m_ulStringInTime[0]);
#ifdef STRINGOUT
	output.WriteResult (TEXT("StringOut    "), m_ulStringOutTime[0]);
#endif
	output.WriteResult (TEXT("StringInOut  "), m_ulStringInOutTime[0]);

	output.WriteResult (TEXT("GuidIn       "), m_ulGuidInTime[0]);
	output.WriteResult (TEXT("GuidOut      "), m_ulGuidOutTime[0]);

    }
    else
    {

	output.WriteString (TEXT("\n"));
	output.WriteResults (TEXT("Void         "), m_ulIterations, m_ulVoidTime);
	output.WriteResults (TEXT("VoidRC       "), m_ulIterations, m_ulVoidRCTime);

	output.WriteResults (TEXT("DwordIn      "), m_ulIterations, m_ulDwordInTime);
	output.WriteResults (TEXT("DwordOut     "), m_ulIterations, m_ulDwordOutTime);
	output.WriteResults (TEXT("DwordInOut   "), m_ulIterations, m_ulDwordInOutTime);

	output.WriteResults (TEXT("StringIn     "), m_ulIterations, m_ulStringInTime);
#ifdef STRINGOUT
	output.WriteResults (TEXT("StringOut    "), m_ulIterations, m_ulStringOutTime);
#endif
	output.WriteResults (TEXT("StringInOut  "), m_ulIterations, m_ulStringInOutTime);

	output.WriteResults (TEXT("GuidIn       "), m_ulIterations, m_ulGuidInTime);
	output.WriteResults (TEXT("GuidOut      "), m_ulIterations, m_ulGuidOutTime);
    }

    return S_OK;
}
	
	



//+-------------------------------------------------------------------------
//
//  Function:	StartServer
//
//  Synopsis:	Start an Rpc server process
//
//  Arguments:	[_fDebug] - start in a debugger or not
//		[_pwszPath] - name of server process
//
//  Returns:	S_OK - Server started
//		S_FALSE - server is already starting
//		CO_E_SERVER_EXEC_FAILURE
//
//  Algorithm:
//
//  History:	21-Apr-93 Ricksa    Created
//		04-Jan-94 Ricksa    Modified for class starting sync.
//
//--------------------------------------------------------------------------
HRESULT StartServer(BOOL _fDebug, LPTSTR _pszPath)
{
    // Where we put the command line
    TCHAR aszTmpCmdLine[MAX_PATH];
    TCHAR *pszTmpCmdLine = aszTmpCmdLine;

    if (_fDebug)
    {
	HKEY  hKey;
	DWORD dwType;
	DWORD cbData = sizeof(aszTmpCmdLine)/sizeof(TCHAR);

	ULONG rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				TEXT("SOFTWARE\\Microsoft\\scm"),
				0,
				KEY_READ,
				&hKey);

	if (rc == ERROR_SUCCESS)
	{
	    //	copy the debugger info into the command line

	    rc = RegQueryValueEx(hKey, TEXT("Debugger"), 0, &dwType,
				(LPBYTE)pszTmpCmdLine, &cbData);

	    if (rc == ERROR_SUCCESS && dwType == REG_SZ)
	    {
		ULONG ulLen = cbData / sizeof(TCHAR);
		pszTmpCmdLine += ulLen;
		aszTmpCmdLine[ulLen-1] = TEXT(' ');	// whitespace
	    }

	    RegCloseKey(hKey);
	}
    }

#ifdef NOTYET	// following code does not compile!
 #ifndef CAIROLE_DOWNLEVEL
    if (acWinFormat[0] == 0)
    {
	TCHAR acWinDir[MAX_PATH];

	UINT cWinDir = GetSystemDirectory(acWinDir, sizeof(acWinDir)/sizeof(TCHAR));

	Win4Assert(cWinDir && "GetWindowsDir failed!");

	wsprintf(acWinFormat, TEXT("%s%s"), acWinDir, TEXT("\\%s %s"));
    }


    // We make all paths relative to the windows directory unless
    // the path is absolute.
    wsprintf(pszTmpCmdLine,
            (_pszPath[1] != TEXT(':')) ? acWinFormat : TEXT("%s %s"),
             _pwszPath,
            TEXT("-Embedding"));
#else
#endif // CAIROLE_DOWNLEVEL

#endif // NOTYET

    // Just use the current path to find the server.
    wsprintf(pszTmpCmdLine, TEXT("%s %s"), _pszPath, TEXT("-Embedding"));

    // Process info for create process
    PROCESS_INFORMATION     procinfo;

    //	build the win32 startup info structure
    STARTUPINFO startupinfo;
    startupinfo.cb = sizeof(STARTUPINFO);
    startupinfo.lpReserved = NULL;
    startupinfo.lpDesktop = NULL;
    startupinfo.lpTitle = _pszPath;
    startupinfo.dwX = 40;
    startupinfo.dwY = 40;
    startupinfo.dwXSize = 80;
    startupinfo.dwYSize = 40;
    startupinfo.dwFlags = 0;
    startupinfo.wShowWindow = SW_SHOWNORMAL;
    startupinfo.cbReserved2 = 0;
    startupinfo.lpReserved2 = NULL;

    if (!CreateProcess( NULL,		// application name
		       aszTmpCmdLine,	// command line
		       NULL,		// process sec attributes
		       NULL,		// thread sec attributes
		       FALSE,		// dont inherit handles
		       CREATE_NEW_CONSOLE,// creation flags
		       NULL,		// use same enviroment block
		       NULL,		// use same directory
		       &startupinfo,	// no startup info
		       &procinfo))	// proc info returned
    {
	return CO_E_SERVER_EXEC_FAILURE;
    }

    CloseHandle(procinfo.hProcess);
    CloseHandle(procinfo.hThread);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	headers.cxx
//
//  Contents:	remote2/new precompiled headers
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <benchmrk.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\bm_clip.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Clip.cxx
//
//  Contents:   Contains the impl of CClipbrdTest which deals with
//              Clipboard related apis.
//
//  Classes:    CClipbrdTest
//
//  Functions:    
//
//  History:    Doesn't work yet.  The code to place data on the clipboard
//              uses autoamation which isn't supported in the server.
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_Clip.hxx"
#include <oleauto.h>


//**********************************************************************
//
// CClipbrd::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CClipbrd. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CClipbrdTest::Name ()
{
    return TEXT("ClipbrdTest");
}



SCODE CClipbrdTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif

    //    initialize timing arrays

#ifndef STRESS

    INIT_RESULTS(m_ulOleGetClipbrd);
    INIT_RESULTS(m_ulOleQueryCreate);
    INIT_RESULTS(m_ulOleQueryLink);

    INIT_RESULTS(m_ulCreateFromClipOutl);
    INIT_RESULTS(m_ulCreateFromClipRenderDrawOutl);
    INIT_RESULTS(m_ulCreateFromClipRenderAsisOutl);

    INIT_RESULTS(m_ulCreateLinkFromClipOutl);
    INIT_RESULTS(m_ulCreateLinkFromClipRenderDrawOutl);

    INIT_RESULTS(m_ulCreateStaticFromClipRenderDrawOutl);
    INIT_RESULTS(m_ulCreateStaticFromClipRenderDrawBMOutl);
#endif //STRESS

    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    assert (hres == NOERROR);

    //Create root Doc and STorage for Doc
    m_lpDoc = CSimpleDoc::Create();
        
    //Create Individual Objects and Init the table
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE CClipbrdTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }

    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CClipbrd::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleSetClipboard     OLE - Is profiled here
//      OleGetClipboard     OLE - Is profiled here
//      OleCreateFromClip   defined below
//
//
// Comments:
//
//********************************************************************


SCODE CClipbrdTest::Run ()
{
    CStopWatch  sw;
    HRESULT     hres;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    //  Get file name of .ini file. if not specified in the command
    //  line, use the default BM.INI in the local directory
    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    //Empty clipboard and get the estimate on empty clipboard
    hres = OleSetClipboard(NULL);
    sw.Reset();
    hres = OleSetClipboard(NULL);
    GetTimerVal(m_ulSetClipEmpty);
        
    fRet = CallOleGetClipbrd(szOutlFileName, m_ulIterations, m_ulOleGetClipbrd,
                        m_ulOleQueryCreate, m_ulOleQueryLink);

    //Now Empty clipboard again. This time Data on clipboard from SvrOutl
    sw.Reset();
    hres = OleSetClipboard(NULL);
    GetTimerVal(m_ulSetClipOutl);


    //
    //Test cases for OleCreateFromData
    //

    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulCreateFromClipOutl, OLECREATE);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulCreateFromClipRenderDrawOutl, OLECREATE);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_ASIS, 
                            NULL, m_ulIterations, m_ulCreateFromClipRenderAsisOutl, OLECREATE);
    
    //
    //Test cases for OleCreateLinkFromData
    //
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulCreateLinkFromClipOutl, OLECREATELINK);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulCreateLinkFromClipRenderDrawOutl, OLECREATELINK);

    //
    //Test cases for OleCreateLinkFromData
    //
    //I would have liked Bitmap but SvrOutl only supports Metafile
    FORMATETC fmte = {CF_ENHMETAFILE, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulCreateStaticFromClipRenderDrawBMOutl, OLECREATESTATIC);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulCreateStaticFromClipRenderDrawOutl, OLECREATESTATIC);
    return S_OK;
}                      



SCODE CClipbrdTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Clipbrd Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleGetClipbrd \t\t\t"), m_ulIterations, m_ulOleGetClipbrd);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSetClipbrd  Empty\t\t"), 1, &m_ulSetClipEmpty);
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSetClipbrd  Data\t\t"), 1, &m_ulSetClipOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateFromClip  Outline \t\t\t"), m_ulIterations, m_ulCreateFromClipOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateFromClip  with RenderDraw Outline\t"), m_ulIterations, m_ulCreateFromClipRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateFromClip  with RenderFormatMF Outline\t "), m_ulIterations, m_ulCreateFromClipRenderFormatMFOutl);
    output.WriteString (TEXT("\n"));


    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateFromClip  with RenderAsIs Outline \t"), m_ulIterations, m_ulCreateFromClipRenderAsisOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateLinkFromClip  Outline \t\t"), m_ulIterations, m_ulCreateLinkFromClipOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLinkFromClip  with RenderDraw Outline \t"), m_ulIterations, m_ulCreateLinkFromClipRenderDrawOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateStaticFromClip  Outline\t"), m_ulIterations, m_ulCreateStaticFromClipRenderDrawOutl);
    output.WriteString (TEXT("\n"));

#if VERIFYSTATICBEHAVIOR

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateStaticFromClip  with RenderDraw Outline \t"), m_ulIterations, m_ulCreateStaticFromClipRenderDrawBMOutl);
    output.WriteString (TEXT("\n"));
#endif


    return S_OK;
}
    
    

//**********************************************************************
//
// OleGetClipboard
//
// Purpose:
//      This routine is called CallOleGetClipboard but it also instruments
//      OLeQueryXX apis! (This was the best place to do that otherwise what 
//      to do with Clipboard data).
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker   OLE - creates file moniker
//      CreateBindCtx       OLE 
//      IDispatch::GetIDsOfNames Dispatch routine which makes call into SvrOutl (yet another version!)
//      OleGetClipboard     OLE - Is profiled here
//      OleQueryCreateFromData     OLE - Is profiled here
//      OleLinkFromData     OLE - Is profiled here
//
//
// Comments:
//
//********************************************************************



BOOL CallOleGetClipbrd(LPCOLESTR lpFileName, ULONG ulIterations, ULONG uOleClipbrdtime[], 
                       ULONG uOleQCreatetime[], ULONG uOleQLinktime[])
{
        CStopWatch  sw;
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        LPDATAOBJECT pDO = NULL;
        LPMONIKER   pmk = NULL;
        LPBC        pbc = NULL;
        IDispatch FAR* pDisp = NULL;

        hres = CreateFileMoniker(lpFileName, &pmk);

        if (hres != NOERROR)
                goto error;
        else {
                
            
            //Bind to moniker object and ask for IID_IDispatch
            hres = CreateBindCtx(NULL, &pbc);
            if (hres != NOERROR)
                goto error;

            hres = pmk->BindToObject(pbc, NULL, IID_IDispatch, (LPVOID FAR*) &pDisp);
            if (hres != NOERROR)
                goto error;


            //Now Make outline copy object to clipboard
            OLECHAR FAR* pCopy = L"COPY";
            DISPID   dispid;
            EXCEPINFO expinfo;
            DISPPARAMS vNullDisp = {NULL, 0, 0, NULL};   

            hres = pDisp->GetIDsOfNames(
                            IID_NULL,
                            &pCopy,
                            1, LOCALE_USER_DEFAULT,
                            &dispid);                

            if (hres == NOERROR) {
                //Invoke Method Copy so that SvrOutl copies data to clipboard
                hres = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
                     &vNullDisp, NULL, &expinfo, NULL);
                if (hres != NOERROR)
                     goto error;
                }

            pDisp->Release();
            pDisp = NULL; 
        }
        
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            sw.Reset();
            //Get the Clipboard data
            hres = OleGetClipboard(&pDO);
            GetTimerVal(uOleClipbrdtime[iIter]);

            LOGRESULTS (TEXT("OleGetClipboard "), hres);
            if (hres != NOERROR)
                {
                goto error;
                }
                
            //Now call QueryCreate and QueryLinkFromCLip Apis

            sw.Reset();
            hres = OleQueryCreateFromData(pDO);
            GetTimerVal(uOleQCreatetime[iIter]);
            LOGRESULTS (TEXT("OleQueryCreateFromData "), hres);

            sw.Reset();
            hres = OleQueryLinkFromData(pDO);
            GetTimerVal(uOleQLinktime[iIter]);
            LOGRESULTS (TEXT("OleQueryCreateLinkFromData "), hres);

            
            if (pDO) {
                pDO->Release();
                pDO = NULL;
            }
        }


        retVal = TRUE;

error:
        if (hres != NOERROR)
            Log (TEXT("Routine OleGetClipbrd failed with hres = "), hres);

        if (pmk)
                pmk->Release();
        if (pDO)
                pDO->Release();
        if (pbc)
                pbc->Release();
        if (pDisp)
                pDisp->Release();

return retVal;
}




//**********************************************************************
//
// CallCreateFromClip
//
// Purpose:
//      This routine creates the OLE object from Clipboard data. It creates 
//      both embedded and linked object.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker       OLE - creates file moniker
//      CreateBindCtx           OLE 
//      IDispatch::GetIDsOfNames Dispatch routine which makes call into SvrOutl (yet another version!)
//      IDispatch::Invoke       Dispatch routine asking Svroutl to copy to clipboard
//      OleGetClipboard         OLE - called to get Data object on Clip
//      OleCreateFromData       OLE - Is profiled here
//      OleCreateLinkFromData   OLE - Is profiled here
//      OleCreateStaticFromData    OLE - Is profiled here
//
//
// Comments:
//
//********************************************************************

BOOL CallCreateFromClip(LPCOLESTR lpFileName, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, ULONG uOleClipbrdtime[], CREATE_METHOD MethodID)
{
        CStopWatch  sw;
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        LPDATAOBJECT pDO = NULL;
        LPMONIKER   pmk = NULL;
        LPBC        pbc = NULL;
        IDispatch FAR* pDisp = NULL;

        hres = CreateFileMoniker(lpFileName, &pmk);

        if (hres != NOERROR)
                goto error;
        else {
                
            
            //Bind to moniker object and ask for IID_IDispatch
            hres = CreateBindCtx(NULL, &pbc);
            if (hres != NOERROR)
                goto error;

            hres = pmk->BindToObject(pbc, NULL, IID_IDispatch, (LPVOID FAR*)&pDisp);
            if (hres != NOERROR)
                goto error;


            //Now Make outline copy object to clipboard
            OLECHAR FAR* pCopy = L"COPY";
            DISPID   dispid;
            EXCEPINFO expinfo;
            DISPPARAMS vNullDisp = {NULL, 0, 0, NULL};   


            hres = pDisp->GetIDsOfNames(
                            IID_NULL,
                                &pCopy,
                            1, LOCALE_USER_DEFAULT,
                                &dispid);                
            if (hres == NOERROR) {
                hres = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
                     &vNullDisp, NULL, &expinfo, NULL);
                if (hres != NOERROR)
                     goto error;
                }

            pDisp->Release();
            pDisp = NULL;
        }
        //Get the Clipboard data
        hres = OleGetClipboard(&pDO);
        if (hres != NOERROR)
                goto error;

        
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            HEAPVALIDATE() ;
            switch(MethodID) {
                case OLECREATE:
                    {
            
                    sw.Reset();
                    hres = OleCreateFromData(pDO, riid, renderopt, 
                                    pFormatEtc, &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                    break;
                    }
    
                case OLECREATELINK:
                    {
            
                    sw.Reset();
                    hres = OleCreateLinkFromData(pDO, riid, renderopt, 
                                    pFormatEtc, &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                    break;
                    }
    
                case OLECREATESTATIC:
                    {
            
                    sw.Reset();
                    hres = OleCreateStaticFromData(pDO, riid, renderopt, 
                                    pFormatEtc, &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                    break;
                    }
                default:
                    assert(FALSE);
                }
            GetTimerVal(uOleClipbrdtime[iIter]);

            LOGRESULTS (TEXT("OleCreate/Link/Static "), hres);
            if (hres != NOERROR)
                {
                goto error;
                }
            
        }


    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }
        retVal = TRUE;

error:
        if (hres != NOERROR)
            Log (TEXT("Routine CallCreateFromClip failed with hres = "), hres);

        if (pmk)
                pmk->Release();
        if (pDO)
                pDO->Release();
        if (pbc)
                pbc->Release();
        if (pDisp)
                pDisp->Release();
return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\bm_cache.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Cache.cxx
//
//  Contents:    Contains the impl of COleCacheTest which deals with Clipboard related
//              apis.
//
//  Classes:    COleCacheTest
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_cache.hxx"
#include <oleauto.h>


//**********************************************************************
//
// CCacheTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CCacheTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *COleCacheTest::Name ()
{
    return TEXT("CacheTest");
}


SCODE COleCacheTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif

    //    initialize timing arrays
#ifndef STRESS

    //INIT_RESULTS(m_CacheTimesOutl.ulCreateCache);
    for (int xx = 0; xx < TEST_MAX_ITERATIONS; xx++)
        {
        m_CacheTimesOutl[xx].ulCreateCache   = NOTAVAIL;
        m_CacheTimesOutl[xx].ulCache         = NOTAVAIL;
        m_CacheTimesOutl[xx].ulInitCache     = NOTAVAIL;
        m_CacheTimesOutl[xx].ulLoadCache     = NOTAVAIL;
        m_CacheTimesOutl[xx].ulSaveCache     = NOTAVAIL;
        m_CacheTimesOutl[xx].ulUncache       = NOTAVAIL;
        m_CacheTimesOutl[xx].ulUpdateCache   = NOTAVAIL;
        m_CacheTimesOutl[xx].ulDiscardCache  = NOTAVAIL;
        }

#endif


    sc = OleInitialize(NULL);
    if (FAILED(sc))
        {
        Log (TEXT("Setup - OleInitialize failed."), sc);
        return    sc;
        }

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    assert (hres == NOERROR);

    //Create root Doc and STorage for Doc
    m_lpDoc = CSimpleDoc::Create();
        
    //Create Individual Objects and Init the table
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // Create an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE COleCacheTest::Cleanup ()
{


    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
        {
        delete m_pSite[iIter]; 
        }

    OleUninitialize();
    return S_OK;
}


SCODE COleCacheTest::Run ()
{
    BOOL fRet;

    fRet = CallRunCache(m_clsidOutl, m_pSite, m_pOleCache2, m_ulIterations, m_CacheTimesOutl);
    return S_OK;
}                      



SCODE COleCacheTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Cache Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));
    output.WriteString (TEXT("\n"));
    WriteCacheOutput(output, TEXT("Outline"), m_CacheTimesOutl, m_ulIterations);
    output.WriteString (TEXT("\n"));


    return S_OK;
}
    
//**********************************************************************
//
// CallRunCache
//
// Purpose:
//          Creates an embedded object and calls routines to create cache
//          Initialize them and then Save and load them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate               OLE2 api 
//      CreateCacheObjects      Create Cache objects
//      FillCache               To fill  up the caches with pDO
//      SaveAndLoadCache        Get the estimates for Save and Load Cache
//
//
// Comments:
//          
//
//********************************************************************


BOOL CallRunCache(REFCLSID rclsid, CSimpleSite *pSite[], LPOLECACHE2 pOleCache2[], 
                ULONG ulIterations, CacheTimes Cachetimes[])
{
        HRESULT         hres;
        ULONG           iIter;
        BOOL            retVal = FALSE;
        LPDATAOBJECT    pDO = NULL;

        CSimpleSite*    pTempSite = CSimpleSite::Create(pSite[0]->m_lpDoc, -1); //Some temporary name
        if (!pTempSite)
            goto error;

        //If we have not had any problem then 
        HEAPVALIDATE() ;
        hres = OleCreate(rclsid,  IID_IOleObject, OLERENDER_DRAW, NULL, 
                         &pTempSite->m_OleClientSite, pTempSite->m_lpObjStorage, 
                         (VOID FAR* FAR*)&pTempSite->m_lpOleObject);

        LOGRESULTS (TEXT("OleCreate "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        hres = pTempSite->m_lpOleObject->QueryInterface(IID_IDataObject, (LPVOID FAR*)&pDO);
        if (hres != NOERROR)
            goto error;
        

        //Now call Appropriate routines to Save and Cache the objects
        hres = CreateCacheObjects( pSite, pOleCache2, ulIterations, Cachetimes);
        if (hres != NOERROR)
            goto error; //there is no point in going if we had problem with creation
        FillCache(pDO, pOleCache2, ulIterations, Cachetimes);
        SaveAndLoadCache(pSite, pOleCache2, ulIterations, Cachetimes);

        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallRunCache failed with hres = "), hres);

    if (pDO)
        pDO->Release();
    if (pTempSite)
        {
        pTempSite->UnloadOleObject();
        delete pTempSite;
        }

    for (iIter=0; iIter < ulIterations; iIter++)
        {
        if (pOleCache2[iIter])
            {
            pOleCache2[iIter]->Release();
            pOleCache2[iIter] = NULL;
            }
        }

return retVal;
}

//**********************************************************************
//
// CreateCacheObjects
//
// Purpose:
//      Creates Cache objects and then initlaize them.
//      
//      
//      
//
// Parameters:
//
//      
// Return Value:
//
//      HRESULT that came from IPS->InitNew
//
// Functions called:
//      CreateDataCache        OLE2 api 
//
//
// Comments:
//          
//
//********************************************************************


HRESULT CreateCacheObjects(CSimpleSite *pSite[], LPOLECACHE2 pOleCache2[], 
                        ULONG ulIterations, CacheTimes Cachetimes[]) 

{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    BOOL        retVal = FALSE;

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = CreateDataCache(NULL, CLSID_NULL, IID_IOleCache2, (LPVOID FAR*)&pOleCache2[iIter]);
        GetTimerVal(Cachetimes[iIter].ulCreateCache);

        LOGRESULTS (TEXT("CreateDataCache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        //
        //Initlaize the cache for use later
        //
        LPPERSISTSTORAGE lpStg = NULL;
        hres = pOleCache2[iIter]->QueryInterface(IID_IPersistStorage, (LPVOID FAR*) &lpStg);
        if (hres == NOERROR)
            {
            hres = lpStg->InitNew(pSite[iIter]->m_lpObjStorage);
            lpStg->Release();
            }
        }
error:
    
    if (hres != NOERROR)
        Log (TEXT("Routine CreateCacheObject failed with hres = "), hres);
    return hres;
}
    

VOID FillCache(LPDATAOBJECT pDO, LPOLECACHE2 pOleCache2[], ULONG ulIterations, 
                       CacheTimes Cachetimes[])

{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    BOOL        retVal = FALSE;

    //Initalize the cache
    //NOTE: What I am doing below is trying to Init the cache with format that
    //I think are very basic and common. So that we can profile the rest of the
    //Cache methods with these options
    //
    //Work On: Create more Cache nodes!!!
    //
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        FORMATETC fmte;
        DWORD     dwConnection = 0L;

        fmte.cfFormat = CF_METAFILEPICT;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.ptd      = NULL; 
        fmte.tymed    = TYMED_MFPICT;
        fmte.lindex   = -1;

        sw.Reset();
        hres = pOleCache2[iIter]->Cache(&fmte, ADVF_PRIMEFIRST | ADVFCACHE_ONSAVE | ADVF_DATAONSTOP, 
                &dwConnection);
        GetTimerVal(Cachetimes[iIter].ulCache);

        LOGRESULTS (TEXT("IOleCache:Cache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }

        }

    //Fill the Cache from Data object provided
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = pOleCache2[iIter]->InitCache(pDO);
        GetTimerVal(Cachetimes[iIter].ulInitCache);

        LOGRESULTS (TEXT("IOleCache:InitCache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

error:
    
    if (hres != NOERROR)
        Log (TEXT("Routine FillCache failed with hres = "), hres);
}

VOID SaveAndLoadCache(CSimpleSite *pSite[], LPOLECACHE2 pOleCache2[], 
                ULONG ulIterations, CacheTimes Cachetimes[])
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;

    // Save the Cache, i.e. save the formats Cached
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        LPPERSISTSTORAGE lpStg = NULL;

        hres = pOleCache2[iIter]->QueryInterface(IID_IPersistStorage, (LPVOID FAR*)&lpStg);
        if (hres != NOERROR)
            continue; //TRy next Cache, it is unexpected condition though

        sw.Reset();
        hres = lpStg->Save(pSite[iIter]->m_lpObjStorage, TRUE);
        hres = lpStg->SaveCompleted(NULL);

        GetTimerVal(Cachetimes[iIter].ulSaveCache);
        if (lpStg)
            lpStg->Release();
        LOGRESULTS (TEXT("Cache- Save and SaveCompleted "), hres);
        }

    //
    //To test IOC:Load we need to destroy old cache nodes, create new
    //ones and ask them to laod themselves
    //
    for (iIter=0; iIter < ulIterations; iIter++)
        {
        if (pOleCache2[iIter])
            {
            pOleCache2[iIter]->Release();
            pOleCache2[iIter] = NULL;
            }
        }

    //Create new set of Cache
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = CreateDataCache(NULL, CLSID_NULL, IID_IOleCache2, (LPVOID FAR*)&pOleCache2[iIter]);
        GetTimerVal(Cachetimes[iIter].ulCreateCache);

        LOGRESULTS (TEXT("CreateDataCache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

    //Load the Cache from the storage provided
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        LPPERSISTSTORAGE lpStg = NULL;

        //Query for IPS to load the object
        hres = pOleCache2[iIter]->QueryInterface(IID_IPersistStorage, (LPVOID FAR*) &lpStg);
        if (hres != NOERROR)
            continue; //Try next Cache

        sw.Reset();
        hres = lpStg->Load(pSite[iIter]->m_lpObjStorage);
        GetTimerVal(Cachetimes[iIter].ulLoadCache);

        if (lpStg)
            lpStg->Release();
        LOGRESULTS (TEXT("Cache- Load "), hres);
        } //End For

error:

    if (hres != NOERROR)
        Log (TEXT("Routine SaveAndLoadCache failed with hres = "), hres);

}

void WriteCacheOutput(CTestOutput &output, LPTSTR lpstr, CacheTimes *CTimes, ULONG ulIterations)
{
    UINT iIter;

    output.WriteString (TEXT("Name"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("Create"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("IOC:Cache"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("IOC:InitCache"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("LoadCache"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("SaveCache"));
    output.WriteString (TEXT("\n"));

    for (iIter = 0; iIter < ulIterations; iIter++)
        {
        output.WriteString (lpstr);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulCreateCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulInitCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulLoadCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulSaveCache);
        output.WriteString (TEXT("\n"));
        }

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\bm_crtl.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_crtl.cxx
//
//  Contents:    CreateLink apis
//
//  Classes:    CCreateLinkApi
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_crtl.hxx"


//**********************************************************************
//
// CCreateLinkTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CCreateLinkTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CCreateLinkTest::Name ()
{
    return TEXT("CreateLinkTest");
}



SCODE CCreateLinkTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif
    
#ifndef STRESS
    //    initialize timing arrays
    INIT_RESULTS(m_ulOleCreateLinkSr32);
    INIT_RESULTS(m_ulOleCreateLinkOutl);
    INIT_RESULTS(m_ulOleCreateLinkRenderDrawSr32);
    INIT_RESULTS(m_ulOleCreateLinkRenderDrawOutl);

#endif

    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(L"Sr32test", &m_clsidSr32);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //CreateLink Doc and Root Storage
    m_lpDoc = CSimpleDoc::Create();
        
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
        {
        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE CCreateLinkTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }

    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CCreateLinkTest::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      The profile is done by creating moniker then calling OleCreateLink  on moniker.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CallOleCreateLink       defined below
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



SCODE CCreateLinkTest::Run ()
{
    CStopWatch  sw;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szSr2FileName[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    //  Get file name of .ini file. if not specified in the command
    //  line, use the default BM.INI in the local directory

    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szSr2FileName,
#ifdef UNICODE
                L"%s\\foo.sr2",
#else
                L"%S\\foo.sr2",
#endif
                szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, NULL, 
                            NULL, m_ulIterations, m_ulOleCreateLinkSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, NULL, 
                            NULL, m_ulIterations, m_ulOleCreateLinkOutl);

    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateLinkRenderDrawSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateLinkRenderDrawOutl);

    //Create the objects with RenderFormat = Metafile
    FORMATETC fmte = {CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT};
    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatMFSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatMFOutl);

    //Create the objects with RenderFormat = Bitmap
    fmte.cfFormat = CF_BITMAP;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.tymed    = TYMED_GDI;
    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatBMSr32);

    //Create the objects with RenderFormat = Text
    fmte.cfFormat = CF_TEXT;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.tymed    = TYMED_HGLOBAL;
    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatTextSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatTextOutl);


    return S_OK;
}                      



SCODE CCreateLinkTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("CreateLink Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink  Sr32test\t\t\t"), m_ulIterations, m_ulOleCreateLinkSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink  Outline \t\t\t"), m_ulIterations, m_ulOleCreateLinkOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderDraw Sr32test\t"), m_ulIterations, m_ulOleCreateLinkRenderDrawSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderDraw Outline\t"), m_ulIterations, m_ulOleCreateLinkRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatMF Sr32test\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatMFSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatMF Outline\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatMFOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatBM Sr32test\t "), m_ulIterations, m_ulOleCreateLinkRenderFormatBMSr32);
    output.WriteString (TEXT("\n"));

#ifdef DOESNOTWORKFOROUTLINE
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatBM Outline\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatBMOutl);
    output.WriteString (TEXT("\n"));
#endif

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatTxt Sr32test\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatTextSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink  with RenderFormatTxt Outline\t "), m_ulIterations, m_ulOleCreateLinkRenderFormatTextOutl);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
    
    


//**********************************************************************
//
// CallOleCreateLink
//
// Purpose:
//      Calls OleCreateLink to create the link and then destroys them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker      OLE2 api 
//      OleCreateLink          OLE2 api - Is profiled here
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



BOOL CallOleCreateLink(LPCOLESTR lpFileName, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, ULONG uOleCreateLinktime[])
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    LPMONIKER   pmk = NULL;
    BOOL        retVal = FALSE;

    hres = CreateFileMoniker(lpFileName, &pmk);
    if (hres != NOERROR)
            goto error;

    for ( iIter=0; iIter<ulIterations; iIter++)
        {
        HEAPVALIDATE() ;
        sw.Reset();
        hres = OleCreateLink(pmk, riid, renderopt, pFormatEtc, &pSite[iIter]->m_OleClientSite,
                            pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
        GetTimerVal(uOleCreateLinktime[iIter]);

        LOGRESULTS (TEXT("OleCreateLink "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

    //CleanUp before going to Next
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }
    retVal = TRUE;

error:
    if (hres != NOERROR)
        Log (TEXT("Routine CallOleCreateLink failed with hres = "), hres);

    if (pmk)
        pmk->Release();
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\bm_load.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Load.cxx
//
//  Contents:    Contains the impl of COleLoadTest which deals with Clipboard related
//              apis.
//
//  Classes:    COleLoadTest
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_Load.hxx"
#include <oleauto.h>


//**********************************************************************
//
// CLoadTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CLoadTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *COleLoadTest::Name ()
{
    return TEXT("LoadTest");
}


SCODE COleLoadTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif

    //    initialize timing arrays
#ifndef STRESS

    INIT_RESULTS(m_ulEmbedLoadOutl);
    INIT_RESULTS(m_ulEmbedSaveOutl);

    INIT_RESULTS(m_ulEmbedLoadRenderDrawOutl);
    INIT_RESULTS(m_ulEmbedSaveRenderDrawOutl);

    INIT_RESULTS(m_ulEmbedLoadRenderAsisOutl);
    INIT_RESULTS(m_ulEmbedSaveRenderAsisOutl);

    INIT_RESULTS(m_ulLinkLoadOutl);
    INIT_RESULTS(m_ulLinkAndSaveOutl);

    INIT_RESULTS(m_ulLinkLoadRenderDrawOutl);
    INIT_RESULTS(m_ulLinkAndSaveRenderDrawOutl);

    INIT_RESULTS(m_ulStaticAndLoadRenderDrawOutl);
    INIT_RESULTS(m_ulStaticAndSaveRenderDrawOutl);

    INIT_RESULTS(m_ulStaticAndLoadRenderBMOutl);
    INIT_RESULTS(m_ulStaticAndSaveRenderBMOutl);
#endif


    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //Create root Doc and STorage for Doc
    m_lpDoc = CSimpleDoc::Create();
        
    //Create Individual Objects and Init the table
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE COleLoadTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }


    OleUninitialize();
    return S_OK;
}


SCODE COleLoadTest::Run ()
{
    CStopWatch  sw;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    //  Get file name of .ini file. if not specified in the command
    //  line, use the default BM.INI in the local directory
    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    //
    //Test cases for OleSave and OleLoad on Embedding
    //

    fRet = CallCreateLoadAndSave(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulEmbedLoadOutl, m_ulEmbedSaveOutl );

    fRet = CallCreateLoadAndSave(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulEmbedLoadRenderDrawOutl, m_ulEmbedSaveRenderDrawOutl);

    fRet = CallCreateLoadAndSave(m_clsidOutl,  m_pSite, IID_IOleObject, OLERENDER_ASIS, 
                            NULL, m_ulIterations, m_ulEmbedLoadRenderAsisOutl, m_ulEmbedSaveRenderAsisOutl );
    
    FORMATETC fmte = {CF_BITMAP, NULL, DVASPECT_CONTENT, -1, TYMED_GDI};
    fRet = CallCreateLoadAndSave(m_clsidOutl,  m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulEmbedLoadRenderBMOutl, m_ulEmbedSaveRenderBMOutl );
    //
    //Test cases for OleSave and OleLoad on Links
    //
    fRet = CallLinkLoadAndSave(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulLinkLoadOutl, m_ulLinkAndSaveOutl);
    fRet = CallLinkLoadAndSave(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulLinkLoadRenderDrawOutl, m_ulLinkAndSaveRenderDrawOutl);

    //
    //Test cases for OleSave and OleLoad on Static objects
    //
    fRet = CallStaticLoadAndSave(m_clsidOutl, m_lpDoc, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulStaticAndLoadRenderDrawOutl, m_ulLinkAndSaveRenderDrawOutl);
    //fRet = CallStaticLoadAndSave(m_clsidOutl, m_lpDoc, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
    //                        &fmte, m_ulIterations, m_ulStaticAndLoadRenderBMOutl, m_ulStaticAndSaveRenderBMOutl);
    return S_OK;
}                      



SCODE COleLoadTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Load Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Embedding \t\t  "), m_ulIterations, m_ulEmbedLoadOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave  Embedding  \t\t"), m_ulIterations, m_ulEmbedSaveOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Embedding with RenderDraw \t"), m_ulIterations, m_ulEmbedLoadRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Embedding with RenderDraw \t"), m_ulIterations, m_ulEmbedSaveRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Embedding with RenderFormatBM Outline \t"), m_ulIterations, m_ulEmbedLoadRenderBMOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave  with RenderFormatBM \t\t "), m_ulIterations, m_ulEmbedLoadRenderBMOutl);
    output.WriteString (TEXT("\n"));


    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad  Embedding with RenderAsIs \t "), m_ulIterations, m_ulEmbedLoadRenderAsisOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Embedding with RenderAsIs   \t"), m_ulIterations, m_ulEmbedLoadRenderAsisOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleLoad Link  Outline   \t\t  "), m_ulIterations, m_ulLinkLoadOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Link  Outline    \t\t "), m_ulIterations, m_ulLinkAndSaveOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Link with RenderDraw \t\t"), m_ulIterations, m_ulLinkLoadRenderDrawOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Link with RenderDraw Outline  \t"), m_ulIterations, m_ulLinkAndSaveRenderDrawOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateStaticAndLoad  Outline   \t  "), m_ulIterations, m_ulStaticAndLoadRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateStaticAndLoad  with RenderDraw Outline \t"), m_ulIterations, m_ulStaticAndLoadRenderBMOutl);
    output.WriteString (TEXT("\n"));


    return S_OK;
}
    
//**********************************************************************
//
// CallCreateLoadAndSave
//
// Purpose:
//      Calls OleCreate to create the object and then 
//      call OleLoad and OleSave to get the performance results on them.        
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate               OLE2 api 
//      LoadAndSave             routine defined in this file
//
//
// Comments:
//          
//
//********************************************************************


BOOL CallCreateLoadAndSave(REFCLSID rclsid, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        //Create the objects 
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            HEAPVALIDATE() ;
            hres = OleCreate(rclsid, riid, renderopt, pFormatEtc, 
                             &pSite[iIter]->m_OleClientSite,
                             pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

            if (hres != NOERROR)
                goto error;
            
            }

        //Now call Appropriate routines to Save and Load the objects
        LoadAndSave( pSite, ulIterations, uOleLoadtime, uOleSavetime);
                
        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallCreateLoadAndSave failed with hres = "), hres);

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

return retVal;
}

BOOL CallLinkLoadAndSave(LPCOLESTR lpFileName, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        //Create the objects 
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            HEAPVALIDATE() ;
            hres = OleCreateLinkToFile(lpFileName, riid, renderopt, pFormatEtc, 
                             &pSite[iIter]->m_OleClientSite,
                             pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

            if (hres != NOERROR)
                goto error;
            
            }

        //Now call Appropriate routines to Save and Load the objects
        LoadAndSave( pSite, ulIterations, uOleLoadtime, uOleSavetime);
                
        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallCreateLoadAndSave failed with hres = "), hres);

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

return retVal;
}

//**********************************************************************
//
// LoadAndSave
//
// Purpose:
//      Calls OleLoad and OleSave on the object and timing results.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleLoad               OLE2 api 
//      OleSave               OLE2 api
//
//
// Comments:
//          
//
//********************************************************************

BOOL LoadAndSave(CSimpleSite * pSite[], ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
    LPPERSISTSTORAGE pStg = NULL;
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    BOOL        retVal = FALSE;

    //Save the objects
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        hres = pSite[iIter]->m_lpOleObject->QueryInterface(IID_IPersistStorage, 
                                                        (LPVOID FAR*)&pStg);
        if (hres != NOERROR)
            goto error;

        sw.Reset();
        hres = OleSave(pStg, pSite[iIter]->m_lpObjStorage, TRUE);
        GetTimerVal(uOleSavetime[iIter]);

        LOGRESULTS (TEXT("OleSave "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        pStg->Release();
        pStg = NULL;

        }


    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

    //Load the objects
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = OleLoad( pSite[iIter]->m_lpObjStorage, IID_IOleObject, 
                       &pSite[iIter]->m_OleClientSite, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

        GetTimerVal(uOleLoadtime[iIter]);
        LOGRESULTS (TEXT("OleLoad "), hres);
        }


    retVal = TRUE;

error:
    if (hres != NOERROR)
        Log (TEXT("Routine LoadAndSave failed with hres = "), hres);
    if (pStg)
        pStg->Release();

return retVal;
}


//**********************************************************************
//
// CallStaticLoadAndSave
//
// Purpose:
//      Calls OleCreateStaticFromDara to create the object and then 
//      call OleLoad and OleSave to get the performance results on them.        
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate               OLE2 api 
//      OleCreateStaticFromData OLE2 api 
//      LoadAndSave             routine defined in this file
//
//
// Comments:
//          In this case we call OleCreateStaticFromData from data object
//          given by application.
//
//********************************************************************



BOOL CallStaticLoadAndSave(REFCLSID rclsid, CSimpleDoc FAR * m_lpDoc, CSimpleSite * pSite[], 
                REFIID riid, DWORD renderopt, LPFORMATETC pFormatEtc, ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;
        LPDATAOBJECT pDO = NULL;
        CSimpleSite* pTempSite = CSimpleSite::Create(m_lpDoc, -1); //-1 is unique in this case

        //Create the ole object and ask for IID_IDataObject interface
        hres = OleCreate(rclsid, IID_IOleObject, renderopt, pFormatEtc, 
                         &pTempSite->m_OleClientSite,
                         pTempSite->m_lpObjStorage, (VOID FAR* FAR*)&pTempSite->m_lpOleObject);

        if (hres != NOERROR)
            goto error;
        hres = pTempSite->m_lpOleObject->QueryInterface(IID_IDataObject, (LPVOID FAR*)&pDO);
        if (hres != NOERROR)
            goto error;

        //Create the static objects from pDO 
        for ( iIter=0; iIter<ulIterations; iIter++) {
            hres = OleCreateStaticFromData(pDO, riid, renderopt, pFormatEtc,
                                    &pSite[iIter]->m_OleClientSite, pSite[iIter]->m_lpObjStorage, 
                                    (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                                            
            if (hres != NOERROR)
                goto error;

            HEAPVALIDATE() ;
            }

        //Now call Appropriate routines to Save and Load the objects
        LoadAndSave( pSite, ulIterations, uOleLoadtime, uOleSavetime);
                
        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallCreateLoadAndSave failed with hres = "), hres);

    if (pDO)
        pDO->Release();

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

    if (pTempSite) //this should also release the object
        {
        pTempSite->UnloadOleObject();
        //delete pTempSite;
        }

return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\bm_link.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:        bm_Link.cxx
//
//  Contents:    Profile methods which manipulate Links, i.e. interface IOleLink
//
//  Classes:    CIOLTest
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_link.hxx"


//**********************************************************************
//
// CIOLTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CIOLTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CIOLTest::Name ()
{
    return TEXT("IOLTest");
}



SCODE CIOLTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif
    
#ifndef STRESS 
    //    initialize timing arrays
    INIT_LINKRESULTS(m_ulOleLinkSr32);
    INIT_LINKRESULTS(m_ulOleLinkOutl);

#endif

    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(L"Sr32test", &m_clsidSr32);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //CreateLink Doc and Root Storage
    m_lpDoc = CSimpleDoc::Create();
        
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
        {
        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE CIOLTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }


    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CIOLTest::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      The profile is done by creating moniker then calling OleCreateLink  on moniker.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CallOleCreate       defined below
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



SCODE CIOLTest::Run ()
{
    CStopWatch  sw;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szSr2FileName[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szSr2FileName,
#ifdef UNICODE
                L"%s\\foo.sr2",
#else
                L"%S\\foo.sr2",
#endif
                szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    fRet = CallOleLinkMethods(szSr2FileName, m_pSite, m_ulIterations, 
                                m_ulOleLinkSr32, L"OTS001", L"OTS002");
    fRet = CallOleLinkMethods(szOutlFileName, m_pSite, m_ulIterations, 
                                m_ulOleLinkOutl, L"Name1", L"Name2");

    return S_OK;
}                      



SCODE CIOLTest::Report (CTestOutput &output)
{

//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("IOleLink Methods"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    WriteLinkOutput(output, TEXT(" Sr32test "), m_ulOleLinkSr32, m_ulIterations);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("******************************************\n"));
    WriteLinkOutput (output, TEXT(" Outline "), m_ulOleLinkOutl, m_ulIterations);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
    
    


//**********************************************************************
//
// CallOleCreateLink
//
// Purpose:
//      Calls OleCreateLink to create the link and then destroys them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker      OLE2 api 
//      OleCreateLink          OLE2 api - Is profiled here
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



BOOL CallOleLinkMethods(LPCOLESTR lpFileName, CSimpleSite * pSite[], 
        ULONG ulIterations, LinkTimes IOLTime[],  LPCOLESTR lpNm1, LPCOLESTR lpNm2)
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    LPMONIKER   pmk = NULL;
    BOOL        retVal = FALSE;
#ifdef STRESS
    LPOLELINK   pLink[STRESSCOUNT] = { NULL };
#else
    LPOLELINK   pLink[TEST_MAX_ITERATIONS] = { NULL };
#endif

    //
    //Create the Links and also cache link pointer for rest of the tests
    //this pointer is reqd for all the tests later
    //
    for ( iIter=0; iIter<ulIterations; iIter++)
        {
        HEAPVALIDATE() ;
        if (!pSite[iIter])
            goto error;
        hres = OleCreateLinkToFile(lpFileName,
                                    IID_IOleObject,
                                    OLERENDER_DRAW,
                                    NULL,
                                    &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage,
                                    (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject
                                    );
        if (hres != NOERROR)
            goto error;

        //Cache IOleLink pointer for rest of the tests that follow below
        hres = pSite[iIter]->m_lpOleObject->QueryInterface(IID_IOleLink, (LPVOID FAR*)&pLink[iIter]);
        if (hres != NOERROR)
            goto error;
        }

    //
    //Run those tests which deal with simple running
    //
    CallOleLinkRunMethods(IOLTime, pLink, ulIterations);

    //
    //Call those tests that deal with SourceDisplayName
    //
    CallOleLinkDisplayName(IOLTime, pLink, lpFileName,
                            lpNm1, lpNm2, ulIterations);


    retVal = TRUE;
error:
    if (hres != NOERROR)
        Log (TEXT("Routine CallOleCreateLink failed with hres = "), hres);

    //CleanUp before going to Next
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        if (pLink[iIter])
            pLink[iIter]->Release();
        if (pSite[iIter])
            pSite[iIter]->UnloadOleObject();
        }

    return retVal;
}



BOOL CallOleLinkRunMethods(LinkTimes IOLTime[], LPOLELINK pLink[], ULONG ulIterations)
{
    HRESULT     hres;
    CStopWatch  sw;
    ULONG       iIter;
    BOOL        retVal = FALSE;
    LPBINDCTX   pBindCtx = NULL;

    //
    //1. get the first estimates using NULL BindCtx
    //
    for ( iIter=0; iIter< ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindToSource(NULL /* !BIND_EVEN_IF_CLASSDIF */,
                                   NULL /*Bind Ctx*/);
        GetTimerVal(IOLTime[iIter].ulBindToSourceNull);
        LOGRESULTS (TEXT("IOL:BindToSource "), hres);
        } //End Bind To Source with Null BindCtx

    //Unbind links to start next estimates. Which also BindToSource with Non 
    //NULL BindCtx
    for ( iIter=0; iIter< ulIterations; iIter++)
        {
        hres = pLink[iIter]->UnbindSource();
        } 

    //
    //2. Following tests are to be done with BindContext that we get here
    //
    hres = CreateBindCtx(NULL, &pBindCtx);
    if (hres != NOERROR)
        goto error;
    //Now get the Estimates when Binding with same BindContext
    //
    for ( iIter=0; iIter< ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindToSource(NULL /* !BIND_EVEN_IF_CLASSDIF */,
                                   pBindCtx /*Bind Ctx*/);
        GetTimerVal(IOLTime[iIter].ulBindToSourceBindCtx);
        LOGRESULTS (TEXT("IOL:BindToSource  "), hres);
        } //End Bind To Source with BindCtx


    //
    //3. Get Estimates for IOL:BindIfRunning
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindIfRunning();
        GetTimerVal(IOLTime[iIter].ulBindIfRunning);
        LOGRESULTS (TEXT("IOL:BindIfRunning "), hres);
        } //End BindIfRunning, when actually running.


    //
    //4. Get Estimates for IOL:UnbindSource    
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->UnbindSource();
        GetTimerVal(IOLTime[iIter].ulUnbindSource);
        LOGRESULTS (TEXT("IOL:UnbindSource "), hres);
        sw.Reset();
        hres = pLink[iIter]->UnbindSource();
        GetTimerVal(IOLTime[iIter].ulUnbindSource2);
        LOGRESULTS (TEXT("IOL:UnbindSource2 "), hres);
        } 
    //
    //5. Get Estimates for IOL:BindIfRunning
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindIfRunning();
        GetTimerVal(IOLTime[iIter].ulBindIfRunning2);
        LOGRESULTS (TEXT("IOL:BindIfRunning2 "), hres);
        } //End BindIfRunning, when not running.
    //
    //6. Get Estimates for IOL:UnbindSource    
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->UnbindSource();
        GetTimerVal(IOLTime[iIter].ulUnbindSource3);
        LOGRESULTS (TEXT("IOL:UnbindSource3 "), hres);
        } 

    retVal = TRUE;

error:
    if (pBindCtx)
        pBindCtx->Release();
    return hres;
}
    



//**********************************************************************
//
// CallOleLinkDisplayName
//
// Purpose:
//      Calls 
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleLoad               OLE2 api 
//      OleSave               OLE2 api
//
//
// Comments:
//          
//
//********************************************************************

BOOL CallOleLinkDisplayName(LinkTimes IOLTime[], LPOLELINK pLink[],
                            LPCOLESTR lpFileName, LPCOLESTR lpNm1, 
                            LPCOLESTR lpNm2, ULONG ulIterations)
{
    CStopWatch  sw;
    HRESULT     hres;
    HRESULT     hres2;
    ULONG       iIter;
    BOOL        retVal = FALSE;
    OLECHAR     szMkName1[256];
    OLECHAR     szMkName2[256];
    LPBINDCTX   pBindCtx = NULL;

    //
    //Set the display name to something known and then call IOL:SetDisplayName
    //Then update the link so that rest of its info is now updated by OLE.
    //

    // This code used to grab the moniker from the link, compose with an item
    // moniker and then the displayname from the composite moniker.  This
    // works, although it's rather convoluted, the first time but then the
    // code would end up doing it a second time and the first item moniker
    // name would still be on the end and it would fail.  Just creating the
    // new display name ourselves seems much easier anyway.
    //
    //First get the Moniker Name by following routine 
    //hres = GetLinkCompositeName(pLink[0], lpNm1, &lpMkName1);
    //if (hres != NOERROR)
    //    goto error;

    swprintf(szMkName1, L"%s!%s", lpFileName, lpNm1);

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Read();
        hres = pLink[iIter]->SetSourceDisplayName(szMkName1);
        hres2 = pLink[iIter]->Update(NULL);
        GetTimerVal(IOLTime[iIter].ulUpdateNull);
        LOGRESULTS (TEXT("IOL:SetSourceDisplayName "), hres);
        LOGRESULTS (TEXT("IOL:Update "), hres2);

        } //End SetSourceDisplayName and Update


    //
    //Repeate the iteration when we have BindContext available. Check the 
    //results.
    //
    //hres = GetLinkCompositeName(pLink[0], lpNm2, &lpMkName2);
    //if (hres != NOERROR)
    //    goto error;

    swprintf(szMkName2, L"%s!%s", lpFileName, lpNm2);

    hres = CreateBindCtx(NULL, &pBindCtx);
    if (hres != NOERROR)
        goto error;

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Read();
        hres = pLink[iIter]->SetSourceDisplayName(szMkName2);
        hres2 = pLink[iIter]->Update(pBindCtx);
        GetTimerVal(IOLTime[iIter].ulUpdateBindCtx);
        LOGRESULTS (TEXT("IOL:SetSourceDisplayName "), hres);
        LOGRESULTS (TEXT("IOL:Update "), hres2);

        } //End SetSourceDisplayName and Update


    retVal = TRUE;

error:
    if (pBindCtx)
        pBindCtx->Release();

return retVal;
}

HRESULT GetLinkCompositeName(LPOLELINK lpLink, LPCOLESTR lpItem,  LPOLESTR FAR* lpComposeName)
{
    HRESULT     hres;
    LPMONIKER   lpLinkMon = NULL;
    LPMONIKER   lpItemMk = NULL;
    LPMONIKER   lpCompose = NULL;
    //SInce NULL BindContext not allowed any more
    LPBINDCTX   pBindCtx = NULL;

    //Get the source moniker of the link
    hres = lpLink->GetSourceMoniker(&lpLinkMon);
    if (hres != NOERROR)
        goto error;
    //Create item moniker from String Item
    hres = CreateItemMoniker(L"!", lpItem, &lpItemMk);
    if (hres != NOERROR)
        goto error;

    //Ask moniker to compose itself with another one in the end to get Composite
    //moniker.
    hres = lpLinkMon->ComposeWith(lpItemMk, FALSE, &lpCompose);
    if (hres != NOERROR)
        goto error;

    hres = CreateBindCtx(NULL, &pBindCtx);
    if (hres != NOERROR)
        goto error;
    //Get the display Name of the moniker
    hres = lpCompose->GetDisplayName(pBindCtx /*BindCtx*/, NULL /*pmkToLeft*/, 
                                    lpComposeName);
    if (hres != NOERROR)
        goto error;

error:
    if (lpLinkMon)
        lpLinkMon->Release();
    if (lpItemMk)
        lpItemMk->Release();
    if (lpCompose)
        lpCompose->Release();
    if (pBindCtx)
        pBindCtx->Release();
        

    return hres;
}

void WriteLinkOutput(CTestOutput &output, LPTSTR lpstr, LinkTimes *lnkTimes, ULONG ulIterations)
{
    UINT iIter;

    output.WriteString (TEXT("Name"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindToSource (NULL)"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindToSource"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindIfRunning"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("UnBindSource"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("UnBindSource2"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindIfRunning2"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("UnBindSource3"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("Update(NULL)"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("Update"));
    output.WriteString (TEXT("\n"));

    for (iIter = 0; iIter < ulIterations; iIter++)
        {
        output.WriteString (lpstr);
        output.WriteLong (lnkTimes[iIter].ulBindToSourceNull);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulBindToSourceBindCtx);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulBindIfRunning);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUnbindSource);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUnbindSource2);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulBindIfRunning2);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUnbindSource3);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUpdateNull);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUpdateBindCtx);
        output.WriteString (TEXT("\n"));
        }

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\bm_crt.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Crt.cxx
//
//  Contents:    Create apis
//
//  Classes:    CCreateApi
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_Crt.hxx"

TCHAR    vlpScratchBuf[256];

//**********************************************************************
//
// CCreate::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CCreateTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CCreateTest::Name ()
{
    return TEXT("CreateTest");
}


SCODE CCreateTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif
    
#ifndef STRESS
    //    initialize timing arrays
    INIT_RESULTS(m_ulOleCreateSr32);
    INIT_RESULTS(m_ulOleCreateOutl);
    INIT_RESULTS(m_ulOleCreateRenderDrawSr32);
    INIT_RESULTS(m_ulOleCreateRenderDrawOutl);
#endif


    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(L"Sr32test", &m_clsidSr32);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //Create Doc and Root storage
    m_lpDoc = CSimpleDoc::Create();
        
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // Create an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}



SCODE CCreateTest::Cleanup ()
{
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }


    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CCreateTest::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      The profile is done by calling OleCreate on Sr32test and SvrOutl.
//      We get results for different FormatEtc types.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CallOleCreate       defined below
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



SCODE CCreateTest::Run ()
{
        CStopWatch  sw;
        BOOL        fRet;

        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, 
                            NULL, NULL, m_ulIterations, m_ulOleCreateSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, NULL, NULL, 
                            m_ulIterations, m_ulOleCreateOutl);

        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateRenderDrawSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateRenderDrawOutl);

        //Create the objects with RenderFormat = Metafile

        FORMATETC fmte = {CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT};
        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatMFSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatMFOutl);


        //Create the objects with RenderFormat = Bitmap
        fmte.cfFormat = CF_BITMAP;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.tymed    = TYMED_GDI;
        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatBMSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatBMOutl);

        //Create the objects with RenderFormat = Text
        fmte.cfFormat = CF_TEXT;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.tymed    = TYMED_HGLOBAL;
        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatTextSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatTextOutl);

    return S_OK;
}                      



SCODE CCreateTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Create Apis\t\t"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  Sr32test \t\t\t"), m_ulIterations, m_ulOleCreateSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  Outline\t\t\t "), m_ulIterations, m_ulOleCreateOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  with RenderDraw Sr32test \t"), m_ulIterations, m_ulOleCreateRenderDrawSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  with RenderDraw Outline \t "), m_ulIterations, m_ulOleCreateRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatMF Sr32test \t"), m_ulIterations, m_ulOleCreateRenderFormatMFSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  with RenderFormatMF Outline \t "), m_ulIterations, m_ulOleCreateRenderFormatMFOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatBM Sr32test \t"), m_ulIterations, m_ulOleCreateRenderFormatBMSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatBM Outline \t "), m_ulIterations, m_ulOleCreateRenderFormatBMOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatTxt Sr32test\t "), m_ulIterations, m_ulOleCreateRenderFormatTextSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatTxt Outline\t "), m_ulIterations, m_ulOleCreateRenderFormatTextOutl);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
    
    




//**********************************************************************
//
// CallOleCreate
//
// Purpose:
//      Calls OleCreate to create the object and then destroys them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate       OLE2 api - Is profiled here
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



BOOL CallOleCreate(REFCLSID rclsid, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, ULONG uOleCreatetime[])
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;

    for ( iIter=0; iIter<ulIterations; iIter++)
        {
        HEAPVALIDATE();
        sw.Reset();
        hres = OleCreate(rclsid, riid, renderopt, pFormatEtc, 
                         &pSite[iIter]->m_OleClientSite,
                         pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

        GetTimerVal(uOleCreatetime[iIter]);
        LOGRESULTS (TEXT("OleCreate "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

    //CleanUp before going to Next
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();

#ifdef REVIEW //BIG REVIEW I am keeping same ClientSIte and Reusing
         //delete pSite[iIter]; 
#endif
        }
    return TRUE;

error:
    if (hres != NOERROR)
        Log (TEXT("Routine CallOleCreate failed with hres = "), hres);
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\hlp_app.cxx ===
//**********************************************************************
// File name: hlp_app.cxx
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.hxx for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "hlp_pre.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

HWND m_hAppWnd;         // main window handle
HINSTANCE m_hInst;          // application instance
CMDIWnd* v_pMDIWnd;
//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//      CSimpleApp has a contained COleInPlaceFrame.  On construction
//      of CSimpleApp, we explicitly call the constructor of this
//      contained class and pass a copy of the this pointer, so that
//      COleInPlaceFrame can refer back to this class
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
								// tells us that we are passing this in
								// an initializer, before "this" is through
								// initializing.  This is ok, because
								// we just store the ptr in the other
								// constructor

CSimpleApp::CSimpleApp() : m_OleInPlaceFrame(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
	DEBUGOUT("In CSimpleApp's Constructor \r\n");

	// Set Ref Count
	m_nCount = 0;

	// clear members
	m_hAppWnd = NULL;
	m_hInst = NULL;
	m_lpDoc = NULL;
    m_hwndUIActiveObj = NULL;
    
	// clear flags
	m_fInitialized = FALSE;
	m_fCSHMode = FALSE;
	m_fMenuMode = FALSE;

	// used for inplace
	SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      OleUninitialize             OLE API
//
// Comments:
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
	DEBUGOUT("In CSimpleApp's Destructor\r\n");

	if (m_hStdPal)
		DeleteObject(m_hStdPal);

	// need to uninit the library...
	if (m_fInitialized)
		OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
	m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Frame level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      COleInPlaceFrame::AddRef    IOIPF.cxx
//
// Comments:
//
//      Note that this QueryInterface is associated with the frame.
//      Since the application could potentially have multiple documents
//      and multiple objects, a lot of the interfaces are ambiguous.
//      (ie. which IOleObject is returned?).  For this reason, only
//      pointers to interfaces associated with the frame are returned.
//      In this implementation, Only IOleInPlaceFrame (or one of the
//      interfaces it is derived from) can be returned.
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT("In CSimpleApp::QueryInterface\r\n");

	*ppvObj = NULL;     // must set out pointer parameters to NULL

	// looking for IUnknown
	if ( riid == IID_IUnknown)
		{
		AddRef();
		*ppvObj = this;
		return ResultFromScode(S_OK);
		}

	// looking for IOleWindow
	if ( riid == IID_IOleWindow)
		{
		m_OleInPlaceFrame.AddRef();
		*ppvObj=&m_OleInPlaceFrame;
		return ResultFromScode(S_OK);
		}

	// looking for IOleInPlaceUIWindow
	if ( riid == IID_IOleInPlaceUIWindow)
		{
		m_OleInPlaceFrame.AddRef();
		*ppvObj=&m_OleInPlaceFrame;
		return ResultFromScode(S_OK);
		}

	// looking for IOleInPlaceFrame
	if ( riid == IID_IOleInPlaceFrame)
		{
		m_OleInPlaceFrame.AddRef();
		*ppvObj=&m_OleInPlaceFrame;
		return ResultFromScode(S_OK);
		}

	// Not a supported interface
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
	DEBUGOUT("In CSimpleApp::AddRef\r\n");
	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
	DEBUGOUT("In CSimpleApp::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
	return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
// Comments:
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
	WNDCLASS  wc;

	// Fill in window class structure with parameters that describe the
	// main window.

	wc.style = NULL;                    // Class style(s).
	wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
										// windows of this class.
	wc.cbClsExtra = 0;                  // No per-class extra data.
	wc.cbWndExtra = 0;                  // No per-window extra data.
	wc.hInstance = hInstance;           // Application that owns the class.
	wc.hIcon = LoadIcon(hInstance, "SimpCntr");
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName =  "SIMPLEMENU";    // Name of menu resource in .RC file.
	wc.lpszClassName = "SimpCntrAppWClass";  // Name used in CreateWindow call

	if (!RegisterClass(&wc))
		return FALSE;

	wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
	wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
										// windows of this class.
	wc.cbClsExtra = 0;                  // No per-class extra data.
	wc.cbWndExtra = 0;                  // No per-window extra data.
	wc.hInstance = hInstance;           // Application that owns the class.
	wc.hIcon = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName =  NULL;
	wc.lpszClassName = "SimpCntrDocWClass"; // Name used in CreateWindow call.

	// Register the window class and return success/failure code.

	return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
	DWORD dwVer = OleBuildVersion();
	LPMALLOC lpMalloc = NULL;

	// check to see if we are compatible with this version of the libraries
	if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup) {
#ifdef _DEBUG
		OutputDebugString("WARNING: Incompatible OLE library version\r\n");
#else
		return FALSE;
#endif
	}

#if defined( _DEBUG )
	/* OLE2NOTE: Use a special debug allocator to help track down
	**    memory leaks.
	*/
	OleStdCreateDbAlloc(0, &lpMalloc);
#endif

	if (OleInitialize(lpMalloc) == NOERROR)
		m_fInitialized = TRUE;

#if defined( _DEBUG )
	/* OLE2NOTE: release the special debug allocator so that only OLE is
	**    holding on to it. later when OleUninitialize is called, then
	**    the debug allocator object will be destroyed. when the debug
	**    allocator object is destoyed, it will report (to the Output
	**    Debug Terminal) whether there are any memory leaks.
	*/
	if (lpMalloc) lpMalloc->Release();
#endif

	m_hInst = hInstance;

	// Create the "application" windows
	m_hAppWnd = CreateWindow ("SimpCntrAppWClass",
							  "Simple OLE 2.0 In-Place Container",
							  WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
							  CW_USEDEFAULT,
							  CW_USEDEFAULT,
							  CW_USEDEFAULT,
							  CW_USEDEFAULT,
							  NULL,
							  NULL,
							  hInstance,
							  NULL);

	if (!m_hAppWnd)
		return FALSE;

    m_pMDIWnd = new (CMDIWnd);
    v_pMDIWnd.Create();

	m_hStdPal = OleStdCreateStandardPalette();

	ShowWindow (m_hAppWnd, nCmdShow);
	UpdateWindow (m_hAppWnd);

	return m_fInitialized;
}

//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//      IOleObject::DoVerb                          Object
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.cxx
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT rect;

	// context sensitive help...
	if (m_fMenuMode || m_fCSHMode)
		{
		if (m_fCSHMode)
			{
			// clear context sensitive help flag
			m_fCSHMode = FALSE;

			// if there is an InPlace active object, call its context sensitive help
			// method with the FALSE parameter to bring the object out of the
			// csh state.  See the technotes for details.
			if (m_lpDoc->m_lpActiveObject)
				{
				LPOLEINPLACEOBJECT lpInPlaceObject;
				m_lpDoc->m_lpActiveObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpInPlaceObject);
				lpInPlaceObject->ContextSensitiveHelp(FALSE);
				lpInPlaceObject->Release();
				}
			}

		// see the technotes for details on implementing context sensitive
		// help
		if (m_fMenuMode)
			{
			m_fMenuMode = FALSE;

			if (m_lpDoc->m_lpActiveObject)
				m_lpDoc->m_lpActiveObject->ContextSensitiveHelp(FALSE);
			}
		// if we provided help, we would do it here...
		MessageBox (hWnd, "Help", "Help", MB_OK);

		return NULL;
		}

	// see if the command is a verb selections
	if (wParam >= IDM_VERB0)
		{
		// get the rectangle of the object
		m_lpDoc->m_lpSite->GetObjRect(&rect);

		m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(wParam - IDM_VERB0, NULL, &m_lpDoc->m_lpSite->m_OleClientSite, -1, m_lpDoc->m_hDocWnd, &rect);
		}
	else
		{
		switch (wParam) {
			// bring up the About box
			case IDM_ABOUT:
				{
				FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

				DialogBox(m_hInst,               // current instance
					"AboutBox",                  // resource to use
					m_hAppWnd,                   // parent handle
					lpProcAbout);                // About() instance address

				FreeProcInstance(lpProcAbout);
				break;
				}

			// bring up the InsertObject Dialog
			case IDM_INSERTOBJECT:
				m_lpDoc->InsertObject();
				break;

			// exit the application
			case IDM_EXIT:
				SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
				break;

			case IDM_NEW:
				m_lpDoc->Close();
				m_lpDoc = NULL;
				lCreateDoc(hWnd, 0, 0, 0);
				break;

            case IDM_COPYLINE:
            case IDM_ADDLINE:
            case IDM_UNINDENTLINE:
                m_lpDoc->HandleDispatch(wParam);
                break;


			default:
				//return (DefWindowProc(hWnd, message, wParam, lParam));
				return (DefFrameProc(hWnd, v_pMDIWnd->hwndMDIClient, message, wParam, lParam));
			}   // end of switch
		}  // end of else
	return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.cxx
//
// Comments:
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT rect;

	GetClientRect(m_hAppWnd, &rect);
	return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.cxx
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT rect;

	GetClientRect(hWnd, &rect);

	m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

	return NULL;
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelUI
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                            Location
//
//      COleInPlaceFrame::SetMenu           IOIPF.cxx
//      CSimpleApp::AddFrameLevelTools      APP.cxx
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelUI()
{
	m_OleInPlaceFrame.SetMenu(NULL, NULL, NULL);
	AddFrameLevelTools();
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelTools
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                              Location
//
//      COleInPlaceFrame::SetBorderSpace      IOIPF.cxx
//      InvalidateRect                        Windows API
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelTools()
{
	m_OleInPlaceFrame.SetBorderSpace(&nullRect);
	InvalidateRect(m_hAppWnd, NULL, TRUE);
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
//      IOleInPlaceActiveObject::TranslateAccelerator   Object
//
// Comments:
//
//      If an object is InPlace active, it gets the first shot at
//      handling the accelerators.
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
	HRESULT hResult;
	BOOL retval = FALSE;

	// if we have an InPlace Active Object
	if (m_lpDoc->m_lpActiveObject)
		{
		// Pass the accelerator on...
		hResult = m_lpDoc->m_lpActiveObject->TranslateAccelerator(lpMsg);
		if (hResult == NOERROR)
			retval = TRUE;
		}

	return retval;
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.cxx
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
	// at this level, we could enumerate through all of the
	// visible objects in the application, so that a palette
	// that best fits all of the objects can be built.

	// This app is designed to take on the same palette
	// functionality that was provided in OLE 1.0, the palette
	// of the last object drawn is realized.  Since we only
	// support one object at a time, it shouldn't be a big
	// deal.

	// if we supported multiple documents, we would enumerate
	// through each of the open documents and call paint.

	if (m_lpDoc)
		m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpleApp::ContextSensitiveHelp
//
// Purpose:
//      Used in supporting context sensitive haelp at the app level.
//
//
// Parameters:
//
//      BOOL fEnterMode    -   Entering/Exiting Context Sensitive
//                             help mode.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//
// Comments:
//
//      This function isn't used because we don't support Shift+F1
//      context sensitive help.  Be sure to look at the technotes
//      in the OLE 2.0 toolkit.
//
//********************************************************************

void CSimpleApp::ContextSensitiveHelp (BOOL fEnterMode)
{
	if (m_fCSHMode != fEnterMode)
		{
		m_fCSHMode = fEnterMode;

		// this code "trickles" the context sensitive help via shift+f1
		// to the inplace active object.  See the technotes for implementation
		// details.
		if (m_lpDoc->m_lpActiveObject)
			{
			LPOLEINPLACEOBJECT lpInPlaceObject;
			m_lpDoc->m_lpActiveObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpInPlaceObject);
			lpInPlaceObject->ContextSensitiveHelp(fEnterMode);
			lpInPlaceObject->Release();
			}
		}
}


/* OLE2NOTE: forward the WM_QUERYNEWPALETTE message (via
**    SendMessage) to UIActive in-place object if there is one.
**    this gives the UIActive object the opportunity to select
**    and realize its color palette as the FOREGROUND palette.
**    this is optional for in-place containers. if a container
**    prefers to force its color palette as the foreground
**    palette then it should NOT forward the this message. or
**    the container can give the UIActive object priority; if
**    the UIActive object returns 0 from the WM_QUERYNEWPALETTE
**    message (ie. it did not realize its own palette), then
**    the container can realize its palette.
**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
**
**    (It is a good idea for containers to use the standard
**    palette even if they do not use colors themselves. this
**    will allow embedded object to get a good distribution of
**    colors when they are being drawn by the container)
**
*/

LRESULT CSimpleApp::QueryNewPalette(void)
{
	if (m_hwndUIActiveObj) {
		if (SendMessage(m_hwndUIActiveObj, WM_QUERYNEWPALETTE,
				(WPARAM)0, (LPARAM)0)) {
			/* Object selected its palette as foreground palette */
			return (LRESULT)1;
		}
	}

	return wSelectPalette(m_hAppWnd, m_hStdPal, FALSE/*fBackground*/);
}


/* This is just a helper routine */

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground)
{
	HDC hdc;
	HPALETTE hOldPal;
	UINT iPalChg = 0;

	if (hPal == 0)
		return (LRESULT)0;

	hdc = GetDC(hWnd);
	hOldPal = SelectPalette(hdc, hPal, fBackground);
	iPalChg = RealizePalette(hdc);
	SelectPalette(hdc, hOldPal, TRUE /*fBackground*/);
	ReleaseDC(hWnd, hdc);

	if (iPalChg > 0)
		InvalidateRect(hWnd, NULL, TRUE);

	return (LRESULT)1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\hlp_iocs.cxx ===
//**********************************************************************
// File name: HLP_IOCS.cxx
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include <headers.cxx>
#pragma hdrstop

#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at this interface
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::QueryInterface SITE.cxx
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In IOCS::QueryInterface\r\n");

        HEAPVALIDATE();

	// delegate to the container Site
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
	DEBUGOUT(L"In IOCS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}


//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
	DEBUGOUT(L"In IOCS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      OutputDebugString                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      OleSave                             OLE API
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
	LPPERSISTSTORAGE lpPS;
	SCODE sc = E_FAIL;

        HEAPVALIDATE();
	DEBUGOUT(L"In IOCS::SaveObject\r\n");

	// get a pointer to IPersistStorage
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(IID_IPersistStorage, (LPVOID FAR *)&lpPS);

	// save the object
	if (hErr == NOERROR)
		{
		sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
		lpPS->SaveCompleted(NULL);
		lpPS->Release();
		}

        HEAPVALIDATE();
	return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
	DEBUGOUT(L"In IOCS::GetMoniker\r\n");

	// need to null the out pointer
	*ppmk = NULL;

        HEAPVALIDATE();
	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
	DEBUGOUT(L"In IOCS::GetContainer\r\n");

	// NULL the out pointer
	*ppContainer = NULL;

	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
	DEBUGOUT(L"In IOCS::ShowObject\r\n");
        HEAPVALIDATE();
	return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      InvalidateRect              Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
	DEBUGOUT(L"In IOCS::OnShowWindow\r\n");
	m_pSite->m_fObjectOpen = fShow;
	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

	// if object window is closing, then bring container window to top
	if (! fShow) {
		BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
		SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
	}
	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
	DEBUGOUT(L"In IOCS::RequestNewObjectLayout\r\n");
	return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\hlp_iops.cxx ===
//**********************************************************************
// File name: HLP_IOPS.cxx
//
//      Implementation file for COleInPlaceSite
//
// Functions:
//
//      See IOIPS.H for class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "hlp_pre.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_iopf.hxx"
#include "hlp_iops.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// COleInPlaceSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::QueryInterface SITE.cxx
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    DEBUGOUT(TEXT("In IOIPS::QueryInterface\r\n"));

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::QueryInterface SITE.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::AddRef()
{
    DEBUGOUT(TEXT("In IOIPS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// COleInPlaceSite::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::Release        SITE.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::Release()
{
    DEBUGOUT(TEXT("In IOIPS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleInPlaceSite::GetWindow
//
// Purpose:
//
//      Returns the Window Handle of the client site
//
// Parameters:
//
//      HWND FAR* lphwnd    - place to return the handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindow (HWND FAR* lphwnd)
{
    DEBUGOUT(TEXT("In IOIPS::GetWindow\r\n"));

    // return the handle to our editing window.
    *lphwnd = m_pSite->m_lpDoc->m_hDocWnd;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::ContextSensitiveHelp
//
// Purpose:
//      set/reset context sensitive help mode
//
// Parameters:
//
//      BOOL fEnterMode - TRUE for entering Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes included with the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::ContextSensitiveHelp (BOOL fEnterMode)
{
    DEBUGOUT(TEXT("In IOIPS::ContextSensitiveHelp\r\n"));

    if (m_pSite->m_lpDoc->m_lpApp->m_fCSHMode != fEnterMode)
        m_pSite->m_lpDoc->m_lpApp->m_fCSHMode = fEnterMode;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::CanInPlaceActivate
//
// Purpose:
//
//      Object calls to find out if the container can InPlace activate
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::CanInPlaceActivate ()
{
    DEBUGOUT(TEXT("In IOIPS::CanInPlaceActivate\r\n"));

    // return S_OK to indicate we can in-place activate
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceActivate
//
// Purpose:
//
//      Called by the object on InPlace Activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK             -  if the interface can be found
//      E_FAIL           -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceActivate ()
{
    HRESULT hrErr;
    DEBUGOUT(TEXT("In IOIPS::OnInPlaceActivate\r\n"));

    hrErr = m_pSite->m_lpOleObject->QueryInterface(
           IID_IOleInPlaceObject, (LPVOID FAR *)&m_pSite->m_lpInPlaceObject);
    if (hrErr != NOERROR)
        return ResultFromScode(E_FAIL);

    // return S_OK to indicate we can in-place activate.
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIActivate
//
// Purpose:
//
//      Object calls this method when it displays it's UI.
//
// Parameters:
//
//      None.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                      Location
//
//      OutputDebugString             Windows API
//      ResultFromScode               OLE API
//      IOleInPlaceObject::GetWindow  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIActivate ()
{
    DEBUGOUT(TEXT("In IOIPS::OnUIActivate\r\n"));

    m_pSite->m_lpDoc->m_fAddMyUI=FALSE;
    m_pSite->m_lpDoc->m_fInPlaceActive = TRUE;
    m_pSite->m_fInPlaceActive = TRUE;

    m_pSite->m_lpInPlaceObject->GetWindow((HWND FAR*)&m_pSite->m_hwndIPObj);

    // return S_OK to continue in-place activation
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::GetWindowContext
//
// Purpose:
//
//      Called by the object to get information for InPlace Negotiation.
//
// Parameters:
//
//      LPOLEINPLACEFRAME FAR* lplpFrame    - Location to return a pointer
//                                            to IOleInPlaceFrame.
//
//      LPOLEINPLACEUIWINDOW FAR* lplpDoc   - Location to return a pointer
//                                            to IOleInPlaceUIWindow.
//
//      LPRECT lprcPosRect                  - The rect that the object
//                                            occupies
//
//      LPRECT lprcClipRect                 - The clipping rect
//
//      LPOLEINPLACEFRAMEINFO lpFrameInfo   - Pointer to FRAMEINFO
//
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      COleInPlaceFrame::AddRef    IOIPF.cxx
//      CSimpleSite::GetObjRect     SITE.cxx
//      OutputDebugString           Windows API
//      CopyRect                    Windows API
//      GetClientRect               Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindowContext (
                               LPOLEINPLACEFRAME FAR* lplpFrame,
                               LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                               LPRECT lprcPosRect,
                               LPRECT lprcClipRect,
                               LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    RECT rect;

    DEBUGOUT(TEXT("In IOIPS::GetWindowContext\r\n"));

    // the frame is associated with the application object.
    // need to AddRef() it...
    m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame.AddRef();
    *lplpFrame = &m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame;
    *lplpDoc = NULL;  // must be NULL, cause we're SDI.

    // get the size of the object in pixels
    m_pSite->GetObjRect(&rect);

    // Copy this to the passed buffer
    CopyRect(lprcPosRect, &rect);

    // fill the clipping region
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);
    CopyRect(lprcClipRect, &rect);

    // fill the FRAMEINFO
    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_pSite->m_lpDoc->m_lpApp->m_hAppWnd;
    lpFrameInfo->haccel = m_pSite->m_lpDoc->m_lpApp->m_hAccel;
    lpFrameInfo->cAccelEntries = SIMPCNTR_ACCEL_CNT;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::Scroll
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      SIZE scrollExtent  - number of pixels scrolled in X and Y direction
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::Scroll (SIZE scrollExtent)
{
    DEBUGOUT(TEXT("In IOIPS::Scroll\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIDeactivate
//
// Purpose:
//
//      Called by the object when its UI goes away
//
// Parameters:
//
//       BOOL fUndoable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleAPP::QueryNewPalette APP.cxx
//      CSimpleAPP::AddFrameLevelUI APP.cxx
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIDeactivate (BOOL fUndoable)
{
    DEBUGOUT(TEXT("In IOIPS::OnUIDeactivate\r\n"));

    // need to clear this flag first
    m_pSite->m_lpDoc->m_fInPlaceActive = FALSE;
    m_pSite->m_fInPlaceActive = FALSE;

    m_pSite->m_lpDoc->m_lpApp->QueryNewPalette();
    m_pSite->m_lpDoc->m_lpApp->AddFrameLevelUI();
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceDeactivate
//
// Purpose:
//
//      Called when the inplace session is over
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//      IOleInPlaceObject::Release  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceDeactivate ()
{
    DEBUGOUT(TEXT("In IOIPS::OnInPlaceDeactivate\r\n"));

    if (m_pSite->m_lpInPlaceObject)
    {
        m_pSite->m_lpInPlaceObject->Release();
        m_pSite->m_lpInPlaceObject = NULL;
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::DiscardUndoState
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DiscardUndoState ()
{
    DEBUGOUT(TEXT("In IOIPS::DiscardUndoState\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::DeactivateAndUndo
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DeactivateAndUndo ()
{
    DEBUGOUT(TEXT("In IOIPS::DeactivateAndUndo\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnPosRectChange
//
// Purpose:
//
//      The object calls this method when it's size changes during an
//      InPlace Session
//
// Parameters:
//
//      LPCRECT lprcPosRect -   The new object rect
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      OutputDebugString                   Windows API
//      GetClientRect                       Windows API
//      IOleObject::GetExtent               Object
//      IOleInPlaceObject::SetObjectRects   Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnPosRectChange (LPCRECT lprcPosRect)
{
    DEBUGOUT(TEXT("In IOIPS::OnPosRectChange\r\n"));

    // update the size in the document object
    // NOTE: here we must call IOleObject::GetExtent to get actual extents
    //       of the running object. IViewObject2::GetExtent returns the
    //       last cached extents.
    m_pSite->m_lpOleObject->GetExtent(DVASPECT_CONTENT, &m_pSite->m_sizel);
    RECT rect;
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);

    // tell the object its new size
    m_pSite->m_lpInPlaceObject->SetObjectRects(lprcPosRect, &rect);

    return ResultFromScode(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\hlp_ias.cxx ===
//**********************************************************************
// File name: HLP_IAS.cxx
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#include <headers.cxx>
#pragma hdrstop


#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      Returns a pointer to a requested interface.
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.cxx
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In IAS::QueryInterface\r\n");

	// delegate to the document Object
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddReff        SITE.cxx
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleSite to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
	DEBUGOUT(L"In IAS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.cxx
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleSite to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
	DEBUGOUT(L"In IAS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	m_nCount--;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
	DEBUGOUT(L"In IAS::OnDataChange\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      InvalidateRect              Windows API
//      IViewObject2::GetExtent     Object
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
	LPVIEWOBJECT2 lpViewObject2;
	DEBUGOUT(L"In IAS::OnViewChange\r\n");

	// get a pointer to IViewObject2
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
			IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);

	if (hErr == NOERROR) {
		// get extent of the object
		// NOTE: this method will never be remoted; it can be called w/i this async method
		lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL, &m_pSite->m_sizel);
		lpViewObject2->Release();
	}

	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
	DEBUGOUT(L"In IAS::OnRename\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
	DEBUGOUT(L"In IAS::OnSave\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
	DEBUGOUT(L"In IAS::OnClose\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bmcomm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmcomm.cxx
//
//  Contents:	definitions for benchmark test 
//
//  Classes:
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>

//  the external definitions for these are in bmcomm.hxx

DWORD dwaClsCtx[] = {CLSCTX_INPROC_SERVER, CLSCTX_LOCAL_SERVER};

LPTSTR apszClsCtx[] = {TEXT("InProc Server"), TEXT("Local Server")};
LPTSTR apszClsIDName[] = {TEXT("ClsID_InProc"), TEXT("ClsID_Local")};
LPOLESTR apszPerstName[] = {aszPerstName[0], aszPerstName[1]};
LPOLESTR apszPerstNameNew[] = {aszPerstNameNew[0], aszPerstNameNew[1]};


LPTSTR saModeNames[] = { TEXT("InProc"),
			 TEXT("Local"),
			 TEXT("Handler"),
			 NULL };

DWORD dwaModes[]     = { CLSCTX_INPROC_SERVER,
			 CLSCTX_LOCAL_SERVER,
			 CLSCTX_INPROC_HANDLER };


OLECHAR  aszPerstName[2][80];	// actual name for persistent instances
OLECHAR  aszPerstNameNew[2][80]; // actual name for persistent instances


HRESULT OleInitializeEx(LPMALLOC pMalloc, DWORD dwIgnored)
{
    return OleInitialize(pMalloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\hlp_site.cxx ===
//**********************************************************************
// File name: HLP_SITE.cxx
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include <headers.cxx>
#pragma hdrstop

#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      IStorage::CreateStorage     OLE API
//      assert                      C Runtime
//
// Comments:
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc, INT iIter)
{
	CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

	if (!lpTemp)
		return NULL;

    OLECHAR szTempName[128];
    swprintf(szTempName, L"Object %d", iIter);

	// create a sub-storage for the object
	HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( szTempName,
				STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
				0,
				0,
				&lpTemp->m_lpObjStorage);

	assert(hErr == NOERROR);

	if (hErr != NOERROR)
		{
		delete lpTemp;
		return NULL;
		}

	// we will add one ref count on our Site. later when we want to destroy
	// the Site object we will release this  ref count. when the Site's ref
	// count goes to 0, it will be deleted.
	lpTemp->AddRef();

    HEAPVALIDATE();

	return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
								// tells us that we are passing this in
								// an initializer, before "this" is through
								// initializing.  This is ok, because
								// we just store the ptr in the other
								// constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
							 m_AdviseSink(this)
//							 m_OleInPlaceSite(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
	// remember the pointer to the doc
	m_lpDoc = lpDoc;

	// clear the reference count
	m_nCount = 0;

	m_dwDrawAspect = DVASPECT_CONTENT;
	m_lpOleObject = NULL;
	m_lpInPlaceObject = NULL;
	m_hwndIPObj = NULL;
	m_fInPlaceActive = FALSE;
	m_fObjectOpen = FALSE;

    HEAPVALIDATE();

}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      OutputDebugString                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
	DEBUGOUT (L"In CSimpleSite's Destructor \r\n");

	if (m_lpOleObject)
	   m_lpOleObject->Release();

	if (m_lpObjStorage)
	   m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      OutputDebugString                       Windows API
//      IOleObject::QueryInterface              Object
//      IOleObject::Close                       Object
//      IOleInPlaceObject::UIDeactivate         Object
//      IOleInPlaceObject::InPlaceDeactivate    Object
//      IOleInPlaceObject::Release              Object
//
// Comments:
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
	LPOLEINPLACEOBJECT lpObject;
	LPVIEWOBJECT lpViewObject = NULL;

	DEBUGOUT (L"In CSimpleSite::CloseOleObject \r\n");

	if (m_lpOleObject)
	   {
	   if (m_fInPlaceActive)
		   {
		   m_lpOleObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpObject);
		   lpObject->UIDeactivate();
		   // don't need to worry about inside-out because the object
		   // is going away.
		   lpObject->InPlaceDeactivate();
		   lpObject->Release();
		   }

	   m_lpOleObject->Close(OLECLOSE_NOSAVE);
	   }

    //Make sure Heap is proper before leaving the routine
    HEAPVALIDATE();
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      OutputDebugString                       Windows API
//      CSimpleSite::CloseOleObject             SITE.cxx
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
	DEBUGOUT (L"In CSimpleSite::UnloadOleObject \r\n");
    HEAPVALIDATE();

	if (m_lpOleObject)
	   {
	   LPVIEWOBJECT lpViewObject;
	   CloseOleObject();    // ensure object is closed; NOP if already closed

	   m_lpOleObject->QueryInterface(IID_IViewObject, (LPVOID FAR *)&lpViewObject);

	   if (lpViewObject)
		   {
		   // Remove the view advise
		   lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
		   lpViewObject->Release();
		   }

	   m_lpOleObject->Release();
	   m_lpOleObject = NULL;
	   } 

}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef          OBJ.cxx
//      COleClientSite::AddRef      IOCS.cxx
//      CAdviseSink::AddRef         IAS.cxx
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In CSimpleSite::QueryInterface\r\n");

    HEAPVALIDATE();
	*ppvObj = NULL;     // must set out pointer parameters to NULL

	if ( riid == IID_IUnknown)
		{
		AddRef();
		*ppvObj = this;
		return ResultFromScode(S_OK);
		}

	if ( riid == IID_IOleClientSite)
		{
		m_OleClientSite.AddRef();
		*ppvObj = &m_OleClientSite;
		return ResultFromScode(S_OK);
		}

	if ( riid == IID_IAdviseSink)
		{
		m_AdviseSink.AddRef();
		*ppvObj = &m_AdviseSink;
		return ResultFromScode(S_OK);
		}

#if 0
	if ( riid == IID_IOleInPlaceSite)
		{
		m_OleInPlaceSite.AddRef();
		*ppvObj = &m_OleInPlaceSite;
		return ResultFromScode(S_OK);
		}
#endif

	// Not a supported interface
        HEAPVALIDATE();
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
	DEBUGOUT(L"In CSimpleSite::AddRef\r\n");

	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
	DEBUGOUT(L"In CSimpleSite::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
        HEAPVALIDATE();
	return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject::SetAdvise          Object
//      IViewObject::Release            Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::InitObject(BOOL fCreateNew)
{
	LPVIEWOBJECT2 lpViewObject2;
	RECT rect;

	// Set a View Advise
	m_lpOleObject->QueryInterface(IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);
	lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST, &m_AdviseSink);

	// get the initial size of the object
	lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/, &m_sizel);
	GetObjRect(&rect);  // get the rectangle of the object in pixels
	lpViewObject2->Release();

	// give the object the name of the container app/document
	m_lpOleObject->SetHostNames(L"Simple Application", L"Simple OLE 2.0 In-Place Container");

	// inform object handler/DLL object that it is used in the embedding container's context
	OleSetContainedObject(m_lpOleObject, TRUE);

	if (fCreateNew) {
	   // force new object to save to guarantee valid object in our storage.
	   // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
	   // object is created FROM FILE; its data in storage is already valid.
	   m_OleClientSite.SaveObject();

	   // we only want to DoVerb(SHOW) if this is an InsertNew object.
	   // we should NOT DoVerb(SHOW) if the object is created FromFile.
	   m_lpOleObject->DoVerb(
			   OLEIVERB_SHOW,
			   NULL,
			   &m_OleClientSite,
			   -1,
			   m_lpDoc->m_hDocWnd,
			   &rect);
	}
}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      SetMapMode                      Windows API
//      LPtoDP                          Windows API
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OUTLUI Function
//      OleDraw                         OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
RECT rect;

	// need to check to make sure there is a valid object
	// available.  This is needed if there is a paint msg
	// between the time that CSimpleSite is instantiated
	// and OleUIInsertObject returns.
	if (!m_lpOleObject)
		return;

	// convert it to pixels
	GetObjRect(&rect);

	LPLOGPALETTE pColorSet = NULL;
	LPVIEWOBJECT lpView = NULL;

	// get a pointer to IViewObject
	m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

	// draw the object
	OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);
#if 0
	// if the object is open, draw a hatch rect.
	if (m_fObjectOpen)
		{
		HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
		HBRUSH hOldBrush = SelectObject (hDC, hBrush);
		SetROP2(hDC, R2_MASKPEN);
		Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
		SelectObject(hDC, hOldBrush);
		DeleteObject(hBrush);
		}
#endif

	// if a view pointer was successfully returned, it needs to be released.
	if (lpView)
		lpView->Release();
}

#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define PTS_PER_INCH        72        // number points (font size) per inch
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
	{
	int     iXppli;     //Pixels per logical inch along width
	int     iWidthInPix;
	BOOL    fSystemDC=FALSE;

	if (NULL==hDC)
		{
		hDC=GetDC(NULL);
		fSystemDC=TRUE;
		}

	iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

	//We got logical HIMETRIC along the display, convert them to pixel units
	iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

	if (fSystemDC)
		ReleaseDC(NULL, hDC);

	return iWidthInPix;
	}


STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
	{
	int     iYppli;     //Pixels per logical inch along height
	int     iHeightInPix;
	BOOL    fSystemDC=FALSE;

	if (NULL==hDC)
		{
		hDC=GetDC(NULL);
		fSystemDC=TRUE;
		}

	iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

	//* We got logical HIMETRIC along the display, convert them to pixel units
	iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

	if (fSystemDC)
		ReleaseDC(NULL, hDC);

	return iHeightInPix;
	}


//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OUTLUI Function
//      XformHeightInHimetricToPixels   OUTLUI Function
//
// Comments:
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
	// convert it to pixels
	lpRect->left = lpRect->top = 0;
	lpRect->right = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
	lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\hlp_doc.cxx ===
//**********************************************************************
// File name: HLP_DOC.CXX
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include <headers.cxx>
#pragma hdrstop

#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create()
{
	CSimpleDoc FAR * lpTemp = new CSimpleDoc();

	if (!lpTemp)
		return NULL;

	// create storage for the doc.
	HRESULT hErr = StgCreateDocfile (NULL, STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
									 0, &lpTemp->m_lpStorage);

	if (hErr != NOERROR)
		goto error;

	// we will add one ref count on our document. later in CSimpleDoc::Close
	// we will release this  ref count. when the document's ref count goes
	// to 0, the document will be deleted.
	lpTemp->AddRef();

	return (lpTemp);

error:
	delete (lpTemp);
	return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      CoLockObjectExternal        OLE API
//      OleFlushClipboard           OLE API
//      ShowWindow                  Windows API
//
// Comments:
//
//********************************************************************

void CSimpleDoc::Close(void)
{
	DEBUGOUT(L"In CSimpleDoc::Close\r\n");

	ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

	// Close the OLE object in our document
	if (m_lpSite)
		m_lpSite->CloseOleObject();

	// Release the ref count added in CSimpleDoc::Create. this will make
	// the document's ref count go to 0, and the document will be deleted.
	Release();
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************

CSimpleDoc::CSimpleDoc()
{
}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      IStorage::Release           OLE API
//
// Comments:
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
	DEBUGOUT(L"In CSimpleDoc's Destructor\r\n");

	// Release all pointers we hold to the OLE object. also release
	// the ref count added in CSimpleSite::Create. this will make
	// the Site's ref count go to 0, and the Site will be deleted.
	if (m_lpSite) {
		m_lpSite->UnloadOleObject();
		m_lpSite->Release();
		m_lpSite = NULL;
	}

	// Release the Storage
	if (m_lpStorage) {
		m_lpStorage->Release();
		m_lpStorage = NULL;
	}

	// if the edit menu was modified, remove the menu item and
	// destroy the popup if it exists
	if (m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);
		RemoveMenu(m_lpApp->m_hEditMenu, nCount-1, MF_BYPOSITION);
		if (m_lpApp->m_hCascadeMenu)
			DestroyMenu(m_lpApp->m_hCascadeMenu);
		}

	DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_FALSE -   Always
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      In this implementation, there are no doc level interfaces.
//      In an MDI application, there would be an IOleInPlaceUIWindow
//      associated with the document to provide document level tool
 //     space negotiation.
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In CSimpleDoc::QueryInterface\r\n");

	*ppvObj = NULL;     // must set out pointer parameters to NULL

	// Not a supported interface
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      CSimpleApp::AddRef          APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
	DEBUGOUT(L"In CSimpleDoc::AddRef\r\n");
	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
	DEBUGOUT(L"In CSimpleDoc::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
	return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      memset                      C Runtime
//      OleUIInsertObject           OUTLUI function
//      CSimpleDoc::DisableInsertObject DOC.CPP
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
#if 0
	m_lpSite = CSimpleSite::Create(this);
	iret = OleUIInsertObject(&io);

	if (iret == OLEUI_OK)
		{
		m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
		// disable Insert Object menu item
		DisableInsertObject();
		}
	else
		{
		m_lpSite->Release();
		m_lpSite = NULL;
		m_lpStorage->Revert();
		}
#endif
 
}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      IOleInPlaceActiveObject::ResizeBorder   Object
//      MoveWindow                              Windows API
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
	// if we are InPlace, then call ResizeBorder on the object, otherwise
	// just move the document window.
	//if (m_fInPlaceActive)
		//m_lpActiveObject->ResizeBorder(lpRect, &m_lpApp->m_OleInPlaceFrame, TRUE);
	//else
		MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, TRUE);

	return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OUTLUI function
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
#if 0
	// m_fModifiedMenu is TRUE if the menu has already been modified
	// once.  Since we only support one obect every time the application
	// is run, then once the menu is modified, it doesn't have
	// to be done again.
	if (m_lpSite && !m_fInPlaceActive  && !m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);

		OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
						   NULL,
						   m_lpApp->m_hEditMenu,
						   nCount + 1,
						   IDM_VERB0,
						   0,           // no maximum verb IDM enforced
						   FALSE,
						   0,
						   &m_lpApp->m_hCascadeMenu);

		m_fModifiedMenu = TRUE;
		}
#endif
	return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
// Comments:
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
	// if we supported multiple objects, then we would enumerate
	// the objects and call paint on each of them from here.

	if (m_lpSite)
		m_lpSite->PaintObj(hDC);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\cairole\ui\hlp_iopf.cxx ===
//**********************************************************************
// File name: HLP_IOIPF.cxx
//
//      Implementation file for COleInPlaceFrame
//
// Functions:
//
//      See IOIPF.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "hlp_pre.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_iopf.hxx"
#include "hlp_iops.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"


//**********************************************************************
//
// COleInPlaceFrame::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleApp::QueryInterface  APP.cxx
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    DEBUGOUT(TEXT("In IOIPF::QueryInterface\r\n"));

    // delegate to the application Object
    return m_pApp->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceFrame::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the CSimpleApp
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleApp::AddRef          APP.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::AddRef()
{
    DEBUGOUT(TEXT("In IOIPF::AddRef\r\n"));

    // delegate to the application Object
    return m_pApp->AddRef();
}

//**********************************************************************
//
// COleInPlaceFrame::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleApp.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleApp::Release         APP.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::Release()
{
    DEBUGOUT(TEXT("In IOIPF::Release\r\n"));

    // delegate to the document object
    return m_pApp->Release();

}

//**********************************************************************
//
// COleInPlaceFrame::GetWindow
//
// Purpose:
//
//      Returns the frame window handle
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetWindow (HWND FAR* lphwnd)
{
    DEBUGOUT(TEXT("In IOIPF::GetWindow\r\n"));
    *lphwnd = m_pApp->m_hAppWnd;
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::ContextSensitiveHelp
//
// Purpose:
//
//      Used in implementing Context sensitive help
//
// Parameters:
//
//      BOOL fEnterMode -   TRUE if starting Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes in the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::ContextSensitiveHelp (BOOL fEnterMode)
{
    DEBUGOUT(TEXT("In IOIPF::ContextSensitiveHelp\r\n"));

    m_pApp->m_fMenuMode = fEnterMode;

    return ResultFromScode(S_OK);
}
//**********************************************************************
//
// COleInPlaceFrame::GetBorder
//
// Purpose:
//
//      Returns the outermost border that frame adornments can be attached
//      during InPlace Activation.
//
// Parameters:
//
//      LPRECT lprectBorder - return parameter to contain the outermost
//                            rect for frame adornments
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      GetClientRect               Windows API
//      CopyRect                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetBorder (LPRECT lprectBorder)
{
    RECT rect;

    DEBUGOUT(TEXT("In IOIPF::GetBorder\r\n"));

    // get the rect for the entire frame.
    GetClientRect(m_pApp->m_hAppWnd, &rect);

    CopyRect(lprectBorder, &rect);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::RequestBorderSpace
//
// Purpose:
//
//      Approves/Denies requests for border space during InPlace
//      negotiation.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - The width in pixels needed on
//                                        each side of the frame.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      This implementation doesn't care about how much border space
//      is used.  It always returns S_OK.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RequestBorderSpace (LPCBORDERWIDTHS
                                                         lpborderwidths)
{
    DEBUGOUT(TEXT("In IOIPF::RequestBorderSpace\r\n"));

    // always approve the request
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetBorderSpace
//
// Purpose:
//
//      The object calls this method when it is actually going to
//      start using the border space.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - Border space actually being used
//                                        by the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::AddFrameLevelTools  APP.cxx
//      OutputDebugString               Windows API
//      GetClientRect                   Windows API
//      MoveWindow                      Windows API
//      ResultFromScode                 Windows API
//
// Comments:
//
//      This routine could be a little smarter and check to see if
//      the object is requesting the entire client area of the
//      window.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{

    DEBUGOUT(TEXT("In IOIPF::SetBorderSpace\r\n"));

    if (lpborderwidths == NULL)
        m_pApp->AddFrameLevelTools();
    else
    {
        RECT rect;

        GetClientRect(m_pApp->m_hAppWnd, &rect);

        MoveWindow( m_pApp->m_lpDoc->m_hDocWnd,
                   rect.left + lpborderwidths->left,
                   rect.top + lpborderwidths->top,
                   rect.right - lpborderwidths->right - lpborderwidths->left,
                   rect.bottom - lpborderwidths->bottom - lpborderwidths->top,
                   TRUE);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetActiveObject
//
// Purpose:
//  install the object being activated in-place
//
//
// Parameters:
//
//  LPOLEINPLACEACTIVEOBJECT lpActiveObject     -   Pointer to the
//                                                  objects
//                                                  IOleInPlaceActiveObject
//                                                  interface
//
//  LPCOLESTR lpszObjName                       -   Name of the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      OutputDebugString                   Windows API
//      IOleInPlaceActiveObject::AddRef     Object
//      IOleInPlaceActiveObject::Release    Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetActiveObject (LPOLEINPLACEACTIVEOBJECT
                                        lpActiveObject, LPCOLESTR lpszObjName)
{

    DEBUGOUT(TEXT("In IOIPF::SetActiveObject\r\n"));

    // AddRef() it and save it...
    if (lpActiveObject)
    {
        lpActiveObject->AddRef();

        lpActiveObject->GetWindow(&m_pApp->m_hwndUIActiveObj);
        if (m_pApp->m_hwndUIActiveObj)
            SendMessage(m_pApp->m_hwndUIActiveObj, WM_QUERYNEWPALETTE, 0, 0L);
    }
    else
    {
        if (m_pApp->m_lpDoc->m_lpActiveObject)
            m_pApp->m_lpDoc->m_lpActiveObject->Release();
        m_pApp->m_hwndUIActiveObj = NULL;
    }

    // in an MDI app, this method really shouldn't be called,
    // this method associated with the doc is called instead.

    m_pApp->m_lpDoc->m_lpActiveObject = lpActiveObject;
    // should set window title here

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::InsertMenus
//
// Purpose:
//
//      Inserts the container menu into the combined menu
//
// Parameters:
//
//      HMENU hmenuShared                   -   Menu Handle to be set.
//      LPOLEMENUGROUPWIDTHS lpMenuWidths   -   Width of menus
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      AppendMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::InsertMenus (HMENU hmenuShared,
                                            LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    DEBUGOUT(TEXT("In IOIPF::InsertMenus\r\n"));

    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hFileMenu, TEXT("&File"));
    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hHelpMenu, TEXT("&Other"));

    lpMenuWidths->width[0] = 1;
    lpMenuWidths->width[2] = 0;
    lpMenuWidths->width[4] = 1;

    return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::SetMenu
//
// Purpose:
//
//      Sets the application menu to the combined menu
//
// Parameters:
//
//      HMENU hmenuShared       - The combined menu
//
//      HOLEMENU holemenu       - Used by OLE
//
//      HWND hwndActiveObject   - Used by OLE
//
// Return Value:
//
//      S_OK                -  if menu was correctly installed
//      E_FAIL              -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      SetMenu                     Windows API
//      OleSetMenuDescriptor        OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetMenu (HMENU hmenuShared, HOLEMENU holemenu,
                                        HWND hwndActiveObject)
{

    DEBUGOUT(TEXT("In IOIPF::SetMenu\r\n"));

    HMENU hMenu = m_pApp->m_lpDoc->m_hMainMenu;

    if (holemenu)
        hMenu = hmenuShared;

    // call the windows api, not this method
    ::SetMenu (m_pApp->m_hAppWnd, hMenu);

    HRESULT hRes = OleSetMenuDescriptor(holemenu, m_pApp->m_hAppWnd,
                                        hwndActiveObject, this,
                                        m_pApp->m_lpDoc->m_lpActiveObject);

    return hRes;
}


//**********************************************************************
//
// COleInPlaceFrame::RemoveMenus
//
// Purpose:
//
//      Removes the container menus from the combined menu
//
// Parameters:
//
//      HMENU hmenuShared   - Handle to the combined menu.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      GetMenuItemCount            Windows API
//      RemoveMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RemoveMenus (HMENU hmenuShared)
{
    int retval;

    DEBUGOUT(TEXT("In IOIPF::RemoveMenus\r\n"));

    while ((retval = GetMenuItemCount(hmenuShared)) && (retval != -1))
        RemoveMenu(hmenuShared, 0, MF_BYPOSITION);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetStatusText
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPCOLESTR  lpszStatusText  -  character string containing the message
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact
//      that this application does not have a status bar.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCOLESTR lpszStatusText)
{
    DEBUGOUT(TEXT("In IOIPF::SetStatusText\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceFrame::EnableModeless
//
// Purpose:
//
//      Enables/Disables container modeless dialogs
//
// Parameters:
//
//      BOOL fEnable    - Enable/Disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      There are no modeless dialogs in this application, so the
//      implementation of this method is trivial.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::EnableModeless (BOOL fEnable)
{
    DEBUGOUT(TEXT("In IOIPF::EnableModeless\r\n"));
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::TranslateAccelerator
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPMSG   lpmsg     -   structure containing keystroke message
//      WORD    wID       -   identifier value corresponding to the keystroke
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::TranslateAccelerator (LPMSG lpmsg, WORD wID)
{
    DEBUGOUT(TEXT("In IOIPF::TranslateAccelerator\r\n"));
    return ::TranslateAccelerator(m_pApp->m_hAppWnd, m_pApp->m_hAccel, lpmsg)
        ? ResultFromScode(S_OK)
        : ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bmconfig.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmconfig.cxx
//
//  Contents:	configuration inquiry and reporting
//
//  Classes:	
//
//  Functions:	ReportBMConfig
//
//  History:    2-July-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmdriver.hxx>


//+-------------------------------------------------------------------
//
//  Function: 	ReportBMConfig
//
//  Synopsis:	Writes the current system / hardware configuration
//		to a specified output class
//
//  Parameters: [lpswzConfigFile]	Name and path of .ini file 
//		[output]		Output class
//
//  History:   	2-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void ReportBMConfig (CTestInput &input, CTestOutput &output)
{
	TCHAR cname[MAX_COMPUTERNAME_LENGTH+1];
	SYSTEM_INFO sinf;
	TCHAR *temp;
	DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;

	GetComputerName (cname, &dwSize);
	output.WriteTextString (cname);

	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("Mfg"), TEXT("n/a"));

	GetSystemInfo (&sinf);
	
	switch (sinf.dwProcessorType)
	{
		case 386:
			temp = TEXT("i386");
			break;
		case 486:
			temp = TEXT("i486");
			break;
		case 860:
			temp = TEXT("i860");
			break;
		case 2000:
			temp = TEXT("R2000");
			break;		
		case 3000:
			temp = TEXT("R3000");
			break;		
		case 4000:
			temp = TEXT("R4000");
			break;		
		default:
			temp = TEXT("Unknown");

		break;
	}
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("CPU"), temp);
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("RAM"), TEXT("n/a"));
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("OS"), TEXT("Cairo"));
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Driver"), TEXT("InitFlag"), TEXT("COINIT_MULTITHREADED"));

	output.WriteString (TEXT("\n\t\t\t\t"));

	output.WriteString (TEXT("All times in microseconds\n"));

//	NtQuerySystemInformation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bmlog.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmlog.cxx
//
//  Contents:	Benchmark test error logging
//
//  Classes:	
//
//  Functions:	
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmoutput.hxx>
#include <bmlog.hxx>

CTestOutput *logOutput;


//+------------------------------------------------------------------------
//
//  funtion:	LogTo
//
//  purpose:	writes the benchmark header to the logfile
//
//+------------------------------------------------------------------------

void LogTo (CTestOutput *_logOutput)
{
    logOutput = _logOutput;
    _SYSTEMTIME stTimeDate;

    logOutput->WriteString (TEXT("CairOLE Benchmark Log File\t"));
    GetLocalTime (&stTimeDate);
    logOutput->WriteDate (&stTimeDate);
    logOutput->WriteString (TEXT("\t"));
    logOutput->WriteTime (&stTimeDate);
    logOutput->WriteString (TEXT("\n\n"));
}


//+------------------------------------------------------------------------
//
//  funtion:	LogSection
//
//  purpose:	writes the section header to the logfile
//
//+------------------------------------------------------------------------

void LogSection (LPTSTR lpszName)
{
    if (!logOutput)
	return;

    logOutput->WriteString (lpszName);
    logOutput->WriteString (TEXT("\n"));
}
	

//+------------------------------------------------------------------------
//
//  funtion:	Log
//
//  purpose:	records the result of one action taken by the benchmark test
//
//+------------------------------------------------------------------------

int Log (LPTSTR lpszActionName, SCODE hr)
{
    if (!logOutput)
	return !SUCCEEDED(hr);

    logOutput->WriteString (TEXT("    "));
    logOutput->WriteString (lpszActionName);

    if (SUCCEEDED(hr))
    {
	logOutput->WriteString (TEXT("\tOK\n"));
	return FALSE;
    }
    else
    {
	logOutput->WriteString (TEXT("\tERROR: "));
	logOutput->WriteSCODE (hr);
	logOutput->WriteString (TEXT("\n"));
	return TRUE;
    }
}

		
int Log (LPTSTR lpszActionName, ULONG ulCode)
{
    if (!logOutput)
        return FALSE;

    logOutput->WriteString (TEXT("    "));
    logOutput->WriteString (lpszActionName);
	logOutput->WriteLong(ulCode);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bmrpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmrpc.cxx
//
//  Contents:	common Raw Rpc code
//
//  Classes:	None
//
//  Functions:	
//
//  History:	02-Feb-94   Rickhi	Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <rawrpc.h>

extern "C" const GUID IID_IRawRpc =
    {0x00000145,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



extern "C" void _gns__GUID (GUID* _target, PRPC_MESSAGE _prpcmsg);


//+-------------------------------------------------------------------------
//
//  Function:	MIDL_user_allocate
//
//  Synopsis:   Allocate memory via OLE task allocator.
//
//--------------------------------------------------------------------------
void *__stdcall MIDL_user_allocate(size_t size)
{
    void *pMemory = (void *) new BYTE[size];

    if(pMemory == 0)
	RaiseException((unsigned long)E_OUTOFMEMORY, 0, 0, 0);

    return pMemory;
}

//+-------------------------------------------------------------------------
//
//  Function:	MIDL_user_free
//
//  Synopsis:   Free memory using OLE task allocator.
//
//--------------------------------------------------------------------------
void __stdcall MIDL_user_free(void *pMemory)
{
    delete pMemory;
}



/* routine that gets node for struct _GUID */
void _gns__GUID (GUID  * _target, PRPC_MESSAGE _prpcmsg)
{
  unsigned long _alloc_total;
  ((void)( _alloc_total ));
  *(unsigned long *)&_prpcmsg->Buffer += 3;
  *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
  /* receive data into &_target->Data1 */
  long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_target->Data1);
  /* receive data into &_target->Data2 */
  short_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned short *)&_target->Data2);
  /* receive data into &_target->Data3 */
  short_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned short *)&_target->Data3);
  char_array_from_ndr ((PRPC_MESSAGE)_prpcmsg, 0, 0 + 8, (unsigned char *)_target->Data4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bmoutput.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmoutput.cxx
//
//  Contents:	output class for benchmark results
//
//  Classes:	CTestOutput
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//              15-Aug-94  davidfie    Make ASCII/Unicode for chicago
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmoutput.hxx>

//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::CTestOutput, public
//
//  Synopsis:	Generates output file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

CTestOutput::CTestOutput (LPTSTR lpszFileName)
{
#ifdef UNICODE
	char szFileName[80];

	wcstombs (szFileName, lpszFileName, wcslen(lpszFileName)+1);
	fpOut = fopen (szFileName, "wt");
#else
	fpOut = fopen (lpszFileName, "wt");
#endif
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::~CTestOutput, public
//
//  Synopsis:	Closes output file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------


CTestOutput::~CTestOutput ()
{
	if (fpOut)
		fclose (fpOut);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::Flush, public
//
//  Synopsis:	flushes the buffers associated with the output file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::Flush(void)
{
	fflush (fpOut);
}



//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteTextString, public
//
//  Synopsis:	Writes a TEXT format string to output file
//
//  Parameters: [lpswzString]	String to be printed
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteTextString (LPTSTR lpszString)
{
	WriteString(lpszString);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteString, public
//
//  Synopsis:	Writes string to output file
//
//  Parameters: [lpszString]	String to be printed
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteString (LPTSTR lpszString)
{
#ifdef UNICODE
	char *fmt = "%ws";
#else
	char *fmt = "%s";
#endif

	if (!fpOut)
		return;
	fprintf (fpOut, fmt, lpszString);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteLong, public
//
//  Synopsis:	Writes long to output file
//
//  Parameters: [lpswzString]	String to be printed
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteLong (ULONG l)
{
	if (!fpOut)
		return;
	fprintf (fpOut, "%lu", l);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteConfigEntry, public
//
//  Synopsis:	Writes string from config file to output file
//
//  Parameters:	[input]		Input class (config file)
//		[lpszSection]	Section name of entry to be printed
//		[lpszEntry]	Entry name to be printed
//		[lpszDefault]	Default string in case entry does
//				not exist
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteConfigEntry (CTestInput &input, LPTSTR lpszSection,
	LPTSTR lpszEntry, LPTSTR lpszDefault)
{
	TCHAR destName[160];

	if (!fpOut)
		return;
	
	input.GetConfigString (lpszSection, lpszEntry, lpszDefault,
		destName, sizeof(destName)/sizeof(TCHAR));

	WriteString (destName);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteSectionHeader, public
//
//  Synopsis:	Writes general test section header to output file
//
//  Parameters: [lpszTestName]		General test name (from
//					[TestClass].Name(),like "OLE")
//		[lpszSectionName]	Specific test name (like
//					"Object Bind Test")
//		[input]			.ini file class
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteSectionHeader (LPTSTR lpszTestName,
	LPTSTR lpszSectionName, CTestInput &input)
{
	if (!fpOut)
		return;

	if (!lpszSectionName)
		lpszSectionName = TEXT("");


	if (g_fFullInfo)
	{
#ifdef UNICODE
    char *fmt = "\n\n%ws - %ws\n\nComments:\t";
#else
    char *fmt = "\n\n%s - %s\n\nComments:\t";
#endif
	    //	we conditionally skip writing the comment to make it
	    //	easier to format for excel.
	    fprintf (fpOut, fmt, lpszTestName, lpszSectionName);

	    WriteConfigEntry (input, lpszTestName, TEXT("comment"));
	    fprintf (fpOut, "\n");
	}
	else
	{
#ifdef UNICODE
    char *fmt = "\n\n%ws\n";
#else
    char *fmt = "\n\n%s\n";
#endif
	    fprintf (fpOut, fmt, lpszSectionName);
	}
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteResult, public
//
//  Synopsis:	Writes test result line to output file, in the form
//		"Create moniker <tab> 30800"
//
//  Parameters: [lpszMeasurementName]	Name of result (like
//					"Create moniker"
//		[ulTime]		Measured time in microseconds
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteResult (LPTSTR lpszMeasurementName, ULONG ulTime)
{
	if (fpOut)
	{
	    WriteString (lpszMeasurementName);
	    fprintf (fpOut, "\t");

	    if (ulTime == NOTAVAIL)
	    {
		fprintf (fpOut, "n/a\n");
	    }
	    else if (ulTime == TEST_FAILED)
	    {
		fprintf (fpOut, "F\n");
	    }
	    else
	    {
		fprintf (fpOut, "%lu\n", ulTime);
	    }
	}
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteResult, public
//
//  Synopsis:	Writes test results over several columns
//
//  Parameters: [lpszMeasurementName]	Name of result (like
//					"Create moniker"
//		[iIterations]		Number of results
//		[paUlTime]		Array with measurement times
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteResults (LPTSTR lpszMeasurementName, int iIterations,
				ULONG *paUlTimes)
{
	int i;

	if (fpOut)
	{
	    WriteString (lpszMeasurementName);

	    for (i=0; i<iIterations; i++)
	    {
		if (paUlTimes[i] == NOTAVAIL)
		{
		    fprintf (fpOut, "\tn/a");
		}
		else  if (paUlTimes[i] == TEST_FAILED)
		{
		    fprintf (fpOut, "\tF");
		}
		else
		{
		    fprintf (fpOut, "\t%lu", paUlTimes[i]);
		}
	    }

	    fprintf (fpOut, "\n");
	}
}


//+-------------------------------------------------------------------
//
//  Member: 	WriteClassCtx, public
//
//  Synopsis:	Prints the class activation conL as string to
//		a specified output class
//
//  Parameters: [dwClsCtx]		Class conL to be printed
//
//		CLSCTX_INPROC_SERVER	--> "InProc"
//		CLSCTX_LOCAL_SERVER	--> "LocaL"
//		CLSCTX_INPROC_HANDLER	--> "Handler"
//		any other				--> "Unknown"
//
//  History:   	12-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteClassCtx (DWORD dwClsCtx)
{
	LPTSTR pc = TEXT("Unknown");
	int i = 0;

	while (saModeNames[i])
	{
	    if (dwaModes[i] == dwClsCtx)
	    {
		pc = saModeNames[i];
		break;
	    }
	    i++;
	}

	WriteString (TEXT("ClsCtx\t"));
	WriteString (pc);
	WriteString (TEXT("\n"));
}


//+-------------------------------------------------------------------
//
//  Member:	WriteClassID
//
//  Synopsis:	Prints the class ID as string to
//		a specified output class
//
//  Parameters: [pClsID]     Class ID to be printed
//
//  History:   	13-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteClassID (CLSID *pClsID)
{
    if (g_fFullInfo)
    {
	TCHAR szGUID[50];

	WriteString (TEXT("ClsID\t"));
	StringFromGUID(*pClsID, szGUID);
	WriteString (szGUID);
	WriteString (TEXT("\n"));
    }
}


//+-------------------------------------------------------------------
//
//  Member:	WriteTime
//
//  Synopsis:	Prints time to a specified output class
//
//  Parameters: [pstTime]	 System time
//
//  History:   	5-August-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteTime (_SYSTEMTIME *pstTime)
{
	WORD wHour;
	char cAmpm;

	if (fpOut)
	{
		cAmpm = 'a';
		wHour = pstTime->wHour;

		if (wHour >= 12)
		{
			cAmpm = 'p';
			if (wHour > 12)
				wHour-=12;
		}
		if (wHour==0)
			wHour=12;

		fprintf (fpOut, "%d:%02d%c", wHour, pstTime->wMinute, cAmpm);
	}
}


//+-------------------------------------------------------------------
//
//  Member:	WriteDate
//
//  Synopsis:	Prints date to a specified output class
//
//  Parameters: [pstdate]	  System date
//
//  History:   	5-August-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteDate (_SYSTEMTIME *pstDate)
{
	if (fpOut)
	{
		fprintf (fpOut, "%02d-%02d-%02d",
			pstDate->wMonth, pstDate->wDay, pstDate->wYear % 100);
	}
}


//+-------------------------------------------------------------------
//
//  Member:	WriteSCODE
//
//  Synopsis:	Prints an SCODE to a specified output class
//
//  Parameters: [sc]	  	  SCODE	
//
//  History:   	5-August-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteSCODE (SCODE sc)
{
	if (fpOut)
		fprintf (fpOut, "%xh/%xh", SCODE_FACILITY(sc), SCODE_CODE(sc));
}


//+-------------------------------------------------------------------
//
//  Member:	StringFromGUID
//
//  Synopsis:	converts a GUID into a string so that it may be
//		printed to a specified output class
//
//  Parameters: [pClsID]     Class ID to be printed
//
//  History:   	13-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::StringFromGUID(GUID &rguid, LPTSTR lpsz)
{
    wsprintf(lpsz, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1],
            rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5],
            rguid.Data4[6], rguid.Data4[7]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\stream.cxx ===
//+-------------------------------------------------------------------
//
//  File:	stream.cxx
//
//  Contents:	Stream interface on flat File.
//
//  Classes:	CStreamOnFile
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------
#include    <ole2.h>
#include    <stream.hxx>


CStreamOnFile::CStreamOnFile(const WCHAR *pwszFileName, SCODE &sc, BOOL fRead) :
    _clRefs(1),
    _hFile(NULL),
    _lOffset(0),
    _cSize(0),
    _cbData(0),
    _fRead(fRead)
{
    _pbData = new BYTE[2048];		    // should be big enough
    if (!_pbData)
    {
	sc = E_OUTOFMEMORY;
	return;
    }

    _cbData = 2048;

    // open the file.
    DWORD fdwCreate = (_fRead) ? OPEN_EXISTING : CREATE_ALWAYS;


    _hFile = CreateFile(pwszFileName,
			GENERIC_READ | GENERIC_WRITE,	    // fdwAccess
			FILE_SHARE_READ | FILE_SHARE_WRITE, // fdwShareMode
			NULL,			// lpsaSecurity
			fdwCreate,		// creation options
			FILE_ATTRIBUTE_NORMAL,	// attributes & flags
			NULL			// hTemplateFile
			);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    // read the file into the memory block
    DWORD cbRead = 0;
    if (_fRead && ! ReadFile(_hFile,
			    _pbData,
			    _cbData,
			    &cbRead,
			    NULL))
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    if (_fRead)
    {
	_cSize = _cbData;
    }

    sc = S_OK;
}

CStreamOnFile::~CStreamOnFile(void)
{
    if (_hFile)
    {
	if (!_fRead)
	{
	    // write the data to the file
	    DWORD cbWritten = 0;
	    if (!WriteFile(_hFile,
			   _pbData,
			   _cbData,
			   &cbWritten,
			   NULL))
	    {
		SCODE sc = HRESULT_FROM_WIN32(GetLastError());
	    }
	}

	CloseHandle(_hFile);
    }
}



STDMETHODIMP CStreamOnFile::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CStreamOnFile::AddRef(void)
{
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CStreamOnFile::Release(void)
{
    if (InterlockedDecrement(&_clRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _clRefs;
}

STDMETHODIMP CStreamOnFile::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if ((LONG)cb + _lOffset > _cSize)
    {
	cb = _cSize - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv, _pbData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	return E_OUTOFMEMORY;
    }

    // copy in the new data
    memcpy(_pbData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}



STDMETHODIMP CStreamOnFile::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG  dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bm_parse.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//					 
//  File:	bm_parse.cxx
//
//  Contents:	Implementation of Base class for generic parsers
//
//  Classes:	CTimerBase
//
//  Functions:	
//
//  History:    16-June-94 t-vadims    Created
//
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bm_parse.hxx>

#define  MAX_INSTR_LENGTH    150

#define BLANK_LINE	(FIRST_INTERNALID + 2)

//
// Structure for linked list of instructions with their timings
//
struct SInstruction
{
    ULONG ulID;
    ULONG ulTime[TEST_MAX_ITERATIONS];
    SInstruction *pNext;
};



//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Setup, public
//
//  Synopsis:	Makes all neccessary initializations.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::Setup (CTestInput *pInput)
{
    SCODE 	sc;
    char 	szFileName[80];
    TCHAR	szBuf[80];


    CTestBase::Setup(pInput);

    m_iIterations = pInput->GetIterations(Name());

    // get name of the script file
    pInput->GetConfigString(Name(), TEXT("ScriptName"), TEXT("script.txt"), szBuf, 80);

#ifdef UNICODE
    wcstombs(szFileName, szBuf, 80);
#else
    strcpy(szFileName, szBuf);
#endif

    m_fpIn = fopen(szFileName, "r");
    if(m_fpIn == NULL)
    {
    	Log(TEXT("Can't open script file"), STG_E_FILENOTFOUND);
    	return STG_E_FILENOTFOUND;
    }


    m_pParser = NULL;
    sc = SetParserObject();       // virtual call to setup m_pParser object.

    if(m_pParser == NULL)
    	sc = E_FAIL;

    if(FAILED(sc))
    {
    	Log(TEXT("Setup failed to initialize parser object"), sc);
	fclose(m_fpIn);
    	return sc;
    }

#ifdef THREADING_SUPPORT
    OleInitializeEx(NULL, pInput->GetOleInitFlag());
#else
    OleInitialize(NULL);
#endif

    sc = m_pParser->Setup(pInput);
    if(FAILED(sc))
    {
    	Log(TEXT("Setup of Parser object failed"), sc);
	DeleteParserObject();
	OleUninitialize();
	fclose(m_fpIn);
    	return sc;
    }

    m_pHead = NULL;
    m_iLine = 0;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Cleanup, public
//
//  Synopsis:	Clean everything up.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::Cleanup ()
{
    SInstruction *pInstr, *pNextInstr;

    pInstr = m_pHead;
    while (pInstr != NULL)
    {
	pNextInstr = pInstr->pNext;
	delete pInstr;
	pInstr = pNextInstr;
    }
    m_pHead = NULL;

    m_pParser->Cleanup();
    DeleteParserObject();
    fclose (m_fpIn);

    OleUninitialize();

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Run, public
//
//  Synopsis:	Read and execute the script file.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------

SCODE CTimerBase::Run ()
{
    ReadFile ();
    ExecuteFile ();
    return S_OK;
}



BOOL CTimerBase::IsEmptyLine (LPTSTR pszLine)
{
    while (*pszLine)
    {
    	if ( *pszLine != TEXT(' ') && *pszLine != TEXT('\n') &&
	     *pszLine != TEXT('\t'))
	   return FALSE;

	pszLine++;
    }

    return TRUE;
}



BOOL CTimerBase::IsInternalID (ULONG ulID)
{
    return (ulID >= FIRST_INTERNALID);
}

//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::ReadFile, private
//
//  Synopsis:	Reads script file, adding each instruction to the
//		link list.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::ReadFile ()
{
    TCHAR 	   szBuf[MAX_INSTR_LENGTH];
    SInstruction  *pTail 	= NULL;
    ULONG	   ulID;
    	

    while ( SUCCEEDED(GetNextLine(szBuf)))  // get line from file to szBuf
    {
    	m_iLine ++;
		
     	if (IsEmptyLine(szBuf))
    	{
	    pTail = AddNewInstruction(pTail, BLANK_LINE);
    	}
    	else
    	{    
    	    ulID = m_pParser->ParseNewInstruction(szBuf);

	    if (ulID == INVALID_INSTRUCTION)
	    {
	    	wsprintf(szBuf, TEXT("Invalid instruction on line %d"), m_iLine );
		Log(szBuf, E_FAIL);
	    }
    	    else if(ulID != NOT_INSTRUCTION)     // valid instruction
	    {
	    	pTail = AddNewInstruction(pTail, ulID);
	    }
    	}
    }
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::AddNewInstruction, private
//
//  Synopsis:	Adds new instruction to linked list
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SInstruction *CTimerBase::AddNewInstruction(SInstruction *pTail, ULONG ulID)
{
    SInstruction *pInstruction = new SInstruction;

    pInstruction->ulID = ulID;
    pInstruction->pNext = NULL;
    INIT_RESULTS(pInstruction->ulTime);

    if (m_pHead == NULL)           // first instruction
    {
    	m_pHead = pTail = pInstruction;
    }
    else
    {
	pTail->pNext = pInstruction;
	pTail = pInstruction;
    }		      

    return pTail;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::GetNextLine, private
//
//  Synopsis:	Reads the next line from the file.
//		Returns E_FAIL on end of file
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::GetNextLine(LPTSTR pszLine)
{
#ifdef UNICODE
    CHAR szBuf[MAX_INSTR_LENGTH];

    if (fgets(szBuf, MAX_INSTR_LENGTH, m_fpIn) != NULL)
    {
    	mbstowcs(pszLine, szBuf, MAX_INSTR_LENGTH); 
    	return S_OK;
    }
#else
    if (fgets(pszLine, MAX_INSTR_LENGTH, m_fpIn) != NULL)
    {
    	return S_OK;
    }
#endif
    else
    	return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::ExecuteFile, private
//
//  Synopsis:	Loops throug the linked list execute each command, and 
//		recording timings.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::ExecuteFile()
{
    ULONG 	   iIter;
    SInstruction  *pInstr;

    for (iIter = 0; iIter < m_iIterations; iIter++)
    {
        pInstr = m_pHead;
	while (pInstr != NULL)
	{
	    if (!IsInternalID(pInstr->ulID))
	    	pInstr->ulTime[iIter] = m_pParser->ExecuteInstruction(pInstr->ulID);
	    pInstr = pInstr->pNext;
	}
    }

    return S_OK;
}



//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Report, public
//
//  Synopsis:	Loops throug the linked list, outputing timings of each command.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::Report (CTestOutput &output)
{
    SInstruction  *pInstr = m_pHead;

    output.WriteSectionHeader (Name(), SectionHeader(), *m_pInput);
    output.WriteString (TEXT("\n"));

    while (pInstr != NULL)
    {
    	if (pInstr->ulID == BLANK_LINE)
	    output.WriteString (TEXT("\n"));
	else
    	    output.WriteResults (m_pParser->InstructionName(pInstr->ulID), 
    			   	 m_iIterations, pInstr->ulTime);

	pInstr = pInstr->pNext;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bminput.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bminput.cxx
//
//  Contents:	input class for benchmark config
//
//  Classes:	CTestinput
//
//  Functions:	
//
//  History:    14-July-93 t-martig    Created
//		07-July-94 t-vadims    Added GetConfigInt and changed
// 				       GetIterations to use it.
//
//--------------------------------------------------------------------------
#include <benchmrk.hxx>
#include <bminput.hxx>

//+-------------------------------------------------------------------
//
//  Member:	CTestInput,public
//
//  Synopsis:	constructor for test input class
//
//+-------------------------------------------------------------------
CTestInput::CTestInput (LPTSTR lpszFileName)
{
	lstrcpy (m_szFileName, lpszFileName);
}


//+-------------------------------------------------------------------
//
//  Member:	GetConfigString,public
//
//  Synopsis:	returns profile string from specified section and
//		parameter.
//
//+-------------------------------------------------------------------
LPTSTR CTestInput::GetConfigString (LPTSTR lpszSection, LPTSTR lpszEntry,
				    LPTSTR lpszDefault, LPTSTR lpszDest,
				    DWORD dwLen)
{
	GetPrivateProfileString (lpszSection, lpszEntry, lpszDefault,
				  lpszDest, dwLen, m_szFileName);
	return lpszDest;
}

//+-------------------------------------------------------------------
//
//  Member:	GetConfigInt,public
//
//  Synopsis:	returns profile integer from specified section and
//		parameter.
//
//+-------------------------------------------------------------------
DWORD CTestInput::GetConfigInt (LPTSTR lpszSection, LPTSTR lpszEntry,
				DWORD dwDefault)
{
	return GetPrivateProfileInt (lpszSection, lpszEntry,
				      dwDefault, m_szFileName);
}

//+-------------------------------------------------------------------
//
//  Member: 	GetClassCtx,public
//
//  Synopsis:	Gets the custom class activation context from .ini
//		file (entry name = "ClsCtx")
//
//  Parameters: [lpszTestName]		Section under which "ClsCtx"
//					is listed
//
//  Returns:	CLSCTX_... mode according to entry:
//
//			"InProc"   CLSCTX_INPROC_SERVER
//			"Local"	   CLSCTX_LOCAL_SERVER,
//			"Handler"  CLSCTX_INPROC_HANDLER
//			any other  CLSCTX_INPROC_SERVER
//
//  History:   	12-July-93   t-martig	Created
//
//--------------------------------------------------------------------
DWORD CTestInput::GetClassCtx (LPTSTR lpszTestName)
{
	TCHAR szMode[50];
	int i;

	GetConfigString (lpszTestName, TEXT("ClsCtx"), TEXT("InProc"),
                    szMode, sizeof(szMode)/sizeof(TCHAR));

	i = 0;
	while (saModeNames[i])
	{
	    if (lstrcmpi (saModeNames[i], szMode) == 0)
		return dwaModes[i];
	    i++;
	}

	return dwaModes[0];
}


//+-------------------------------------------------------------------
//
//  Member:	GetOleInitFlag,public
//
//  Synopsis:	Gets OleInitialize flag
//
//  Parameters:
//
//  History:   	13-August-93   t-martig	Created
//
//--------------------------------------------------------------------
DWORD CTestInput::GetOleInitFlag(void)
{
	TCHAR szInitFlag[60];

	GetPrivateProfileString (TEXT("Driver"), TEXT("InitFlag"),
				  TEXT("COINIT_APARTMENTTHREADED"),
				  szInitFlag, sizeof(szInitFlag)/sizeof(TCHAR),
				  m_szFileName);

#ifdef THREADING_SUPPORT
	if (lstrlen(szInitFlag)==0)
	    return COINIT_APARTMENTTHREADED;

	if (!lstrcmpi(szInitFlag, TEXT("COINIT_MULTITHREADED")))
	    return COINIT_MULTITHREADED;
	else
#endif
	    return 2; // COINIT_APARTMENTTHREADED;
}


//+-------------------------------------------------------------------
//
//  Member:	GetInfoLevelFlag,public
//
//  Synopsis:	Gets InfoLevel flag
//
//  Parameters:
//
//  History:   	13-August-93   t-martig	Created
//
//--------------------------------------------------------------------
DWORD CTestInput::GetInfoLevelFlag(void)
{
	TCHAR szInfoFlag[60];

	GetPrivateProfileString (TEXT("Driver"), TEXT("InfoLevel"),
				  TEXT("BASE"),
				  szInfoFlag, sizeof(szInfoFlag)/sizeof(TCHAR),
				  m_szFileName);

	if (lstrlen(szInfoFlag)==0)
	    return 0;

	if (!lstrcmpi(szInfoFlag, TEXT("FULL")))
	    return 1;
	else
	    return 0;
}


//+-------------------------------------------------------------------
//
//  Member: 	GetGUID,public
//
//  Synopsis:	Gets GUID from .ini file
//
//  Parameters: [pClsID]		Address where to put class ID
//		[lpszTestName]		Section
//		[lpszEntry]		Entry name
//
//  History:   	13-August-93   t-martig	Created
//
//--------------------------------------------------------------------
SCODE CTestInput::GetGUID (CLSID *pClsID, LPTSTR lpszTestName,
			   LPTSTR lpszEntry)
{
	TCHAR szClsID[60];
    LPOLESTR lpszClsID;

	GetConfigString (lpszTestName, lpszEntry, TEXT(""),
                    szClsID, sizeof(szClsID)/sizeof(TCHAR));

	if (lstrlen(szClsID)==0)
	    return E_FAIL;
#ifdef UNICODE
    lpszClsID = szClsID;
#else
    OLECHAR szTmp[60];
    MultiByteToWideChar(CP_ACP, 0, szClsID, -1, szTmp, 60);
    lpszClsID = szTmp;
#endif

	return CLSIDFromString(lpszClsID, pClsID);
}



//+-------------------------------------------------------------------
//
//  Member: 	GetClassID,public
//
//  Synopsis:	Gets the custom class ID from .ini file
//		(entry name = "ClsID")
//
//  Parameters: [pClsID]		Address where to put class ID
//		[lpszTestName]		Section under which "ClsID"
//					is listed
//
//  History:   	13-July-93   t-martig	Created
//
//--------------------------------------------------------------------
SCODE CTestInput::GetClassID (CLSID *pClsID, LPTSTR lpszTestName)
{
	return GetGUID(pClsID, lpszTestName, TEXT("ClsID"));
}



//+-------------------------------------------------------------------
//
//  Member:	GetIterations, public
//
//  Synopsis:	returns the iteration count for the test. if out of
//		range, it returns either 1 or TEST_MAX_ITERATIONS.
//
//  History:	07-July-94  t-vadims  Modified to use new GetConfigInt function.
//
//+-------------------------------------------------------------------
DWORD CTestInput::GetIterations (LPTSTR lpszTestName, int iIterDefault)
{
	int iIterations;

	iIterations = GetConfigInt (lpszTestName, TEXT("Iterations"), iIterDefault);

	if (iIterations > TEST_MAX_ITERATIONS)
	    iIterations = TEST_MAX_ITERATIONS;

	return (iIterations > 0) ? iIterations : 1;
}


//+-------------------------------------------------------------------
//
//  Member:	GetRealIterations, public
//
//  Synopsis:	returns the iteration count for the test.  Does not
//		range check.
//
//  History:	07-July-94  t-vadims  Modified to use new GetConfigInt function.
//
//+-------------------------------------------------------------------
DWORD CTestInput::GetRealIterations (LPTSTR lpszTestName, int iIterDefault)
{
	int iIterations;

	iIterations = GetConfigInt (lpszTestName, TEXT("Iterations"), iIterDefault);

	return (iIterations > 0) ? iIterations : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\bm_base.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_base.cxx
//
//  Contents:	output class for benchmark results
//
//  Classes:	CTestBase
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bm_base.hxx>


SCODE CTestBase::Setup (CTestInput *pInput)
{
    m_pInput = pInput;

    // get the OleInitialize flag.
    m_dwInitFlag = m_pInput->GetOleInitFlag();

    return S_OK;
}


SCODE CTestBase::Cleanup ()
{
    return S_OK;
}


SCODE CTestBase::InitOLE()
{
    SCODE sc;

#ifdef OLE_THREADING_SUPPORT
    if (m_dwInitFlag == COINIT_MULTITHREADED)
    {
	// we are Cairo and want MULTI_THREADING, call OleInitEx
	sc = OleInitializeEx(NULL, m_dwInitFlag);
    }
    else
#endif // OLE_THREADING_SUPPORT
    {
	sc = OleInitialize(NULL);
    }

    return sc;
}

void CTestBase::UninitOLE()
{
    OleUninitialize();
}


SCODE CTestBase::InitCOM()
{
    SCODE sc;

#ifdef COM_THREADING_SUPPORT
    if (m_dwInitFlag == COINIT_MULTITHREADED)
    {
	// we are Cairo and want MULTI_THREADING, call OleInitEx
	sc = CoInitializeEx(NULL, m_dwInitFlag);
    }
    else
#endif // COM_THREADING_SUPPORT
    {
	sc = CoInitialize(NULL);
    }

    return sc;
}


void CTestBase::UninitCOM()
{
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\cqisrv.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cqi.cxx
//
//  Contents:	implementations for QueryInterface test
//
//  Functions:
//		CQI::CQI
//		CQI::~CQI
//		CQI::QueryInterface
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
#include    <headers.cxx>
#pragma     hdrstop
#include    <cqisrv.hxx>	 // class definition

//+-------------------------------------------------------------------------
//
//  Method:	CQI::CQI
//
//  Synopsis:	Creates an instance of CQI
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
CQI::CQI(void) : _cRefs(1)
{
}

CQI::~CQI(void)
{
    //	automatic actions are enough
}

//+-------------------------------------------------------------------------
//
//  Method:	CQI::AddRef/Release
//
//  Synopsis:	track reference counts
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CQI::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CQI::Release(void)
{
    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------------
//
//  Method:	CQI::QueryInterface
//
//  Synopsis:	returns ptr to requested interface.
//
//		DANGER: this returns SUCCESS on almost every interface,
//		though the only valid methods on any interface are IUnknown.
//
//  Arguments:	[riid] - interface instance requested
//		[ppv]  - where to put pointer to interface instance
//
//  Returns:	S_OK or E_NOINTERFACE
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CQI::QueryInterface(REFIID riid, void **ppv)
{
    //	the interface cant be one of these or marshalling will fail.

    if (IsEqualIID(riid,IID_IUnknown) ||
	IsEqualIID(riid,IID_IAdviseSink) ||
	IsEqualIID(riid,IID_IDataObject) ||
	IsEqualIID(riid,IID_IOleObject) ||
	IsEqualIID(riid,IID_IOleClientSite) ||
	IsEqualIID(riid,IID_IParseDisplayName) ||
	IsEqualIID(riid,IID_IPersistStorage) ||
	IsEqualIID(riid,IID_IPersistFile) ||
	IsEqualIID(riid,IID_IStorage) ||
	IsEqualIID(riid,IID_IOleContainer) ||
	IsEqualIID(riid,IID_IOleItemContainer) ||
	IsEqualIID(riid,IID_IOleInPlaceSite) ||
	IsEqualIID(riid,IID_IOleInPlaceActiveObject) ||
	IsEqualIID(riid,IID_IOleInPlaceObject) ||
	IsEqualIID(riid,IID_IOleInPlaceUIWindow) ||
	IsEqualIID(riid,IID_IOleInPlaceFrame) ||
	IsEqualIID(riid,IID_IOleWindow))
    {
	*ppv = (void *)(IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else
    {
	*ppv = NULL;
	return E_NOINTERFACE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\rawrpc.h ===
#ifndef __RAWRPC_H__
#define __RAWRPC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define small char

#include "rpc.h"
#include "rpcndr.h"



#include "wtypes.h"

extern RPC_IF_HANDLE IRawRpc_ServerIfHandle;

extern RPC_IF_HANDLE IRawRpc_ClientIfHandle;

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

SCODE Quit(
	handle_t hRpc);
void Void(
	handle_t hRpc);
SCODE VoidRC(
	handle_t hRpc);
SCODE VoidPtrIn(
	handle_t hRpc,
	ULONG cb,
	void *pv);
SCODE VoidPtrOut(
	handle_t hRpc,
	ULONG cb,
	ULONG *pcb,
	void *pv);
SCODE DwordIn(
	handle_t hRpc,
	DWORD dw);
SCODE DwordOut(
	handle_t hRpc,
	DWORD *pdw);
SCODE DwordInOut(
	handle_t hRpc,
	DWORD *pdw);
SCODE LiIn(
	handle_t hRpc,
	LARGE_INTEGER li);
SCODE LiOut(
	handle_t hRpc,
	LARGE_INTEGER *pli);
SCODE ULiIn(
	handle_t hRpc,
	ULARGE_INTEGER uli);
SCODE ULiOut(
	handle_t hRpc,
	ULARGE_INTEGER *puli);
SCODE StringIn(
	handle_t hRpc,
	LPWSTR pwsz);
SCODE StringOut(
	handle_t hRpc,
	LPWSTR *ppwsz);
SCODE StringInOut(
	handle_t hRpc,
	LPWSTR pwsz);
SCODE GuidIn(
	handle_t hRpc,
	GUID guid);
SCODE GuidOut(
	handle_t hRpc,
	GUID *pguid);

#if !defined(IMPORT_USED_MULTIPLE) && !defined(IMPORT_USED_SINGLE)

#endif /*!defined(IMPORT_USED_MULTIPLE) && !defined(IMPORT_USED_SINGLE)*/

typedef struct _IRawRpc_SERVER_EPV
  {
  SCODE (__RPC_FAR * Quit)(
	handle_t hRpc);
  void (__RPC_FAR * Void)(
	handle_t hRpc);
  SCODE (__RPC_FAR * VoidRC)(
	handle_t hRpc);
  SCODE (__RPC_FAR * VoidPtrIn)(
	handle_t hRpc,
	ULONG cb,
	void *pv);
  SCODE (__RPC_FAR * VoidPtrOut)(
	handle_t hRpc,
	ULONG cb,
	ULONG *pcb,
	void *pv);
  SCODE (__RPC_FAR * DwordIn)(
	handle_t hRpc,
	DWORD dw);
  SCODE (__RPC_FAR * DwordOut)(
	handle_t hRpc,
	DWORD *pdw);
  SCODE (__RPC_FAR * DwordInOut)(
	handle_t hRpc,
	DWORD *pdw);
  SCODE (__RPC_FAR * LiIn)(
	handle_t hRpc,
	LARGE_INTEGER li);
  SCODE (__RPC_FAR * LiOut)(
	handle_t hRpc,
	LARGE_INTEGER *pli);
  SCODE (__RPC_FAR * ULiIn)(
	handle_t hRpc,
	ULARGE_INTEGER uli);
  SCODE (__RPC_FAR * ULiOut)(
	handle_t hRpc,
	ULARGE_INTEGER *puli);
  SCODE (__RPC_FAR * StringIn)(
	handle_t hRpc,
	LPWSTR pwsz);
  SCODE (__RPC_FAR * StringOut)(
	handle_t hRpc,
	LPWSTR *ppwsz);
  SCODE (__RPC_FAR * StringInOut)(
	handle_t hRpc,
	LPWSTR pwsz);
  SCODE (__RPC_FAR * GuidIn)(
	handle_t hRpc,
	GUID guid);
  SCODE (__RPC_FAR * GuidOut)(
	handle_t hRpc,
	GUID *pguid);
  }
IRawRpc_SERVER_EPV;
void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t);
void __RPC_API MIDL_user_free(void __RPC_FAR *);
#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\common\stopwtch.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	stopwtch.cxx
//
//  Contents:	StopWatch timer
//
//  Classes:	CStopWatch
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------

extern "C" 
{
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
};
#include <windows.h>
#include <stopwtch.hxx>


//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Resolution, public
//
//  Synopsis:	Inquires performance timer resolution
//
//	Returns:	Performance counter ticks / second
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------
CStopWatch::CStopWatch ()
{
	QueryPerformanceFrequency (&liFreq);
}

//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Reset, public
//
//  Synopsis:	Starts measurement cycle
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CStopWatch::Reset ()
{
	QueryPerformanceCounter (&liStart); // BUGBUG - test for error !
}


//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Read, public
//
//  Synopsis:	Reads stop watch timer
//
//  Returns:	Time since call of CStopWatch::Reset (in microseconds)
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------
	
ULONG CStopWatch::Read ()
{
	LARGE_INTEGER liNow, liDelta, liRemainder;

	QueryPerformanceCounter (&liNow);	// BUGBUG - test for error
   
	liDelta = RtlLargeIntegerSubtract (liNow, liStart);
	liDelta = RtlExtendedIntegerMultiply (liDelta, 1000000);
	liDelta = RtlLargeIntegerDivide (liDelta, liFreq, &liRemainder);

	return liDelta.LowPart;
}


//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Resolution, public
//
//  Synopsis:	Inquires performance timer resolution
//
//	Returns:	Performance counter ticks / second
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

ULONG CStopWatch::Resolution ()
{
	return liFreq.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\rawrpc\rawrpc_y.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\driver\bmguid.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmguid.cxx
//
//  Contents:	OLE test guids
//
//  Classes:	
//
//  Functions:	
//
//  History:    12-August-93 t-martig    Created
//
//--------------------------------------------------------------------------


#define INITGUID
#include "windows.h"

#ifdef _NTIDW340
// Handle port problems easily
// #define WIN32

#ifdef __cplusplus
// PORT: Handle the fact that jmp_buf doesn't make any sense in cpp.
#define jmp_buf int
#endif // __cplusplus
#endif // _NTIDW340

// PORT: HTASK no longer seems to be defined in Win32
#define HTASK DWORD
#define HINSTANCE_ERROR 32
#define __loadds
#define __segname
#define BASED_CODE
#define HUGE
#define _ffree free
#define __based(x)
#include <port1632.h>

DEFINE_OLEGUID(CLSID_COleTestClass,  0x20730701, 1, 8);	    // CT Test GUID
DEFINE_OLEGUID(CLSID_COleTestClass2, 0x20730712, 1, 8);	    // CT Test GUID                          
DEFINE_OLEGUID(CLSID_TestProp,	     0x20730722, 1, 8);	    // CT Test GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\driver\bmdriver.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmdriver.cxx
//
//  Contents:	Main module of the benchmark test
//
//  Classes:	CBenchMarkDriver
//
//  Functions:	WinMain
//
//  History:    30-June-93 t-martig    Created
//		        07-June-94 t-vadims    Added Storage tests
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmdriver.hxx>

#include <bm_activ.hxx>
#include <bm_alloc.hxx>
#include <bm_api.hxx>
#include <bm_cgps.hxx>
#include <bm_iid.hxx>
#include <bm_init.hxx>
#include <bm_marsh.hxx>
#include <bm_mrsh2.hxx>
#include <bm_noise.hxx>
#include <bm_nest.hxx>
#include <bm_obind.hxx>
#include <bm_props.hxx>
#include <bm_qi.hxx>
#include <bm_regis.hxx>
#include <bm_rot.hxx>
#include <bm_rpc.hxx>
#include <bm_rpc2.hxx>
#include <bm_rrpc.hxx>
#include <bm_sbind.hxx>
#include <bm_filio.hxx>
#include <bm_stg.hxx>
#include <bm_nstg.hxx>
#include <bmp_stg.hxx>
#include "..\cairole\ui\hlp_iocs.hxx"
#include "..\cairole\ui\hlp_ias.hxx"
#include "..\cairole\ui\hlp_site.hxx"
#include "..\cairole\ui\hlp_doc.hxx"
#include "..\cairole\ui\bm_crt.hxx"
#include "..\cairole\ui\bm_crtl.hxx"
//#include "..\cairole\ui\bm_clip.hxx"
#include "..\cairole\ui\bm_load.hxx"
#include "..\cairole\ui\bm_link.hxx"
#include "..\cairole\ui\bm_cache.hxx"


#define REGISTRY_ENTRY_LEN 256

typedef struct
{
  const char *key;
  const char *value;
} RegistryKeyValue;

const RegistryKeyValue REG_CONST_KEY[] =
{
  ".bm1", "CLSID\\{99999999-0000-0008-C000-000000000052}",
  ".bm2", "CLSID\\{99999999-0000-0008-C000-000000000051}",

  "CLSID\\{20730701-0001-0008-C000-000000000046}", "OleTestClass",
  "CLSID\\{20730711-0001-0008-C000-000000000046}", "OleTestClass1",
  "CLSID\\{20730712-0001-0008-C000-000000000046}", "OleTestClass2",
  "CLSID\\{20730713-0001-0008-C000-000000000046}", "OleTestClass3",
  "CLSID\\{20730714-0001-0008-C000-000000000046}", "OleTestClass4",
  "CLSID\\{20730715-0001-0008-C000-000000000046}", "OleTestClass5",
  "CLSID\\{20730716-0001-0008-C000-000000000046}", "OleTestClass6",
  "CLSID\\{20730717-0001-0008-C000-000000000046}", "OleTestClass7",
  "CLSID\\{20730718-0001-0008-C000-000000000046}", "OleTestClass8",

  "CLSID\\{00000138-0001-0008-C000-000000000046}", "CPrxyBalls",
  "Interface\\{00000138-0001-0008-C000-000000000046}", "IBalls",
  "Interface\\{00000139-0001-0008-C000-000000000046}", "ICube",
  "Interface\\{00000136-0001-0008-C000-000000000046}", "ILoops",
  "Interface\\{00000137-0001-0008-C000-000000000046}", "IRpcTest",

  "Interface\\{00000138-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000136-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000137-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "CLSID\\{0000013a-0001-0008-C000-000000000046}\\ProgID", "ProgID60",
  "CLSID\\{0000013a-0001-0008-C000-000000000046}", "CBallsClassFactory",
  "CLSID\\{0000013b-0001-0008-C000-000000000046}", "CCubesClassFactory",
  "CLSID\\{0000013c-0001-0008-C000-000000000046}", "CLoopClassFactory",
  "CLSID\\{0000013d-0001-0008-C000-000000000046}", "CRpcTestClassFactory",
  "CLSID\\{00000140-0000-0008-C000-000000000046}", "CQueryInterface",
  "CLSID\\{00000142-0000-0008-C000-000000000046}", "Dummy",


  ".ut4", "ProgID50",
  ".ut5", "ProgID51",
  ".ut6", "ProgID52",
  ".ut7", "ProgID53",
  ".ut8", "ProgID54",
  ".ut9", "ProgID55",
  ".bls", "ProgID60",

  "CLSID\\{99999999-0000-0008-C000-000000000050}", "SDI",
  "CLSID\\{99999999-0000-0008-C000-000000000051}", "MDI",
  "CLSID\\{99999999-0000-0008-C000-000000000052}", "InprocNoRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000053}", "InprocRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000054}", "InprocRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000054}\\TreatAs", "{99999999-0000-0008-C000-000000000050}",
  "CLSID\\{99999999-0000-0008-C000-000000000055}", "MDI",
  "CLSID\\{99999999-0000-0008-C000-000000000055}\\ActivateAtBits", "Y",

  "ProgID50", "objact sdi",
  "ProgID50\\CLSID", "{99999999-0000-0008-C000-000000000050}",
  "ProgID51", "objact mdi",
  "ProgID51\\CLSID", "{99999999-0000-0008-C000-000000000051}",
  "ProgID52", "objact dll",
  "ProgID52\\CLSID", "{99999999-0000-0008-C000-000000000052}",
  "ProgID53", "objact dll reg",
  "ProgID53\\CLSID", "{99999999-0000-0008-C000-000000000053}",
  "ProgID54", "objact dll reg",
  "ProgID54\\CLSID", "{99999999-0000-0008-C000-000000000054}",
  "ProgID55", "remote activation",
  "ProgID55\\CLSID", "{99999999-0000-0008-C000-000000000055}",
  "ProgID60", "CLSIDFromProgID test",
  "ProgID60\\CLSID", "{0000013a-0001-0008-C000-000000000046}",

  // Indicates end of list.
  "", ""
};

const RegistryKeyValue REG_EXE_KEY[] =
{
  "CLSID\\{20730701-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730711-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730712-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730713-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730714-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730715-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730716-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730717-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730718-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",

  "CLSID\\{20730712-0001-0008-C000-000000000046}\\LocalServer32", "bmtstsvr.exe",
  "CLSID\\{20730701-0001-0008-C000-000000000046}\\LocalServer32", "bmtstsvr.exe",

  "CLSID\\{0000013a-0001-0008-C000-000000000046}\\LocalServer32", "ballsrv.exe",
  "CLSID\\{00000138-0001-0008-C000-000000000046}\\InprocServer32", "iballs.dll",
  "CLSID\\{0000013b-0001-0008-C000-000000000046}\\LocalServer32", "cubesrv.exe",
  "CLSID\\{0000013c-0001-0008-C000-000000000046}\\LocalServer32", "loopsrv.exe",
  "CLSID\\{0000013d-0001-0008-C000-000000000046}\\LocalServer32", "rpctst.exe",
  "CLSID\\{00000140-0000-0008-C000-000000000046}\\LocalServer32", "qisrv.exe",
  "CLSID\\{00000140-0000-0008-C000-000000000046}\\InprocServer32", "qisrv.dll",
  "CLSID\\{00000142-0000-0008-C000-000000000046}\\InprocServer32", "ballsrv.dll",


  "CLSID\\{99999999-0000-0008-C000-000000000050}\\LocalServer32", "sdi.exe",
  "CLSID\\{99999999-0000-0008-C000-000000000051}\\LocalServer32", "mdi.exe",
  "CLSID\\{99999999-0000-0008-C000-000000000052}\\InprocServer32", "dlltest.dll",
  "CLSID\\{99999999-0000-0008-C000-000000000053}\\InprocServer32", "dlltest.dll",
  "CLSID\\{99999999-0000-0008-C000-000000000055}\\LocalServer32", "db.exe",

  // Indicates end of list.
  "", ""
};

DWORD g_fFullInfo = 0;		    //	write full info or not
DWORD g_dwPauseBetweenTests = 0;    //	time delay between running tests



//+-------------------------------------------------------------------
//
//  Member: 	CBenchMarkDriver::RunTest, public
//
//  Synopsis:	Sets up, runs, reports and cleans up test procedure
//		of specified class
//
//  Parameters: [output]	Output class for results
//		[pTest]		Test object
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------
	
SCODE CBenchMarkDriver::RunTest (CTestInput  &input,
				 CTestOutput &output, CTestBase *pTest)
{
	TCHAR szConfigString[80];
	SCODE sc;

	input.GetConfigString (TEXT("Tests"), pTest->Name(),
			       TEXT("OFF"), szConfigString, 80);

	if (lstrcmpi (szConfigString, TEXT("OFF")) != 0 &&
	    lstrcmpi (szConfigString, TEXT("FALSE")) != 0)
	{
		LogSection (pTest->Name());

		sc=pTest->Setup(&input);
		if (FAILED(sc))
		    return sc;

		//  pause between test invocations
		Sleep(g_dwPauseBetweenTests);

		sc = pTest->Run();
		pTest->Report(output);
		pTest->Cleanup();

		if (FAILED(sc))
		{
		    output.WriteString (TEXT("\nStatus:\tERROR, see log file\n"));
		}

		//  pause between test invocations
		Sleep(g_dwPauseBetweenTests);
    }

	return sc;
}


//+-------------------------------------------------------------------
//
//  Member: 	CBenchMarkDriver::WriteHeader, public
//
//  Synopsis:	Prints test form header into output file
//
//  History:   	5-August-93 	  t-martig	Created
//
//--------------------------------------------------------------------

void CBenchMarkDriver::WriteHeader (CTestInput &input, CTestOutput &output)
{
	_SYSTEMTIME stTimeDate;

	output.WriteString (TEXT("CairOLE Benchmarks\n"));
	output.WriteConfigEntry (input, TEXT("Driver"), TEXT("Tester"), TEXT(""));
	GetLocalTime (&stTimeDate);
	output.WriteDate (&stTimeDate);
	output.WriteString (TEXT("\t"));
	output.WriteTime (&stTimeDate);
	output.WriteString (TEXT("\n\n"));
}	


//+-------------------------------------------------------------------
//
//  Member: 	CBenchMarkDriver::Run, public
//
//  Synopsis:	Runs all tests specified in .ini file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

#define RUN_TEST(CMyTestClass)		 \
{					 \
	CTestBase *pTest;		 \
	pTest = new CMyTestClass;	 \
	RunTest (input, output, pTest);  \
	delete pTest;			 \
	output.Flush();			 \
}


SCODE CBenchMarkDriver::Run (LPSTR lpCmdLine)
{
	TCHAR szBenchMarkIniFile[MAX_PATH];
	TCHAR szOutputFileName[MAX_PATH];
	TCHAR szLogFileName[MAX_PATH];
	TCHAR szTemp[MAX_PATH];


	//  Get file name of .ini file. if not specified in the command
	//  line, use the default BM.INI in the local directory

	GetCurrentDirectory (MAX_PATH, szTemp);

	lstrcpy(szBenchMarkIniFile, szTemp);
	lstrcat (szBenchMarkIniFile, TEXT("\\BM.INI"));

	//  create the names for the temporary files. uses pid.xxx. Its the
	//  current directory appended with the pid and a file extension.
	OLECHAR	szPid[9];
	DWORD pid = GetCurrentProcessId();
	CHAR	aszPid[9];
	_itoa(pid, aszPid, 16);
	mbstowcs(szPid, aszPid, strlen(aszPid)+1);

#ifdef UNICODE
	wcscpy(aszPerstName[0], szTemp);
#else
	mbstowcs(aszPerstName[0], szTemp, strlen(szTemp)+1);
#endif
	wcscat(aszPerstName[0], L"\\");
	wcscat(aszPerstName[0], szPid);

	wcscpy(aszPerstName[1],    aszPerstName[0]);
	wcscpy(aszPerstNameNew[0], aszPerstName[0]);
	wcscpy(aszPerstNameNew[1], aszPerstName[0]);

	wcscat(aszPerstName[0],    L".BM1");
	wcscat(aszPerstNameNew[0], L"NEW.BM1");
	wcscat(aszPerstName[1],    L".BM2");
	wcscat(aszPerstNameNew[1], L"NEW.BM2");



	// Define input, output and log file

	CTestInput input (szBenchMarkIniFile);
	CTestOutput output (input.GetConfigString (TEXT("Driver"), TEXT("Report"),
		TEXT("BM.RES"), szOutputFileName, MAX_PATH));
	CTestOutput log (input.GetConfigString (TEXT("Driver"), TEXT("Log"),
		TEXT("BM.LOG"), szLogFileName, MAX_PATH));

	LogTo (&log);


	//  Get the pause time between test invocations

	g_dwPauseBetweenTests = input.GetConfigInt (TEXT("Driver"),
                                                TEXT("PauseBetweenTests"),
                                                2000);

	// Get global info level flag

	g_fFullInfo = input.GetInfoLevelFlag();


	// Write the correct OleInitialize flag to win.ini for the various
	// OLE servers to use, based on the init flag in bm.ini.

	LPTSTR pszOleInit;
#ifdef THREADING_SUPPORT
	if (input.GetOleInitFlag() == COINIT_MULTITHREADED)
	{
//	    pszOleInit = TEXT("MultiThreaded");
	}
	else
#endif
	{
//	    pszOleInit = TEXT("ApartmentThreaded");
	}

//	WriteProfileString(TEXT("TestSrv"), TEXT("ThreadMode"), pszOleInit);
//	WriteProfileString(TEXT("OleSrv"), TEXT("ThreadMode"), pszOleInit);


	// Write header and configuration info

	WriteHeader (input, output);
	ReportBMConfig (input, output);


	// Run all the tests
	// To add tests, use macro RUN_TEST, the parameter is the name of
	// the test class. Be sure to include a sction called [<TestClass>] in
	// the BM.INI file, as well as a switch under the [Tests] section
	// (<TestClass> = ON, e.g.)

	Sleep(1000);

	RUN_TEST (COleMarshalTest2);
	RUN_TEST (CNoiseTest);
	RUN_TEST (CRawRpc);		// NOTE: must come before any OLE tests
	RUN_TEST (COleInitializeTest);
	RUN_TEST (COleRegistrationTest);
	RUN_TEST (COleActivationTest);
	RUN_TEST (CFileMonikerStorageBindTest);
	RUN_TEST (CFileMonikerObjBindTest);
	RUN_TEST (CROTTest);
	RUN_TEST (COlePropertyTest);
	RUN_TEST (COleMarshalTest);
	RUN_TEST (CRpcTest);
	RUN_TEST (CRpcTest2);
	RUN_TEST (CNestTest);
	RUN_TEST (CQueryInterfaceTest);
	RUN_TEST (CApiTest);
	RUN_TEST (CCGPSTest);
	RUN_TEST (COleAllocTest);
	RUN_TEST (CGuidCompareTest);
	RUN_TEST (CFileIOTest);
	RUN_TEST (CStorageTest);
	RUN_TEST (CNestedStorageTest);
	RUN_TEST (CStorageParserTest);

	//Upper layer tests
	RUN_TEST (CCreateTest);
	RUN_TEST (CCreateLinkTest);
//	RUN_TEST (CClipbrdTest);
	RUN_TEST (COleLoadTest);
	RUN_TEST (CIOLTest);
	RUN_TEST (COleCacheTest);


	return S_OK;
}


//+-------------------------------------------------------------------
//
//  Function: 	RegistrySetup
//
//  Synopsis:	If the registry entries for this program are not set,
//              write them
//
//  Note:       This function uses all Ascii characters and character
//              arithmatic because it has to run on NT and Chicago.
//
//  History:   	16 Dec 94	AlexMit		Created
//
//--------------------------------------------------------------------

BOOL RegistrySetup()
{
    char value[REGISTRY_ENTRY_LEN];
    LONG  value_size;
    LONG  result;
    char  directory[MAX_PATH];
    char *appname;
    BOOL  success = FALSE;

    // Write constant entries.
    for (int i = 0; REG_CONST_KEY[i].key[0] != '\0'; i++)
    {
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_CONST_KEY[i].key,
                 REG_SZ,
                 REG_CONST_KEY[i].value,
                 strlen(REG_CONST_KEY[i].value) );

        if (result != ERROR_SUCCESS)
	        goto cleanup;
    }

    // Compute the path to the application.
    result = GetFullPathNameA("benchmrk", sizeof(directory), directory, &appname);
    if (result == 0)
        goto cleanup;

    // Add the path to all the dll and exe entries.
    for (i = 0; REG_EXE_KEY[i].key[0] != '\0'; i++)
    {
        // Verify that the path will fit in the buffer and compute the path
        // to the next executable.
        if (strlen(REG_EXE_KEY[i].value) >=
            (ULONG)(MAX_PATH - (appname - directory)))
	        goto cleanup;

        strcpy(appname, REG_EXE_KEY[i].value);

        // Write the next entry.
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_EXE_KEY[i].key,
                 REG_SZ,
                 directory,
                 strlen(directory));

        if (result != ERROR_SUCCESS)
	        goto cleanup;
    }

    success = TRUE;

cleanup:
    return success;
}

//+-------------------------------------------------------------------
//
//  Function: 	WinMain
//
//  Synopsis:	Program entry point, starts benchmark driver
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CBenchMarkDriver driver;

    if (!_stricmp(lpCmdLine, "/r") || !_stricmp(lpCmdLine, "-r"))
    {
        if (!RegistrySetup())
        {
            printf("Registry Updated\n");
            return 0;
        }
        else
        {
            printf("Registry Update Failed\n");
            return 1;
        }
    }

    driver.Run (lpCmdLine);
    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\le\create\ocperf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  	ocperf.cpp
//
//  Contents: 	OleCreate performance test
//
//  Classes: 	CBareServer
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		01-Jan-95 alexgo    author
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <initguid.h>

DEFINE_GUID(CLSID_BareServer, 0xce3d5220, 0x25fa, 0x11ce, 0x90, 0xeb, 0x00,
0x00, 0x4c, 0x75, 0x2a, 0x63);

class CBareServer : public IOleObject, public IDataObject,
	public IPersistStorage
{

public:

    // IUnknown methods

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IDataObject methods

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
	    LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink,
            DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);

    // IOleObject methods

    STDMETHOD(SetClientSite) ( LPOLECLIENTSITE pClientSite);
    STDMETHOD(GetClientSite) ( LPOLECLIENTSITE FAR* ppClientSite);
    STDMETHOD(SetHostNames) ( LPCOLESTR szContainerApp,
		LPCOLESTR szContainerObj);
    STDMETHOD(Close) ( DWORD reserved);
    STDMETHOD(SetMoniker) ( DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHOD(GetMoniker) ( DWORD dwAssign, DWORD dwWhichMoniker,
		LPMONIKER FAR* ppmk);
    STDMETHOD(InitFromData) ( LPDATAOBJECT pDataObject,
		BOOL fCreation,
		DWORD dwReserved);
    STDMETHOD(GetClipboardData) ( DWORD dwReserved,
		LPDATAOBJECT FAR* ppDataObject);
    STDMETHOD(DoVerb) ( LONG iVerb,
		LPMSG lpmsg,
		LPOLECLIENTSITE pActiveSite,
		LONG lindex,
		HWND hwndParent,
		const RECT FAR* lprcPosRect);
    STDMETHOD(EnumVerbs) ( IEnumOLEVERB FAR* FAR* ppenumOleVerb);
    STDMETHOD(Update) (void);
    STDMETHOD(IsUpToDate) (void);
    STDMETHOD(GetUserClassID) ( CLSID FAR* pClsid);
    STDMETHOD(GetUserType) ( DWORD dwFormOfType,
		LPOLESTR FAR* pszUserType);
    STDMETHOD(SetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(GetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(Advise)(IAdviseSink FAR* pAdvSink,
		DWORD FAR* pdwConnection);
    STDMETHOD(Unadvise)( DWORD dwConnection);
    STDMETHOD(EnumAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);
    STDMETHOD(GetMiscStatus) ( DWORD dwAspect,
		DWORD FAR* pdwStatus);
    STDMETHOD(SetColorScheme) ( LPLOGPALETTE lpLogpal);

    // IPeristStorage methods

    STDMETHOD(GetClassID) ( LPCLSID pClassID);
    STDMETHOD(IsDirty) (void);
    STDMETHOD(InitNew) ( LPSTORAGE pstg);
    STDMETHOD(Load) ( LPSTORAGE pstg);
    STDMETHOD(Save) ( LPSTORAGE pstgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted) ( LPSTORAGE pstgNew);
    STDMETHOD(HandsOffStorage) ( void);


    CBareServer();

private:

    ~CBareServer();

    ULONG		_cRefs;
    IStorage *		_pstg;
    IOleClientSite *	_pclientsite;
    IOleAdviseHolder *	_poaholder;

};

CBareServer::CBareServer()
{
    _cRefs = 1;
    _pstg  = NULL;
    _pclientsite = NULL;
    _poaholder = NULL;
}

CBareServer::~CBareServer()
{
    if( _poaholder )
    {
	_poaholder->Release();
	_poaholder = NULL;
    }

    if( _pclientsite )
    {
	_pclientsite->Release();
	_pclientsite = NULL;
    }
	
    if( _pstg )
    {
	_pstg->Release();
	_pstg = NULL;
    }
}

// IUnknown methods

STDMETHODIMP CBareServer::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hresult = NOERROR;

    if( IsEqualIID(riid, IID_IUnknown) )
    {
	*ppvObj = (void *)(IOleObject *)this;
    }
    else if( IsEqualIID(riid, IID_IOleObject) )
    {
	*ppvObj = (void *)(IOleObject *)this;
    }
    else if( IsEqualIID(riid, IID_IDataObject) )
    {
	*ppvObj = (void *)(IDataObject *)this;
    }
    else if( IsEqualIID(riid, IID_IPersistStorage) )
    {
	*ppvObj = (void *)(IPersistStorage *)this;
    }
    else
    {
	hresult = E_NOINTERFACE;
	*ppvObj = NULL;
    }

    if( hresult == NOERROR )
    {
	AddRef();
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CBareServer::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CBareServer::Release(void)
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}	

// IDataObject methods

STDMETHODIMP CBareServer::GetData ( LPFORMATETC pformatetcIn,
	LPSTGMEDIUM pmedium )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::GetDataHere ( LPFORMATETC pformatetc,
	LPSTGMEDIUM pmedium )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::QueryGetData ( LPFORMATETC pformatetc )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::GetCanonicalFormatEtc ( LPFORMATETC pformatetc,
	LPFORMATETC pformatetcOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::SetData ( LPFORMATETC pformatetc,
	LPSTGMEDIUM pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::EnumFormatEtc ( DWORD dwDirection,
	LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    *ppenumFormatEtc = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::DAdvise ( FORMATETC FAR* pFormatetc, DWORD advf,
	IAdviseSink FAR* pAdvSink,
	DWORD FAR* pdwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::DUnadvise ( DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::EnumDAdvise ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    return E_NOTIMPL;
}

// IOleObject methods

STDMETHODIMP CBareServer::SetClientSite ( LPOLECLIENTSITE pClientSite)
{
    _pclientsite = pClientSite;
    _pclientsite->AddRef();

    return NOERROR;
}

STDMETHODIMP CBareServer::GetClientSite ( LPOLECLIENTSITE FAR* ppClientSite)
{
    return E_NOTIMPL;
}


STDMETHODIMP CBareServer::SetHostNames ( LPCOLESTR szContainerApp,
	    LPCOLESTR szContainerObj)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::Close ( DWORD reserved)
{
    printf("close called\n");

    if( _poaholder )
    {
	_poaholder->SendOnClose();
    }

    CoDisconnectObject((IOleObject *)this, 0);

    return NOERROR;
}

STDMETHODIMP CBareServer::SetMoniker ( DWORD dwWhichMoniker, LPMONIKER pmk)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::GetMoniker ( DWORD dwAssign, DWORD dwWhichMoniker,
	    LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::InitFromData ( LPDATAOBJECT pDataObject,
	    BOOL fCreation,
	    DWORD dwReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::GetClipboardData ( DWORD dwReserved,
	    LPDATAOBJECT FAR* ppDataObject)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::DoVerb ( LONG iVerb,
	    LPMSG lpmsg,
	    LPOLECLIENTSITE pActiveSite,
	    LONG lindex,
	    HWND hwndParent,
	    const RECT FAR* lprcPosRect)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::EnumVerbs ( IEnumOLEVERB FAR* FAR* ppenumOleVerb)
{
    return OLE_S_USEREG;
}

STDMETHODIMP CBareServer::Update (void)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::IsUpToDate (void)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::GetUserClassID ( CLSID FAR* pClsid)
{
    *pClsid = CLSID_BareServer;

    return NOERROR;
}

STDMETHODIMP CBareServer::GetUserType ( DWORD dwFormOfType,
	    LPOLESTR FAR* pszUserType)
{
    return OLE_S_USEREG;
}

STDMETHODIMP CBareServer::SetExtent ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::GetExtent ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::Advise (IAdviseSink FAR* pAdvSink,
	    DWORD FAR* pdwConnection)
{

    printf("Advise called\n");

    HRESULT hresult;

    if( !_poaholder )
    {	
	hresult = CreateOleAdviseHolder(&_poaholder);
    }

    if( _poaholder )
    {
	hresult = _poaholder->Advise(pAdvSink, pdwConnection);
    }

    return hresult;
}

STDMETHODIMP CBareServer::Unadvise ( DWORD dwConnection)
{
    if( _poaholder )
    {
	return _poaholder->Unadvise(dwConnection);
    }

    return E_FAIL;
}

STDMETHODIMP CBareServer::EnumAdvise ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    if( _poaholder )
    {
	return _poaholder->EnumAdvise(ppenumAdvise);
    }

    return E_FAIL;
}

STDMETHODIMP CBareServer::GetMiscStatus ( DWORD dwAspect,
	    DWORD FAR* pdwStatus)
{
    return OLE_S_USEREG;
}

STDMETHODIMP CBareServer::SetColorScheme ( LPLOGPALETTE lpLogpal)
{
    return NOERROR;
}


// IPeristStorage methods

STDMETHODIMP CBareServer::GetClassID ( LPCLSID pClassID)
{
    *pClassID = CLSID_BareServer;

    return NOERROR;
}

STDMETHODIMP CBareServer::IsDirty (void)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::InitNew ( LPSTORAGE pstg)
{
    printf("InitNew called\n");

    _pstg = pstg;
    _pstg->AddRef();

    return NOERROR;
}

STDMETHODIMP CBareServer::Load ( LPSTORAGE pstg)
{
    _pstg = pstg;
    _pstg->AddRef();

    return NOERROR;
}

STDMETHODIMP CBareServer::Save ( LPSTORAGE pstgSave, BOOL fSameAsLoad)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::SaveCompleted ( LPSTORAGE pstgNew)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::HandsOffStorage ( void)
{
    _pstg->Release();
    _pstg = NULL;

    return NOERROR;
}


// class factory

class CBareFactory : public IClassFactory
{

public:
    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);
    STDMETHOD(CreateInstance) (LPUNKNOWN pUnkOuter, REFIID iid,
				    LPVOID FAR* ppv);
    STDMETHOD(LockServer) ( BOOL fLock );

    CBareFactory();

private:
    ULONG		_cRefs;
};

CBareFactory::CBareFactory()
{
    _cRefs = 1;
}

STDMETHODIMP CBareFactory::QueryInterface (REFIID iid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(iid, IID_IClassFactory) ||
	IsEqualIID(iid, IID_IUnknown) )
    {
	*ppvObj = this;
	AddRef();
	return NOERROR;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBareFactory::AddRef (void)
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CBareFactory::Release (void)
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

STDMETHODIMP CBareFactory::CreateInstance (LPUNKNOWN pUnkOuter, REFIID iid,
				LPVOID FAR* ppv)
{
    *ppv = (IOleObject *)new CBareServer();

    return NOERROR;
}

STDMETHODIMP CBareFactory::LockServer ( BOOL fLock )
{
    return NOERROR;
}

// Client Site

class CBareClientSite : public IOleClientSite
{
public:

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject)();
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker,
                            LPMONIKER FAR* ppmk);
    STDMETHOD(GetContainer)(LPOLECONTAINER FAR* ppContainer);
    STDMETHOD(ShowObject)();
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)();

    CBareClientSite();

private:

    ULONG	_cRefs;
};

CBareClientSite::CBareClientSite()
{
    _cRefs = 1;
}

STDMETHODIMP CBareClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IOleClientSite) )
    {
	*ppvObj = this;
	AddRef();
	return NOERROR;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBareClientSite::AddRef()
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CBareClientSite::Release()
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

// *** IOleClientSite methods ***
STDMETHODIMP CBareClientSite::SaveObject()
{
    return NOERROR;
}

STDMETHODIMP CBareClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
			LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_FAIL;
}

STDMETHODIMP CBareClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    *ppContainer = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CBareClientSite::ShowObject()
{
    return NOERROR;
}

STDMETHODIMP CBareClientSite::OnShowWindow(BOOL fShow)
{
    return NOERROR;
}

STDMETHODIMP CBareClientSite::RequestNewObjectLayout()
{
    return NOERROR;
}


void RunServerSide(void)
{
    DWORD dwcf = 0;
    HWND hwnd;
    MSG msg;

    IClassFactory *pcf = new CBareFactory();

    WNDCLASS	wc;

    // Register Clipboard window class
    //
    wc.style = 0;
    wc.lpfnWndProc = DefWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 4;
    wc.hInstance = NULL;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = "BareServerWindow";

    // don't bother checking for errors
    RegisterClass(&wc);
	
    hwnd = CreateWindow("BareServerWindow","",WS_POPUP,CW_USEDEFAULT,
			CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
			NULL,NULL,NULL,NULL);

    CoRegisterClassObject( CLSID_BareServer, pcf, CLSCTX_LOCAL_SERVER,
	REGCLS_MULTIPLEUSE, &dwcf );

    while (GetMessage(&msg, NULL, NULL, NULL))
    {
        TranslateMessage(&msg);    /* Translates virtual key codes  */
        DispatchMessage(&msg);     /* Dispatches message to window  */
    }

    CoRevokeClassObject(dwcf);
}

void RunContainerSide()
{
    DWORD dwStart, dwFinish, i;
    HRESULT hresult;
    IStorage *pstg;
    IOleObject *poo;
    IOleClientSite *pcs;

    hresult = StgCreateDocfile(NULL, STGM_CREATE | STGM_READWRITE |
		STGM_SHARE_EXCLUSIVE,
		0, &pstg);

    if( hresult != NOERROR )
    {
	printf("CreateDocFile failed! (%lx)\n", hresult);
	exit(hresult);
    }

    pcs = (IOleClientSite *)new CBareClientSite();

    // prime the server

    hresult = OleCreate( CLSID_BareServer, IID_IOleObject, OLERENDER_NONE,
		NULL, pcs, pstg, (void **)&poo);

    if( hresult != NOERROR )
    {
	printf("OleCreate failed! (%lx)\n", hresult);
	exit(hresult);
    }

    hresult = OleRun(poo);

    if( hresult != NOERROR )
    {
	printf("OleRun failed! (%lx)\n", hresult);
	exit(hresult);
    }

    poo->Close(0);
    poo->Release();
    poo = NULL;

    pcs->Release();
    pcs = NULL;

    for( i = 0; i < 100; i++ )
    {

	pcs = (IOleClientSite *)new CBareClientSite();

	dwStart = GetTickCount();

	hresult = OleCreate(CLSID_BareServer, IID_IOleObject, OLERENDER_NONE,
		NULL, pcs, pstg, (void **)&poo);

	if( hresult == NOERROR )
	{
	    hresult = OleRun(poo);
	}

	dwFinish = GetTickCount();

	if( hresult == NOERROR )
	{
	    poo->Close(0);
	    poo->Release();
	    poo = NULL;

	    printf("%ld\n", dwFinish - dwStart);
     	}
	else
	{
	    printf("%ld failed! (%lx)\n", i, hresult);
	}

	pcs->Release();
	pcs = NULL;
    }

    pstg->Release();
}


int main( int argc, char **argv )
{
    OleInitialize(NULL);

    if( argc == 2 )
    {
	// assume -Embedding
	RunServerSide();
    }
    else
    {
	RunContainerSide();
    }

    OleUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\procswap\procswap.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	procswap.cxx
//
//  Contents:	Program for measuring task switching performance
//		between two windows programs. The program creates
//		CTaskSwitch objects...
//
//		Each Object can wait on one of three things...
//		    1. GetMessage
//		    2. MsgWaitForMultipleObjects
//		    3. WaitForSingleObject (event)
//
//		and when awoken, will signal another Object in one
//		of three ways...
//		    1. PostMessage
//		    2. SendMessage
//		    3. SetEvent
//
//		These cases can be combined in any manner to obtain
//		a maxtrix of possible scenarios.
//
//		The CTaskSwitch objects can be in the same process on
//		different threads, or in different processes.
//
//  Classes:	CEvent	      -	event handling class
//		CTaskSwitch   -	main task switch class
//
//
//  Functions:	WinMain       - entry point of process
//		ThreadEntry   - entry point of spawned threads
//		ThreadWndProc -	processes windows messages
//
//
//  History:	08-Feb-94   Rickhi	Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <tchar.h>


//  execution parameter structure

typedef struct tagSExecParms
{
    int 	oloop;		//  outer loop count
    int 	iloop;		//  inner loop count
    HWND	hWndOther;	//  HWND of other process
    HANDLE	hEventOther;	//  Event Handle of other process
    WNDPROC	pfnWndProc;	//  ptr to WndProc function
    TCHAR	szFile[20];	//  output file name
    TCHAR	szWaitEvent[20];   // event name to wait on
    TCHAR	szSignalEvent[20]; // event name to signal
} SExecParms;


typedef enum tagWAITTYPES
{
    WAIT_EVENT		    = 1,
    WAIT_MSGWAITFORMULTIPLE = 2,
    WAIT_GETMESSAGE	    = 3,
    WAIT_SYNCHRONOUS	    = 4
} WAITTYPES;

typedef enum tagSIGNALTYPES
{
    SIGNAL_EVENT	    = 1,
    SIGNAL_POSTMESSAGE	    = 2,
    SIGNAL_SENDMESSAGE	    = 3,
    SIGNAL_SYNCHRONOUS	    = 4
} SIGNALTYPES;

//  input names corresponding to the wait types
LPSTR aszWait[] = {"", "event", "msgwait", "getmsg", "sync", NULL};

//  input names corresponding to the signal types
LPSTR aszSignal[] = {"", "event", "postmsg", "sendmsg", "sync", NULL};



//  Name of window class for dispatching messages.

#define MY_WINDOW_CLASS TEXT("ProcSwapWindowClass")

#define MAX_OLOOP   100


//  globals

DWORD		g_fFullInfo = 0;	    //	write full info or not
HINSTANCE	g_hInst     = NULL;	    //	misc windows junk.
ATOM		g_MyClass   = 0;
UINT		g_MyMessage = WM_USER;


//  function prototype
LRESULT	ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam);
DWORD	ThreadEntry(void *param);


//--------------------------------------------------------------------------
//
//  Class:	CEvent
//
//  Purpose:	class for blocking & starting threads.
//
//--------------------------------------------------------------------------

class	CEvent
{
public:
	    CEvent(LPTSTR szName, HRESULT &hr) { Init(szName, hr); }
	    CEvent(void) {m_hdl = NULL; }

	    ~CEvent()	 { CloseHandle(m_hdl); }

    void    Signal(void) { SetEvent(m_hdl); }
    void    Reset(void)  { ; }		      // ResetEvent(m_hdl); }
    void    BlockS(void) { WaitForSingleObject(m_hdl, 60000); }
    void    BlockM(void) { WaitForMultipleObjects(1, &m_hdl, FALSE, 60000); }
    HANDLE *GetHdl(void) { return &m_hdl; };

    void    Init(LPTSTR szName, HRESULT &hr);

private:

    HANDLE  m_hdl;
};


void CEvent::Init(LPTSTR szName, HRESULT &hr)
{
    hr = S_OK;

    //	first try opening the event
    m_hdl = OpenEvent(EVENT_ALL_ACCESS,
		      FALSE,
		      szName);

    if (m_hdl == NULL)
    {
	//  doesnt exist yet so create it.
	m_hdl = CreateEvent(NULL,	    // security
			    FALSE,	    // auto reset
			    FALSE,	    // initially not signalled
			    szName);

	if (m_hdl == NULL)
	{
	    _tprintf (TEXT("Error Creating CEvent (%s)\n"), szName);
	    hr = GetLastError();
	}
	else
	{
	    _tprintf (TEXT("Created CEvent (%s)\n"), szName);
	}
    }
    else
    {
        _tprintf (TEXT("Opened CEvent (%s)\n"), szName);
    }
}



//--------------------------------------------------------------------------
//
//  Class:	CTaskSwitch
//
//  Purpose:	class for timing task switches.
//
//--------------------------------------------------------------------------

class	CTaskSwitch
{
public:
		CTaskSwitch(LPSTR lpszCmdLine, HRESULT &hr);
		~CTaskSwitch(void);

    int		MainProcessLoop(void);
    LRESULT	ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam);
    HRESULT	SpawnOtherSide(void);

private:

    //	initialization / cleanup methods

    HRESULT	ParseCmdLine(LPSTR lpszCmdLine, SExecParms &execp);
    HRESULT	WindowInitialize(WNDPROC pfnWndProc, HWND &hWnd);
    void	WindowUninitialize(HWND hWnd);
    void	CreateOtherParms(void);
    void	WriteExecParms(void);
    void	WriteResults(void);
    void	Help(void);
    DWORD	GetWaitType(LPSTR pszCmd);
    DWORD	GetSignalType(LPSTR pszCmd);
    DWORD	CreateProc(void);

    //	processing methods

    HRESULT	SendOrWaitFirstSignal(void);
    void	ProcessMsgWaitForMultiple(DWORD dwRet);
    void	ProcessIncommingEvent(void);
    void	UpdateLoopCounters(void);
    void	SignalOtherSide(void);

    //	data

    BOOL		g_fDone;	    //	when to exit the loop
    BOOL		g_fKicker;	    //	we kick the other guy
    BOOL		g_fThreadSwitch;    //	thread or process switching?
    BOOL		g_fWaitMultiple;    //	wait single or multiple

    ULONG		g_oloop;	    //	outer loop counter
    ULONG		g_iloop;	    //	inner loop counter

    DWORD		g_WaitType;	    //	what to wait on
    DWORD		g_SignalType;	    //	what to signal

    //	used only for parameter parseing
    DWORD		g_WaitType1;	    //	what to wait on
    DWORD		g_SignalType1;	    //	what to signal
    DWORD		g_WaitType2;	    //	what to wait on
    DWORD		g_SignalType2;	    //	what to signal


    HWND		g_hWndOther;	    //	hWnd of other side
    HWND		g_hWndMe;	    //	my hWnd

    CEvent		g_WaitEvent;	    //	event to wait on
    CEvent		g_SignalEvent;	    //	event to signal

    ULONG		g_time[MAX_OLOOP];  //	place to store the timings.
    CStopWatch		g_timer;	    //	global timer proc 1

    SExecParms		g_execp;	    //	execution parameters
    CTestOutput       * g_output;	    //	output log

    HRESULT		g_hr;		    //	result code

    CHAR		g_szOtherParms[MAX_PATH]; // parm string for other guy
};




//  task switch objects - must be global for ThreadWndProc

CTaskSwitch	*g_pTaskSwitch1 = NULL;
CTaskSwitch	*g_pTaskSwitch2 = NULL;


//--------------------------------------------------------------------------
//
//  WinMain - main entry point of program.  May just call ThreadEntry, or
//	      may spawn another thread in the case of thread switching.
//
//
//--------------------------------------------------------------------------

int WinMain(HINSTANCE hinst, HINSTANCE hPrev, LPSTR lpszCmdLine, int CmdShow)
{
    HRESULT hr;

    //	create the first task switch object for this process
    g_pTaskSwitch1 = new CTaskSwitch(lpszCmdLine, hr);

    if (hr == S_OK)
    {
	//  spawn a new thread or a new process to do task switching with.
	hr = g_pTaskSwitch1->SpawnOtherSide();

	if (hr == S_OK)
	{
	    //	enter the main processing loop
	    g_pTaskSwitch1->MainProcessLoop();
	}
    }

    //	print the results
    delete g_pTaskSwitch1;
    return 1;
}



//--------------------------------------------------------------------------
//
//  ThreadEntry - main entry point for a thread spawned by CreateThread
//	    in the case of task switching between threads.
//
//	    Creates an instance of the CTaskSwitch class and invokes it
//	    main function.
//
//--------------------------------------------------------------------------

DWORD ThreadEntry(void *param)
{
    LPSTR lpszCmdLine = (LPSTR) param;

    HRESULT hr;

    //	create the second task switch object for this process
    g_pTaskSwitch2 = new CTaskSwitch(lpszCmdLine, hr);

    if (hr == S_OK)
    {
	//  enter the main processing loop
	g_pTaskSwitch2->MainProcessLoop();
    }

    //	print the results
    delete g_pTaskSwitch2;
    return hr;
}




//--------------------------------------------------------------------------
//
//  Dipatch to the correct CTaskSwitch object if the message is our
//  special message.
//
//--------------------------------------------------------------------------

LRESULT ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    if (msg == g_MyMessage)
    {
	//  its my special message, go handle it.
	//  here i have to select which object to dispatch to for the
	//  multithreaded case. i base that decision on lparam.

	if (lparam == 0)
	{
	    //	use the first task switch object
	    return g_pTaskSwitch1->ThreadWndProc(hWnd, msg, wparam, lparam);
	}
	else
	{
	    //	use the second task switch object
	    return g_pTaskSwitch2->ThreadWndProc(hWnd, msg, wparam, lparam);
	}
    }
    else
    {
	// let the default window procedure have the message.
	return DefWindowProc(hWnd, msg, wparam, lparam);
    }
}




//--------------------------------------------------------------------------
//
//  Constructor : parse the command line, create the events, create the
//		  window, and open a log file.
//
//--------------------------------------------------------------------------

CTaskSwitch::CTaskSwitch(LPSTR lpszCmdLine, HRESULT &hr) :
    g_fDone(FALSE),
    g_fKicker(FALSE),
    g_fThreadSwitch(FALSE),
    g_fWaitMultiple(FALSE),
    g_oloop(10),
    g_iloop(100),
    g_WaitType(WAIT_EVENT),
    g_SignalType(SIGNAL_EVENT),
    g_hWndMe(NULL),
    g_hWndOther(NULL),
    g_output(NULL),
    g_hr(S_OK)
{
    //	parse command line and write the parms to log file.
    g_hr = ParseCmdLine(lpszCmdLine, g_execp);

    if (g_hr == S_OK)
    {
	//  Create a log file & write execution parameters
	g_output = new CTestOutput(g_execp.szFile);
	WriteExecParms();

	//  create the window for this thread
	g_hr = WindowInitialize(g_execp.pfnWndProc, g_hWndMe);
	if (g_hr == S_OK)
	{
	    //	Create the Wait event.
	    g_WaitEvent.Init(g_execp.szWaitEvent, g_hr);
	    if (g_hr == S_OK)
	    {
		//  Create the Signal event.
		g_SignalEvent.Init(g_execp.szSignalEvent, g_hr);

		if (g_hr == S_OK)
		{
		    //	create paramters to send to other side.
		    CreateOtherParms();
		}
	    }
	}
    }

    //	return the results
    hr = g_hr;
}


//--------------------------------------------------------------------------
//
//  Desructor
//
//--------------------------------------------------------------------------

CTaskSwitch::~CTaskSwitch(void)
{
    //	write the results
    WriteResults();

    //	cleanup window registration
    WindowUninitialize(g_hWndMe);

    //	close the log file
    delete g_output;
}


//--------------------------------------------------------------------------
//
//  Spawns either another process or another thread to perform the task
//  switching with.
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::SpawnOtherSide(void)
{
    if (g_fKicker)
    {
	//  i'm already the second entry, dont spawn anything.
	//  sleep for a bit to make sure both sides are ready
	//  when i kick things off.

	Sleep(1000);
	return S_OK;
    }


    if (g_fThreadSwitch)
    {
	//  spawn a thread

	HANDLE	hdl;
	DWORD  dwId;
	hdl = CreateThread(NULL,	    //	default security
			   0,		    //	default stack size
			   ThreadEntry,     //	entry point
			   g_szOtherParms,  //	command line parms
			   0,		    //	flags
			   &dwId);	    //	threadid

	if (hdl)
	{
	    //	dont need the handle
	    CloseHandle(hdl);
	}
	else
	{
	    //	what went wrong?
	    return GetLastError();
	}
    }
    else
    {
	//  spawn a process
	DWORD dwRet = CreateProc();
	if (dwRet != S_OK)
	{
	    return dwRet;
	}
    }

    return S_OK;
}



//--------------------------------------------------------------------------
//
//  MainProcessLoop - does the main wait & process the event
//
//--------------------------------------------------------------------------

int CTaskSwitch::MainProcessLoop(void)
{
    MSG     msg;
    DWORD   dwRet;


    //	Send, or wait on, the first signal.
    SendOrWaitFirstSignal();


    //	Reset the timer and enter the main loop.
    g_timer.Reset();


    //	wait loop - based on the type of event we should receive, we
    //	wait here until such an event occurs. Then we send a signal
    //	to the other side based on what it expects from us.

    while (!g_fDone)
    {
	switch (g_WaitType)
	{

	case WAIT_MSGWAITFORMULTIPLE:

	    //	wait here for a message or an event to be signalled
	    dwRet = MsgWaitForMultipleObjects(1,
					    g_WaitEvent.GetHdl(),
					    FALSE,
					    600000,
					    QS_ALLINPUT);

	    //	Dispatch to ThreadWndProc if a message, or
	    //	to ProcessEvent if an event was signalled
	    ProcessMsgWaitForMultiple(dwRet);
	    break;


	case WAIT_GETMESSAGE:

	    //	wait for a windows message
	    if (GetMessage(&msg, NULL, 0, 0))
	    {
		//  dispatches to my ThreadWndProc
		DispatchMessage(&msg);
	    }
	    break;


	case WAIT_EVENT:

	    //	wait for the event to be signalled
	    if (g_fWaitMultiple)
		g_WaitEvent.BlockM();
	    else
		g_WaitEvent.BlockS();

	    //	process the event
	    ProcessIncommingEvent();
	    break;


	case WAIT_SYNCHRONOUS:

	    //	we have a synchronous singal to the other side, so there is
	    //	nothing to wait on, we will just go make another synchronous
	    //	call. this is valid only if the g_SignalType is
	    //	SIGNAL_SENDMESSAGE.

	    ProcessIncommingEvent();
	    break;


	default:

	    //	unknown event
	    break;
	}

    }	// while

    return msg.wParam;	 // Return value from PostQuitMessage
}



//--------------------------------------------------------------------------
//
//  processes a wakeup from MsgWaitForMultiple. Determines if the event was
//  a message arrival (in which case it Peeks it and Dispatches it, or if it
//  was an event signalled, in which case it calls the event handler.
//
//--------------------------------------------------------------------------

void CTaskSwitch::ProcessMsgWaitForMultiple(DWORD dwRet)
{
	MSG msg;

	if (dwRet == WAIT_OBJECT_0)
	{
	    // our event got signalled, update the counters
	    ProcessIncommingEvent();
	}

	else if (dwRet == WAIT_OBJECT_0 + 1)
	{
	    //	some windows message was received. dispatch it.

	    if (PeekMessage(&msg, g_hWndMe, 0, 0, PM_REMOVE))
	    {
		DispatchMessage(&msg);
	    }
	}
	else
	{
	    //	our event timed out or our event was abandoned or
	    //	an error occurred.

	    g_fDone = TRUE;
	}
}



//--------------------------------------------------------------------------
//
//  processes an incomming event. Just updates the counters and
//  signals the other side.
//
//--------------------------------------------------------------------------

void CTaskSwitch::ProcessIncommingEvent(void)
{
    //	update the loop counters
    UpdateLoopCounters();

    //	Signal the other side
    SignalOtherSide();
}



//--------------------------------------------------------------------------
//
//  process the incomming message
//
//--------------------------------------------------------------------------

LRESULT CTaskSwitch::ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    //	save the callers hWnd
    g_hWndOther = (HWND) wparam;

    //	process as usual
    ProcessIncommingEvent();

    return 0;
}



//--------------------------------------------------------------------------
//
//  updates the global loop counters, reseting the time when the inner
//  loop counter expires, and setting the fDone when the outer and inner
//  loop counters expire.
//
//--------------------------------------------------------------------------

void CTaskSwitch::UpdateLoopCounters(void)
{
    if (g_iloop == 0)
    {
	//  get time for latest outer loop
	g_time[g_oloop] = g_timer.Read();

	if (g_oloop == 0)
	{
	    //	that was the last outerloop, we're done.
	    g_fDone = TRUE;
	}
	else
	{
	    //	update the counters
	    g_iloop = g_execp.iloop;
	    --g_oloop;

	    //	restart the timer
	    g_timer.Reset();
	}
    }
    else
    {
	//  just update the inner loop count
	--g_iloop;
    }
}



//--------------------------------------------------------------------------
//
//  signals the other process or thread according to the SendType (either
//  signals an event or posts a message).
//
//--------------------------------------------------------------------------

void CTaskSwitch::SignalOtherSide(void)
{
    switch (g_SignalType)
    {

    case SIGNAL_EVENT:

	//  signal the other sides event
	g_SignalEvent.Signal();
	break;


    case SIGNAL_POSTMESSAGE:

	//  post a message to the other sides window handle.
	//  lparam tells ThreadWndProc which object to dispatch to, either
	//  g_pTaskSwitch1 or g_pTaskSwitch2.  We only go to 2 if we are
	//  doing thread switches AND the poster is not the kicker.

	PostMessage(g_hWndOther,
		    g_MyMessage,
		    (WPARAM)g_hWndMe,
		    (g_fThreadSwitch && !g_fKicker));
	break;


    case SIGNAL_SENDMESSAGE:

	//  send a message to the other side. this is a synchronous
	//  event. see comment in PostMessage above regarding lparam.

	SendMessage(g_hWndOther,
		    g_MyMessage,
		    (WPARAM)g_hWndMe,
		    (g_fThreadSwitch && !g_fKicker));
	break;


    case SIGNAL_SYNCHRONOUS:

	//  the event we received is a synchronous event. there is no need
	//  to do anything to wake the other side.

	break;


    default:

	//  unknown signal type
	break;
    }
}


//--------------------------------------------------------------------------
//
//  signals the other process or thread that it can begin the test. this
//  avoids timings skewed due to process startup latency.
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::SendOrWaitFirstSignal(void)
{
    if (g_fKicker)
    {
	//  send a signal to drop the otherside into its wait loop, and
	//  then call SignalOtherSide to start the cycle, kicking the
	//  other side out of his first wait.

	printf ("Initial Signal to Other Side\n");
	g_SignalEvent.Signal();
	SignalOtherSide();
    }
    else
    {
	printf ("Waiting for Signal From Other Side\n");
	g_WaitEvent.BlockS();
    }

    return S_OK;
}



//--------------------------------------------------------------------------
//
//  initializes the window with the specified window proc.
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::WindowInitialize(WNDPROC pfnWndProc, HWND &hWnd)
{

	if (!g_MyMessage)
	{
	    //	Register my message type
	    g_MyMessage = RegisterWindowMessage(
			  TEXT("Component Object Model Remote Request Arrival") );
	}

	if (!g_MyClass)
	{
	    // Register my window class.
	    WNDCLASS wcls;

	    wcls.style	       = 0;
	    wcls.lpfnWndProc   = pfnWndProc;
	    wcls.cbClsExtra    = 0;
	    wcls.cbWndExtra    = 0;
	    wcls.hInstance     = g_hInst;
	    wcls.hIcon	       = NULL;
	    wcls.hCursor       = NULL;
	    wcls.hbrBackground = (HBRUSH) COLOR_BACKGROUND + 1;
	    wcls.lpszMenuName  = NULL;
	    wcls.lpszClassName = MY_WINDOW_CLASS;

	    g_MyClass = RegisterClass( &wcls );
	}


	if (g_MyClass)
	{
	    // Create a hidden window.
	    hWnd  = CreateWindowEx( 0,
				    (LPCTSTR) g_MyClass,
				    TEXT("Task Switcher"),
                                    WS_DISABLED,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    NULL,
                                    NULL,
				    g_hInst,
				    NULL );


	    if (hWnd)
	    {
		printf ("Created Window with hWnd %x\n", hWnd);
		return S_OK;
	    }
	}

	return E_OUTOFMEMORY;
}


//--------------------------------------------------------------------------
//
//  destroys the window and unregisters the class.
//
//--------------------------------------------------------------------------

void CTaskSwitch::WindowUninitialize(HWND hWnd)
{
    if (hWnd != NULL)
    {
	DestroyWindow(hWnd);
    }

    if (g_MyClass != 0)
    {
	UnregisterClass(MY_WINDOW_CLASS, g_hInst);
    }
}



//--------------------------------------------------------------------------
//
//  parses the command line and returns the execution parameters
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::ParseCmdLine(LPSTR lpszCmdLine, SExecParms &execp)
{
    BOOL fFile	       = FALSE;

    //	set the default values for execution parameters.

    execp.oloop        = 10;
    execp.iloop        = 100;
    execp.hWndOther    = NULL;
    execp.pfnWndProc   = ::ThreadWndProc;



    //	check the input parameters

    LPSTR pszCmd = lpszCmdLine;
    LPSTR pszCmdNext = NULL;

    while (pszCmd)
    {
	pszCmdNext = strchr(pszCmd, ' ');
	if (pszCmdNext)
	{
	    *pszCmdNext = '\0';
	    pszCmdNext++;
	}

	//  check for outer loop count
	if (!_strnicmp(pszCmd, "/o:", 3))
	{
	    execp.oloop = atoi (pszCmd+3);
	    if (execp.oloop > MAX_OLOOP)
		execp.oloop = MAX_OLOOP;
	}

	//  check for inner loop count
	else if (!_strnicmp(pszCmd, "/i:", 3))
	{
	    execp.iloop = atoi (pszCmd+3);
	    if (execp.iloop < 1)
		execp.iloop = 1;
	}

	//  check for window handle
	else if (!_strnicmp(pszCmd, "/hwnd:", 6))
	{
	    execp.hWndOther = (HWND) atoi (pszCmd+6);
	}

	//  check for waiter or Kicker
	else if (!_strnicmp(pszCmd, "/k", 2))
	{
	    g_fKicker = TRUE;
	}

	//  check for thread or process switch
	else if (!_strnicmp(pszCmd, "/p", 2))
	{
	    g_fThreadSwitch = FALSE;
	}

	//  check for thread or process switch
	else if (!_strnicmp(pszCmd, "/t", 2))
	{
	    g_fThreadSwitch = TRUE;
	}

	//  check for wait single or multiple
	else if (!_strnicmp(pszCmd, "/m", 2))
	{
	    g_fWaitMultiple = TRUE;
	}

	//  check for wait event name
	else if (!_strnicmp(pszCmd, "/e1:", 4))
	{
#ifdef UNICODE
	    mbstowcs(execp.szWaitEvent, pszCmd+4, strlen(pszCmd+4)+1);
#else
	    strcpy(execp.szWaitEvent, pszCmd+4);
#endif
	}

	//  check for signal event name
	else if (!_strnicmp(pszCmd, "/e2:", 4))
	{
#ifdef UNICODE
	    mbstowcs(execp.szSignalEvent, pszCmd+4, strlen(pszCmd+4)+1);
#else
	    strcpy(execp.szSignalEvent, pszCmd+4);
#endif
	}

	//  check for output file name
	else if (!_strnicmp(pszCmd, "/f:", 3))
	{
	    fFile = TRUE;
#ifdef UNICODE
	    mbstowcs(execp.szFile, pszCmd+3, strlen(pszCmd+3)+1);
#else
	    strcpy(execp.szFile, pszCmd+3);
#endif
	}

	//  check for wait type
	else if (!_strnicmp(pszCmd, "/w1:", 4))
	{
	    g_WaitType1 = GetWaitType(pszCmd+4);
	}
	else if (!_strnicmp(pszCmd, "/w2:", 4))
	{
	    g_WaitType2 = GetWaitType(pszCmd+4);
	}

	//  check for signal type
	else if (!_strnicmp(pszCmd, "/s1:", 4))
	{
	    g_SignalType1 = GetSignalType(pszCmd+4);
	}
	else if (!_strnicmp(pszCmd, "/s2:", 4))
	{
	    g_SignalType2 = GetSignalType(pszCmd+4);
	}

	//  check for help request
	else if ((!_strnicmp(pszCmd, "/?", 2)) || (!_strnicmp(pszCmd, "/h", 2)))
	{
	    Help();
	    return -1;
	}

	pszCmd = pszCmdNext;
    }


    g_iloop = execp.iloop;
    g_oloop = execp.iloop;
    g_hWndOther = execp.hWndOther;


    if (g_fKicker)
    {
	g_WaitType = g_WaitType2;
	g_SignalType = g_SignalType2;
	if (!fFile)
	    _tcscpy(execp.szFile, TEXT("kicker"));
    }
    else
    {
	g_WaitType = g_WaitType1;
	g_SignalType = g_SignalType1;
	if (!fFile)
	    _tcscpy(execp.szFile, TEXT("waiter"));

    }

    return S_OK;
}



DWORD	CTaskSwitch::GetWaitType(LPSTR pszCmd)
{
    ULONG   i=0;

    while (aszWait[++i])	// slot 0 is not used
    {
	if (!_stricmp(pszCmd, aszWait[i]))
	    return i;
    }

    Help();
    return 0;
}


DWORD	CTaskSwitch::GetSignalType(LPSTR pszCmd)
{
    ULONG   i=0;

    while (aszSignal[++i])	// slot 0 is not used
    {
	if (!_stricmp(pszCmd, aszSignal[i]))
	    return i;
    }

    Help();
    return 0;
}



//--------------------------------------------------------------------------
//
//  creates the command line parameters for the other guy
//
//--------------------------------------------------------------------------

void  CTaskSwitch::CreateOtherParms(void)
{




    //	write the formatted parms to the parm string

    sprintf(g_szOtherParms, "/k %s %s /i:%d /o:%d /hWnd:%ld "
        "/e1:%hs /e2:%hs /w1:%s /s1:%s /w2:%s /s2:%s",
	    (g_fThreadSwitch) ? "/t" : "/p",
	    (g_fWaitMultiple) ? "/m" : " ",
	    g_execp.iloop,		// same loop counts as me
	    g_execp.oloop,
	    g_hWndMe,			// posts to my window
	    g_execp.szSignalEvent,		// it waits on my signal event
	    g_execp.szWaitEvent,		// it signals my wait event
	    aszWait[g_WaitType1],	// signal what i wait on
	    aszSignal[g_SignalType1],	// wait on what i signal
	    aszWait[g_WaitType2],	// signal what i wait on
	    aszSignal[g_SignalType2]);	// wait on what i signal

}



//--------------------------------------------------------------------------
//
//  writes the execution parameters to a log file.
//
//--------------------------------------------------------------------------

void CTaskSwitch::WriteExecParms()
{
    //	write the run parameters to the output file

    g_output->WriteString(TEXT("Using Parametes:\n"));
    g_output->WriteResult(TEXT("\tInner Loop Count = "), g_execp.iloop);
    g_output->WriteResult(TEXT("\tOuter Loop Count = "), g_execp.oloop);
    g_output->WriteString(TEXT("\n\n"));

    //	flush to avoid disk io during the test
    g_output->Flush();
}


//--------------------------------------------------------------------------
//
//  writes the results to a log file.
//
//--------------------------------------------------------------------------

void CTaskSwitch::WriteResults(void)
{
    if (g_hr == S_OK)
    {
	//  compute the averages

	ULONG tTotal = 0;

	//  skip the first & last value as they are sometimes skewed
	for (int i=0; i<g_execp.oloop; i++)
	{
	    tTotal += g_time[i];
	}

	//  compute average for 1 call/response
	tTotal /= (g_execp.oloop * g_execp.iloop);


	//	display the results

	g_output->WriteResults(TEXT("Times "), g_execp.oloop, g_time);
	g_output->WriteResult(TEXT("\nAverage "), tTotal);
    }
}


//--------------------------------------------------------------------------
//
//  writes the help info to the screen
//
//--------------------------------------------------------------------------

void CTaskSwitch::Help()
{
    printf ("msgtask\n");
    printf ("\t/o:<nnn>             - outer loop count def 10\n");
    printf ("\t/i:<nnn>             - inner loop count def 100\n");
    printf ("\t/f:<name>            - name of output file. def [kick | wait]\n");
    printf ("\t/w1:<event|getmsg|msgwait> - what to wait on\n");
    printf ("\t/s1:<event|postmsg>   - what to signal\n");
    printf ("\t/w2:<event|getmsg|msgwait> - what to wait on\n");
    printf ("\t/s2:<event|postmsg>   - what to signal\n");
    printf ("\t/e1:<name>           - name of wait event\n");
    printf ("\t/e2:<name>           - name of signal event\n");
    printf ("\t/k                   - kicker (as opposed to waiter)\n");
    printf ("\t/t                   - use thread switching\n");
    printf ("\t/p                   - use process switching\n");
    printf ("\t/m                   - use WaitMultiple vs WaitSingle\n");
    printf ("\t/hWnd:<nnnn>         - window handle of other side\n");

    printf ("\n");
    printf ("timings are given for the inner loop count calls\n");

    return;
}


//--------------------------------------------------------------------------
//
//  creates a process
//
//--------------------------------------------------------------------------

DWORD CTaskSwitch::CreateProc(void)
{
    //	create the command line

    TCHAR szCmdLine[256];

    _stprintf(szCmdLine, TEXT("ntsd procswap %hs"), g_szOtherParms);



    //	build the win32 startup info structure

    STARTUPINFO startupinfo;
    startupinfo.cb	    = sizeof(STARTUPINFO);
    startupinfo.lpReserved  = NULL;
    startupinfo.lpDesktop   = NULL;
    startupinfo.lpTitle     = TEXT("Task Switcher");
    startupinfo.dwX	    = 40;
    startupinfo.dwY	    = 40;
    startupinfo.dwXSize     = 80;
    startupinfo.dwYSize     = 40;
    startupinfo.dwFlags     = 0;
    startupinfo.wShowWindow = SW_SHOWNORMAL;
    startupinfo.cbReserved2 = 0;
    startupinfo.lpReserved2 = NULL;

    PROCESS_INFORMATION	ProcInfo;


    BOOL fRslt = CreateProcess(NULL,	    //	app name
			 szCmdLine,	    //	command line
			 NULL,		    //	lpsaProcess
			 NULL,		    //	lpsaThread
			 FALSE,		    //	inherit handles
			 CREATE_NEW_CONSOLE,//	creation flags
			 NULL,		    //	lpEnvironment
			 NULL,		    //	curr Dir
			 &startupinfo,	    //	Startup Info
			 &ProcInfo);	    //	process info

    if (fRslt)
    {
	//  we dont need the handles
	CloseHandle(ProcInfo.hProcess);
	CloseHandle(ProcInfo.hThread);
	printf ("Created Process (%ws) pid=%x\n", szCmdLine, ProcInfo.dwProcessId);
	return S_OK;
    }
    else
    {
	//  what went wrong?
	DWORD dwRet = GetLastError();
	printf ("CreateProcess (%ws) failed %x\n", szCmdLine, dwRet);
	return dwRet;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\rawrpc\rawrpc_s.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
extern RPC_DISPATCH_TABLE IRawRpc_DispatchTable;

static RPC_SERVER_INTERFACE ___RpcServerInterface =  {
  sizeof(RPC_SERVER_INTERFACE),
  {{0x00000145,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}},
  {0,0}},
    {
    {0x8A885D04L,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},
    {2,0}
    }
  ,
  &IRawRpc_DispatchTable,0,0,
  0
  }
;
RPC_IF_HANDLE IRawRpc_ServerIfHandle = (RPC_IF_HANDLE) &___RpcServerInterface;
void __RPC_STUB IRawRpc_Quit(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->Quit(hRpc);
    }
  else
    {
	_ret_value = Quit(hRpc);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_Void(
	PRPC_MESSAGE _prpcmsg)
  {
  handle_t hRpc = _prpcmsg->Handle;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->Void(hRpc);
    }
  else
    {
	Void(hRpc);
    }
  _prpcmsg->BufferLength = 0;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  }
void __RPC_STUB IRawRpc_VoidRC(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->VoidRC(hRpc);
    }
  else
    {
	_ret_value = VoidRC(hRpc);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_VoidPtrIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULONG cb;
  void *pv = 0;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    /* receive data into &cb */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&cb);
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    if (pv ==0)
      {
      pv = (void *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(unsigned char)));
      }
    byte_array_from_ndr ((PRPC_MESSAGE)_prpcmsg, 0, _alloc_total, pv);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->VoidPtrIn(hRpc, cb, pv);
      }
    else
      {
	_ret_value = VoidPtrIn(hRpc, cb, pv);
      }
    _prpcmsg->BufferLength = 4;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pv));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_VoidPtrOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULONG cb;
  ULONG *pcb = 0;
  void *pv = 0;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    /* receive data into &cb */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&cb);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  pcb = (unsigned long  *)MIDL_user_allocate ((size_t)(sizeof(long)));
  _alloc_total = cb;
  pv = (void *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(unsigned char)));
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->VoidPtrOut(hRpc, cb, pcb, pv);
      }
    else
      {
	_ret_value = VoidPtrOut(hRpc, cb, pcb, pv);
      }
    _prpcmsg->BufferLength = 24;
    if (pv ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    if (cb)
      {
      if (((*(pcb))) > (cb)) RpcRaiseException(RPC_X_INVALID_BOUND);
      }
    else
      {
      if (((*(pcb))) != (cb)) RpcRaiseException(RPC_X_INVALID_BOUND);
      }
    _prpcmsg->BufferLength += 12;
    _prpcmsg->BufferLength += (unsigned int)((*(pcb)));
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from *pcb */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)*pcb;
    // send total number of elements
    *(*(long **)&_prpcmsg->Buffer)++ = cb;
    // send valid range
    *(*(long **)&_prpcmsg->Buffer)++ = 0;
    *(*(long **)&_prpcmsg->Buffer)++ = (*(pcb));
    /* send data from pv */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) ((unsigned char *)pv+0), (unsigned int)((*(pcb))));
    *(unsigned long *)&_prpcmsg->Buffer += (*(pcb));
    /* send data from _ret_value */
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pv));
    MIDL_user_free((void  *)(pcb));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_DwordIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  DWORD dw;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    /* receive data into &dw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&dw);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->DwordIn(hRpc, dw);
    }
  else
    {
	_ret_value = DwordIn(hRpc, dw);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_DwordOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  DWORD pdw;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->DwordOut(hRpc, &pdw);
      }
    else
      {
	_ret_value = DwordOut(hRpc, &pdw);
      }
    _prpcmsg->BufferLength = 8;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from pdw */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)pdw;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_DwordInOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  DWORD pdw;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    /* receive data into &pdw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&pdw);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->DwordInOut(hRpc, &pdw);
      }
    else
      {
	_ret_value = DwordInOut(hRpc, &pdw);
      }
    _prpcmsg->BufferLength = 8;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from pdw */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)pdw;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_LiIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LARGE_INTEGER li;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (&li), "4ll", 8);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->LiIn(hRpc, li);
    }
  else
    {
	_ret_value = LiIn(hRpc, li);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_LiOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LARGE_INTEGER pli;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->LiOut(hRpc, &pli);
      }
    else
      {
	_ret_value = LiOut(hRpc, &pli);
      }
    _prpcmsg->BufferLength = 12;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from &pli */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&pli), (unsigned int)(8));
    *(unsigned long *)&_prpcmsg->Buffer += 8;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_ULiIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULARGE_INTEGER uli;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (&uli), "4ll", 8);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->ULiIn(hRpc, uli);
    }
  else
    {
	_ret_value = ULiIn(hRpc, uli);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_ULiOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULARGE_INTEGER puli;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->ULiOut(hRpc, &puli);
      }
    else
      {
	_ret_value = ULiOut(hRpc, &puli);
      }
    _prpcmsg->BufferLength = 12;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from &puli */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&puli), (unsigned int)(8));
    *(unsigned long *)&_prpcmsg->Buffer += 8;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_StringIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LPWSTR pwsz = 0;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    if (pwsz ==0)
      {
      pwsz = (WCHAR *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(WCHAR)));
      }
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pwsz), "s2", 1);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->StringIn(hRpc, pwsz);
      }
    else
      {
	_ret_value = StringIn(hRpc, pwsz);
      }
    _prpcmsg->BufferLength = 4;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pwsz));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_StringOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LPWSTR ppwsz = 0;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->StringOut(hRpc, &ppwsz);
      }
    else
      {
	_ret_value = StringOut(hRpc, &ppwsz);
      }
    _prpcmsg->BufferLength = 16;
    _prpcmsg->BufferLength += 4;
    if (ppwsz !=0)
      {
      tree_size_ndr((void __RPC_FAR *)&(ppwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
      }
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from ppwsz */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)ppwsz;
    if (ppwsz !=0)
      {
      tree_into_ndr((void __RPC_FAR *)&(ppwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
      }
    /* send data from _ret_value */
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    if (ppwsz !=0)
      {
      MIDL_user_free((void  *)(ppwsz));
      }
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_StringInOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LPWSTR pwsz = 0;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    if (pwsz ==0)
      {
      pwsz = (WCHAR *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(WCHAR)));
      }
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pwsz), "s2", 1);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->StringInOut(hRpc, pwsz);
      }
    else
      {
	_ret_value = StringInOut(hRpc, pwsz);
      }
    _prpcmsg->BufferLength = 16;
    if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    tree_size_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    tree_into_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
    /* send data from _ret_value */
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pwsz));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_GuidIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  GUID guid;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    _gns__GUID ((GUID *)&guid, (PRPC_MESSAGE)_prpcmsg);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->GuidIn(hRpc, guid);
    }
  else
    {
	_ret_value = GuidIn(hRpc, guid);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_GuidOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  GUID pguid;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->GuidOut(hRpc, &pguid);
      }
    else
      {
	_ret_value = GuidOut(hRpc, &pguid);
      }
    _prpcmsg->BufferLength = 20;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from &pguid */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&pguid), (unsigned int)(16));
    *(unsigned long *)&_prpcmsg->Buffer += 16;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
static RPC_DISPATCH_FUNCTION IRawRpc_table[] =
  {
  IRawRpc_Quit,
  IRawRpc_Void,
  IRawRpc_VoidRC,
  IRawRpc_VoidPtrIn,
  IRawRpc_VoidPtrOut,
  IRawRpc_DwordIn,
  IRawRpc_DwordOut,
  IRawRpc_DwordInOut,
  IRawRpc_LiIn,
  IRawRpc_LiOut,
  IRawRpc_ULiIn,
  IRawRpc_ULiOut,
  IRawRpc_StringIn,
  IRawRpc_StringOut,
  IRawRpc_StringInOut,
  IRawRpc_GuidIn,
  IRawRpc_GuidOut,
  0
  }
;
RPC_DISPATCH_TABLE IRawRpc_DispatchTable =
  {
  17,
  IRawRpc_table
  }
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server1\ctestemb.cxx ===
//+-------------------------------------------------------------------
//  File:       ctestemb.cxx
//
//  Contents:   CTestEmbed class implementation.
//
//  Classes:    CTestEmbed
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"



//+-------------------------------------------------------------------
//  Method:     CTestEmbed::CTestEmbed
//
//  Synopsis:   Constructor for CTestEmbed objects
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbed::CTestEmbed() : _cRef(1)
{
    _ptsaServer  = NULL;
    _pDataObject = NULL;
    _pOleObject  = NULL;
    _pPersStg    = NULL;
    _hwnd	 = NULL;
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::~CTestEmbed
//
//  Synopsis:   Performs cleanup for CTestEmbed objects by releasing
//              internal pointers.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbed::~CTestEmbed()
{
    // Inform controlling server app this object is gone
    _ptsaServer->DecEmbeddedCount();

    // Delete all of this objects interface classes
    delete _pDataObject;
    delete _pOleObject;
    delete _pPersStg;
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::InitObject
//
//  Synopsis:   Initialize this CTestEmbed object - ie, set everything
//              up for actual use.
//
//  Parameters: None
//
//  Returns:    S_OK if everything is okay to use, or an error code
//
//  History:    7-Dec-92   DeanE   Created
//
//  Notes:      The state of the object must be cleaned up in case of
//              failure - so the destructor will not blow up.
//--------------------------------------------------------------------
SCODE CTestEmbed::InitObject(CTestServerApp *ptsaServer, HWND hwnd)
{
    SCODE sc = S_OK;

    // Initialize controlling server app
    if (NULL != ptsaServer)
    {
        _ptsaServer = ptsaServer;
    }
    else
    {
        sc = E_ABORT;
    }

    // Initilize this objects window handle
    _hwnd = hwnd;

    // Create a CDataObject
    if (SUCCEEDED(sc))
    {
        _pDataObject = new CDataObject(this);
        if (NULL == _pDataObject)
        {
            sc = E_ABORT;
        }
    }

    // Create a COleObject
    if (SUCCEEDED(sc))
    {
        _pOleObject = new COleObject(this);
        if (NULL == _pOleObject)
        {
            sc = E_ABORT;
        }
    }

    // Create a CPersistStorage
    if (SUCCEEDED(sc))
    {
        _pPersStg = new CPersistStorage(this);
        if (NULL == _pPersStg)
        {
            sc = E_ABORT;
        }
    }

    if (FAILED(sc))
    {
        delete _pDataObject;
        delete _pOleObject;
        delete _pPersStg;
        _pDataObject = NULL;
        _pOleObject  = NULL;
        _pPersStg    = NULL;
        _ptsaServer  = NULL;
        _hwnd        = NULL;
    }

    // Inform controlling server we are a new embedded object
    if (SUCCEEDED(sc))
    {
        _ptsaServer->IncEmbeddedCount();
    }

    return(sc);
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::QueryInterface
//
//  Synopsis:   IUnknown, IOleObject, IPersist, IPersistStorage supported
//              return pointer to the actual object
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbed::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    SCODE scRet;

    if (GuidEqual(IID_IUnknown, iid))
    {
        *ppv = (IUnknown *)this;
	AddRef();
        scRet = S_OK;
    }
    else
    if (GuidEqual(IID_IOleObject, iid))
    {
        *ppv = _pOleObject;
	AddRef();
        scRet = S_OK;
    }
    else
    if (GuidEqual(IID_IPersist, iid) || GuidEqual(IID_IPersistStorage, iid))
    {
        *ppv = _pPersStg;
	AddRef();
        scRet = S_OK;
    }
    else
    if (GuidEqual(IID_IDataObject, iid))
    {
        *ppv = _pDataObject;
	AddRef();
        scRet = S_OK;
    }
    else
    {
        *ppv  = NULL;
        scRet = E_NOINTERFACE;
    }

    return(scRet);
}


STDMETHODIMP_(ULONG) CTestEmbed::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CTestEmbed::Release(void)
{
    ULONG cRefs = --_cRef;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}
SCODE CTestEmbed::GetWindow(HWND *phwnd)
{
    if (NULL != phwnd)
    {
        *phwnd = _hwnd;
        return(S_OK);
    }
    else
    {
        return(E_ABORT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\rot\rotut.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	rotut.cxx
//
//  Contents:	Unit Test for ROT
//
//  Classes:	MISSING
//
//  Functions:	MISSING
//
//  History:	16-Oct-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <windows.h>
#include    <widewrap.h>    // For chicago build
#include    <ole2.h>
#include    <stdio.h>
#include    <safepnt.hxx>
#include    <com.hxx>

#define TEST_FAILED(x, y) \
    if (x) \
    { \
	printf("%s:%d %s\n", __FILE__, __LINE__, y); \
	return TRUE; \
    }

GUID clsidLocal =
    {0xbbbbbbbb,0xbbbb,0xbbbb,{0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb}};

CHAR szTmpCurrrentDirectory[MAX_PATH];
WCHAR szCurrentDirectory[MAX_PATH];


SAFE_INTERFACE_PTR(CSafeROT, IRunningObjectTable)
SAFE_INTERFACE_PTR(CSafeUnk, IUnknown)
SAFE_INTERFACE_PTR(CSafePersist, IPersist)
SAFE_INTERFACE_PTR(CSafeEnumMoniker, IEnumMoniker)
SAFE_INTERFACE_PTR(CSafeMoniker, IMoniker)
SAFE_INTERFACE_PTR(CSafeStorage, IStorage)

class COleInit
{
public:
			COleInit(HRESULT& hr);

			~COleInit(void);
private:

    // No private data
};

inline COleInit::COleInit(HRESULT& hr)
{
    hr = OleInitialize(NULL);
}

inline COleInit::~COleInit(void)
{
    // Do the clean up
    OleUninitialize();
}



class CRotTestObject : public IPersist
{
public:
			CRotTestObject(WCHAR *pwszID);

    // IUnknown Interface
    STDMETHODIMP	QueryInterface(REFIID riid, void **ppv);

    STDMETHODIMP_(ULONG)AddRef(void);

    STDMETHODIMP_(ULONG)Release(void);

    STDMETHODIMP	GetClassID(LPCLSID pclsid);

private:

    WCHAR		_awcID[256];

    ULONG		_cRefs;

};




CRotTestObject::CRotTestObject(WCHAR *pwszID) : _cRefs(1)
{
    wcscpy(_awcID, pwszID);
}




STDMETHODIMP CRotTestObject::QueryInterface(REFIID riid, void **ppv)
{
    if ((memcmp((void *) &riid, (void *) &IID_IUnknown, sizeof(GUID)) == 0)
	|| (memcmp((void *) &riid, (void *) &IID_IPersist, sizeof(GUID)) == 0))
    {
	_cRefs++;
	*ppv = (IUnknown *) this;
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}



STDMETHODIMP_(ULONG) CRotTestObject::AddRef(void)
{
    _cRefs++;
    return (ULONG) _awcID;
}



STDMETHODIMP_(ULONG) CRotTestObject::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
    }

    return _cRefs;
}



STDMETHODIMP CRotTestObject::GetClassID(LPCLSID pclsid)
{
    memcpy(pclsid, &clsidLocal, sizeof(clsidLocal));
    return S_OK;
}






BOOL VerifyRegistration(
    IMoniker *pmk,
    REFCLSID clsidExpected,
    FILETIME *pFileTimeExpected)
{
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:GetRunningObjectTable failed!\n")

    // Verify the object is running
    hr = prot->IsRunning(pmk);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:Unexpected return from IsRunning\n")

    // Test Get Object
    CSafeUnk punk;

    hr = prot->GetObject(pmk, &punk);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:Unexpected from GetObject\n")

    // Confirm object class
    CSafePersist prst;

    hr = punk->QueryInterface(IID_IPersist, (void **) &prst);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:QI to IPersist failed\n")

    CLSID clsid;

    hr = prst->GetClassID(&clsid);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:GetClassID on IPersist failed\n")

    TEST_FAILED((memcmp(&clsid, &clsidExpected, sizeof(clsid)) != 0),
	"VerifyRegistration:GetClassID mismatch with expected\n")

    // Test get the time
    FILETIME filetime;

    hr = prot->GetTimeOfLastChange(pmk, &filetime);

    TEST_FAILED((hr != S_OK), "VerifyRegistration:GetTimeOfLastChange Failed\n")

    TEST_FAILED((memcmp(&filetime, pFileTimeExpected, sizeof(filetime)) != 0),
	"VerifyRegistration:GetTimeOfLastChange != NoteChangeTime value")

    // Enumerate all the running monikers
    CSafeEnumMoniker penummk;

    hr = prot->EnumRunning(&penummk);

    TEST_FAILED(FAILED(hr), "VerifyRegistration:EnumRunning Failed\n")

    // Cycle through running object table
    BOOL fFound = FALSE;
    IMoniker *pmkTable;
    int cIdx = 0;
    int cOurMoniker;

    while (SUCCEEDED(hr = penummk->Next(1, &pmkTable, NULL))
	&& (hr != S_FALSE))
    {
	if (pmk->IsEqual(pmkTable) == S_OK)
	{
	    fFound = TRUE;
	    cOurMoniker = cIdx;
	    pmkTable->Release();
	    break;
	}

	pmkTable->Release();

	cIdx++;
    }

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT Moniker Enumeration ended in failure")

    TEST_FAILED((!fFound),
	"VerifyRegistration:Did not find our moniker in the table");

    // Reset the pointer
    hr = penummk->Reset();

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT IEnumMoniker::Reset Failed");

    // Skip to our moniker
    hr = penummk->Skip(cOurMoniker);

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT IEnumMoniker::Skip Failed");

    // Read it from the enumerator
    hr = penummk->Next(1, &pmkTable, NULL);

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT IEnumMoniker::Next Failed");

    TEST_FAILED((pmk->IsEqual(pmkTable) != S_OK),
	"VerifyRegistration:ROT IEnumMoniker::Next after skip monikers !=");

    // If we get to here the test passed
    return FALSE;
}



BOOL VerifyNotRunning(IMoniker *pmk)
{
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED(FAILED(hr), "GetRunningObjectTable failed!\n")

    // Check result from IsRunning
    hr = prot->IsRunning(pmk);

    TEST_FAILED((hr != S_FALSE),
	"Unexpected return from IsRunning\n")

    // Test Get Object
    CSafeUnk punk;

    hr = prot->GetObject(pmk, &punk);

    TEST_FAILED((hr != MK_E_UNAVAILABLE), "Unexpected from GetObject\n")

    // Test get the time
    FILETIME filetime2;

    hr = prot->GetTimeOfLastChange(pmk, &filetime2);

    TEST_FAILED((hr != MK_E_UNAVAILABLE), "GetTimeOfLastChange Failed\n")

    // Enumerate all the running monikers
    CSafeEnumMoniker penummk;

    hr = prot->EnumRunning(&penummk);

    TEST_FAILED(FAILED(hr), "EnumRunning Failed\n")

    // Cycle through running object table
    BOOL fFound = FALSE;
    IMoniker *pmkTable;

    while (SUCCEEDED(hr = penummk->Next(1, &pmkTable, NULL))
	&& (hr != S_FALSE))
    {
	if (pmk->IsEqual(pmkTable) == S_OK)
	{
	    pmkTable->Release();
	    fFound = TRUE;
	    break;
	}

	pmkTable->Release();
    }

    TEST_FAILED(FAILED(hr), "ROT Moniker Enumeration ended in failure")

    TEST_FAILED((fFound), "Found our non-running moniker in the table");

    // If we get to here the test passed
    return FALSE;

}



BOOL TestInvalidParameters(void)
{
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    // Test set the time
    FILETIME filetime;
    memset(&filetime, 'A', sizeof(filetime));

    // Test with invalid pointer
    hr = prot->Revoke(0xFFFFFFFF);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from Revoke Invalid Address");

    hr = prot->NoteChangeTime(0xFFFFFFFF, &filetime);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from NoteChangeTime Invalid Address");

    // Test with valid pointer but invalid data
    DWORD dwValidAddress[30];

    hr = prot->Revoke((DWORD) dwValidAddress);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from Revoke Invalid Data");

    hr = prot->NoteChangeTime((DWORD) dwValidAddress, &filetime);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from NoteChangeTime Invalid Data");

    return FALSE;
}


BOOL TestLocalROT(void)
{
    CSafeMoniker pmk2;
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED(FAILED(hr), "GetRunningObjectTable failed!\n")

    // Make sure that we can do something on the pointer that
    // we got back.
    prot->AddRef();
    prot->Release();

    // Create an IUnknown pointer for the class.
    CSafeUnk punk;
    punk.Attach(new CRotTestObject(L"First Test Object"));

    hr = CreateItemMoniker(L"\\", L"Bob", &pmk2);

    TEST_FAILED(FAILED(hr), "CreateItemMoniker for \\Bob failed\n")

    // Make sure new object is not running
    TEST_FAILED(VerifyNotRunning(pmk2), "TestLocalROT:Object Already running\n")

    // Cookie for deregistering object
    DWORD dwRegister;

    hr = prot->Register(0, punk, pmk2, &dwRegister);

    TEST_FAILED(FAILED(hr), "TestLocalROT:Register in ROT for \\Bob failed\n")

    // Test set the time
    FILETIME filetime;

    memset(&filetime, 'A', sizeof(filetime));

    hr = prot->NoteChangeTime(dwRegister, &filetime);

    TEST_FAILED((hr != S_OK), "TestLocalROT:NoteChangeTime Failed\n")

    // Verify that this is running
    TEST_FAILED(VerifyRegistration(pmk2, clsidLocal, &filetime),
	"TestLocalROT: Registration failed\n");

    // Revoke registration
    hr = prot->Revoke(dwRegister);

    TEST_FAILED((hr != S_OK), "TestLocalROT:Revoke failed\n");

    // Verify no longer registered
    TEST_FAILED(VerifyNotRunning(pmk2),
	"TestLocalROT:VerifyNotRunning failed\n")

    // If we get to here the test passed
    return FALSE;
}



void CreatePath(int iId, WCHAR *pwszPath)
{
    wsprintf(pwszPath, L"%s\\%s%ld", szCurrentDirectory, L"ROTUT", iId);
}


BOOL CreateObjectAndBind(WCHAR *pwszPath, IUnknown **ppunk)
{
    HRESULT hr;

    // create a storage for the object
    {
	CSafeStorage pstg;

	hr = StgCreateDocfile(pwszPath,
	    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, &pstg);

	TEST_FAILED(FAILED(hr), "CreateObjectAndBind:StgCreateDocfile failed")

	// Write the class id to the storage
	hr = pstg->SetClass(CLSID_AdvBnd);
    }

    TEST_FAILED(FAILED(hr), "CreateObjectAndBind IStorage::SetClass Failed")

    // Bind to the path
    CSafeMoniker pmk;

    hr = CreateFileMoniker(pwszPath, &pmk);

    TEST_FAILED(FAILED(hr), "CreateObjectAndBind:CreateFileMoniker failed")

    hr = BindMoniker(pmk, 0, IID_IUnknown, (void **) ppunk);

    TEST_FAILED(FAILED(hr), "CreateObjectAndBind:BindMoniker failed")

    // Test set the time
    FILETIME filetime;

    memset(&filetime, 'B', sizeof(filetime));

    // Verify that it is running
    TEST_FAILED(VerifyRegistration(pmk, CLSID_AdvBnd, &filetime),
	"CreateObjectAndBind: Registration failed\n");

    return FALSE;
}



BOOL RemoteROT(void)
{
    // Create an object of the class
    WCHAR szPath[MAX_PATH];

    CreatePath(0, szPath);

    CSafeUnk punk;

    // Bind to the object
    if (CreateObjectAndBind(szPath, &punk))
    {
	printf("RemoteRot: Failed on CreateObjectAndBind\n");
	return TRUE;
    }

    // Release object
    punk->Release();
    punk.Detach();

    // Bind to the path
    CSafeMoniker pmk;

    HRESULT hr = CreateFileMoniker(szPath, &pmk);

    TEST_FAILED(FAILED(hr), "RemoteROT:CreateFileMoniker failed")

    // Verify that it is freed
    TEST_FAILED(VerifyNotRunning(pmk),
	"RemoteROT:VerifyNotRunning failed\n")

    DeleteFile(szPath);

    return FALSE;
}


#define MAX_TO_TEST 100
IUnknown *apunk[MAX_TO_TEST];



BOOL TestManyRegistrations(void)
{
    // Create an object of the class
    WCHAR szPath[MAX_PATH];

    for (int i = 0; i < MAX_TO_TEST; i++)
    {
	// Create name of bound object
	CreatePath(i, szPath);

	// Create object
	printf("Many create %ld\n", i);

	if (CreateObjectAndBind(szPath, &apunk[i]))
	{
	    printf("TestManyRegistrations failed on %ld\n", i);
	    return TRUE;
	}
    }

    for (i = 0; i < MAX_TO_TEST; i++)
    {
	printf("Many Release %ld\n", i);

	// Create name of bound object
	CreatePath(i, szPath);

	// Bind to the path
	CSafeMoniker pmk;

	HRESULT hr = CreateFileMoniker(szPath, &pmk);

	TEST_FAILED(FAILED(hr),
	    "TestManyRegistrations:CreateFileMoniker failed")

	// Release object
	apunk[i]->Release();

	// Verify object is not running
	if (VerifyNotRunning(pmk))
	{
	    printf("TestManyRegistrations:VerifyNotRunning failed on %ld\n", i);
	    return TRUE;
	}

	DeleteFile(szPath);
    }

    return FALSE;
}



int _cdecl main(int argc, TCHAR **argv)
{
    // Get the current directory
    int len = GetCurrentDirectoryA(sizeof(szTmpCurrrentDirectory),
	szTmpCurrrentDirectory);

    // Convert to UNICODE
    mbstowcs(szCurrentDirectory, szTmpCurrrentDirectory, len + 1);

    // Result of test - TRUE == passed
    BOOL fTest = FALSE;

    // Initialize Ole
    HRESULT hr;

    COleInit oleinit(hr);

    if (FAILED(hr))
    {
	printf("OleInitialize Failed\n");
	return -1;
    }

    // Test Invalidad Parameters and Local ROT
    if (!TestInvalidParameters() && !TestLocalROT())
    {
	// Test Remote Registration for object
	if (!RemoteROT())
	{
	    // Test Large Registration
	    if (!TestManyRegistrations())
	    {
		fTest = TRUE;
	    }
	}
    }

    if (fTest)
    {
	printf("Test Passed\n");
    }
    else
    {
	printf("Test FAILED!!!\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\perform\rawrpc\rawrpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	rawrpc.cxx
//
//  Contents:	definitions for benchmark test 
//
//  Classes:
//
//  Functions:	
//
//  History:	08-Feb-94   Rickhi	Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <rpc.h>
#include <rawrpc.h>

extern "C" const GUID IID_IRawRpc;


int _cdecl main (int argc, char ** argv)
{
    //	start Rpc
    RPC_STATUS	rc;
#ifdef USE_MSWMSG
    LPTSTR	pszProtseq  = TEXT("mswmsg");
    MSG msg;
#else
    LPTSTR	pszProtseq  = TEXT("ncalrpc");
#endif
    LPTSTR	pszEndPoint = TEXT("99999.99999");
    HANDLE hEvent;

#ifdef UNICODE
    rc = RpcServerUseProtseqEp(pszProtseq,
			       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
			       pszEndPoint,
			       NULL);
#else
    rc = RpcServerUseProtseqEp((unsigned char *)pszProtseq,
			       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
			       (unsigned char *)pszEndPoint,
			       NULL);
#endif
    if (rc != RPC_S_OK)
    {
	return rc;
    }


    rc = RpcServerRegisterIf(IRawRpc_ServerIfHandle, 0, 0);
    if (rc != RPC_S_OK)
    {
	return rc;
    }


    I_RpcSsDontSerializeContext();

    //
    // Signal the client that we're up and running
    //
    hEvent = CreateEvent(NULL, TRUE, FALSE,
                        TEXT("OleBenchRawRpcServerStarted"));

    //	start server listening. this call blocks until we get an
    //	RpcMgmtStopServerListening call.

    rc = RpcServerListen(1, 0xffff, 1);
    if (rc != RPC_S_OK)
    {
        CloseHandle(hEvent);
	return rc;
    }
    if (!SetEvent(hEvent))
    {
        CloseHandle(hEvent);
	return GetLastError();
    }
    CloseHandle(hEvent);

#ifdef USE_MSWMSG
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
#endif
    rc = RpcMgmtWaitServerListen();
    if (rc != RPC_S_OK)
    {
	return rc;
    }

    //	done, exit.
    return 0;
}



//  Server side of Rpc functions.

SCODE  Quit(handle_t hRpc)
{
    SCODE rc;

    rc = RpcMgmtStopServerListening(NULL);
#ifdef USE_MSWMSG
    PostQuitMessage(0);
#endif
    return rc;
}


//+-------------------------------------------------------------------------
//
//  Method:	Void
//
//  Synopsis:	tests passing no parameters
//
//  Arguments:
//
//  Returns:
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
void  Void(handle_t hRpc)
{
    return;
}

SCODE  VoidRC(handle_t hRpc)
{
    return RPC_S_OK;
}

SCODE  VoidPtrIn(handle_t hRpc, ULONG cb, void *pv)
{
    return RPC_S_OK;
}
    
SCODE  VoidPtrOut(handle_t hRpc, ULONG cb, ULONG *pcb, void *pv)
{
    memset(pv, 1, cb);
    *pcb = cb;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	 Dword
//
//  Synopsis:	tests passing dwords in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
SCODE  DwordIn(handle_t hRpc, DWORD dw)
{
    return RPC_S_OK;
}


SCODE  DwordOut(handle_t hRpc, DWORD *pdw)
{
    *pdw = 1;
    return RPC_S_OK;
}


SCODE  DwordInOut(handle_t hRpc, DWORD *pdw)
{
    *pdw = 1;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	 Li
//
//  Synopsis:	tests passing LARGE INTEGERS in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

SCODE  LiIn(handle_t hRpc, LARGE_INTEGER li)
{
    return RPC_S_OK;
}


SCODE  LiOut(handle_t hRpc, LARGE_INTEGER *pli)
{
    pli->LowPart = 0;
    pli->HighPart = 1;
    return RPC_S_OK;
}


SCODE  ULiIn(handle_t hRpc, ULARGE_INTEGER uli)
{
    return RPC_S_OK;
}


SCODE  ULiOut(handle_t hRpc, ULARGE_INTEGER *puli)
{
    puli->LowPart = 0;
    puli->HighPart = 1;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	 String
//
//  Synopsis:	tests passing strings in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
SCODE  StringIn(handle_t hRpc, LPWSTR pwsz)
{
    return RPC_S_OK;
}


SCODE  StringOut(handle_t hRpc, LPWSTR *ppwsz)
{
    // LPOLESTR pwsz = new OLECHAR[80];
    // *ppwsz = pwsz;
    wcscpy(*ppwsz, L"Hello World This is a Message");
    return RPC_S_OK;
}


SCODE  StringInOut(handle_t hRpc, LPWSTR pwsz)
{
    wcscpy(pwsz, L"Hello World This is a Message");
    return RPC_S_OK;
}



//+-------------------------------------------------------------------------
//
//  Function:	 Guid
//
//  Synopsis:	tests passing GUIDs in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
SCODE  GuidIn(handle_t hRpc, GUID guid)
{
    return RPC_S_OK;
}

SCODE  GuidOut(handle_t hRpc, GUID *piid)
{
    memcpy(piid, &IID_IRawRpc, sizeof(GUID));
    return  RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server1\ioleobj.cxx ===
//+-------------------------------------------------------------------
//  File:       ioleobj.cxx
//
//  Contents:   IOleObject methods of COleObject class.
//
//  Classes:    COleObject - IOleObject implementation
//
//  History:    7-Dec-92   DeanE   Created
//              31-Dec-93  ErikGav Chicago port
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"


//+-------------------------------------------------------------------
//  Member:     COleObject::COleObject()
//
//  Synopsis:   The constructor for COleObject.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
COleObject::COleObject(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pOAHolder = NULL;
    _pocs      = NULL;
    _pteObject = pteObject;
    _pmkContainer = NULL;
}


//+-------------------------------------------------------------------
//  Member:     COleObject::~COleObject()
//
//  Synopsis:   The destructor for COleObject.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
COleObject::~COleObject()
{
    // _cRef should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error - someone hasn't released
    }

    if (_pocs != NULL)
    {
	_pocs->Release();
    }

    if (_pmkContainer != NULL)
    {
	_pmkContainer->Release();
    }

}


//+-------------------------------------------------------------------
//  Method:     COleObject::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleObject::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleObject::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetClientSite
//
//  Synopsis:   Save the IOleClientSite pointer passed - it's this
//              object's client site object.
//
//  Parameters: [pClientSite] - Pointer to the new client site object.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    if (_pocs != NULL)
    {
	_pocs->Release();
    }

    _pocs = pClientSite;

    if (pClientSite)
    {
	_pocs->AddRef();
    }

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetClientSite
//
//  Synopsis:   Return this objects current client site - NULL indicates
//              it hasn't been set yet.
//
//  Parameters: [ppClientSite] - Save current client site pointer here.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetClientSite(LPOLECLIENTSITE FAR *ppClientSite)
{
    *ppClientSite = _pocs;
    _pocs->AddRef();
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetHostNames
//
//  Synopsis:   See spec 2.00.09 p99.  Returns names the caller can use
//              to display our object name (in window titles and such).
//
//  Parameters: [szContainerApp] - Name of container application.
//              [szContainerObj] - Name of this object.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetHostNames(
	LPCWSTR szContainerApp,
	LPCWSTR szContainerObj)
{
    szContainerApp = L"Test Server";
    szContainerObj = L"Test Server:Test Object";
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Close
//
//  Synopsis:   See spec 2.00.09 p104.  Short story is:  if fMerelyHide,
//              turn off the UI of this object, else return to the
//              "loaded" state, which for us means to shut down (since we
//              don't do any caching).
//
//  Parameters: [dwSaveOption] - ???
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - what if we have multiple instances?  Do we
//                return the server app to the loaded state or do we
//                return this object to the loaded state?
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Close(DWORD dwSaveOption)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetMoniker
//
//  Synopsis:   See spec 2.00.09 p99.  The moniker for this object
//              (or it's container) has been changed to that passed
//              in.  Take appropriate actions (de-register old object
//              and register new, inform contained objects, etc).
//
//  Parameters: [dwWhichMoniker] - Moniker type being sent.
//              [pmk]            - The new moniker.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();

    }

    _pmkContainer = pmk;

    pmk->AddRef();

    // Set moniker in container
    IOleObject *pobj;

    HRESULT hresult = _pocs->QueryInterface(IID_IOleObject, (void **) &pobj);

    pobj->SetMoniker(dwWhichMoniker, pmk);

    pobj->Release();

    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetMoniker
//
//  Synopsis:   See spec 2.00.09 p100.  Return either this objects
//              container moniker, this objects relative moniker, or
//              this objects full moniker.
//
//  Parameters: [dwAssign]       - Condition to get moniker.
//              [dwWhichMoniker] - Kind of moniker being requested.
//              [ppmk]           - Return moniker here.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetMoniker(
        DWORD          dwAssign,
        DWORD          dwWhichMoniker,
        LPMONIKER FAR *ppmk)
{
    *ppmk = _pmkContainer;
    _pmkContainer->AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::InitFromData
//
//  Synopsis:   See spec 2.00.09 p100.  Initialize this object from
//              the format passed in.
//
//  Parameters: [pDataObject] - IDataObject providing data.
//              [fCreation]   - TRUE if this is the initial creation.
//              [dwReserved]  - Ignored.
//
//  Returns:    S_OK if we attempt to initialize, S_FALSE if we don't
//              want to.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::InitFromData(
        LPDATAOBJECT pDataObject,
        BOOL         fCreation,
        DWORD        dwReserved)
{
    // BUGBUG - NYI
    return(S_FALSE);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetClipboardData
//
//  Synopsis:   See spec 2.00.09 p101.  Return clipboard object that would
//              be created if Edit/Copy were done to this item.
//
//  Parameters: [dwReserved]   - Ignored.
//              [ppDataObject] - IDataObject return locale.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetClipboardData(
        DWORD             dwReserved,
        LPDATAOBJECT FAR *ppDataObject)
{
    // BUGBUG - NYI
    *ppDataObject = NULL;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::DoVerb
//
//  Synopsis:   See spec 2.00.09 p101.  Execute the verb passed in.
//
//  Parameters: [iVerb]       - Verb being requested.
//              [pMsg]        - Message that triggered the request.
//              [pActiveSite] - IOleClientSite for this object.
//              [lReserved]   - Ignored.
//
//  Returns:    S_OK, or other ones specified but not defined yet...
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::DoVerb(
        LONG            iVerb,
        LPMSG           pMsg,
        LPOLECLIENTSITE pActiveSite,
	LONG		lReserved,
	HWND		hwndParent,
	LPCRECT 	lprcPosRect)
{
    // HWND hwndObj;

    if (OLEIVERB_SHOW == iVerb)
    {
        // BUGBUG - NYI
        // Display the object (we're not in-place yet)
	// PostMessage(g_hwndMain, WM_REPORT, MB_SHOWVERB, 0);
        // PostMessage(0xFFFF, WM_REPORT, MB_SHOWVERB, 0);
	// MessageBox(g_hwndMain, L"Received OLEIVERB_SHOW", L"OLE Server", MB_ICONINFORMATION | MB_OK);

        // Get hwndObj
        //_pteObject->GetWindow(&hwndObj);
	//MessageBox(hwndObj, L"Received OLEIVERB_SHOW", L"OLE Server", MB_ICONINFORMATION | MB_OK);
    }
    else
    {
        // Return alternate error code?
    }

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::EnumVerbs
//
//  Synopsis:   See spec 2.00.09 p103.  Enumerate all the verbs available
//              on this object in increasing numerical order.
//
//  Parameters: [ppenmOleVerb] - Enumeration object return locale.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::EnumVerbs(IEnumOLEVERB FAR* FAR *ppenmOleVerb)
{
    // BUGBUG - NYI
    *ppenmOleVerb = NULL;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Update
//
//  Synopsis:   See spec 2.00.09 p105.  Ensure any data or view caches
//              maintained inside the object are up to date.
//
//  Parameters: None
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Update()
{
    // We don't use any caches, so we don't have to do anything
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::IsUpToDate
//
//  Synopsis:   See spec 2.00.09 p105. Check to see if this object is
//              up to date - including embedded children, etc.
//
//  Parameters: None
//
//  Returns:    S_OK, S_FALSE, or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::IsUpToDate()
{
    // We should always be up to date as we don't have any caches
    // or children or links
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	COleObject::GetUserClassID
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Parameters: [dwFormOfType] -
//              [pszUserType]  -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetUserClassID(
	CLSID FAR *pClsid)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetUserType
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Parameters: [dwFormOfType] -
//              [pszUserType]  -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetUserType(
        DWORD      dwFormOfType,
	LPWSTR FAR *pszUserType)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetExtent
//
//  Synopsis:   See spec 2.00.09 p106.  Set the rectangular extent of
//              this object.  Container will call us with the size
//              it will give us; we must fit accordingly.
//
//  Parameters: [dwDrawAspect] - DVASPECT specified for this object.
//              [lpsizel]      - Extent structure.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetExtent
//
//  Synopsis:   See spec 2.00.09 p106.  Size of the object given in the
//              the last SetExtent call is returned.  If SetExtent has
//              not been called, the natural size of the object is
//              returned.
//
//  Parameters: [dwDrawAspect] - DVASPECT specified for this object.
//              [lpsizel]      - Extent structure to set.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Advise
//
//  Synopsis:   See spec 2.00.09 p121.  Set up an advisory connection
//              between this object and an advisory sink; when certain
//              events happen (birthdays?) this sink should be informed
//              by this object.  Use the OleAdviseHolder object as a
//              helper (see p122).
//
//  Parameters: [pAdvSink]      - Sink that should be informed of changes.
//              [pdwConnection] - Pass advisory token returned so our
//                                caller can shut down the link.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Advise(
        IAdviseSink FAR *pAdvSink,
        DWORD       FAR *pdwConnection)
{
//    if (NULL == _pOAHolder)
//    {
//	 if (S_OK != CreateOleAdviseHolder(&_pOAHolder))
//	 {
//	     return(E_OUTOFMEMORY);
//	 }
//    }
//
//    return(_pOAHolder->Advise(pAdvSink, pdwConnection));
    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Unadvise
//
//  Synopsis:   See spec 2.00.09 p121.  Tear down an advisory connection
//              set up previously.
//
//  Parameters: [dwConnection] - Connection established earlier.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Unadvise(DWORD dwConnection)
{
    if (NULL == _pOAHolder)
    {
        // No one is registered - see ellipswt.cpp for this
        return(E_INVALIDARG);
    }

    return(_pOAHolder->Unadvise(dwConnection));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::EnumAdvise
//
//  Synopsis:   See spec 2.00.09 p122.  Enumerate the advisory connections
//              currently attached to this object.
//
//  Parameters: [ppenmAdvise] - Enumeration object to return.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::EnumAdvise(LPENUMSTATDATA FAR *ppenmAdvise)
{
    if (NULL == _pOAHolder)
    {
	return(E_FAIL);
    }
    return(_pOAHolder->EnumAdvise(ppenmAdvise));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetMiscStatus
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetMiscStatus(
        DWORD dwAspect,
        DWORD FAR *pdwStatus)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetColorScheme
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    // BUGBUG - NYI
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server1\ctestcf.cxx ===
//+-------------------------------------------------------------------
//  File:       ctestcf.cxx
//
//  Contents:
//
//  Classes:    CTestEmbedCF - IClassFactory
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"

//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::CTestEmbedCF()
//
//  Synopsis:   The constructor for CTestEmbedCF.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbedCF::CTestEmbedCF(CTestServerApp *ptsaServer) : _cRef(1)
{
    _ptsaServer = ptsaServer;

    return;
}


//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::~CTestEmbedCF()
//
//  Synopsis:   The destructor for CTestEmbedCF.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbedCF::~CTestEmbedCF()
{
    _ptsaServer = NULL;
}


//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::Create()
//
//  Synopsis:   Creates a new CTestEmbedCF object.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
IClassFactory FAR* CTestEmbedCF::Create(CTestServerApp *ptsaServer)
{
    CTestEmbedCF FAR* pteCF = new FAR CTestEmbedCF(ptsaServer);
//    if (NULL != pteCF)
//    {
//        _ptsaServer = ptsaServer;
//    }
    return(pteCF);
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//              return pointer to the actual object
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (GuidEqual(iid, IID_IUnknown) || GuidEqual(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return(S_OK);
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CTestEmbedCF::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CTestEmbedCF::Release(void)
{
    ULONG cRefs = --_cRef;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}





//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object.
//
//  Parameters: [pUnkOuter]    - Ignored.  Affects aggregation.
//              [iidInterface] - Interface ID object should support.
//              [ppv]          - Pointer to the object.
//
//  Returns:    S_OOM if object couldn't be created, or SCODE from
//              QueryInterface call.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::CreateInstance(
        IUnknown FAR  *pUnkOuter,
        REFIID         iidInterface,
        void FAR* FAR *ppv)
{
    CTestEmbed FAR *pteObj;
    SCODE           sc;

    pteObj = new FAR CTestEmbed();
    if (pteObj == NULL)
    {
        return(E_OUTOFMEMORY);
    }
    sc = pteObj->InitObject(_ptsaServer, g_hwndMain);
    if (S_OK != sc)
    {
        delete pteObj;
        return(E_OUTOFMEMORY);
    }

    // Having created the actual object, ensure desired
    // interfaces are available.
    //
    sc = pteObj->QueryInterface(iidInterface, ppv);


    // We are done with the CTestEmbed instance - it's now referenced by ppv
    pteObj->Release();

    return(sc);
}

//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::LockServer
//
//  Synopsis:   What does this do?
//
//  Parameters: [fLock] - ???
//
//  Returns:    ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::LockServer(BOOL fLock)
{
    // BUGBUG - What does this do?
    return(E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server1\csrvapp.cxx ===
//+-------------------------------------------------------------------
//  File:       csrvapp.cxx
//
//  Contents:   Implementation of CTestServerApp
//
//  Classes:    CTestServerApp
//
//  History:    17-Dec-92   DeanE   Created
//              31-Dec-93   ErikGav Chicago port
//              25-Apr-95   BruceMa CoRevokeClassObject before shutting down
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"
#include <except.hxx>

void ProcessCmdLine(LPSTR, BOOL *);

// Used to send a quit message
extern HWND g_hwndMain;


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CTestServerApp
//
//  Synopsis:   Constructor - initialize members
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::CTestServerApp()
{
    _pteClassFactory = NULL;
    _dwRegId         = 0;
    _fRegistered     = FALSE;
    _fInitialized    = FALSE;
    _fEmbedded	     = TRUE;
    _cEmbeddedObjs   = 0;
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::~CTestServerApp
//
//  Synopsis:   Insure pointers are free - note this is mainly for
//              error-checking.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::~CTestServerApp()
{
    Win4Assert(_pteClassFactory == NULL &&
               "Class factory should have been released");
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::InitApp
//
//  Synopsis:   Initialize this instance of the app.
//
//  Parameters: [lpszCmdline] - Command line of the application.
//
//  Returns:    S_OK if everything was initialized, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      If this does not return, the CloseApp method should
//              still be called for proper cleanup.
//---------------------------------------------------------------
SCODE CTestServerApp::InitApp(LPSTR lpszCmdline)
{
    SCODE sc;

    // Check OLE version running
    // BUGBUG - NYI by OLE
    //   Bail out if we are not running with an acceptable version of OLE

    // Process Command Line arguments
    ProcessCmdLine(lpszCmdline, &_fEmbedded);

    // Look up the thread mode from the win.ini file.
    DWORD thread_mode;
    TCHAR buffer[80];
    int len;

    len = GetProfileString( TEXT("TestSrv"),
                            TEXT("ThreadMode"),
                            TEXT("MultiThreaded"),
                            buffer,
			    sizeof(buffer) / sizeof(TCHAR));

    if (lstrcmp(buffer, TEXT("ApartmentThreaded")) == 0)
    {
	thread_mode = COINIT_APARTMENTTHREADED;
	sc = CoInitialize(NULL);
    }
    else
    {
#ifdef MULTI_THREADING
	thread_mode = COINIT_MULTITHREADED;
	sc = CoInitializeEx(NULL, thread_mode);
#else
	// multi-threading not supported
	sc = E_INVALIDARG;
#endif
    }

    if (S_OK == sc)
    {
        _fInitialized = TRUE;
    }
    else
    {
        return(sc);
    }

    // Create the applications class factory - note that we have to free
    //   at a later time
    _pteClassFactory = CTestEmbedCF::Create(this);
    if (NULL == _pteClassFactory)
    {
        return(E_ABORT);
    }

    // Register the class with OLE
    sc = CoRegisterClassObject(
           CLSID_TestEmbed,
           _pteClassFactory,
           CLSCTX_LOCAL_SERVER,
	   REGCLS_MULTIPLEUSE,
           &_dwRegId);
    if (S_OK == sc)
    {
        _fRegistered = TRUE;
    }

    return(sc);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CloseApp
//
//  Synopsis:   Clean up resources this instance of the app is using.
//
//  Parameters: None
//
//  Returns:    S_OK if everything was cleaned up, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
SCODE CTestServerApp::CloseApp()
{
    // Release this apps class factory, and insure the returned count is 0
    if (NULL != _pteClassFactory)
    {
        if (0 == _pteClassFactory->Release())
        {
            _pteClassFactory = NULL;
        }
        else
        {
            // BUGBUG - Log error
        }
    }

    // Uninitialize OLE only if OleInitialize succeeded
    if (TRUE == _fInitialized)
    {
	CoUninitialize();
    }
    return(S_OK);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::GetEmbeddedFlag
//
//  Synopsis:   Returns TRUE if app was started for an embedded object,
//              FALSE if standalone.
//
//  Parameters: None
//
//  Returns:    BOOL (_fEmbedded)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
CTestServerApp::GetEmbeddedFlag()
{
    return(_fEmbedded);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::IncEmbeddedCount
//
//  Synopsis:   Increments the count of embedded objects the server
//              has open.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::IncEmbeddedCount()
{
    return(++_cEmbeddedObjs);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::DecEmbeddedCount
//
//  Synopsis:   Decrements the count of embedded objects the server
//              has open.  If 0 are left and we were running for an
//              embedded object(s), shut down.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//---------------------------------------------------------------
ULONG CTestServerApp::DecEmbeddedCount()
{
    if ((0 == --_cEmbeddedObjs) && _fEmbedded)
    {
        // Revoke the class object, if registered
        if (TRUE == _fRegistered)
        {
            CoRevokeClassObject(_dwRegId);
//            OutputDebugStringA("Revoking class object now!\n");
        }

        // Shut down the app
	SendMessage(g_hwndMain, WM_USER, 0xFFFFFFFF, 0xFFFFFFFF);
    }

    return(_cEmbeddedObjs);
}


//+--------------------------------------------------------------
// Function:    ProcessCmdline
//
// Synopsis:    Checks the cmd line parameters, in particular for
//              '/Embedding' or '-Embedding'.
//
// Parameters:  [lpszCmdLine] - Command line buffer.
//              [pfEmbedded]  - Flag should be set to true if we get
//                              the '/Embedding' switch.
//
// Returns:     void
//
// History:	25-Nov-92   DeanE   Created
//
// Notes:	Only two valid commandlines for this program:
//		(1) -Embedding when started by OLE or (2) Null
//		string if started from the command line.
//---------------------------------------------------------------
void ProcessCmdLine(LPSTR lpszCmdline, BOOL *pfEmbedded)
{
    if (lpszCmdline[0] == 0)
    {
	*pfEmbedded = FALSE;
	return;
    }

    if (strcmp(lpszCmdline, "-Embedding") == 0)
    {
	*pfEmbedded = TRUE;
	return;
    }

    Win4Assert(!"testsrv received an invalid command line!");
    *pfEmbedded = FALSE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server1\ipersist.cxx ===
//+-------------------------------------------------------------------
//  File:       ipersist.cxx
//
//  Contents:   IPersist and IPersistStorage methods of CPersistStorage class.
//
//  Classes:    CPersistStorage - IPersist, IPersistStorage implementations
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"


//+-------------------------------------------------------------------
//  Member:     CPersistStorage::CPersistStorage()
//
//  Synopsis:   The constructor for CPersistStorage.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CPersistStorage::CPersistStorage(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pteObject = pteObject;
    _fDirty    = FALSE;
}


//+-------------------------------------------------------------------
//  Member:     CPersistStorage::~CPersistStorage()
//
//  Synopsis:   The destructor for CPersistStorage.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CPersistStorage::~CPersistStorage()
{
    // _cRef should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error, someone hasn't released
    }
    return;
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPersistStorage::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPersistStorage::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::GetClassId
//
//  Synopsis:   See spec 2.00.09 p197.  Answer the Class ID of this
//              object.
//
//  Parameters: [pClassId] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::GetClassID(LPCLSID pClassId)
{
    if (NULL != pClassId)
    {
        *pClassId = CLSID_TestEmbed;
    }
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::IsDirty
//
//  Synopsis:   See spec 2.00.09 p200.  Return S_OK if the object needs
//              to be saved in order to avoid data loss, or S_FALSE
//              if not.
//
//  Parameters: None
//
//  Returns:    S_OK or S_FALSE
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::IsDirty()
{
    // BUGBUG - NYI
    //   Because we are NYI, just return S_FALSE
    return(S_FALSE);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::InitNew
//
//  Synopsis:   See spec 2.00.09 p197.  This method provides a way
//              for a container to provide persistent storage to this
//              object.  Call AddRef on the pStg passed if we do save
//              it.
//
//  Parameters: [pStg] - IStorage instance this object can use.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::InitNew(LPSTORAGE pStg)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Load
//
//  Synopsis:   See spec 2.00.09 p200.  Called by handler to put this
//              object into the running state.  Object should use the
//              pStg passed to "initialize" itself.  We can hold onto
//              this pStg, but when ::Save is called, this can be
//              a different IStorage.
//
//  Parameters: [pStg] - IStorage to initialize object from.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::Load(LPSTORAGE pStg)
{
    // BUGBUG - NYI
    //   Initialize the object here, though, just as if we had obtained
    //   data from an IStorage
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Save
//
//  Synopsis:   See spec 2.00.09 p197.  Save the data in the IStorage
//              passed.  Ignore flags for now.
//
//  Parameters: [pStgSave]    - Save data in here.
//              [fSameAsLoad] - Indicates this object is the same one
//                              that was initially started.
//              [fRemember]   - Only matters if fSameAsLoad is FALSE.
//
//  Returns:    STG_E_MEDIUMFULL - why???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::Save(
        LPSTORAGE pStgSave,
	BOOL	  fSameAsLoad)
{
    // BUGBUG - NYI
    return(STG_E_MEDIUMFULL);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::SaveCompleted
//
//  Synopsis:   See spec 2.00.09 p198.  Used only in certain circumstances.
//
//  Parameters: [pStgSaved] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::SaveCompleted(LPSTORAGE pStgSaved)
{
    // BUGBUG - NYI
    //   We don't have to worry about this unless we allow a "Save As"
    //   operation
    return(S_OK);
}



//+-------------------------------------------------------------------
//  Method:	CPersistStorage::HandsOffStorage
//
//  Synopsis:   See spec 2.00.09 p198.  Used only in certain circumstances.
//
//  Parameters: [pStgSaved] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::HandsOffStorage(void)
{
    // BUGBUG - NYI
    //   We don't have to worry about this unless we allow a "Save As"
    //   operation
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server1\idataobj.cxx ===
//+-------------------------------------------------------------------
//  File:       idataobj.cxx
//
//  Contents:   IDataObject methods of CTestEmbed class.
//
//  Classes:    CTestEmbed - IDataObject implementation
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"


//+-------------------------------------------------------------------
//  Member:     CDataObject::CDataObject()
//
//  Synopsis:   The constructor for CDataObject.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CDataObject::CDataObject(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pDAHolder = NULL;
    _pteObject = pteObject;
}


//+-------------------------------------------------------------------
//  Member:     CDataObject::~CDataObject()
//
//  Synopsis:   The destructor for CDataObject.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CDataObject::~CDataObject()
{
    // _cRef count should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error
        // Someone hasn't released one of these - Log error
    }
    return;
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDataObject::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDataObject::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetData
//
//  Synopsis:   See spec 2.00.09 p129.  Retrieve data for this object
//              using the FORMATETC passed.
//
//  Parameters: [pformatetcIn] - The format caller wants returned data
//              [pmedium]      - Returned data
//
//  Returns:    S_OK, or E_FORMAT if we don't support the format requested
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetData(
        LPFORMATETC pformatetcIn,
        LPSTGMEDIUM pmedium)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetDataHere
//
//  Synopsis:   See spec 2.00.09 p130.  Like GetData, but the pmedium is
//              allocated and ready for us to use.
//
//  Parameters: [pformatetc] - The format caller wants returned data
//              [pmedium]    - STGMEDIUM object ready for our use
//
//  Returns:    S_OK, E_FORMAT
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetDataHere(
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::QueryGetData
//
//  Synopsis:   See spec 2.00.09 p130.  Answer if the format requested
//              would be honored by GetData.
//
//  Parameters: [pformatetc] - The format being queried about
//
//  Returns:    S_OK or S_FALSE
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC pformatetc)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   See spec 2.00.09 p131
//
//  Parameters: [pformatetc]    -
//              [pformatetcOut] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetCanonicalFormatEtc(
        LPFORMATETC pformatetc,
        LPFORMATETC pformatetcOut)

{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::SetData
//
//  Synopsis:   See spec 2.00.09 p131.
//
//  Parameters: [pformatetc] -
//              [pmedium]    -
//              [fRelease]   -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::SetData(
        LPFORMATETC    pformatetc,
        STGMEDIUM FAR *pmedium,
        BOOL           fRelease)
{
    // BUGBUG - NYI
    return(DV_E_CLIPFORMAT);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::EnumFormatEtc
//
//  Synopsis:   See spec 2.00.09 p131.
//
//  Parameters: [dwDirection]    -
//              [ppenmFormatEtc] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::EnumFormatEtc(
        DWORD                dwDirection,
        LPENUMFORMATETC FAR *ppenmFormatEtc)
{
    // BUGBUG - NYI
    *ppenmFormatEtc = NULL;
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::DAdvise
//
//  Synopsis:   See spec 2.00.09 p132
//
//  Parameters: [pFormatetc]    -
//              [advf]          -
//              [pAdvSink]      -
//              [pdwConnection] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::DAdvise(
        FORMATETC FAR *pFormatetc,
        DWORD          advf,
        LPADVISESINK   pAdvSink,
        DWORD     FAR *pdwConnection)
{
    if (NULL == _pDAHolder)
    {
        if (S_OK != CreateDataAdviseHolder(&_pDAHolder))
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(_pDAHolder->Advise(this, pFormatetc, advf, pAdvSink, pdwConnection));
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::DUnadvise
//
//  Synopsis:   See spec 2.00.09 p133
//
//  Parameters: [dwConnection] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
    if (NULL == _pDAHolder)
    {
        // Nobody is registered
        return(E_INVALIDARG);
    }

    return(_pDAHolder->Unadvise(dwConnection));
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::EnumDAdvise
//
//  Synopsis:   See spec 2.00.09 p133
//
//  Parameters: [ppenmAdvise] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::EnumDAdvise(LPENUMSTATDATA FAR *ppenmAdvise)
{
    if (NULL == _pDAHolder)
    {
	return(E_FAIL);
    }

    return(_pDAHolder->EnumAdvise(ppenmAdvise));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server2\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	headers.cxx
//
//  Contents:	class precompiled headers
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------
#include    <headers.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server2\wterm.h ===
#ifndef __WTERM__
#define __WTERM__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Message to print a line on the window
#define WM_PRINT_LINE (WM_USER + 1)

// Message to print a character on the window
#define WM_PUTC (WM_USER + 2)

// Message used to terminate this window
#define WM_TERM_WND (WM_USER + 3)

//
//  Typedefs for call back functions for the window
//
typedef long (*MFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*CFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*TFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);

// Register the terminal window class
BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR ICON);

// Create a window for the terminal
BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __WTERM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server2\wterm.c ===
/****************************************************************************

    PROGRAM: wterm.c

    PURPOSE: Implementation of TermWClass Windows

    FUNCTIONS:


    COMMENTS:


****************************************************************************/

#include "windows.h"
#include "stdlib.h"
#include "memory.h"
#include "wterm.h"

#define MAX_ROWS 24
#define MAX_COLS 80

typedef struct WData
{
    // Function to execute for processing a menu
    MFUNCP pMenuProc;

    // Function to execute for processing a single character
    CFUNCP pCharProc;

    // Function to execute when window is closed (terminated)
    TFUNCP pCloseProc;

    // Pass on callback
    void *pvCallBackData;

    BOOL fGotFocus;

    BOOL fCaretHidden;

    // Rows on the screen
    int cRows;

    // Columns on the screen
    int cCols;

    // Row at top of screen
    int iTopRow;

    // Row at bottom of the screen
    int iBottomRow;

    // First Column on screen
    int iFirstCol;

    // Column at bottom of the screen
    int iBottomCol;

    // Row for next character
    int iNextRow;

    // Row for next column
    int iNextCol;

    // Width of character
    int cxChar;

    // Height of character
    int cyChar;

    // Memory image of screen this is treated as a circular buffer
    TCHAR aImage[MAX_ROWS] [MAX_COLS];

    // First row in circular screen buffer
    int iBufferTop;
} WData;

static HANDLE hInst = 0;
TCHAR BlankLine[80];

static int
row_diff(
    int row1,
    int row2)
{
    return (row2 > row1)
        ? MAX_ROWS - (row2 - row1)
        : row1 - row2;
}

static void
set_vscroll_pos(
    HWND hwnd,
    WData *pwdata)
{
    if (pwdata->cRows != 0)
    {
        // Save a few indirections by caching cRows
        register int cRows = pwdata->cRows;

        // calculate distance bottom of screen from top of data buffer
        register int top_from_row = row_diff(pwdata->iBottomRow,
            pwdata->iBufferTop);

        // Output position of scroll bar
        int new_pos = 0;

        if (top_from_row >= cRows)
        {
            // Calculate number of screens to display entire buffer
            int screens_for_data = MAX_ROWS / cRows
               + ((MAX_ROWS % cRows != 0) ? 1 : 0);

            // Figure out which screen the row falls in
            int screen_loc = top_from_row / cRows
                + ((top_from_row % cRows != 0) ? 1 : 0);

            // If the screen is in the last one set box to max
            new_pos = (screen_loc == screens_for_data)
                ? MAX_ROWS : screen_loc * cRows;
        }

        SetScrollPos(hwnd, SB_VERT, new_pos, TRUE);
    }
}

static int
calc_row(
    register int row,
    WData *pwdata)
{
    register int top = pwdata->iTopRow;
    static int boopa = 0;

    if (top > row)
        boopa++;

    return (row >= top) ? row - top : (MAX_ROWS - (top - row));
}

static void
display_text(
    HWND hwnd,
    int row,
    int col,
    LPTSTR text,
    int text_len,
    WData *pWData)
{
    // Get the DC to display the text
    HDC hdc = GetDC(hwnd);

    // Select Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Hide caret while we are printing
    HideCaret(hwnd);

    // Update the screen
    TextOut(hdc, (col - pWData->iFirstCol) * pWData->cxChar,
        calc_row(row, pWData) * pWData->cyChar, text, text_len);

    // Done with DC
    ReleaseDC(hwnd, hdc);

    // Put the caret back now that we are done
    ShowCaret(hwnd);
}

static void
display_char(
    HWND hwnd,
    TCHAR char_to_display,
    WData *pWData)
{
    // Update image buffer
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = char_to_display;

    display_text(hwnd, pWData->iNextRow, pWData->iNextCol,
      &char_to_display, 1, pWData);
}

static void
do_backspace(
    HWND hwnd,
    WData *pWData)
{
    // Point to the previous character in the line
    if (--pWData->iNextCol < 0)
    {
        // Can't backspace beyond the current line
        pWData->iNextCol = 0;
        return;
    }

    display_char(hwnd, ' ', pWData);

    // Null character for repaint
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';
}

static int
inc_row(
    int row,
    int increment)
{
    row += increment;

    if (row >= MAX_ROWS)
    {
        row -= MAX_ROWS;
    }
    else if (row < 0)
    {
        row += MAX_ROWS;
    }

    return row;
}

void
inc_next_row(
    HWND hwnd,
    WData *pWData)
{
    if (pWData->iNextRow == pWData->iBottomRow)
    {
        // Line is at bottom -- scroll the client area one row
        ScrollWindow(hwnd, 0, -pWData->cyChar, NULL, NULL);

        // Increment the top & bottom of the screen
        pWData->iTopRow = inc_row(pWData->iTopRow, 1);
        pWData->iBottomRow = inc_row(pWData->iBottomRow, 1);
    }

    // Increment the row
    pWData->iNextRow = inc_row(pWData->iNextRow, 1);

    if (pWData->iNextRow == pWData->iBufferTop)
    {
        // Have to reset circular buffer to next
        pWData->iBufferTop = inc_row(pWData->iBufferTop, 1);

        // Reset line to nulls for repaint
        memset(&pWData->aImage[pWData->iNextRow][0], '\0', MAX_COLS);
    }

    pWData->iNextCol = 0;
}

static void
do_cr(
    HWND hwnd,
    WData *pWData)
{
    // Set position to next row
    inc_next_row(hwnd, pWData);
    pWData->iNextCol = 0;

    // Make sure next character is null for repaint of line
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';

    // Update the vertical scroll bar's position
    set_vscroll_pos(hwnd, pWData);
}

static void
do_char(
    HWND hwnd,
    WPARAM wParam,
    WData *pWData)
{
    display_char(hwnd, (TCHAR) wParam, pWData);

    // Point to the next character in the line
    if (++pWData->iNextCol > MAX_COLS)
    {
        // Handle switch to next line
        inc_next_row(hwnd, pWData);
    }
}

static void
do_tab(
    HWND hwnd,
    WData *pWData)
{
    int c = pWData->iNextCol % 8;

    if ((pWData->iNextCol + c) <= MAX_COLS)
    {
        for ( ; c; c--)
        {
            do_char(hwnd, ' ', pWData);
        }
    }
    else
    {
        do_cr(hwnd, pWData);
    }
}

static void
EchoChar(
    HWND hwnd,
    WORD cRepeats,
    WPARAM wParam,
    WData *pWData)
{
    for ( ; cRepeats; cRepeats--)
    {
        switch (wParam)
        {
        // Backspace
        case '\b':
            do_backspace(hwnd, pWData);
            break;

        // Carriage return
        case '\n':
        case '\r':
            do_cr(hwnd, pWData);
            break;

        // Tab
        case '\t':
            do_tab(hwnd, pWData);
            break;

        // Regular characters
        default:
            do_char(hwnd, wParam, pWData);
        }
    }

    // The row is guaranteed to be on the screen because we will
    // scroll on a CR. However, the next column for input may be
    // beyond the window we are working in.
    if (pWData->iNextCol > pWData->iBottomCol)
    {
        // We are out of the window so scroll the window one
        // column to the right.
        SendMessage(hwnd, WM_HSCROLL, SB_LINEDOWN, 0L);
    }
    else if (pWData->iNextCol < pWData->iFirstCol)
    {
        // We are out of the window so repaint the window using
        // iNextCol as the first column for the screen.
        pWData->iFirstCol = pWData->iNextCol;
        pWData->iBottomCol = pWData->iFirstCol + pWData->cCols - 1;

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pWData->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
    else
    {
        // Reset Caret's position
        SetCaretPos((pWData->iNextCol - pWData->iFirstCol) * pWData->cxChar,
            calc_row(pWData->iNextRow, pWData) * pWData->cyChar);
    }
}

/****************************************************************************

    FUNCTION: WmCreate(HWND)

    PURPOSE:  Initializes control structures for a TermWClass Window

    MESSAGES:
              WM_CREATE

    COMMENTS:

            This prepares a window for processing character based
            I/O. In particular it does stuff like calculate the
            size of the window needed.

****************************************************************************/
static void
WmCreate(
    HWND hwnd,
    CREATESTRUCT *pInit)
{
    WData *pData = (WData *) (pInit->lpCreateParams);
    HDC hdc = GetDC(hwnd);
    TEXTMETRIC tm;

    // Store pointer to window data
    SetWindowLong(hwnd, 0, (LONG) pData);

    // Set font to system fixed font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Calculate size of a character
    GetTextMetrics(hdc, &tm);
    pData->cxChar = tm.tmAveCharWidth;
    pData->cyChar = tm.tmHeight;
    ReleaseDC(hwnd, hdc);

    // Set up vertical scroll bars
    SetScrollRange(hwnd, SB_VERT, 0, MAX_ROWS, TRUE);
    SetScrollPos(hwnd, SB_VERT, 0, TRUE);

    // Set up horizontal scroll bars
    SetScrollRange(hwnd, SB_HORZ, 0, MAX_COLS, TRUE);
    SetScrollPos(hwnd, SB_HORZ, 0, TRUE);
}

/****************************************************************************

    FUNCTION: WmSize(HWND, WORD, LONG)

    PURPOSE:  Processes a size message

    MESSAGES:

    COMMENTS:

****************************************************************************/
static void
WmSize(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    // Get the new size of the window
    int cxClient;
    int cyClient;
    int cRowChange = pwdata->cRows;
    RECT rect;

    // Get size of client area
    GetClientRect(hwnd, &rect);

    // Calculate size of client area
    cxClient = rect.right - rect.left;
    cyClient = rect.bottom - rect.top;

    // Calculate size of area in rows
    pwdata->cCols = cxClient / pwdata->cxChar;
    pwdata->cRows = min(MAX_ROWS, cyClient / pwdata->cyChar);
    pwdata->iBottomCol = min(pwdata->iFirstCol + pwdata->cCols, MAX_COLS);
    cRowChange = pwdata->cRows - cRowChange;

    // Keep input line toward bottom of screen
    if (cRowChange < 0)
    {
        // Screen has shrunk in size.
        if (pwdata->iNextRow != pwdata->iTopRow)
        {
            // Has input row moved out of screen?
            if (row_diff(pwdata->iNextRow, pwdata->iTopRow) >= pwdata->cRows)
            {
                // Yes -- Calculate top new top that puts input line on
                // the bottom.
                pwdata->iTopRow =
                    inc_row(pwdata->iNextRow, 1 - pwdata->cRows);
            }
        }
    }
    else
    {
        // Screen has gotten bigger -- Display more text if possible
        if (pwdata->iTopRow != pwdata->iBufferTop)
        {
            pwdata->iTopRow = inc_row(pwdata->iTopRow,
                -(min(row_diff(pwdata->iTopRow, pwdata->iBufferTop),
                    cRowChange)));
        }
    }

    // Calculate new bottom
    pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows - 1);

    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);
}

static void
WmSetFocus(
    HWND hwnd,
    WData *pwdata)
{
    // save indirections
    register int cxchar = pwdata->cxChar;
    register int cychar = pwdata->cyChar;
    pwdata->fGotFocus = TRUE;
    CreateCaret(hwnd, NULL, cxchar, cychar);

    if (!pwdata->fCaretHidden)
    {
        SetCaretPos(pwdata->iNextCol * cxchar,
            calc_row(pwdata->iNextRow, pwdata) * cychar);
    }

    ShowCaret(hwnd);
}

static void
WmKillFocus(
    HWND hwnd,
    WData *pwdata)
{
    pwdata->fGotFocus = FALSE;

    if (!pwdata->fCaretHidden)
    {
        HideCaret(hwnd);
    }

    DestroyCaret();
}

static void
WmVscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    int cVscrollInc = 0;
    register int top_diff = row_diff(pwdata->iTopRow, pwdata->iBufferTop);
    register int bottom_diff = MAX_ROWS - (top_diff + pwdata->cRows);

    switch(wParam)
    {
    case SB_TOP:

        if (top_diff != 0)
        {
            cVscrollInc = -top_diff;
        }

        break;

    case SB_BOTTOM:

        if (bottom_diff != 0)
        {
            cVscrollInc = bottom_diff;
        }

        break;

    case SB_LINEUP:

        if (top_diff != 0)
        {
            cVscrollInc = -1;
        }

        break;

    case SB_LINEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = 1;
        }

        break;

    case SB_PAGEUP:

        if (top_diff != 0)
        {
            cVscrollInc = - ((top_diff > pwdata->cRows)
                ? pwdata->cRows : top_diff);
        }

        break;

    case SB_PAGEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = (bottom_diff > pwdata->cRows)
                ? pwdata->cRows : bottom_diff;
        }

        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cVscrollInc = LOWORD(lParam)
                - row_diff(pwdata->iTopRow, pwdata->iBufferTop);
        }
    }

    // Cacluate new top row
    if (cVscrollInc != 0)
    {
        // Calculate new top and bottom
        pwdata->iTopRow = inc_row(pwdata->iTopRow, cVscrollInc);
        pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows);

        // Scroll window
        ScrollWindow(hwnd, 0, pwdata->cyChar * cVscrollInc, NULL, NULL);

        // Reset scroll bar
        set_vscroll_pos(hwnd, pwdata);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmHscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    register int cHscrollInc = 0;

    switch(wParam)
    {
    case SB_LINEUP:

        cHscrollInc = -1;
        break;

    case SB_LINEDOWN:

        cHscrollInc = 1;
        break;

    case SB_PAGEUP:

        cHscrollInc = -8;
        break;

    case SB_PAGEDOWN:

        cHscrollInc = 8;
        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cHscrollInc = LOWORD(lParam) - pwdata->iFirstCol;
        }
    }

    if (cHscrollInc != 0)
    {
        // Cacluate new first column
        register int NormalizedScrollInc = cHscrollInc + pwdata->iFirstCol;

        if (NormalizedScrollInc < 0)
        {
            cHscrollInc = -pwdata->iFirstCol;
        }
        else if (NormalizedScrollInc > MAX_COLS - pwdata->cCols)
        {
            cHscrollInc = (MAX_COLS - pwdata->cCols) - pwdata->iFirstCol;
        }

        pwdata->iFirstCol += cHscrollInc;
        pwdata->iBottomCol = pwdata->iFirstCol + pwdata->cCols - 1;

        // Scroll window
        ScrollWindow(hwnd, -(pwdata->cxChar * cHscrollInc), 0, NULL, NULL);

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pwdata->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmPaint(
    HWND hwnd,
    WData *pwdata)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    register int row = pwdata->iTopRow;
    register int col = pwdata->iFirstCol;
    int bottom_row = pwdata->iBottomRow;
    int cxChar = pwdata->cxChar;
    int cyChar = pwdata->cyChar;
    int y;

    // Select System Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    while (TRUE)
    {
	int len = lstrlen(&pwdata->aImage[row][col]);

        if (len != 0)
        {
            y = calc_row(row, pwdata) * cyChar;
	    TextOut(hdc, 0, y, &pwdata->aImage[row][col], len);
        }

        if (row == bottom_row)
        {
            break;
        }

        row = inc_row(row, 1);
    }

    if (pwdata->fGotFocus)
    {
        if ((pwdata->iNextCol >= pwdata->iFirstCol)
            && (row_diff(pwdata->iNextRow, pwdata->iTopRow) < pwdata->cRows))
        {
            if (pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = FALSE;
                ShowCaret(hwnd);
            }

            SetCaretPos(
                (pwdata->iNextCol - pwdata->iFirstCol) * pwdata->cxChar,
                calc_row(pwdata->iNextRow, pwdata) * pwdata->cyChar);
        }
        else
        {
            if (!pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = TRUE;
                HideCaret(hwnd);
            }
        }
    }

    EndPaint(hwnd, &ps);
}





//
//  FUNCTION:   WmPrintLine
//
//  PURPOSE:    Print a line on the screen.
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPrintLine(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pTermData)
{
    TCHAR *pBuf = (TCHAR *) lParam;

    // MessageBox(hwnd, L"WmPrintLine", L"Debug", MB_OK);

    // DebugBreak();

    while (wParam--)
    {
        // Is character a lf?
        if (*pBuf == '\n')
        {
            // Convert to cr since that is what this window uses
            *pBuf = '\r';
        }

        // Write the character to the window
        EchoChar(hwnd, 1, *pBuf++, pTermData);
    }

}

//
//  FUNCTION:   WmPutc
//
//  PURPOSE:    Print a single character on the screen
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPutc(
    HWND hwnd,
    WPARAM wParam,
    WData *pTermData)
{
    // Is character a lf?
    if (wParam == '\n')
    {
        // Convert to cr since that is what this window uses
        wParam = '\r';
    }

    // Write the character to the window
    EchoChar(hwnd, 1, wParam, pTermData);
}


/****************************************************************************

    FUNCTION: TermWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    COMMENTS:

****************************************************************************/

long TermWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    WData *pTerm = (WData *) GetWindowLong(hWnd, 0);

    switch (message)
    {
        case WM_CREATE:
            WmCreate(hWnd, (CREATESTRUCT *) lParam);
            break;

        case WM_COMMAND:
        case WM_SYSCOMMAND:
            // Call procedure that processes the menus
            return (*(pTerm->pMenuProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_SIZE:
            WmSize(hWnd, wParam, lParam, pTerm);
            break;

        case WM_SETFOCUS:
            WmSetFocus(hWnd, pTerm);
            break;

        case WM_KILLFOCUS:
            WmKillFocus(hWnd, pTerm);
            break;

        case WM_VSCROLL:
            WmVscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_HSCROLL:
            WmHscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_CHAR:
            // Character message echo and put in buffer
            return (*(pTerm->pCharProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PAINT:
            WmPaint(hWnd, pTerm);
            break;

        case WM_USER:
        case WM_CLOSE:
	    DestroyWindow(hWnd);
            break;

        case WM_NCDESTROY:
            // Call close notification procedure
            return (*(pTerm->pCloseProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PRINT_LINE:
            WmPrintLine(hWnd, wParam, lParam, pTerm);
            break;

        case WM_PUTC:
            WmPutc(hWnd, wParam, pTerm);
	    break;

	case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

	case WM_TERM_WND:
	    DestroyWindow(hWnd);
	    break;

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return 0;
}


/****************************************************************************

    FUNCTION: TermRegisterClass(HANDLE)

    PURPOSE:  Register a class for a terminal window

    COMMENTS:


****************************************************************************/

BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR Icon)
{
    WNDCLASS  wc;
    BOOL retVal;

    // Make sure blank line is blank
    memset(BlankLine, ' ', 80);

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;
    wc.lpfnWndProc = TermWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(WData *);
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, Icon);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  MenuName;
    wc.lpszClassName = ClassName;

    /* Register the window class and return success/failure code. */
    if (retVal = RegisterClass(&wc))
    {
        // Class got registered -- so finish set up
        hInst = hInstance;
    }

    return retVal;
}


/****************************************************************************

    FUNCTION:  TermCreateWindow(LPWSTR, LPWSTR, HMENU, void *, void *, int)

    PURPOSE:   Create a window of a previously registered window class

    COMMENTS:


****************************************************************************/

BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData)
{
    HWND            hWnd;               // Main window handle.
    WData           *pTermData;

    // Allocate control structure for the window
    if ((pTermData = malloc(sizeof(WData))) == NULL)
    {
        return FALSE;
    }

    // Set entire structure to nulls
    memset((TCHAR *) pTermData, '\0', sizeof(WData));

    // Initialize function pointers
    pTermData->pMenuProc = MenuProc;
    pTermData->pCharProc = CharProc;
    pTermData->pCloseProc = CloseProc;

    // Initialize callback data
    pTermData->pvCallBackData = pvCallBackData;

    // Create a main window for this application instance.
    hWnd = CreateWindow(
        lpClassName,
        lpWindowName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        hMenu,
        hInst,
	(LPTSTR) pTermData
    );

    // If window could not be created, return "failure"

    if (!hWnd)
    {
        free(pTermData);
        return FALSE;
    }

    // BUGBUG - Why would we want to set focus?
    // SetFocus(hWnd);

    // Make the window visible; update its client area; and return "success"

    //  ShowWindow(hWnd, nCmdShow);
    //  UpdateWindow(hWnd);
    *phNewWindow = hWnd;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server2\olesrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:       oleimpl.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//			CAdvBndCF (class factory)
//			CAdvBnd   (actual class implementation)
//
//  Classes:	CAdvBndCF, CAdvBnd
//
//
//  History:	30-Nov-92      SarahJ      Created
//              31-Dec-93      ErikGav     Chicago port
//---------------------------------------------------------------------

// Turn off ole Cairol IUnknown
#include    "headers.cxx"
#pragma hdrstop
#include    <stdio.h>
#include    <stdarg.h>
#include    "wterm.h"


#define IDM_DEBUG 0x100

static const TCHAR *szAppName = TEXT("Test OLE Server");
static const char *szFatalError = "OLESRV - Fatal Error";

void MsgBox(char *pszMsg)
{
    MessageBoxA(NULL, pszMsg, szFatalError, MB_OK);
}

void HrMsgBox(char *pszMsg, HRESULT hr)
{
    char awcBuf[512];

    // Build string for output
    wsprintfA(awcBuf, "%s HRESULT = %lx", pszMsg, hr);

    // Display message box
    MessageBoxA(NULL, &awcBuf[0], szFatalError, MB_OK);
}

//+-------------------------------------------------------------------
//  Class:    CTestServerApp
//
//  Synopsis: Class that holds application-wide data and methods
//
//  Methods:  InitApp
//            CloseApp
//            GetEmbeddedFlag
//
//  History:  17-Dec-92     DeanE   Created
//--------------------------------------------------------------------
class FAR CTestServerApp
{
public:

// Constructor/Destructor
    CTestServerApp();
    ~CTestServerApp();

    SCODE InitApp         (LPSTR lpszCmdline);
    SCODE CloseApp        (void);
    BOOL  GetEmbeddedFlag (void);
    ULONG IncEmbeddedCount(void);
    ULONG DecEmbeddedCount(void);

private:
    IClassFactory *_pteClassFactory;
    ULONG          _cEmbeddedObjs;  // Count of embedded objects this server
                                    // is controlling now
    DWORD          _dwRegId;        // OLE registration ID
    BOOL           _fRegistered;    // TRUE if srv was registered w/OLE
    BOOL           _fEmbedded;      // TRUE if OLE started us at the request
                                    //   of an embedded obj in a container app
};

CTestServerApp tsaMain;
HWND g_hMain;

void ProcessCmdLine(LPSTR, BOOL *);

//+--------------------------------------------------------------
//  Function:   CTestServerApp::CTestServerApp
//
//  Synopsis:   Constructor - initialize members
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::CTestServerApp()
{
    _pteClassFactory = NULL;
    _dwRegId         = 0;
    _fRegistered     = FALSE;
    _fEmbedded	     = TRUE;
    _cEmbeddedObjs   = 0;
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::~CTestServerApp
//
//  Synopsis:   Insure pointers are free - note this is mainly for
//              error-checking.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::~CTestServerApp()
{
    Win4Assert(_pteClassFactory == NULL &&
               "Class factory should have been released");
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::InitApp
//
//  Synopsis:   Initialize this instance of the app.
//
//  Parameters: [lpszCmdline] - Command line of the application.
//
//  Returns:    S_OK if everything was initialized, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      If this does not return, the CloseApp method should
//              still be called for proper cleanup.
//---------------------------------------------------------------
SCODE CTestServerApp::InitApp(LPSTR lpszCmdline)
{
    SCODE sc;

    // Check OLE version running
    // BUGBUG - NYI by OLE
    //   Bail out if we are not running with an acceptable version of OLE

    // Process Command Line arguments
    ProcessCmdLine(lpszCmdline, &_fEmbedded);

    // Create the applications class factory - note that we have to free
    //   at a later time
    _pteClassFactory = new CAdvBndCF();

    if (NULL == _pteClassFactory)
    {
        MsgBox("Class Object Creation Failed");
        return(E_ABORT);
    }

    // Register the class with OLE
    sc = CoRegisterClassObject(
           CLSID_AdvBnd,
           _pteClassFactory,
           CLSCTX_LOCAL_SERVER,
	   REGCLS_MULTIPLEUSE,
           &_dwRegId);

    if (S_OK == sc)
    {
        _fRegistered = TRUE;
    }
    else
    {
        HrMsgBox("CoRegisterClassObject FAILED", sc);
    }

    return(sc);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CloseApp
//
//  Synopsis:   Clean up resources this instance of the app is using.
//
//  Parameters: None
//
//  Returns:    S_OK if everything was cleaned up, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
SCODE CTestServerApp::CloseApp()
{
    // Revoke the class object, if registered
    if (TRUE == _fRegistered)
    {
        CoRevokeClassObject(_dwRegId);
    }

    // Release this apps class factory, and insure the returned count is 0
    if (NULL != _pteClassFactory)
    {

      // NB: Workaround for ref count problem.

      #define HACK 1
      #if HACK
        _pteClassFactory->Release();
        _pteClassFactory = NULL;
      #else
        if (0 == _pteClassFactory->Release())
        {
            _pteClassFactory = NULL;
        }
        else
        {
            Win4Assert("Release on class factory returned positive ref count");
            // BUGBUG - Log error
        }
      #endif
    }

    return(S_OK);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::GetEmbeddedFlag
//
//  Synopsis:   Returns TRUE if app was started for an embedded object,
//              FALSE if standalone.
//
//  Parameters: None
//
//  Returns:    BOOL (_fEmbedded)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
CTestServerApp::GetEmbeddedFlag()
{
    return(_fEmbedded);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::IncEmbeddedCount
//
//  Synopsis:   Increments the count of embedded objects the server
//              has open.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::IncEmbeddedCount()
{
    return(++_cEmbeddedObjs);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::DecEmbeddedCount
//
//  Synopsis:   Decrements the count of embedded objects the server
//              has open.  If 0 are left and we were running for an
//              embedded object(s), shut down.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::DecEmbeddedCount()
{
    if ((0 == --_cEmbeddedObjs) && _fEmbedded)
    {
        // We are done so revoke our OLE stuff. We need to do this as
        // soon as we know that we are shutting down so that the window
        // for returning a bad class object is shut.
        CloseApp();

        // Tell window to die
	SendMessage(g_hMain, WM_USER, 0xFFFFFFFF, 0xFFFFFFFF);
    }

    return(_cEmbeddedObjs);
}


//+--------------------------------------------------------------
// Function:    ProcessCmdline
//
// Synopsis:    Checks the cmd line parameters, in particular for
//              '/Embedding' or '-Embedding'.
//
// Parameters:  [lpszCmdLine] - Command line buffer.
//              [pfEmbedded]  - Flag should be set to true if we get
//                              the '/Embedding' switch.
//
// Returns:     void
//
// History:	25-Nov-92   DeanE   Created
//
// Notes:	Only two valid commandlines for this program:
//		(1) -Embedding when started by OLE or (2) Null
//		string if started from the command line.
//---------------------------------------------------------------
void ProcessCmdLine(LPSTR lpszCmdline, BOOL *pfEmbedded)
{
    if (lpszCmdline[0] == 0)
    {
	*pfEmbedded = FALSE;
	return;
    }

    if (strcmp(lpszCmdline, "-Embedding") == 0)
    {
	*pfEmbedded = TRUE;
	return;
    }

    MsgBox("Received an invalid command line!");
    *pfEmbedded = FALSE;

    return;
}

void Display(TCHAR *pszFmt, ...)
{
    va_list marker;
    TCHAR szBuffer[256];

    va_start(marker, pszFmt);

    #ifdef UNICODE
    int iLen = vswprintf(szBuffer, pszFmt, marker);
    #else
    int iLen = vsprintf(szBuffer, pszFmt, marker);
    #endif

    va_end(marker);

    // Display the message on terminal window
    SendMessage(g_hMain, WM_PRINT_LINE, iLen, (LONG) szBuffer);
}




//+-------------------------------------------------------------------------
//
//  Function:	ProcessMenu
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessMenu(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    if ((uiMessage == WM_SYSCOMMAND) && (wParam == IDM_DEBUG))
    {
	// Request for a debug breakpoint!
	DebugBreak();
    }


    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessChar
//
//  Synopsis:	Gets called when a WM_CHAR message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessChar(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessClose
//
//  Synopsis:	Gets called when a NC_DESTROY message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessClose(
    HWND hWindow,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    void *pvCallBackData)
{
    // Take default action with message
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    char *lpszCmdLine,
    int nCmdShow)
{
    // For windows message
    MSG msg;
    BOOL bRet;
    HRESULT hr;

    // Register the window class
    bRet = TermRegisterClass(hInstance, NULL, (LPTSTR) szAppName,
	                     (LPTSTR) MAKEINTRESOURCE(IDI_APPLICATION));

    if (!bRet)
    {
        MsgBox("TermRegisterClass FAILED");
        return 1;
    }

    // Create the server window
    bRet = TermCreateWindow(
	(LPTSTR) szAppName,
	(LPTSTR) szAppName,
	NULL,
	ProcessMenu,
	ProcessChar,
	ProcessClose,
	SW_SHOWMINIMIZED,
	&g_hMain,
	NULL);

    if (!bRet)
    {
        MsgBox("TermCreateWindow FAILED");
        return 1;
    }

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hMain, FALSE);

    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, TEXT("Debug"));

    // Look up the thread mode from the win.ini file.
    DWORD thread_mode;
    TCHAR buffer[80];
    int len;

    len = GetProfileString( TEXT("OleSrv"),
                            TEXT("ThreadMode"),
                            TEXT("MultiThreaded"),
                            buffer,
                            sizeof(buffer) / sizeof(TCHAR));

    if (lstrcmp(buffer, TEXT("ApartmentThreaded")) == 0)
    {
	thread_mode = COINIT_APARTMENTTHREADED;
	hr = CoInitialize(NULL);
    }
    else
    {
#ifdef MULTI_THREADING
	thread_mode = COINIT_MULTITHREADED;
	hr = CoInitializeEx(NULL, thread_mode);
#else
	hr = E_INVALIDARG;
#endif
    }

    if (S_OK != hr)
    {
	HrMsgBox("CoInitialize FAILED", hr);
        return(1);
    }


    // Initialize Application
    if (S_OK != tsaMain.InitApp(lpszCmdLine))
    {
        tsaMain.CloseApp();
        return(1);
    }

    if (tsaMain.GetEmbeddedFlag())
    {
        // We're running as an embedded app
        // Don't show the main window unless we're instructed to do so
        // BUGBUG - In-place editing is NYI
	ShowWindow(g_hMain, SW_SHOWMINIMIZED);
    }
    else
    {
        // We are not running as an embedded app - show the main window
        ShowWindow(g_hMain, nCmdShow);
    }

    UpdateWindow(g_hMain);


    // message loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // If we get here, we initialized OLE so let's uninitialize it.
    CoUninitialize();

    return (msg.wParam);	   /* Returns the value from PostQuitMessage */
}



//+-------------------------------------------------------------------
//
//  Class:    CAdvBndCF
//
//  Synopsis: Class Factory for CAdvBnd
//
//  Interfaces:  IUnknown      - QueryInterface, AddRef, Release
//               IClassFactory - CreateInstance
//
//  History:  21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


//+-------------------------------------------------------------------
//
//  Member:	CAdvBndCF::CAdvBndCF()
//
//  Synopsis:	The constructor for CAdvBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::CAdvBndCF() : _cRefs(1)
{
    // Load the class object for the class to aggregate.
    HRESULT hresult = CoGetClassObject(CLSID_BasicBnd, CLSCTX_SERVER, NULL,
	IID_IClassFactory, (void **) &_xifac);

    return;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::~CAdvBndCF()
{
    return;
}


//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (GuidEqual(iid, IID_IUnknown)
	|| GuidEqual(iid, IID_IClassFactory))
    {
	*ppv = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else
    {
        *ppv = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CAdvBndCF::AddRef(void)
{
    return(++_cRefs);
}

STDMETHODIMP_(ULONG) CAdvBndCF::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
        return(0);
    }

    return _cRefs;
}





//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------

STDMETHODIMP CAdvBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    Display(TEXT("CAdvBndCF::CreateInstance called\n"));

    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    CAdvBnd * lpcBB = new FAR CAdvBnd((IClassFactory *) _xifac);

    if (lpcBB == NULL)
    {
	return E_OUTOFMEMORY;
    }

    HRESULT hresult = lpcBB->QueryInterface(iidInterface, ppv);

    lpcBB->Release();

    return hresult;
}

STDMETHODIMP CAdvBndCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::CAdvBnd()
//
//  Synopsis:	The constructor for CAdvBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::CAdvBnd(IClassFactory *pcfBase) : _xiunk(), _dwRegister(0), _cRefs(1)
{
    HRESULT hresult = pcfBase->CreateInstance((IUnknown *) this, IID_IUnknown,
	(void **) &_xiunk);

    tsaMain.IncEmbeddedCount();

    return;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::~CAdvBnd()
{
    Display(TEXT("CAdvBndCF::~CAdvBnd called\n"));

    if (_dwRegister != 0)
    {
	// Get the running object table
	IRunningObjectTable *prot;

	HRESULT hresult = GetRunningObjectTable(0, &prot);

        if (hresult != S_OK)
        {
            HrMsgBox("CAdvBnd::~CAdvBnd GetRunningObjectTable failed", hresult);
        }
        else
        {
	    hresult = prot->Revoke(_dwRegister);

            if (hresult != S_OK)
            {
                HrMsgBox("CAdvBnd::~CAdvBnd Revoke failed", hresult);
            }

	    prot->Release();
        }
    }

    tsaMain.DecEmbeddedCount();
    return;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::QueryInterface
//
//  Returns:    SUCCESS_SUCCCESS
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::QueryInterface(REFIID iid, void ** ppunk)
{
    Display(TEXT("CAdvBnd::QueryInterface called\n"));

    if (GuidEqual(iid, IID_IUnknown))
    {
	*ppunk = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else if ((GuidEqual(iid, IID_IPersistFile))
	|| (GuidEqual(iid, IID_IPersist)))
    {
	*ppunk = (IPersistFile *) this;
	AddRef();
	return S_OK;
    }

    return _xiunk->QueryInterface(iid, ppunk);
}

STDMETHODIMP_(ULONG) CAdvBnd::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CAdvBnd::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
        return(0);
    }

    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Load
//
//  Synopsis:   IPeristFile interface - needed 'cause we bind with
//              file moniker and BindToObject insists on calling this
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Load(LPCWSTR lpszFileName, DWORD grfMode)
{
    Display(TEXT("CAdvBndCF::Load called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Load(lpszFileName, grfMode);

    pipfile->Release();

    if (FAILED(hresult))
    {
	// Make sure delegated too class liked what it got/
	// BUGBUG: Can't just forward hresults!
	return hresult;
    }

    // Create a file moniker
    IMoniker *pmk;
    hresult = CreateFileMoniker((LPWSTR)lpszFileName, &pmk);

    if (FAILED(hresult))
    {
        HrMsgBox("CAdvBnd::Load CreateFileMoniker failed", hresult);
        return hresult;
    }

    // Get the running object table
    IRunningObjectTable *prot;

    hresult = GetRunningObjectTable(0, &prot);

    if (FAILED(hresult))
    {
        HrMsgBox("CAdvBnd::Load GetRunningObjectTable failed", hresult);
        return hresult;
    }

    // Register in the running object table
    IUnknown *punk;
    QueryInterface(IID_IUnknown, (void **) &punk);

    hresult = prot->Register(0, punk, pmk, &_dwRegister);

    if (FAILED(hresult))
    {
        HrMsgBox("CAdvBnd::Load Register failed", hresult);
        return hresult;
    }

    // Set filetime to known value
    FILETIME filetime;
    memset(&filetime, 'B', sizeof(filetime));

    // Set time to some known value
    prot->NoteChangeTime(_dwRegister, &filetime);

    // Release uneeded objects
    pmk->Release();
    prot->Release();
    punk->Release();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Save
//
//  Synopsis:   IPeristFile interface - save
//              does little but here for commentry
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Save(LPCWSTR lpszFileName, BOOL fRemember)
{
    Display(TEXT("CAdvBndCF::Save called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Save(lpszFileName, fRemember);

    pipfile->Release();

    return hresult;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::SaveCpmpleted
//		CAdvBnd::GetCurFile
//		CAdvBnd::IsDirty
//
//  Synopsis:   More IPeristFile interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::SaveCompleted(LPCWSTR lpszFileName)
{
    Display(TEXT("CAdvBndCF::SaveCompleted called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->SaveCompleted(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::GetCurFile(LPWSTR FAR *lpszFileName)
{
    Display(TEXT("CAdvBndCF::GetCurFile called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->GetCurFile(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::IsDirty()
{
    Display(TEXT("CAdvBndCF::IsDirty called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->IsDirty();

    pipfile->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//

STDMETHODIMP CAdvBnd::GetClassID(LPCLSID classid)
{
    Display(TEXT("CAdvBndCF::GetClassID called\n"));

    *classid = CLSID_AdvBnd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server1\testsrv.cxx ===
//+-------------------------------------------------------------------
//  File:       testsrv.cxx
//
//  Contents:
//
//  Classes:    CBasicSrvCF - IUnknown IClassFactory
//              CBasicSrv   - IUnknown IPersist IPersistFile IParseDisplayName
//
//  Notes:      This code is written based on OLE2.0 code. Therefore
//              all error codes, defines etc are OLE style rather than Cairo
//
//  History:    24-Nov-92   DeanE   Created
//              31-Dec-93   ErikGav Chicago port
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"
#include <stdio.h>

// BUGBUG - memory allocation hacks need these so new and delete don't
//   break us
//
#include <malloc.h>
#include <dos.h>

#define IDM_DEBUG 0x100

extern "C" LRESULT FAR PASCAL MainWndProc(HWND, UINT, WPARAM, LPARAM);
void ReportMessage(HWND, WORD);

// This is global because we're still in $%E#$#K 16-bit world
HWND g_hwndMain = NULL;

// Note constructor cannot fail
CTestServerApp tsaMain;


//+--------------------------------------------------------------
//  Function:   WinMain
//
//  Synopsis:   Initializes application and controls message pump.
//
//  Returns:    Exits with exit code 0 if success, non-zero otherwise
//
//  History:    25-Nov-92   DeanE   Created
//---------------------------------------------------------------
int PASCAL WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
        LPSTR  lpszCmdline,
        int    nCmdShow)
{
    static TCHAR szAppName[] = TEXT("OleServer");
    MSG         msg;
    WNDCLASS    wndclass;

    if (!hPrevInstance)
    {
        wndclass.style         = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = MainWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = 0;
        wndclass.hInstance     = hInstance;
        wndclass.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(125));
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = szAppName;

        if (0==RegisterClass(&wndclass))
        {
            // Error! Clean up and exit
            return(LOG_ABORT);
        }
    }

    g_hwndMain	 = CreateWindow(
                       szAppName,
		               TEXT("OLE Server"),
                       WS_OVERLAPPEDWINDOW | WS_VSCROLL,
                       GetSystemMetrics(SM_CXSCREEN)/12,      // Init X pos
                       GetSystemMetrics(SM_CYSCREEN)/12,      // Init Y pos
                       GetSystemMetrics(SM_CXSCREEN)*2/3,     // width
                       GetSystemMetrics(SM_CYSCREEN)*2/3,     // height
                       NULL,
                       NULL,
                       hInstance,
		       NULL);

    if (NULL==g_hwndMain)
    {
        // Error! Clean up and exit
        return(LOG_ABORT);
    }

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hwndMain, FALSE);

    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, TEXT("Debug"));


    // Initialize Application
    if (S_OK != tsaMain.InitApp(lpszCmdline))
    {
        tsaMain.CloseApp();
        return(LOG_ABORT);
    }

    if (tsaMain.GetEmbeddedFlag())
    {
        // We're running as an embedded app
        // Don't show the main window unless we're instructed to do so
        // BUGBUG - In-place editing is NYI
	ShowWindow(g_hwndMain, SW_SHOWMINIMIZED);
    }
    else
    {
        // We are not running as an embedded app - show the main window
        ShowWindow(g_hwndMain, nCmdShow);
    }

    UpdateWindow(g_hwndMain);


    // message loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Clean up and exit
    // BUGBUG - check return code?
    tsaMain.CloseApp();

    return(0);
}


//+--------------------------------------------------------------
// Function:    MainWndProc
//
// Synopsis:    Callback for the server window
//
// Returns:     Varies dependent on message received.
//
// History:     25-Nov-92   DeanE   Created
//---------------------------------------------------------------
extern "C" LRESULT FAR PASCAL MainWndProc(
        HWND   hwnd,
        UINT   wMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    switch(wMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
	return(0);

    case WM_USER:
	DestroyWindow(hwnd);
	return 0;

    case WM_SYSCOMMAND:

	if (wParam == IDM_DEBUG)
	{
	    // Request for a debug breakpoint!
	    DebugBreak();
	}

    default:
	break;
    }

    return(DefWindowProc(hwnd, wMsg, wParam, lParam));
}


void ReportMessage(HWND hwnd, WORD wParam)
{
    TCHAR szBuffer[256];
    szBuffer[0] = '\0';

    switch (wParam)
    {
    case MB_SHOWVERB:
	lstrcpy(szBuffer, TEXT("OLEIVERB_SHOW Received"));
        break;

    case MB_PRIMVERB:
	lstrcpy(szBuffer, TEXT("OLEIVERB_PRIMARY Received"));
        break;

    default:
	lstrcpy(szBuffer, TEXT("Unrecognized ReportMessage code"));
        break;
    }

    MessageBox(hwnd, szBuffer, TEXT("OLE Server"), MB_ICONINFORMATION | MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

extern void DeactivateIfActive(HWND hWnd);

#ifdef WIN32
extern INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam,
                           LPARAM lParam);
#endif


//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//      CSimpleApp has a contained COleInPlaceFrame.  On construction
//      of CSimpleApp, we explicitly call the constructor of this
//      contained class and pass a copy of the this pointer, so that
//      COleInPlaceFrame can refer back to this class
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructor

CSimpleApp::CSimpleApp() : m_OleInPlaceFrame(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TestDebugOut(TEXT("In CSimpleApp's Constructor \r\n"));

    // Set Ref Count
    m_nCount = 0;

    // clear members
    m_hAppWnd = NULL;
    m_hInst = NULL;
    m_lpDoc = NULL;

    // Make sure we don't think we are deactivating
    m_fDeactivating = FALSE;

    // We haven't got a unit test accelerator so ...
    m_fGotUtestAccelerator = FALSE;

    // clear flags
    m_fInitialized = FALSE;
    m_fCSHMode = FALSE;
    m_fMenuMode = FALSE;

    // used for inplace
    SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DeleteObject                Windows API
//      OleUninitialize             OLE API
//
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
    TestDebugOut(TEXT("In CSimpleApp's Destructor\r\n"));

    if (m_hStdPal)
        DeleteObject(m_hStdPal);

    // need to uninit the library...
    if (m_fInitialized)
        OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//      CSimpDoc::Close             DOC.CPP
//
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
    m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the application level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      COleInPlaceFrame::AddRef    IOIPF.CPP
//      CSimpleApp::AddRef          APP.CPP
//
// Comments:
//
//      Note that this QueryInterface is associated with the frame.
//      Since the application could potentially have multiple documents
//      and multiple objects, a lot of the interfaces are ambiguous.
//      (ie. which IOleObject is returned?).  For this reason, only
//      pointers to interfaces associated with the frame are returned.
//      In this implementation, Only IOleInPlaceFrame (or one of the
//      interfaces it is derived from) can be returned.
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpleApp::QueryInterface\r\n"));

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // looking for IUnknown
    if ( IsEqualIID(riid, IID_IUnknown))
        {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
        }

    // looking for IOleWindow
    if ( IsEqualIID(riid, IID_IOleWindow))
        {
        m_OleInPlaceFrame.AddRef();
        *ppvObj=&m_OleInPlaceFrame;
        return ResultFromScode(S_OK);
        }

    // looking for IOleInPlaceUIWindow
    if ( IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        {
        m_OleInPlaceFrame.AddRef();
        *ppvObj=&m_OleInPlaceFrame;
        return ResultFromScode(S_OK);
        }

    // looking for IOleInPlaceFrame
    if ( IsEqualIID(riid, IID_IOleInPlaceFrame))
        {
        m_OleInPlaceFrame.AddRef();
        *ppvObj=&m_OleInPlaceFrame;
        return ResultFromScode(S_OK);
        }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
    TestDebugOut(TEXT("In CSimpleApp::AddRef\r\n"));
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
    TestDebugOut(TEXT("In CSimpleApp::Release\r\n"));

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
    // Initialize our accelerator table
    if ((m_hAccel = LoadAccelerators((HINSTANCE) hInstance,
        TEXT("SimpcntrAccel"))) == NULL)
    {
        // Load failed so abort
        TestDebugOut(TEXT("ERROR: Accelerator Table Load FAILED\r\n"));
        return FALSE;
    }

    WNDCLASS  wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style = NULL;                    // Class style(s).
    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;     // Application that owns the
                                              // class.
    wc.hIcon   = LoadIcon((HINSTANCE) hInstance, TEXT("SimpCntr"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  =  TEXT("SIMPLEMENU");        // Name of menu resource in
                                                   // .RC file.
    wc.lpszClassName = TEXT("SimpCntrAppWClass");  // Name used in
                                                   // CreateWindow call

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
    wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns
                                                    // the class.
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("SimpCntrDocWClass");   // Name used in
                                                    // CreateWindow call.

    // Register the window class and return success/failure code.

    return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
    LPMALLOC lpMalloc = NULL;

#ifndef WIN32
   /* Since OLE is part of the operating system in Win32, we don't need to
    * check the version number in Win32.
    */
    DWORD dwVer = OleBuildVersion();

    // check to see if we are compatible with this version of the libraries
    if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
    {
#ifdef _DEBUG
      TestDebugOut(TEXT("WARNING:Incompatible OLE library version\r\n"));
#else
      return FALSE;
#endif
    }
#endif // WIN32

#if defined( _DEBUG )
    /* OLE2NOTE: Use a special debug allocator to help track down
    **    memory leaks.
    */
    OleStdCreateDbAlloc(0, &lpMalloc);
#endif

    //  We try passing in our own allocator first - if that fails we
    //  try without overriding the allocator.

    if (SUCCEEDED(OleInitialize(lpMalloc)) ||
        SUCCEEDED(OleInitialize(NULL)))
    {
        m_fInitialized = TRUE;
    }

#if defined( _DEBUG )
    /* OLE2NOTE: release the special debug allocator so that only OLE is
    **    holding on to it. later when OleUninitialize is called, then
    **    the debug allocator object will be destroyed. when the debug
    **    allocator object is destoyed, it will report (to the Output
    **    Debug Terminal) whether there are any memory leaks.
    */
    if (lpMalloc) lpMalloc->Release();
#endif

    m_hInst = (HINSTANCE) hInstance;

    // Create the "application" windows
    m_hAppWnd = CreateWindow (TEXT("SimpCntrAppWClass"),
                              TEXT("Simple OLE 2.0 In-Place Container"),
                              WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              NULL,
                              (HINSTANCE) hInstance,
                              NULL);

    if (!m_hAppWnd)
        return FALSE;

    m_hStdPal = OleStdCreateStandardPalette();

    ShowWindow (m_hAppWnd, nCmdShow);
    UpdateWindow (m_hAppWnd);

    // if we have been launched by the test driver, tell it our window handle
    if( m_hDriverWnd )
    {
        PostMessage(m_hDriverWnd, WM_TESTREG, (WPARAM)m_hAppWnd, 0);
    }



    return m_fInitialized;
}

//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//      IOleObject::DoVerb                          Object
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.CPP
//      CSimpleSite::GetObjRect                     SITE.CPP
//      CSimpleApp::lCreateDoc                      APP.CPP
//
//
//********************************************************************

long CSimpleApp::lCommandHandler (HWND hWnd, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    // Win32 uses high word to tell were command came from so we dump it.
    wParam = LOWORD(wParam);

    // context sensitive help...
    if (m_fMenuMode || m_fCSHMode)
    {
        if (m_fCSHMode)
        {
            // clear context sensitive help flag
            m_fCSHMode = FALSE;

            // if there is an InPlace active object, call its context
            // sensitive help method with the FALSE parameter to bring the
            // object out of the csh state.  See the technotes for details.
            if (m_lpDoc->m_lpActiveObject)
            {
                LPOLEINPLACEOBJECT lpInPlaceObject;
                m_lpDoc->m_lpActiveObject->QueryInterface(
                                             IID_IOleInPlaceObject,
                                             (LPVOID FAR *)&lpInPlaceObject);
                lpInPlaceObject->ContextSensitiveHelp(FALSE);
                lpInPlaceObject->Release();
            }
        }

        // see the technotes for details on implementing context sensitive
        // help
        if (m_fMenuMode)
        {
            m_fMenuMode = FALSE;

            if (m_lpDoc->m_lpActiveObject)
                m_lpDoc->m_lpActiveObject->ContextSensitiveHelp(FALSE);
        }
        // if we provided help, we would do it here...
        MessageBox (hWnd, TEXT("Help"), TEXT("Help"), MB_OK);

        return NULL;
    }

    // see if the command is a verb selections
    if (wParam >= IDM_VERB0)
    {
        // get the rectangle of the object
        m_lpDoc->m_lpSite->GetObjRect(&rect);

        m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(wParam - IDM_VERB0, NULL,
                                    &m_lpDoc->m_lpSite->m_OleClientSite,
                                    -1, m_lpDoc->m_hDocWnd, &rect);
    }
    else
    {
        switch (wParam)
           {
            // bring up the About box
            case IDM_ABOUT:
                {
#ifdef WIN32
                  DialogBox(m_hInst,             // current instance
                          TEXT("AboutBox"),      // resource to use
                          m_hAppWnd,             // parent handle
                          About);                // About() instance address
#else
                  FARPROC lpProcAbout = MakeProcInstance((FARPROC)About,
                                                         m_hInst);

                  DialogBox(m_hInst,               // current instance
                          TEXT("AboutBox"),        // resource to use
                          m_hAppWnd,               // parent handle
                          lpProcAbout);            // About() instance address

                  FreeProcInstance(lpProcAbout);
#endif

                  break;
                }

            // bring up the InsertObject Dialog
            case IDM_INSERTOBJECT:
                m_lpDoc->InsertObject();
                break;

            // exit the application
            case IDM_EXIT:
                SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                break;

            case IDM_NEW:
                m_lpDoc->Close();
                m_lpDoc = NULL;
                lCreateDoc(hWnd, 0, 0, 0);
                break;

            case IDM_DEACTIVATE:
                DeactivateIfActive(hWnd);
                break;

            case IDM_UTEST:
                m_fGotUtestAccelerator = TRUE;
                break;

            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
           }   // end of switch
    }  // end of else
    return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam,
                               LPARAM lParam)
{
    RECT rect;

    GetClientRect(m_hAppWnd, &rect);
    return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam,
                             LPARAM lParam)
{
    RECT rect;

    GetClientRect(hWnd, &rect);

    m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

    return NULL;
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelUI
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                            Location
//
//      COleInPlaceFrame::SetMenu           IOIPF.CPP
//      CSimpleApp::AddFrameLevelTools      APP.CPP
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelUI()
{
    m_OleInPlaceFrame.SetMenu(NULL, NULL, NULL);
    AddFrameLevelTools();
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelTools
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                              Location
//
//      COleInPlaceFrame::SetBorderSpace      IOIPF.CPP
//      InvalidateRect                        Windows API
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelTools()
{
    m_OleInPlaceFrame.SetBorderSpace(&nullRect);
    InvalidateRect(m_hAppWnd, NULL, TRUE);
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
//      IOleInPlaceActiveObject::TranslateAccelerator   Object
//
// Comments:
//
//      If an object is InPlace active, it gets the first shot at
//      handling the accelerators.
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
    HRESULT hResult;
    BOOL retval = FALSE;

    // The following is what you would do if this were an inproc DLL.
    // A local server will be passing us commands to process
#if 0
    // if we have an InPlace Active Object
    if (m_lpDoc->m_lpActiveObject)
    {
        // Pass the accelerator on...
        hResult = m_lpDoc->m_lpActiveObject->TranslateAccelerator(lpMsg);
        if (hResult == NOERROR)
            retval = TRUE;
    }
#endif

    // We process our accelerators
    return TranslateAccelerator(m_hAppWnd, m_hAccel, lpMsg);
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
    // at this level, we could enumerate through all of the
    // visible objects in the application, so that a palette
    // that best fits all of the objects can be built.

    // This app is designed to take on the same palette
    // functionality that was provided in OLE 1.0, the palette
    // of the last object drawn is realized.  Since we only
    // support one object at a time, it shouldn't be a big
    // deal.

    // if we supported multiple documents, we would enumerate
    // through each of the open documents and call paint.

    if (m_lpDoc)
        m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpleApp::ContextSensitiveHelp
//
// Purpose:
//      Used in supporting context sensitive help at the app level.
//
//
// Parameters:
//
//      BOOL fEnterMode    -   Entering/Exiting Context Sensitive
//                             help mode.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//
// Comments:
//
//      This function isn't used because we don't support Shift+F1
//      context sensitive help.  Be sure to look at the technotes
//      in the OLE 2.0 toolkit.
//
//********************************************************************

void CSimpleApp::ContextSensitiveHelp (BOOL fEnterMode)
{
    if (m_fCSHMode != fEnterMode)
    {
        m_fCSHMode = fEnterMode;

        // this code "trickles" the context sensitive help via shift+f1
        // to the inplace active object.  See the technotes for implementation
        // details.
        if (m_lpDoc->m_lpActiveObject)
        {
            LPOLEINPLACEOBJECT lpInPlaceObject;
            m_lpDoc->m_lpActiveObject->QueryInterface(IID_IOleInPlaceObject,
                                            (LPVOID FAR *)&lpInPlaceObject);
            lpInPlaceObject->ContextSensitiveHelp(fEnterMode);
            lpInPlaceObject->Release();
        }
    }
}

/* OLE2NOTE: forward the WM_QUERYNEWPALETTE message (via
**    SendMessage) to UIActive in-place object if there is one.
**    this gives the UIActive object the opportunity to select
**    and realize its color palette as the FOREGROUND palette.
**    this is optional for in-place containers. if a container
**    prefers to force its color palette as the foreground
**    palette then it should NOT forward the this message. or
**    the container can give the UIActive object priority; if
**    the UIActive object returns 0 from the WM_QUERYNEWPALETTE
**    message (ie. it did not realize its own palette), then
**    the container can realize its palette.
**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
**
**    (It is a good idea for containers to use the standard
**    palette even if they do not use colors themselves. this
**    will allow embedded object to get a good distribution of
**    colors when they are being drawn by the container)
**
*/

//**********************************************************************
//
// CSimpleApp::QueryNewPalette
//
// Purpose:
//      See above
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      0 if the handle to palette (m_hStdPal) is NULL,
//      1 otherwise
//
// Function Calls:
//      Function                                    Location
//
//      SendMessage                                 Windows API
//
//
//********************************************************************

LRESULT CSimpleApp::QueryNewPalette(void)
{
	if (m_hwndUIActiveObj)
   {
		if (SendMessage(m_hwndUIActiveObj, WM_QUERYNEWPALETTE,
				(WPARAM)0, (LPARAM)0))
      {
			/* Object selected its palette as foreground palette */
			return (LRESULT)1;
		}	
	}

	return wSelectPalette(m_hAppWnd, m_hStdPal, FALSE/*fBackground*/);
}


/* This is just a helper routine */

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground)
{
	HDC hdc;
	HPALETTE hOldPal;
	UINT iPalChg = 0;

	if (hPal == 0)
		return (LRESULT)0;

	hdc = GetDC(hWnd);
	hOldPal = SelectPalette(hdc, hPal, fBackground);
	iPalChg = RealizePalette(hdc);
	SelectPalette(hdc, hOldPal, TRUE /*fBackground*/);
	ReleaseDC(hWnd, hdc);
				
	if (iPalChg > 0)
		InvalidateRect(hWnd, NULL, TRUE);

	return (LRESULT)1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpleApp
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

#include <ole2.h>
#include "ioipf.h"

class CSimpleDoc;

class CSimpleApp : public IUnknown
{
public:

    int m_nCount;           // reference count
    HWND m_hAppWnd;         // main window handle
    HACCEL m_hAccel;        // Handle to accelerator table
    HINSTANCE m_hInst;          // application instance

    COleInPlaceFrame m_OleInPlaceFrame; // IOleInPlaceFrame Implementation

    CSimpleDoc FAR * m_lpDoc;   // pointer to document object
    BOOL m_fInitialized;        // OLE initialization flag
    BOOL m_fCSHMode;
    BOOL m_fMenuMode;
    HWND m_hwndUIActiveObj; // HWND of UIActive Object
    HPALETTE m_hStdPal;     // Color palette used by container
    BOOL m_fAppActive;      // TRUE if app is active

    BOOL m_fDeactivating;   // TRUE if we are in the process of deactivating
                            // an inplace object.

    BOOL m_fGotUtestAccelerator;// Received a unit test accelerator

    HWND m_hDriverWnd;      // Window of test driver

    CSimpleApp();           // Constructor
    ~CSimpleApp();          // Destructor
    RECT nullRect;


    // IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Initialization methods

    BOOL fInitApplication (HANDLE hInstance);
    BOOL fInitInstance (HANDLE hInstance, int nCmdShow);

    // Message handling methods

    long lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    BOOL HandleAccelerators (LPMSG lpMsg);
    void PaintApp(HDC hDC);
    void DestroyDocs();

    // In-Place support functions
    void AddFrameLevelUI();
    void AddFrameLevelTools();
    void ContextSensitiveHelp (BOOL fEnterMode);
    LRESULT QueryNewPalette(void);
};

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create(CSimpleApp FAR *lpApp, LPRECT lpRect,
                                    HWND hWnd)
{
    CSimpleDoc FAR * lpTemp = new CSimpleDoc(lpApp, hWnd);

    if (!lpTemp)
        return NULL;

    // create storage for the doc.
    HRESULT hErr = StgCreateDocfile (NULL,
                                     STGM_READWRITE | STGM_TRANSACTED |
                                     STGM_SHARE_EXCLUSIVE,
                                     0, &lpTemp->m_lpStorage);

    if (hErr != NOERROR)
        goto error;

    // create the document Window
    lpTemp->m_hDocWnd = CreateWindow(
            TEXT("SimpCntrDocWClass"),
            NULL,
            WS_CHILD | WS_CLIPCHILDREN,
            lpRect->left,
            lpRect->top,
            lpRect->right,
            lpRect->bottom,
            hWnd,
            NULL,
            lpApp->m_hInst,
            NULL);

    if (!lpTemp->m_hDocWnd)
        goto error;

    ShowWindow(lpTemp->m_hDocWnd, SW_SHOWNORMAL);  // Show the window
    UpdateWindow(lpTemp->m_hDocWnd);               // Sends WM_PAINT message

    // Ensable InsertObject menu choice
    EnableMenuItem( lpTemp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);

    // we will add one ref count on our document. later in CSimpleDoc::Close
    // we will release this  ref count. when the document's ref count goes
    // to 0, the document will be deleted.
    lpTemp->AddRef();

    return (lpTemp);

error:
    delete (lpTemp);
    return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//      None
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CloseOleObject SITE.CPP
//      ShowWindow                  Windows API
//      TestDebugOut           Windows API
//
//
//********************************************************************

void CSimpleDoc::Close(void)
{
    TestDebugOut(TEXT("In CSimpleDoc::Close\r\n"));

    ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

    // Close the OLE object in our document
    if (m_lpSite)
    	m_lpSite->CloseOleObject();

    // Release the ref count added in CSimpleDoc::Create. this will make
    // the document's ref count go to 0, and the document will be deleted.
    Release();
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
//
//********************************************************************

CSimpleDoc::CSimpleDoc(CSimpleApp FAR * lpApp,HWND hWnd)
{
    TestDebugOut(TEXT("In CSimpleDoc's Constructor\r\n"));
    m_lpApp = lpApp;
    m_lpSite = NULL;
    m_nCount = 0;
    // set up menu handles
    m_hMainMenu = GetMenu(hWnd);
    m_hFileMenu = GetSubMenu(m_hMainMenu, 0);
    m_hEditMenu = GetSubMenu(m_hMainMenu, 1);
    m_hHelpMenu = GetSubMenu(m_hMainMenu, 2);
    m_hCascadeMenu = NULL;

    m_lpActiveObject = NULL;

    // flags
    m_fInPlaceActive = FALSE;
    m_fAddMyUI = FALSE;
    m_fModifiedMenu = FALSE;
}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                     Location
//
//      TestDebugOut            Windows API
//      CSimpleSite::UnloadOleObject SITE.CPP
//      CSimpleSite::Release         SITE.CPP
//      IStorage::Release            OLE API
//      GetMenuItemCount             Windows API
//      RemoveMenu                   Windows API
//      DestroyMenu                  Windows API
//      DestroyWindows               Windows API
//
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
    TestDebugOut(TEXT("In CSimpleDoc's Destructor\r\n"));

    // Release all pointers we hold to the OLE object. also release
    // the ref count added in CSimpleSite::Create. this will make
    // the Site's ref count go to 0, and the Site will be deleted.
    if (m_lpSite)
    {
      m_lpSite->UnloadOleObject();
    	m_lpSite->Release();
    	m_lpSite = NULL;
    }

    // Release the Storage
    if (m_lpStorage)
    {
        m_lpStorage->Release();
        m_lpStorage = NULL;
    }

    // if the edit menu was modified, remove the menu item and
    // destroy the popup if it exists
    if (m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_hEditMenu);
        RemoveMenu(m_hEditMenu, nCount-1, MF_BYPOSITION);
        if (m_hCascadeMenu)
            DestroyMenu(m_hCascadeMenu);
    }

    DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      interface negotiation at document level
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      E_NOINTERFACE       -   Always
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      In this implementation, there are no doc level interfaces.
//      In an MDI application, there would be an IOleInPlaceUIWindow
//      associated with the document to provide document level tool
//      space negotiation.
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpleDoc::QueryInterface\r\n"));

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
    TestDebugOut(TEXT("In CSimpleDoc::AddRef\r\n"));
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
    TestDebugOut(TEXT("In CSimpleDoc::Release\r\n"));

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                         Location
//
//      CSimpleSite::CSimpleSite         SITE.CPP
//      CSimpleSite::InitObject          SITE.CPP
//      CSimpleSite::Release             SITE.CPP
//      memset                           C Runtime
//      OleUIInsertObject                OLE2UI function
//      CSimpleDoc::DisableInsertObject  DOC.CPP
//      IStorage::Revert                 OLE API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
    OLEUIINSERTOBJECT io;
    UINT iret;
    TCHAR szFile[OLEUI_CCHPATHMAX];

    m_lpSite = CSimpleSite::Create(this);

    if (!m_lpSite)
    {
       /* memory allocation problem! cannot carry on.
        */
       TestDebugOut(TEXT("Memory allocation error!\n"));
       return;
    }

    // clear the structure
    _fmemset(&io, 0, sizeof(OLEUIINSERTOBJECT));

    // fill the structure
    io.cbStruct = sizeof(OLEUIINSERTOBJECT);
    io.dwFlags = IOF_SELECTCREATENEW      | IOF_DISABLELINK     |
                 IOF_DISABLEDISPLAYASICON | IOF_CREATENEWOBJECT |
                 IOF_CREATEFILEOBJECT;
    io.hWndOwner = m_hDocWnd;
    io.lpszCaption = (LPTSTR) TEXT("Insert Object");
    io.iid = IID_IOleObject;
    io.oleRender = OLERENDER_DRAW;
    io.lpIOleClientSite = &m_lpSite->m_OleClientSite;
    io.lpIStorage = m_lpSite->m_lpObjStorage;
    io.ppvObj = (LPVOID FAR *)&m_lpSite->m_lpOleObject;
    io.lpszFile = szFile;
    io.cchFile = sizeof(szFile)/sizeof(TCHAR);
                            // cchFile is the number of characters of szFile
    _fmemset((LPTSTR)szFile, 0, sizeof(szFile));

    // call OUTLUI to do all the hard work
    iret = OleUIInsertObject(&io);

    if (iret == OLEUI_OK)
    {
        m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
        // disable Insert Object menu item
        DisableInsertObject();
    }
    else
    {
        m_lpSite->Release();
        m_lpSite = NULL;
        m_lpStorage->Revert();
    }

}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      IOleInPlaceActiveObject::ResizeBorder   Object
//      MoveWindow                              Windows API
//
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
    // if we are InPlace, then call ResizeBorder on the object, otherwise
    // just move the document window.
    if (m_fInPlaceActive)
        m_lpActiveObject->ResizeBorder(lpRect, &m_lpApp->m_OleInPlaceFrame,
                                       TRUE);
    else
        MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right,
                   lpRect->bottom, TRUE);

    return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OLE2UI function
//
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
    // m_fModifiedMenu is TRUE if the menu has already been modified
    // once.  Since we only support one obect every time the application
    // is run, then once the menu is modified, it doesn't have
    // to be done again.
    if (m_lpSite && !m_fInPlaceActive  && !m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_hEditMenu);

        if (!OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
                           NULL,
                           m_hEditMenu,
                           nCount + 1,
                           IDM_VERB0,
                           0,           // no maximum verb IDM enforced
                           FALSE,
                           0,
                           &m_hCascadeMenu))
        {
           TestDebugOut(TEXT("Fail in OleUIAddVerbMenu"));
        }

        m_fModifiedMenu = TRUE;
    }
    return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
    // if we supported multiple objects, then we would enumerate
    // the objects and call paint on each of them from here.

    if (m_lpSite)
        m_lpSite->PaintObj(hDC);

}

//**********************************************************************
//
// CSimpleDoc::DisableInsertObject
//
// Purpose:
//
//      Disable the ability to insert a new object in this document.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::DisableInsertObject(void)
{
    // Disable InsertObject menu choice
    EnableMenuItem( m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpleDoc
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

class CSimpleSite;
class CSimpleApp;

class CSimpleDoc : public IUnknown 
{   
public:                  
    int 			m_nCount;  
    LPSTORAGE 		m_lpStorage;
    HMENU 			m_hMainMenu;    
    HMENU 			m_hFileMenu;
    HMENU 			m_hEditMenu;
    HMENU 			m_hHelpMenu;  
    HMENU 			m_hCascadeMenu;
    LPOLEINPLACEACTIVEOBJECT m_lpActiveObject;
    BOOL 			m_fInPlaceActive;
    BOOL 			m_fAddMyUI;
    BOOL 			m_fModifiedMenu;
    
    CSimpleSite FAR * m_lpSite;
    CSimpleApp FAR * m_lpApp;
    
    HWND m_hDocWnd;

    static CSimpleDoc FAR * Create(CSimpleApp FAR *lpApp, LPRECT lpRect,HWND hWnd);

    void Close(void);

    CSimpleDoc();          
    CSimpleDoc(CSimpleApp FAR *lpApp, HWND hWnd);
    ~CSimpleDoc();        
    
    // IUnknown Interface    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 
    
    void InsertObject(void);
    void DisableInsertObject(void);
    long lResizeDoc(LPRECT lpRect);
    long lAddVerbs(void);
    void PaintDoc(HDC hDC);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\server3\fail.cxx ===
//+-------------------------------------------------------------------
//
//  File:       fail.cxx
//
//  Contents:   An exe that just returns: to test failure of process start.
//
//  History:	1-Dec-94 BillMo Created.
//
//---------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>

#define FILE_SHARE_DELETE               0x00000004

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to EXE - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    1-Dec-94  BillMo  Created
//
//--------------------------------------------------------------------

int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    char *lpszCmdLine,
    int nCmdShow)
{
    //
    // We indicate that we ran by touching a file that olebind will look at the
    // timestamps of. This is because we don't have a unique error code
    // to distinguish errors during start of a server.
    //
    HANDLE hTouchFile;
    TCHAR  tszFileName[MAX_PATH+1];
    DWORD dw;
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemDirectory(tszFileName, MAX_PATH+1);
    _tcscat(tszFileName, TEXT("\\failtst.tst"));
    hTouchFile = CreateFile(tszFileName, 
                                   GENERIC_READ|GENERIC_WRITE,
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
    if (hTouchFile == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            MessageBox(GetDesktopWindow(), 
                       TEXT("This program (fail.exe) must be run from olebind.exe"),
                       TEXT("Error in test"),
                       MB_OK);
        }
        else
        {
            MessageBox(GetDesktopWindow(), 
                       TEXT("This program (fail.exe) failed for unknown reason"),
                       TEXT("Error in test"),
                       MB_OK);
            GetLastError();
        }
        return 0;
    }
    
    GetSystemTime(&st);
    WriteFile(hTouchFile, &st, sizeof(st), &dw, NULL);
    CloseHandle(hTouchFile);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\ias.h ===
//**********************************************************************
// File name: IAS.H
//
//      Definition of CAdviseSink
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IAS_H_ )
#define _IAS_H_

#include <assert.h>

class CSimpleSite;

interface CAdviseSink : public IAdviseSink
{
    CSimpleSite FAR * m_pSite;

    CAdviseSink(CSimpleSite FAR * pSite)
       {
        TestDebugOut(TEXT("In IAS's constructor\r\n"));
        m_pSite = pSite;
       };

    ~CAdviseSink()
       {
        TestDebugOut(TEXT("In IAS's destructor\r\n"));
       } ;

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // *** IAdviseSink methods ***
    STDMETHODIMP_(void) OnDataChange (FORMATETC FAR* pFormatetc,
                                      STGMEDIUM FAR* pStgmed);
    STDMETHODIMP_(void) OnViewChange (DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename (LPMONIKER pmk);
    STDMETHODIMP_(void) OnSave ();
    STDMETHODIMP_(void) OnClose ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\ias.cpp ===
//**********************************************************************
// File name: IAS.CPP
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      used for interface negotiation
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IAS::QueryInterface\r\n"));

    // delegate to the document Object
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleSite. Since CAdviseSink is
//      a nested class of CSimpleSite, we don't need to have a separate
//      reference count for CAdviseSink. We can safely use the reference
//      count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddReff        SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
    TestDebugOut(TEXT("In IAS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleSite. Since CAdviseSink is
//      a nested class of CSimpleSite, we don't need to have a separate
//      reference count for CAdviseSink. We can safely use the reference
//      count of CSimpleSite.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
    TestDebugOut(TEXT("In IAS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      FORMATETC pFormatetc   -  data format info that was originally set up
//      STGMEDIUM pStgmed      -  storage medium which data is passed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc,
                                               STGMEDIUM FAR* pStgmed)
{
    TestDebugOut(TEXT("In IAS::OnDataChange\r\n"));
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      IOleObject::QueryInterface  Object
//      IViewObject2::GetExtent     Object
//      IViewObject2::Release       Object
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
    LPVIEWOBJECT2 lpViewObject2;

    TestDebugOut(TEXT("In IAS::OnViewChange\r\n"));

    // get a pointer to IViewObject2
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
                            IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);

    if (hErr == NOERROR)
    {
        // get extent of the object
        // NOTE: this method will never be remoted; it can be called w/i
        // this async method
        lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL,
                                 &m_pSite->m_sizel);
        lpViewObject2->Release();
    }

    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      LPMONIKER  pmk       -  new name of the object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
    TestDebugOut(TEXT("In IAS::OnRename\r\n"));
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
    TestDebugOut(TEXT("In IAS::OnSave\r\n"));
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
    TestDebugOut(TEXT("In IAS::OnClose\r\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IOCS::QueryInterface\r\n"));

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleClientSite::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need to have a separate
//      reference count for COleClientSite. We can safely use the reference
//      count of CSimpleSite.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::AddRef         SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
    TestDebugOut(TEXT("In IOCS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}


//**********************************************************************
//
// COleClientSite::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need to have a separate
//      reference count for COleClientSite. We can safely use the reference
//      count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
    TestDebugOut(TEXT("In IOCS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      OleSave                             OLE API
//      GetScode                            OLE API
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
    LPPERSISTSTORAGE lpPS;
    SCODE sc = E_FAIL;

    TestDebugOut(TEXT("In IOCS::SaveObject\r\n"));

    // get a pointer to IPersistStorage
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(IID_IPersistStorage,
                                                        (LPVOID FAR *)&lpPS);

    // save the object
    if (hErr == NOERROR)
    {
        sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
        lpPS->SaveCompleted(NULL);
        lpPS->Release();
    }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      DWORD  dwAssign         -   type of moniker to return
//      DWORD  dwWhichMoniker   -   which moniker to return
//
// Return Value:
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    TestDebugOut(TEXT("In IOCS::GetMoniker\r\n"));

    // need to null the out pointer
    *ppmk = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPOLECONTAINER  FAR * ppContainer  -  where IOleContainer interface
//                                            pointer to be returned
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    TestDebugOut(TEXT("In IOCS::GetContainer\r\n"));

    // NULL the out pointer
    *ppContainer = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
    TestDebugOut(TEXT("In IOCS::ShowObject\r\n"));
    return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      BringWindowToTop            Windows API
//      SetFocus                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    TestDebugOut(TEXT("In IOCS::OnShowWindow\r\n"));
    m_pSite->m_fObjectOpen = fShow;
    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

    // if object window is closing, then bring container window to top
    if (! fShow)
    {
        BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
        SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
    TestDebugOut(TEXT("In IOCS::RequestNewObjectLayout\r\n"));
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class CSimpleSite;

interface COleClientSite : public IOleClientSite
{
    CSimpleSite FAR * m_pSite;

    COleClientSite(CSimpleSite FAR * pSite)
       {
        TestDebugOut(TEXT("In IOCS's constructor\r\n"));
        m_pSite = pSite;
       }

    ~COleClientSite()
       {
        TestDebugOut(TEXT("In IOCS's destructor\r\n"));
       }

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IOleClientSite methods ***
    STDMETHODIMP SaveObject();
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                            LPMONIKER FAR* ppmk);
    STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
    STDMETHODIMP ShowObject();
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpcntr.h"
#include "resource.h"

extern "C" void TestDebugOut(LPSTR psz);



#ifndef WIN32
/* Since OLE is part of the operating system in Win32, we don't need to
 * check the version number in Win32.
 */
#include <ole2ver.h>
#endif  // WIN32


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\ioipf.h ===
//**********************************************************************
// File name: IOIPF.H
//
//      Definition of COleInPlaceFrame
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPF_H_ )
#define _IOIPF_H_


class CSimpleApp;

interface COleInPlaceFrame : public IOleInPlaceFrame
{
    CSimpleApp FAR * m_pApp;

    COleInPlaceFrame(CSimpleApp FAR * pApp)
       {
        TestDebugOut(TEXT("In IOIPF's constructor\r\n"));
        m_pApp = pApp;
       };

    ~COleInPlaceFrame()
       {
        TestDebugOut(TEXT("In IOIPFS's destructor\r\n"));
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceUIWindow methods ***
    STDMETHODIMP GetBorder (LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetBorderSpace (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCOLESTR lpszObjName);

    // *** IOleInPlaceFrame methods ***
    STDMETHODIMP InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus (HMENU hmenuShared);
    STDMETHODIMP SetStatusText (LPCOLESTR lpszStatusText);
    STDMETHODIMP EnableModeless (BOOL fEnable);
    STDMETHODIMP TranslateAccelerator (LPMSG lpmsg, WORD wID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\ioips.h ===
//**********************************************************************
// File name: IOIPS.H
//
//      Definition of COleInPlaceSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPS_H_ )
#define _IOIPS_H_


class CSimpleSite;

interface COleInPlaceSite : public IOleInPlaceSite
{
    CSimpleSite FAR * m_pSite;

    COleInPlaceSite(CSimpleSite FAR *pSite)
       {
        TestDebugOut(TEXT("In IOIPS's constructor\r\n"));
        m_pSite = pSite;
       };

    ~COleInPlaceSite()
       {
        TestDebugOut(TEXT("In IOIPS;s destructor\r\n"));
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceSite methods ***
    STDMETHODIMP CanInPlaceActivate ();
    STDMETHODIMP OnInPlaceActivate ();
    STDMETHODIMP OnUIActivate ();
    STDMETHODIMP GetWindowContext (LPOLEINPLACEFRAME FAR* lplpFrame,
                                   LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                                   LPRECT lprcPosRect,
                                   LPRECT lprcClipRect,
                                   LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll (SIZE scrollExtent);
    STDMETHODIMP OnUIDeactivate (BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate ();
    STDMETHODIMP DiscardUndoState ();
    STDMETHODIMP DeactivateAndUndo ();
    STDMETHODIMP OnPosRectChange (LPCRECT lprcPosRect);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\ioips.cpp ===
//**********************************************************************
// File name: IOIPS.CPP
//
//      Implementation file for COleInPlaceSite
//
// Functions:
//
//      See IOIPS.H for class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// COleInPlaceSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IOIPS::QueryInterface\r\n"));

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::AddRef()
{
    TestDebugOut(TEXT("In IOIPS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// COleInPlaceSite::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::Release()
{
    TestDebugOut(TEXT("In IOIPS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleInPlaceSite::GetWindow
//
// Purpose:
//
//      Returns the Window Handle of the client site
//
// Parameters:
//
//      HWND FAR* lphwnd    - place to return the handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindow (HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In IOIPS::GetWindow\r\n"));

    // return the handle to our editing window.
    *lphwnd = m_pSite->m_lpDoc->m_hDocWnd;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::ContextSensitiveHelp
//
// Purpose:
//      set/reset context sensitive help mode
//
// Parameters:
//
//      BOOL fEnterMode - TRUE for entering Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes included with the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::ContextSensitiveHelp (BOOL fEnterMode)
{
    TestDebugOut(TEXT("In IOIPS::ContextSensitiveHelp\r\n"));

    if (m_pSite->m_lpDoc->m_lpApp->m_fCSHMode != fEnterMode)
        m_pSite->m_lpDoc->m_lpApp->m_fCSHMode = fEnterMode;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::CanInPlaceActivate
//
// Purpose:
//
//      Object calls to find out if the container can InPlace activate
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::CanInPlaceActivate ()
{
    TestDebugOut(TEXT("In IOIPS::CanInPlaceActivate\r\n"));

    // return S_OK to indicate we can in-place activate
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceActivate
//
// Purpose:
//
//      Called by the object on InPlace Activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK             -  if the interface can be found
//      E_FAIL           -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceActivate ()
{
    HRESULT hrErr;
    TestDebugOut(TEXT("In IOIPS::OnInPlaceActivate\r\n"));

    hrErr = m_pSite->m_lpOleObject->QueryInterface(
           IID_IOleInPlaceObject, (LPVOID FAR *)&m_pSite->m_lpInPlaceObject);
    if (hrErr != NOERROR)
        return ResultFromScode(E_FAIL);

    // return S_OK to indicate we can in-place activate.
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIActivate
//
// Purpose:
//
//      Object calls this method when it displays it's UI.
//
// Parameters:
//
//      None.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                      Location
//
//      TestDebugOut             Windows API
//      ResultFromScode               OLE API
//      IOleInPlaceObject::GetWindow  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIActivate ()
{
    TestDebugOut(TEXT("In IOIPS::OnUIActivate\r\n"));

    m_pSite->m_lpDoc->m_fAddMyUI=FALSE;
    m_pSite->m_lpDoc->m_fInPlaceActive = TRUE;
    m_pSite->m_fInPlaceActive = TRUE;

    m_pSite->m_lpInPlaceObject->GetWindow((HWND FAR*)&m_pSite->m_hwndIPObj);

    // return S_OK to continue in-place activation
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::GetWindowContext
//
// Purpose:
//
//      Called by the object to get information for InPlace Negotiation.
//
// Parameters:
//
//      LPOLEINPLACEFRAME FAR* lplpFrame    - Location to return a pointer
//                                            to IOleInPlaceFrame.
//
//      LPOLEINPLACEUIWINDOW FAR* lplpDoc   - Location to return a pointer
//                                            to IOleInPlaceUIWindow.
//
//      LPRECT lprcPosRect                  - The rect that the object
//                                            occupies
//
//      LPRECT lprcClipRect                 - The clipping rect
//
//      LPOLEINPLACEFRAMEINFO lpFrameInfo   - Pointer to FRAMEINFO
//
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      COleInPlaceFrame::AddRef    IOIPF.CPP
//      CSimpleSite::GetObjRect     SITE.CPP
//      TestDebugOut           Windows API
//      CopyRect                    Windows API
//      GetClientRect               Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindowContext (
                               LPOLEINPLACEFRAME FAR* lplpFrame,
                               LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                               LPRECT lprcPosRect,
                               LPRECT lprcClipRect,
                               LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    RECT rect;

    TestDebugOut(TEXT("In IOIPS::GetWindowContext\r\n"));

    // the frame is associated with the application object.
    // need to AddRef() it...
    m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame.AddRef();
    *lplpFrame = &m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame;
    *lplpDoc = NULL;  // must be NULL, cause we're SDI.

    // get the size of the object in pixels
    m_pSite->GetObjRect(&rect);

    // Copy this to the passed buffer
    CopyRect(lprcPosRect, &rect);

    // fill the clipping region
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);
    CopyRect(lprcClipRect, &rect);

    // fill the FRAMEINFO
    if (sizeof(OLEINPLACEFRAMEINFO) != lpFrameInfo->cb)
    {
        TestDebugOut(TEXT("WARNING IOIPS::GetWindowContext "
                               "lpFrameInfo->cb size may be incorrect\r\n"));
    }

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_pSite->m_lpDoc->m_lpApp->m_hAppWnd;
    lpFrameInfo->haccel = m_pSite->m_lpDoc->m_lpApp->m_hAccel;
    lpFrameInfo->cAccelEntries = SIMPCNTR_ACCEL_CNT;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::Scroll
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      SIZE scrollExtent  - number of pixels scrolled in X and Y direction
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::Scroll (SIZE scrollExtent)
{
    TestDebugOut(TEXT("In IOIPS::Scroll\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIDeactivate
//
// Purpose:
//
//      Called by the object when its UI goes away
//
// Parameters:
//
//       BOOL fUndoable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleAPP::QueryNewPalette APP.CPP
//      CSimpleAPP::AddFrameLevelUI APP.CPP
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIDeactivate (BOOL fUndoable)
{
    TestDebugOut(TEXT("In IOIPS::OnUIDeactivate\r\n"));

    // need to clear this flag first
    m_pSite->m_lpDoc->m_fInPlaceActive = FALSE;
    m_pSite->m_fInPlaceActive = FALSE;

    m_pSite->m_lpDoc->m_lpApp->QueryNewPalette();
    m_pSite->m_lpDoc->m_lpApp->AddFrameLevelUI();
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceDeactivate
//
// Purpose:
//
//      Called when the inplace session is over
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IOleInPlaceObject::Release  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceDeactivate ()
{
    TestDebugOut(TEXT("In IOIPS::OnInPlaceDeactivate\r\n"));

    if (m_pSite->m_lpInPlaceObject)
    {
        m_pSite->m_lpInPlaceObject->Release();
        m_pSite->m_lpInPlaceObject = NULL;
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::DiscardUndoState
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DiscardUndoState ()
{
    TestDebugOut(TEXT("In IOIPS::DiscardUndoState\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::DeactivateAndUndo
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DeactivateAndUndo ()
{
    TestDebugOut(TEXT("In IOIPS::DeactivateAndUndo\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnPosRectChange
//
// Purpose:
//
//      The object calls this method when it's size changes during an
//      InPlace Session
//
// Parameters:
//
//      LPCRECT lprcPosRect -   The new object rect
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      GetClientRect                       Windows API
//      IOleObject::GetExtent               Object
//      IOleInPlaceObject::SetObjectRects   Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnPosRectChange (LPCRECT lprcPosRect)
{
    TestDebugOut(TEXT("In IOIPS::OnPosRectChange\r\n"));

    // update the size in the document object
    // NOTE: here we must call IOleObject::GetExtent to get actual extents
    //       of the running object. IViewObject2::GetExtent returns the
    //       last cached extents.
    m_pSite->m_lpOleObject->GetExtent(DVASPECT_CONTENT, &m_pSite->m_sizel);
    RECT rect;
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);

    // tell the object its new size
    m_pSite->m_lpInPlaceObject->SetObjectRects(lprcPosRect, &rect);

    return ResultFromScode(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\ioipf.cpp ===
//**********************************************************************
// File name: IOIPF.CPP
//
//      Implementation file for COleInPlaceFrame
//
// Functions:
//
//      See IOIPF.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleInPlaceFrame::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::QueryInterface  APP.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IOIPF::QueryInterface\r\n"));

    // delegate to the application Object
    return m_pApp->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceFrame::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the CSimpleApp
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::AddRef          APP.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::AddRef()
{
    TestDebugOut(TEXT("In IOIPF::AddRef\r\n"));

    // delegate to the application Object
    return m_pApp->AddRef();
}

//**********************************************************************
//
// COleInPlaceFrame::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleApp.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::Release         APP.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::Release()
{
    TestDebugOut(TEXT("In IOIPF::Release\r\n"));

    // delegate to the document object
    return m_pApp->Release();

}

//**********************************************************************
//
// COleInPlaceFrame::GetWindow
//
// Purpose:
//
//      Returns the frame window handle
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetWindow (HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In IOIPF::GetWindow\r\n"));
    *lphwnd = m_pApp->m_hAppWnd;
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::ContextSensitiveHelp
//
// Purpose:
//
//      Used in implementing Context sensitive help
//
// Parameters:
//
//      BOOL fEnterMode -   TRUE if starting Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes in the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::ContextSensitiveHelp (BOOL fEnterMode)
{
    TestDebugOut(TEXT("In IOIPF::ContextSensitiveHelp\r\n"));

    m_pApp->m_fMenuMode = fEnterMode;

    return ResultFromScode(S_OK);
}
//**********************************************************************
//
// COleInPlaceFrame::GetBorder
//
// Purpose:
//
//      Returns the outermost border that frame adornments can be attached
//      during InPlace Activation.
//
// Parameters:
//
//      LPRECT lprectBorder - return parameter to contain the outermost
//                            rect for frame adornments
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetClientRect               Windows API
//      CopyRect                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetBorder (LPRECT lprectBorder)
{
    RECT rect;

    TestDebugOut(TEXT("In IOIPF::GetBorder\r\n"));

    // get the rect for the entire frame.
    GetClientRect(m_pApp->m_hAppWnd, &rect);

    CopyRect(lprectBorder, &rect);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::RequestBorderSpace
//
// Purpose:
//
//      Approves/Denies requests for border space during InPlace
//      negotiation.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - The width in pixels needed on
//                                        each side of the frame.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      This implementation doesn't care about how much border space
//      is used.  It always returns S_OK.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RequestBorderSpace (LPCBORDERWIDTHS
                                                         lpborderwidths)
{
    TestDebugOut(TEXT("In IOIPF::RequestBorderSpace\r\n"));

    // always approve the request
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetBorderSpace
//
// Purpose:
//
//      The object calls this method when it is actually going to
//      start using the border space.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - Border space actually being used
//                                        by the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::AddFrameLevelTools  APP.CPP
//      TestDebugOut               Windows API
//      GetClientRect                   Windows API
//      MoveWindow                      Windows API
//      ResultFromScode                 Windows API
//
// Comments:
//
//      This routine could be a little smarter and check to see if
//      the object is requesting the entire client area of the
//      window.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{

    TestDebugOut(TEXT("In IOIPF::SetBorderSpace\r\n"));

    if (lpborderwidths == NULL)
        m_pApp->AddFrameLevelTools();
    else
    {
        RECT rect;

        GetClientRect(m_pApp->m_hAppWnd, &rect);

        MoveWindow( m_pApp->m_lpDoc->m_hDocWnd,
                   rect.left + lpborderwidths->left,
                   rect.top + lpborderwidths->top,
                   rect.right - lpborderwidths->right - lpborderwidths->left,
                   rect.bottom - lpborderwidths->bottom - lpborderwidths->top,
                   TRUE);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetActiveObject
//
// Purpose:
//  install the object being activated in-place
//
//
// Parameters:
//
//  LPOLEINPLACEACTIVEOBJECT lpActiveObject     -   Pointer to the
//                                                  objects
//                                                  IOleInPlaceActiveObject
//                                                  interface
//
//  LPCOLESTR lpszObjName                       -   Name of the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceActiveObject::AddRef     Object
//      IOleInPlaceActiveObject::Release    Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetActiveObject (LPOLEINPLACEACTIVEOBJECT
                                        lpActiveObject, LPCOLESTR lpszObjName)
{

    TestDebugOut(TEXT("In IOIPF::SetActiveObject\r\n"));

    // AddRef() it and save it...
    if (lpActiveObject)
    {
        lpActiveObject->AddRef();

        lpActiveObject->GetWindow(&m_pApp->m_hwndUIActiveObj);
        if (m_pApp->m_hwndUIActiveObj)
            SendMessage(m_pApp->m_hwndUIActiveObj, WM_QUERYNEWPALETTE, 0, 0L);
    }
    else
    {
        if (m_pApp->m_lpDoc->m_lpActiveObject)
            m_pApp->m_lpDoc->m_lpActiveObject->Release();
        m_pApp->m_hwndUIActiveObj = NULL;
    }

    // in an MDI app, this method really shouldn't be called,
    // this method associated with the doc is called instead.

    m_pApp->m_lpDoc->m_lpActiveObject = lpActiveObject;
    // should set window title here

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::InsertMenus
//
// Purpose:
//
//      Inserts the container menu into the combined menu
//
// Parameters:
//
//      HMENU hmenuShared                   -   Menu Handle to be set.
//      LPOLEMENUGROUPWIDTHS lpMenuWidths   -   Width of menus
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      AppendMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::InsertMenus (HMENU hmenuShared,
                                            LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    TestDebugOut(TEXT("In IOIPF::InsertMenus\r\n"));

    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hFileMenu, TEXT("&File"));
    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hHelpMenu, TEXT("&Other"));

    lpMenuWidths->width[0] = 1;
    lpMenuWidths->width[2] = 0;
    lpMenuWidths->width[4] = 1;

    return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::SetMenu
//
// Purpose:
//
//      Sets the application menu to the combined menu
//
// Parameters:
//
//      HMENU hmenuShared       - The combined menu
//
//      HOLEMENU holemenu       - Used by OLE
//
//      HWND hwndActiveObject   - Used by OLE
//
// Return Value:
//
//      S_OK                -  if menu was correctly installed
//      E_FAIL              -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetMenu                     Windows API
//      OleSetMenuDescriptor        OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetMenu (HMENU hmenuShared, HOLEMENU holemenu,
                                        HWND hwndActiveObject)
{

    TestDebugOut(TEXT("In IOIPF::SetMenu\r\n"));

    HMENU hMenu = m_pApp->m_lpDoc->m_hMainMenu;

    if (holemenu)
        hMenu = hmenuShared;

    // call the windows api, not this method
    ::SetMenu (m_pApp->m_hAppWnd, hMenu);

    HRESULT hRes = OleSetMenuDescriptor(holemenu, m_pApp->m_hAppWnd,
                                        hwndActiveObject, this,
                                        m_pApp->m_lpDoc->m_lpActiveObject);

    return hRes;
}


//**********************************************************************
//
// COleInPlaceFrame::RemoveMenus
//
// Purpose:
//
//      Removes the container menus from the combined menu
//
// Parameters:
//
//      HMENU hmenuShared   - Handle to the combined menu.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenuItemCount            Windows API
//      RemoveMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RemoveMenus (HMENU hmenuShared)
{
    int retval;

    TestDebugOut(TEXT("In IOIPF::RemoveMenus\r\n"));

    while ((retval = GetMenuItemCount(hmenuShared)) && (retval != -1))
        RemoveMenu(hmenuShared, 0, MF_BYPOSITION);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetStatusText
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPCOLESTR  lpszStatusText  -  character string containing the message
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact
//      that this application does not have a status bar.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCOLESTR lpszStatusText)
{
    TestDebugOut(TEXT("In IOIPF::SetStatusText\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceFrame::EnableModeless
//
// Purpose:
//
//      Enables/Disables container modeless dialogs
//
// Parameters:
//
//      BOOL fEnable    - Enable/Disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      There are no modeless dialogs in this application, so the
//      implementation of this method is trivial.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::EnableModeless (BOOL fEnable)
{
    TestDebugOut(TEXT("In IOIPF::EnableModeless\r\n"));
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::TranslateAccelerator
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPMSG   lpmsg     -   structure containing keystroke message
//      WORD    wID       -   identifier value corresponding to the keystroke
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::TranslateAccelerator (LPMSG lpmsg, WORD wID)
{
    TestDebugOut(TEXT("In IOIPF::TranslateAccelerator\r\n"));
    return ::TranslateAccelerator(m_pApp->m_hAppWnd, m_pApp->m_hAccel, lpmsg)
        ? ResultFromScode(S_OK)
        : ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPCNTR.RC
//
#define IDM_OPEN                        102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_DEACTIVATE                  113
#define IDM_UTEST                       998

#define SIMPCNTR_ACCEL_CNT              3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\simpcntr.h ===
//**********************************************************************
// File name: simple.h
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#endif

BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef WIN32
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#endif


/* These strings are used to name two custom control classes used by
**    the OLE2UI library. These strings must be unique for each
**    application that uses the OLE2UI library. These strings should be
**    composed by combining the APPNAME with a suffix in order to be
**    unique for a particular application. The special symbols
**    "SZCLASSICONBOX" and "SZCLASSRESULTIMAGE" are used define these
**    strings. These symbols are passed in the OleUIInitialize call and
**    are referenced in the INSOBJ.DLG and PASTESPL.DLG resouce files
**    of the OLE2UI library.
*/
#define SZCLASSICONBOX "simpcntrIBClass"
#define SZCLASSRESULTIMAGE "simpcntrRIClass"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of CSimpleSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <ole2.h>
#include "ias.h"
#include "ioips.h"
#include "iocs.h"

class CSimpleDoc;

class CSimpleSite : public IUnknown
{
public:
    int m_nCount;
    DWORD m_dwConnection;
    LPOLEOBJECT m_lpOleObject;
    LPOLEINPLACEOBJECT m_lpInPlaceObject;
    HWND m_hwndIPObj;
    DWORD m_dwDrawAspect;
    SIZEL m_sizel;
    BOOL m_fInPlaceActive;
    BOOL m_fObjectOpen;
    LPSTORAGE m_lpObjStorage;

    CAdviseSink m_AdviseSink;
    COleInPlaceSite m_OleInPlaceSite;
    COleClientSite m_OleClientSite;

    CSimpleDoc FAR * m_lpDoc;

    // IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    void InitObject(BOOL fCreateNew);
    static CSimpleSite FAR * Create(CSimpleDoc FAR *lpDoc);
    CSimpleSite(CSimpleDoc FAR *lpDoc);
    ~CSimpleSite();
    void PaintObj(HDC hDC);
    void GetObjRect(LPRECT lpRect);
    void CloseOleObject(void);
    void UnloadOleObject(void);
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      IStorage::CreateStorage     OLE API
//      CSimpleSite::AddRef         SITE.CPP
//      assert                      C Runtime
//
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc)
{
    CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

    if (!lpTemp)
        return NULL;

    // create a sub-storage for the object
    HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( OLESTR("Object"),
                STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &lpTemp->m_lpObjStorage);

    assert(hErr == NOERROR);

    if (hErr != NOERROR)
    {
        delete lpTemp;
        return NULL;
    }

    // we will add one ref count on our Site. later when we want to destroy
    // the Site object we will release this  ref count. when the Site's ref
    // count goes to 0, it will be deleted.
    lpTemp->AddRef();

    return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
                                                   m_AdviseSink(this),
                                                   m_OleInPlaceSite(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TestDebugOut (TEXT("In CSimpleSite's Constructor \r\n"));

    // remember the pointer to the doc
    m_lpDoc = lpDoc;

    // clear the reference count
    m_nCount = 0;

	 m_dwDrawAspect = DVASPECT_CONTENT;
    m_lpOleObject = NULL;
    m_lpInPlaceObject = NULL;
    m_hwndIPObj = NULL;
    m_fInPlaceActive = FALSE;
    m_fObjectOpen = FALSE;
}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
    TestDebugOut (TEXT("In CSimpleSite's Destructor \r\n"));

    if (m_lpOleObject)
       m_lpOleObject->Release();

    if (m_lpObjStorage)
       m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::QueryInterface              Object
//      IOleObject::Close                       Object
//      IOleInPlaceObject::UIDeactivate         Object
//      IOleInPlaceObject::InPlaceDeactivate    Object
//      IOleInPlaceObject::Release              Object
//
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
    LPOLEINPLACEOBJECT lpObject;
    LPVIEWOBJECT lpViewObject = NULL;

    TestDebugOut (TEXT("In CSimpleSite::CloseOleObject \r\n"));

    if (m_lpOleObject)
    {
       if (m_fInPlaceActive)
       {
           m_lpOleObject->QueryInterface(IID_IOleInPlaceObject,
                                         (LPVOID FAR *)&lpObject);
           lpObject->UIDeactivate();
           // don't need to worry about inside-out because the object
           // is going away.
           lpObject->InPlaceDeactivate();
           lpObject->Release();
       }

       m_lpOleObject->Close(OLECLOSE_NOSAVE);
    }
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IOleObject::Release                     Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
    TestDebugOut (TEXT("In CSimpleSite::UnloadOleObject \r\n"));

    if (m_lpOleObject)
    {
       LPVIEWOBJECT lpViewObject;
       CloseOleObject();    // ensure object is closed; NOP if already closed

       m_lpOleObject->QueryInterface(IID_IViewObject,
                                     (LPVOID FAR *)&lpViewObject);

       if (lpViewObject)
       {
           // Remove the view advise
           lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
           lpViewObject->Release();
       }

       m_lpOleObject->Release();
       m_lpOleObject = NULL;
    }
}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK           -   The interface is supported.
//      E_NOINTERFACE  -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef         OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//      COleInPlaceSite::AddRef     IOIPS.CPP
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpleSite::QueryInterface\r\n"));

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    if ( IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IOleClientSite))
    {
        m_OleClientSite.AddRef();
        *ppvObj = &m_OleClientSite;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IAdviseSink))
    {
        m_AdviseSink.AddRef();
        *ppvObj = &m_AdviseSink;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IOleInPlaceSite))
    {
        m_OleInPlaceSite.AddRef();
        *ppvObj = &m_OleInPlaceSite;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
    TestDebugOut(TEXT("In CSimpleSite::AddRef\r\n"));

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
    TestDebugOut(TEXT("In CSimpleSite::Release\r\n"));

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject2::SetAdvise         Object
//      IViewObject2::Release           Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
//
//********************************************************************

void CSimpleSite::InitObject(BOOL fCreateNew)
{
    LPVIEWOBJECT2 lpViewObject2;
    RECT rect;

    TestDebugOut(TEXT("In CSimpleSite::InitObject\r\n"));

    // Set a View Advise
    m_lpOleObject->QueryInterface(IID_IViewObject2,
                                  (LPVOID FAR *)&lpViewObject2);
    lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST, &m_AdviseSink);

    // get the initial size of the object
    lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/,
                             &m_sizel);
    GetObjRect(&rect);  // get the rectangle of the object in pixels
    lpViewObject2->Release();

    // give the object the name of the container app/document
    m_lpOleObject->SetHostNames(OLESTR("Simple Application"),
                                OLESTR("Simple OLE 2.0 In-Place Container"));

    // inform object handler/DLL object that it is used in the embedding
    // container's context
    HRESULT hRes;
    if ((hRes = OleSetContainedObject(m_lpOleObject, TRUE))
        != ResultFromScode(S_OK) )
    {
       TestDebugOut(TEXT("Fail in OleSetContainedObject\n"));
    }

    if (fCreateNew)
    {
       // force new object to save to guarantee valid object in our storage.
       // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
       // object is created FROM FILE; its data in storage is already valid.
       m_OleClientSite.SaveObject();

       // we only want to DoVerb(SHOW) if this is an InsertNew object.
       // we should NOT DoVerb(SHOW) if the object is created FromFile.
       m_lpOleObject->DoVerb(
               OLEIVERB_SHOW,
               NULL,
               &m_OleClientSite,
               -1,
               m_lpDoc->m_hDocWnd,
               &rect);
    }
}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      CSimpleSite::GetObjRect         SITE.CPP
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      SetROP2                         Windows API
//      Rectamgle                       Windows API
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OLE2UI Function
//      OleDraw                         OLE API
//
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
    RECT rect;

    // need to check to make sure there is a valid object
    // available.  This is needed if there is a paint msg
    // between the time that CSimpleSite is instantiated
    // and OleUIInsertObject returns.
    if (!m_lpOleObject)
        return;

    // convert it to pixels
    GetObjRect(&rect);

    LPLOGPALETTE pColorSet = NULL;
    LPVIEWOBJECT lpView = NULL;

    // get a pointer to IViewObject
    m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

    // if the QI succeeds, get the LOGPALETTE for the object
    if (lpView)
        lpView->GetColorSet(m_dwDrawAspect, -1, NULL, NULL, NULL, &pColorSet);

    HPALETTE hPal=NULL;
    HPALETTE hOldPal=NULL;

    // if a LOGPALETTE was returned (not guarateed), create the palette and
    // realize it.NOTE:A smarter application would want to get the LOGPALETTE
    // for each of its visible objects, and try to create a palette that
    // satisfies all of the visible objects.  ALSO: OleStdFree() is use to
    // free the returned LOGPALETTE.
    if ((pColorSet))
    {
        hPal = CreatePalette((const LPLOGPALETTE) pColorSet);
        hOldPal = SelectPalette(hDC, hPal, FALSE);
        RealizePalette(hDC);
        OleStdFree(pColorSet);
    }

    // draw the object
    HRESULT hRes;
    hRes = OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);
    if ((hRes != ResultFromScode(S_OK)) &&
        (hRes != ResultFromScode(OLE_E_BLANK)) &&
        (hRes != ResultFromScode(DV_E_NOIVIEWOBJECT)))
    {
       TestDebugOut(TEXT("Fail in OleDraw\n"));
    }

    // if the object is open, draw a hatch rect.
    if (m_fObjectOpen)
    {
        HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
        HBRUSH hOldBrush = (HBRUSH) SelectObject (hDC, hBrush);
        SetROP2(hDC, R2_MASKPEN);
        Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
        SelectObject(hDC, hOldBrush);
        DeleteObject(hBrush);
    }

    // if we created a palette, restore the old one, and destroy
    // the object.
    if (hPal)
    {
        SelectPalette(hDC,hOldPal,FALSE);
        DeleteObject(hPal);
    }

    // if a view pointer was successfully returned, it needs to be released.
    if (lpView)
        lpView->Release();
}

//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OLE2UI Function
//      XformHeightInHimetricToPixels   OLE2UI Function
//
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
    // convert it to pixels
    lpRect->left = lpRect->top = 0;
    lpRect->right = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
    lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\tests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   	tests.cpp
//
//  Contents:	Implementations of the Upper Layer unit tests for Inplace
//
//  Classes:
//
//  Functions: 	Test1
//
//  History:    dd-mmm-yy Author    Comment
//		27-Apr-94 ricksa    author
//
//--------------------------------------------------------------------------

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "tests.h"
#include "utaccel.h"

const CLSID CLSID_SimpleServer = {0xbcf6d4a0, 0xbe8c, 0x1068, { 0xb6, 0xd4,
	0x00, 0xdd, 0x01, 0x0c, 0x05, 0x09 }};

const TCHAR *pszErrorTitle = TEXT("Unit Test FAILURE");

//+-------------------------------------------------------------------------
//
//  Function:   TestMsgPostThread
//
//  Synopsis:   We use this thread to post messages to the inplace server
//
//  Arguments:  [pvApp] - application object
//
//  Algorithm:  Post key board message for the accelerator for the container
//              and wait 3 seconds to see if we get response. If we do, then
//              continue by posting an accelerator to the embeddinging and
//              waiting three seconds for a response. Finally post messages
//              to everyone telling them the test is over.
//
//  History:    dd-mmm-yy Author    Comment
//              02-May-94 ricksa    author
//
//  Notes:      
//
//--------------------------------------------------------------------------
extern "C" DWORD TestMsgPostThread(void *pvApp)
{
    CSimpleApp *pApp = (CSimpleApp *) pvApp;
    HRESULT hr = ResultFromScode(E_UNEXPECTED);

    // Send an accelerator bound for the container
    PostMessage(pApp->m_hwndUIActiveObj, WM_CHAR, SIMPCNTR_UT_ACCEL, 1);

    // Give 6 seconds for chance to process an accelerator
    for (int i = 0; i < 6; i++)
    {
        // Get embedding and container a chance to process the accelerator
        Sleep(1000);

        // See if it got processed
        if (pApp->m_fGotUtestAccelerator)
        {
            break;
        }
    }

    if (pApp->m_fGotUtestAccelerator)
    {
        hr = S_OK;
    }
    else
    {
        // The container did not received the accelerator
        MessageBox(pApp->m_hAppWnd,
            TEXT("Container didn't recieve accelerator"),
                pszErrorTitle, MB_OK);
    }

    PostMessage(pApp->m_hDriverWnd, WM_TESTEND,
        SUCCEEDED(hr) ? TEST_SUCCESS : TEST_FAILURE, (LPARAM) hr);

    PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);

    return 0;
}




//+-------------------------------------------------------------------------
//
//  Function:	Test1
//
//  Synopsis:   Inserts an inplace object into this container
//
//  Arguments:	pApp	-- a pointer to the CSimpleApp that we're a part of  
//
//  Algorithm:  Create a simple server object. Activate the simple server
//              object. Send the container an accelerator and confirm that
//              the accelerator worked. Send the object an accelerator and
//              make sure that that accelerator worked. Then return the
//              result of the test to the test driver.
//
//  History:    dd-mmm-yy Author    Comment
//              27-Apr-94 ricksa    author
//
//  Notes:      
//
//--------------------------------------------------------------------------
void Test1(CSimpleApp *pApp)
{
    // Create the inplace object
    HRESULT hr;
    static FORMATETC formatetc;

    //insert the simple server object

    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.cfFormat = NULL;
    formatetc.lindex = -1;

    //need to create the client site

    pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

    hr = OleCreate(
                CLSID_SimpleServer,
                IID_IOleObject,
		OLERENDER_DRAW,
                &formatetc,
		&pApp->m_lpDoc->m_lpSite->m_OleClientSite,
		pApp->m_lpDoc->m_lpSite->m_lpObjStorage, 
		(void **) &(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

    if(hr == NOERROR)
    {
        // Activate the inplace object
        pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

        // Default to unexpected failure
        hr = ResultFromScode(E_UNEXPECTED);

        if (pApp->m_lpDoc->m_fInPlaceActive)
        {
            // Create thread to send windows messages to container and
            // embedding
            DWORD dwThreadId;

            HANDLE hThread = CreateThread(
                NULL,               // Security attributes - default
                0,                  // Stack size - default
                TestMsgPostThread,  // Addresss of thread function
                pApp,               // Parameter to thread
                0,                  // Flags - run immediately
                &dwThreadId);       // Thread ID returned - unused.

            if (hThread != NULL)
            {
                // Thread was created so tell routine & dump handle
                // we won't use.
                hr = S_OK;
                CloseHandle(hThread);
            }
            else
            {
                // The container did not received the accelerator
                MessageBox(pApp->m_hAppWnd,
                    TEXT("Could not create message sending thread"),
                        pszErrorTitle, MB_OK);
            }
        }
        else
        {
            // The object did not get activated in place
            MessageBox(pApp->m_hAppWnd, TEXT("Could not activate in place"),
                pszErrorTitle, MB_OK);
        }
    }
    else
    {
        // We could not create the object
        MessageBox(pApp->m_hAppWnd, TEXT("Could not create embedding"),
            pszErrorTitle, MB_OK);
    }

    if (FAILED(hr))
    {
        PostMessage(pApp->m_hDriverWnd, WM_TESTEND,
            SUCCEEDED(hr) ? TEST_SUCCESS : TEST_FAILURE, (LPARAM) hr);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\simpcntr.cpp ===
//**********************************************************************
// File name: Simple.cpp
//
//      Main source file for the Simple OLE 2.0 object container
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "tests.h"

// This line is needed for the debug utilities in OLE2UI
extern "C" {
    OLEDBGDATA_MAIN(TEXT("SIMPCNTR"))
}

CSimpleApp FAR * lpCSimpleApp;

void DeactivateIfActive(HWND hWnd)
{
    LPOLEINPLACEOBJECT lpObject;
    MSG msg;
    msg.message = WM_LBUTTONDOWN;


    if (lpCSimpleApp->m_lpDoc->m_fInPlaceActive)
    {
        // We are in the process of deactiving the in place object
        lpCSimpleApp->m_fDeactivating = TRUE;

        lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->QueryInterface(
                            IID_IOleInPlaceObject, (LPVOID FAR *)&lpObject);
        lpObject->UIDeactivate();

        // this code is needed because we don't support inside out.
        RECT rect;
        lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);
        lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                           OLEIVERB_HIDE,
                           &msg,
                           &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                           -1, hWnd, &rect);

        lpObject->Release();

        // We are done deactiving
        lpCSimpleApp->m_fDeactivating = FALSE;
    }

}


BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugStringA(psz);
    }
}


//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::CSimpleApp          APP.CPP
//      CSimpleApp::AddRef              APP.CPP
//      CSimpleApp::Release             APP.CPP
//      CSimpleApp::fInitApplication    APP.CPP
//      CSimpleApp::fInitInstance       APP.CPP
//      CSimpleApp::HandleAccelerators  APP.CPP
//      CSimpleApp::~CSimpleApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
//********************************************************************
int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#endif
{
    MSG msg;

    // needed for LRPC to work properly...
    SetMessageQueue(96);

    lpCSimpleApp = new CSimpleApp;
    fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

    if(fBeVerbose == 0)
    {
	fBeVerbose = GetProfileInt("OLEUTEST","simpcntr",0);
    }

    if (!lpCSimpleApp)
    {
       /* memory allocation error. cannot carry on.
        */
       return(FALSE);
    }

    // we will add one ref count on our App. later when we want to destroy
    // the App object we will release this  ref count. when the App's ref
    // count goes to 0, it will be deleted.
    lpCSimpleApp->AddRef();

    char *pszTemp;

    // process the command line
    if( (pszTemp = strstr(lpCmdLine, "-driver")) )
    {
    	//we were launched by the test driver
	lpCSimpleApp->m_hDriverWnd = (HWND)strtoul(pszTemp+8, NULL, 10);
    }

    // app initialization
    if (!hPrevInstance)
        if (!lpCSimpleApp->fInitApplication(hInstance))
        {
            lpCSimpleApp->Release();
            return (FALSE);
        }

    // instance initialization
    if (!lpCSimpleApp->fInitInstance(hInstance, nCmdShow))
    {
        lpCSimpleApp->Release();
        return (FALSE);
    }

    /* Initialization required for OLE 2 UI library.  This call is
    **    needed ONLY if we are using the static link version of the UI
    **    library. If we are using the DLL version, we should NOT call
    **    this function in our application.
    **    The 3rd and 4th parameters passed the OleUIInitialize
    **    function are strings which are used to name two custom
    **    control classes used by the OLE2UI library. These strings
    **    must be unique for each application that uses the OLE2UI
    **    library. These strings are typically composed by combining
    **    the APPNAME with a suffix in order to be unique for a
    **    particular application. The special symbols "SZCLASSICONBOX"
    **    and "SZCLASSRESULTIMAGE" are used define these strings. These
    **    symbols must be defined in a header file that is included
    **    both in this file AND the resource file that included the
    **    "OLE2UI.RC" resoure file. These symbols should be used in the
    **    call to OleUIInitialize and are referenced in the INSOBJ.DLG
    **    and PASTESPL.DLG resouce files of the OLE2UI library.
    */
#if 0   //  We use the DLL form of OLE2U32A
    if (!OleUIInitialize(hInstance, hPrevInstance, TEXT(SZCLASSICONBOX),
                         TEXT(SZCLASSRESULTIMAGE)))
    {
        OleDbgOut(TEXT("Could not initialize OLEUI library\n"));
        lpCSimpleApp->Release();
        return FALSE;
    }
#endif

    // message loop
    while (GetMessage(&msg, NULL, NULL, NULL))
        if (!lpCSimpleApp->HandleAccelerators(&msg))
        {
            TranslateMessage(&msg);    /* Translates virtual key codes */
            DispatchMessage(&msg);     /* Dispatches message to window */
        }


#if 0   //  We use the DLL form of OLE2U32A
    // De-initialization for UI libraries.  Just like OleUIInitialize, this
    // funciton is needed ONLY if we are using the static link version of the
    // OLE UI library.
    OleUIUninitialize();
#endif

    // Release the ref count added on the App above. this will make
    // the App's ref count go to 0, and the App object will be deleted.
    lpCSimpleApp->Release();

    return (msg.wParam);         /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::lCommandHandler     APP.CPP
//      CSimpleApp::DestroyDocs         APP.CPP
//      CSimpleApp::lCreateDoc          APP.CPP
//      CSimpleApp::lSizeHandler        APP.CPP
//      CSimpleDoc::lAddVerbs           DOC.CPP
//      CSimpleDoc::QueryNewPalette     APP.CPP
//      SendMessage                     Windows API
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message,
                                   WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_CLOSE:
            DestroyWindow(lpCSimpleApp->m_hAppWnd);
            break;

        case WM_TEST1:
            // Do the unit test
            Test1(lpCSimpleApp);
            break;

        case WM_SETFOCUS:
            // If we have an inplace application it needs to get the focus
            if (lpCSimpleApp->m_lpDoc->m_fInPlaceActive
                && !lpCSimpleApp->m_fDeactivating)
            {
                SetFocus(lpCSimpleApp->m_hwndUIActiveObj);
                break;
            }

            // Othewise default behavior is enough
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_COMMAND:           // message: command from application menu
            return lpCSimpleApp->lCommandHandler(hWnd, message,
                                                 wParam, lParam);
            break;

        case WM_CREATE:
            return lpCSimpleApp->lCreateDoc(hWnd, message, wParam, lParam);
            break;

        case WM_DESTROY:                  // message: window being destroyed
            lpCSimpleApp->DestroyDocs();  // need to destroy the doc...
            PostQuitMessage(0);
            break;

        case WM_INITMENUPOPUP:
            // is this the edit menu?
            if ( LOWORD(lParam) == 1)
                return lpCSimpleApp->m_lpDoc->lAddVerbs();

            break;

        // this code is needed for 256 color objects to work properly.
        case WM_QUERYNEWPALETTE:
            if (! lpCSimpleApp->m_fAppActive)
                return 0L;

            return lpCSimpleApp->QueryNewPalette();


	case WM_PALETTECHANGED:
        {
			  HWND hWndPalChg = (HWND) wParam;
			
			  if (hWnd != hWndPalChg)
				  wSelectPalette(hWnd, lpCSimpleApp->m_hStdPal,
                             TRUE/*fBackground*/);

			/* OLE2NOTE: always forward the WM_PALETTECHANGED message (via
			**    SendMessage) to any in-place objects that currently have
			**    their window visible. this gives these objects the chance
			**    to select their palettes. this is
			**    REQUIRED by all in-place containers independent of
			**    whether they use color palettes themselves--their objects
			**    may use color palettes.
			**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
			*/
			  if (lpCSimpleApp->m_lpDoc && lpCSimpleApp->m_lpDoc->m_lpSite &&
                   lpCSimpleApp->m_lpDoc->m_lpSite->m_hwndIPObj)
           {
                SendMessage(lpCSimpleApp->m_lpDoc->m_lpSite->m_hwndIPObj,
                        WM_PALETTECHANGED, wParam, lParam);
           }

           return 0L;
        }

        case WM_ACTIVATEAPP:
            if ((lpCSimpleApp->m_fAppActive = (BOOL)wParam) == TRUE)
                lpCSimpleApp->QueryNewPalette();

            if (lpCSimpleApp->m_lpDoc->m_lpActiveObject)
            {
               lpCSimpleApp->m_lpDoc->m_lpActiveObject->OnFrameWindowActivate(
                        (BOOL)wParam);
            }
            break;

        case WM_SIZE:
            return lpCSimpleApp->lSizeHandler(hWnd, message, wParam, lParam);

        default:                          // Passes it on if unproccessed
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//      TRUE if message processed, FALSE otherwise
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
//
//********************************************************************

INT_PTR FAR PASCAL EXPORT About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)

{
    switch (message)
    {
    case WM_INITDIALOG:               /* message: initialize dialog box */
        return (TRUE);

    case WM_COMMAND:                  /* message: received a command */
        if (wParam == IDOK            /* "OK" box selected?          */
            || wParam == IDCANCEL)    /* System menu close command?  */
        {
           EndDialog(hDlg, TRUE);     /* Exits the dialog box        */
           return (TRUE);
        }
        break;
    }
    return (FALSE);                   /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//      NULL
//
// Function Calls:
//      Function                            Location
//
//      CSimpleApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      PtInRect                            Windows API
//      CSimpleSite::GetObjRect             SITE.CPP
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::UIDeactivate     Object
//      IOleObject::DoVerb                  Object
//      IOleInPlaceObject::Release          Object
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;

    switch (message)
    {
        case WM_SETFOCUS:
            // If we have an inplace application it needs to get the focus
            if (lpCSimpleApp->m_lpDoc->m_fInPlaceActive
                && !lpCSimpleApp->m_fDeactivating)
            {
                SetFocus(lpCSimpleApp->m_hwndUIActiveObj);
                break;
            }

            // Otherwise default behavior is enough
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_PAINT:

            hDC = BeginPaint(hWnd, &ps);

            if (lpCSimpleApp)
                lpCSimpleApp->PaintApp (hDC);

            EndPaint(hWnd, &ps);
            break;


        case WM_LBUTTONDBLCLK:
        {
            POINT pt;

            pt.x = (int)(short)LOWORD (lParam );
            pt.y = (int)(short)HIWORD (lParam );

            if (lpCSimpleApp->m_lpDoc->m_lpSite &&
                lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject)
            {
                RECT rect;

                lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);

                if ( PtInRect(&rect, pt) )
                {
                    // Execute object's default verb
                    lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                            OLEIVERB_PRIMARY, (LPMSG)&message,
                            &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                            -1, hWnd, &rect);
                }
            }
        }
            break;

    // no code is added to WM_LBUTTONDOWN for context sensitive help, because
    // this app does not do context sensitive help.

        case WM_LBUTTONDOWN:
           DeactivateIfActive(hWnd);
           break;
	
    	  default:                        /* Passes it on if unproccessed */
        	  return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\tests.h ===
#ifndef _TESTS_H_
#define _TESTS_H_

#include <testmess.h>

void Test1(CSimpleApp *pApp);

#endif // _TESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpcntr\utaccel.h ===
#ifndef _UTACCEL_H_
#define _UTACCEL_H_

#define SIMPCNTR_UT_ACCEL   1
#define SIMPSVR_UT_ACCEL    3

#endif // _UTACCEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\enumfetc.h ===
// This file is now OBSOLETE (include olestd.h instead)

/*************************************************************************
** 
**    OLE 2 Utility Code
**    
**    enumfetc.c
**    
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

// Function prototypes moved to olestd.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpleApp
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

#include <ole2.h>

class CSimpleDoc;

class CSimpleApp : public IUnknown
{            
public:

    int m_nCount;           // reference count
    HWND m_hAppWnd;         // main window handle
    HWND m_hDriverWnd;	    // window handle for the driver app.
    HINSTANCE m_hInst;      // application instance
    CSimpleDoc FAR * m_lpDoc;   // pointer to document object
    BOOL m_fInitialized;    // OLE initialization flag
    HMENU           m_hMainMenu;        
    HMENU           m_hFileMenu;
    HMENU           m_hEditMenu;
    HMENU           m_hHelpMenu;  
    HMENU           m_hCascadeMenu;     // OLE object's verb

    // Drag/Drop related fields
    int m_nDragDelay;       // time delay (in msec) before drag should start
    int m_nDragMinDist;     // min. distance (radius) before drag should start
    int m_nScrollDelay;     // time delay (in msec) before scroll should start
    int m_nScrollInset;     // Border inset distance to start drag scroll
    int m_nScrollInterval;  // scroll interval time (in msec)

    DWORD m_dwSourceEffect; // Allowed effects to source
    DWORD m_dwTargetEffect; // Allowed target effects
    
    CSimpleApp();           // Constructor
    ~CSimpleApp();          // Destructor
    
    // IUnknown Interfaces    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 

    // Initialization methods
    
    BOOL fInitApplication (HANDLE hInstance);
    BOOL fInitInstance (HANDLE hInstance, int nCmdShow);
    
    // Message handling methods
    
    LRESULT lCommandHandler (HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
    long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    BOOL HandleAccelerators (LPMSG lpMsg);
    void PaintApp(HDC hDC);
    void DestroyDocs();
    void UpdateDragDropEffects(int iMenuPos, int iMenuCommand, DWORD dwEffect,
        DWORD *pdwEffectToUpdate);
};

#endif  // _APP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"
#include "dxferobj.h"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      RegisterDragDrop            OLE API
//      CoLockObjectExternal        OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create(CSimpleApp FAR *lpApp, LPRECT lpRect,
                                    HWND hWnd)
{
    CSimpleDoc FAR * lpTemp = new CSimpleDoc(lpApp, hWnd);

    if (!lpTemp)
    {
        TestDebugOut("Memory allocation error\n");
        return NULL;
    }

    // create storage for the doc.
    HRESULT hErr = StgCreateDocfile (
        NULL,       // generate temp name
        STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
        0, &lpTemp->m_lpStorage);

    if (hErr != NOERROR)
        goto error;

    // create the document Window
    lpTemp->m_hDocWnd = CreateWindow(
            TEXT("SimpDndDocWClass"),
            NULL,
            WS_CHILD | WS_CLIPCHILDREN,
            lpRect->left,
            lpRect->top,
            lpRect->right,
            lpRect->bottom,
            hWnd,
            NULL,
            lpApp->m_hInst,
            NULL);

    if (!lpTemp->m_hDocWnd)
        goto error;

    ShowWindow(lpTemp->m_hDocWnd, SW_SHOWNORMAL);  // Show the window
    UpdateWindow(lpTemp->m_hDocWnd);               // Sends WM_PAINT message

#ifdef NOTREADY
    // Ensable InsertObject menu choice
    EnableMenuItem( lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);
#else
    // Ensable InsertObject menu choice
    EnableMenuItem( lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_ENABLED);
    // Disable Copy menu choice
    EnableMenuItem( lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED |
                                           MF_GRAYED);
#endif // NOTREADY

    HRESULT  hRes;

    // It is *REQUIRED* to hold a strong LOCK on the object that is
    // registered as drop target. this call will result in at least one
    // ref count held on our document. later in CSimpleDoc::Close we will
    // unlock this lock which will make our document's ref count go to 0.
    // when the document's ref count goes to 0, it will be deleted.
    if ( (hRes=CoLockObjectExternal (&lpTemp->m_DropTarget, TRUE, 0))
         != ResultFromScode(S_OK) )
    {
       /* CoLockObjectExternal should never fail. If it fails, we don't want
        * to carry on since we don't have a guaranteed object lock.
        */
       goto error;
    }

    // Register our window as a DropTarget
    if (((hRes=RegisterDragDrop(lpTemp->m_hDocWnd, &lpTemp->m_DropTarget))
          !=ResultFromScode(S_OK))
          && (hRes != ResultFromScode(DRAGDROP_E_ALREADYREGISTERED)))
    {
       lpTemp->m_fRegDragDrop = FALSE;
    }
    else
    {
       lpTemp->m_fRegDragDrop = TRUE;
    }

    return (lpTemp);

error:
    TestDebugOut("Fail in CSimpleDoc::Create\n");
    delete (lpTemp);
    return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      CoLockObjectExternal        OLE API
//      OleFlushClipboard           OLE API
//      ShowWindow                  Windows API
//      CSimpleSite::CloseOleObject SITE.CPP
//
//
//********************************************************************

void CSimpleDoc::Close(void)
{
    TestDebugOut("In CSimpleDoc::Close\r\n");

    HRESULT hRes;

    ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

    // Remove our data transfer object from clipboard if it is there.
    // this will leave HGLOBAL based data behind on the clipboard
    // including OLE 1.0 compatibility formats.

    if (OleFlushClipboard() != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleFlushClipBoard\n");
    }

    // Revoke our window as a DropTarget
    if (m_fRegDragDrop)
    {
        if (((hRes=RevokeDragDrop(m_hDocWnd)) != ResultFromScode(S_OK)) &&
             (hRes!=ResultFromScode(DRAGDROP_E_NOTREGISTERED)))
        {
           /* if we fail in revoking the drag-drop, we will probably be
            * having memory leakage.
            */
           TestDebugOut("Fail in RevokeDragDrop\n");
        }
        else
        {
           m_fRegDragDrop = FALSE;
        }
    }

    // Close the OLE object in our document
    if (m_lpSite)
        m_lpSite->CloseOleObject();

    // Unlock the lock added in CSimpleDoc::Create. this will make
    // the document's ref count go to 0, and the document will be deleted.
    if ((hRes=CoLockObjectExternal (&m_DropTarget, FALSE, TRUE))
        !=ResultFromScode(S_OK))
    {
        /* if CoLockObjectExternal fails, this means that we cannot release
         * the reference count to our destinated object. This will cause
         * memory leakage.
         */
        TestDebugOut("Fail in CoLockObjectExternal\n");
    }
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructor

CSimpleDoc::CSimpleDoc(CSimpleApp FAR * lpApp,HWND hWnd)
        : m_DropTarget(this), m_DropSource(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TestDebugOut("In CSimpleDoc's Constructor\r\n");
    m_lpApp = lpApp;
    m_lpSite = NULL;
    m_nCount = 0;
    // set up menu handles
    lpApp->m_hMainMenu = GetMenu(hWnd);
    lpApp->m_hFileMenu = GetSubMenu(lpApp->m_hMainMenu, 0);
    lpApp->m_hEditMenu = GetSubMenu(lpApp->m_hMainMenu, 1);
    lpApp->m_hHelpMenu = GetSubMenu(lpApp->m_hMainMenu, 2);
    lpApp->m_hCascadeMenu = NULL;
    m_fModifiedMenu = FALSE;

    // drag/drop related stuff
    m_fRegDragDrop = FALSE;       // is doc registered as drop target?
    m_fLocalDrag = FALSE;         // is doc source of the drag
    m_fLocalDrop = FALSE;         // was doc target of the drop
    m_fCanDropCopy = FALSE;       // is Drag/Drop copy/move possible?
    m_fCanDropLink = FALSE;       // is Drag/Drop link possible?
    m_fDragLeave = FALSE;         // has drag left
    m_fPendingDrag = FALSE;       // LButtonDown--possible drag pending
    m_ptButDown.x = m_ptButDown.y = 0; // LButtonDown coordinates

}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                     Location
//
//      TestDebugOut            Windows API
//      GetMenuItemCount             Windows API
//      RemoveMenu                   Windows API
//      DestroyMenu                  Windows API
//      DestroyWindow                Windows API
//      CSimpleSite::Release         SITE.CPP
//      CSimpleSite::UnloadOleObject SITE.CPP
//      IStorage::Release            OLE API
//
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
    TestDebugOut("In CSimpleDoc's Destructor\r\n");

    // Release all pointers we hold to the OLE object, also release
    // the ref count added in CSimpleSite::Create. this will make
    // the Site's ref count go to 0, and the Site will be deleted.
    if (m_lpSite)
    {
        m_lpSite->UnloadOleObject();
        m_lpSite->Release();
        m_lpSite = NULL;
    }

    // Release the Storage
    if (m_lpStorage)
    {
        m_lpStorage->Release();
        m_lpStorage = NULL;
    }

    // if the edit menu was modified, remove the menu item and
    // destroy the popup if it exists
    if (m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);
        RemoveMenu(m_lpApp->m_hEditMenu, nCount-1, MF_BYPOSITION);
        if (m_lpApp->m_hCascadeMenu)
            DestroyMenu(m_lpApp->m_hCascadeMenu);
    }

    DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Document level.
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CSimpleDoc::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // looking for IUnknown
    if (IsEqualIID( riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    // looking for IDropTarget
    if (IsEqualIID( riid, IID_IDropTarget))
    {
        m_DropTarget.AddRef();
        *ppvObj=&m_DropTarget;
        return ResultFromScode(S_OK);
    }

    // looking for IDropSource
    if (IsEqualIID( riid, IID_IDropSource))
    {
        m_DropSource.AddRef();
        *ppvObj=&m_DropSource;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count on the document object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::AddRef          APP.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
    TestDebugOut("In CSimpleDoc::AddRef\r\n");
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
    TestDebugOut("In CSimpleDoc::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Create         SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      CSimpleSite::Release        SITE.CPP
//      CSimpleSite::Revert         SITE.CPP
//      memset                      C Runtime
//      OleUIInsertObject           OLE2UI function
//      CSimpleDoc::DisableInsertObject DOC.CPP
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
    OLEUIINSERTOBJECT io;
    UINT iret;
    TCHAR szFile[OLEUI_CCHPATHMAX];

    HRESULT hRes;

    m_lpSite = CSimpleSite::Create(this);

    if (!m_lpSite)
    {
       /* memory allocation problem. cannot continue.
        */
       TestDebugOut("Memory allocation error\n");
       return;
    }

    // clear the structure
    _fmemset(&io, 0, sizeof(OLEUIINSERTOBJECT));

    // fill the structure
    io.cbStruct = sizeof(OLEUIINSERTOBJECT);
    io.dwFlags = IOF_SELECTCREATENEW      | IOF_DISABLELINK     |
                 IOF_DISABLEDISPLAYASICON | IOF_CREATENEWOBJECT |
                 IOF_CREATEFILEOBJECT;
    io.hWndOwner = m_hDocWnd;
    io.lpszCaption = (LPTSTR)TEXT("Insert Object");
    io.iid = IID_IOleObject;
    io.oleRender = OLERENDER_DRAW;
    io.lpIOleClientSite = &m_lpSite->m_OleClientSite;
    io.lpIStorage = m_lpSite->m_lpObjStorage;
    io.ppvObj = (LPVOID FAR *)&m_lpSite->m_lpOleObject;
    io.lpszFile = szFile;
    io.cchFile = sizeof(szFile)/sizeof(TCHAR);
                                      // cchFile is the number of characters
    _fmemset((LPTSTR)szFile, 0, sizeof(szFile));

    // call OUTLUI to do all the hard work
    iret = OleUIInsertObject(&io);

    if (iret == OLEUI_OK)
    {
        m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
        // disable Insert Object menu item
        DisableInsertObject();
    }
    else
    {
        m_lpSite->Release();
        m_lpSite = NULL;
        if (((hRes=m_lpStorage->Revert()) != ResultFromScode(S_OK)) &&
             (hRes!=ResultFromScode(STG_E_REVERTED)))
        {
           TestDebugOut("Fail in IStorage::Revert\n");
        }
    }
}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
    MoveWindow(
            m_hDocWnd,
            lpRect->left, lpRect->top,
            lpRect->right, lpRect->bottom, TRUE);

    return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OLE2UI function
//
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
    // m_fModifiedMenu is TRUE if the menu has already been modified
    // once.  Since we only support one obect every time the application
    // is run, then once the menu is modified, it doesn't have
    // to be done again.
    if (m_lpSite && !m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);

        if (!OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
                           NULL,
                           m_lpApp->m_hEditMenu,
                           nCount + 1,
                           IDM_VERB0,
                           0,           // no maximum verb IDM enforced
                           FALSE,
                           1,
                           &m_lpApp->m_hCascadeMenu) )
        {
            TestDebugOut("Fail in OleUIAddVerbMenu\n");
        }

        m_fModifiedMenu = TRUE;
    }
    return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
    // if we supported multiple objects, then we would enumerate
    // the objects and call paint on each of them from here.

    if (m_lpSite)
        m_lpSite->PaintObj(hDC);

}

//**********************************************************************
//
// CSimpleDoc::DisableInsertObject
//
// Purpose:
//
//      Disable the ability to insert a new object in this document.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another. Also we revoke ourself as
//      a potential drop target.
//
//********************************************************************

void CSimpleDoc::DisableInsertObject(void)
{
#ifdef NOTREADY
    // Disable InsertObject menu choice
    EnableMenuItem( m_lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED |
                                             MF_GRAYED);
#else
    // Disable InsertObject menu choice
    EnableMenuItem( m_lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_DISABLED |
                                             MF_GRAYED);
    // Enable Copy menu choice
    EnableMenuItem( m_lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);
#endif // NOTREADY

    // We no longer accept dropping of objects
    if (m_fRegDragDrop)
    {
        HRESULT hRes;
        if (((hRes=RevokeDragDrop(m_hDocWnd))!=ResultFromScode(S_OK)) &&
             (hRes!=ResultFromScode(DRAGDROP_E_NOTREGISTERED)))
        {
           /* if we fail in revoking the drag-drop, we will probably be
            * having memory leakage.
            */
           TestDebugOut("Fail in RevokeDragDrop\n");
        }
        else
        {
           m_fRegDragDrop = FALSE;
        }
    }
}

//**********************************************************************
//
// CSimpleDoc::CopyObjectToClip
//
// Purpose:
//
//      Copy the embedded OLE object to the clipboard
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::Release       DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      OleSetClipboard             OLE API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Copy menu choice is enabled.
//
//********************************************************************

void CSimpleDoc::CopyObjectToClip(void)
{
    LPDATAOBJECT lpDataObj;

    // Create a data transfer object by cloning the existing OLE object
    CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);
    if (! pDataXferObj)
    {
        /* memory allocation error !
         */
        MessageBox(NULL, TEXT("Out-of-memory"), TEXT("SimpDnD"),
                   MB_SYSTEMMODAL | MB_ICONHAND);
        return;
    }
    // initially obj is created with 0 refcnt. this QI will make it go to 1.
    pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);

    // put out data transfer object on the clipboard. this API will AddRef.
    if (OleSetClipboard(lpDataObj) != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleSetClipboard\n");
       lpDataObj->Release();
    }

    // Give ownership of data transfer object to clipboard
    pDataXferObj->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpleDoc
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

#include "idt.h"        
#include "ids.h"        

class CSimpleSite;
class CSimpleApp;

class CSimpleDoc : public IUnknown 
{   
public:                  
    int             m_nCount;           // reference count
    LPSTORAGE       m_lpStorage;        // IStorage* pointer for Doc
    BOOL            m_fModifiedMenu;    // is object's verb menu on menu

    // Drag/Drop related fields
    BOOL            m_fRegDragDrop;     // is doc registered as drop target?
    BOOL            m_fLocalDrag;       // is doc source of the drag
    BOOL            m_fLocalDrop;       // was doc target of the drop
    BOOL            m_fCanDropCopy;     // is Drag/Drop copy/move possible?
    BOOL            m_fCanDropLink;     // is Drag/Drop link possible?
    BOOL            m_fDragLeave;       // has drag left
    BOOL            m_fPendingDrag;     // LButtonDown--possible drag pending
    POINT           m_ptButDown;        // LButtonDown coordinates
    
    CSimpleSite FAR * m_lpSite;
    CSimpleApp FAR * m_lpApp;
    
    HWND m_hDocWnd;
                        
    CDropTarget m_DropTarget;
    CDropSource m_DropSource;

    static CSimpleDoc FAR* Create(CSimpleApp FAR *lpApp, LPRECT lpRect, 
            HWND hWnd);

    void Close(void);

    CSimpleDoc();          
    CSimpleDoc(CSimpleApp FAR *lpApp, HWND hWnd);
    ~CSimpleDoc();        
    
    // IUnknown Interface    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 
    
    void InsertObject(void);
    void DisableInsertObject(void);
    long lResizeDoc(LPRECT lpRect);
    long lAddVerbs(void);
    void PaintDoc(HDC hDC);
    
    // Drag/Drop and clipboard support methods
    void CopyObjectToClip(void);
    BOOL QueryDrag(POINT pt);
    DWORD DoDragDrop(void);
    void Scroll(DWORD dwScrollDir) { /*...scroll Doc here...*/ }

private:

    void FailureNotifyHelper(TCHAR *pszMsg, DWORD dwData);

};
    
#endif  // _DOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\dxferobj.h ===
//**********************************************************************
// File name: dxferobj.h
//
//      Definition of CDataXferObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DATAXFEROBJ_H_)
#define _DATAXFEROBJ_H_

class CSimpleSite;

interface CDataObject;

class CDataXferObj : public IDataObject
{
private:
    int m_nCount;                       // reference count
    SIZEL m_sizel;
    POINTL m_pointl;
    LPSTORAGE m_lpObjStorage;
    LPOLEOBJECT m_lpOleObject;

    // construction/destruction         
    CDataXferObj();
    ~CDataXferObj();

public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release (); 

    STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf, 
    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) 
        { return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP DUnadvise  ( DWORD dwConnection) 
        { return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
        { return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
            STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut)
        { pformatetcOut->ptd = NULL; return ResultFromScode(E_NOTIMPL);	}
    STDMETHODIMP GetData  (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
    STDMETHODIMP GetDataHere  (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium);  
    STDMETHODIMP QueryGetData  (LPFORMATETC pformatetc ); 
    STDMETHODIMP SetData  (LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
            BOOL fRelease)
        { return ResultFromScode(E_NOTIMPL); }                           

    static CDataXferObj FAR* Create(CSimpleSite FAR* lpSite,
            POINTL FAR* pPointl);

};       
#endif 	// _DATAXFEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>


#ifdef WIN32
extern INT_PTR CALLBACK About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
#endif

//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//********************************************************************
CSimpleApp::CSimpleApp()
{
    TestDebugOut("In CSimpleApp's Constructor \r\n");

    // Set Ref Count
    m_nCount = 0;

    // clear members
    m_hAppWnd = NULL;
    m_hInst = NULL;
    m_lpDoc = NULL;

    // clear flags
    m_fInitialized = FALSE;

    // Initialize effects we allow.
    m_dwSourceEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE;
    m_dwTargetEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE;
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutdebugString              Windows API
//      OleUninitialize             OLE API
//
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
    TestDebugOut("In CSimpleApp's Destructor\r\n");

    // need to uninit the library...
    if (m_fInitialized)
        OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Close           DOC.CPP
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
    m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Application level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      S_FALSE             -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CSimpleApp::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
    TestDebugOut("In CSimpleApp::AddRef\r\n");
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at the application level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
    TestDebugOut("In CSimpleApp::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style = NULL;                    // Class style(s).
    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance =(HINSTANCE) hInstance;           // Application that owns
                                                   // the class.
    wc.hIcon = LoadIcon((HINSTANCE)hInstance,TEXT("SimpDnd"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  TEXT("SIMPLEMENU");    // Name of menu resource in
                                              // .RC file.
    wc.lpszClassName = TEXT("SimpDndAppWClass");  // Name used in
                                                  // CreateWindow call.

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
    wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns
                                                    // the class.
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("SimpDndDocWClass");    // Name used in
                                                    //CreateWindow call.

    // Register the window class and return success/failure code.

    return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      GetProfileInt               Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//      OleStdCreateDbAlloc         OLE2UI
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
    LPMALLOC lpMalloc = NULL;

#ifndef WIN32
   /* Since OLE is part of the operating system in Win32, we don't need to
    * check the version number in Win32.
    */
    DWORD dwVer = OleBuildVersion();

    // check to see if we are compatible with this version of the libraries
    if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
    {
#ifdef _DEBUG
        TestDebugOut("WARNING: Incompatible OLE library version\r\n");
#else
        return FALSE;
#endif
    }
#endif // WIN32

#if defined( _DEBUG )
    /* OLE2NOTE: Use a special debug allocator to help track down
    **    memory leaks.
    */
    OleStdCreateDbAlloc(0, &lpMalloc);
#endif

    //  We try passing in our own allocator first - if that fails we
    //  try without overriding the allocator.

    if (SUCCEEDED(OleInitialize(lpMalloc)) ||
        SUCCEEDED(OleInitialize(NULL)))
    {
        m_fInitialized = TRUE;
    }

#if defined( _DEBUG )
    /* OLE2NOTE: release the special debug allocator so that only OLE is
    **    holding on to it. later when OleUninitialize is called, then
    **    the debug allocator object will be destroyed. when the debug
    **    allocator object is destoyed, it will report (to the Output
    **    Debug Terminal) whether there are any memory leaks.
    */
    if (lpMalloc) lpMalloc->Release();
#endif

    m_hInst = (HINSTANCE) hInstance;

    // Create the "application" windows
    m_hAppWnd = CreateWindow (TEXT("SimpDndAppWClass"),
                              TEXT("Simple OLE 2.0 Drag/Drop Container"),
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              NULL,
                              (HINSTANCE) hInstance,
                              NULL);

    if (!m_hAppWnd)
        return FALSE;

    // if we have been launched by the test driver, tell it our window handle

    if( m_hDriverWnd )
    {
        PostMessage(m_hDriverWnd, WM_TESTREG, (WPARAM)m_hAppWnd, 0);
    }

    // delay before dragging should start, in milliseconds
    m_nDragDelay = GetProfileInt(
            TEXT("windows"),
            TEXT("DragDelay"),
            DD_DEFDRAGDELAY
    );

    // minimum distance (radius) before drag should start, in pixels
    m_nDragMinDist = GetProfileInt(
            TEXT("windows"),
            TEXT("DragMinDist"),
            DD_DEFDRAGMINDIST
    );

    // delay before scrolling, in milliseconds
    m_nScrollDelay = GetProfileInt(
            TEXT("windows"),
            TEXT("DragScrollDelay"),
            DD_DEFSCROLLDELAY
    );

    // inset-width of the hot zone, in pixels
    m_nScrollInset = GetProfileInt(
            TEXT("windows"),
            TEXT("DragScrollInset"),
            DD_DEFSCROLLINSET
    );

    // scroll interval, in milliseconds
    m_nScrollInterval = GetProfileInt(
            TEXT("windows"),
            TEXT("DragScrollInterval"),
            DD_DEFSCROLLINTERVAL
    );

    ShowWindow (m_hAppWnd, nCmdShow);
    UpdateWindow (m_hAppWnd);

    return m_fInitialized;
}





//+-------------------------------------------------------------------------
//
//  Member:     CSimpleApp::UpdateDragDropEffects
//
//  Synopsis:   Update drag/drop effects
//
//  Arguments:  [iMenuPos] - menu position either source or target
//              [iMenuCommand] - what command the menu selection maps to
//              [dwEffect] - new effects
//              [pdwEffectToUpdate] - where to store the effects
//
//  Algorithm:  Get the menu for either source or target. Then clear any
//              outstanding check marks. Check the appropriate item. Finally
//              update the effects that we allow.
//
//  History:    dd-mmm-yy Author    Comment
//     		06-May-94 Ricksa    author
//
//--------------------------------------------------------------------------
void CSimpleApp::UpdateDragDropEffects(
    int iMenuPos,
    int iMenuCommand,
    DWORD dwEffect,
    DWORD *pdwEffectToUpdate)
{
    // Get the menu that we want to process
    HMENU hMenuItem = GetSubMenu(m_hHelpMenu, iMenuPos);

    // Clear any current check marks
    for (int i = 0; i < 3; i++)
    {
        CheckMenuItem(hMenuItem, i, MF_BYPOSITION | MF_UNCHECKED);
    }

    // Check the appropriate item.
    CheckMenuItem(hMenuItem, iMenuCommand, MF_BYCOMMAND | MF_CHECKED);
    *pdwEffectToUpdate = dwEffect;
}


//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleObject::DoVerb                          Object
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.CPP
//      CSimpleDoc::CopyObjectToClip                DOC.CPP
//      CSimpleDoc::Close                           DOC.CPP
//
//********************************************************************

LRESULT CSimpleApp::lCommandHandler (HWND hWnd, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    // see if the command is a verb selections
    if (wParam >= IDM_VERB0)
    {
        // get the rectangle of the object
        m_lpDoc->m_lpSite->GetObjRect(&rect);

        if (m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                wParam - IDM_VERB0, NULL,
                &m_lpDoc->m_lpSite->m_OleClientSite, -1,
                m_lpDoc->m_hDocWnd, &rect)
                != ResultFromScode(S_OK))
        {
            TestDebugOut("Fail in IOleObject::DoVerb\n");
        }
    }
    else
    {
        switch (wParam)
        {
            // bring up the About box
            case IDM_ABOUT:
                {
#ifdef WIN32
                    DialogBox(m_hInst,          // current instance
                        TEXT("AboutBox"),       // resource to use
                        m_hAppWnd,              // parent handle
                        About);                 // About() instance address
#else
                    FARPROC lpProcAbout = MakeProcInstance((FARPROC)About,
                                                            m_hInst);

                    DialogBox(m_hInst,          // current instance
                        TEXT("AboutBox"),       // resource to use
                        m_hAppWnd,              // parent handle
                        lpProcAbout);           // About() instance address

                    FreeProcInstance(lpProcAbout);
#endif
                    break;
                }

            // bring up the InsertObject Dialog
            case IDM_INSERTOBJECT:
                m_lpDoc->InsertObject();
                break;

            // Copy the object to the Clipboard
            case IDM_COPY:
                m_lpDoc->CopyObjectToClip();
                break;

            // exit the application
            case IDM_EXIT:
                SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                break;

            case IDM_NEW:
                lCreateDoc(hWnd, 0, 0, 0);
                break;

            // Only allow copy from the source
            case IDM_SOURCE_COPY:
                UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS,
                    IDM_SOURCE_COPY, DROPEFFECT_COPY, &m_dwSourceEffect);
                break;

            // Only allow move from the source
            case IDM_SOURCE_MOVE:
                UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS,
                    IDM_SOURCE_MOVE, DROPEFFECT_MOVE, &m_dwSourceEffect);
                break;

            // Allow both copy and move from the source
            case IDM_SOURCE_COPYMOVE:
                UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS,
                    IDM_SOURCE_COPYMOVE, DROPEFFECT_COPY | DROPEFFECT_MOVE,
                        &m_dwSourceEffect);
                break;

            // Only accept copy in target
            case IDM_TARGET_COPY:
                UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS,
                    IDM_TARGET_COPY, DROPEFFECT_COPY, &m_dwTargetEffect);
                break;

            // Only accept move in target
            case IDM_TARGET_MOVE:
                UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS,
                    IDM_TARGET_MOVE, DROPEFFECT_MOVE, &m_dwTargetEffect);
                break;

            // Accept both move and copy in the target
            case IDM_TARGET_COPYMOVE:
                UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS,
                    IDM_TARGET_COPYMOVE, DROPEFFECT_COPY | DROPEFFECT_MOVE,
                        &m_dwTargetEffect);
                break;

            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
        }   // end of switch

    }  // end of else

    return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message,
                               WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    GetClientRect(m_hAppWnd, &rect);
    return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document object.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message,
                             WPARAM wParam, LPARAM lParam)
{
    RECT rect;
    static BOOL fFirstTime = TRUE;

    if (m_lpDoc != NULL)
    {
        // There is a document defined already so we close it without
        // saving which is equivalent to deleting the object.
        m_lpDoc->Close();
        m_lpDoc = NULL;
    }

    GetClientRect(hWnd, &rect);

    m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

    // First time initialization - for some reason the doc sets the
    // the application's m_hHelpMenu which we need. So we do the
    // initialization here.
    if (fFirstTime)
    {
        fFirstTime = FALSE;

        // Check default allowed effects for the source
        UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS, IDM_SOURCE_COPYMOVE,
            m_dwSourceEffect, &m_dwSourceEffect);

        // Check default allowed effects for the target
        UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS, IDM_TARGET_COPYMOVE,
            m_dwTargetEffect, &m_dwTargetEffect);
    }

    return NULL;
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
    BOOL retval = FALSE;

    // we do not have any accelerators

    return retval;
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
    // at this level, we could enumerate through all of the
    // visible objects in the application, so that a palette
    // that best fits all of the objects can be built.

    // This app is designed to take on the same palette
    // functionality that was provided in OLE 1.0, the palette
    // of the last object drawn is realized.  Since we only
    // support one object at a time, it shouldn't be a big
    // deal.

    // if we supported multiple documents, we would enumerate
    // through each of the open documents and call paint.

    if (m_lpDoc)
    {
        m_lpDoc->PaintDoc(hDC);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\ias.cpp ===
//**********************************************************************
// File name: IAS.CPP
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IAS::QueryInterface\r\n");

    // delegate to the document Object
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count on the CSimpleSite. Since CAdviseSink
//      is a nested class of CSimpleSite, we don't need a separate reference
//      count for CAdviseSink. We can just use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddRef         SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
    TestDebugOut("In IAS::AddRef\r\n");

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count on the CSimpleSite. Since CAdviseSink
//      is a nested class of CSimpleSite, we don't need a separate reference
//      count for CAdviseSink. We can just use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
    TestDebugOut("In IAS::Release\r\n");

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      FORMATETC pFormatetc     -   data format infomation
//      STGMEDIUM pStgmed        -   storage medium on which data is passed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc,
                                               STGMEDIUM FAR* pStgmed)
{
    TestDebugOut("In IAS::OnDataChange\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      IViewObject2::GetExtent     Object
//      IViewObject2::Release       Object
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
    LPVIEWOBJECT2 lpViewObject2;
    TestDebugOut("In IAS::OnViewChange\r\n");

    // get a pointer to IViewObject2
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
            IID_IViewObject2,
            (LPVOID FAR *)&lpViewObject2);

    if (hErr == NOERROR)
    {
        // get extent of the object
        // NOTE: this method will never be remoted; it can be called w/i
        // this async method
        lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL,
                                 &m_pSite->m_sizel);
        lpViewObject2->Release();
    }

    // need to clean up the region
    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      LPMONIKER pmk         -  pointer to moniker
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
    TestDebugOut("In IAS::OnRename\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
    TestDebugOut("In IAS::OnSave\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
    TestDebugOut("In IAS::OnClose\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\dxferobj.cpp ===
//**********************************************************************
// File name: DXFEROBJ.CPP
//
//      Implementation file for CDataXferObj, data transfer object
//      implementation of IDataObject interface.
//
// Functions:
//
//      See DXFEROBJ.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include <enumfetc.h>
#include <assert.h>
#include "dxferobj.h"
#include "site.h"

//BUGBUG:  These should be fetched from real header files
#define CF_HDROP 15
typedef struct _dropfilestruct {
    DWORD pFiles;
    POINT pt;
    BOOL fNC;
    BOOL fWide;
} DROPFILESTRUCT;


CLIPFORMAT g_cfEmbeddedObject=RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
CLIPFORMAT g_cfObjectDescriptor=RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);

// List of formats offered by our data transfer object via EnumFormatEtc
static FORMATETC s_arrGetFmtEtcs[] =
{
    { g_cfEmbeddedObject, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},
    { g_cfObjectDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    { CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT}
};


//**********************************************************************
//
// CDataXferObj::Create
//
// Purpose:
//
//      Creation routine for CDataXferObj
//
// Parameters:
//
//      CSimpleSite FAR *lpSite   - Pointer to source CSimpleSite
//                                  this is the container site of the
//                                  source OLE object to be transfered
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      assert                      C Runtime
//
// Comments:
//      reference count of CDataXferObj will be 0 on return.
//
//********************************************************************

CDataXferObj FAR * CDataXferObj::Create(
		CSimpleSite FAR *lpSite,
		POINTL FAR* pPointl
)
{
    CDataXferObj FAR * lpTemp = new CDataXferObj();

    if (!lpTemp)
        return NULL;

    // create a sub-storage for the object
    HRESULT hErr = StgCreateDocfile(
    			NULL,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE |
            STGM_DELETEONRELEASE,
            0,
            &lpTemp->m_lpObjStorage);

    assert(hErr == NOERROR);

    if (hErr != NOERROR)
    {
        delete lpTemp;
        return NULL;
    }

    // Clone the source object
    if (lpSite->m_lpOleObject)
    {
        // Object is loaded; ask the object to save into the new storage
        LPPERSISTSTORAGE pPersistStorage;

        if (lpSite->m_lpOleObject->QueryInterface(IID_IPersistStorage,
                (LPVOID FAR*)&pPersistStorage) != ResultFromScode(S_OK))
        {
           /* cannot find interface
            */
           return(NULL);
        }
        assert(pPersistStorage);
        if (OleSave(pPersistStorage, lpTemp->m_lpObjStorage, FALSE)
            != ResultFromScode(S_OK))
        {
            TestDebugOut("Fail in OleSave\n");
        }

        // pass NULL so that object application won't forget the real stg
        if (pPersistStorage->SaveCompleted(NULL) != ResultFromScode(S_OK))
        {
          TestDebugOut("Fail in IPersistStorage::SaveCompleted\n");
        }
        pPersistStorage->Release();
    }
    else
    {
        // Object not loaded so use cheaper IStorage CopyTo operation
        lpSite->m_lpObjStorage->CopyTo(0, NULL, NULL, lpTemp->m_lpObjStorage);
    }

    if (OleLoad(lpTemp->m_lpObjStorage, IID_IOleObject, NULL,
                (LPVOID FAR*)&lpTemp->m_lpOleObject)
        != ResultFromScode(S_OK))
    {
       /* we cannot load the embedded/linked object into the memory
        */
       return(NULL);
    }
    assert(lpTemp->m_lpOleObject);

    lpTemp->m_sizel = lpSite->m_sizel;
    if (pPointl)
    	lpTemp->m_pointl = *pPointl;
    else
    	lpTemp->m_pointl.x = lpTemp->m_pointl.y = 0;
    return lpTemp;
}

//**********************************************************************
//
// CDataXferObj::CDataXferObj
//
// Purpose:
//
//      Constructor for CDataXferObj
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************

CDataXferObj::CDataXferObj (void)
{
    // clear the reference count
    m_nCount = 0;

    m_lpObjStorage = NULL;
    m_lpOleObject = NULL;
    m_sizel.cx = m_sizel.cy = 0;
    m_pointl.x = m_pointl.y = 0;
}

//**********************************************************************
//
// CDataXferObj::~CDataXferObj
//
// Purpose:
//
//      Destructor for CDataXferObj
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
//
//********************************************************************

CDataXferObj::~CDataXferObj ()
{
    TestDebugOut ("In CDataXferObj's Destructor \r\n");

    if (m_lpOleObject)
    {
       m_lpOleObject->Release();
       m_lpOleObject = NULL;

       // Release the storage for this object
       m_lpObjStorage->Release();
       m_lpObjStorage = NULL;
    }
}



//**********************************************************************
//
// CDataXferObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the CDataXferObj instance
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CDataXferObj::AddRef        DXFEROBJ.CPP
//
//
//********************************************************************

STDMETHODIMP CDataXferObj::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CDataXferObj::QueryInterface\r\n");

    if (IsEqualIID( riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    // unknown interface requested
    *ppvObj = NULL;     // must set out pointer parameters to NULL
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CDataXferObj::AddRef
//
// Purpose:
//
//      Increments the reference count of the CDataXferObj instance
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::AddRef()
{
    TestDebugOut("In CDataXferObj::AddRef\r\n");

    return ++m_nCount;
}

//**********************************************************************
//
// CDataXferObj::Release
//
// Purpose:
//
//      Decrements the reference count of the CDataXferObj object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::Release()
{
    TestDebugOut("In CDataXferObj::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}


/********************************************************************
** This IDataObject implementation is used for data transfer.
**
** The following methods are NOT supported for data transfer:
**		IDataObject::SetData	-- return E_NOTIMPL
**		IDataObject::DAdvise -- return OLE_E_ADVISENOTSUPPORTED
**				   ::DUnadvise
**				   ::EnumDAdvise
**		IDataObject::GetCanonicalFormatEtc -- return E_NOTIMPL
**						(NOTE: must set pformatetcOut->ptd = NULL)
*********************************************************************/

    	
//**********************************************************************
//
// CDataXferObj::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DV_E_FORMATETC    - The FORMATETC is not supported
//      S_OK              - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//      we support the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************
STDMETHODIMP CDataXferObj::QueryGetData (LPFORMATETC pformatetc)
{
    SCODE sc = DV_E_FORMATETC;

    TestDebugOut("In CDataXferObj::QueryGetData\r\n");

    // check the validity of the formatetc.

    if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
        sc = S_OK;
    }

    else if ( (pformatetc->cfFormat == g_cfObjectDescriptor) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_HGLOBAL) )
    {
        sc = S_OK;
    }

    else if ( (pformatetc->cfFormat == CF_METAFILEPICT) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_MFPICT) )
    {
        sc = S_OK;
    }
    else if ( (pformatetc->cfFormat == CF_HDROP) &&
	 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
	 (pformatetc->tymed == TYMED_HGLOBAL) )
    {
	sc = S_OK;
    }

    return ResultFromScode(sc);
}

extern BOOL gfUseEmptyEnumerator;

//**********************************************************************
//
// CDataXferObj::EnumFormatEtc
//
// Purpose:
//
//      Enumerates the formats that can be used to store data
//
// Parameters:
//
//      DWORD dwDirection                - format to be enumerated
//
//      LPENUMFORMATETC ppenumFormatEtc  - where to return the
//                                         instantiated enumerator
//
// Return Value:
//
//      S_OK              - if the operation is successful
//      E_OUTOFMEMORY     - if ran out of memory
//      E_NOTIMPL         - if dwDirection is not supported
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      OleStdEnumFmtEtc_Create     OLE2UI
//
//**********************************************************************

STDMETHODIMP CDataXferObj::EnumFormatEtc(
		DWORD dwDirection,
		LPENUMFORMATETC FAR* ppenumFormatEtc
)
{
    SCODE sc = E_NOTIMPL;

    TestDebugOut("In CDataXferObj::EnumFormatEtc\r\n");
    *ppenumFormatEtc = NULL;

    if( gfUseEmptyEnumerator == TRUE )
    {
	return E_FAIL;
    }

    if (dwDirection == DATADIR_GET)
    {
        *ppenumFormatEtc = OleStdEnumFmtEtc_Create(
                sizeof(s_arrGetFmtEtcs)/sizeof(s_arrGetFmtEtcs[0]),
                s_arrGetFmtEtcs);
        if (*ppenumFormatEtc == NULL)
            sc = E_OUTOFMEMORY;
        else
        	   sc = S_OK;
    }
    return ResultFromScode(sc);
}


//**********************************************************************
//
// CDataXferObj::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DV_E_FORMATETC    - Format not supported
//      S_OK              - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      OleStdGetOleObjectData          OLE2UI API
//      OleStdGetMetafilePictFromOleObject OLE2UI API
//      OleStdGetObjectDescriptorDataFromOleObject OLE2UI API
//      ResultFromScode                 OLE API
//      IOleObject::QueryInterface      Object
//
// Comments:
//      we support GetData for the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetData (
		LPFORMATETC pformatetcIn,
		LPSTGMEDIUM pmedium
)
{
    SCODE sc = DV_E_FORMATETC;

    TestDebugOut("In CDataXferObj::GetData\r\n");

    // we must set all out pointer parameters to NULL. */
    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;    // we transfer ownership to caller
    pmedium->hGlobal = NULL;

    // Check the FORMATETC and fill pmedium if valid.
    if ( (pformatetcIn->cfFormat == g_cfEmbeddedObject) &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed == TYMED_ISTORAGE) )
    {
         LPPERSISTSTORAGE pPersistStorage;

         /* render CF_EMBEDDEDOBJECT by asking the object to save
         **    into a temporary, DELETEONRELEASE IStorage allocated by us.
         */
         HRESULT hRes;
         if ((hRes=m_lpOleObject->QueryInterface(
                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage))
             != ResultFromScode(S_OK))
         {
             return(hRes);
         }

         assert(pPersistStorage);
         HRESULT hrErr = OleStdGetOleObjectData(
                    pPersistStorage,
                    pformatetcIn,
                    pmedium,
                    FALSE   /* fUseMemory -- (use file-base stg) */
         );
         pPersistStorage->Release();
         sc = GetScode( hrErr );

    }
    else if ( (pformatetcIn->cfFormat == g_cfObjectDescriptor) &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed == TYMED_HGLOBAL) )
    {

         // render CF_OBJECTDESCRIPTOR data
         pmedium->hGlobal = OleStdGetObjectDescriptorDataFromOleObject(
                m_lpOleObject,
                TEXT("Simple OLE 2.0 Container"), //string to identify source
                DVASPECT_CONTENT,
                m_pointl,
                (LPSIZEL)&m_sizel
            );
         if (! pmedium->hGlobal)
             sc = E_OUTOFMEMORY;
         else
         {
             pmedium->tymed = TYMED_HGLOBAL;
             sc = S_OK;
         }

    }
    else if ( (pformatetcIn->cfFormat == CF_METAFILEPICT) &&
            (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
            (pformatetcIn->tymed == TYMED_MFPICT) )
    {

	// render CF_METAFILEPICT by drawing the object into a metafile DC
	pmedium->hGlobal = OleStdGetMetafilePictFromOleObject(
	     m_lpOleObject, DVASPECT_CONTENT, NULL, pformatetcIn->ptd);
	if (! pmedium->hGlobal)
	   sc = E_OUTOFMEMORY;
	else
	{
	   pmedium->tymed = TYMED_MFPICT;
	   sc = S_OK;
	}
    }
    else if ( (pformatetcIn->cfFormat == CF_HDROP) &&
	    (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
	    (pformatetcIn->tymed == TYMED_HGLOBAL) )
    {
	// testing for Win3.1 style drag drop.  If we offer
	// CF_HDROP ( basically, a list of filenames) in a data object
	// given to OLE DoDragDrop, then DoDragDrop will translate
	// OLE drag drop into Win3.1 drag drop for Win3.1 drop targets

	ULONG cbFile;
	char szFile[256];
	DROPFILESTRUCT *pdfs;
	char *pfile;


	cbFile = GetEnvironmentVariable("SystemRoot", szFile, sizeof(szFile));

	if( cbFile == 0 )
	{
	    sc = E_FAIL;
	    goto errRtn;
	}


	cbFile += sizeof("\\setup.txt");

	strcat(szFile, "\\setup.txt");
	
	pmedium->tymed = TYMED_HGLOBAL;

	pmedium->hGlobal = GlobalAlloc( GMEM_DDESHARE,
			    sizeof(DROPFILESTRUCT) +
			    cbFile + 3);

	if( pmedium->hGlobal )
	{
	    pdfs = (DROPFILESTRUCT *)GlobalLock(pmedium->hGlobal);

	    if( pdfs )
	    {
		pdfs->pFiles = sizeof(DROPFILESTRUCT);
		pfile = (char *)((BYTE *)pdfs) + sizeof(DROPFILESTRUCT);
		pdfs->fNC = FALSE;
		pdfs->fWide = FALSE;
		pdfs->pt.x = 0;
		pdfs->pt.y = 0;
		strcpy(pfile, szFile);
		// double-NULL terminate it
		pfile[strlen(pfile)+2] = '\0';

		GlobalUnlock(pmedium->hGlobal);

		sc = S_OK;
	    }
	    else
	    {
		sc = E_OUTOFMEMORY;
	    }
	}
	else
	{
	    sc = E_OUTOFMEMORY;
	}
    }

errRtn:

    return ResultFromScode( sc );
}

//**********************************************************************
//
// CDataXferObj::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      NOERROR             - if OleStdGetOleObjectData success
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleStdGetOleObjectData      OLE2UI API
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetDataHere (
		LPFORMATETC pformatetc,
		LPSTGMEDIUM pmedium
)
{
    SCODE sc = DV_E_FORMATETC;

    TestDebugOut("In CDataXferObj::GetDataHere\r\n");

    // NOTE: pmedium is an IN parameter. we should NOT set
    //           pmedium->pUnkForRelease to NULL

    // Check the FORMATETC and fill pmedium if valid.
    if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
         LPPERSISTSTORAGE pPersistStorage;

         /* render CF_EMBEDDEDOBJECT by asking the object to save
         **    into the IStorage allocated by the caller.
         */
         HRESULT hRes;

         if ((hRes=m_lpOleObject->QueryInterface(
                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage))
             != ResultFromScode(S_OK))
         {
             return(hRes);
         }
         assert(pPersistStorage);
         HRESULT hrErr = OleStdGetOleObjectData(
                 pPersistStorage, pformatetc, pmedium,0 /*fUseMemory--N/A*/ );
         pPersistStorage->Release();
         sc = GetScode( hrErr );
    }
    return ResultFromScode( sc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\ias.h ===
//**********************************************************************
// File name: IAS.H
//
//      Definition of CAdviseSink
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IAS_H_ )
#define _IAS_H_

#include <assert.h>

class CSimpleSite;

interface CAdviseSink : public IAdviseSink
{
    CSimpleSite FAR * m_pSite;

    CAdviseSink(CSimpleSite FAR * pSite)
       {
        TestDebugOut("In IAS's constructor\r\n");
        m_pSite = pSite;
       };

    ~CAdviseSink()
       {
        TestDebugOut("In IAS's destructor\r\n");
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // *** IAdviseSink methods ***
    STDMETHODIMP_(void) OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed);
    STDMETHODIMP_(void) OnViewChange (DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename (LPMONIKER pmk);
    STDMETHODIMP_(void) OnSave ();
    STDMETHODIMP_(void) OnClose ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\ids.h ===
//**********************************************************************
// File name: ids.h
//
//      Definition of CDropSource
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDS_H_ )
#define _IDS_H_

#include <assert.h>

class CSimpleDoc;

interface CDropSource : public IDropSource
{
    CSimpleDoc FAR * m_pDoc;

    CDropSource(CSimpleDoc FAR * pDoc)
       {
        TestDebugOut("In IDS's constructor\r\n");
        m_pDoc = pDoc;
       };

    ~CDropSource()
       {
        TestDebugOut("In IDS's destructor\r\n");
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

       // *** IDropSource methods ***
    STDMETHODIMP QueryContinueDrag (BOOL fEscapePressed, DWORD grfKeyState);
    STDMETHODIMP GiveFeedback (DWORD dwEffect);

private:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\idt.cpp ===
//**********************************************************************
// File name: IDT.CPP
//
//      Implementation file for CDropTarget
//
// Functions:
//
//      See IDT.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"

extern CLIPFORMAT g_cfObjectDescriptor;


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//      Check if the desired drop operation (identified by the given key
//      state) is possible at the current mouse position (pointl).
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      BOOL fDragScroll        - TRUE if drag scrolling cursor should
//                                be shown.
//      LPDWORD pdwEffect       - (OUT) drag effect that should occur
//
// Return Value:
//
//      BOOL                    - TRUE if drop could take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      OleStdGetDropEffect         OLE2UI API
//
//
//********************************************************************

BOOL CDropTarget::QueryDrop (
    DWORD           grfKeyState,
    POINTL          pointl,
    BOOL            fDragScroll,
    LPDWORD         pdwEffect
)
{
    DWORD      dwScrollEffect = 0L;
    DWORD      dwOKEffects = m_pDoc->m_lpApp->m_dwTargetEffect & *pdwEffect;

    /* check if the cursor is in the active scroll area, if so need the
    **    special scroll cursor.
    */
    if (fDragScroll)
        dwScrollEffect = DROPEFFECT_SCROLL;

    /* if we have already determined that the source does NOT have any
    **    acceptable data for us, the return NO-DROP
    */
    if (! m_fCanDropCopy && ! m_fCanDropLink)
        goto dropeffect_none;

    /* OLE2NOTE: determine what type of drop should be performed given
    **    the current modifier key state. we rely on the standard
    **    interpretation of the modifier keys:
    **          no modifier -- DROPEFFECT_MOVE or whatever is allowed by src
    **          SHIFT       -- DROPEFFECT_MOVE
    **          CTRL        -- DROPEFFECT_COPY
    **          CTRL-SHIFT  -- DROPEFFECT_LINK
    */

    *pdwEffect = OleStdGetDropEffect(grfKeyState);
    if (*pdwEffect == 0)
    {
        // No modifier keys given. Try in order MOVE, COPY, LINK.
        if ((DROPEFFECT_MOVE & dwOKEffects) && m_fCanDropCopy)
            *pdwEffect = DROPEFFECT_MOVE;
        else if ((DROPEFFECT_COPY & dwOKEffects) && m_fCanDropCopy)
            *pdwEffect = DROPEFFECT_COPY;
        else if ((DROPEFFECT_LINK & dwOKEffects) && m_fCanDropLink)
            *pdwEffect = DROPEFFECT_LINK;
        else
            goto dropeffect_none;
    }
    else
    {
        /* OLE2NOTE: we should check if the drag source application allows
        **    the desired drop effect.
        */
        if (!(*pdwEffect & dwOKEffects))
            goto dropeffect_none;

        if ((*pdwEffect == DROPEFFECT_COPY || *pdwEffect == DROPEFFECT_MOVE)
                && ! m_fCanDropCopy)
            goto dropeffect_none;

        if (*pdwEffect == DROPEFFECT_LINK && ! m_fCanDropLink)
            goto dropeffect_none;
    }

    *pdwEffect |= dwScrollEffect;
    return TRUE;

dropeffect_none:

    *pdwEffect = DROPEFFECT_NONE;
    return FALSE;
}


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//     Check to see if Drag scroll operation should be initiated.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if scroll cursor should be given
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      ScreenToClient              WINDOWS API
//      GetClientRect               WINDOWS API
//
// Comments:
//     A Drag scroll operation should be initiated when the mouse has
//     remained in the active scroll area (11 pixels frame around border
//     of window) for a specified amount of time (50ms).
//
//********************************************************************

BOOL CDropTarget::DoDragScroll (POINTL pointl)
{
    DWORD dwScrollDir = SCROLLDIR_NULL;
    DWORD dwTime = GetCurrentTime();
    int nScrollInset = m_pDoc->m_lpApp->m_nScrollInset;
    int nScrollDelay = m_pDoc->m_lpApp->m_nScrollDelay;
    int nScrollInterval = m_pDoc->m_lpApp->m_nScrollInterval;
    POINT point;
    RECT rect;

    point.x = (int)pointl.x;
    point.y = (int)pointl.y;

    ScreenToClient( m_pDoc->m_hDocWnd, &point);
    GetClientRect ( m_pDoc->m_hDocWnd, (LPRECT) &rect );

    if (rect.top <= point.y && point.y<=(rect.top+nScrollInset))
        dwScrollDir = SCROLLDIR_UP;
    else if ((rect.bottom-nScrollInset) <= point.y && point.y <= rect.bottom)
        dwScrollDir = SCROLLDIR_DOWN;
    else if (rect.left <= point.x && point.x <= (rect.left+nScrollInset))
        dwScrollDir = SCROLLDIR_LEFT;
    else if ((rect.right-nScrollInset) <= point.x && point.x <= rect.right)
        dwScrollDir = SCROLLDIR_RIGHT;

    if (m_dwTimeEnterScrollArea)
    {
        /* cursor was already in Scroll Area */

        if (! dwScrollDir)
        {
            /* cusor moved OUT of scroll area.
            **      clear "EnterScrollArea" time.
            */
            m_dwTimeEnterScrollArea = 0L;
            m_dwNextScrollTime = 0L;
            m_dwLastScrollDir = SCROLLDIR_NULL;

        }
        else
           if (dwScrollDir != m_dwLastScrollDir)
           {
            /* cusor moved into a different direction scroll area.
            **      reset "EnterScrollArea" time to start a new 50ms delay.
            */
            m_dwTimeEnterScrollArea = dwTime;
            m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
            m_dwLastScrollDir = dwScrollDir;

           }
           else
              if (dwTime && dwTime >= m_dwNextScrollTime)
              {
                 m_pDoc->Scroll ( dwScrollDir );    // Scroll document now
                 m_dwNextScrollTime = dwTime + (DWORD)nScrollInterval;
              }
    }
    else
    {
        if (dwScrollDir)
        {
            /* cusor moved INTO a scroll area.
            **   reset "EnterScrollArea" time to start a new 50ms delay.
            */
            m_dwTimeEnterScrollArea = dwTime;
            m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
            m_dwLastScrollDir = dwScrollDir;
        }
    }

    return (dwScrollDir ? TRUE : FALSE);
}


// Support functions/macros
#define SetTopLeft(rc, pt)		\
	((rc)->top = (pt)->y,(rc)->left = (pt)->x)
#define SetBottomRight(rc, pt)		\
	((rc)->bottom = (pt)->y,(rc)->right = (pt)->x)
#define OffsetPoint(pt, dx, dy)		\
	((pt)->x += dx, (pt)->y += dy)


/* HighlightRect
** -------------
**    Invert rectangle on screen. used for drop target feedback.
*/

static int HighlightRect(HWND hwnd, HDC hdc, LPRECT rc)
{
    POINT pt1, pt2;
    int old = SetROP2(hdc, R2_NOT);
    HPEN hpen;
    HGDIOBJ hold;

    pt1.x = rc->left;
    pt1.y = rc->top;
    pt2.x = rc->right;
    pt2.y = rc->bottom;

    ScreenToClient(hwnd, &pt1);
    ScreenToClient(hwnd, &pt2);

    hold = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    hpen = (HPEN) SelectObject(hdc, CreatePen(PS_SOLID, 2,
                          GetSysColor(COLOR_ACTIVEBORDER)));

    Rectangle(hdc, pt1.x, pt1.y, pt2.x, pt2.y);

    SetROP2(hdc, old);

    hold = SelectObject(hdc, hold);
    hpen = (HPEN) SelectObject(hdc, hpen);

    DeleteObject(hpen);

  return 0;
}


//**********************************************************************
//
// CDropTarget::InitDragFeedback
//
// Purpose:
//
//      Initialize data used to draw drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      IDataObject::GetData        Object
//      XformSizeInHimetricToPixels OLE2UI Library
//      GlobalLock                  WINDOWS API
//      GlobalUnlock                WINDOWS API
//      ReleaseStgMedium            OLE2 API
//      OffsetPoint                 IDT.CPP
//      SetTopLeft                  IDT.CPP
//      SetBottomRight              IDT.CPP
//
// Comments:
//      In order to know the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. If the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl)
{
    FORMATETC fmtetc;
    STGMEDIUM stgmed;
    POINT pt;
    int height, width;
    HRESULT hrErr;

    height = width = 100; // some default values
    pt.x = (int)pointl.x;
    pt.y = (int)pointl.y;

    // do a GetData for CF_OBJECTDESCRIPTOR format to get the size of the
    // object as displayed in the source. using this size, initialize the
    // size for the drag feedback rectangle.
    fmtetc.cfFormat = g_cfObjectDescriptor;
    fmtetc.ptd = NULL;
    fmtetc.lindex = -1;
    fmtetc.dwAspect = DVASPECT_CONTENT;
    fmtetc.tymed = TYMED_HGLOBAL;

    hrErr = pDataObj->GetData(&fmtetc, &stgmed);
    if (hrErr == NOERROR)
    {
        LPOBJECTDESCRIPTOR pOD=(LPOBJECTDESCRIPTOR)GlobalLock(stgmed.hGlobal);
        if (pOD != NULL)
        {
            XformSizeInHimetricToPixels(NULL, &pOD->sizel, &pOD->sizel);

            width = (int)pOD->sizel.cx;
            height = (int)pOD->sizel.cy;
            m_dwSrcAspect = pOD->dwDrawAspect;
        }

        GlobalUnlock(stgmed.hGlobal);
        ReleaseStgMedium(&stgmed);
    }

    m_ptLast = pt;
    m_fDragFeedbackDrawn = FALSE;
	
    OffsetPoint(&pt, -(width/2), -(height/2));
    SetTopLeft(&m_rcDragRect, &pt);

    OffsetPoint(&pt, width, height);
    SetBottomRight(&m_rcDragRect, &pt);
}


//**********************************************************************
//
// CDropTarget::UndrawDragFeedback
//
// Purpose:
//
//      Erase any drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//      HighlightRect               IDT.CPP
//
// Comments:
//      In order to know the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. if the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::UndrawDragFeedback( void )
{
    if (m_fDragFeedbackDrawn)
    {
        m_fDragFeedbackDrawn = FALSE;
        HDC hDC = GetDC(m_pDoc->m_hDocWnd);
        HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
        ReleaseDC(m_pDoc->m_hDocWnd, hDC);
    }
}


//**********************************************************************
//
// CDropTarget::DrawDragFeedback
//
// Purpose:
//
//      Compute new position of drop target feedback rectangle and
//      erase old rectangle and draw new rectangle.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      OffsetPoint                 IDT.CPP
//      OffsetRect                  IDT.CPP
//      HighlightRect               IDT.CPP
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//
//
//********************************************************************

void CDropTarget::DrawDragFeedback( POINTL pointl )
{
    POINT ptDiff;

    ptDiff.x = (int)pointl.x - m_ptLast.x;
    ptDiff.y = (int)pointl.y - m_ptLast.y;

    if (m_fDragFeedbackDrawn && (ptDiff.x == 0 && ptDiff.y == 0))
        return;     // mouse did not move; leave rectangle as drawn

    HDC hDC = GetDC(m_pDoc->m_hDocWnd);
    if (m_fDragFeedbackDrawn)
    {
        m_fDragFeedbackDrawn = FALSE;
        HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
    }

    OffsetRect(&m_rcDragRect, ptDiff.x, ptDiff.y);
    HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
    m_fDragFeedbackDrawn = TRUE;
	 m_ptLast.x = (int)pointl.x;
    m_ptLast.y = (int)pointl.y;
	 ReleaseDC(m_pDoc->m_hDocWnd, hDC);
}


//**********************************************************************
//
// CDropTarget::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
//
//********************************************************************

STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IDT::QueryInterface\r\n");

    // delegate to the document
    return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropTarget::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleDoc. Since CDropTarget is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for CDropTarget. We can safely use the reference count of
//      CSimpleDoc.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::AddReff         DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
    TestDebugOut("In IDT::AddRef\r\n");

    // delegate to the document Object
    return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropTarget::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleDoc. Since CDropTarget is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for CDropTarget. We can safely use the reference count of
//      CSimpleDoc.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Release         DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::Release()
{
    TestDebugOut("In IDT::Release\r\n");

    // delegate to the document object
    return m_pDoc->Release();
}


//**********************************************************************
//
// CDropTarget::DragEnter
//
// Purpose:
//
//      Called when the mouse first enters our DropTarget window
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleQueryCreateFromData      OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::DragEnter(LPDATAOBJECT pDataObj, DWORD grfKeyState,
                                     POINTL pointl, LPDWORD pdwEffect)
{
    TestDebugOut("In IDT::DragEnter\r\n");

    /* Determine if the drag source data object offers a data format
    **  that we understand. we accept only creating embedded objects.
    */
    m_fCanDropCopy = ((OleQueryCreateFromData(pDataObj) == NOERROR) ?
            TRUE : FALSE);
    m_fCanDropLink = FALSE; // linking NOT supported in this simple sample

    if (m_fCanDropCopy || m_fCanDropLink)
        InitDragFeedback(pDataObj, pointl);

    BOOL fDragScroll = DoDragScroll ( pointl );

    if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
    {
        DrawDragFeedback( pointl );
    }

    // with our drag drop optimization, pDataObj will actually be a
    // wrapper data object.  QueryGetData calls (currently) will be
    // propogated to the drag source (whereas EnumFormatetc is handled
    // locally).  Make sure we can do a QueryGetData.

    FORMATETC formatetc;
    formatetc.cfFormat = CF_METAFILEPICT;
    formatetc.tymed = TYMED_MFPICT;
    formatetc.ptd = NULL;
    formatetc.lindex = -1;
    formatetc.dwAspect = DVASPECT_CONTENT;

    // E_FAIL is usually returned if we could not get the drag source
    // data object.
    if( pDataObj->QueryGetData(&formatetc) == E_FAIL )
    {
	TestDebugOut("WARNING! QueryGetData failed!");
    }

    return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragOver
//
// Purpose:
//
//      Called when the mouse moves, key state changes, or a time
//      interval passes while the mouse is still within our DropTarget
//      window.
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE. OLE pulses the DragOver
//      calls in order that the DropTarget can implement drag scrolling
//
//********************************************************************

STDMETHODIMP CDropTarget::DragOver (DWORD grfKeyState, POINTL pointl,
                                    LPDWORD pdwEffect)
{
    TestDebugOut("In IDT::DragOver\r\n");

    BOOL fDragScroll = DoDragScroll ( pointl );

    if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
    {
        DrawDragFeedback( pointl );
    }
    else
    {
        UndrawDragFeedback();
    }

    return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragLeave
//
// Purpose:
//
//      Called when the mouse leaves our DropTarget window
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      UndrawDragFeedback          IDT.CPP
//      ResultFromScode             OLE2 API
//
//
//********************************************************************

STDMETHODIMP CDropTarget::DragLeave ()
{
    TestDebugOut("In IDT::DragLeave\r\n");

    UndrawDragFeedback();

    return ResultFromScode(S_OK);
}


//**********************************************************************
//
// CDropTarget::Drop
//
// Purpose:
//
//      Called when a Drop operation should take place.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK if sucess or HRESULT of the error code if fails
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Create         SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      OleCreateFromData           OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//      GetScode                    OLE2 API
//      ResultFromScode             OLE2 API
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState,
                                POINTL pointl, LPDWORD pdwEffect)
{
	 FORMATETC fmtetc;
    SCODE sc = S_OK;
	
    TestDebugOut("In IDT::Drop\r\n");

    UndrawDragFeedback();

    if (pDataObj && QueryDrop(grfKeyState,pointl,FALSE,pdwEffect))
    {
        m_pDoc->m_lpSite = CSimpleSite::Create(m_pDoc);
        if (!m_pDoc->m_lpSite)
        {
           /* memory allocation problem. cannot continue.
            */
           return(ResultFromScode(E_OUTOFMEMORY));
        }

        // keep same aspect as drop source
        m_pDoc->m_lpSite->m_dwDrawAspect = m_dwSrcAspect;

        // in order to specify a particular drawing Aspect we must
        // pass a FORMATETC* to OleCreateFromData
 	     fmtetc.cfFormat = NULL; 			// use whatever for drawing
	     fmtetc.ptd = NULL;
	     fmtetc.lindex = -1;
	     fmtetc.dwAspect = m_dwSrcAspect;	// desired drawing aspect
	     fmtetc.tymed = TYMED_NULL;

        HRESULT hrErr = OleCreateFromData (
                            pDataObj,
                            IID_IOleObject,
                            OLERENDER_DRAW,
                            &fmtetc,
                            &m_pDoc->m_lpSite->m_OleClientSite,
                            m_pDoc->m_lpSite->m_lpObjStorage,
                            (LPVOID FAR *)&m_pDoc->m_lpSite->m_lpOleObject);

        if (hrErr == NOERROR)
        {
            m_pDoc->m_lpSite->InitObject(FALSE /* fCreateNew */);
            m_pDoc->DisableInsertObject();
        }
        else
            sc = GetScode(hrErr);
    }

    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\idt.h ===
//**********************************************************************
// File name: idt.h
//
//      Definition of CDropTarget
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDT_H_ )
#define _IDT_H_

#include <assert.h>

class CSimpleDoc;

/* Flags to control direction for drag scrolling */
typedef enum tagSCROLLDIR {
    SCROLLDIR_NULL          = 0,
    SCROLLDIR_UP            = 1,
    SCROLLDIR_DOWN          = 2,
    SCROLLDIR_RIGHT         = 3,
    SCROLLDIR_LEFT          = 4
} SCROLLDIR;

interface CDropTarget : public IDropTarget
{
    CSimpleDoc FAR * m_pDoc;
    BOOL  m_fCanDropCopy;
    BOOL  m_fCanDropLink;
    DWORD m_dwSrcAspect;
	 RECT  m_rcDragRect;
    POINT m_ptLast;
    BOOL  m_fDragFeedbackDrawn;
    DWORD m_dwTimeEnterScrollArea;  // time of entering scroll border region
    DWORD m_dwLastScrollDir;        // current dir for drag scroll
    DWORD m_dwNextScrollTime;       // time for next scroll

    CDropTarget(CSimpleDoc FAR * pDoc)
       {
        TestDebugOut("In IDT's constructor\r\n");
        m_pDoc = pDoc;
        m_fCanDropCopy = FALSE;
        m_fCanDropLink = FALSE;
        m_fDragFeedbackDrawn = FALSE;
        m_dwTimeEnterScrollArea = 0L;
        m_dwNextScrollTime = 0L;
        m_dwLastScrollDir = SCROLLDIR_NULL;
       };

    ~CDropTarget()
       {
        TestDebugOut("In IDT's destructor\r\n");
       } ;

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

       // *** IDropTarget methods ***
    STDMETHODIMP DragEnter (LPDATAOBJECT pDataObj, DWORD grfKeyState,
            POINTL pt, LPDWORD pdwEffect);
    STDMETHODIMP DragOver  (DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);
    STDMETHODIMP DragLeave ();
    STDMETHODIMP Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt,
            LPDWORD pdwEffect);

private:
    // Drag/Drop support methods
    BOOL QueryDrop (DWORD grfKeyState, POINTL pointl, BOOL fDragScroll,
            LPDWORD lpdwEffect);
    BOOL DoDragScroll( POINTL pointl );
	void InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl);
    void DrawDragFeedback( POINTL pointl );
    void UndrawDragFeedback( void );
};

#endif  // _IDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class CSimpleSite;

interface COleClientSite : public IOleClientSite
{
    CSimpleSite FAR * m_pSite;

    COleClientSite(CSimpleSite FAR * pSite)
       {
        TestDebugOut("In IOCS's constructor\r\n");
        m_pSite = pSite;
       }

    ~COleClientSite()
       {
        TestDebugOut("In IOCS's destructor\r\n");
       }

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IOleClientSite methods ***
    STDMETHODIMP SaveObject();
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                            LPMONIKER FAR* ppmk);
    STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
    STDMETHODIMP ShowObject();
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IOCS::QueryInterface\r\n");

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleClientSite::AddRef
//
// Purpose:
//
//      Increments the reference count to CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need an extra reference
//      count for COleClientSite. We can safely use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::AddRef         SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
    TestDebugOut("In IOCS::AddRef\r\n");

    // delegate to the container Site
    return m_pSite->AddRef();
}


//**********************************************************************
//
// COleClientSite::Release
//
// Purpose:
//
//      Decrements the reference count to CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need an extra reference
//      count for COleClientSite. We can safely use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
    TestDebugOut("In IOCS::Release\r\n");

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
    LPPERSISTSTORAGE lpPS;
    SCODE sc = E_FAIL;

    TestDebugOut("In IOCS::SaveObject\r\n");

    // get a pointer to IPersistStorage
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
                            IID_IPersistStorage,(LPVOID FAR *)&lpPS);

    // save the object
    if (hErr == NOERROR)
    {
        sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
        lpPS->SaveCompleted(NULL);
        lpPS->Release();
    }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      DWORD  dwAssign         - the type of Moniker to be returned
//      DWORD  dwWhichMoniker   - which Moniker to be returned in ppmk
//      LPMONIKER ppmk          - point to where to return the Moniker
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                                        LPMONIKER FAR* ppmk)
{
    TestDebugOut("In IOCS::GetMoniker\r\n");

    // need to null the out pointer
    *ppmk = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPOLECONTAINER ppContainer   -  point to where the interface to be
//                                      returned
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    TestDebugOut("In IOCS::GetContainer\r\n");

    // NULL the out pointer
    *ppContainer = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
    TestDebugOut("In IOCS::ShowObject\r\n");
    return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      BringWindowToTop            Windows API
//      SetFocus                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    TestDebugOut("In IOCS::OnShowWindow\r\n");
    m_pSite->m_fObjectOpen = fShow;
    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

    // if object window is closing, then bring container window to top
    if (! fShow)
    {
        BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
        SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
    TestDebugOut("In IOCS::RequestNewObjectLayout\r\n");
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\ids.cpp ===
//**********************************************************************
// File name: IDS.CPP
//
//      Implementation file for CDropSource
//
// Functions:
//
//      See IDS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "app.h"
#include "doc.h"
#include "site.h"
#include "dxferobj.h"




//+-------------------------------------------------------------------------
//
//  Member:     CSimpleDoc::FailureNotifyHelper(
//
//  Synopsis:   Report a drag drop error
//
//  Arguments:  [pszMsg] - Message
//              [dwData] - Data to print out
//
//  Algorithm:  Print a message box for fatal errors during drag drop
//              operation.
//
//  History:    dd-mmm-yy Author    Comment
//     		06-May-94 Ricksa    author
//
//--------------------------------------------------------------------------
void CSimpleDoc::FailureNotifyHelper(TCHAR *pszMsg, DWORD dwData)
{
    TCHAR pszBuf[256];

    wsprintf(pszBuf, TEXT("%s %lx"), pszMsg, dwData);

    MessageBox(m_hDocWnd, pszBuf, TEXT("Drag/Drop Error"), MB_OK);
}



//**********************************************************************
//
// CSimpleDoc::QueryDrag
//
// Purpose:
//
//      Check to see if Drag operation should be initiated based on the
//      current position of the mouse.
//
// Parameters:
//
//      POINT pt                - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if drag should take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::GetObjRect     SITE.CPP
//      PtInRect                    Windows API
//
//
//********************************************************************

BOOL CSimpleDoc::QueryDrag(POINT pt)
{
    // if pt is within rect of object, then start drag
    if (m_lpSite)
    {
        RECT rect;
        m_lpSite->GetObjRect(&rect);
        return ( PtInRect(&rect, pt) ? TRUE : FALSE );
    }
    else
        return FALSE;
}


//**********************************************************************
//
// CSimpleDoc::DoDragDrop
//
// Purpose:
//
//      Actually perform a drag/drop operation with the current
//      selection in the source document.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      DWORD                    - returns the result effect of the
//                                 drag/drop operation:
//                                      DROPEFFECT_NONE,
//                                      DROPEFFECT_COPY,
//                                      DROPEFFECT_MOVE, or
//                                      DROPEFFECT_LINK
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      CDataXferObj::Release       DXFEROBJ.CPP
//      DoDragDrop                  OLE API
//      TestDebugOut           Windows API
//      MessageBox                  Windows API
//
//
//********************************************************************

DWORD CSimpleDoc::DoDragDrop (void)
{
    DWORD       dwEffect     = 0;
    LPDATAOBJECT lpDataObj;

    TestDebugOut("In CSimpleDoc::DoDragDrop\r\n");

    // Create a data transfer object by cloning the existing OLE object
    CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);

    if (! pDataXferObj)
    {
        MessageBox(NULL, TEXT("Out-of-memory"), TEXT("SimpDnD"),
                   MB_SYSTEMMODAL | MB_ICONHAND);
        return DROPEFFECT_NONE;
    }

    // initially obj is created with 0 refcnt. this QI will make it go to 1.
    pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);
    assert(lpDataObj);

    m_fLocalDrop     = FALSE;
    m_fLocalDrag     = TRUE;

    HRESULT hRes;
    hRes=::DoDragDrop(lpDataObj,
                 &m_DropSource,
                 m_lpApp->m_dwSourceEffect, 	// we only allow copy
                 &dwEffect);

    if (hRes!=ResultFromScode(S_OK)
       && hRes!=ResultFromScode(DRAGDROP_S_DROP)
       && hRes!=ResultFromScode(DRAGDROP_S_CANCEL))
    {
        FailureNotifyHelper(
            TEXT("Unexpected error from DoDragDrop"), hRes);
    }

    // Validate the responses
    if (hRes == ResultFromScode(DRAGDROP_S_DROP))
    {
        // Drop was successful so make sure the effects make sense
        if (((dwEffect & m_lpApp->m_dwSourceEffect) == 0)
            && (dwEffect != DROPEFFECT_NONE))
        {
            FailureNotifyHelper(
                TEXT("Unexpected Effect on DRAGDROP_S_DROP from DoDragDrop"),
                    dwEffect);
        }
    }
    else if ((hRes == ResultFromScode(DRAGDROP_S_CANCEL))
        || (hRes == ResultFromScode(S_OK)))
    {
        // Drop was cancelled/or never happened so the effect s/b none
        if (dwEffect != DROPEFFECT_NONE)
        {
            FailureNotifyHelper(
                TEXT("Unexpected Effect on S_OK or Cancel from DoDragDrop"),
                    dwEffect);
        }
    }

    m_fLocalDrag     = FALSE;

    /* if after the Drag/Drop modal (mouse capture) loop is finished
    **    and a drag MOVE operation was performed, then we must delete
    **    the selection that was dragged.
    */
    if ( (dwEffect & DROPEFFECT_MOVE) != 0 )
    {
        // Dump our object - we never save it.
        m_lpApp->lCreateDoc(m_lpApp->m_hAppWnd, 0, 0, 0);
    }

    pDataXferObj->Release();    // this should destroy the DataXferObj
    return dwEffect;
}



//**********************************************************************
//
// CDropSource::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
//
//********************************************************************

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IDS::QueryInterface\r\n");

    // delegate to the document
    return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropSource::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleDoc. Since CDropSource is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for the CDropSource. We can safely use the reference count
//      of CSimpleDoc here.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::AddRef          DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
    TestDebugOut("In IDS::AddRef\r\n");

    // delegate to the document Object
    return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropSource::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleDoc. Since CDropSource is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for the CDropSource. We can safely use the reference count
//      of CSimpleDoc here.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Release         DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::Release()
{
    TestDebugOut("In IDS::Release\r\n");

    // delegate to the document object
    return m_pDoc->Release();
}
    	
//**********************************************************************
//
// CDropSource::QueryContinueDrag
//
// Purpose:
//
//      Called to determine if a drop should take place or be canceled.
//
// Parameters:
//
//      BOOL fEscapePressed - TRUE if ESCAPE key has been pressed
//      DWORD grfKeyState   - key state
//
// Return Value:
//
//      DRAGDROP_S_CANCEL   - drag operation should be canceled
//      DRAGDROP_S_DROP     - drop operation should be performed
//      S_OK                - dragging should continue
//
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CDropSource::QueryContinueDrag (
        BOOL    fEscapePressed,
        DWORD   grfKeyState
)
{
    if (fEscapePressed)
        return ResultFromScode(DRAGDROP_S_CANCEL);
    else
       if (!(grfKeyState & MK_LBUTTON))
          return ResultFromScode(DRAGDROP_S_DROP);
       else
          return NOERROR;
}

    	
//**********************************************************************
//
// CDropSource::GiveFeedback
//
// Purpose:
//
//      Called to set cursor feedback
//
// Parameters:
//
//      DWORD dwEffect      - drop operation to give feedback for
//
// Return Value:
//
//      DRAGDROP_S_USEDEFAULTCURSORS  - tells OLE to use standard cursors
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CDropSource::GiveFeedback (DWORD dwEffect)
{
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpdnd.h"
#include "resource.h"


extern "C" void TestDebugOut(LPSTR psz);

#ifndef WIN32
/* Since OLE is part of the operating system in Win32, we don't need to
 * check the version number in Win32.
 */
#include <ole2ver.h>
#endif  // WIN32

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPDND.RC
//
#define IDM_OPEN                        102
#define IDC_DRAGPENDING                 102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_SOURCE_COPY                 113
#define IDM_SOURCE_MOVE                 114
#define IDM_SOURCE_COPYMOVE             115
#define IDM_TARGET_COPY                 116
#define IDM_TARGET_MOVE                 117
#define IDM_TARGET_COPYMOVE             118

// Menu positions of source/target effects menus
#define SOURCE_EFFECTS_MENU_POS         0
#define TARGET_EFFECTS_MENU_POS         1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\tests.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	tests.h
//
//  Contents: 	Declarations for the unit test functions
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef __TESTS_H
#define __TESTS_H

void StartTest1(CSimpleApp *);
void StartTest2(CSimpleApp *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\simpdnd.h ===
//**********************************************************************
// File name: simpdnd.h
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#endif


BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef WIN32
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WPARAM wParam, LONG lParam);
#endif

#ifndef LATER
#define SZCLASSICONBOX "SimpDndIBClass"
#define SZCLASSRESULTIMAGE "SimpDndRIClass"
#endif


#ifdef WIN32

// Macro for TestDebugOut
#ifdef UNICODE
#undef TestDebugOut
#define TestDebugOut(A); TestDebugOutW(TEXT(A));
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      CSimpleSite::~CSimpleSite   SITE.CPP
//      CSimpleSite::AddRef         SITE.CPP
//      IStorage::CreateStorage     OLE API
//      assert                      C Runtime
//
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc)
{
    CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

    if (!lpTemp)
        return NULL;

    // create a sub-storage for the object
    HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( OLESTR("Object"),
                STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &lpTemp->m_lpObjStorage);

    assert(hErr == NOERROR);

    if (hErr != NOERROR)
    {
        delete lpTemp;
        return NULL;
    }

    // we will add one ref count on our Site. later when we want to destroy
    // the Site object we will release this  ref count. when the Site's ref
    // count goes to 0, it will be deleted.
    lpTemp->AddRef();

    return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
                                                   m_AdviseSink(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    // remember the pointer to the doc
    m_lpDoc = lpDoc;
    m_sizel.cx = 0;
    m_sizel.cy = 0;

    // clear the reference count
    m_nCount = 0;

	 m_dwDrawAspect = DVASPECT_CONTENT;
    m_lpOleObject  = NULL;
    m_fObjectOpen  = FALSE;
}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
    TestDebugOut ("In CSimpleSite's Destructor \r\n");

    if (m_lpOleObject)
       m_lpOleObject->Release();

    if (m_lpObjStorage)
       m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Close                       Object
//
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
    LPVIEWOBJECT lpViewObject = NULL;

    TestDebugOut ("In CSimpleSite::CloseOleObject \r\n");

    if (m_lpOleObject)
    {
       m_lpOleObject->Close(OLECLOSE_NOSAVE);
    }
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IOleObject::Release                     Object
//
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
    TestDebugOut ("In CSimpleSite::UnloadOleObject \r\n");

    if (m_lpOleObject)
    {
       LPVIEWOBJECT lpViewObject;
       CloseOleObject();    // ensure object is closed; NOP if already closed

       m_lpOleObject->QueryInterface(IID_IViewObject,
                                     (LPVOID FAR *)&lpViewObject);

       if (lpViewObject)
       {
           // Remove the view advise
           lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
           lpViewObject->Release();
       }

       m_lpOleObject->Release();
       m_lpOleObject = NULL;
   }
}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef         OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CSimpleSite::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    if ( IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IOleClientSite))
    {
        m_OleClientSite.AddRef();
        *ppvObj = &m_OleClientSite;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IAdviseSink))
    {
        m_AdviseSink.AddRef();
        *ppvObj = &m_AdviseSink;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
    TestDebugOut("In CSimpleSite::AddRef\r\n");

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
    TestDebugOut("In CSimpleSite::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject2::SetAdvise         Object
//      IViewObject2::Release           Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
//
//********************************************************************

HRESULT CSimpleSite::InitObject(BOOL fCreateNew)
{
    LPVIEWOBJECT2 lpViewObject2;
    RECT rect;
    HRESULT hRes;

    // Set a View Advise
    hRes = m_lpOleObject->QueryInterface(IID_IViewObject2,
                                  (LPVOID FAR *)&lpViewObject2);
    if (hRes == ResultFromScode(S_OK))
    {
       hRes = lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST,
                                &m_AdviseSink);

       if( FAILED(hRes))
       {
      		goto errRtn;
       }
       // get the initial size of the object

       hRes = lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/,
                                &m_sizel);

       //
       // Is OK if the object is actually blank
       //
       if( FAILED(hRes) && (hRes != OLE_E_BLANK) )
       {
       		goto errRtn;
       }

       lpViewObject2->Release();
    }
    GetObjRect(&rect);  // get the rectangle of the object in pixels

    // give the object the name of the container app/document
    hRes  = m_lpOleObject->SetHostNames(OLESTR("Simple Application"),
                                OLESTR("Simple OLE 2.0 Drag/Drop Container"));

    if( FAILED(hRes) )
    {
       goto errRtn;
    }

    // inform object handler/DLL object that it is used in the embedding
    // container's context
    if (OleSetContainedObject(m_lpOleObject, TRUE) != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleSetContainedObject\n");
    }

    if (fCreateNew)
    {
       // force new object to save to guarantee valid object in our storage.
       // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
       // object is created FROM FILE; its data in storage is already valid.
       m_OleClientSite.SaveObject();

       // we only want to DoVerb(SHOW) if this is an InsertNew object.
       // we should NOT DoVerb(SHOW) if the object is created FromFile.
       hRes = m_lpOleObject->DoVerb(
               OLEIVERB_SHOW,
               NULL,
               &m_OleClientSite,
               -1,
               m_lpDoc->m_hDocWnd,
               &rect);
    }

errRtn:
    return hRes;

}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      SetROP2                         Windows API
//      Rectangle                       Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OUTLUI Function
//      OleDraw                         OLE API
//      CSimpleSite::GetObjRect         SITE.CPP
//
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
    RECT rect;

    // need to check to make sure there is a valid object
    // available.  This is needed if there is a paint msg
    // between the time that CSimpleSite is instantiated
    // and OleUIInsertObject returns.
    if (!m_lpOleObject)
        return;

    // convert it to pixels
    GetObjRect(&rect);

    LPLOGPALETTE pColorSet = NULL;
    LPVIEWOBJECT lpView = NULL;

    // get a pointer to IViewObject
    m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

    // if the QI succeeds, get the LOGPALETTE for the object
    if (lpView)
        lpView->GetColorSet(m_dwDrawAspect, -1, NULL, NULL, NULL, &pColorSet);

    HPALETTE hPal=NULL;
    HPALETTE hOldPal=NULL;

    // if a LOGPALETTE was returned (not guarateed), create the palette and
    // realize it.  NOTE: A smarter application would want to get the LOGPALETTE
    // for each of its visible objects, and try to create a palette that
    // satisfies all of the visible objects.  ALSO: OleStdFree() is use to
    // free the returned LOGPALETTE.
    if ((pColorSet))
    {
        hPal = CreatePalette((const LPLOGPALETTE) pColorSet);
        hOldPal = SelectPalette(hDC, hPal, FALSE);
        RealizePalette(hDC);
        OleStdFree(pColorSet);
    }

    // draw the object
    HRESULT hRes;
    hRes = OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);
    if ((hRes != ResultFromScode(S_OK)) &&
        (hRes != ResultFromScode(OLE_E_BLANK)) &&
        (hRes != ResultFromScode(DV_E_NOIVIEWOBJECT)))
    {
        TestDebugOut("Fail in OleDraw\n");
    }

    // if the object is open, draw a hatch rect.
    if (m_fObjectOpen)
    {
        HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
        HBRUSH hOldBrush = (HBRUSH) SelectObject (hDC, hBrush);
        SetROP2(hDC, R2_MASKPEN);
        Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
        SelectObject(hDC, hOldBrush);
        DeleteObject(hBrush);
    }

    // if we created a palette, restore the old one, and destroy
    // the object.
    if (hPal)
    {
        SelectPalette(hDC,hOldPal,FALSE);
        DeleteObject(hPal);
    }

    // if a view pointer was successfully returned, it needs to be released.
    if (lpView)
        lpView->Release();
}

//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OLE2UI Function
//      XformHeightInHimetricToPixels   OLE2UI Function
//
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
    // convert it to pixels
    lpRect->left   = lpRect->top = 0;
    lpRect->right  = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
    lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of CSimpleSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <ole2.h> 
#include "ias.h"
#include "iocs.h"

class CSimpleDoc;

class CSimpleSite : public IUnknown
{
public:
    int m_nCount;
    LPOLEOBJECT m_lpOleObject;
    DWORD m_dwDrawAspect;
    SIZEL m_sizel;
    BOOL m_fObjectOpen;
    LPSTORAGE m_lpObjStorage;

    CAdviseSink m_AdviseSink;
    COleClientSite m_OleClientSite;
    
    CSimpleDoc FAR * m_lpDoc;
    
    // IUnknown Interfaces    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 
    
    HRESULT InitObject(BOOL fCreateNew);
    static CSimpleSite FAR * Create(CSimpleDoc FAR *lpDoc);
    CSimpleSite(CSimpleDoc FAR *lpDoc);
    ~CSimpleSite();          
    void PaintObj(HDC hDC);
    void GetObjRect(LPRECT lpRect);
    void CloseOleObject(void); 
    void UnloadOleObject(void);
};

#endif  // _SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\simpdnd.cpp ===
//**********************************************************************
// File name: Simple.cpp
//
//      Main source file for the Simple OLE 2.0 object container
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <stdlib.h>
#include <testmess.h>
#include "tests.h"


// This line is needed for the debug utilities in OLE2UI
extern "C" {
    OLEDBGDATA_MAIN(TEXT("SIMPDND"))
}

CSimpleApp FAR * lpCSimpleApp;
BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugStringA(psz);
    }
}

BOOL gfUseEmptyEnumerator;


//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam or FALSE if failure to initialize
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::CSimpleApp          APP.CPP
//      CSimpleApp::fInitApplication    APP.CPP
//      CSimpleApp::fInitInstance       APP.CPP
//      CSimpleApp::~CSimpleApp         APP.CPP
//      CSimpleApp::AddRef              APP.CPP
//      CSimpleApp::Release             APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      SetMessageQueue                 Windows API
//      MessageBox                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
//
//********************************************************************

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
    int nCmdShow)
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#endif
{
    MSG msg;
    LPSTR	pszTemp;
    fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

    if(fBeVerbose == 0)
    {
	fBeVerbose = GetProfileInt("OLEUTEST","simpdnd",0);
    }

    // needed for LRPC to work properly...
    SetMessageQueue(96);

    lpCSimpleApp = new CSimpleApp;


    if (!lpCSimpleApp)
    {
       /* memory allocation problem. We cannot carry on.
        */
       MessageBox(NULL, TEXT("Out of Memory"), TEXT("SimpDnD"),
                  MB_SYSTEMMODAL | MB_ICONHAND);
       return(FALSE);
    }

    // we will add one ref count on our App. later when we want to destroy
    // the App object we will release this  ref count. when the App's ref
    // count goes to 0, it will be deleted.
    lpCSimpleApp->AddRef();

    // process the command line

    if( (pszTemp = strstr(lpCmdLine, "-driver")) )
    {
    	//we were launched by the test driver
	lpCSimpleApp->m_hDriverWnd = (HWND)strtoul(pszTemp+8, NULL, 10);
    }

    // check for the -empty flag (use empty enumerator)
    if( strstr(lpCmdLine, "-empty") )
    {
	gfUseEmptyEnumerator = TRUE;
    }

    // app initialization
    if (!hPrevInstance)
        if (!lpCSimpleApp->fInitApplication(hInstance))
        {
            lpCSimpleApp->Release();
            return (FALSE);
        }

    // instance initialization
    if (!lpCSimpleApp->fInitInstance(hInstance, nCmdShow))
    {
        lpCSimpleApp->Release();
        return (FALSE);
    }

#if 0
    /* Initialization required for OLE 2 UI library.  This call is
    **    needed ONLY if we are using the static link version of the UI
    **    library. If we are using the DLL version, we should NOT call
    **    this function in our application.
    */

    if (!OleUIInitialize(hInstance, hPrevInstance, TEXT(SZCLASSICONBOX),
                         TEXT(SZCLASSRESULTIMAGE)))
    {
        OleDbgOut(TEXT("Could not initialize OLEUI library\n"));
        lpCSimpleApp->Release();
        return FALSE;
    }
#endif
    // message loop
    while (GetMessage(&msg, NULL, NULL, NULL))
        if (!lpCSimpleApp->HandleAccelerators(&msg))
        {
            TranslateMessage(&msg);    /* Translates virtual key codes */
            DispatchMessage(&msg);     /* Dispatches message to window */
        }

#if 0
    // De-initialization for UI libraries.  Just like OleUIInitialize, this
    // funciton is needed ONLY if we are using the static link version of the
    // OLE UI library.
    OleUIUninitialize();
#endif

    // Release the ref count added on the App above. this will make
    // the App's ref count go to 0, and the App object will be deleted.
    lpCSimpleApp->Release();

    return (msg.wParam);         /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      LRESULT
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::lCommandHandler     APP.CPP
//      CSimpleApp::DestroyDocs         APP.CPP
//      CSimpleApp::lCreateDoc          APP.CPP
//      CSimpleApp::lSizeHandler        APP.CPP
//      CSimpleDoc::lAddVerbs           DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//      DestroyWindow                   Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message,
                                   WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
    	case WM_TEST2:
	    StartTest2(lpCSimpleApp);
	    break;
    	case WM_TEST1:
	    StartTest1(lpCSimpleApp);
	    break;
        case WM_CLOSE:
            DestroyWindow(lpCSimpleApp->m_hAppWnd);
            break;

        case WM_COMMAND:           // message: command from application menu
            return lpCSimpleApp->lCommandHandler(hWnd, message, wParam,
                                                 lParam);
            break;

        case WM_CREATE:
#ifdef NOTREADY
            RemoveMenu(GetSubMenu(GetMenu(hWnd), 1), 0, MF_BYPOSITION);
#endif // NOTREADY
            return lpCSimpleApp->lCreateDoc(hWnd, message, wParam, lParam);
            break;

        case WM_DESTROY:                  // message: window being destroyed
            lpCSimpleApp->DestroyDocs();  // need to destroy the doc...
            PostQuitMessage(0);
            break;

        case WM_INITMENUPOPUP:
            // is this the edit menu?
            if ( LOWORD(lParam) == 1)
                return lpCSimpleApp->m_lpDoc->lAddVerbs();
            break;

        case WM_SIZE:
            return lpCSimpleApp->lSizeHandler(hWnd, message, wParam, lParam);

        default:                          // Passes it on if unproccessed
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
//
//********************************************************************
INT_PTR
#ifdef WIN32
	CALLBACK
#else
   FAR PASCAL EXPORT
#endif
   About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)

{
    switch (message)
    {
    case WM_INITDIALOG:              /* message: initialize dialog box */
       return (TRUE);

    case WM_COMMAND:                 /* message: received a command    */
        if (wParam == IDOK           /* "OK" box selected?             */
            || wParam == IDCANCEL)   /* System menu close command?     */
        {
           EndDialog(hDlg, TRUE);    /* Exits the dialog box           */
           return (TRUE);
        }
        break;
    }

    return (FALSE);                  /* Didn't process a message       */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                            Location
//
//      CSimpleApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::DoVerb                  Object
//      CSimpleSite::GetObjRect             SITE.CPP
//      CSimpleDoc::QueryDrag               DOC.CPP
//      CSimpleDoc::DoDragDrop              DOC.CPP
//      SetTimer                            Windows API
//      KillTimer                           Windows API
//      SetCapture                          Windows API
//      ReleaseCapture                      Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam,
                                  LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;

    switch (message)
    {
        case WM_PAINT:

            hDC = BeginPaint(hWnd, &ps);

            if (lpCSimpleApp)
                lpCSimpleApp->PaintApp (hDC);

            EndPaint(hWnd, &ps);
            break;

        case WM_LBUTTONDBLCLK:
        {
            POINT pt;

            pt.x = (int)(short)LOWORD (lParam );
            pt.y = (int)(short)HIWORD (lParam );

            if (lpCSimpleApp->m_lpDoc->m_lpSite &&
                lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject)
            {
                RECT rect;

                lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);

                if ( PtInRect(&rect, pt) )
                {
                    // Execute object's default verb
                    lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                            OLEIVERB_PRIMARY, (LPMSG)&message,
                            &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                            -1, hWnd, &rect);
                }
            }
            break;
        }

        case WM_LBUTTONDOWN:
        {
            POINT pt;

            pt.x = (int)(short)LOWORD (lParam );
            pt.y = (int)(short)HIWORD (lParam );

            /* OLE2NOTE: check if this is a button down on the region
            **    that is a handle to start a drag operation. for us,
            **    this this is any where in the window. we
            **    do NOT want to start a drag immediately; we want to
            **    wait until the mouse moves a certain threshold. or a
            **    certain amount of time has elapsed. if
            **    LButtonUp comes before the drag is started, then
            **    the fPendingDrag state is cleared. we must capture
            **    the mouse to ensure the modal state is handled
            **    properly.
            */
            if (lpCSimpleApp->m_lpDoc->QueryDrag(pt) )
            {
                lpCSimpleApp->m_lpDoc->m_fPendingDrag = TRUE;
                lpCSimpleApp->m_lpDoc->m_ptButDown = pt;
                SetTimer(hWnd, 1, lpCSimpleApp->m_nDragDelay, NULL);
                SetCapture(hWnd);
            }
            break;
        }

        case WM_LBUTTONUP:

            if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
            {
                /* ButtonUP came BEFORE distance/time threshholds were
                **    exceeded. clear fPendingDrag state.
                */
                ReleaseCapture();
                KillTimer(hWnd, 1);
                lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;
            }
            break;

        case WM_MOUSEMOVE:
        {
           if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
           {
            	int  x = (int)(short)LOWORD (lParam );
            	int  y = (int)(short)HIWORD (lParam );
            	POINT pt = lpCSimpleApp->m_lpDoc->m_ptButDown;
            	int nDragMinDist = lpCSimpleApp->m_nDragMinDist;
            	
               if (! ( ((pt.x - nDragMinDist) <= x)
                        && (x <= (pt.x + nDragMinDist))
                        && ((pt.y - nDragMinDist) <= y)
                        && (y <= (pt.y + nDragMinDist)) ) )
               {
                    // mouse moved beyond threshhold to start drag
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

                    // perform the modal drag/drop operation.
                    lpCSimpleApp->m_lpDoc->DoDragDrop( );
               }
           }
        	  break;
        }

        case WM_TIMER:
        {
            // drag time delay threshhold exceeded -- start drag
            ReleaseCapture();
            KillTimer(hWnd, 1);
            lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

            // perform the modal drag/drop operation.
            lpCSimpleApp->m_lpDoc->DoDragDrop( );
        	   break;
        }
	
    	  default:                       /* Passes it on if unproccessed */
        	   return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpdnd\tests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   	tests.cpp
//
//  Contents:	Implementations of the Upper Layer unit tests
//
//  Classes:
//
//  Functions: 	StartTest1
//
//  History:    dd-mmm-yy Author    Comment
//		07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

const CLSID CLSID_SimpleServer = {0xbcf6d4a0, 0xbe8c, 0x1068, { 0xb6, 0xd4,
	0x00, 0xdd, 0x01, 0x0c, 0x05, 0x09 }};

const CLSID CLSID_Paintbrush = {0x0003000a, 0, 0, { 0xc0, 0,0,0,0,0,0,0x46 }};

//+-------------------------------------------------------------------------
//
//  Function:	StartTest1
//
//  Synopsis:	Starts unit test1, inserting a simple server object into
//		this (simpdnd) container.
//
//  Effects:
//
//  Arguments:	pApp	-- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:    			
//
//  Modifies:
//			
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//     		07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest1( CSimpleApp *pApp )
{
	HRESULT hresult;
	static FORMATETC formatetc;

	//insert the simple server object

	formatetc.dwAspect = DVASPECT_CONTENT;
	formatetc.cfFormat = NULL;
	formatetc.lindex = -1;

	//need to create the client site

	pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

	hresult = OleCreate(CLSID_SimpleServer, IID_IOleObject,
		OLERENDER_DRAW, &formatetc,
		&pApp->m_lpDoc->m_lpSite->m_OleClientSite,
		pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
		(void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

	if( hresult != NOERROR )
	{
		goto errRtn;
	}

	//initialize the object
							
	hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

	if( hresult == NOERROR )
	{
		//tell it to paint itself, then we'll quit
		PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
		PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
		(LPARAM)hresult);
		PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
		return;
	}

errRtn:
	PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
		(LPARAM)hresult);
	PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
	return;
}


//+-------------------------------------------------------------------------
//
//  Function:	StartTest2
//
//  Synopsis:	Starts unit Test2, inserting a paintbrush object into
//		this (simpdnd) container.
//
//  Effects:
//
//  Arguments:	pApp	-- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:    			
//
//  Modifies:
//			
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//     		24-May-94 kevinro & alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest2( CSimpleApp *pApp )
{
	HRESULT hresult;
	static FORMATETC formatetc;

	//insert the simple server object

	formatetc.dwAspect = DVASPECT_CONTENT;
	formatetc.cfFormat = NULL;
	formatetc.lindex = -1;

	//need to create the client site

	pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

	hresult = OleCreate(CLSID_Paintbrush, IID_IOleObject,
		OLERENDER_DRAW, &formatetc,
		&pApp->m_lpDoc->m_lpSite->m_OleClientSite,
		pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
		(void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

	if( hresult != NOERROR )
	{
		goto errRtn;
	}

	//initialize the object
							
	hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

	//
	// The DDE layer is going to ignore all of the parameters except
	// the verb index. The parameters here are mostly dummies.
	//
	if (hresult == NOERROR)
	{
		hresult = pApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(0,
				NULL,
				&(pApp->m_lpDoc->m_lpSite->m_OleClientSite),
				-1,
				NULL,
				NULL);
	}

	if( hresult == NOERROR )
	{
		//tell it to paint itself, then we'll quit
		PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
		PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
		(LPARAM)hresult);
		PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
		return;
	}

errRtn:
	PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
		(LPARAM)hresult);
	PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"
#include <msgfiltr.h>

#include "initguid.h"
DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);

#ifdef WIN32
extern INT_PTR CALLBACK About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
#endif

//+-------------------------------------------------------------------------
//
//  Function:   SimpsvrMsgCallBack
//
//  Synopsis:   Tell Standard Message Filter not to toss windows messages
//
//  Arguments:  [pmsg] - first message in the queue
//
//  History:    dd-mmm-yy Author    Comment
//              19-May-94 ricksa    author
//
//--------------------------------------------------------------------------
BOOL CALLBACK SimpsvrMsgCallBack(MSG *pmsg)
{
    // We don't care about any of the in particular. We simply care that
    // our messages are not tossed not matter what.
    return TRUE;
}

//**********************************************************************
//
// CSimpSvrApp::CSimpSvrApp()
//
// Purpose:
//
//      Constructor for CSimpSvrApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//
//********************************************************************

CSimpSvrApp::CSimpSvrApp()
{
    TestDebugOut(TEXT("In CSimpSvrApp's Constructor \r\n"));

    // Set Ref Count
    m_nCount = 0;

    // clear members
    m_hAppWnd = NULL;
    m_hInst = NULL;
    m_lpDoc = NULL;

    // clear flags
    m_fInitialized = FALSE;

    // used for inplace
    SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpSvrApp::~CSimpSvrApp()
//
// Purpose:
//
//      Destructor for CSimpSvrApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::IsInitialized  APP.H
//      OleUninitialize             OLE API
//
//********************************************************************

CSimpSvrApp::~CSimpSvrApp()
{
    TestDebugOut(TEXT("In CSimpSvrApp's Destructor\r\n"));

    /* The Simple Server is structured so that SimpSvrApp is ALWAYS the
     * last one to be released, after all the SimpSvrDoc and SimpSvrObj are
     * released. So, we don't need to do any clean up to the SimpSvrDoc
     * and SimpSvrObj objects.
     */

    // Revoke our message filter as the last step.
    CoRegisterMessageFilter(NULL, NULL);

    // need to uninit the library...
    if (IsInitialized())
        OleUninitialize();

    DestroyWindow(m_hAppWnd);
}


//**********************************************************************
//
// CSimpSvrApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at Application Level
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            APP.CPP
//
//
//
//********************************************************************

STDMETHODIMP CSimpSvrApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpSvrApp::QueryInterface\r\n"));

    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = this;
    else
        {
        *ppvObj = NULL;
        sc = E_NOINTERFACE;
        }

    if (*ppvObj)
        ((LPUNKNOWN)*ppvObj)->AddRef();

    // asking for something we don't understand at this level.
    return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::AddRef()
{
    TestDebugOut(TEXT("In CSimpSvrApp::AddRef\r\n"));
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::Release()
{
    TestDebugOut(TEXT("In CSimpSvrApp::Release\r\n"));

    if (--m_nCount==0)
    {
        delete this;
        return(0);
    }

    return m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//      RegisterHatchWindowClass    OUTLUI.DLL
//
//
//********************************************************************

BOOL CSimpSvrApp::fInitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style = NULL;                    // Class style(s).
    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns the class.
    wc.hIcon = LoadIcon((HINSTANCE) hInstance, TEXT("SimpSvr"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);

    wc.lpszMenuName =  TEXT("SimpSvrMENU");    // Name of menu resource in .RC file.
    wc.lpszClassName = TEXT("SimpSvrWClass");  // Name used in call to CreateWindow.

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style = CS_VREDRAW | CS_HREDRAW;                    // Class style(s).
    wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns the class.
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;

    wc.lpszClassName = TEXT("DocWClass");     // Name used in call to CreateWindow.

    // Register the window class and return success/failure code.

    if (!RegisterClass(&wc))
        return FALSE;

    return (RegisterHatchWindowClass((HINSTANCE) hInstance));
}

//**********************************************************************
//
// CSimpSvrApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      InvalidateRect              Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CoRegisterClassObject       OLE API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpSvrApp::fInitInstance (HANDLE hInstance, int nCmdShow,
                                 CClassFactory FAR * lpClassFactory)
{
    m_hInst = (HINSTANCE) hInstance;

#ifndef WIN32
   /* Since OLE is part of the operating system in Win32, we don't need to
    * check the version number in Win32.
    */
    DWORD dwVer = OleBuildVersion();

    // check to see if we are compatible with this version of the libraries
    if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
    {
#ifdef _DEBUG
        TestDebugOut("WARNING: Incompatible OLE library version\r\n");
#else
        return FALSE;
#endif
    }

#endif // WIN32

    // initialize the libraries
    if (OleInitialize(NULL) == NOERROR)
        m_fInitialized = TRUE;

    // Load our accelerators
    if ((m_hAccel = LoadAccelerators(m_hInst, TEXT("SimpsvrAccel"))) == NULL)
    {
        // Load failed so abort
        TestDebugOut(TEXT("ERROR: Accelerator Table Load FAILED\r\n"));
        return FALSE;
    }


    // Create the "application" windows
    m_hAppWnd = CreateWindow (TEXT("SimpSvrWClass"),
                              TEXT("Simple OLE 2.0 Server"),
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              NULL,
                              (HINSTANCE) hInstance,
                              NULL);

    if (!m_hAppWnd)
        return FALSE;

    // Because there default call control behavior tosses messages
    // which cause intermittent failures of the test, we install a
    // message filter to get around the problem.
    IMessageFilter *pmf = OleStdMsgFilter_Create(m_hAppWnd,
        TEXT("Simple OLE 2.0 Server"), SimpsvrMsgCallBack, NULL);

    if (pmf == NULL)
    {
        // this call failed so we are hosed. So fail the whole thing
        TestDebugOut(
            TEXT("CSimpSvrApp::fInitInstance OleStdMsgFilter_Create fails\n"));
        return FALSE;
    }

    HRESULT hr = CoRegisterMessageFilter(pmf, NULL);

    if (FAILED(hr))
    {
        // this call failed so we are hosed. So fail the whole thing
        TestDebugOut(
            TEXT("CSimpSvrApp::fInitInstance CoRegisterMessageFilter fails\n"));
        return FALSE;
    }

    // The message filter keeps a reference to this object so we don't have
    // to remember anything about it -- except of course to deregister it.
    pmf->Release();

    // if not started by OLE, then show the Window, and create a "fake" object, else
    // Register a pointer to IClassFactory so that OLE can instruct us to make an
    // object at the appropriate time.
    if (!m_fStartByOle)
        {
        ShowAppWnd(nCmdShow);
        m_lpDoc->CreateObject(IID_IOleObject, (LPVOID FAR *)&m_OleObject);
        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
        }
    else
        {
        lpClassFactory = new CClassFactory(this);

        if (!lpClassFactory)
        {
           /* Memory allocation fails
            */
           return(FALSE);
        }

        // shouldn't pass an API an object with a zero ref count
        lpClassFactory->AddRef();

        if (
            CoRegisterClassObject(GUID_SIMPLE,
                                  (IUnknown FAR *)lpClassFactory,
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_SINGLEUSE,
                                  &m_dwRegisterClass) != S_OK
           )
           TestDebugOut(TEXT("CSimpSvrApp::fInitInstance \
                                   CoRegisterClassObject fails\n"));

        // remove artificial Ref. count
        lpClassFactory->Release();
        }

    return m_fInitialized;
}


//+-------------------------------------------------------------------------
//
//  Member:     CSimpSvrApp::HandleDrawItem (public)
//
//  Synopsis:   Handles the Draw Item message for the owner draw menu for color
//
//  Arguments:	[lpdis]	-- pointer to draw item structure
//
//  Algorithm:  If the request is to draw the item, we create a solid brush
//              based on the color for the menu. Make a copy of the rectangle
//              input. Finally, we shrink the rectangle in size and then fill
//              it with the color.
//
//  History:    dd-mmm-yy Author    Comment
//              02-May-94 ricksa    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void CSimpSvrApp::HandleDrawItem(LPDRAWITEMSTRUCT lpdis)
{
    HBRUSH hbr;
    RECT rc;

    if (lpdis->itemAction == ODA_DRAWENTIRE)
    {
        // Paint the color item in the color requested.
        hbr = CreateSolidBrush(lpdis->itemData);
        CopyRect((LPRECT)&rc, (LPRECT)&lpdis->rcItem);
        InflateRect((LPRECT)&rc, -10, -10);
        FillRect(lpdis->hDC, &rc, hbr);
        DeleteObject(hbr);
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CSimpSvrApp::HandleChangeColors (public)
//
//  Synopsis:   Handles change between owner draw and regular menu
//
//  Algorithm:  Reset the checked state of the menu item. If it is an owner
//              draw menu requested, then we reset all the menu items to that.
//              Otherwise, we set it to the reqular menu items.
//
//  History:    dd-mmm-yy Author    Comment
//              02-May-94 ricksa    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void CSimpSvrApp::HandleChangeColors(void)
{
    // Get a handle to the Colors menu
    HMENU hMenu = m_lpDoc->GetColorMenu();

    // Get the current state of the item
    BOOL fOwnerDraw = GetMenuState(hMenu, IDM_COLOROWNERDR, MF_BYCOMMAND)
        & MF_CHECKED;

    // Toggle the state of the item.
    CheckMenuItem(hMenu, IDM_COLOROWNERDR,
        MF_BYCOMMAND | (fOwnerDraw ? MF_UNCHECKED : MF_CHECKED));

    if (!fOwnerDraw)
    {
        // Change the items to owner-draw items. Pass the RGB value for the
        // color as the application-supplied data. This makes it easier for
        // us to draw the items.
        ModifyMenu(hMenu, IDM_RED, MF_OWNERDRAW | MF_BYCOMMAND, IDM_RED,
            (LPSTR) RGB (255,0,0));
        ModifyMenu(hMenu, IDM_GREEN, MF_OWNERDRAW | MF_BYCOMMAND, IDM_GREEN,
             (LPSTR)RGB (0,255,0));
        ModifyMenu(hMenu, IDM_BLUE, MF_OWNERDRAW | MF_BYCOMMAND, IDM_BLUE,
             (LPSTR)RGB (0,0,255));
    }
    else
    {
        // Change the items to normal text items. */
        ModifyMenu(hMenu, IDM_RED, MF_BYCOMMAND, IDM_RED, "Red");
        ModifyMenu(hMenu, IDM_GREEN, MF_BYCOMMAND, IDM_GREEN, "Green");
        ModifyMenu(hMenu, IDM_BLUE, MF_BYCOMMAND, IDM_BLUE, "Blue");
    }
}


//**********************************************************************
//
// CSimpSvrApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      InvalidateRect                              Windows API
//      CSimpSvrDoc::InsertObject                   DOC.CPP
//      CSimpSvrObj::SetColor                       OBJ.CPP
//      CSimpSvrObj::RotateColor                    OBJ.CPP
//
//
//********************************************************************

LRESULT CSimpSvrApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    // In Win32, the upper word of wParam is the notify code. Since we
    // don't care about this code, we dump it.
    wParam = LOWORD(wParam);

    switch (wParam) {
        // bring up the About box
        case IDM_ABOUT:
            {
#ifdef WIN32
                  DialogBox(m_hInst,               // current instance
                          TEXT("AboutBox"),                  // resource to use
                          m_hAppWnd,                   // parent handle
                          About);                      // About() instance address
#else
                  FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

                  DialogBox(m_hInst,               // current instance
                          TEXT("AboutBox"),                  // resource to use
                          m_hAppWnd,                   // parent handle
                          lpProcAbout);                // About() instance address

                  FreeProcInstance(lpProcAbout);
#endif  // WIN32

            break;
            }

        // exit the application
        case IDM_EXIT:
            SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
            break;

        case IDM_RED:
            m_lpDoc->GetObj()->SetColor (128, 0, 0);
            InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
            break;

        case IDM_GREEN:
            m_lpDoc->GetObj()->SetColor (0,128, 0);
            InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
            break;

        case IDM_BLUE:
            m_lpDoc->GetObj()->SetColor (0, 0, 128);
            InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
            break;

        case IDM_COLOROWNERDR:
            HandleChangeColors();
            break;

        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
           }   // end of switch
    return NULL;
}

//**********************************************************************
//
// CSimpSvrApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::lResizeDoc      DOC.CPP
//
//
//********************************************************************

long CSimpSvrApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    GetClientRect(m_hAppWnd, &rect);
    return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpSvrApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::Create         DOC.CPP
//
//
//********************************************************************

long CSimpSvrApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    GetClientRect(hWnd, &rect);

    m_lpDoc = CSimpSvrDoc::Create(this, &rect, hWnd);

    return NULL;
}



//**********************************************************************
//
// CSimpSvrApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::PaintDoc        DOC.CPP
//
//
//
//********************************************************************

void CSimpSvrApp::PaintApp (HDC hDC)
{

    // if we supported multiple documents, we would enumerate
    // through each of the open documents and call paint.

    if (m_lpDoc)
        m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpSvrApp::ParseCmdLine
//
// Purpose:
//
//      Determines if the app was started by OLE
//
//
// Parameters:
//
//      LPSTR lpCmdLine -   Pointer to the command line
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      lstrlen                     Windows API
//      lstrcmp                     Windows API
//
//
// Comments:
//
//      Parses the command line looking for the -Embedding or /Embedding
//      flag.
//
//********************************************************************

void CSimpSvrApp::ParseCmdLine(LPSTR lpCmdLine)
{
    CHAR szTemp[255];

    m_fStartByOle = TRUE;

    ::ParseCmdLine (lpCmdLine, &m_fStartByOle, szTemp);

}

//**********************************************************************
//
// CSimpSvrApp::SetStatusText
//
// Purpose:
//
//      Blanks out the text in the status bar
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::SetStatusText  DOC.CPP
//
//
//********************************************************************

void CSimpSvrApp::SetStatusText()
{
    m_lpDoc->SetStatusText();
}


//**********************************************************************
//
// CSimpSvrApp::IsInPlaceActive
//
// Purpose:
//
//      Safely determines from the app level if currently inplace active.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      TRUE    - Inplace active
//      FALSE   - Not Inplace active
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::GetObject      DOC.H
//      CSimpSvrObj:IsInPlaceActive OBJ.H
//
//
//********************************************************************

BOOL CSimpSvrApp::IsInPlaceActive()
{
    BOOL retval = FALSE;

    if (m_lpDoc)
        if (m_lpDoc->GetObj())
            retval = m_lpDoc->GetObj()->IsInPlaceActive();

    return retval;
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Shows the Application Window
//
// Parameters:
//
//      int nCmdShow    - Window State
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      CoLockObjectExternal            OLE API
//
//********************************************************************

void CSimpSvrApp::ShowAppWnd(int nCmdShow)
{
    if (CoLockObjectExternal(this, TRUE, FALSE) != S_OK)
       TestDebugOut(TEXT("CSimpSvrApp::ShowAppWnd  \
                               CoLockObjectExternal fails\n"));
    ShowWindow (m_hAppWnd, nCmdShow);
    UpdateWindow (m_hAppWnd);
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Hides the Application Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      CoLockObjectExternal            OLE API
//
//********************************************************************

void CSimpSvrApp::HideAppWnd()
{
    if (CoLockObjectExternal(this, FALSE, TRUE) != S_OK)
       TestDebugOut(TEXT("CSimpSvrApp::HideAppWnd  \
                               CoLockObjectExternal fails\n"));
    ShowWindow (m_hAppWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpSvrDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrDoc::Create
//
// Purpose:
//
//      Creation for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CSimpSvrDoc::CSimpSvrDoc    DOC.CPP
//      CreateHatchWindow           OLE2UI
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpSvrDoc FAR * CSimpSvrDoc::Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd)
{
    CSimpSvrDoc FAR * lpTemp = new CSimpSvrDoc(lpApp, hWnd);

    if (!lpTemp)
        return NULL;

    // create the document Window
    lpTemp->m_hDocWnd = CreateWindow(
            TEXT("DocWClass"),
            NULL,
            WS_CHILD | WS_CLIPSIBLINGS,
            lpRect->left,
            lpRect->top,
            lpRect->right,
            lpRect->bottom,
            hWnd,
            NULL,
            lpApp->GethInst(),
            NULL);

    if (!lpTemp->m_hDocWnd)
        goto error;

    lpTemp->ShowDocWnd();

    lpTemp->m_hHatchWnd = CreateHatchWindow( lpTemp->m_hDocWnd, lpApp->GethInst());

    lpTemp->HideHatchWnd();

    return (lpTemp);

error:
    delete (lpTemp);
    return NULL;

}

//**********************************************************************
//
// CSimpSvrDoc::CSimpSvrDoc
//
// Purpose:
//
//      Constructor for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::CSimpSvrDoc(CSimpSvrApp FAR * lpApp,HWND hWnd)
{
    TestDebugOut(TEXT("In CSimpSvrDoc's Constructor\r\n"));
    m_lpApp = lpApp;
    m_nCount = 0;
    m_lpObj = NULL;

    // set up menu handles
    m_hMainMenu = GetMenu(hWnd);
    m_hColorMenu = GetSubMenu(m_hMainMenu, 1);
    m_hHelpMenu = GetSubMenu(m_hMainMenu, 2);


}

//**********************************************************************
//
// CSimpSvrDoc::~CSimpSvrDoc
//
// Purpose:
//
//      Destructor for CSimpSvrDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::ClearDoc       APP.CPP
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::~CSimpSvrDoc()
{
    TestDebugOut(TEXT("In CSimpSvrDoc's Destructor\r\n"));

    // Clear the Doc object pointer so that the SimpSvrApp won't be able
    // to access invalid objects. (same for the SimpSvrObj)
    if (m_lpApp)
       m_lpApp->ClearDoc();

    if (m_lpObj)
       m_lpObj->ClearDoc();

    DestroyWindow(m_hHatchWnd);
    DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpSvrDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      E_NOINTERFACE -   Always
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::QueryInterface APP.CPP
//
// Comments:
//
//      Since the document could contain multiple objects, all
//      interfaces except those associated with the document should
//      be returned.  In this implementation, there are no doc level
//      interfaces.
//
//********************************************************************

STDMETHODIMP CSimpSvrDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpSvrDoc::QueryInterface\r\n"));

    SCODE sc = E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IUnknown))
       {
       AddRef();
       *ppvObj = this;
       sc = S_OK;
       }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::AddRef
//
// Purpose:
//
//      Increments the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::AddRef         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::AddRef()
{
    TestDebugOut(TEXT("In CSimpSvrDoc::AddRef\r\n"));
    // AddRef the app, but return the doc count
    m_lpApp->AddRef();

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::Release
//
// Purpose:
//
//      Decrements the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::Release         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::Release()
{
    TestDebugOut(TEXT("In CSimpSvrDoc::Release\r\n"));
    // Release the app, but return the app count
    m_lpApp->Release();

    if (--m_nCount== 0)
    {
        delete this;
        return(0);
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
//
//********************************************************************

long CSimpSvrDoc::lResizeDoc(LPRECT lpRect)
{
    MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, TRUE);
    return NULL;
}


//**********************************************************************
//
// CSimpSvrDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::Draw                   OBJ.CPP
//      CSimpSvrObj::GetDataAdviseHolder    OBJ.H
//      CSimpSvrObj::GetDataObject          OBJ.H
//      CSimpAppObj::IsStartedByOle         APP.CPP
//      IDataAdviseHolder::SendOnDataChange OLE API
//
//
//********************************************************************

void CSimpSvrDoc::PaintDoc (HDC hDC)
{

    // if the object hasn't been created yet, then don't draw
    if (m_lpObj)
        m_lpObj->Draw(hDC,FALSE);
    else
        return;

    // Sending a data change every time we paint, but only if we
    // were started by OLE
    if (m_lpApp->IsStartedByOle())
            m_lpObj->SendOnDataChange( );
}



//**********************************************************************
//
// CSimpSvrDoc::CreateObject
//
// Purpose:
//      Handles the creation of a SimpSvrObj.
//
// Parameters:
//
//
// Return Value:
//
//      S_OK if the function succeeds, otherwise E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::CSimpSvrObj    OBJ.CPP
//      CSimpSvrOjb::QueryInterface OBJ.CPP
//
//
//********************************************************************

HRESULT CSimpSvrDoc::CreateObject(REFIID riid, LPVOID FAR *ppvObject)
{
    SCODE sc = E_FAIL;

    m_lpObj = new CSimpSvrObj(this);

    if (m_lpObj)
        {
        m_lpObj->QueryInterface(riid, ppvObject);
        sc = S_OK;
        }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::Close
//
// Purpose:
//
//      Closes the object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpSvrObj::AddRef                     OBJ.CPP
//      CSimpSvrObj::Release                    OBJ.CPP
//      CSimpSvrObj::IsInPlaceActive            OBJ.H
//      CSimpSvrObj::GetOleInPlaceObject        OBJ.H
//      CSimpSvrObj::ClearOleClientSite         OBJ.H
//      CSimpSvrObj::GetDataAdviseHolder        OBJ.H
//      CSimpSvrObj::GetOleClientSite           OBJ.H
//      CSimpSvrObj::ClearDataAdviseHolder      OBJ.H
//      CSimpSvrObj::GetOleAdviseHolder         OBJ.H
//      CSimpSvrObj::ClearOleAdviseHolder       OBJ.H
//      IOleInPlaceObject::InPlaceDeactivate    Container
//      IOleClientSite::SaveObject              Container
//      IOleClientSite::OnShowWindow            Container
//      IOleClientSite::Release                 Container
//      IDataAdviseHolder::SendOnDataChange     OLE
//      IDataAdviseHolder::Release              OLE
//      IOleAdviseHolder::SendOnClose           OLE
//      IOleAdviseHolder::Release               OLE
//
//
//********************************************************************

void CSimpSvrDoc::Close()
{
    TestDebugOut(TEXT("In CSimpSvrDoc::Close() \r\n"));

    m_lpObj->AddRef(); // hold object alive

    // if the object is currently inplace active, then deactivate
    if (m_lpObj->IsInPlaceActive())
        m_lpObj->GetOleInPlaceObject()->InPlaceDeactivate();

    // unregister from the ROT...
    if (m_lpObj->GetRotRegister())
        {
        LPRUNNINGOBJECTTABLE lpRot;

        if (GetRunningObjectTable (0, &lpRot) == NOERROR )
            {
            lpRot->Revoke(m_lpObj->GetRotRegister());
            lpRot->Release();
            }
        }

    // if we have a clientsite, instruct it to save the object
    if (m_lpObj->GetOleClientSite())
        {
        m_lpObj->GetOleClientSite()->SaveObject();
        m_lpObj->GetOleClientSite()->OnShowWindow(FALSE);
        }

    // Do a final SendOnDataChange for those containers that have specified the
    // ADF_DATAONSTOP flag.
    if (m_lpObj->GetDataAdviseHolder())
        {
        m_lpObj->GetDataAdviseHolder()->SendOnDataChange( m_lpObj->GetDataObject(), 0, ADVF_DATAONSTOP);
        }


    // Tell the container that we are shutting down.
    if (m_lpObj->GetOleAdviseHolder())
        {
        m_lpObj->GetOleAdviseHolder()->SendOnClose();
        }

    // release our streams and storage
    m_lpObj->GetPersistStorage()->ReleaseStreamsAndStorage();

    // Disconnect the object.  NOTE: This call should not do anything
    // unless the container has cause a GP Fault or some other problem
    // has occured...
    TestDebugOut(TEXT("*** Before CoDisconnectObject *** \r\n"));

    CoDisconnectObject((LPUNKNOWN)m_lpObj, 0);

    TestDebugOut(TEXT("*** After CoDisconnectObject *** \r\n"));

    m_lpObj->Release(); // let object close

}


//**********************************************************************
//
// CSimpSvrDoc::SetStatusText
//
// Purpose:
//
//      Sets the Container's status bar text
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrObj::IsInPlaceActive    OBJ.CPP
//      IOleInPlaceFrame::SetStatusText Container
//
// Comments:
//
//      Even though there is no status line in this sample, this
//      method must be called on WM_MENUSELECT to clear the last
//      message in the status line.
//
//********************************************************************

void CSimpSvrDoc::SetStatusText()
{
    if (m_lpObj->IsInPlaceActive())
        m_lpObj->GetInPlaceFrame()->SetStatusText(OLESTR("\0"));

}

//**********************************************************************
//
// CSimpSvrDoc::ShowDocWnd
//
// Purpose:
//
//      Shows the Document Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowDocWnd()
{
    ShowWindow(m_hDocWnd, SW_SHOWNORMAL);  // Show the window
    UpdateWindow(m_hDocWnd);               // Sends WM_PAINT message
}

//**********************************************************************
//
// CSimpSvrDoc::ShowHatchWnd
//
// Purpose:
//
//      Shows the hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowHatchWnd()
{
    ShowWindow(m_hHatchWnd, SW_SHOW);
}

//**********************************************************************
//
// CSimpSvrDoc::HideDocWnd
//
// Purpose:
//
//      Hides the DocumentWindow
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideDocWnd()
{
    ShowWindow(m_hDocWnd, SW_HIDE);
}

//**********************************************************************
//
// CSimpSvrDoc::HideHatchWnd
//
// Purpose:
//
//      Hides the Hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideHatchWnd()
{
    ShowWindow(m_hHatchWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpSvrDoc
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

class CSimpSvrApp;
class CSimpSvrObj;

class CSimpSvrDoc : IUnknown
{
private:
    int m_nCount;

    CSimpSvrApp FAR * m_lpApp;
    CSimpSvrObj FAR * m_lpObj;
    HMENU m_hMainMenu;
    HMENU m_hColorMenu;
    HMENU m_hHelpMenu;

    HWND m_hDocWnd;
    HWND m_hHatchWnd;

public:
    static CSimpSvrDoc FAR * Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd);

    CSimpSvrDoc();
    CSimpSvrDoc(CSimpSvrApp FAR *lpApp, HWND hWnd);
    ~CSimpSvrDoc();

// IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    long lResizeDoc(LPRECT lpRect);
    long lAddVerbs();

    BOOL Load(LPTSTR lpszFileName);
    void PaintDoc(HDC hDC);
    void lButtonDown(WPARAM wParam,LPARAM lParam);

    HRESULT CreateObject(REFIID riid, LPVOID FAR *ppvObject);

    void Close();
    void SetStatusText();
    void ShowDocWnd();
    void ShowHatchWnd();
    void CSimpSvrDoc::HideDocWnd();
    void CSimpSvrDoc::HideHatchWnd();

// member access
    inline HMENU GetMainMenu() { return m_hMainMenu; };
    inline HMENU GetColorMenu() { return m_hColorMenu; };
    inline HMENU GetHelpMenu() { return m_hHelpMenu; } ;
    inline HWND GethDocWnd() { return m_hDocWnd; };
    inline HWND GethHatchWnd() { return m_hHatchWnd; };
    inline HWND GethAppWnd() { return m_lpApp->GethAppWnd(); };
    inline CSimpSvrApp FAR * GetApp() { return m_lpApp; };
    inline CSimpSvrObj FAR * GetObj() { return m_lpObj; };
    inline void ClearObj() { m_lpObj = NULL; };

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpSvrApp
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

class CSimpSvrDoc;
interface CClassFactory;

class CSimpSvrApp : public IUnknown
{
private:

    int m_nCount;               // reference count

    HINSTANCE m_hInst;          // application instance
    BOOL m_fStartByOle;         // TRUE if app started by OLE
    DWORD m_dwRegisterClass;    // returned by RegisterClassFactory

    LPOLEOBJECT m_OleObject;    // pointer to "dummy" object


    CSimpSvrDoc FAR * m_lpDoc;   // pointer to document object
    BOOL m_fInitialized;         // OLE initialization flag

    RECT nullRect;               // used in inplace negotiation

    // Convert to/from owner draw menus
    void HandleChangeColors(void);


public:

    HWND m_hAppWnd;             // main window handle

    HACCEL m_hAccel;            // Accelerators


    // IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Initialization methods

    CSimpSvrApp();           // Constructor
    ~CSimpSvrApp();          // Destructor


    BOOL fInitApplication (HANDLE hInstance);
    BOOL fInitInstance (HANDLE hInstance, int nCmdShow, CClassFactory FAR * lpClassFactory);

    // Message handling methods

    LRESULT lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    void PaintApp(HDC hDC);
    void HandleDrawItem(LPDRAWITEMSTRUCT lpdis);

    //  Utility functions
    void ParseCmdLine(LPSTR lpCmdLine);
    void SetStatusText();
    BOOL IsInPlaceActive();
    void ShowAppWnd(int nCmdShow=SW_SHOWNORMAL);
    void HideAppWnd();


    // member variable access
    inline HWND GethAppWnd() { return m_hAppWnd; };
    inline HINSTANCE GethInst() { return m_hInst; };
    inline BOOL IsStartedByOle() { return m_fStartByOle; };
    inline BOOL IsInitialized() { return m_fInitialized; };
    inline DWORD GetRegisterClass() { return m_dwRegisterClass; };
    inline CSimpSvrDoc FAR * GetDoc() { return m_lpDoc; };
    inline void ClearDoc() { m_lpDoc = NULL; };
    inline LPOLEOBJECT GetOleObject() { return m_OleObject; };

    friend interface CClassFactory;  // make the contained class a friend
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\icf.h ===
//**********************************************************************
// File name: icf.h
//
//      Definition of CClassFactory
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _ICF_H_)
#define _ICF_H_

class CSimpSvrApp;

interface CClassFactory :  IClassFactory
{
private:
    int m_nCount;               // reference count
    CSimpSvrApp FAR * m_lpApp;

public:
    CClassFactory::CClassFactory(CSimpSvrApp FAR * lpApp)
        {
        TestDebugOut(TEXT("In CClassFactory's Constructor\r\n"));
        m_lpApp = lpApp;
        m_nCount = 0;
        };
    CClassFactory::~CClassFactory()
       {
       TestDebugOut(TEXT("In CClassFactory's Destructor\r\n"));
       };

    // IUnknown Methods

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP CreateInstance (LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject);
    STDMETHODIMP LockServer ( BOOL fLock);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\icf.cpp ===
//**********************************************************************
// File name: ICF.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See icf.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

//**********************************************************************
//
// CClassFactory::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CClassFactory::AddRef       ICF.CPP
//
//********************************************************************

STDMETHODIMP CClassFactory::QueryInterface  ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CClassFactory::QueryInterface\r\n"));

    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
         IsEqualIID(riid, IID_IClassFactory) )
        *ppvObj = this;
    else
        {
        *ppvObj = NULL;
        sc = E_NOINTERFACE;
        }

    if (*ppvObj)
        ((LPUNKNOWN)*ppvObj)->AddRef();

    // pass it on to the Application object
    return ResultFromScode(sc);
}

//**********************************************************************
//
// CClassFactory::AddRef
//
// Purpose:
//
//      Increments the reference count on CClassFactory and the application
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on CClassFactory
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::AddRef ()
{
    TestDebugOut(TEXT("In CClassFactory::AddRef\r\n"));

    return ++m_nCount;
}

//**********************************************************************
//
// CClassFactory::Release
//
// Purpose:
//
//      Decrements the reference count of CClassFactory and the
//      application object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::Release ()
{
    TestDebugOut(TEXT("In CClassFactory::Release\r\n"));

    if (--m_nCount== 0)
    {
        delete this;
        return(0);
    }
    return m_nCount;
}


//**********************************************************************
//
// CClassFactory::CreateInstance
//
// Purpose:
//
//      Instantiates a new OLE object
//
// Parameters:
//
//      LPUNKNOWN pUnkOuter     - Pointer to the controlling unknown
//
//      REFIID riid             - The interface type to fill in ppvObject
//
//      LPVOID FAR* ppvObject   - Out pointer for the object
//
// Return Value:
//
//      S_OK                    - Creation was successful
//      CLASS_E_NOAGGREGATION   - Tried to be created as part of an aggregate
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
//********************************************************************

STDMETHODIMP CClassFactory::CreateInstance ( LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject)
{
    HRESULT hErr;

    TestDebugOut(TEXT("In CClassFactory::CreateInstance\r\n"));

    // need to NULL the out parameter
    *ppvObject = NULL;

    // we don't support aggregation...
    if (pUnkOuter)
        {
        hErr = ResultFromScode(CLASS_E_NOAGGREGATION);
        goto error;
        }

    hErr = m_lpApp->m_lpDoc->CreateObject(riid, ppvObject);

error:
    return hErr;
}

//**********************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//      To lock the server and keep an open object application in memory
//
// Parameters:
//
//      BOOL fLock      - TRUE to lock the server, FALSE to unlock it
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoLockObjectExternal        OLE API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CClassFactory::LockServer ( BOOL fLock)
{
    HRESULT hRes;

    TestDebugOut(TEXT("In CClassFactory::LockServer\r\n"));

    if ((hRes=CoLockObjectExternal(m_lpApp, fLock, TRUE)) != S_OK)
    {
       TestDebugOut(TEXT("CClassFactory::LockServer   \
                               CoLockObjectExternal fails\n"));
       return(hRes);
    }

    return ResultFromScode( S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ido.cpp ===
//**********************************************************************
// File name: IDO.CPP
//
//    Implementation file for the CDataObject Class
//
// Functions:
//
//    See ido.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ido.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CDataObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//********************************************************************


STDMETHODIMP CDataObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CDataObject::QueryInterface\r\n"));

    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CDataObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. CDataObject is
//      a nested class of CSimpSvrObj, so we don't need a separate
//      reference count for CDataObject. We can just use the reference
//      count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new Reference count on CSimpSvrObject
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataObject::AddRef ()
{
    TestDebugOut(TEXT("In CDataObject::AddRef\r\n"));

    return( m_lpObj->AddRef() );
}

//**********************************************************************
//
// CDataObject::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. CDataObject is
//      a nested class of CSimpSvrObj, so we don't need a separate
//      reference count for CDataObject. We can just use the reference
//      count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of the CSimpSvrObj.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataObject::Release ()
{
    TestDebugOut(TEXT("In CDataObject::Release\r\n"));

    return( m_lpObj->Release() );
}

//**********************************************************************
//
// CDataObject::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DATA_E_FORMATETC    - The FORMATETC is not supported
//      S_OK                - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//********************************************************************


STDMETHODIMP CDataObject::QueryGetData  ( LPFORMATETC pformatetc )
{
    SCODE sc = DATA_E_FORMATETC;

    TestDebugOut(TEXT("In CDataObject::QueryGetData\r\n"));

    // check the validity of the formatetc.
    if ( (pformatetc->cfFormat == CF_METAFILEPICT)  &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_MFPICT) )
        sc = S_OK;

    return ResultFromScode(sc);
}

//**********************************************************************
//
// CDataObject::DAdvise
//
// Purpose:
//
//      Called by the container when it would like to be notified of
//      changes in the object data.
//
// Parameters:
//
//      FORMATETC FAR* pFormatetc   - The format the container is interested in.
//
//      DWORD advf                  - The type of advise to be set up.
//
//      LPADVISESINK pAdvSink       - Pointer to the containers IAdviseSink
//
//      DWORD FAR* pdwConnection    - Out parameter to return a unique connection id.
//
// Return Value:
//
//      passed on from IDataAdviseHolder
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateDataAdviseHolder      OLE API
//      IDataAdviseHolder::Advise   OLE API
//
//
//********************************************************************


STDMETHODIMP CDataObject::DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
                                     LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    HRESULT hRes;

    TestDebugOut(TEXT("In CDataObject::DAdvise\r\n"));

    // if no DataAdviseHolder has been created, then create one.
    if (!m_lpObj->m_lpDataAdviseHolder)
    {
        hRes=CreateDataAdviseHolder(&m_lpObj->m_lpDataAdviseHolder);
        if (hRes != S_OK)
        {
           TestDebugOut(TEXT("CDataObject::DAdvise  \
                                   cannot CreateDataAdviseHolder\n"));
           return(hRes);
        }
    }

    // pass on to the DataAdviseHolder
    return m_lpObj->m_lpDataAdviseHolder->Advise( this, pFormatetc, advf,
                                                  pAdvSink, pdwConnection);
}

//**********************************************************************
//
// CDataObject::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DATA_E_FORMATETC    - Format not supported
//      S_OK                - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::GetMetaFilePict()  OBJ.CPP
//      ResultFromScode                 OLE API
//
//********************************************************************

STDMETHODIMP CDataObject::GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
    SCODE sc = DATA_E_FORMATETC;

    TestDebugOut(TEXT("In CDataObject::GetData\r\n"));

    // Check to the FORMATETC and fill pmedium if valid.
    if ( (pformatetcIn->cfFormat == CF_METAFILEPICT)  &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed & TYMED_MFPICT) )
        {
        HANDLE hmfPict = m_lpObj->GetMetaFilePict();
        pmedium->tymed = TYMED_MFPICT;
        pmedium->hGlobal = hmfPict;
        pmedium->pUnkForRelease = NULL;
        sc = S_OK;
        }

    return ResultFromScode( sc );
}

//**********************************************************************
//
// CDataObject::DUnadvise
//
// Purpose:
//
//      Breaks down an Advise connection.
//
// Parameters:
//
//      DWORD dwConnection  - Advise connection ID.
//
// Return Value:
//
//      Returned from the DataAdviseHolder.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IDataAdviseHolder::Unadvise OLE
//
//********************************************************************

STDMETHODIMP CDataObject::DUnadvise  ( DWORD dwConnection)
{
    TestDebugOut(TEXT("In CDataObject::DUnadvise\r\n"));

    return m_lpObj->m_lpDataAdviseHolder->Unadvise(dwConnection);
}

//**********************************************************************
//
// CDataObject::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In this simple implementation, we don't really support this
//      method, we just always return DATA_E_FORMATETC.
//
//********************************************************************


STDMETHODIMP CDataObject::GetDataHere  ( LPFORMATETC pformatetc,
                                         LPSTGMEDIUM pmedium )
{
    TestDebugOut(TEXT("In CDataObject::GetDataHere\r\n"));
    return ResultFromScode( DATA_E_FORMATETC);
}

//**********************************************************************
//
// CDataObject::GetCanonicalFormatEtc
//
// Purpose:
//
//      Returns a FORMATETC that is equivalent to the one passed in.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - FORMATETC to be tested.
//
//      LPFORMATETC pformatetcOut   - Out ptr for returned FORMATETC.
//
// Return Value:
//
//      DATA_S_SAMEFORMATETC    - Use the same formatetc as was passed.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoGetMalloc                 OLE API
//      IMalloc::Alloc              OLE
//      IMalloc::Release            OLE
//      _fmemcpy                    C run-time
//
//********************************************************************


STDMETHODIMP CDataObject::GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
                                                   LPFORMATETC pformatetcOut)
{
    HRESULT hresult;
    TestDebugOut(TEXT("In CDataObject::GetCanonicalFormatEtc\r\n"));

    if (!pformatetcOut)
        return ResultFromScode(E_INVALIDARG);

    /* OLE2NOTE: we must make sure to set all out parameters to NULL. */
    pformatetcOut->ptd = NULL;

    if (!pformatetc)
        return ResultFromScode(E_INVALIDARG);

    // OLE2NOTE: we must validate that the format requested is supported
    if ((hresult = QueryGetData(pformatetc)) != NOERROR)
        return hresult;

    /* OLE2NOTE: an app that is insensitive to target device (as
    **    SimpSvr is) should fill in the lpformatOut parameter
    **    but NULL out the "ptd" field; it should return NOERROR if the
    **    input formatetc->ptd what non-NULL. this tells the caller
    **    that it is NOT necessary to maintain a separate screen
    **    rendering and printer rendering. if should return
    **    DATA_S_SAMEFORMATETC if the input and output formatetc's are
    **    identical.
    */

    *pformatetcOut = *pformatetc;
    if (pformatetc->ptd == NULL)
        return ResultFromScode(DATA_S_SAMEFORMATETC);
    else
        {
        pformatetcOut->ptd = NULL;
        return NOERROR;
        }
}

//**********************************************************************
//
// CDataObject::SetData
//
// Purpose:
//
//      Called to set the data for the object.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - the format of the data being passed
//
//      STGMEDIUM FAR * pmedium     - the location of the data.
//
//      BOOL fRelease               - Defines the ownership of the medium
//
// Return Value:
//
//      DATA_E_FORMATETC    - Not a valid FORMATETC for this object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This simple object does not support having its data set, so an
//      error value is always returned.
//
//********************************************************************


STDMETHODIMP CDataObject::SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                                     BOOL fRelease)
{
    TestDebugOut(TEXT("In CDataObject::SetData\r\n"));
    return ResultFromScode( DATA_E_FORMATETC );
}

//**********************************************************************
//
// CDataObject::EnumFormatEtc
//
// Purpose:
//
//      Enumerates the formats supported by this object.
//
// Parameters:
//
//      DWORD dwDirection                       - Order of enumeration.
//
//      LPENUMFORMATETC FAR* ppenumFormatEtc    - Place to return a pointer
//                                                to the enumerator.
//
// Return Value:
//
//      OLE_S_USEREG    - Indicates that OLE should consult the REG DB
//                        to enumerate the formats.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This simple implementation just returns OLE_SUSEREG
//
//********************************************************************


STDMETHODIMP CDataObject::EnumFormatEtc  ( DWORD dwDirection,
                                           LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    TestDebugOut(TEXT("In CDataObject::EnumFormatEtc\r\n"));
    // need to NULL the out parameter
    *ppenumFormatEtc = NULL;
    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// CDataObject::EnumDAdvise
//
// Purpose:
//
//      Returns an enumerator that enumerates all of the advises
//      set up on this data object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise    - An out ptr in which to
//                                            return the enumerator.
//
// Return Value:
//
//      Passed back from IDataAdviseHolder::EnumAdvise
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IDAtaAdviseHolder::EnumAdvise   OLE
//
// Comments:
//
//      This just delegates to the DataAdviseHolder.
//
//********************************************************************


STDMETHODIMP CDataObject::EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    TestDebugOut(TEXT("In CDataObject::EnumDAdvise\r\n"));
    // need to NULL the out parameter
    *ppenumAdvise = NULL;

    return m_lpObj->m_lpDataAdviseHolder->EnumAdvise(ppenumAdvise);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ido.h ===
//**********************************************************************
// File name: ido.h
//
//      Definition of CDataObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDO_H_)
#define _IDO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CDataObject : public IDataObject
{
private:
    CSimpSvrObj FAR * m_lpObj;

public:
    CDataObject::CDataObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        };

    CDataObject::~CDataObject() {};

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
    STDMETHODIMP DUnadvise  ( DWORD dwConnection);
    STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
    STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
                                  LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
                                          LPFORMATETC pformatetcOut);
    STDMETHODIMP GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
    STDMETHODIMP GetDataHere  ( LPFORMATETC pformatetc, LPSTGMEDIUM pmedium );
    STDMETHODIMP QueryGetData  ( LPFORMATETC pformatetc );
    STDMETHODIMP SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease);


};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\iec.h ===
//**********************************************************************
// File name: iec.h
//
//      Definition of CExternalConnection
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IEC_H_)
#define _IEC_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CExternalConnection : public IExternalConnection
{
private:
    CSimpSvrObj FAR * m_lpObj;  // Ptr to object
    DWORD m_dwStrong;           // Connection Count

public:
    CExternalConnection::CExternalConnection(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        m_dwStrong = 0;
        };

    CExternalConnection::~CExternalConnection() {};

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // *** IExternalConnection methods ***
    STDMETHODIMP_(DWORD) AddConnection (DWORD extconn, DWORD reserved);
    STDMETHODIMP_(DWORD) ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses);
};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ioipao.h ===
//**********************************************************************
// File name: IOIPAO.H
//
//      Definition of COleInPlaceActiveObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPAO_H_)
#define _IOIPAO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceActiveObject : public IOleInPlaceActiveObject
{
private:
    CSimpSvrObj FAR * m_lpObj;

public:
    COleInPlaceActiveObject::COleInPlaceActiveObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;     // set up the back ptr
        };
    COleInPlaceActiveObject::~COleInPlaceActiveObject() {};   // destructor

// IUnknown Methods

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP OnDocWindowActivate  ( BOOL fActivate) ;
    STDMETHODIMP OnFrameWindowActivate  ( BOOL fActivate) ;
    STDMETHODIMP GetWindow  ( HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
    STDMETHODIMP TranslateAccelerator  ( LPMSG lpmsg);
    STDMETHODIMP ResizeBorder  ( LPCRECT lprectBorder,
                                 LPOLEINPLACEUIWINDOW lpUIWindow,
                                 BOOL fFrameWindow);
    STDMETHODIMP EnableModeless  ( BOOL fEnable);

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\iec.cpp ===
//**********************************************************************
// File name: IEC.CPP
//
//    Implementation file for the CExternalConnection Class
//
// Functions:
//
//    See iec.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "iec.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CExternalConnection::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//********************************************************************

STDMETHODIMP CExternalConnection::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CExternalConnection::QueryInterface\r\n"));

    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CExternalConnection::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj object. Since
//      CExternalConnection is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for CExternalConnection. We
//      can just use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of the CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CExternalConnection::AddRef ()
{
    TestDebugOut(TEXT("In CExternalConnection::AddRef\r\n"));

    return( m_lpObj->AddRef() );
}

//**********************************************************************
//
// CExternalConnection::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj object. Since
//      CExternalConnection is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for CExternalConnection. We
//      can just use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CExternalConnection::Release ()
{
    TestDebugOut(TEXT("In CExternalConnection::Release\r\n"));

    return m_lpObj->Release();
}

//**********************************************************************
//
// CExternalConnection::AddConnection
//
// Purpose:
//
//      Called when another connection is made to the object.
//
// Parameters:
//
//      DWORD extconn   -   Type of connection
//
//      DWORD reserved  -   Reserved
//
// Return Value:
//
//      Strong connection count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::AddConnection (DWORD extconn, DWORD reserved)
{
    TestDebugOut(TEXT("In CExternalConnection::AddConnection\r\n"));

    if (extconn & EXTCONN_STRONG)
        return ++m_dwStrong;

    return 0;
}

//**********************************************************************
//
// CExternalConnection::ReleaseConnection
//
// Purpose:
//
//      Called when a connection to the object is released.
//
// Parameters:
//
//      DWORD extconn               - Type of Connection
//
//      DWORD reserved              - Reserved
//
//      BOOL fLastReleaseCloses     - Close flag
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      COleObject::Close           IOO.CPP
//
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
    TestDebugOut(TEXT("In CExternalConnection::ReleaseConnection\r\n"));

    if (extconn & EXTCONN_STRONG)
        {
        DWORD dwSave = --m_dwStrong;

        if (!m_dwStrong && fLastReleaseCloses)
            m_lpObj->m_OleObject.Close(OLECLOSE_SAVEIFDIRTY);

        return dwSave;
        }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ioipao.cpp ===
//**********************************************************************
// File name: IOIPAO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipao.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipao.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// COleInPlaceActiveObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::QueryInterface\r\n"));
    // need to NULL the out parameter
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceActiveObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. Since
//      COleInPlaceActiveObject is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for COleInPlaceActiveObject. We
//      can use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count on the CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::AddRef ()
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::AddRef\r\n"));

    return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceActiveObject::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. Since
//      COleInPlaceActiveObject is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for COleInPlaceActiveObject. We
//      can use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::Release ()
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::Release\r\n"));

    return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceActiveObject::OnDocWindowActivate
//
// Purpose:
//
//      Called when the doc window (in an MDI App) is (de)activated.
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetActiveObject   Container
//      CSimpSvrObject::AddFrameLevelUI     OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnDocWindowActivate  ( BOOL fActivate )
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::OnDocWindowActivate\r\n"));

    // Activating?
    if (fActivate)
        m_lpObj->AddFrameLevelUI();

    // No frame level tools to remove...

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceActiveObject::OnFrameWindowActivate
//
// Purpose:
//
//      Called when the Frame window is (de)activating
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if Deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetFocus                    Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnFrameWindowActivate  ( BOOL fActivate)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::OnFrameWindowActivate\r\n"));

    // set the focus to the object window if we are activating.
/*    if (fActivate)
        SetFocus(m_lpObj->m_lpDoc->GethDocWnd()); */

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceActiveObject::GetWindow
//
// Purpose:
//
//      Gets the objects Window Handle.
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::GethDocWnd     DOC.H
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::GetWindow  ( HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::GetWindow\r\n"));
    // need to NULL the out parameter
    *lphwnd = m_lpObj->m_lpDoc->GethDocWnd();
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceActiveObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used to implement Context Sensitive help
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      See TECHNOTES.WRI include with the OLE SDK for proper
//      implementation of this function.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ContextSensitiveHelp  ( BOOL fEnterMode )
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::ContextSensitiveHelp\r\n"));
    return ResultFromScode( E_NOTIMPL);
}

//**********************************************************************
//
// COleInPlaceActiveObject::TranslateAccelerator
//
// Purpose:
//
//      Used for translating accelerators in .DLL objects.
//
// Parameters:
//
//      LPMSG lpmsg - Pointer to a message
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This method should never be called since we are implemented
//      in an executable.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::TranslateAccelerator  ( LPMSG lpmsg)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::TranslateAccelerator\r\n"));
    // no accelerator table, return FALSE
    return ResultFromScode( S_FALSE );
}

//**********************************************************************
//
// COleInPlaceActiveObject::ResizeBorder
//
// Purpose:
//
//      Called when the border changes size.
//
// Parameters:
//
//      LPCRECT lprectBorder                - New Border
//
//      LPOLEINPLACEUIWINDOW lpUIWindow     - Pointer to UIWindow
//
//      BOOL fFrameWindow                   - True if lpUIWindow is the
//                                            frame window.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Need to call SetBorderSpace again...
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ResizeBorder  ( LPCRECT lprectBorder,
                                                      LPOLEINPLACEUIWINDOW lpUIWindow,
                                                      BOOL fFrameWindow)
{
    HRESULT hRes;

    TestDebugOut(TEXT("In COleInPlaceActiveObject::ResizeBorder\r\n"));

    // should always have an inplace frame...
    if ((hRes=m_lpObj->GetInPlaceFrame()->SetBorderSpace(NULL)) != S_OK)
    {
       TestDebugOut(TEXT("COleInPlaceActiveObject::ResizeBorder  \
                               SetBorderSpace fails\n"));
       return(hRes);
    }


    // There will only be a UIWindow if in an MDI container
    if (m_lpObj->GetUIWindow())
    {
        if((hRes=m_lpObj->GetUIWindow()->SetBorderSpace(NULL)) != S_OK)
        {
          TestDebugOut(TEXT("COleInPlaceActiveObject::ResizeBorder  \
                                  SetBorderSpace fails\n"));
          return(hRes);
        }
    }

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceActiveObject::EnableModeless
//
// Purpose:
//
//      Called to enable/disable modeless dialogs.
//
// Parameters:
//
//      BOOL fEnable    - TRUE to enable, FALSE to disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Called by the container when a model dialog box is added/removed
//      from the screen.  The appropriate action for a server application
//      is to disable/enable any modeless dialogs currently being displayed.
//      Since this application doesn't display any modeless dialogs,
//      this method is essentially ignored.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::EnableModeless  ( BOOL fEnable)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::EnableModeless\r\n"));
    return ResultFromScode( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ioipo.cpp ===
//**********************************************************************
// File name: IOIPO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"
#include "math.h"

//**********************************************************************
//
// COleInPlaceObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In COleInPlaceObject::QueryInterface\r\n"));
    // need to NULL the out parameter
    *ppvObj = NULL;
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceObject::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpSvrObj. Since
//      COleInPlaceObject is a nested class of CSimpSvrObj, we don't need
//      to have a separate reference count for COleInPlaceObject. We can
//      use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::AddRef ()
{
    TestDebugOut(TEXT("In COleInPlaceObject::AddRef\r\n"));
    return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceObject::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpSvrObj. Since
//      COleInPlaceObject is a nested class of CSimpSvrObj, we don't need
//      to have a separate reference count for COleInPlaceObject. We can
//      use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::Release ()
{
    TestDebugOut(TEXT("In COleInPlaceObject::Release\r\n"));
    return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceObject::InPlaceDeactivate
//
// Purpose:
//
//      Called to deactivat the object
//
// Parameters:
//
//      None
//
// Return Value:
//      NOERROR
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleInPlaceSite::OnInPlaceDeactivate    Container
//      IOleInPlaceSite::Release                Container
//      CSimpSvrObj::DeactivateUI               OBJ.CPP
//      CSimpSvrObj::DoInPlaceHide              OBJ.CPP
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::InPlaceDeactivate()
{
     TestDebugOut(TEXT("In COleInPlaceObject::InPlaceDeactivate\r\n"));

     // if not inplace active, return NOERROR
     if (!m_lpObj->m_fInPlaceActive)
         return NOERROR;

     // clear inplace flag
     m_lpObj->m_fInPlaceActive = FALSE;

     // deactivate the UI
     m_lpObj->DeactivateUI();
     m_lpObj->DoInPlaceHide();

     // tell the container that we are deactivating.
     if (m_lpObj->m_lpIPSite)
         {
         HRESULT hRes;
         if ((hRes=m_lpObj->m_lpIPSite->OnInPlaceDeactivate()) != S_OK)
         {
            TestDebugOut(TEXT("COleInPlaceObject::InPlaceDeactivate  \
                                    OnInPlaceDeactivate fails\n"));
         }
         m_lpObj->m_lpIPSite->Release();
         m_lpObj->m_lpIPSite =NULL;
         }

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::UIDeactivate
//
// Purpose:
//
//      Instructs us to remove our UI.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpSvrObj::DeactivateUI               OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::UIDeactivate()
{
    TestDebugOut(TEXT("In COleInPlaceObject::UIDeactivate\r\n"));

    m_lpObj->DeactivateUI();

    return ResultFromScode (S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::SetObjectRects
//
// Purpose:
//
//      Called when the container clipping region or the object position
//      changes.
//
// Parameters:
//
//      LPCRECT lprcPosRect     - New Position Rect.
//
//      LPCRECT lprcClipRect    - New Clipping Rect.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IntersectRect               Windows API
//      OffsetRect                  Windows API
//      CopyRect                    Windows API
//      MoveWindow                  Windows API
//      CSimpSvrDoc::GethHatchWnd   DOC.H
//      CSimpSvrDoc::gethDocWnd     DOC.h
//      SetHatchWindowSize          OLE2UI
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    TestDebugOut(TEXT("In COleInPlaceObject::SetObjectRects\r\n"));

    RECT resRect;
    POINT pt;

    // Get the intersection of the clipping rect and the position rect.
    IntersectRect(&resRect, lprcPosRect, lprcClipRect);

    m_lpObj->m_xOffset = abs (resRect.left - lprcPosRect->left);
    m_lpObj->m_yOffset = abs (resRect.top - lprcPosRect->top);

    m_lpObj->m_scale = (float)(lprcPosRect->right - lprcPosRect->left)/m_lpObj->m_size.x;

    if (m_lpObj->m_scale == 0)
        m_lpObj->m_scale = 1.0F;

    TCHAR szBuffer[255];

    wsprintf(szBuffer, TEXT("New Scale %3d\r\n"), m_lpObj->m_scale);

    TestDebugOut(szBuffer);

    // Adjust the size of the Hatch Window.
    SetHatchWindowSize(m_lpObj->m_lpDoc->GethHatchWnd(),(LPRECT) lprcPosRect, (LPRECT) lprcClipRect, &pt);

    // offset the rect
    OffsetRect(&resRect, pt.x, pt.y);

    CopyRect(&m_lpObj->m_posRect, lprcPosRect);

    // Move the actual object window
    MoveWindow(m_lpObj->m_lpDoc->GethDocWnd(),
                   resRect.left,
                   resRect.top,
                   resRect.right - resRect.left,
                   resRect.bottom - resRect.top,
                   TRUE);


    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceObject::GetWindow
//
// Purpose:
//
//      Returns the Window handle of the inplace object
//
// Parameters:
//
//      HWND FAR* lphwnd    - Out pointer in which to return the window
//                            Handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::GethDocWnd      DOC.H
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::GetWindow  ( HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In COleInPlaceObject::GetWindow\r\n"));
    *lphwnd = m_lpObj->m_lpDoc->GethDocWnd();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used in performing Context Sensitive Help
//
// Parameters:
//
//      BOOL fEnterMode     - Flag to determine if enter or exiting
//                            Context Sensitive Help.
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact that it is
//      beyond the scope of a simple object.  All *real* applications
//      are going to want to implement this function, otherwise any
//      container that supports context sensitive help will not work
//      properly while the object is in place.
//
//      See TECHNOTES.WRI include with the OLE SDK for details on
//      Implementing this method.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ContextSensitiveHelp  ( BOOL fEnterMode)
{
    TestDebugOut(TEXT("In COleInPlaceObject::ContextSensitiveHelp\r\n"));
    return ResultFromScode( E_NOTIMPL);
}

//**********************************************************************
//
// COleInPlaceObject::ReactivateAndUndo
//
// Purpose:
//
//      Called when the container wants to undo the last edit made in
//      the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      INPLACE_E_NOTUNDOABLE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Since this server does not support undo, the value
//      INPLACE_E_NOTUNDOABLE is always returned.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ReactivateAndUndo  ()
{
    TestDebugOut(TEXT("In COleInPlaceObject::ReactivateAndUndo\r\n"));
    return ResultFromScode( INPLACE_E_NOTUNDOABLE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ioo.h ===
//**********************************************************************
// File name: ioo.h
//
//      Definition of COleObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOO_H_)
#define _IOO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleObject : public IOleObject
{
private:
    CSimpSvrObj FAR * m_lpObj;
    BOOL m_fOpen;

public:
    COleObject::COleObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        m_fOpen = FALSE;
        };
    COleObject::~COleObject()
        {
        };
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP SetClientSite (LPOLECLIENTSITE pClientSite);
    STDMETHODIMP Advise (LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
    STDMETHODIMP SetHostNames  ( LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHODIMP DoVerb  (  LONG iVerb,
                            LPMSG lpmsg,
                            LPOLECLIENTSITE pActiveSite,
                            LONG lindex,
                            HWND hwndParent,
                            LPCRECT lprcPosRect);
    STDMETHODIMP GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHODIMP Update  () ;
    STDMETHODIMP Close  ( DWORD dwSaveOption) ;
    STDMETHODIMP Unadvise ( DWORD dwConnection);
    STDMETHODIMP EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb) ;
    STDMETHODIMP GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite);
    STDMETHODIMP SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHODIMP GetMoniker  ( DWORD dwAssign, DWORD dwWhichMoniker,
                               LPMONIKER FAR* ppmk);
    STDMETHODIMP InitFromData  ( LPDATAOBJECT pDataObject,
                                 BOOL fCreation,
                                 DWORD dwReserved);
    STDMETHODIMP GetClipboardData  ( DWORD dwReserved,
                                     LPDATAOBJECT FAR* ppDataObject);
    STDMETHODIMP IsUpToDate  ();
    STDMETHODIMP GetUserClassID  ( CLSID FAR* pClsid);
    STDMETHODIMP GetUserType  ( DWORD dwFormOfType, LPOLESTR FAR* pszUserType);
    STDMETHODIMP SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHODIMP EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
    STDMETHODIMP GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus);
    STDMETHODIMP SetColorScheme  ( LPLOGPALETTE lpLogpal);

    void OpenEdit(LPOLECLIENTSITE pActiveSite);

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ioipo.h ===
//**********************************************************************
// File name: ioipo.h
//
//      Definition of COleInPlaceObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPO_H_)
#define _IOIPO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceObject : public IOleInPlaceObject
{
private:
    CSimpSvrObj FAR * m_lpObj;

public:
    COleInPlaceObject::COleInPlaceObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        };
    COleInPlaceObject::~COleInPlaceObject() {};

//  IUnknown Methods
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP InPlaceDeactivate  ();
    STDMETHODIMP UIDeactivate  () ;
    STDMETHODIMP SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect);
    STDMETHODIMP GetWindow  ( HWND FAR* lphwnd) ;
    STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
    STDMETHODIMP ReactivateAndUndo  ();
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ips.h ===
//**********************************************************************
// File name: ips.h
//
//      Definition of CPersistStorage
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IPS_H_)
#define _IPS_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CPersistStorage : IPersistStorage
{
private:
    CSimpSvrObj FAR * m_lpObj;
    BOOL m_fSameAsLoad;

public:
    CPersistStorage::CPersistStorage(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        };
    CPersistStorage::~CPersistStorage() {};

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP InitNew (LPSTORAGE pStg);
    STDMETHODIMP GetClassID  ( LPCLSID lpClassID) ;
    STDMETHODIMP Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad) ;
    STDMETHODIMP SaveCompleted  ( LPSTORAGE pStgNew);
    STDMETHODIMP Load  ( LPSTORAGE pStg);
    STDMETHODIMP IsDirty  ();
    STDMETHODIMP HandsOffStorage  ();

    void ReleaseStreamsAndStorage();
    void OpenStreams(LPSTORAGE lpStg);
    void CreateStreams(LPSTORAGE lpStg);
    void CreateStreams(LPSTORAGE lpStg, LPSTREAM FAR *lpTempColor, LPSTREAM FAR *lpTempSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\obj.cpp ===
//**********************************************************************
// File name: obj.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See obj.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "ido.h"
#include "ips.h"
#include "icf.h"
#include "ioipao.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the "Object" level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            OBJ.CPP, IOO.CPP, IDO.CPP, IPS.CPP
//                                  IOIPO.CPP, IOIPAO.CPP
//
//
//********************************************************************

STDMETHODIMP CSimpSvrObj::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpSvrObj::QueryInterface\r\n"));

    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = this;
    else if (IsEqualIID(riid, IID_IOleObject))
        *ppvObj = &m_OleObject;
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppvObj = &m_DataObject;
    else if ( IsEqualIID(riid, IID_IPersistStorage) ||
              IsEqualIID(riid, IID_IPersist) )
        *ppvObj = &m_PersistStorage;
    else if (IsEqualIID(riid, IID_IOleInPlaceObject))
        *ppvObj = &m_OleInPlaceObject;
    else if (IsEqualIID(riid, IID_IOleInPlaceActiveObject))
        *ppvObj = &m_OleInPlaceActiveObject;
    else
       if (IsEqualIID(riid, IID_IExternalConnection))
         *ppvObj = &m_ExternalConnection;
    else
        {
        *ppvObj = NULL;
        sc = E_NOINTERFACE;
        }

    if (*ppvObj)
        ((LPUNKNOWN)*ppvObj)->AddRef();

    return ResultFromScode( sc );
}

//**********************************************************************
//
// CSimpSvrObj::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Object level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::AddRef         DOC.CPP
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces. (ie IDataObject,
//      IExternalConnection, IPersistStorage, IOleInPlaceActiveObject,
//      IOleObject, IOleInPlaceObject)
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::AddRef ()
{
    TestDebugOut(TEXT("In CSimpSvrObj::AddRef\r\n"));

    m_lpDoc->AddRef();

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrObj::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::Release        DOC.CPP
//      CSimpSvrDoc::ClearObj       DOC.H
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces. (ie IDataObject,
//      IExternalConnection, IPersistStorage, IOleInPlaceActiveObject,
//      IOleObject, IOleInPlaceObject)
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::Release ()
{
    TestDebugOut(TEXT("In CSimpSvrObj::Release\r\n"));

    /* The SimpSvrObj destructor needs to access SimpSvrDoc. We want to
     * hold on to the SimpSvrDoc object until we have deleted our own.
     */
    CSimpSvrDoc *lpDoc=m_lpDoc;

    if (--m_nCount== 0)
    {
       /* We still have Doc object. But SimpSvrObj object is going away.
        * So, we need to clear the obj pointer in the Doc object.
        */
       lpDoc->ClearObj();

       delete this;

       lpDoc->Release();
       return(0);
    }

    lpDoc->Release();
    return m_nCount;
}

//**********************************************************************
//
// CSimpSvrObj::CSimpSvrObj
//
// Purpose:
//
//      Constructor for CSimpSvrObj. Initialize the members variables
//
// Parameters:
//
//      CSimpSvrDoc FAR * lpSimpSvrDoc - ptr to the doc object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************
#pragma warning (disable : 4355)
                   // "this" used in base initializer list warning.  This
                   // can be disabled because we are not using "this" in
                   // the constructor for these objects, rather we are
                   // just storing it for future use...
CSimpSvrObj::CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc) :
                                             m_OleObject(this),
                                             m_DataObject(this),
                                             m_PersistStorage(this),
                                             m_OleInPlaceActiveObject(this),
                                             m_OleInPlaceObject(this),
                                             m_ExternalConnection(this)
#pragma warning (default : 4355) // Turn the warning back on

{
    m_lpDoc = lpSimpSvrDoc;
    m_nCount = 0;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_hmenuShared = NULL;
    m_hOleMenu = NULL;

    m_dwRegister = 0;

    m_lpFrame = NULL;
    m_lpCntrDoc = NULL;

    m_lpStorage = NULL;
    m_lpColorStm = NULL;
    m_lpSizeStm = NULL;
    m_lpOleClientSite = NULL;
    m_lpOleAdviseHolder = NULL;
    m_lpDataAdviseHolder = NULL;
    m_lpIPSite = NULL;

    // The default object is red
    m_red = 128;
    m_green = 0;
    m_blue = 0;

    m_size.x = 100;
    m_size.y = 100;

    m_xOffset = 0;
    m_yOffset = 0;

    m_scale = 1.0F;

    m_fSaveWithSameAsLoad = FALSE;
    m_fNoScribbleMode = FALSE;

}

//**********************************************************************
//
// CSimpSvrObj::~CSimpSvrObj
//
// Purpose:
//
//      Destructor for CSimpSvrObj
//
// Parameters:
//
//      None
//
// Return Value:
//      None
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      PostMessage                 Windows API
//      CSimpSvrDoc::GetApp         DOC.H
//      CSimpSvrDoc::GethAppWnd     DOC.H
//      CSimpSvrApp::IsStartedByOle APP.CPP
//      IDataAdviseHolder           OLE
//      IOleAdviseHolder            OLE
//      IOleClientSite              OLE
//
// Comment:
//      We need to release the DataAdviseHolder, OleClientSite and
//      OleAdviseHolder if they are created by our CSimpSvrObj.
//
//
//********************************************************************

CSimpSvrObj::~CSimpSvrObj()
{
    TestDebugOut(TEXT("In CSimpSvrObj's Destructor \r\n"));

    // if we were started by ole, post ourselves a close message
    if (m_lpDoc->GetApp()->IsStartedByOle())
        PostMessage(m_lpDoc->GethAppWnd(), WM_SYSCOMMAND, SC_CLOSE, 0L);

    /* We need to release our Data Advise Holder when we destroy our
     * object.
     */
    if (m_lpDataAdviseHolder)
    {
        m_lpDataAdviseHolder->Release();
    }

    if (m_lpOleAdviseHolder)
    {
        m_lpOleAdviseHolder->Release();
    }

    if (m_lpOleClientSite)
    {
        m_lpOleClientSite->Release();
    }
}

//**********************************************************************
//
// CSimpSvrObj::Draw
//
// Purpose:
//
//      Draws the object into an arbitrary DC
//
// Parameters:
//
//      HDC hDC - DC to draw into
//
// Return Value:
//
//      NONE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateBrushIndirect         Windows API
//      SelectObject                Windows API
//      Rectangle                   Windows API
//      DeleteObject                Windows API
//
//
//********************************************************************

void CSimpSvrObj::Draw (HDC hDC, BOOL m_fMeta)
{
    LOGBRUSH lb;

    TestDebugOut(TEXT("In CSimpSvrObj::Draw\r\n"));

    TCHAR szBuffer[255];

    wsprintf(szBuffer, TEXT("Drawing Scale %3d\r\n"),m_scale);

    TestDebugOut(szBuffer);

    if (!m_fMeta)
    {
        SetMapMode(hDC, MM_ANISOTROPIC);
        SetWindowOrg(hDC, (int)(m_xOffset/m_scale), (int)(m_yOffset/m_scale));
        SetWindowExt(hDC, m_size.x, m_size.y);
        SetViewportExt(hDC, (int)(m_size.x*m_scale), (int)(m_size.y*m_scale));
    }

    // fill out a LOGBRUSH
    lb.lbStyle = BS_SOLID;
    lb.lbColor = RGB(m_red, m_green, m_blue);
    lb.lbHatch = 0;

    // create the brush
    HBRUSH hBrush = CreateBrushIndirect(&lb);

    // select the brush
    HBRUSH hOldBrush = (HBRUSH) SelectObject(hDC, hBrush);
    HPEN hPen = CreatePen(PS_INSIDEFRAME, 6, RGB(0, 0, 0));

    HPEN hOldPen = (HPEN) SelectObject(hDC, hPen);

    // draw the rectangle
    Rectangle (hDC, 0, 0, m_size.x, m_size.y);

    // restore the pen
    hPen = (HPEN) SelectObject(hDC, hOldPen);

    // free the pen
    DeleteObject(hPen);

    // restore the old brush
    hBrush = (HBRUSH) SelectObject(hDC, hOldBrush);

    // free the brush
    DeleteObject(hBrush);
}

//**********************************************************************
//
// CSimpSvrObj::GetMetaFilePict
//
// Purpose:
//
//      Returns a handle to a metafile representation of the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      Handle to the metafile.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      GlobalAlloc                     Windows API
//      GlobalLock                      Windows API
//      SetWindowOrg                    Windows API
//      SetWindowExt                    Windows API
//      CreateMetaFile                  Windows API
//      CloseMetaFile                   Windows API
//      GlobalUnlock                    Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//      CSimpSvrObj::Draw               OBJ.CPP
//
//
//********************************************************************

HANDLE CSimpSvrObj::GetMetaFilePict()
{
    HANDLE hMFP;
    METAFILEPICT FAR * lpMFP;
    POINT pt;

    TestDebugOut(TEXT("In CSimpSvrObj::GetMetaFilePict\r\n"));

    // allocate the memory for the METAFILEPICT structure
    hMFP = GlobalAlloc (GMEM_SHARE | GHND, sizeof (METAFILEPICT) );
    if (!hMFP)
    {
       /* GlobalAlloc fails. Cannot allocate global memory.
        */
       return(NULL);
    }
    lpMFP = (METAFILEPICT FAR*) GlobalLock(hMFP);
    if (!lpMFP)
    {
       /* Cannot lock the allocated memory.
        */
       return(NULL);
    }

    // get the size of the object in HIMETRIC
    pt.x = XformWidthInPixelsToHimetric(NULL, m_size.x);
    pt.y = XformHeightInPixelsToHimetric(NULL, m_size.y);

    // fill out the METAFILEPICT structure
    lpMFP->mm = MM_ANISOTROPIC;
    lpMFP->xExt = pt.x;
    lpMFP->yExt = pt.y;

    // Create the metafile
    HDC hDC = CreateMetaFile(NULL);

    if (hDC)
    {
       SetWindowOrg (hDC, 0, 0);
       SetWindowExt (hDC, m_size.x,
                          m_size.y);

       Draw(hDC);

       lpMFP->hMF = CloseMetaFile(hDC);
    }

    // unlock the metafilepict
    GlobalUnlock(hMFP);

    return hMFP;
}


//**********************************************************************
//
// CSimpSvrObj::SaveToStorage
//
// Purpose:
//
//      Saves the object to the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg - Storage in which to save the object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::CreateStream      OLE
//      IStream::Write              OLE
//      IStream::Release            OLE
//
// Comments:
//
//      A real app will want to do better error checking / returning
//
//********************************************************************

void CSimpSvrObj::SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad)
{
    TestDebugOut(TEXT("In CSimpSvrObj::SaveToStorage\r\n"));

    LPSTREAM lpTempColor, lpTempSize;

    if (!fSameAsLoad)
        m_PersistStorage.CreateStreams( lpStg, &lpTempColor, &lpTempSize);
    else
        {
        lpTempColor = m_lpColorStm;
        lpTempColor->AddRef();
        lpTempSize = m_lpSizeStm;
        lpTempSize->AddRef();
        }

    ULARGE_INTEGER uli;

    uli.LowPart = 0;
    uli.HighPart = 0;

    if ( lpTempColor->SetSize(uli) != S_OK )
       goto EXIT;            // we don't want to proceed further if fails
    if ( lpTempSize->SetSize(uli) != S_OK )
       goto EXIT;

    LARGE_INTEGER li;

    li.LowPart = 0;
    li.HighPart = 0;

    if ( lpTempColor->Seek(li, STREAM_SEEK_SET, NULL) != S_OK )
       goto EXIT;
    if ( lpTempSize->Seek(li, STREAM_SEEK_SET, NULL) != S_OK )
       goto EXIT;

    // write the colors to the stream
    if ( lpTempColor->Write(&m_red, sizeof(m_red), NULL) != S_OK )
       goto EXIT;
    if ( lpTempColor->Write(&m_green, sizeof(m_green), NULL) != S_OK )
       goto EXIT;
    if ( lpTempColor->Write(&m_blue, sizeof(m_blue), NULL) != S_OK )
       goto EXIT;

    // write the size to the stream
    if ( lpTempSize->Write(&m_size, sizeof(m_size), NULL) != S_OK )
       goto EXIT;

    TestDebugOut(TEXT("SaveToStorage exits normally\n"));

EXIT:
    lpTempColor->Release();
    lpTempSize->Release();
}

//**********************************************************************
//
// CSimpSvrObj::LoadFromStorage
//
// Purpose:
//
//      Loads the object from the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg     - Storage in which to load the object from
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::OpenStream        OLE
//      IStream::Read               OLE
//      IStream::Release            OLE
//
//
//********************************************************************

void CSimpSvrObj::LoadFromStorage ()
{
    TestDebugOut(TEXT("In CSimpSvrObj::LoadFromStorage\r\n"));

    // Read the colors
    if ( m_lpColorStm->Read(&m_red, sizeof(m_red), NULL) != S_OK )
       return;
    if ( m_lpColorStm->Read(&m_green, sizeof(m_green), NULL) != S_OK )
       return;
    if ( m_lpColorStm->Read(&m_blue, sizeof(m_blue), NULL) != S_OK )
       return;

    // read the size
    if ( m_lpSizeStm->Read(&m_size, sizeof(m_size), NULL) != S_OK )
       return;

    TestDebugOut(TEXT("LoadFromStorage exits normally\n"));

}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceActivate
//
// Purpose:
//
//      Does the inplace activation for the object
//
// Parameters:
//
//      LONG lVerb  - Verb that caused this function to be called
//
// Return Value:
//
//      TRUE/FALSE depending on success or failure.
//
// Function Calls:
//      Function                                Location
//
//      IOleClientSite::QueryInterface          Container
//      IOleClientSite::ShowObject              Container
//      IOleInPlaceSite::CanInPlaceActivate     Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceSite::OnInPlaceActivate      Container
//      IOleInPlaceSite::GetWindow              Container
//      IOleInPlaceSite::GetWindowContext       Container
//      IOleInPlaceSite::OnUIActivate           Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      TestDebugOut                       Windows API
//      ShowWindow                              Windows API
//      SetParent                               Windows API
//      IntersectRect                           Windows API
//      OffsetRect                              Windows API
//      MoveWindow                              Windows API
//      CopyRect                                Windows API
//      SetFocus                                Windows API
//      SetHatchWindowSize                      OLE2UI
//      CSimpSvrObj::AssembleMenus              OBJ.CPP
//      CSimpSvrObj::AddFrameLevelUI            OBJ.CPP
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

BOOL CSimpSvrObj::DoInPlaceActivate (LONG lVerb)
{
    BOOL retval = FALSE;
    RECT posRect, clipRect;


    TestDebugOut(TEXT("In CSimpSvrObj::DoInPlaceActivate\r\n"));

    // if not currently in place active
    if (!m_fInPlaceActive)
    {
        // get the inplace site
        if (m_lpOleClientSite->QueryInterface(IID_IOleInPlaceSite,
                                      (LPVOID FAR *)&m_lpIPSite) != NOERROR)
            goto error;


        // if the inplace site could not be obtained, or refuses to inplace
        // activate then goto error.
        if (m_lpIPSite == NULL || m_lpIPSite->CanInPlaceActivate() != NOERROR)
        {
            if (m_lpIPSite)
                m_lpIPSite->Release();
            m_lpIPSite = NULL;
            goto error;
        }

        // tell the site that we are activating.
        if (m_lpIPSite->OnInPlaceActivate() != S_OK)
           TestDebugOut(TEXT("OnInPlaceActivate fails\n"));

        m_fInPlaceActive = TRUE;
    }

    // if not currently inplace visibl
    if (!m_fInPlaceVisible)
    {
        m_fInPlaceVisible = TRUE;

        // get the window handle of the site
        if (m_lpIPSite->GetWindow(&m_hWndParent) != S_OK)
           TestDebugOut(TEXT("GetWindow fails\n"));

        // get window context from the container
        m_FrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        if (m_lpIPSite->GetWindowContext ( &m_lpFrame,
                                     &m_lpCntrDoc,
                                     &posRect,
                                     &clipRect,
                                     &m_FrameInfo) != S_OK)
           TestDebugOut(TEXT("GetWindowContext fails\n"));

        if (sizeof(OLEINPLACEFRAMEINFO) != m_FrameInfo.cb)
        {
           TestDebugOut(TEXT("WARNING! GetWindowContext call "
                                  "modified FrameInfo.cb!\n"));
        }


        // show the hatch window
        m_lpDoc->ShowHatchWnd();

        // Set the parenting
        SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
        SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

        // tell the client site to show the object
        if (m_lpOleClientSite->ShowObject() != S_OK)
           TestDebugOut(TEXT("ShowObject fails\n"));

        RECT resRect;

        // figure out the "real" size of the object
        IntersectRect(&resRect, &posRect, &clipRect);
        CopyRect(&m_posRect, &posRect);

        POINT pt;

        // adjust our hatch window size
        SetHatchWindowSize ( m_lpDoc->GethHatchWnd(),
                             &resRect,
                             &posRect,
                             &pt);

        // calculate the actual object rect inside the hatchwnd.
        OffsetRect (&resRect, pt.x, pt.y);

        // move the object window
        MoveWindow(m_lpDoc->GethDocWnd(),
                   resRect.left,
                   resRect.top,
                   resRect.right - resRect.left,
                   resRect.bottom - resRect.top,
                   FALSE);

        // create the combined window
        AssembleMenus();
    }

    // if not UIActive
    if (!m_fUIActive)
    {
        m_fUIActive = TRUE;

        // tell the inplace site that we are activating
        m_lpIPSite->OnUIActivate();

        // set the focus to our object window
        SetFocus(m_lpDoc->GethDocWnd());

        // set the active object on the frame
        if (m_lpFrame->SetActiveObject(&m_OleInPlaceActiveObject,
            OLESTR("Simple OLE 2.0 Server")) != S_OK)
           TestDebugOut(TEXT("SetActiveObject fails\n"));

        // set the active object on the Doc, if available.
        if (m_lpCntrDoc)
           if (m_lpCntrDoc->SetActiveObject(&m_OleInPlaceActiveObject,
               OLESTR("Simple OLE 2.0 Server")) != S_OK)
               TestDebugOut(TEXT("SetActiveObjet fails\n"));

        // add the frame level UI.
        AddFrameLevelUI();
    }

    retval = TRUE;
error:
    return retval;
}

//**********************************************************************
//
// CSimpSvrObj::AssembleMenus
//
// Purpose:
//
//      Creates the combined menus used during inplace activation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CreateMenu                      Windows API
//      IOleInPlaceFrame::InsertMenus   Container
//      InsertMenu                      Windows API
//      DestroyMenu                     Windows API
//      OleCreateMenuDescriptor         OLE API
//
//
//********************************************************************

void CSimpSvrObj::AssembleMenus()
{
    TestDebugOut(TEXT("In CSimpSvrObj::AssembleMenus\r\n"));
    OLEMENUGROUPWIDTHS menugroupwidths;

    m_hmenuShared = NULL;

    //  Create the menu resource
    m_hmenuShared = CreateMenu();

    // have the contaner insert its menus
    if (m_lpFrame->InsertMenus (m_hmenuShared, &menugroupwidths) == NOERROR)
    {
        int nFirstGroup = (int) menugroupwidths.width[0];

        // insert the server menus
        InsertMenu( m_hmenuShared, nFirstGroup, MF_BYPOSITION | MF_POPUP,
                    (UINT)m_lpDoc->GetColorMenu(), TEXT("&Color"));
        menugroupwidths.width[1] = 1;
        menugroupwidths.width[3] = 0;
        menugroupwidths.width[5] = 0;
    }
    else
    {
        // Destroy the menu resource
        DestroyMenu(m_hmenuShared);
        m_hmenuShared = NULL;
    }

    // tell OLE to create the menu descriptor
    m_hOleMenu = OleCreateMenuDescriptor(m_hmenuShared, &menugroupwidths);
    if (!m_hOleMenu)
       TestDebugOut(TEXT("OleCreateMenuDescriptor fails\n"));
}

//**********************************************************************
//
// CSimpSvrObj::AddFrameLevelUI
//
// Purpose:
//
//      Adds the Frame level user interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetMenu           Container
//      IOleInPlaceFrame::SetBorderSpace    Container
//      IOleInPlaceUIWindow::SetBorderSpace Container
//      CSimpSvrDoc::GethDocWnd             DOC.H
//
//
//********************************************************************

void CSimpSvrObj::AddFrameLevelUI()
{
    TestDebugOut(TEXT("In CSimpSvrObj::AddFrameLevelUI\r\n"));

    // add the combined menu
    if ( m_lpFrame->SetMenu(m_hmenuShared, m_hOleMenu,
                            m_lpDoc->GethDocWnd()) != S_OK )
       return;

    // do hatched border
    SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
    SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

    // set the border space.  Normally we would negotiate for toolbar
    // space at this point.  Since this server doesn't have a toolbar,
    // this isn't needed...
    if (m_lpFrame)
       if (m_lpFrame->SetBorderSpace(NULL) != S_OK)
          return;

    if (m_lpCntrDoc)
       if (m_lpCntrDoc->SetBorderSpace(NULL) != S_OK)
          return;

    TestDebugOut(TEXT("AddFrameLevelUI exits\n"));

}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceHide
//
// Purpose:
//
//      Hides the object while inplace actvie
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      SetParent                       Windows API
//      CSimpSvrDoc::GethDocWnd         DOC.H
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//      CSimpSvrObj::DisassembleMenus   OBJ.CPP
//      IOleInPlaceFrame::Release       Container
//      IOleInPlaceUIWindow::Release    Container
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DoInPlaceHide()
{
    TestDebugOut(TEXT("In CSimpSvrObj::DoInPlaceHide\r\n"));

    // if we aren't inplace visible, then this routine is a NOP,
    if (!m_fInPlaceVisible)
        return;

    m_fInPlaceVisible = FALSE;

    // change the parenting
    SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
    SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

    // rip down the combined menus
    DisassembleMenus();

    // release the inplace frame
    m_lpFrame->Release();

    m_lpFrame = NULL;  // only holding one ref. to frame.

    // release the UIWindow if it is there.
    if (m_lpCntrDoc)
        m_lpCntrDoc->Release();

    m_lpCntrDoc = NULL;

}

//**********************************************************************
//
// CSimpSvrObj::DisassembleMenus
//
// Purpose:
//
//      Disassembles the combined menus used in inplace activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut               Windows API
//      OleDestroyMenuDescriptor        OLE API
//      RemoveMenu                      Windows API
//      IOleInPlaceFrame::RemoveMenus   Container
//      DestroyMenu                     Windows API
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DisassembleMenus()
{
    // destroy the menu descriptor
    OleDestroyMenuDescriptor(m_hOleMenu);

    if (m_hmenuShared)
    {
        // remove the menus that we added
        RemoveMenu( m_hmenuShared, 1, MF_BYPOSITION);

        // have the container remove its menus
        if (m_lpFrame->RemoveMenus(m_hmenuShared) != S_OK)
           TestDebugOut(TEXT("RemoveMenus fails\n"));

        // Destroy the menu resource
        DestroyMenu(m_hmenuShared);

        m_hmenuShared = NULL;
    }
}

//**********************************************************************
//
// CSimpSvrObj::SendOnDataChange
//
// Purpose:
//
//      Uses the data advise holder to send a data change, then updates
//      the ROT to note the time of change.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IDataAdviseHolder::SendOnDataChange     OLE API
//      GetRunningObjectTable                   OLE API
//      CoFileTimeNow                           OLE API
//      IRunningObjectTable::NoteChangeTime     OLE API
//
//
//********************************************************************

void CSimpSvrObj::SendOnDataChange()
{
    if (m_lpDataAdviseHolder)
        if (m_lpDataAdviseHolder->SendOnDataChange( (LPDATAOBJECT)
                                                   &m_DataObject, 0, 0))
           TestDebugOut(TEXT("SendOnDataChange fails\n"));

    LPRUNNINGOBJECTTABLE lpRot;

    GetRunningObjectTable(0, &lpRot);

    if ( lpRot && m_dwRegister)
    {

        FILETIME ft;
        CoFileTimeNow(&ft);

        lpRot->NoteChangeTime(m_dwRegister, &ft);

        lpRot->Release();
    }
}


//**********************************************************************
//
// CSimpSvrObj::DeactivateUI
//
// Purpose:
//
//      Breaks down the inplace ui
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      SetParent                               Windows API
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceSite::UIDeactivate           Container
//
//
//********************************************************************

void CSimpSvrObj::DeactivateUI()
{
    // if not UI active, or no pointer to IOleInPlaceFrame, then
    // return NOERROR
    if (!(m_fUIActive || m_lpFrame))
        return;
    else
    {
        m_fUIActive = FALSE;

        // remove hatching
        SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
        SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

        // if in an MDI container, call SetActiveObject on the DOC.
        if (m_lpCntrDoc)
            if (m_lpCntrDoc->SetActiveObject(NULL, NULL) != S_OK)
               TestDebugOut(TEXT("Fail in SetActiveObject\n"));

        if (m_lpFrame->SetActiveObject(NULL, NULL) != S_OK)
           TestDebugOut(TEXT("Fail in SetActiveObject\n"));

        // tell the container that our UI is going away.
        if (m_lpIPSite)
            if (m_lpIPSite->OnUIDeactivate(FALSE) != S_OK)
               TestDebugOut(TEXT("Fail in OnUIDeactivate\n"));
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>

#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpsvr.h"
#include "resource.h"
extern "C" void TestDebugOut(LPSTR psz);
#ifndef WIN32
/* Since OLE is part of the operating system in Win32, we don't need to
 * check the version number in Win32.
 */
#include <ole2ver.h>
#endif  // WIN32


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ioo.cpp ===
//**********************************************************************
// File name: IOO.CPP
//
//    Implementation file for the COleObject Class
//
// Functions:
//
//    See ioo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "app.h"
#include "doc.h"

#define VERB_OPEN 1

//**********************************************************************
//
// COleObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In COleObject::QueryInterface\r\n"));
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. Since COleObject
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for COleObject. We can safely use the reference count of
//      CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count on the CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::AddRef ()
{
    TestDebugOut(TEXT("In COleObject::AddRef\r\n"));
    return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleObject::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. Since COleObject
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for COleObject. We can safely use the reference count of
//      CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::Release ()
{
    TestDebugOut(TEXT("In COleObject::Release\r\n"));
    return m_lpObj->Release();
}

//**********************************************************************
//
// COleObject::SetClientSite
//
// Purpose:
//
//      Called to notify the object of it's client site.
//
// Parameters:
//
//      LPOLECLIENTSITE pClientSite     - ptr to new client site
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleClientSite::Release     Container
//      IOleClientSite::AddRef      Container
//
//
//********************************************************************

STDMETHODIMP COleObject::SetClientSite  ( LPOLECLIENTSITE pClientSite)
{
    TestDebugOut(TEXT("In COleObject::SetClientSite\r\n"));

    // if we already have a client site, release it.
    if (m_lpObj->m_lpOleClientSite)
        {
        m_lpObj->m_lpOleClientSite->Release();
        m_lpObj->m_lpOleClientSite = NULL;
        }

    // store copy of the client site.
    m_lpObj->m_lpOleClientSite = pClientSite;

    // AddRef it so it doesn't go away.
    if (m_lpObj->m_lpOleClientSite)
        m_lpObj->m_lpOleClientSite->AddRef();

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleObject::Advise
//
// Purpose:
//
//      Called to set up an advise on the OLE object.
//
// Parameters:
//
//      LPADVISESINK pAdvSink       - ptr to the Advise Sink for notification
//
//      DWORD FAR* pdwConnection    - place to return the connection ID.
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Advise.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateOleAdviseHolder       OLE API
//      IOleAdviseHolder::Advise    OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::Advise ( LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    TestDebugOut(TEXT("In COleObject::Advise\r\n"));

    // if we haven't made an OleAdviseHolder yet, make one.
    if (!m_lpObj->m_lpOleAdviseHolder)
    {
        HRESULT hRes;
        if ((hRes=CreateOleAdviseHolder(&m_lpObj->m_lpOleAdviseHolder))!=S_OK)
        {
           TestDebugOut(TEXT("CreateOleAdviseHolder fails\n"));
           return(hRes);
        }
    }

    // pass this call onto the OleAdviseHolder.
    return m_lpObj->m_lpOleAdviseHolder->Advise(pAdvSink, pdwConnection);
}

//**********************************************************************
//
// COleObject::SetHostNames
//
// Purpose:
//
//      Called to pass strings for Window titles.
//
// Parameters:
//
//      LPCOLESTR szContainerApp   -   ptr to string describing Container App
//
//      LPCOLESTR szContainerObj   -   ptr to string describing Object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This routine is called so that the server application can
//      set the window title appropriately.
//
//********************************************************************

STDMETHODIMP COleObject::SetHostNames  ( LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    TestDebugOut(TEXT("In COleObject::SetHostNames\r\n"));

    return ResultFromScode( S_OK);
}

//**********************************************************************
//
// COleObject::DoVerb
//
// Purpose:
//
//      Called by the container application to invoke a verb.
//
// Parameters:
//
//      LONG iVerb                  - The value of the verb to be
//                                    invoked.
//
//      LPMSG lpmsg                 - The message that caused the
//                                    verb to be invoked.
//
//      LPOLECLIENTSITE pActiveSite - Ptr to the active client site.
//
//      LONG lindex                 - Used in extended layout
//
//      HWND hwndParent             - This should be the window handle of
//                                    the window in which we are contained.
//                                    This value could be used to "fake"
//                                    inplace activation in a manner similar
//                                    to Video for Windows in OLE 1.0.
//
//      LPCRECT lprcPosRect         - The rectangle that contains the object
//                                    within hwndParent.  Also used to
//                                    "fake" inplace activation.
//
// Return Value:
//
//      OLE_E_NOTINPLACEACTIVE      - Returned if attempted to undo while not
//                                    inplace active.
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      ShowWindow                          Windows API
//      CSimpSvrObj::DoInPlaceActivate      OBJ.CPP
//      CSimpSvrObj::DoInPlaceHide          OBJ.CPP
//      COleObject::OpenEdit                IOO.CPP
//      CSimpSvrDoc::GethDocWnd             DOC.H
//      COleInPlaceObj::InPlaceDeactivate   IOIPO.CPP
//
// Comments:
//
//      Be sure to look at TECHNOTES.WRI included with the OLE
//      SDK for a description of handling the inplace verbs
//      properly.
//
//********************************************************************

STDMETHODIMP COleObject::DoVerb  (  LONG iVerb,
                                    LPMSG lpmsg,
                                    LPOLECLIENTSITE pActiveSite,
                                    LONG lindex,
                                    HWND hwndParent,
                                    LPCRECT lprcPosRect)
{
    TestDebugOut(TEXT("In COleObject::DoVerb\r\n"));

    switch (iVerb)
        {
        case OLEIVERB_SHOW:
        case OLEIVERB_PRIMARY:
            if (m_fOpen)
                SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
            else if (m_lpObj->DoInPlaceActivate(iVerb) == FALSE)
                OpenEdit(pActiveSite);
            break;

        case OLEIVERB_UIACTIVATE:
            if (m_fOpen)
                return ResultFromScode (E_FAIL);

            // inplace activate
            if (!m_lpObj->DoInPlaceActivate(iVerb))
                return ResultFromScode (E_FAIL);
            break;

        case OLEIVERB_DISCARDUNDOSTATE:
            // don't have to worry about this situation as we don't
            // support an undo state.
            if (!m_lpObj->m_fInPlaceActive)
                return ResultFromScode(OLE_E_NOT_INPLACEACTIVE);
            break;

        case OLEIVERB_HIDE:
            // if inplace active, do an "inplace" hide, otherwise
            // just hide the app window.
            if (m_lpObj->m_fInPlaceActive)
                {
                //  clear inplace flag
                m_lpObj->m_fInPlaceActive = FALSE;

                //  deactivate the UI
                m_lpObj->DeactivateUI();
                m_lpObj->DoInPlaceHide();
                }
            else
                m_lpObj->m_lpDoc->GetApp()->HideAppWnd();
            break;

        case OLEIVERB_OPEN:
        case VERB_OPEN:
            // if inplace active, deactivate
            if (m_lpObj->m_fInPlaceActive)
                m_lpObj->m_OleInPlaceObject.InPlaceDeactivate();

            // open into another window.
            OpenEdit(pActiveSite);
            break;

        default:
            if (iVerb < 0)
                return ResultFromScode(E_FAIL);
        }

    return ResultFromScode( S_OK);
}

//**********************************************************************
//
// COleObject::GetExtent
//
// Purpose:
//
//      Returns the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - The aspect in which to get the size.
//
//      LPSIZEL lpsizel     - Out ptr to return the size.
//
// Return Value:
//      S_OK        if the aspect is DVASPECT_CONTENT
//      E_FAIL      otherwise
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//
//
//********************************************************************

STDMETHODIMP COleObject::GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    TestDebugOut(TEXT("In COleObject::GetExtent\r\n"));

    SCODE sc = E_FAIL;

    // Only DVASPECT_CONTENT is supported....
    if (dwDrawAspect == DVASPECT_CONTENT)
        {
        sc = S_OK;

        // return the correct size in HIMETRIC...
        lpsizel->cx = XformWidthInPixelsToHimetric(NULL, m_lpObj->m_size.x);
        lpsizel->cy = XformHeightInPixelsToHimetric(NULL, m_lpObj->m_size.y);
        }

    return ResultFromScode( sc );
}

//**********************************************************************
//
// COleObject::Update
//
// Purpose:
//
//      Called to get the most up to date data
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IDataAdviseHolder::SendOnDataChange OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::Update()
{
    TestDebugOut(TEXT("In COleObject::Update\r\n"));

    // force an update
    m_lpObj->SendOnDataChange();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::Close
//
// Purpose:
//
//      Called when the OLE object needs to be closed
//
// Parameters:
//
//      DWORD dwSaveOption  - Flags to instruct the server how to prompt
//                            the user.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::Close          DOC.CPP
//
//
//********************************************************************

STDMETHODIMP COleObject::Close  ( DWORD dwSaveOption)
{
    TestDebugOut(TEXT("In COleObject::Close\r\n"));

    // delegate to the document object.
    m_lpObj->m_lpDoc->Close();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::Unadvise
//
// Purpose:
//
//      Breaks down an OLE advise that has been set up on this object.
//
// Parameters:
//
//      DWORD dwConnection  - Connection that needs to be broken down
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Unadvise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleAdviseHolder::Unadvise  OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::Unadvise ( DWORD dwConnection)
{
    TestDebugOut(TEXT("In COleObject::Unadvise\r\n"));

    // pass on to OleAdviseHolder.
    return m_lpObj->m_lpOleAdviseHolder->Unadvise(dwConnection);
}

//**********************************************************************
//
// COleObject::EnumVerbs
//
// Purpose:
//
//      Enumerates the verbs associated with this object.
//
// Parameters:
//
//      LPENUMOLEVERB FAR* ppenumOleVerb    - Out ptr in which to return
//                                            the enumerator
//
// Return Value:
//
//      OLE_S_USEREG    - Instructs OLE to use the verbs found in the
//                        REG DB for this server.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In a .DLL, an application cannot return OLE_S_USEREG.  This is
//      due to the fact that the default object handler is not being
//      used, and the container is really making direct function calls
//      into the server .DLL.
//
//********************************************************************

STDMETHODIMP COleObject::EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb)
{
    TestDebugOut(TEXT("In COleObject::EnumVerbs\r\n"));

    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// COleObject::GetClientSite
//
// Purpose:
//
//      Called to get the current client site of the object.
//
// Parameters:
//
//      LPOLECLIENTSITE FAR* ppClientSite   - Out ptr in which to return the
//                                            client site.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleObject::GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite)
{
    TestDebugOut(TEXT("In COleObject::GetClientSite\r\n"));
    *ppClientSite = m_lpObj->m_lpOleClientSite;
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::SetMoniker
//
// Purpose:
//
//      Used to set the objects moniker
//
// Parameters:
//
//      DWORD dwWhichMoniker    - Type of moniker being set
//
//      LPMONIKER pmk           - Pointer to the moniker
//
// Return Value:
//      S_OK
//      E_FAIL                      if the Moniker cannot be set
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleObject::SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk)
{
    TestDebugOut(TEXT("In COleObject::SetMoniker\r\n"));

    LPMONIKER lpmk;
    HRESULT   hRes;

    if (! m_lpObj->GetOleClientSite())
        return ResultFromScode (E_FAIL);

    if (m_lpObj->GetOleClientSite()->GetMoniker (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, &lpmk) != NOERROR)
        return ResultFromScode (E_FAIL);


    if (m_lpObj->GetOleAdviseHolder())
    {
        if ((hRes=m_lpObj->GetOleAdviseHolder()->SendOnRename(lpmk))!=S_OK)
           TestDebugOut(TEXT("SendOnRename fails\n"));
    }

    LPRUNNINGOBJECTTABLE lpRot;

    if (GetRunningObjectTable(0, &lpRot) == NOERROR)
        {
        if (m_lpObj->m_dwRegister)
            lpRot->Revoke(m_lpObj->m_dwRegister);

        if ( ((hRes=lpRot->Register(0, m_lpObj, lpmk,
                                  &m_lpObj->m_dwRegister))!=S_OK) ||
             (hRes!=ResultFromScode(MK_S_MONIKERALREADYREGISTERED)))
           TestDebugOut(TEXT("Running Object Table Register fails\n"));

        lpRot->Release();
        }


    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::GetMoniker
//
// Purpose:
//      returns a moniker from the client site
//
// Parameters:
//
//      DWORD dwAssign          - Assignment for the moniker
//
//      DWORD dwWhichMoniker    - Which moniker to return
//
//      LPMONIKER FAR* ppmk     - An out ptr to return the moniker
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMoniker  (  DWORD dwAssign, DWORD dwWhichMoniker,
                                        LPMONIKER FAR* ppmk)
{
    TestDebugOut(TEXT("In COleObject::GetMoniker\r\n"));
    // need to NULL the out parameter
    *ppmk = NULL;

    return m_lpObj->GetOleClientSite()->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
                                                   OLEWHICHMK_OBJFULL, ppmk);
}

//**********************************************************************
//
// COleObject::InitFromData
//
// Purpose:
//
//      Initialize the object from the passed pDataObject.
//
// Parameters:
//
//      LPDATAOBJECT pDataObject    - Pointer to data transfer object
//                                    to be used in the initialization
//
//      BOOL fCreation              - TRUE if the object is currently being
//                                    created.
//
//      DWORD dwReserved            - Reserved
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      We don't support this functionality, so we will always return
//      error.
//
//********************************************************************

STDMETHODIMP COleObject::InitFromData  ( LPDATAOBJECT pDataObject,
                                         BOOL fCreation,
                                         DWORD dwReserved)
{
    TestDebugOut(TEXT("In COleObject::InitFromData\r\n"));

    return ResultFromScode( S_FALSE );
}

//**********************************************************************
//
// COleObject::GetClipboardData
//
// Purpose:
//
//      Returns an IDataObject that is the same as doing an OleSetClipboard
//
// Parameters:
//
//      DWORD dwReserved                - Reserved
//
//      LPDATAOBJECT FAR* ppDataObject  - Out ptr for the Data Object.
//
// Return Value:
//
//      OLE_E_NOTSUPPORTED
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Support of this method is optional.
//
//********************************************************************

STDMETHODIMP COleObject::GetClipboardData  ( DWORD dwReserved,
                                             LPDATAOBJECT FAR* ppDataObject)
{
    TestDebugOut(TEXT("In COleObject::GetClipboardData\r\n"));
    // NULL the out ptr
    *ppDataObject = NULL;
    return ResultFromScode( E_NOTIMPL );
}

//**********************************************************************
//
// COleObject::IsUpToDate
//
// Purpose:
//
//      Determines if an object is up to date
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Our embedded object is always up to date.  This function is
//      particularly useful in linking situations.
//
//********************************************************************

STDMETHODIMP COleObject::IsUpToDate()
{
    TestDebugOut(TEXT("In COleObject::IsUpToDate\r\n"));
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::GetUserClassID
//
// Purpose:
//
//      Returns the applications CLSID
//
// Parameters:
//
//      CLSID FAR* pClsid   - Out ptr to return the CLSID
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::GetClassID IPS.CPP
//
// Comments:
//
//      This function is just delegated to IPS::GetClassID.
//
//********************************************************************

STDMETHODIMP COleObject::GetUserClassID  ( CLSID FAR* pClsid)
{
    TestDebugOut(TEXT("In COleObject::GetUserClassID\r\n"));

    return ( m_lpObj->m_PersistStorage.GetClassID(pClsid) );
}

//**********************************************************************
//
// COleObject::GetUserType
//
// Purpose:
//
//      Used to get a user presentable id for this object
//
// Parameters:
//
//      DWORD dwFormOfType      - The ID requested
//
//      LPOLESTR FAR* pszUserType  - Out ptr to return the string
//
// Return Value:
//
//      OLE_S_USEREG    - Use the reg db to get these entries.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comment:
//      In this implementation, we delegate to the default handler's
//      implementation using the registration database to provide
//      the requested info.
//
//********************************************************************

STDMETHODIMP COleObject::GetUserType  ( DWORD dwFormOfType,
                                        LPOLESTR FAR* pszUserType)
{
    TestDebugOut(TEXT("In COleObject::GetUserType\r\n"));

    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// COleObject::SetExtent
//
// Purpose:
//
//      Called to set the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - Aspect to have its size set
//
//      LPSIZEL lpsizel     - New size of the object.
//
// Return Value:
//
//      E_NOTIMPL   - This function is not curently implemented.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      See TECHNOTES.WRI include with the OLE SDK for proper
//      implementation of this function.
//
//
//********************************************************************

STDMETHODIMP COleObject::SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    TestDebugOut(TEXT("In COleObject::SetExtent\r\n"));
    return ResultFromScode( E_NOTIMPL);
}

//**********************************************************************
//
// COleObject::EnumAdvise
//
// Purpose:
//
//      Returns an enumerate which enumerates the outstanding advises
//      associated with this OLE object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise - Out ptr in which to return
//                                         the enumerator.
//
// Return Value:
//
//      Passed on from IOleAdviseHolder::EnumAdvise.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IOleAdviseHolder::EnumAdvise    OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    TestDebugOut(TEXT("In COleObject::EnumAdvise\r\n"));
    // need to NULL the out parameter
    *ppenumAdvise = NULL;

    // pass on to the OLE Advise holder.
    return m_lpObj->m_lpOleAdviseHolder->EnumAdvise(ppenumAdvise);
}

//**********************************************************************
//
// COleObject::GetMiscStatus
//
// Purpose:
//
//      Return status information about the object
//
// Parameters:
//
//      DWORD dwAspect          - Aspect interested in.
//
//      DWORD FAR* pdwStatus    - Out ptr in which to return the bits.
//
// Return Value:
//
//      OLE_S_USEREG            - Use the reg db to get these entries.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comment:
//      In this implementation, we delegate to the default handler's
//      implementation using the registration database to provide
//      the requested info.
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus)
{
    TestDebugOut(TEXT("In COleObject::GetMiscStatus\r\n"));
    // need to NULL the out parameter
    *pdwStatus = NULL;
    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// COleObject::SetColorScheme
//
// Purpose:
//
//      Used to set the palette for the object to use.
//
// Parameters:
//
//      LPLOGPALETTE lpLogpal   - Pointer to the LOGPALETTE to be used.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This server ignores this method.
//
//********************************************************************

STDMETHODIMP COleObject::SetColorScheme  ( LPLOGPALETTE lpLogpal)
{
    TestDebugOut(TEXT("In COleObject::SetColorScheme\r\n"));
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::OpenEdit
//
// Purpose:
//
//      Used to Open the object into a seperate window.
//
// Parameters:
//
//      LPOLECLIENTSITE pActiveSite - Pointer to the Active clientsite.
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                        Location
//
//      IOleClientSite::OnShowWindow    Container
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      TestDebugOut               Windows API
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//
//
//********************************************************************

void COleObject::OpenEdit(LPOLECLIENTSITE pActiveSite)
{
   if (m_lpObj->GetOleClientSite())
       m_lpObj->GetOleClientSite()->ShowObject();


    m_fOpen = TRUE;

    // tell the site we are opening so the object can be hatched out.
    if (m_lpObj->GetOleClientSite())
        m_lpObj->GetOleClientSite()->OnShowWindow(TRUE);


    m_lpObj->m_lpDoc->ShowDocWnd();

    m_lpObj->m_lpDoc->HideHatchWnd();

    // Show app window.
    m_lpObj->m_lpDoc->GetApp()->ShowAppWnd();

    SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\ips.cpp ===
//**********************************************************************
// File name: ips.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See ips.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ips.h"
#include "app.h"
#include "doc.h"

DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);

//**********************************************************************
//
// CPersistStorage::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CPersistStorage::QueryInterface\r\n"));
    // need to NULL the out parameter
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CPersistStorage::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. Since CPersistStorage
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for CPersistStorage. We can safely use the reference count of
//      CSimpSvrObj.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::AddRef ()
{
    TestDebugOut(TEXT("In CPersistStorage::AddRef\r\n"));
    return m_lpObj->AddRef();
}

//**********************************************************************
//
// CPersistStorage::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. Since CPersistStorage
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for CPersistStorage. We can safely use the reference count of
//      CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::Release ()
{
    TestDebugOut(TEXT("In CPersistStorage::Release\r\n"));
    return m_lpObj->Release();
}

//**********************************************************************
//
// CPersistStorage::InitNew
//
// Purpose:
//
//      Used to give a new OLE object a ptr to its storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Pointer to the storage
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStorage::AddRef            OLE
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::InitNew (LPSTORAGE pStg)
{
    TestDebugOut(TEXT("In CPersistStorage::InitNew\r\n"));

    // release any streams and storages that may be open
    ReleaseStreamsAndStorage();

    m_lpObj->m_lpStorage = pStg;

    // AddRef the new Storage
    if (m_lpObj->m_lpStorage)
	m_lpObj->m_lpStorage->AddRef();

    CreateStreams(m_lpObj->m_lpStorage);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// CPersistStorage::GetClassID
//
// Purpose:
//
//      Returns the CLSID of this object.
//
// Parameters:
//
//      LPCLSID lpClassID   - Out ptr in which to return the CLSID
//
// Return Value:
//
//       S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::GetClassID  ( LPCLSID lpClassID)
{
     TestDebugOut(TEXT("In CPersistStorage::GetClassID\r\n"));

    *lpClassID = GUID_SIMPLE;

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::Save
//
// Purpose:
//
//      Instructs the object to save itself into the storage.
//
// Parameters:
//
//      LPSTORAGE pStgSave  - Storage in which the object should be saved
//
//      BOOL fSameAsLoad    - TRUE if pStgSave is the same as the storage
//                            that the object was originally created with.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::InitNew    IPS.CPP
//      CSimpSvrObj::SaveToStorage  OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad)
{
    TestDebugOut(TEXT("In CPersistStorage::Save\r\n"));

    // save the data
    m_lpObj->SaveToStorage (pStgSave, fSameAsLoad);

    m_lpObj->m_fSaveWithSameAsLoad = fSameAsLoad;
    m_lpObj->m_fNoScribbleMode = TRUE;

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::SaveCompleted
//
// Purpose:
//
//      Called when the container is finished saving the object
//
// Parameters:
//
//      LPSTORAGE pStgNew   - ptr to the new storage
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::SaveCompleted  ( LPSTORAGE pStgNew)
{
    TestDebugOut(TEXT("In CPersistStorage::SaveCompleted\r\n"));

    if (pStgNew)
	{
	ReleaseStreamsAndStorage();
	m_lpObj->m_lpStorage = pStgNew;
	m_lpObj->m_lpStorage->AddRef();
	OpenStreams(pStgNew);
	}


    /* OLE2NOTE: it is only legal to perform a Save or SaveAs operation
    **    on an embedded object. if the document is a file-based document
    **    then we can not be changed to a IStorage-base object.
    **
    **      fSameAsLoad   lpStgNew     Type of Save     Send OnSave
    **    ---------------------------------------------------------
    **         TRUE        NULL        SAVE             YES
    **         TRUE        ! NULL      SAVE *           YES
    **         FALSE       ! NULL      SAVE AS          YES
    **         FALSE       NULL        SAVE COPY AS     NO
    **
    **    * this is a strange case that is possible. it is inefficient
    **    for the caller; it would be better to pass lpStgNew==NULL for
    **    the Save operation.
    */

    if ( pStgNew || m_lpObj->m_fSaveWithSameAsLoad)
	{
	if (m_lpObj->m_fNoScribbleMode)
	    if (
		m_lpObj->GetOleAdviseHolder()->SendOnSave()!=S_OK
					       // normally would clear a
												  // dirty bit
	       )
	       TestDebugOut(TEXT("SendOnSave fails\n"));
		m_lpObj->m_fSaveWithSameAsLoad = FALSE;
		}
	
	m_lpObj->m_fNoScribbleMode = FALSE;
												
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::Load
//
// Purpose:
//
//      Instructs the object to be loaded from storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Ptr to the storage in which to be loaded
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::LoadFromStorage    OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Load  ( LPSTORAGE pStg)
{
    TestDebugOut(TEXT("In CPersistStorage::Load\r\n"));

    // remember the storage
    if (m_lpObj->m_lpStorage)
	{
	m_lpObj->m_lpStorage->Release();
	m_lpObj->m_lpStorage = NULL;
	}

    m_lpObj->m_lpStorage = pStg;

    m_lpObj->m_lpStorage->AddRef();

    OpenStreams(m_lpObj->m_lpStorage);

    m_lpObj->LoadFromStorage();


    return ResultFromScode( S_OK );
}


//**********************************************************************
//
// CPersistStorage::IsDirty
//
// Purpose:
//
//      Returns whether or not the object is dirty w/respect to its
//      Storage
//
// Parameters:
//
//      None
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This sample does not implement this function, although a
//      real application should.
//
//********************************************************************

STDMETHODIMP CPersistStorage::IsDirty()
{
    TestDebugOut(TEXT("In CPersistStorage::IsDirty\r\n"));
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::HandsOffStorage
//
// Purpose:
//
//      Forces the object to release its handle to its storage.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
//********************************************************************

STDMETHODIMP CPersistStorage::HandsOffStorage  ()
{
    TestDebugOut(TEXT("In CPersistStorage::HandsOffStorage\r\n"));

    ReleaseStreamsAndStorage();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates the streams that are held open for the object's lifetime.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to create the streams
//
// Return Value:
//
//      none
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStream::Release            OLE
//      IStorage::CreateStream      OLE
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg)
{
    if (m_lpObj->m_lpColorStm)
	m_lpObj->m_lpColorStm->Release();

    if (m_lpObj->m_lpSizeStm)
	m_lpObj->m_lpSizeStm->Release();

    // create a stream to save the colors
    if (
	 lpStg->CreateStream ( OLESTR("RGB"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			   0,
			   0,
			   &m_lpObj->m_lpColorStm)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));

    // create a stream to save the size
    if (
	 lpStg->CreateStream ( OLESTR("size"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			   0,
			   0,
			   &m_lpObj->m_lpSizeStm)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));
}

//**********************************************************************
//
// CPersistStorage::OpenStreams
//
// Purpose:
//
//      Opens the streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to open the streams.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStream::Release            OLE
//      IStorage::OpenStream        OLE
//
//
//********************************************************************

void CPersistStorage::OpenStreams(LPSTORAGE lpStg)
{
    if (m_lpObj->m_lpColorStm)
	m_lpObj->m_lpColorStm->Release();

    if (m_lpObj->m_lpSizeStm)
	m_lpObj->m_lpSizeStm->Release();

    // open the color stream
    if (
       lpStg->OpenStream ( OLESTR("RGB"),
			   0,
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			   0,
			   &m_lpObj->m_lpColorStm)
       !=S_OK
       )
       TestDebugOut(TEXT("OpenStream fails\n"));


    // open the color stream
    if (
       lpStg->OpenStream ( OLESTR("size"),
			   0,
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			   0,
			   &m_lpObj->m_lpSizeStm)
       !=S_OK
       )
       TestDebugOut(TEXT("OpenStream fails\n"));

}

//**********************************************************************
//
// CPersistStorage::ReleaseStreamsAndStorage
//
// Purpose:
//
//      Releases the stream and storage ptrs
//
// Parameters:
//
//      None
//
// Return Value:
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStream::Release            OLE
//      IStorage::Release           OLE
//
//********************************************************************

void CPersistStorage::ReleaseStreamsAndStorage()
{
    if (m_lpObj->m_lpColorStm)
	{
	m_lpObj->m_lpColorStm->Release();
	m_lpObj->m_lpColorStm = NULL;
	}

    if (m_lpObj->m_lpSizeStm)
	{
	m_lpObj->m_lpSizeStm->Release();
	m_lpObj->m_lpSizeStm = NULL;
	}

    if (m_lpObj->m_lpStorage)
	{
	m_lpObj->m_lpStorage->Release();
	m_lpObj->m_lpStorage = NULL;
	}
}

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates temporary streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg                 - Pointer to the storage
//
//      LPSTREAM FAR* lplpTempColor     - Color Stream
//
//      LPSTREAM FAR* lplpTempSize      - Size Stream
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg,
				    LPSTREAM FAR* lplpTempColor,
				    LPSTREAM FAR* lplpTempSize)
{
     // create a stream to save the colors
    if (
       lpStg->CreateStream ( OLESTR("RGB"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE |
			   STGM_CREATE,
			   0,
			   0,
			   lplpTempColor)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));

    // create a stream to save the size
    if (
       lpStg->CreateStream ( OLESTR("size"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE |
			   STGM_CREATE,
			   0,
			   0,
			   lplpTempSize)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\obj.h ===
//**********************************************************************
// File name: obj.h
//
//      Definition of CSimpSvrObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _OBJ_H_)
#define _OBJ_H_

#include "ioipao.h"
#include "ioipo.h"
#include "ioo.h"
#include "ips.h"
#include "ido.h"
#include "iec.h"

class CSimpSvrDoc;
interface COleObject;
interface CPersistStorage;
interface CDataObject;
interface COleInPlaceActiveObject;
interface COleInPlaceObject;
interface CExternalConnection;

class CSimpSvrObj : public IUnknown
{
private:
    CSimpSvrDoc FAR * m_lpDoc;      // Back pointer
    int m_nCount;                   // reference count
    BOOL m_fInPlaceActive;          // Used during InPlace Negotiation
    BOOL m_fInPlaceVisible;         // "  "  "  "   "   "   "   "   "
    BOOL m_fUIActive;               // "  "  "  "   "   "   "   "   "
    HMENU m_hmenuShared;            // "  "  "  "   "   "   "   "   "
    HOLEMENU m_hOleMenu;            // "  "  "  "   "   "   "   "   "
    RECT m_posRect;                 // "  "  "  "   "   "   "   "   "
    OLEINPLACEFRAMEINFO m_FrameInfo;
    BOOL m_fSaveWithSameAsLoad;
    BOOL m_fNoScribbleMode;

    DWORD m_dwRegister;             // Registered in ROT

    int m_red, m_green, m_blue;     // current color
    POINT m_size;                   // current size
    int m_xOffset;
    int m_yOffset;
    float m_scale;

    HWND m_hWndParent;              // parent window handle

    // interfaces used
    LPSTORAGE m_lpStorage;
    LPSTREAM m_lpColorStm, m_lpSizeStm;
    LPOLECLIENTSITE m_lpOleClientSite;          // IOleClientSite
    LPOLEADVISEHOLDER m_lpOleAdviseHolder;      // IOleAdviseHolder
    LPDATAADVISEHOLDER m_lpDataAdviseHolder;    // IDataAdviseHolder
    LPOLEINPLACEFRAME m_lpFrame;                // IOleInPlaceFrame
    LPOLEINPLACEUIWINDOW m_lpCntrDoc;           // IOleInPlaceUIWindow
    LPOLEINPLACESITE m_lpIPSite;                // IOleInPlaceSite

    // interface implemented
    COleObject m_OleObject;                             // IOleObject
    CPersistStorage m_PersistStorage;                   // IPersistStorage
    CDataObject m_DataObject;                           // IDataObject
    COleInPlaceActiveObject m_OleInPlaceActiveObject;   // IOleInPlaceActiveObject
    COleInPlaceObject m_OleInPlaceObject;               // IOleInPlaceObject
    CExternalConnection m_ExternalConnection;

public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

// construction/destruction
    CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc);
    ~CSimpSvrObj();

// utility functions
    void Draw(HDC hDC, BOOL fMetaDC = TRUE);
    void PaintObj(HDC hDC);
    void lButtonDown(WPARAM wParam,LPARAM lParam);
    HANDLE GetMetaFilePict();
    void SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad);
    void LoadFromStorage ();

// visual editing helper functions
    BOOL DoInPlaceActivate (LONG lVerb);
    void AssembleMenus();
    void AddFrameLevelUI();
    void DoInPlaceHide();
    void DisassembleMenus();
    void SendOnDataChange();
    void DeactivateUI();

// member variable access
    inline BOOL IsInPlaceActive() { return m_fInPlaceActive; };
    inline BOOL IsInPlaceVisible() { return m_fInPlaceVisible; };
    inline BOOL IsUIActive() { return m_fUIActive; };
    inline HWND GetParent() { return m_hWndParent; };
    inline LPSTORAGE GetStorage() { return m_lpStorage; };
    inline LPOLECLIENTSITE GetOleClientSite() { return m_lpOleClientSite; };
    inline LPDATAADVISEHOLDER GetDataAdviseHolder() { return m_lpDataAdviseHolder; };
    inline LPOLEADVISEHOLDER GetOleAdviseHolder() { return m_lpOleAdviseHolder; };
    inline LPOLEINPLACEFRAME GetInPlaceFrame() { return m_lpFrame; };
    inline LPOLEINPLACEUIWINDOW GetUIWindow() { return m_lpCntrDoc; };
    inline LPOLEINPLACESITE GetInPlaceSite() { return m_lpIPSite; };
    inline COleObject FAR * GetOleObject() { return &m_OleObject; };
    inline CPersistStorage FAR * GetPersistStorage() { return &m_PersistStorage; };
    inline CDataObject FAR * GetDataObject() { return &m_DataObject; };
    inline COleInPlaceActiveObject FAR * GetOleInPlaceActiveObject() { return &m_OleInPlaceActiveObject; };
    inline COleInPlaceObject FAR * GetOleInPlaceObject() { return &m_OleInPlaceObject; };
    inline void ClearOleClientSite() { m_lpOleClientSite = NULL; };
    inline void ClearDataAdviseHolder() { m_lpDataAdviseHolder = NULL; };
    inline void ClearOleAdviseHolder() { m_lpOleAdviseHolder = NULL; };
    inline LPRECT GetPosRect() { return &m_posRect; };
    inline LPPOINT GetSize() { return &m_size; };
    inline LPOLEINPLACEFRAMEINFO GetFrameInfo() {return &m_FrameInfo;};
    inline DWORD GetRotRegister() { return m_dwRegister; };
    inline void ClearDoc() { m_lpDoc = NULL; };

    // member manipulation
    inline void SetColor (int nRed, int nGreen, int nBlue)
        { m_red = nRed; m_green = nGreen; m_blue = nBlue; };

    inline void RotateColor()
        { m_red+=10; m_green+=10; m_blue+=10;};


// all of the interface implementations should be friends of this
// class
friend interface COleObject;
friend interface CPersistStorage;
friend interface CDataObject;
friend interface COleInPlaceActiveObject;
friend interface COleInPlaceObject;
friend interface CExternalConnection;

};
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPSVR.RC
//
#define IDM_OPEN                        102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_RED                         113
#define IDM_GREEN                       114
#define IDM_BLUE                        115
#define IDM_COLOROWNERDR                116

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         117
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cbasecmd.cxx ===
//+------------------------------------------------------------------
//
// File:        cbasecmd.cxx
//
// Contents:    implementation for CBaseCmdlineObj
//
// Synoposis:   CBaseCmdlineObj encapsulates a single command line
//              switch, eg. /username:lizch. It specifies the switch
//              string (username) and stores the value (lizch) as
//              a string. This class also provides methods for
//              retrieving the value, displaying it and setting it
//              to a default, and displaying usage for this switch.
//
// Classes:     CBaseCmdlineObj
//
// Functions:
//
// History:     12/27/91    Lizch       Created
//              04/17/92    Lizch       Converted to NLS_STR
//              28 Aug 92   GeordiS     changed nlsNULL to nlsNULLSTR
//              31 Aug 92   GeordiS     changed nlsNULLSTR back.
//              09/09/92    Lizch       Changed SUCCESS and NERR_Success
//                                      to NO_ERROR
//              09/18/92    Lizch       Precompile headers
//              11/14/92    DwightKr    Updates for new version of NLS_STR
//              10/13/93    DeanE       Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


LPCNSTR nszCmdlineBase = _TEXTN("Takes a string ");
LPCNSTR nszLineArgBase = _TEXTN("<string> ");


//+------------------------------------------------------------------
//
// Function:    CBaseCmdlineObj Constructor (1 of 2)
//
// Member:      CBaseCmdlineObj
//
// Synoposis:   Initialises switch string, usage values and whether the
//              switch is mandatory. This constructor gives no default value
//              for this switch.
//
// Arguments:   [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [fMustHave]  - whether the switch is mandatory or not.
//                             if it is, an error will be generated if
//                             the switch is not specified on the
//                             command line. Defaults to FALSE.
//              [nszLineArg] - line arg
//
// Returns:     none, but sets _iLastError
//
// History:     Created 04/17/92 Lizch
//
//-------------------------------------------------------------------
CBaseCmdlineObj::CBaseCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        BOOL   fMustHave,
        LPCNSTR nszLineArg)
{
    Init(nszSwitch, nszUsage, fMustHave, _TEXTN(""), nszLineArg);
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdlineObj Constructor (2 of 2)
//
// Member:      CBaseCmdlineObj
//
// Synoposis:   Initialises switch string, usage strings and default value.
//              This constructor is only used if a switch is optional.
//
// Effects:    Sets fMandatory to FALSE (ie. switch is optional)
//
// Arguments:   [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [nszDefault] - the value to be used if no switch is
//                             specified on the command line.
//              [nszLineArg] - line arg
//
// Returns:     none, but sets _iLastError
//
// History:     Created 04/17/92 Lizch
//
//-------------------------------------------------------------------
CBaseCmdlineObj::CBaseCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        LPCNSTR nszDefault,
        LPCNSTR nszLineArg)
{
    Init(nszSwitch, nszUsage, FALSE, nszDefault, nszLineArg);
    _fDefaultSpecified = TRUE;
}


//+------------------------------------------------------------------
//
// Function:    Init
//
// Member:      Private, called from constructors for CBaseCmdlineObj
//
// Synoposis:   Sets defaults for members and allocates memory
//              for switch string.
//
// Arguments:   [nszSwitch]  - the expected command line switch
//              [nszUsage]   - the usage statement for display
//              [fMustHave]  - whether the switch is mandatory or not.
//                             if it is, an error will be generated if
//                             the switch is not specified on the
//                             command line. Defaults to FALse
//              [nszDefault] - the value to be used if no switch is
//                             specified on the command line.
//              [nszLineArg] - line arg.
//
// Returns:     Nothing
//
// Modifies:    Out of memory error, or CMDLINE_NO_ERROR
//
// History:     12/29/91    Lizch   Created.
//              04/17/92    Lizch   Converted to NLS_STR
//              7/14/92     DeanE   Initialized _fFoundSwitch
//              07/31/92    Davey   Added _fSecondArg and _pnlsLineArgType,
//                                  and added nlsLineArg parameter.
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::Init(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        BOOL   fMustHave,
        LPCNSTR nszDefault,
        LPCNSTR nszLineArg)
{
    SetError(CMDLINE_NO_ERROR);

    // Initialize member variables
    _pValue            = NULL;
    _fMandatory        = fMustHave;
    _fDefaultSpecified = FALSE;
    _fSecondArg        = TRUE;
    _fFoundSwitch      = FALSE;

    SetSeparator(nchDefaultSep);
    SetEquater(nchDefaultEquater);

    // Allocate space and initialize member strings
    _pnszUsageString = new NCHAR[_ncslen(nszUsage)+1];
    if (_pnszUsageString == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        _ncscpy(_pnszUsageString, nszUsage);
    }

    _pnszSwitch = new NCHAR[_ncslen(nszSwitch)+1];
    if (_pnszSwitch == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        _ncscpy(_pnszSwitch, nszSwitch);
    }

    _pnszDefaultValue = new NCHAR[_ncslen(nszDefault)+1];
    if (NULL == _pnszDefaultValue)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        _ncscpy(_pnszDefaultValue, nszDefault);
    }

    // if the passed in linearg is NULL then use default one, use
    // NULL to keep arguments consistent in parameter lists.
    //
    if (nszLineArg == NULL)
    {
        _pnszLineArgType = NULL;
    }
    else
    {
        _pnszLineArgType = new NCHAR[_ncslen(nszLineArg)+1];
        if (NULL == _pnszLineArgType)
        {
            SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        }
        else
        {
            _ncscpy(_pnszLineArgType, nszLineArg);
        }
    }
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj destructor
//
// Synoposis:   Frees any memory associated with the object
//
// History:     12/27/91 Lizch  Created.
//              04/17/92 Lizch  Changed to NLS_STR.
//              08/03/92 Davey  Added delete of _pnlsLineArgType
//
//-------------------------------------------------------------------
CBaseCmdlineObj::~CBaseCmdlineObj()
{
    delete (NCHAR *)_pValue;
    _pValue = NULL;

    delete _pnszUsageString;
    delete _pnszSwitch;
    delete _pnszDefaultValue;
    delete _pnszLineArgType;
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::SetValue, public
//
// Synopsis:    Stores the value specified after the switch string
//              (eg: "lizch" from "/username:lizch").
//
// Arguments:   [nszArg] - the string following the switch on
//                         the command line. Excludes the
//                         equator (eg. ':' in the above example)
//
// Returns:     CMDLINE_NO_ERROR or out of memory
//
// History:     12/27/91 Lizch  Created
//              04/17/92 Lizch  Converted to NLS_STR
//
//-------------------------------------------------------------------
INT CBaseCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT nRet = CMDLINE_NO_ERROR;

    // delete any existing pValue
    delete (NCHAR *)_pValue;
    _pValue = NULL;

    _pValue = new NCHAR[_ncslen(nszArg)+1];
    if (_pValue == NULL)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncscpy((NCHAR *)_pValue, nszArg);
    }

    return(nRet);
}



//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::ResetValue, public
//
// Synopsis:    Deletes the value so the object becomes "clean" again.
//              
//
// Returns:     CMDLINE_NO_ERROR or out of memory
//
// History:     06/13/97 MariusB  Created
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::ResetValue()
{
    if (NULL != _pValue)
	{
		delete _pValue;
		_pValue = NULL;
	}
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::SetValueToDefault, public
//
// Synopsis:    Sets the default value for the switch. This value is
//              used if no switch is specified on the command line.
//
// Effects:     This is the base implementation for the virtual
//              method SetValueToDefault. It simply calls SetValue.
//              Derived classes may need to do more complex things,
//              eg, the default may be the name of the Domain Controller,
//
// Arguments:   none
//
// Returns:     CMDLINE_NO_ERROR or out of memory
//
// History:     Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
INT CBaseCmdlineObj::SetValueToDefault()
{
    return(SetValue(_pnszDefaultValue));
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::GetValue, public
//
// Synopsis:    Returns a pointer to the switch value
//
// Arguments:   none
//
// Returns:     a const CHAR pointer to the switch value, not including
//              the equater character
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::GetValue()
{
    return((LPCNSTR)_pValue);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::IsFound, public
//
// Synopsis:    Indicates whether this command line switch was found.
//
// Arguments:   none
//
// Returns:     TRUE if the switch was found, FALSE otherwise
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
BOOL CBaseCmdlineObj::IsFound()
{
    return(_fFoundSwitch);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::SetFoundFlag, public
//
// Synopsis:    Sets whether this command line switch was found.
//
// Arguments:   TRUE if switch is found, FALSE otherwise
//
// Returns:     nothing
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::SetFoundFlag(BOOL fFound)
{
    _fFoundSwitch = fFound;
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::IsRequired, public
//
// Synopsis:    Indicates whether this command line switch is mandatory.
//
// Arguments:   none
//
// Returns:     TRUE if the switch was manadatory, FALSE otherwise
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
BOOL CBaseCmdlineObj::IsRequired ()
{
    return(_fMandatory);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::IsDefaultSpecified, public
//
// Synopsis:    Indicates whether this command line switch has a default
//              value.
//
// Arguments:   none
//
// Returns:     TRUE if the switch has a default, FALSE otherwise
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
BOOL CBaseCmdlineObj::IsDefaultSpecified ()
{
    return(_fDefaultSpecified);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::SetSeparator, public
//
//  Synoposis:  Sets the valid switch separator character, i.e.
//              the '/' in /a:foo
//
//  Arguments:  [nchSeparator] - the new separator character
//
//  Returns:    Previous separator.
//
//  History:    05/23/91 Lizch  Created.
//              08/10/92 Davey  Changed to take only one char., added
//                              return of error code
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::SetSeparator(NCHAR nchSeparator)
{
    NCHAR nchOld = _nchSeparator;

    _nchSeparator = nchSeparator;

    return(nchOld);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::SetEquater, public
//
//  Synoposis:  Sets the set of valid equater characters, i.e.
//              the ':' in /a:foo
//
//  Arguments:  [nchEquater] - the new equater character
//
//  Returns:    Previous equater.
//
//  History:    05/23/91 Lizch  Created.
//              08/10/92 Davey  Changed to take only one char., added
//                              return of error code
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::SetEquater(NCHAR nchEquater)
{
    NCHAR nchOld = _nchEquater;

    _nchEquater = nchEquater;

    return(nchOld);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::GetSeparator, public
//
//  Synoposis:  Returns the separator character for this object.
//
//  Arguments:  None
//
//  Returns:    Current separator character.
//
//  History:    10/17/93    DeanE   Created
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::GetSeparator()
{
    return(_nchSeparator);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::GetEquater, public
//
//  Synoposis:  Returns the equater character for this object.
//
//  Arguments:  None
//
//  Returns:    Current equater character.
//
//  History:    10/17/93    DeanE   Created
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::GetEquater()
{
    return(_nchEquater);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::QuerySwitchString, public
//
// Synopsis:    Returns a pointer to the switch string, eg. the "mc" in
//              /mc:foo
//
// Arguments:   none
//
// Returns:     a const NCHAR pointer to the switch string
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::QuerySwitchString()
{
    return(_pnszSwitch);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::DisplayValue, public
//
// Synoposis:   Prints the stored command line value according to
//              current display method.  Generally this will be to stdout.
//
// History:     Created          12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        _sNprintf(_nszErrorBuf,
                 _TEXTN("Command line switch %s has value %s\n"),
                 _pnszSwitch,
                 (NCHAR *)_pValue);
        (*_pfnDisplay)(_nszErrorBuf);
    }
    else
    {
        DisplayNoValue();
    }
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::DisplayNoValue, protected
//
//  Synoposis:  Displays a "no value set" message.
//
//  History:    Created          05/14/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::DisplayNoValue()
{
      _sNprintf(_nszErrorBuf,
               _TEXTN("No value for command line switch %s\n"),
               _pnszSwitch);
      (*_pfnDisplay)(_nszErrorBuf);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::DisplaySpecialUsage, protected
//
//  Synoposis:  Outputs special usage - for base class there is none.
//
//  History:    Created          05/14/92 Lizch
//
//-------------------------------------------------------------------
INT CBaseCmdlineObj::DisplaySpecialUsage(
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    return(CMDLINE_NO_ERROR);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR * reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineBase);
}

//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR *reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgBase);
    }
    else
    {
        return(_pnszLineArgType);
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayUsageLine, protected
//
//  Synopsis:   Displays line usage information
//
//  Arguments:  [pusWidth]       - How much space is left on line to display
//                                 the usage.
//              [usDisplayWidth] - Max width allowed to display usage
//              [usIndent]       - Amount to indent for next line of usage
//
//  History:    28-Jul-92  davey    Created.
//
//  Notes:      Looks like:
//
//              test2 /mc:<worker> [/ml:<log_server>] [/mt:<test>]
//              [/mn:<tester-email>] [/mp:<path>] [/mo:<obj_name>]
//              [/md:<dispatcher>] [/?]
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayUsageLine(
        USHORT *pusWidth,
        USHORT  usDisplayWidth,
        USHORT  usIndent)
{
    INT    nRet            = CMDLINE_NO_ERROR;
    LPNSTR  pnszLine        = NULL;
    ULONG  cchLine;
    LPCNSTR nszLeftBracket  = _TEXTN("[");
    LPCNSTR nszRightBracket = _TEXTN("]");
    LPCNSTR nszType         = QueryLineArgType();
    NCHAR  nszSeparator[2];
    NCHAR  nszEquater[2];

    // Initialize separator and equater strings
    nszSeparator[0] = _nchSeparator;
    nszSeparator[1] = nchClNull;

    nszEquater[0] = _nchEquater;
    nszEquater[1] = nchClNull;

    // Determine length of the display line - Add one for terminating NULL
    cchLine = 1 + _ncslen(nszSeparator) + _ncslen(_pnszSwitch);

    if (FALSE == _fMandatory)
    {
        cchLine += _ncslen(nszLeftBracket) + _ncslen(nszRightBracket);
    }

    if (TRUE == _fSecondArg)
    {
        cchLine += _ncslen(nszEquater) + _ncslen(nszType);
    }

    // Build the display line
    pnszLine = new NCHAR[cchLine];
    if (NULL == pnszLine)
    {
        return(CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    *pnszLine = nchClNull;
    if (FALSE == _fMandatory)
    {
        _ncscat(pnszLine, nszLeftBracket);
    }

    _ncscat(pnszLine, nszSeparator);
    _ncscat(pnszLine, _pnszSwitch);

    if (TRUE == _fSecondArg)
    {
        _ncscat(pnszLine, nszEquater);
        _ncscat(pnszLine, nszType);
    }

    if (FALSE == _fMandatory)
    {
        _ncscat(pnszLine, nszRightBracket);
    }

    nRet = DisplayWord(pnszLine, usDisplayWidth, usIndent, pusWidth);

    // Clean up and exit
    delete pnszLine;

    return(nRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayUsageDescr, protected
//
//  Synopsis:   Displays switch descriptions information
//
//  Arguments:  [usSwitchIndent] - Amount to indent for switches
//              [usDisplayWidth] - Max width allowed to display usage
//              [usUsageIndent]  - Amount to indent for next line of usage
//
//  History:    28-Jul-92  davey    Created.
//
//  Notes:      looks like.
//
//  /mc         Takes a list of strings specifying worker names.
//              These workers should have full names.
//              Don't you think so?
//              The strings in the list are separated by one of the following
//              character(s): ",; ".
//  /ml         Takes a string specifying log server name.
//  /mt         Takes a string specifying name of the test.
//  /mn         Takes a string specifying email name of the tester.
//  /mp         Takes a string specifying path name to log to.
//  /mo         Takes a string specifying name of the object.
//  /md         Takes a string specifying name of the dispatcher to use.
//  /?          Flag specifying command line usage. It defaults to FALSE.
//
//  Here's how the various indent values relate to each other:
//
//  <-------------------------usDisplayWidth------------------------->
//  <--usSwitchIndent-->/foo
//  <--------usUsageIndent----->Takes a list...
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayUsageDescr(
        USHORT usSwitchIndent,
        USHORT usDisplayWidth,
        USHORT usUsageIndent)
{
    INT    iRC;
    LPNSTR  pnszSwitch;
    LPNSTR  pnszUsage;
    LPNSTR  pnszDefault      = NULL;
    USHORT cchUsage;
    USHORT cchSwitch;
    USHORT cchPaddedSwitch;
    USHORT usLineSpaceLeft;
    LPCNSTR nszSpecify       = _TEXTN("specifying ");
    LPCNSTR nszDefault       = _TEXTN("It defaults to ");
    LPCNSTR nszType          = QueryCmdlineType();
    NCHAR  nszSeparator[2];

    // Initialize separator string
    nszSeparator[0] = _nchSeparator;
    nszSeparator[1] = nchClNull;

    // Calculate size of switch buffer - if this length is less than
    // usUsageIndent then allocate extra room to pad spaces out to
    // usUsageIndent and the usage will start on the same line; else
    // the usage will start on the next line with an indent.  Also,
    // the null-terminator is NOT accounted for in this value.
    //
    cchSwitch = (USHORT) (usSwitchIndent + _ncslen(nszSeparator) 
                               + _ncslen(_pnszSwitch) ) ;
    if (cchSwitch < usUsageIndent)
    {
        cchPaddedSwitch = usUsageIndent;
    }
    else
    {
        cchPaddedSwitch = (USHORT) (cchSwitch + usUsageIndent 
                                    + _ncslen(nszClNewLine) );
    }

    // Calculate size of usage buffer - null-terminator NOT accounted for
    //
    cchUsage = (USHORT) (_ncslen(nszType) +
                         _ncslen(nszSpecify) +
                         _ncslen(_pnszUsageString) );


    // Allocate buffers - add 1 for NULL-terminators
    pnszSwitch = new NCHAR[cchPaddedSwitch+1];
    pnszUsage  = new NCHAR[cchUsage+1];
    if (pnszSwitch == NULL || pnszUsage == NULL)
    {
        delete pnszSwitch;
        delete pnszUsage;
        return(CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    // Initialize switch buffer - fill with usSwitchIndent spaces, then
    // append the separator and switch, then pad with spaces out to
    // usUsageIndent if necessary
    //
    for (USHORT i=0; i<usSwitchIndent; i++)
    {
        pnszSwitch[i] = nchClSpace;
    }

    pnszSwitch[usSwitchIndent] = nchClNull;
    _ncscat(pnszSwitch, nszSeparator);
    _ncscat(pnszSwitch, _pnszSwitch);

    if ((USHORT)_ncslen(pnszSwitch) >= usUsageIndent)
    {
        // Pad a new line.
        _ncscat(pnszSwitch, nszClNewLine);
    }
    // Pad spaces until usUsageIndemt
    for (i = (USHORT) _ncslen(pnszSwitch); i < cchPaddedSwitch; i++)
    {
        pnszSwitch[i] = nchClSpace;
    }
    pnszSwitch[cchPaddedSwitch] = nchClNull;

    // Initialize usage buffer
    _ncscpy(pnszUsage, nszType);
    _ncscat(pnszUsage, nszSpecify);
    _ncscat(pnszUsage, _pnszUsageString);

    // Now we're ready to output the strings - output the switch, then
    // set up the values needed to output the usage line.
    //
    (*_pfnDisplay)(pnszSwitch);
    usLineSpaceLeft = (USHORT) (usDisplayWidth - usUsageIndent);

    // Output the usage
    iRC = DisplayStringByWords(
                 pnszUsage,
                 usDisplayWidth,
                 usUsageIndent,
                 &usLineSpaceLeft);
    if (iRC != CMDLINE_NO_ERROR)
    {
        delete pnszSwitch;
        delete pnszUsage;
        return(iRC);
    }


    // output the special usage
    //
    iRC = DisplaySpecialUsage(usDisplayWidth, usUsageIndent, &usLineSpaceLeft);
    if (iRC != CMDLINE_NO_ERROR)
    {
        delete pnszSwitch;
        delete pnszUsage;
        return(iRC);
    }


    // output the default value string
    //
    if (_fDefaultSpecified)
    {
        // Default string is "  " + nszDefault + _pnszDefaultValue + "."
        pnszDefault = new NCHAR[_ncslen(_pnszDefaultValue) +
                                            _ncslen(nszDefault) + 4];
        if (pnszDefault == NULL)
        {
            iRC = CMDLINE_ERROR_OUT_OF_MEMORY;
        }
        else
        {
            _ncscpy(pnszDefault, _TEXTN("  "));
            _ncscat(pnszDefault, nszDefault);
            _ncscat(pnszDefault, _pnszDefaultValue);
            _ncscat(pnszDefault, _TEXTN("."));

            iRC = DisplayStringByWords(
                         pnszDefault,
                         usDisplayWidth,
                         usUsageIndent,
                         &usLineSpaceLeft);
        }

        if (iRC != CMDLINE_NO_ERROR)
        {
            delete pnszDefault;
            delete pnszSwitch;
            delete pnszUsage;
            return(iRC);
        }
    }


    // Next thing output should go on a new line
    //
    (*_pfnDisplay)(nszClNewLine);

    delete pnszSwitch;
    delete pnszUsage;
    delete pnszDefault;

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayStringByWords, protected
//
//  Synopsis:   Writes out the strings word by word following indentation
//              and display width rules; words are delimeted by spaces.
//              The string begins on the current line at the current
//              location (usDisplayWidth-*pusSpaceLeft), including
//              any leading space characters.
//
//  Arguments:  [nszString]      - String to output.
//              [usDisplayWidth] - Max width allowed to display usage
//              [usIndent]       - Amount to indent for next line of usage
//              [pusSpaceLeft]   - Space left on this line
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayStringByWords(
        LPCNSTR  nszString,
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusSpaceLeft)
{
    INT    iRC      = CMDLINE_NO_ERROR;
    BOOL   fDone    = FALSE;
    LPNSTR  pnszWord = NULL;
    LPCNSTR pnchWord = nszString;
    LPCNSTR pnchTrav = nszString;
    USHORT i;

    // Skip leading spaces, but they are part of the first word
    while (nchClSpace == *pnchTrav)
    {
        pnchTrav++;
    }

    // Traverse the string until we get to the end
    while (!fDone)
    {
        // Traverse until we find a space, newline, or null
        switch(*pnchTrav)
        {
            case L' ':
                // Retrieve the word from the string
                iRC = CopyWord(pnchWord, pnchTrav-pnchWord, &pnszWord);
                if (iRC == CMDLINE_NO_ERROR)
                {
                    // Output the word
                    iRC = DisplayWord(
                                 pnszWord,
                                 usDisplayWidth,
                                 usIndent,
                                 pusSpaceLeft);
                }
                delete pnszWord;

                //Set up the next word
                pnchWord = pnchTrav++;

                // traverse to next non-space character
                while (nchClSpace == *pnchTrav)
                {
                    pnchTrav++;
                }
                break;

            case L'\n':
                // Retrieve the word from the string, including the newline
                iRC = CopyWord(pnchWord, ++pnchTrav-pnchWord, &pnszWord);
                if (iRC == CMDLINE_NO_ERROR)
                {
                    // Output the word
                    iRC = DisplayWord(
                                 pnszWord,
                                 usDisplayWidth,
                                 usIndent,
                                 pusSpaceLeft);
                }
                delete pnszWord;

                // Output usIndent spaces
                for (i=0; i<usIndent; i++)
                {
                    (*_pfnDisplay)(nszClSpace);
                }
                *pusSpaceLeft = (USHORT) (usDisplayWidth - usIndent);

                // traverse to next non-space character
                while (nchClSpace == *pnchTrav)
                {
                    pnchTrav++;
                }

                // Set up the next word - note leading blanks are skipped
                // so the word will be aligned with the indent
                //
                pnchWord = pnchTrav;
                break;

            case L'\0':
                // Output the current word
                iRC = DisplayWord(
                             pnchWord,
                             usDisplayWidth,
                             usIndent,
                             pusSpaceLeft);
                fDone = TRUE;
                break;

            default:
                // Skip to next character
                pnchTrav++;
                break;
        }

        if (iRC != CMDLINE_NO_ERROR)
        {
            fDone = TRUE;
        }
    }

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::CopyWord, protected
//
//  Synopsis:   Copies cchWord characters starting at pnchWord into a
//              null-terminated string buffer (which the caller must
//              delete).
//
//  Arguments:  [pnchWord]  - place to copy from.
//              [cchWord]   - number of characters to copy.
//              [ppnszWord] - buffer returned to caller.
//
//  History:    15-Oct-93  DeanE    Created.
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::CopyWord(
        LPCNSTR pnchWord,
        ULONG  cchWord,
        LPNSTR *ppnszWord)
{
    INT iRC = CMDLINE_NO_ERROR;

    *ppnszWord = new NCHAR[cchWord+1];
    if (NULL == *ppnszWord)
    {
        iRC = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncsncpy(*ppnszWord, pnchWord, cchWord);
        *(*ppnszWord + cchWord) = nchClNull;
    }

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayWord, protected
//
//  Synopsis:   Writes out the given word according to the display
//              parameters.
//
//  Arguments:  [nszWord]        - word to output.
//              [usDisplayWidth] - Max width allowed to display usage.
//              [usIndent]       - Amount to indent for next line of usage.
//              [pusWidth]       - Space left on this line.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayWord(
        LPCNSTR  nszWord,
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    INT    nRet   = CMDLINE_NO_ERROR;
    LPCNSTR nszTmp = nszWord;
    LPNSTR  pnszBuf;
    USHORT cchWord;
    USHORT cchBuf;
    USHORT cchLine = (USHORT) (usDisplayWidth - usIndent);
    BOOL   fDone   = FALSE;

    // Add one for leading space
    cchWord = (USHORT) _ncslen(nszWord);

    // if there is enough room left on the current line, output word
    //
    if (cchWord <= *pusWidth)
    {
        (*_pfnDisplay)(nszWord);

        // update the remaining width
        *pusWidth = (USHORT) (*pusWidth - cchWord);
    }
    else
    {
        // Spit the word out on the next line, traversing more than
        // one line if necessary
        do
        {
            // Calculate how much of the word can be output
            if (_ncslen(nszTmp) <= cchLine)
            {
                cchBuf = (USHORT) _ncslen(nszTmp);
                fDone  = TRUE;
            }
            else
            {
                cchBuf = cchLine;
            }

            pnszBuf = new NCHAR[cchBuf+1];
            if (NULL == pnszBuf)
            {
                fDone = TRUE;
                nRet  = CMDLINE_ERROR_OUT_OF_MEMORY;
            }
            else
            {
                _ncsncpy(pnszBuf, nszTmp, cchBuf);
                *(pnszBuf+cchBuf) = L'\0';
            }
            nszTmp += cchBuf;

            // Output newline
            (*_pfnDisplay)(nszClNewLine);

            // Indent usIndent spaces
            for (USHORT i=0; i<usIndent; i++)
            {
                (*_pfnDisplay)(nszClSpace);
            }

            // Output buffer
            (*_pfnDisplay)(pnszBuf);

            delete pnszBuf;
        } while (!fDone);

        // Calculate remaining width on the current line
        *pusWidth = (USHORT) (usDisplayWidth - usIndent - cchBuf);
    }

    return(nRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cboolcmd.cxx ===
//+------------------------------------------------------------------
//
// File:        cboolcmd.cxx
//
// Contents:    implementation for CBoolCmdlineObj
//
// Synoposis:   Encapsulates a command line switch which takes a
//              Bool value. If the command line switch is present, the
//              value is set to TRUE, otherwise it is set to FALSE
//
// Classes:     CBoolCmdlineObj
//
// Functions:
//              AsciiToBool                       private, local
//              CBoolCmdlineObj::~CBoolCmdlineObj public
//              CBoolCmdlineObj::DisplayValue     public
//              CBoolCmdlineObj::GetValue         public
//              CBoolCmdlineObj::SetValue         public
//
// History:     06/15/92  DeanE    Created
//              07/29/92  davey    Added nlsType and nlsLineArgType
//              09/09/92  Lizch    Changed SUCCESS to NO_ERROR
//              09/18/92  Lizch    Precompile headers
//              11/14/92  DwightKr Updates for new version of NLS_STR
//              10/14/93  DeanE    Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


INT StringToBool(LPCNSTR nszBool, BOOL *pBool);

LPCNSTR nszCmdlineBool = _TEXTN("Flag ");
LPCNSTR nszLineArgBool = _TEXTN("[TRUE|FALSE] ");

NCHAR nchBoolEquater = _TEXTN(':');

// BUGBUG - base Equater needs to be a string, then the equator for
//   a bool is L'<base equator><space>';
//

//+------------------------------------------------------------------
//
//  Function:   CBoolCmdlineObj Constructor
//
//  Member:     CBoolCmdlineObj
//
//  Synoposis:  Initialises switch string, usage strings and default value.
//
//  Effects:    Sets fSecondArg to FALSE, so that knows there is
//              no argument following switch.
//
//  Arguments:  [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [nszDefault] - the value to be used if no switch is
//                            specified on the command line.  Defaults
//                            to FALSE if not specified.
//
//  Returns:    none, but sets _iLastError
//
//  History:    Created               12/27/91 Lizch
//              Converted to NLS_STR  04/17/92 Lizch
//
//-------------------------------------------------------------------
CBoolCmdlineObj::CBoolCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        LPCNSTR nszDefault) :
        CBaseCmdlineObj(nszSwitch, nszUsage, nszDefault)
{
    _fSecondArg = TRUE;
    SetEquater(nchBoolEquater);
}


//+------------------------------------------------------------------
//
//  Member:     CBoolCmdlineObj::SetValue, public
//
//  Synposis:   Sets _pValue to point to the proper value of the switch
//
//  Arguments:  [nszString] - the string following the switch on the
//                            command line. Includes the equator (eg. ':'
//                            or '=' ), if any. It is ignored for this
//                            command line type.
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_OUT_OF_MEMORY
//
//  History:    Created   6/15/92  DeanE  Stolen from Security implementation
//
//-------------------------------------------------------------------
INT CBoolCmdlineObj::SetValue(LPCNSTR nszString)
{
    INT nRet = CMDLINE_NO_ERROR;

    // Delete old value if it exists
    delete (BOOL *)_pValue;
    _pValue = NULL;

    // Allocate space for a new value and initialize it
    _pValue = new BOOL;
    if (_pValue == NULL)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        nRet = StringToBool(nszString, (BOOL *)_pValue);
        if (nRet != CMDLINE_NO_ERROR)
        {
            delete (BOOL *)_pValue;
            _pValue = NULL;
        }
    }

    return(nRet);
}


//+------------------------------------------------------------------
//
// Member:      CBoolCmdlineObj::GetValue, public
//
// Synposis:    Returns pointer to BOOL that has the value.
//
// Arguments:   void
//
// Returns:     BOOL *
//
// History:     Created   6/15/92  DeanE  Stolen from Security implementation
//
//-------------------------------------------------------------------
const BOOL *CBoolCmdlineObj::GetValue()
{
    return((BOOL *)_pValue);
}


//+------------------------------------------------------------------
//
// Member:      CBoolCmdlineObj::DisplayValue, public
//
// Synoposis:   prints the stored command line value according to
//              current display method.  This will generally be to stdout.
//
// History:     6/15/92  DeanE  Stolen from Security implementation
//              7/31/92  davey  Modified to match other cmdline objs.
//
//-------------------------------------------------------------------
void CBoolCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        if (*(BOOL *)_pValue == TRUE)
        {
            _sNprintf(_nszErrorBuf,
                     _TEXTN("Command line switch %s is Set\n"),
                     _pnszSwitch);
        }
        else
        {
            _sNprintf(_nszErrorBuf,
                     _TEXTN("Command line switch %s is Not Set\n"),
                     _pnszSwitch);
        }
    }
    else
    {
            _sNprintf(_nszErrorBuf,
                     _TEXTN("Command line switch %s has no value\n"),
                     _pnszSwitch);
    }

    (*_pfnDisplay)(_nszErrorBuf);
}


//+------------------------------------------------------------------
//
// Member:      CBoolCmdlineObj::~CBoolCmdlineObj, public
//
// Synoposis:   Cleans up CBoolCmdlineObj objects.
//
// History:     Created  6/15/92  DeanE  Stolen from Security implementation
//
//-------------------------------------------------------------------
CBoolCmdlineObj::~CBoolCmdlineObj()
{
    delete (BOOL *)_pValue;
    _pValue = (BOOL *)NULL;
}


//+------------------------------------------------------------------
//
// Function:    StringToBool
//
// Synoposis:   Converts ascii string to the equivalent Boolean value,
//              TRUE for "true", FALSE for "false", or TRUE for a null
//              string or string starting with a space.
//
// Arguments:   [nszBool] - string to convert
//              [pBool]   - pointer to converted boolean
//
// Returns:     CMDLINE_NO_ERROR, CMDLINE_ERROR_INVALID_VALUE
//
// History:     Created                     12/17/91 Lizch
//              Implemented as AsciiToBool  6/15/92  DeanE
//              Renamed StringToBool        10/13/93 DeanE
//
//-------------------------------------------------------------------
INT StringToBool(LPCNSTR nszBool, BOOL *pBool)
{
    INT iRC = CMDLINE_NO_ERROR;

    // If the string given to us is a null string or begins with a space,
    // the function was called from the parser and the command line arg
    // was given (with no value).  We want the value to be TRUE, however.
    //
    if ((nchClNull == *nszBool) || (nchClSpace == *nszBool))
    {
        *pBool = TRUE;
    }
    else
    // Otherwise we set the boolean to a value explicitly based on
    // the string passed, either 'true' or 'false', case insensitive
    //
    if (0 == _ncsicmp(nszBool, nszBoolTrue) ||
        0 == _ncsicmp(nszBool, nszBoolOne))
    {
        *pBool = TRUE;
    }
    else
    if (0 == _ncsicmp(nszBool, nszBoolFalse) ||
        0 == _ncsicmp(nszBool, nszBoolZero))
    {
        *pBool = FALSE;
    }
    else
    {
        iRC = CMDLINE_ERROR_INVALID_VALUE;
    }

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBoolCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBoolCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineBool);
}


//+-------------------------------------------------------------------
//
//  Method:     CBoolCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBoolCmdlineObj::QueryLineArgType() const
{
    LPCNSTR nszRet;

    // if user has not defined one then give default one
    if (NULL == _pnszLineArgType)
    {
        nszRet = nszLineArgBool;
    }
    else
    {
        nszRet = _pnszLineArgType;
    }

    return(nszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\simpsvr.cpp ===
//**********************************************************************
// File name: simpsvr.cpp
//
//      Main source file for the simple OLE 2.0 server
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"
#include <stdlib.h>
#include <testmess.h>

#define MEASUREITEMWIDTH  40
#define MEASUREITEMHEIGHT 40

// This line is needed for the debug utilities in OLE2UI
extern "C" {
    OLEDBGDATA_MAIN(TEXT("SIMPSVR"))
}

BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugStringA(psz);
    }
}

CSimpSvrApp FAR * lpCSimpSvrApp;
CClassFactory FAR * lpClassFactory;

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::CSimpSvrApp          APP.CPP
//      CSimpSvrApp::fInitApplication    APP.CPP
//      CSimpSvrApp::fInitInstance       APP.CPP
//      CSimpSvrApp::HandleAccelerators  APP.CPP
//      CSimpSvrApp::~CSimpSvrApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
//
//********************************************************************

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#endif
{
    MSG msg;
    fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

    if(fBeVerbose == 0)
    {
	fBeVerbose = GetProfileInt("OLEUTEST","simpsvr",0);
    }

    TestDebugOut(TEXT("Starting Simpsvr.....\n"));
	
    // recommended size for OLE apps
    SetMessageQueue(96);

    lpCSimpSvrApp = new CSimpSvrApp;

    if (!lpCSimpSvrApp)
    {
       /* memory allocation error. We cannot carry on.
        */
       MessageBox(NULL, TEXT("Out of Memory"), TEXT("SimpSvr"),
                  MB_SYSTEMMODAL | MB_ICONHAND);
       return(FALSE);
    }

    lpCSimpSvrApp->AddRef();      // need the app ref. count at 1 to hold the
                                  // app alive.

    lpCSimpSvrApp->ParseCmdLine(lpCmdLine);

    // app initialization
    if (!hPrevInstance)
        if (!lpCSimpSvrApp->fInitApplication(hInstance))
        {
            // We need to release CSimpSvrApp before we go away
            lpCSimpSvrApp->Release();
            return (FALSE);
        }

    // instance initialization
    if (!lpCSimpSvrApp->fInitInstance(hInstance, nCmdShow, lpClassFactory))
    {
        // We need to release CSimpSvrApp before we go away
        lpCSimpSvrApp->Release();
        return (FALSE);
    }

    /* Initialization required for OLE 2 UI library.  This call is
    **    needed ONLY if we are using the static link version of the UI
    **    library. If we are using the DLL version, we should NOT call
    **    this function in our application.
    **    The 3rd and 4th parameters passed the OleUIInitialize
    **    function are strings which are used to name two custom
    **    control classes used by the OLE2UI library. These strings
    **    must be unique for each application that uses the OLE2UI
    **    library. These strings are typically composed by combining
    **    the APPNAME with a suffix in order to be unique for a
    **    particular application. The special symbols "SZCLASSICONBOX"
    **    and "SZCLASSRESULTIMAGE" are used define these strings. These
    **    symbols must be defined in a header file that is included
    **    both in this file AND the resource file that included the
    **    "OLE2UI.RC" resoure file. These symbols should be used in the
    **    call to OleUIInitialize and are referenced in the INSOBJ.DLG
    **    and PASTESPL.DLG resouce files of the OLE2UI library.
    */
    if (!OleUIInitialize(hInstance, hPrevInstance, TEXT(SZCLASSICONBOX),
                         TEXT(SZCLASSRESULTIMAGE)))
    {
        OleDbgOut(TEXT("Could not initialize OLEUI library\n"));

        // We need to release CSimpSvrApp before we go away
        lpCSimpSvrApp->Release();

        return FALSE;
    }

    // message loop
    while (GetMessage(&msg, NULL, NULL, NULL))
    {
        // Is this an accelerator for us? -- Remember that this server
        // only has one window and only processes one object at a time.
        if (TranslateAccelerator(lpCSimpSvrApp->GethAppWnd(),
            lpCSimpSvrApp->m_hAccel, &msg))
        {
            // Yes -- so we can loop for the next message
            continue;
        }

        if (lpCSimpSvrApp->IsInPlaceActive())
        {
            // Only key messages need to be sent to OleTranslateAccelerator.
            // Any other message would result in an extra FAR call to occur
            // for that message processing...

            if ((msg.message >= WM_KEYFIRST) && (msg.message <= WM_KEYLAST))
            {
                // OleTranslateAccelerator MUST be called, even though this
                // application does not have an accelerator table.  This has
                // to be done in order for the mneumonics for the top level
                // menu items to work properly.

                if (OleTranslateAccelerator(
                    lpCSimpSvrApp->GetDoc()->GetObj()->GetInPlaceFrame(),
                        lpCSimpSvrApp->GetDoc()->GetObj()->GetFrameInfo(),
                            &msg) == NOERROR)
                {
                    continue;
                }
            }
        }

        TranslateMessage(&msg);    /* Translates virtual key codes  */
        DispatchMessage(&msg);     /* Dispatches message to window  */
    }

    // De-initialization for UI libraries.  Just like OleUIInitialize, this
    // funciton is needed ONLY if we are using the static link version of the
    // OLE UI library.
    OleUIUninitialize();

    return (msg.wParam);          /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the main frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::lCommandHandler     APP.CPP
//      CSimpSvrApp::DestroyDocs         APP.CPP
//      CSimpSvrApp::lCreateDoc          APP.CPP
//      CSimpSvrApp::lSizeHandler        APP.CPP
//      CGameDoc::lAddVerbs              DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd,UINT message,WPARAM wParam,
                                   LPARAM lParam)
{

    switch (message)
        {
        case WM_CLOSE:
            TestDebugOut(TEXT("*** In WM_CLOSE *** \r\n"));

            // if there is still a document
            if (lpCSimpSvrApp->GetDoc())

                // if there is still an object within a document
                if (lpCSimpSvrApp->GetDoc()->GetObj())
                   // this case occurs if there is still
                   // an outstanding Ref count on the object
                   // when the app is trying to go away.
                   // typically this case will occur in
                   // the "open" editing mode.
                   //
                    //  Close the document
                    lpCSimpSvrApp->GetDoc()->Close();

            // hide the app window
            lpCSimpSvrApp->HideAppWnd();

            // if we were started by ole, unregister the class factory,
            // otherwise remove the ref count on our dummy OLE object
            if (lpCSimpSvrApp->IsStartedByOle())
            {
                if (CoRevokeClassObject(lpCSimpSvrApp->GetRegisterClass())
                    != S_OK)
                    TestDebugOut(TEXT("Fail in CoRevokeClassObject\n"));
            }
            else
                lpCSimpSvrApp->GetOleObject()->Release();

            lpCSimpSvrApp->Release();  // This should close the app.

            break;

        case WM_COMMAND:           // message: command from application menu
            return lpCSimpSvrApp->lCommandHandler(hWnd, message,
                                                  wParam, lParam);
            break;

        case WM_CREATE:
            return lpCSimpSvrApp->lCreateDoc(hWnd, message, wParam, lParam);
            break;

        case WM_DESTROY:                  // message: window being destroyed
            PostQuitMessage(0);
            break;

        case WM_MEASUREITEM:
            ((LPMEASUREITEMSTRUCT)lParam)->itemWidth = MEASUREITEMWIDTH;
            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = MEASUREITEMHEIGHT;
            break;

        case WM_DRAWITEM:
            lpCSimpSvrApp->HandleDrawItem((LPDRAWITEMSTRUCT) lParam);
            break;

        case WM_SIZE:
            return lpCSimpSvrApp->lSizeHandler(hWnd, message, wParam, lParam);

        default:                          // Passes it on if unproccessed
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
//
//********************************************************************

INT_PTR
#ifdef WIN32
	CALLBACK
#else
   FAR PASCAL EXPORT
#endif
   About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:               /* message: initialize dialog box */
        return (TRUE);

    case WM_COMMAND:                  /* message: received a command */
        if (wParam == IDOK            /* "OK" box selected?          */
            || wParam == IDCANCEL)    /* System menu close command?  */
        {
           EndDialog(hDlg, TRUE);     /* Exits the dialog box        */
           return (TRUE);
        }
        break;
    }
    return (FALSE);                   /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                            Location
//
//      CSimpSvrApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::UIDeactivate     Object
//      IOleObject::DoVerb                  Object
//      IOleInPlaceObject::Release          Object
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd,UINT message,WPARAM wParam,
                                  LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;

    switch (message)
    {
        case WM_COMMAND:           // message: command from application menu
            return lpCSimpSvrApp->lCommandHandler(hWnd, message,
                                                  wParam, lParam);
            break;

        case WM_PAINT:
            hDC = BeginPaint(hWnd, &ps);

            // tell the app class to paint itself
            if (lpCSimpSvrApp)
                lpCSimpSvrApp->PaintApp (hDC);

            EndPaint(hWnd, &ps);
            break;

        case WM_MENUSELECT:
            lpCSimpSvrApp->SetStatusText();
            break;

        case WM_MEASUREITEM:
            ((LPMEASUREITEMSTRUCT)lParam)->itemWidth = MEASUREITEMWIDTH;
            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = MEASUREITEMHEIGHT;
            break;

        case WM_DRAWITEM:
            lpCSimpSvrApp->HandleDrawItem((LPDRAWITEMSTRUCT) lParam);
            break;


        default:                   /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\simpsvr\simpsvr.h ===
//**********************************************************************
// File name: simpsvr.h
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#endif

BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
#ifdef WIN32
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WORD wParam, LONG lParam);
#endif

#define SZCLASSICONBOX "SimpSvrIBClass"
#define SZCLASSRESULTIMAGE "SimpSvrRIClass"

#ifdef WIN32
   // The following functions are all obsolete in Win32.
   // By using the following macros, we can use the app in both Win16 and
   // Win32
	#define SetWindowOrg(h,x,y)       SetWindowOrgEx((h),(x),(y),NULL)
	#define SetWindowExt(h,x,y)       SetWindowExtEx((h),(x),(y),NULL)
   #define SetViewportExt(h,x,y)     SetViewportExtEx((h),(x),(y),NULL)
   #ifndef EXPORT
      #define EXPORT
   #endif
#else

   #ifndef EXPORT
      // _export is obsolete in Win32
      #define EXPORT _export
   #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cbaseall.cxx ===
//+------------------------------------------------------------------
//
// File:        cbaseall.cxx
//
// Contents:    implementation for base class for all command line
//              classes, both the individual command line object
//              classes and the overall parsing class
//
// Synoposis:   This base class contains the print function pointer
//              the default print implementation and the constructor
//              error value.
//
// Classes:     CBaseCmdline
//
// Functions:
//
// History:     12/27/91 Lizch Created
//              04/17/92 Lizch Converted to NLS_STR
//              09/09/92 Lizch Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch Precompile headers
//              10/13/93 DeanE Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


void DefaultDisplayMethod(LPCNSTR nszMessage);
void (* CBaseCmdline::_pfnDisplay)(LPCNSTR nszMessage) = DefaultDisplayMethod;

NCHAR CBaseCmdline::_nszErrorBuf[];

//+------------------------------------------------------------------
//
// Function:   CBaseCmdline Constructor
//
// Member:     CBaseCmdline
//
// Synoposis:  Initialises error string and print function pointer
//
// History:    Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
CBaseCmdline::CBaseCmdline()
{
    _pfnDisplay = DefaultDisplayMethod;
    _iLastError = CMDLINE_NO_ERROR;
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdline::SetDisplayMethod, public
//
// Member:      CBaseCmdline
//
// Synoposis:   Sets the print function pointer to the passed value. This
//              enables client programs to replace the default printf
//              print method with their own (eg. wprintf).
//
// Arguments:   [pfnNewDisplayMethod] - Function pointer that replaces
//                                      current display function.
//
// Returns:     none
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdline::SetDisplayMethod(
        void (* pfnNewDisplayMethod)(LPCNSTR nszMessage))
{
    _pfnDisplay = pfnNewDisplayMethod;
}


//+------------------------------------------------------------------
//
// Function:    DefaultDisplayMethod
//
// Synoposis:   Used to wrap the printf function to get around problems
//              equating a function pointer expecting a char * to the
//              printf function expecting (char *,...)
//
// Arguments:   [nszMessage] - Message to display.
//
// Returns:     none
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
void DefaultDisplayMethod(LPCNSTR nszMessage)
{
    _nprintf(_TEXTN("%s"), nszMessage);
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdline::QueryError, public
//
// Member:      CBaseCmdline
//
// Synoposis:   Returns the internal error indicator and resets it
//              to CMDLINE_NO_ERROR.
//
// Effects:     sets _iLastError to CMDLINE_NO_ERROR.
//
// Arguments:   none
//
// Returns:     the last error
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
INT CBaseCmdline::QueryError()
{
   INT iLastError = _iLastError;

   SetError(CMDLINE_NO_ERROR);

   return(iLastError);
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdline::SetError, public
//
// Member:      CBaseCmdline
//
// Synoposis:   Sets the internal error indicator to the passed value
//
// Effects:     sets _iLastError to passed value.
//
// Arguments:   [iLastError] - the new error value
//
// Returns:     nothing
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdline::SetError(INT iLastError)
{
    _iLastError = iLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\wstrlist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993.
//
// File:        nstrlist.cxx
//
// Contents:    Implementation of class CnStrList
//
// Functions:   CnStrList::CnStrList
//              CnStrList::~CnStrList
//              CnStrList::QueryError
//              CnStrList::Next
//              CnStrList::Reset
//              CnStrList::Append
//
// History:     XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions

#include <wstrlist.hxx>

//+-----------------------------------------------------------------------
//
// Function:   CnStrList::CnStrList
//
// Synopsis:   Constructor, which creates a string list.
//
// Arguments:  [pnszItems]  -- Supplied string consisting of zero or more
//                             item strings separated by delimiters.  Two
//                             consecutive delimiters mean an item of
//                             an empty string in between.
//             [pnszDelims] -- Supplied set of delimiter characters.
//
// Returns:    Nothing
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

CnStrList::CnStrList(LPCNSTR pnszItems, LPCNSTR pnszDelims) :
    _head(NULL), _tail(NULL), _next(NULL), _iLastError(NSTRLIST_NO_ERROR)
{
    LPCNSTR  pnszNewItem;
    PNSTR   pnszLocalItems;
    PNSTR   pnszHead;
    BOOL    fDone;

    SetError(NSTRLIST_NO_ERROR);
    if (pnszItems == NULL)
    {
        // No items.
        return;
    }

    // Make a local copy of items.
    pnszLocalItems = new NCHAR[_ncslen(pnszItems) + 1];
    if (pnszLocalItems == NULL)
    {
        SetError(NSTRLIST_ERROR_OUT_OF_MEMORY);
        return;
    }
    _ncscpy(pnszLocalItems, pnszItems);
    pnszHead = pnszLocalItems;

    fDone = FALSE;
    while (fDone == FALSE)
    {
        pnszNewItem = (LPCNSTR)pnszLocalItems;  // Beginning of a new item.
        // Search for next delimiter or end of given string.
        while (*pnszLocalItems != _TEXTN('\0') &&
               _ncschr(pnszDelims, *pnszLocalItems) == NULL)
        {
            pnszLocalItems++;
        }

        if (*pnszLocalItems == _TEXTN('\0'))
        {
            // End of string.
            fDone = TRUE;
        }
        else
        {
            // Replace end of item with L'\0' for Append.
            *pnszLocalItems = _TEXTN('\0');
        }
        // Append the item to the list.
        if (Append(pnszNewItem) == FALSE)
        {
            SetError(NSTRLIST_ERROR_OUT_OF_MEMORY);
            fDone = TRUE;
        }
        pnszLocalItems++;
    }
    delete pnszHead;
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::~CnStrList
//
// Synopsis:   Destructor.
//
// Arguments:  None.
//
// Returns:    Nothing
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

CnStrList::~CnStrList()
{
    NSTRLIST *pNext;

    while (_head != NULL)
    {
        pNext = _head->pNext;
        delete [] _head->pnszStr;
        delete [] _head;
        _head = pNext;
    }
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::Next
//
// Synopsis:   Get next item.
//
// Arguments:  None.
//
// Returns:    Next item if there is one, or else NULL.
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

LPCNSTR CnStrList::Next()
{
    LPCNSTR pnsz;

    if (_next == NULL)
    {
        return NULL;
    }
    pnsz = _next->pnszStr;
    _next = _next->pNext;
    return pnsz;
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::Reset
//
// Synopsis:   Reset the iterator.
//
// Arguments:  None
//
// Returns:    None
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

VOID CnStrList::Reset()
{
    _next = _head;
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::Append
//
// Synopsis:   Append a string to the list.
//
// Arguments:  [pnszItem]  -- Supplied string.
//
// Returns:    TRUE if the function succeeds or else (out of memory) FALSE.
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

BOOL CnStrList::Append(LPCNSTR pnszItem)
{
    // Construct a new node.
    NSTRLIST *pNode = new NSTRLIST[1];
    if (pNode == NULL)
    {
        return FALSE;
    }
    pNode->pnszStr = new NCHAR [_ncslen(pnszItem) + 1];
    if (pNode->pnszStr == NULL)
    {
        delete [] pNode;
        return FALSE;
    }
    _ncscpy(pNode->pnszStr, pnszItem);
    pNode->pNext = NULL;

    // Add it to the list.
    if (_head == NULL)
    {
        _next = _head = pNode;
    }
    else
    {
        _tail->pNext = pNode;
    }
    _tail = pNode;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cstrlen.cxx ===
//+------------------------------------------------------------------
//
//  File:       cstrlen.cxx
//
//  Contents:   implementation for CStrLengthCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch which takes an
//              length restricted string, eg: /password:<value>, where the
//              value must be between MINPASSWORD and MAXPASSWORD in
//              length
//
//  Classes:    CStrLengthCmdlineObj
//
//  History:    12/27/91 Lizch Created
//              04/17/92 Lizch Converted to NLS_STR
//              09/09/92 Lizch Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch Precompile headers
//              10/18/93 DeanE Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


LPCNSTR nszCmdlineString = _TEXTN("Takes a string ");
LPCNSTR nszLineArgString = _TEXTN("<string> ");


//+------------------------------------------------------------------
//
//  Member:     CStrLengthCmdlineObj::SetValue, public
//
//  Synoposis:  Stores the specified value, eg "lizch" from
//              "username:lizch"
//
//  Effects:    This SetValue simply checks for length within
//              specified range, and then calls the base SetValue
//
//  Arguments:  [nszArg] - the string following the switch on the
//                         command line. Excludes the equator (eg.
//                         ':' or '=' ), if any.
//
//  Returns:    CMDLINE_NO_ERROR or CMDLINE_ERROR_INVALID_VALUE
//
//  History:    Created          12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//-------------------------------------------------------------------
INT CStrLengthCmdlineObj::SetValue(LPCNSTR nszArg)
{
    UINT cchArg;

    cchArg = _ncslen(nszArg);
    if ((cchArg >= _uiMinLength) && (cchArg <= _uiMaxLength))
    {
        return(CBaseCmdlineObj::SetValue(nszArg));
    }
    else
    {
        return(CMDLINE_ERROR_INVALID_VALUE);
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CStrLengthCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const WCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CStrLengthCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineString);
}


//+-------------------------------------------------------------------
//
//  Method:     CStrLengthCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const WCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CStrLengthCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgString);
    }
    else
    {
        return(_pnszLineArgType);
    }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::DisplaySpecialUsage, protected
//
//  Synoposis:  Prints the switch usage statement according to current
//              display method.  Generally this will be stdout.
//
//  Arguments:  [usDisplayWidth] - total possible width available to display
//              [usIndent]       - amount to indent
//              [pusWidth]       - space to print on current line
//
//  Returns:    error code from QueryError,
//              error code from DisplayStringByWords
//
//  History:    05/14/91 Lizch    Created
//              07/29/92 Davey    Modified to work with new usage display
//-------------------------------------------------------------------
INT CStrLengthCmdlineObj::DisplaySpecialUsage(
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    NCHAR nszBuf[100];

    _sNprintf(nszBuf,
             _TEXTN("The string must be between %u and %u characters in length."),
             _uiMinLength,
             _uiMaxLength);

    return(DisplayStringByWords(
                  nszBuf,
                  usDisplayWidth,
                  usIndent,
                  pusWidth));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\pch.cxx ===
//+------------------------------------------------------------------
//
// File:        pch.cxx
//
// Contents:    headers to precompile when building cmdline.lib
//
// Synoposis:
//
// Classes:
//
// Functions:
//
// History:     09/18/92 Lizch  Created
//
//-------------------------------------------------------------------
#include "pch.hxx"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cintcmd.cxx ===
//+------------------------------------------------------------------
//
//  File:       cintcmd.cxx
//
//  Contents:   implementation for CIntCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch which takes an
//              integer value, eg: /maxusers:10
//
//  Classes:    CIntCmdlineObj
//
//  Functions:
//
//  History:    12/27/91 Lizch      Created
//              04/17/92 Lizch      Converted to NLS_STR
//              07/29/92 davey      Added nlsType and nlsLineArgType
//              09/09/92 Lizch      Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch      Precompile headers
//              11/14/92 DwightKr   Updates for new version of NLS_STR
//              10/14/93 DeanE      Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


INT StringToInt (LPCNSTR nszInt, INT *pInt);


LPCNSTR nszCmdlineInt = _TEXTN("Takes an integer ");
LPCNSTR nszLineArgInt = _TEXTN("<int> ");


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj destructor
//
//  Synoposis:  Frees any memory associated with the object
//
//  History:    Added to allow casting of pValue 05/12/92 Lizch
//
//-------------------------------------------------------------------
CIntCmdlineObj::~CIntCmdlineObj()
{
    delete (INT *)_pValue;
    _pValue = NULL;
}


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj::SetValue, public
//
//  Synposis:   Stores the integer value specified after the switch
//              string, eg. 10 for /maxusers:10
//
//  Effects:    This implementation for the virtual method SetValue
//              converts the characters following the switch to an integer.
//              It allocates memory for the integer.  If there is no
//              equator character, or if there is no character following
//              the equator character, _pValue remains NULL.
//
//  Arguments:   [nszArg] -  the string following the switch on the
//                           command line. Includes the equator (eg.
//                           ':' or '=' ), if any.
//
//  Requires:
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_OUT_OF_MEMORY,
//              CMDLINE_ERROR_TOO_BIG, CMDLINE_ERROR_INVALID_VALUE
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
INT CIntCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT nRet;

    // delete any existing _pValue
    delete (INT *)_pValue;
    _pValue = NULL;

    _pValue = new INT;
    if (_pValue == NULL)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        // I'm using this rather than c runtime atoi so that I
        // can detect error conditions like overflow and non-digits.
        //
        nRet = StringToInt(nszArg, (INT *)_pValue);
        if (nRet != CMDLINE_NO_ERROR)
        {
            delete (INT *)_pValue;
            _pValue = NULL;
        }
    }

    return(nRet);
}


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj::GetValue, public
//
//  Synopsis:   Returns a pointer to the switch value
//
//  Arguments:  none
//
//  Returns:    a integer pointer to the switch value, not including
//              the equater character
//
//  History:    Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
const int * CIntCmdlineObj::GetValue()
{
    return((int *)_pValue);
}


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj::DisplayValue, public
//
//  Synoposis:  Prints the stored command line value according to
//              current display method.  This will generally be to stdout.
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
void CIntCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        _sNprintf(_nszErrorBuf,
                 _TEXTN("Command line switch %s has value %d\n"),
                 _pnszSwitch,
                 *(int *)_pValue);
        (*_pfnDisplay)(_nszErrorBuf);
    }
    else
    {
        DisplayNoValue();
    }
}


//+------------------------------------------------------------------
//
//  Function:   StringToInt
//
//  Synoposis:  Converts ascii string to integer, checking for overflow,
//              and illegal characters. Only +, - and digits are accepted
//
//  Arguments:  [nszInt] - ascii string to convert
//              [pInt]   - pointer to converted integer
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_INVALID_VALUE,
//              CMDLINE_ERROR_TOO_BIG
//
//  History:    Created 12/17/91 Lizch
//
//  Notes:      I'm using this rather than c runtime atoi so that I
//              can detect error conditions like overflow and non-digits.
//
//-------------------------------------------------------------------
INT StringToInt(LPCNSTR nszInt, INT *pInt)
{
    short sNegator = 1;
    INT   iResult  = 0;
    INT   iRC      = CMDLINE_NO_ERROR;

    // Skip any leading spaces - these can occur if the command line
    // switch incorporates spaces, eg "/a:   123"
    while (_isnspace(*nszInt))
    {
        nszInt++;
    }

    switch (*nszInt)
    {
    case L'-':
        sNegator = -1;
        nszInt++;
        break;

    case L'+':
        sNegator = 1;
        nszInt++;
        break;

    default:
        break;
    }

    for (;*nszInt != nchClNull; nszInt++)
    {
        if (!_isndigit(*nszInt))
        {
            iResult = 0;
            iRC = CMDLINE_ERROR_INVALID_VALUE;
            break;
        }

        iResult = (iResult * 10) + (*nszInt - '0');

        // Since iResult doesn't get it's sign added until later,
        // I can test for overflow by checking if it goes negative
        if (iResult < 0)
        {
            iResult = 0;
            iRC = CMDLINE_ERROR_TOO_BIG;
            break;
        }
    }

    *pInt = ((int)(iResult * sNegator));

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CIntCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CIntCmdlineObj::QueryCmdlineType() const
{
   return(nszCmdlineInt);
}


//+-------------------------------------------------------------------
//
//  Method:     CIntCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CIntCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgInt);
    }
    else
    {
        return(_pnszLineArgType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\culong.cxx ===
//+------------------------------------------------------------------
//
//  File:       culong.cxx
//
//  Contents:   implementation for CUlongCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch which takes an
//              unsigned long value, eg: /maxusers:10
//
//  Classes:    CUlongCmdlineObj
//
//  Functions:
//
//  History:    06/15/92 DeanE      Stolen from CIntCmdlineObj code
//              07/29/92 davey      Added nlsType and nlsLineArgType
//              09/09/92 Lizch      Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch      Precompile headers
//              11/14/92 DwightKr   Updates for new version of NLS_STR
//              10/14/93 DeanE      Converted to NCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


INT StringToUlong(LPCNSTR pnszInt, ULONG *pUlong);

LPCNSTR nszCmdlineUlong = _TEXTN("Takes an unsigned long ");
LPCNSTR nszLineArgUlong = _TEXTN("<ulong> ");


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj destructor
//
//  Synoposis:  Frees any memory associated with the object
//
//  History:    Added to allow casting of pValue 05/12/92 Lizch
//              Integrated into CUlongCmdlineObj 6/15/92  DeanE
//
//-------------------------------------------------------------------
CUlongCmdlineObj::~CUlongCmdlineObj()
{
    delete (ULONG *)_pValue;
    _pValue = NULL;
}


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj::SetValue, public
//
//  Synposis:   Stores the ulong value specified after the switch
//              string, eg. 10 for /maxusers:10
//
//  Effects:    This implementation for the virtual method SetValue
//              converts the characters following the switch to an unsigned
//              long.  It allocates memory for the ulong.
//              If there is no equator character, or if there
//              is no character following the equator character, _pValue
//              remains NULL.
//
//  Arguments:  [nszArg] - the string following the switch on the
//                         command line. Includes the equator (eg.
//                         ':' or '=' ), if any.
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_OUT_OF_MEMORY,
//              CMDLINE_ERROR_TOO_BIG, CMDLINE_ERROR_INVALID_VALUE
//
//  History:    Created                          12/27/91 Lizch
//              Converted to NLS_STR             4/17/92  Lizch
//              Integrated into CUlongCmdlineObj 6/15/92  DeanE
//
//-------------------------------------------------------------------
INT CUlongCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT iRC;

    // delete any existing _pValue
    delete (ULONG *)_pValue;
    _pValue = NULL;

    _pValue = new ULONG;
    if (_pValue == NULL)
    {
        return (CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    // I'm using this rather than c runtime atol so that I
    // can detect error conditions like overflow and non-digits.
    iRC = StringToUlong(nszArg, (ULONG *)_pValue);
    if (iRC != CMDLINE_NO_ERROR)
    {
        delete (ULONG *)_pValue;
        _pValue = NULL;
    }

    return(iRC);
}


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj::GetValue, public
//
//  Synposis:   Returns a pointer to ULONG that holds the value.
//
//  Arguments:  void
//
//  Returns:    ULONG value at *_pValue.
//
//  History:    Created                          12/27/91 Lizch
//              Converted to NLS_STR             4/17/92  Lizch
//              Integrated into CUlongCmdlineObj 6/15/92  DeanE
//
//-------------------------------------------------------------------
const ULONG *CUlongCmdlineObj::GetValue()
{
    return((ULONG *)_pValue);
}


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj::DisplayValue, public
//
//  Synoposis:  Prints the stored command line value accordint to
//              current display method.  Generally this will be to stdout.
//
//  History:    Created                           12/27/91 Lizch
//              Converted to NLS_STR              4/17/92  Lizch
//              Integrated into CUlongCmdlineObj  6/15/92  DeanE
//
//-------------------------------------------------------------------
void CUlongCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        _sNprintf(_nszErrorBuf,
                 _TEXTN("Command line switch %s has value %lu\n"),
                 _pnszSwitch,
                 *(ULONG *)_pValue);
        (*_pfnDisplay)(_nszErrorBuf);
    }
    else
    {
        DisplayNoValue();
    }
}


//+------------------------------------------------------------------
//
//  Function:   StringToUlong
//
//  Synoposis:  Converts given string to unsigned long, checking for
//              overflow and illegal characters. Only +, - and digits
//              are accepted.
//
//  Arguments:  [nszUlong] - string to convert
//              [pUlong]   - pointer to converted unsigned long
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_INVALID_VALUE,
//              CMDLINE_ERROR_TOO_BIG
//
//  History:    Created                    12/17/91 Lizch
//              Converted to AsciiToUlong  6/15/92  DeanE
//              Added in conversion of Hex 12/27/94 DaveY
//
//  Notes:      I'm using this rather than c runtime atoi so that I
//              can detect error conditions like overflow and non-digits.
//              The sign is checked for and stored, although it is not
//              used - so a negative value will still be converted to
//              an unsigned equivalent.
//
//-------------------------------------------------------------------
INT StringToUlong(LPCNSTR nszUlong, ULONG *pUlong)
{
    short sNegator = 1;
    ULONG ulResult = 0;
    INT   iRC      = CMDLINE_NO_ERROR;

    // Skip any leading spaces - these can occur if the command line
    // switch incorporates spaces, eg "/a:   123"
    //
    while (_isnspace(*nszUlong))
    {
        nszUlong++;
    }

    // Get sign - ignore for now
    switch (*nszUlong)
    {
    case '-':
        sNegator = -1;
        nszUlong++;
        break;
    case '+':
        sNegator = 1;
        nszUlong++;
        break;
    default:
        break;
    }

    // see if using hex values
    if ((*nszUlong == _TEXTN('0')) && 
        ((*(nszUlong+1) == _TEXTN('x')) || (*(nszUlong+1) == _TEXTN('X'))))
    {
        nszUlong += 2;   // pass the "0x"

        int max = sizeof(ULONG) << 1;   // number of hex digits possible

        for(int i=0;  *nszUlong != NULL && i < max; i++, nszUlong++)
        {
            if ((_TEXTN('0') <= *nszUlong ) && (*nszUlong <= _TEXTN('9')))
            {
                ulResult = ulResult * 16 + (*nszUlong - _TEXTN('0'));
            }
            else if ((_TEXTN('A') <= *nszUlong ) && (*nszUlong <= _TEXTN('F')))
            {
                ulResult = ulResult * 16 + 10 + (*nszUlong - _TEXTN('A'));
            }
            else if ((_TEXTN('a') <= *nszUlong) && (*nszUlong <= _TEXTN('f')))
            {
                ulResult = ulResult * 16 + 10 + (*nszUlong - _TEXTN('a'));
            }
            else
            {
                iRC = CMDLINE_ERROR_INVALID_VALUE;
                ulResult = 0;
                break;
            }
        }
        if ((i >= max) && (*nszUlong != NULL))
        {
            iRC = CMDLINE_ERROR_INVALID_VALUE;
            ulResult = 0;
        }
        *pUlong = ulResult;
        return iRC;
    }


    // must be decimal

    for (;*nszUlong != L'\0'; nszUlong++)
    {
        if (!_isndigit(*nszUlong))
        {
            ulResult = 0;
            iRC = CMDLINE_ERROR_INVALID_VALUE;
            break;
        }

        ULONG ulPrevious = ulResult;

        ulResult = (ulResult * 10) + (*nszUlong - '0');

        // Check for overflow by checking that the previous result is less
        // than the current result - if the previous one was bigger, we've
        // overflowed!
        //
        if (ulResult < ulPrevious)
        {
            ulResult = 0;
            iRC = CMDLINE_ERROR_TOO_BIG;
            break;
        }
    }

    *pUlong = ulResult;

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CUlongCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CUlongCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineUlong);
}


//+-------------------------------------------------------------------
//
//  Method:     CUlongCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NLS_STR reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CUlongCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgUlong);
    }
    else
    {
        return(_pnszLineArgType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cmdline.cxx ===
//+------------------------------------------------------------------
//
//  File:       cmdline.cxx
//
//  Contents:   implementation of CCmdline class
//
//  Synopsis:   CCmdline encapsulates the actual command line, and
//              parses it looking for expected switches.
//
//
//  Classes:    CCmdline
//
//  Functions:
//
//  History:    12/23/91 Lizch    Created
//              04/17/92 Lizch    Converted to NLS_STR
//              09/09/92 Lizch    Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch    Precompile headers
//              11/14/92 DwightKr Updates for new version of NLS_STR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


static void DelimitWithNulls(LPNSTR pnszArgline,
                             LPNSTR pnszDest,
                             UINT   *puiArgc);

//+------------------------------------------------------------------
//
//  Member:     CCmdline::CCmdline(int, char **, BOOL = FALSE)
//
//  Synopsis:   Copies argv and argc, and initialises defaults.
//
//  Effects:    Makes a copy of argv and argc. Argv (minus argv[0]) is
//              copied into an array of CCmdlineArg objects.
//              Argv[0] is copied into a program name data member.
//
//  Arguments:  [argc]           - count of arguments.
//              [argv]           - arguments.
//              [fInternalUsage] - Use internal Usage.
//
//  Returns:    None
//
//  Modifies:   aeLastError
//
//  History:    12/23/91 Lizch    Created.
//              04/17/92 Lizch    Converted to NLS_STR
//              07/28/92 Davey    Intialize _pfExtraUsage, _usIndent,
//                                _usDisplayWidth.
//                                Modified call to SetProgName,
//                                Added fInternalUsage parameter.
//              10/11/94 XimingZ  Initialize _pnszProgName.
//                                Call SetError before the first error return.
//                                Set _apArgs to NULL as it is deleted in
//                                case of memory allocatio failure.
//
//-------------------------------------------------------------------
CCmdline::CCmdline(int argc, char *argv[], BOOL fInternalUsage) :
        _apArgs(NULL),
        _uiNumArgs(0),
        _pfExtraUsage(NULL),
        _usIndent(CMD_INDENT),
        _usDisplayWidth(CMD_DISPLAY_WIDTH),
        _usSwitchIndent(CMD_SWITCH_INDENT),
        _pbcInternalUsage(NULL),
        _pnszProgName(NULL)
{
    INT   iRC;
    PNSTR pnszBuf;

    SetError(CMDLINE_NO_ERROR);

    if (fInternalUsage)
    {
        iRC = SetInternalUsage();
        if (CMDLINE_NO_ERROR != iRC)
            return;
    }

    pnszBuf = new NCHAR[strlen(argv[0])+1];
    if (NULL == pnszBuf)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }
    else
    {
#ifdef CTUNICODE
        mbstowcs(pnszBuf, argv[0], strlen(argv[0])+1);
#else
        strcpy(pnszBuf, argv[0]);
#endif

    }

    iRC = SetProgName(pnszBuf);
    delete pnszBuf;
    if (iRC != CMDLINE_NO_ERROR)
    {
        SetError(iRC);
        return;
    }


    // Don't include argv[0] in the argument count.
    _uiNumArgs = argc - 1;

    // Now set up an array of CCmdlineArg objects, each of which
    // encapsulates one argv element
    //
    _apArgs = new (CCmdlineArg *[_uiNumArgs]);
    if (_apArgs == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }

    for (INT i=0; i< (INT)_uiNumArgs; i++)
    {
        // Convert argv[i] to unicode
        pnszBuf = new NCHAR[strlen(argv[i+1])+1];
        if (NULL == pnszBuf)
        {
            _apArgs[i] = NULL;
        }
        else
        {
            // We check for errors in the next block
#ifdef CTUNICODE
            mbstowcs(pnszBuf, argv[i+1], strlen(argv[i+1])+1);
#else
            strcpy(pnszBuf, argv[i+1]);
#endif

            _apArgs[i] = new CCmdlineArg(pnszBuf);
            delete pnszBuf;
        }

        // If an allocation failed, rewind through those we have
        // allocated
        //
        if ((_apArgs[i] == NULL) || (_apArgs[i]->QueryError() != CMDLINE_NO_ERROR))
        {
            for (; i>=0; i--)
            {
                delete _apArgs[i];
            }

            delete [] _apArgs;
            _apArgs = NULL;
            SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
            break;
        }
    }
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::CCmdline(BOOL fInternalUsage = FALSE)
//
//  Synopsis:   Takes arguments from GetCommandLine(). To be used
//              with Windows programs whose startpoint is WinMain()
//
//  Effects:    Takes the arguments out of GetCommandLine(), and
//              copies them into an array of CCmdlineArg objects.
//
//  Arguments:  [fInternalUsage]  Use internal usage
//
//  Returns:    None
//
//  Modifies:   Not much really
//
//  History:    2/6/1995 jesussp  Created
//
//  Note:       For 16 bit, this will set the error to
//              CMDLINE_ERROR_USAGE_FOUND, as the GetCommandLine is
//              not support in WIN16.
//
//-------------------------------------------------------------------
CCmdline::CCmdline(BOOL fInternalUsage) :
        _apArgs(NULL),
        _uiNumArgs(0),
        _pfExtraUsage(NULL),
        _usIndent(CMD_INDENT),
        _usDisplayWidth(CMD_DISPLAY_WIDTH),
        _usSwitchIndent(CMD_SWITCH_INDENT),
        _pbcInternalUsage(NULL),
        _pnszProgName(NULL)
{

#if !defined (_WIN32)

    SetError(CMDLINE_ERROR_USAGE_FOUND);
    return;

#else

    INT    iRC;
    NCHAR  *pnszArgs,
           *pnszProg,
           *pnszDst;
    NCHAR  *pncArg;

    INT    iError;


    SetError(CMDLINE_NO_ERROR);

    if (fInternalUsage)
    {
        iRC = SetInternalUsage();
        if (CMDLINE_NO_ERROR != iRC)
            return;
    }

    // Obtain a copy of the command line

#if defined(CTUNICODE)
    pnszProg = new NCHAR[1+wcslen(GetCommandLineW())];
#else
    pnszProg = new NCHAR[1+strlen(GetCommandLineA())];
#endif

    if (NULL == pnszProg)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }

#if defined(CTUNICODE)
    wcscpy(pnszProg, GetCommandLineW());
#else
    strcpy(pnszProg, GetCommandLineA());
#endif

    // Skip through the command line looking for arguments

    pnszArgs = pnszProg;
    while (nchClSpace != *pnszArgs && nchClNull != *pnszArgs)
    {
        ++pnszArgs;
    }

    if (nchClSpace == *pnszArgs)
    {
        *pnszArgs++ = nchClNull;
    }

    // Now pnszProg points to a null-terminated string containing the
    // program name, and pnszArgs points to a null-terminated string
    // containing the program arguments...

    SetProgName(pnszProg);

    // Allocate memory for a buffer containing the different arguments
    // separated by nulls

    INT cBufSize = 1+_ncslen(pnszArgs);

    //
    // to accomodate for an extra null character
    //
    pnszDst = new NCHAR[1+cBufSize];
    if (NULL == pnszDst)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        delete pnszProg;
        return;
    }

    // Parse the argument line and get a null-terminated string

    DelimitWithNulls(pnszArgs, pnszDst, &_uiNumArgs);


    // Set up an array of CCmdlineArg objects, each of which
    // encapsulates one argument
    //
    _apArgs = new (CCmdlineArg *[_uiNumArgs]);
    if (_apArgs == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }

    pncArg = pnszDst;

    for (INT i=0; i< (INT)_uiNumArgs; i++)
        {

	//  Copy argument string

        NCHAR *pnszBuf = new NCHAR[_ncslen(pncArg)+1];

        if (NULL == pnszBuf)
	{
	    _apArgs[i] = NULL;
        }
	else
        //  We check for errors until the next block
	{
            _ncscpy(pnszBuf, pncArg);
            _apArgs[i] = new CCmdlineArg(pnszBuf);
            delete pnszBuf;
        }

        //  If an allocation failed, rewind through those we have
        //  allocated
        if ((_apArgs[i] == NULL) || (_apArgs[i]->QueryError() != CMDLINE_NO_ERROR))
        {
            for (; i>=0; i--)
            {
                delete _apArgs[i];
            }

            delete [] _apArgs;
            _apArgs = NULL;
            SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
            break;
        }

        // Skip to the next argument (past a null byte)

	while (*pncArg++)
	{
	    ;
	}
    }

    // Release allocated memory

    delete pnszProg;
    delete pnszDst;

#endif // if !defined (_WIN32)

}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::~CCmdline()
//
//  Synopsis:   Destructor for CCmdline
//
//  Effects:    Deletes _apArgs
//
//  History:    12/23/91 Lizch   Created.
//              04/17/92 Lizch   Converted to NLS_STR
//              08/10/92 Davey   Added delete of _pnlsEquater/_pnlsSeparator
//              10/11/94 XimingZ Added checking _apArgs != NULL
//
//-------------------------------------------------------------------
CCmdline::~CCmdline()
{
    if (_apArgs != NULL)
    {
        for (UINT i=0; i<_uiNumArgs; i++)
        {
            delete _apArgs[i];
        }
        delete [] _apArgs;
    }

    delete _pbcInternalUsage;

    delete _pnszProgName;
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::Parse, public
//
//  Synoposis:  Parses the stored command line, matching actual with
//              expected command line switches.
//
//  Effects:    Calls FindSwitch which stores the command line values
//              (eg. "lizch" in "/user:lizch") in the individual command
//              line objects, via the polymorphic SetValue call.
//
//  Arguments:  [apExpectedArgs] - an array of all possible command line
//                                 objects
//              [iMaxArgs]       - the number of elements in that array.
//              [fExtras]        - if TRUE, a warning is given if an
//                                 unexpected command line argument is given.
//
//  Returns:    CMDLINE_NO_ERROR,
//              CMDLINE_ERROR_INVALID_FLAG.
//              CMDLINE_ERROR_ARGUMENT_MISSING
//              CMDLINE_ERROR_UNRECOGNISED_ARG
//              CMDLINE_ERROR_USAGE_FOUND
//
//  History:    12/23/91 Lizch   Created.
//              04/17/92 Lizch   Converted to NLS_STR.
//              08/10/92 Davey   Added internal usage check.
//				06/13/97 MariusB Reset found flag for each expected 
//								 arg. Reset the value of the arg if it 
//								 is not found, no default and not 
//								 required.
//-------------------------------------------------------------------
INT CCmdline::Parse(
        CBaseCmdlineObj *apExpectedArgs[],
        UINT             uiMaxArgs,
        BOOL             fCheckForExtras)
{
    INT  iRC = CMDLINE_NO_ERROR;
    UINT i;

    // Traverse the array of objects given, making sure none have errors
    for (i=0; i<uiMaxArgs; i++)
    {
        iRC = apExpectedArgs[i]->QueryError();
        if (CMDLINE_NO_ERROR != iRC)
        {
            return(iRC);
        }

		apExpectedArgs[i]->SetFoundFlag(FALSE);
    }

    // check for internal usage if defined.
    if (_pbcInternalUsage != NULL)
    {
        iRC = FindSwitch(_pbcInternalUsage, fCheckForExtras);
        if (iRC != CMDLINE_NO_ERROR)
        {
            DisplayUsage(apExpectedArgs, uiMaxArgs);
            return(iRC);
        }

        // if found, print out usage and return.
        if (_pbcInternalUsage->IsFound() == TRUE)
        {
            DisplayUsage(apExpectedArgs, uiMaxArgs);
            return(CMDLINE_ERROR_USAGE_FOUND);
        }
    }


    // look for each expected argument in turn.
    for (i=0; i<uiMaxArgs; i++)
    {
        CBaseCmdlineObj *pArg = apExpectedArgs[i];

        // Go along the actual command line, looking for this switch
        // CMDLINE_NO_ERROR doesn't necessarily indicate we found it,
        // just that nothing went wrong
        //
        iRC = FindSwitch(pArg, fCheckForExtras);
        if (iRC != CMDLINE_NO_ERROR)
        {
            break;
        }

        // We've gone through the entire command line. Check if any
        // switch was omitted. For those that had defaults specified,
        // set the default. For mandatory switches, generate an error.
        // Note that you should never have a default value for a
        // mandatory switch!
        //
        if ((pArg->IsFound()) == FALSE)
        {
            if (pArg->IsDefaultSpecified() == TRUE)
            {
                iRC = pArg->SetValueToDefault();
                if (iRC != CMDLINE_NO_ERROR)
                {
                    break;
                }
            }
            else
            {
                if ((pArg->IsRequired()) == TRUE)
                {
                    pArg->DisplayUsageDescr(
                                 _usSwitchIndent,
                                 _usDisplayWidth,
                                 _usIndent);

                    iRC = CMDLINE_ERROR_ARGUMENT_MISSING;
                    break;
                }
				else
				{
					// If the object is not found, it has no default 
					// value and it is not required, reset it. This 
					// action will not harm for normal use, but it 
					// will allow you to reuse the same set of command 
					// line object within the same app.

					pArg->ResetValue();
    			}
            }
        }
    }

    if (iRC == CMDLINE_NO_ERROR)
    {
        // We've got all our expected switches. Now check to see if
        // any switches are left on the command line unparsed,
        // if that's what the user wanted.
        //
        if (fCheckForExtras == TRUE)
        {
            for (i=0; i<_uiNumArgs; i++)
            {
                if (_apArgs[i]->IsProcessed() != TRUE)
                {
                    _sNprintf(_nszErrorBuf,
                             _TEXTN("Unrecognised switch %s\n"),
                             _apArgs[i]->QueryArg());
                    (*_pfnDisplay)(_nszErrorBuf);
                    iRC = CMDLINE_ERROR_UNRECOGNISED_ARG;
                }
            }
        }
    }
    else
    {
        DisplayUsage(apExpectedArgs, uiMaxArgs);
    }

    return(iRC);
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::FindSwitch, private
//
//  Synoposis:  Searches the command line for a given switch, checking
//              for separator and equator characters.
//
//  Effects:    Stores the value of the given switch, if any
//
//  Arguments:  [pArg]            - pointer to the switch object to search
//                                  for
//              [fCheckForExtras] - flag to see if should check for extra
//                                  args.
//
//  Returns:    CMDLINE_NO_ERROR
//              CMDLINE_ERROR_INVALID_VALUE
//              CMDLINE_ERROR_UNRECOGNISED_ARG
//
//  History:    12/23/91 Lizch    Created.
//              04/17/92 Lizch    Converted to NLS_STR
//              07/29/92 Davey    Converted to use DisplayUsageDescr
//                                Also fixed error output, was using
//                                printf, changed to sprintf.  Added
//                                Check for extras flag.
//              02/27/95 jesussp  Corrected the case when the switch
//                                name is non-existent
//				06/25/97 mariusb  Make /<switch>: and /<switch> 
//								  equivalent when the switch takes a 
//								  second argument (i.e. no equator 
//								  means the switch does not take a 
//								  second arg). Useful to specify NULL 
//								  values.
//  Notes:      Terminology to help understand this:
//	Example:    /username:lizch
//              The '/' is the separator
//              The ':' is the equator
//              'username' is the switch
//              'lizch' is the value
//
//-------------------------------------------------------------------
INT CCmdline::FindSwitch(CBaseCmdlineObj * const pArg, BOOL fCheckForExtras)
{
    INT    iRC = CMDLINE_NO_ERROR;
    LPCNSTR nszArg;
    LPCNSTR nszSep;
    LPCNSTR nszSwitch;
    LPCNSTR nszThisSwitch;
    LPCNSTR nszEquater;
    USHORT cchSwitch;
    USHORT usSecondArg  = 1;
    NCHAR  nchSeparator = pArg->GetSeparator();
    NCHAR  nchEquater   = pArg->GetEquater();
    NCHAR  nszSeparator[2];

    // If this switch does NOT take a second argument, we don't advance
    // past the equater when setting the value
    //
    if (!pArg->SecondArg())
    {
        usSecondArg = 0;
    }

    nszSeparator[0] = nchSeparator;
    nszSeparator[1] = nchClNull;

    for (UINT i=0; i<_uiNumArgs; i++)
    {
        nszArg = _apArgs[i]->QueryArg();

        // Find the separator character - it should be the first
        // character in the command line argument. If not, return
        // an error if fCheckForExtras == TRUE.
        //
        nszSep = nszArg;
        if (0 == _ncscspn(nszSep, nszSeparator))
        {
            // Get the switch value - first character after separator
            // up to but not including the equater
            //
            nszSwitch  = nszSep+1;
            nszEquater = nszSwitch;

            // Look for equater
            while ((nchClNull != *nszEquater) && (nchEquater != *nszEquater))
            {
                nszEquater++;
            }
            cchSwitch = (USHORT) (nszEquater - nszSwitch);

            nszThisSwitch = pArg->QuerySwitchString();

            // See if this switch is for this argument
            if (0 != cchSwitch &&
                cchSwitch == _ncslen(nszThisSwitch) &&
                0 == _ncsnicmp(nszSwitch, nszThisSwitch, cchSwitch))
            {
				// If we couldn't find the equater, decrease usSecondArg
				// which means we accept a NULL value for the switch. Thus
				// we make /<switch>: and /<switch> equivalent.
				if (nchEquater != *nszEquater && 1 == usSecondArg)
				{
					--usSecondArg;
				}
	
                // It is - get this switch's value
                _apArgs[i]->SetProcessedFlag(TRUE);

                // Now set the value of the switch (if any). How this is
                // done will vary from object to object: some won't take
                // values, some take lists of values etc.  The polymorphic
                // SetValue call handles this.  We don't want to pass
                // in the equater so add one to get to the beginning
                // of the value.
                //
                iRC = pArg->SetValue(nszSwitch+cchSwitch+usSecondArg);
                if (iRC != CMDLINE_NO_ERROR)
                {
                    pArg->DisplayUsageDescr(
                                 _usSwitchIndent,
                                 _usDisplayWidth,
                                 _usIndent);
                }

                pArg->SetFoundFlag(TRUE);
                // We have found the value for the given switch.

                break;
            } //if
        }
        else
        {
            // Error out if didn't find separator, only if checking for
            // extras
            //
            if (fCheckForExtras == TRUE)
            {
                _sNprintf(
                   _nszErrorBuf,
                   _TEXTN("The initial separator %c was not found on switch %s\n"),
                   nchSeparator,
                   nszArg);

                (*_pfnDisplay)(_nszErrorBuf);

                return(CMDLINE_ERROR_UNRECOGNISED_ARG);
            }
        }
    }

    return(iRC);
}




//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetProgName, public
//
//  Synoposis:  Sets the program name to the passed value
//              This value can later be used in usage statements
//
//  Arguments:  [nszProgName] - the program name
//
//  Returns:    Error code
//
//  History:    Created     05/23/91 Lizch
//
//-------------------------------------------------------------------
INT CCmdline::SetProgName(PNSTR nszProgName)
{


    INT    nRet      = CMDLINE_NO_ERROR;
    NCHAR *pnchStart = nszProgName;
    NCHAR *pnchDot;

    // check for last slash.
    if (NULL != (pnchStart = _ncsrchr(nszProgName, '\\')))
    {
        pnchStart++;   // get past slash
    }
    else
    {
        // there was no slash so check for colon
        if (NULL != (pnchStart = _ncschr(nszProgName, ':')))
        {
            pnchStart++;   // get past colon
        }
        else
        {
            // there was no colon or slash so set to beginning of name
            pnchStart = nszProgName;
        }
    }

    if (NULL != (pnchDot = _ncschr(pnchStart, _TEXTN('.'))))
    {
        *pnchDot = nchClNull;
    }

    _pnszProgName = new NCHAR[_ncslen(pnchStart)+1];
    if (NULL == _pnszProgName)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncscpy(_pnszProgName, pnchStart);
    }

    return(nRet);

}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::GetProgName, public
//
//  Synoposis:  Returns a pointer to the program name
//
//  Arguments:  none
//
//  Returns:    a const NCHAR pointer to the program name
//
//  History:    Created         05/23/91 Lizch
//
//-------------------------------------------------------------------
const NCHAR *CCmdline::GetProgName()
{
    return(_pnszProgName);
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetExtraUsage, public
//
//  Synoposis:  Sets the extra usage file pointer.
//
//  Arguments:  [pfUsage] - function pointer to usage function.
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
void CCmdline::SetExtraUsage(PFVOID pfUsage)
{
    _pfExtraUsage = pfUsage;
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetIndent, public
//
//  Synoposis:  Sets the indent parameter for usage display.
//
//  Arguments:  [usIndent] - how much to indent second lines.
//
//  Returns:    codes from CheckParamerterConsistency
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::SetIndent(USHORT usIndent)
{
    _usIndent = usIndent;
    return(CheckParameterConsistency());
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetSwitchIndent, public
//
//  Synoposis:  Sets the switch indent parameter for usage display.
//
//  Arguments:  [usSwitchIndent] - how much to indent switch.
//
//  Returns:    codes from CheckParamerterConsistency
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::SetSwitchIndent(USHORT usSwitchIndent)
{
    _usSwitchIndent = usSwitchIndent;
    return(CheckParameterConsistency());
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetDisplayWidth, public
//
//  Synoposis:  Sets the amount of line space available for the
//              usage display.
//
//  Arguments:  [usDisplayWidth] - line space available
//
//  Returns:    codes from CheckParamerterConsistency
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::SetDisplayWidth(USHORT usDisplayWidth)
{
    _usDisplayWidth = usDisplayWidth;
    return(CheckParameterConsistency());
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::CheckParameterConsistency, private const
//
//  Synoposis:  Checks to make sure the display parameters are
//              useable.
//
//  Arguments:  None.
//
//  Returns:    CMDLINE_NO_ERROR
//              CMDLINE_ERROR_DISPLAY_PARAMS
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::CheckParameterConsistency(void) const
{
    if (_usSwitchIndent >= _usIndent)
    {
        return(CMDLINE_ERROR_DISPLAY_PARAMS);
    }
    if (_usIndent >= _usDisplayWidth)
    {
        return(CMDLINE_ERROR_DISPLAY_PARAMS);
    }

    return(CMDLINE_NO_ERROR);
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::QueryDisplayParameters, public
//
//  Synoposis:  Returns the three parameters which control the
//              usage display output.
//
//  Arguments:  [pusDisplayWidth] - returns display width
//              [pusSwitchIndent] - returns switch indent
//              [pusIndent]       - returns indent of second lines
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
void CCmdline::QueryDisplayParameters(
        USHORT *pusDisplayWidth,
        USHORT *pusSwitchIndent,
        USHORT *pusIndent) const
{
    *pusDisplayWidth = _usDisplayWidth;
    *pusSwitchIndent = _usSwitchIndent;
    *pusIndent       = _usIndent;
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::DisplayUsage, public
//
//  Synoposis:  Displays usage of switches,
//
//  Arguments:  apExpectedArgs: the array of command line objects
//              uiMaxArgs:      number of elements in the array
//
//  Returns:    Error code from QueryError
//
//  History:    07/28/92 Davey Created.
//
//  Notes:      Looks like:
//
//  Usage Instructions
//  test2         /mc:<worker> [/ml:<log_server>] [/mt:<test>]
//               [/mn:<tester-email>] [/mp:<path>] [/mo:<obj_name>]
//               [/md:<dispatcher>] [/?]
//
//   /mc         Takes a list of strings specifying worker names.
//               These workers should have full names.
//               Don't you think so?
//               The strings in the list are separated by one of the following
//               character(s): ",; ".
//   /ml         Takes a string specifying log server name.
//   /mt         Takes a string specifying name of the test.
//   /mn         Takes a string specifying email name of the tester.
//   /mp         Takes a string specifying path name to log to.
//   /mo         Takes a string specifying name of the object.
//   /md         Takes a string specifying name of the dispatcher to use.
//   /?          Flag specifying command line usage. It defaults to FALSE.
//
//   ***following is whatever is output by the function pfnExtraUsage****
//
//-------------------------------------------------------------------
INT CCmdline::DisplayUsage(
        CBaseCmdlineObj * const apExpectedArgs[],
        UINT                    uiMaxArgs)
{
    USHORT usWidth = _usDisplayWidth;
    USHORT StrLen;
    INT    iRC;
    USHORT cchProgName;
    PNSTR  pnszLine;
    USHORT i;

    (*_pfnDisplay)(_TEXTN("\nUsage Instructions\n"));

    // Start creating usage line.
    //

    // Determine length to make line buffer - if the size of the program
    // name is less than the indentation, the buffer needs to be at
    // least as big as the indentation, less 1 for an extra space that
    // gets printed.
    cchProgName = (USHORT) _ncslen(_pnszProgName);

    if (cchProgName < _usIndent)
    {
        // Add 1 for null term
        StrLen = (USHORT) (_usIndent + 1);
    }
    else
    {
        // Add 1 for null term, 1 for new line and indent in next line
        StrLen = (USHORT) (cchProgName + _usIndent + 2);
    }

    // copy program name
    //
    pnszLine = new NCHAR[StrLen];
    if (NULL == pnszLine)
    {
        return(CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    _ncscpy(pnszLine, _pnszProgName);

    // if the size of the program name is less than indentation then
    // add in padding; else add in a new line and then padding.
    //
    if (cchProgName >= _usIndent)
    {
        _ncscat(pnszLine, nszClNewLine);
    }
    // fill in with spaces until get to indent position
    for (i = (USHORT) _ncslen(pnszLine); i < StrLen - 1; i++)
    {
        _ncscat(pnszLine, nszClSpace);
    }

    // output program name
    //
    (*_pfnDisplay)(pnszLine);

    // update remaining display width
    //
    usWidth = (USHORT) (usWidth - _usIndent);

    // done with pnszLine - delete it now to avoid leaks in case of
    // errors
    //
    delete pnszLine;

    // display the command line usage statement, required ones first
    //
    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == TRUE)
        {
            iRC = apExpectedArgs[i]->DisplayUsageLine(
                                            &usWidth,
                                            _usDisplayWidth,
                                            _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == FALSE)
        {
            iRC = apExpectedArgs[i]->DisplayUsageLine(
                                            &usWidth,
                                            _usDisplayWidth,
                                            _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    // print out if using internal usage.
    //
    if (_pbcInternalUsage != NULL)
    {
        iRC = _pbcInternalUsage->DisplayUsageLine(
                                        &usWidth,
                                        _usDisplayWidth,
                                        _usIndent);
        if (iRC)
        {
            SetError(iRC);
            return(iRC);
        }
    }


    // separate the line and descriptions
    (*_pfnDisplay)(_TEXTN("\n\n"));

    // display the switch descriptions, required ones first
    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == TRUE)
        {
            iRC = apExpectedArgs[i]->DisplayUsageDescr(
                                            _usSwitchIndent,
                                            _usDisplayWidth,
                                            _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == FALSE)
        {
            iRC = apExpectedArgs[i] -> DisplayUsageDescr(
                                              _usSwitchIndent,
                                              _usDisplayWidth,
                                              _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    // print out if using internal usage.
    //
    if (_pbcInternalUsage != NULL)
    {
        iRC = _pbcInternalUsage->DisplayUsageDescr(
                                        _usSwitchIndent,
                                        _usDisplayWidth,
                                        _usIndent);
        if (iRC)
        {
            SetError(iRC);
            return(iRC);
        }
    }


    (*_pfnDisplay)(_TEXTN("\n\n"));

    // invoke the special usage function if defined.
    if (_pfExtraUsage != NULL)
    {
        _pfExtraUsage();
    }

    return(CMDLINE_NO_ERROR);
}

//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetInternalUsage, private
//
//  Synposis:   Sets the internal usage flag
//
//  Effects:    Modifies _pcbInternalUsage, so that it displays
//
//  Arguments:  none
//
//  Returns:    CMDLINE_NO_ERROR
//              CMDLINE_ERROR_OUT_OF_MEMORY
//
//
//  History:    02/06/95 jesussp  Created
//
//  Notes:
//-------------------------------------------------------------------

INT CCmdline::SetInternalUsage(void)
{
INT iError;             // Error to be returned

    _pbcInternalUsage = new CBoolCmdlineObj(_TEXTN("?"), _TEXTN("command line usage."));
    if (NULL == _pbcInternalUsage)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        SetError(_pbcInternalUsage->QueryError());
    }
    iError = QueryError();
    if (CMDLINE_NO_ERROR != iError)
    {
        // Since QueryError always sets CMDLINE_NO_ERROR, we need to
        // call SetError to put the error back.
        SetError(iError);
    }
    return iError;
}

//+------------------------------------------------------------------
//
//  Function:   DelimitWithNulls, private
//
//  Synposis:   Delimits an argument string, putting a null byte
//              between parameters and an additional extra null byte
//              at the end of the string. For use by CCmdline
//              constructor.
//
//  Effects:    Copies pnszArgLine to pnszDest. Space must be
//              allocated for both strings. Modifies uiArgc.
//
//  Arguments:  [pnszArgLine]     The line with arguments
//              [pnszDest]        Null-delimited destination
//              [puiArgc]         Pointer to an argument count
//
//  Returns:    Nothing
//
//
//  History:    02/10/95 jesussp  Created
//
//  Notes:      Inspired on parse_cmdline(), crt32\startup\stdargv.c
//              pnszArgLine and pnszDest must point to valid memory
//              allocations. Also, the space allocation for
//              pnszDest must be greater than that of pnszArgLine.
//-------------------------------------------------------------------

static void DelimitWithNulls(LPNSTR  pnszArgLine,
                             LPNSTR  pnszDest,
                             UINT    *puiArgc)
{
    LPNSTR pncSrc = pnszArgLine;
    LPNSTR pncDst = pnszDest;

    BOOL    fInQuote    = 0;
    USHORT  ucBackSlash = 0;
    USHORT  ucQuotes    = 0;


    *puiArgc = 0;

    // Loop through the entire argument line

    for (;;)
    {
       // skip blanks
       while (*pncSrc && _isnspace(*pncSrc))
       {
          ++pncSrc;
       }

       // Reached the end of the string?
       if (nchClNull == *pncSrc)
       {
          // Put a null byte at the end only if we haven't had
          // any argument...

          if (0 == *puiArgc)
          {
              *pncDst++ = nchClNull;
          }
          break;
       }

       // We now have one more argument...
       ++(*puiArgc);

       // process one argument

       for (;;)
       {

          ucBackSlash = 0;

          while (nchClBackSlash == *pncSrc)
          {
              ++pncSrc; ++ucBackSlash;
          }

      	  if (nchClQuote == *pncSrc)
          {
             if (ucBackSlash % 2 == 0)   // Even number of backslashes?
      	     {
                fInQuote = !fInQuote;
      	        ++pncSrc;                // Eat up quote
      	     }
      	     ucBackSlash /= 2;
      	  }

          while (ucBackSlash--)
          {
      	      *pncDst++ = nchClBackSlash;
      	  }

      	  if (nchClNull == *pncSrc || (!fInQuote && _isnspace(*pncSrc)))
      	  {
      	     break;
      	  }

      	  *pncDst++ = *pncSrc++;
       }

       if (fInQuote)
       {
           *pncDst++ = nchClSpace;
       }
       else
       {
           *pncDst++ = nchClNull;
       }
    }

    // Complete the string, adding an extra nul character

    *pncDst = nchClNull;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cmdarg.cxx ===
//+------------------------------------------------------------------
//
//  File:       cmdarg.cxx
//
//  Contents:   implementation of CCmdlineArg class
//
//  Synoposis:  CCmdlineArg encapsulates an argv string.
//
//  Classes:    CCmdlineArg
//
//  Functions:
//
//  History:    12/30/91 Lizch Created
//              04/17/92 Lizch Converted to NLS_STR
//              09/18/92 Lizch Precompile headers
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


//+------------------------------------------------------------------
//
//  Function:   Constructor for CCmdlineArg
//
//  Synoposis:  Makes a copy of one argv string.
//
//  Arguments:  [nszArg] - an argv element
//
//  Returns:    nothing
//
//  History:    Created              12/30/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
CCmdlineArg::CCmdlineArg(LPCNSTR nszArg)
{
    _fProcessed = FALSE;
    _pnszArgument = new NCHAR[_ncslen(nszArg)+1];
    if (NULL != _pnszArgument)
    {
        _ncscpy(_pnszArgument, nszArg);
    }
    else
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
}


//+------------------------------------------------------------------
//
//  Function:   Destructor for CCmdlineArg
//
//  Synoposis:  Frees resources allocated in constructor.
//
//  Arguments:  None
//
//  Returns:    nothing
//
//  History:    Created              10/25/93 DeanE
//
//-------------------------------------------------------------------
CCmdlineArg::~CCmdlineArg()
{
    delete _pnszArgument;
}


//+------------------------------------------------------------------
//
//  Function:   IsProcessed
//
//  Synoposis:  Indicates whether this argument has been processed on
//              the command line. If FALSE, it probably indicates that
//              an unexpected switch was supplied.
//
//  Arguments:  none
//
//  Returns:    TRUE if processed, FALSE otherwise
//
//  History:    Created          05/30/92 Lizch
//
//-------------------------------------------------------------------
const BOOL CCmdlineArg::IsProcessed()
{
    return(_fProcessed);
}


//+------------------------------------------------------------------
//
//  Function:   SetProcessedFlag
//
//  Synoposis:  Sets whether this argument has been found on the command
//              line.
//
//  Arguments:  fProcessed - TRUE if found, FALSE otherwise
//
//  Returns:    nothing
//
//  History:    Created          05/30/92 Lizch
//
//-------------------------------------------------------------------
void CCmdlineArg::SetProcessedFlag(BOOL fProcessed)
{
    _fProcessed = fProcessed;
}


//+------------------------------------------------------------------
//
//  Function:   QueryArg
//
//  Synoposis:  Returns a pointer to this argument
//
//  Arguments:  none
//
//  Returns:    a NCHAR pointer to the argument
//
//  History:    Created          05/30/92 Lizch
//
//-------------------------------------------------------------------
LPCNSTR CCmdlineArg::QueryArg()
{
    return(_pnszArgument);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\cmdlinew\cstrlist.cxx ===
//+------------------------------------------------------------------
//
//  File:       cstrlist.cxx
//
//  Contents:   implementation for CStrListCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch that takes a list
//              of strings.
//
//  Classes:    CStrListCmdlineObj
//
//  Functions:
//
//  History:    12/27/91 Lizch      Created
//              04/17/92 Lizch      Converted to NLS_STR
//              05/11/92 Lizch      Incorporated review feedback
//              07/07/92 Lizch      Added GetValue method
//              07/29/92 davey      Added nlsType and nlsLineArgType
//              09/09/92 Lizch      Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch      Precompile headers
//              10/14/93 DeanE      Converted to WCHAR
//              12/23/93 XimingZ    Converted to CWStrList
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions

LPCNSTR nszDefaultDelims = _TEXTN(",; ");
LPCNSTR nszCmdlineType   = _TEXTN("Takes a list of strings ");
LPCNSTR nszLineArgType   = _TEXTN("<string_list>");


//+------------------------------------------------------------------
//
//  Function:   CStrListCmdlineObj Constructor (1 of 2)
//
//  Member:     CStrListCmdlineObj
//
//  Synoposis:  Initialises switch string, usage values and whether the
//              switch is mandatory. This constructor gives no default value
//              for this switch. Also initialises the Delimiters
//
//  Effects:
//
//  Arguments:  [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [fMustHave]  - whether the switch is mandatory or not.
//                             if it is, an error will be generated if
//                             the switch is not specified on the
//                             command line. Defaults to FALSE.
//              [nszLineArg] - line argument string
//
//  Returns:    none, but sets _iLastError
//
//  History:    04/17/92 Lizch Created
//              08/03/92 Davey Added nlsLineArg
//
//-------------------------------------------------------------------
CStrListCmdlineObj::CStrListCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        BOOL   fMustHave,
        LPCNSTR nszLineArg) :
        CBaseCmdlineObj(nszSwitch, nszUsage, fMustHave, nszLineArg),
        _pNStrList(NULL)
{
    SetDelims(nszDefaultDelims);
}


//+------------------------------------------------------------------
//
//  Function:   CStrListCmdlineObj Constructor (2 of 2)
//
//  Member:     CStrListCmdlineObj
//
//  Synoposis:  Initialises switch string, usage strings and default value.
//              Also initialises the Delimiters
//              This constructor is only used if a switch is optional.
//
//  Effects:    Sets fMandatory to FALSE (ie. switch is optional)
//
//  Arguments:  [nszSwitch]   - the expected switch string
//              [nszUsage]    - the usage statement to display
//              [nszDefault]  - the value to be used if no switch is
//                              specified on the command line.
//              [nszLineArg]  - line argument string
//
//  Returns:    none, but sets _iLastError
//
//  History:    04/17/92 Lizch Created.
//              08/03/92 Davey Added nlsLineArg
//
//-------------------------------------------------------------------
CStrListCmdlineObj::CStrListCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        LPCNSTR nszDefault,
        LPCNSTR nszLineArg) :
        CBaseCmdlineObj(nszSwitch, nszUsage, nszDefault, nszLineArg),
        _pNStrList(NULL)
{
    SetDelims(nszDefaultDelims);
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::SetDelims, public
//
//  Synoposis:  Sets Delimiters for items within the list.
//
//  Arguments:  [nszDelims] - the list of possible separators
//
//  Returns:    ERROR_NOT_ENOUGH_MEMORY or NO_ERROR
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
INT CStrListCmdlineObj::SetDelims(LPCNSTR nszDelims)
{
    INT nRet = CMDLINE_NO_ERROR;

    _pnszListDelims = new NCHAR[_ncslen(nszDelims)+1];
    if (NULL == _pnszListDelims)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncscpy(_pnszListDelims, nszDelims);
    }

    return(nRet);
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::~CStrListCmdlineObj
//
//  Synoposis:  Frees the string list associated with the object
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//              Converted to WSTRLIST 12/23/93 XimingZ
//
//-------------------------------------------------------------------
CStrListCmdlineObj::~CStrListCmdlineObj()
{
    delete (NCHAR *)_pValue;
    _pValue = NULL;
    delete _pNStrList;
    delete _pnszListDelims;
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::SetValue, public
//
//  Synoposis:  Uses the CnStrList class to store the list of strings
//              following a command line switch, eg. "M1" "M2" "M3" from
//              "/computers:M1,M2,M3"
//
//  Arguments:  [nszArg] - the string following the switch on the command
//                         line. Excludes the equator (eg. ':' or '=' ).
//
//  Returns:    CMDLINE_NO_ERROR or CMDLINE_ERROR_OUT_OF_MEMORY
//
//  History:    Created                12/27/91 Lizch
//              Converted to NLS_STR   04/17/92 Lizch
//              Converted to CnStrList 12/23/93 XimingZ
//
//-------------------------------------------------------------------
INT CStrListCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT nRet = CMDLINE_NO_ERROR;

    // delete any existing pValue and pWStrList.
    if (_pValue != NULL)
    {
        delete (NCHAR *)_pValue;
        _pValue = NULL;
    }
    if (_pNStrList != NULL)
    {
        delete _pNStrList;
        _pNStrList = NULL;
    }


    if (nszArg == NULL)
    {
        _pValue = NULL;
    }
    else
    {
        _pValue = new NCHAR[_ncslen(nszArg)+1];
        if (_pValue == NULL)
        {
            nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
        }
        else
        {
            _ncscpy((NCHAR *)_pValue, nszArg);
        }

        _pNStrList = new CnStrList(nszArg, _pnszListDelims);
        if (_pNStrList == NULL ||
            _pNStrList->QueryError() != NSTRLIST_NO_ERROR)
        {
            nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
        }
    }
    return(nRet);
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::ResetValue, public
//
//  Synopsis:   Releases all the internal elements of the object.
//              
//              
//
//  Arguments:  [nszArg] - the string following the switch on the command
//                         line. Excludes the equator (eg. ':' or '=' ).
//
//  Returns:    CMDLINE_NO_ERROR or CMDLINE_ERROR_OUT_OF_MEMORY
//
//  History:    Created                06/13/97 MariusB
//
//-------------------------------------------------------------------
void CStrListCmdlineObj::ResetValue()
{
    // delete any existing pValue and pWStrList.
    if (_pValue != NULL)
    {
        delete (NCHAR *)_pValue;
        _pValue = NULL;
    }

    if (_pNStrList != NULL)
    {
        delete _pNStrList;
        _pNStrList = NULL;
    }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::GetValue, public
//
//  Synposis:   Returns pointer to NCHAR string that holds the next value.
//              If no next value exists, NULL is returned. The returned
//              string will stay alive only within the lifetime of the
//              current CStrListCmdlineObj object and before any call to
//              SetValue.
//
//  Arguments:  void
//
//  Returns:    LPCNSTR
//
//  History:    Created   7/07/92  Lizch
//              Changed to CnStrList  12/23/93  XimingZ
//
//-------------------------------------------------------------------
LPCNSTR CStrListCmdlineObj::GetValue()
{
        if (_pNStrList == NULL)
        {
            return NULL;
        }
        return _pNStrList->Next();
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::Reset, public
//
//  Synposis:   Reset string iterator.
//
//  Arguments:  void
//
//  Returns:    none
//
//  History:    Created  12/23/93  XimingZ
//
//-------------------------------------------------------------------
VOID CStrListCmdlineObj::Reset()
{
        if (_pNStrList != NULL)
        {
            _pNStrList->Reset();
        }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::DisplayValue, public
//
//  Synoposis:  Prints the stored command line value to stdout.
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//              Changed to CnStrList 12/23/93 XimingZ
//
//-------------------------------------------------------------------
void CStrListCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        LPCNSTR      pnszItem;
        CnStrList   StringList((NCHAR *)_pValue, _pnszListDelims);
        _sNprintf (_nszErrorBuf,
                  _TEXTN("Switch %ls specified the following strings\n"),
                  _pnszSwitch);
        (_pfnDisplay)(_nszErrorBuf);

        while ((pnszItem = StringList.Next()) != NULL)
        {
            _sNprintf(_nszErrorBuf, _TEXTN("\t%ls\n"), pnszItem);
            (*_pfnDisplay)(_nszErrorBuf);
        }

    }
    else
    {
        DisplayNoValue();
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CStrListCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
const NCHAR *CStrListCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineType);
}


//+-------------------------------------------------------------------
//
//  Method:     CStrListCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NLS_STR reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
const NCHAR *CStrListCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgType);
    }
    else
    {
        return(_pnszLineArgType);
    }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::DisplaySpecialUsage, protected
//
//  Synoposis:  Prints the switch usage statement to stdout
//
//  Arguments:  [usDisplayWidth] - total possible width available
//                                 to display
//              [usIndent]       - amount to indent.
//              [pusWidth]       - space to print on current line
//
//  Returns:    error code from QueryError,
//              error code from DisplayStringByWords
//
//  History:    12/27/91 Lizch    Created
//              04/17/92 Lizch    Converted to NLS_STR
//              07/29/92 Davey    Modified to work with new usage display
//
//-------------------------------------------------------------------
INT CStrListCmdlineObj::DisplaySpecialUsage(
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    NCHAR nszBuf[150];
    _sNprintf(nszBuf,
             _TEXTN(" The strings in the list are separated by one of the")
             _TEXTN(" following character(s): \"%ls\"."),
             _pnszListDelims);

    return(DisplayStringByWords(
                  nszBuf,
                  usDisplayWidth,
                  usIndent,
                  pusWidth));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\datagen\pch.cxx ===
//+------------------------------------------------------------------
//
// File:        pch.cxx
//
// Contents:    precompiled headers for dg.lib
//
// Synoposis:
//
// Classes:
//
// Functions:
//
// History:     10/18/93    DeanE   Created
//
//-------------------------------------------------------------------
#include "pch.hxx"

#pragma  hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\datagen\dg_uni.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_UNICODE.cxx
//
//   Contents:  Definition for DataGen DG_UNICODE class.
//
//    Classes:  DG_UNICODE    - Class to generate 8-bit random strings.
//
//  Functions:  DG_UNICODE::DG_UNICODE()
//              DG_UNICODE::Generate()      All varieties
//              DG_UNICODE::_LenMem()
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::DG_UNICODE, public
//
//   Synopsis:  Calls DG_INTEGER class constructor, and initializes _fNull.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//   Modifies:  _fNull
//
//  Algorithm:  Calls the DG_INTEGER constructor, and initializes _fNull.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_UNICODE::DG_UNICODE(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(range), public
//
//   Synopsis:  Produces a random 16-bit character, random length string.
//              The "randomness" of the characters may be constrained by
//              value parameters passed to the function, and the length
//              by length parameters passed to the function.
//
//  Arguments:  [**pwchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                     allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                    maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              use the integer generator to fill in the string.
//
//      Notes:  At this time, only wide character support is provided.  When
//              true UNICODE fuctionality becomes available in Win32, it will
//              be added here.
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwchString,
                            ULONG   *pulLength,
                            WCHAR    wchMinVal,
                            WCHAR    wchMaxVal,
                            ULONG     ulMinLen,
                            ULONG     ulMaxLen)
{
    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(pwchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with random characters.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        WCHAR wch;
        _usRet = DG_INTEGER::Generate(&wch, wchMinVal, wchMaxVal);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*pwchString)[i] = wch;
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *pwchString;
            *pwchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(NULL), public
//
//   Synopsis:  Generates a NULL terminated string by setting the _fNull
//              variable to TRUE, which causes an extra space containing
//              the NULL character to be put at the end the string, casting
//              the appropriate arguments, and calling the Generate(range)
//              member function to perform the actual work.
//
//  Arguments:  [**pwcsString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  See the Generate(range) member function.
//
//   Modifies:  _fNull
//
//  Algorithm:  Set _fNull to TRUE and call the Generate(range) member
//              function to do the actual work.
//
//      Notes:
//
//    History:  19-May-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwszString,
                            WCHAR    wchMinVal,
                            WCHAR    wchMaxVal,
                            ULONG     ulMinLen,
                            ULONG     ulMaxLen)
{
    _fNull = TRUE;
    ULONG ulLength;
    return Generate((WCHAR **)pwszString,
                               &ulLength,
                               wchMinVal,
                               wchMaxVal,
                                ulMinLen,
                                ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(selection), public
//
//
//   Synopsis:  Produces a random 16-bit character, random length string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**pwchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [*pwchSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulSelLength] - the length of the selection string.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwchString,
                            ULONG   *pulLength,
                            WCHAR  *pwchSelection,
                            ULONG     ulSelLength,
                            ULONG     ulMinLen,
                            ULONG     ulMaxLen)
{
    // Handle the special cases of:
    //   1) the pwchSelection being NULL
    //   2) the pwchSelection argument is empty (ulSelLength = 0)
    //
    if (pwchSelection == NULL)
    {
        return Generate(pwchString,
                        pulLength,
                        (WCHAR)0,
                        WCHAR_MAX,
                        ulMinLen,
                        ulMaxLen);
    }
    if (ulSelLength == 0)
    {
        *pwchString = NULL;
        *pulLength = 0;
        return _usRet;
    }

    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(pwchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with characters randomly chosen from
    // the selection string.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        ULONG ul;
        _usRet = DG_INTEGER::Generate(&ul, 0L, ulSelLength - 1L);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*pwchString)[i] = pwchSelection[ul];
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *pwchString;
            *pwchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(selection, NULL), public
//
//
//   Synopsis:  Produces a random 16-bit character, random length, NULL-
//              terminated string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**pwszString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pwszSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  8-Jun-92  DeanE     Cut & paste from Generate(NULL).
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwszString,
                            WCHAR  *pwszSelection,
                            ULONG   ulMinLen,
                            ULONG   ulMaxLen)
{
    _fNull = TRUE;
    ULONG ulLength;
    ULONG ulSelLength;
    ulSelLength = wcslen(pwszSelection);
    return Generate(pwszString,
                    &ulLength,
                    pwszSelection,
                    ulSelLength,
                    ulMinLen,
                    ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::_LenMem, private
//
//   Synopsis:  Determine the size needed to create the ASCII string, and
//              then allocate that much memory for it.
//
//  Arguments:  [**pwchString] - pointer to the pointer which will point to
//                               the beginning memory for the string.
//
//              [*pulLength] - pointer to the memory in which to store the
//                             length of the string.
//
//              [ulMinLen] - the minimum length of the string.
//
//              [ulMaxLen] - the maximum length of the string.
//
//    Returns:  DG_RC_SUCCESS -- if successful.
//
//              DG_RC_BAD_STRING_PTR -- if the string location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTH_PTR -- if the length location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTHS -- if the minimum length is greater than
//                                   the maximum lengths.
//
//              DG_RC_OUT_OF_MEMORY -- if space for the string cannot be
//                                     allocated.
//
//  Algorithm:  Verify the arguments.  Then if this is the default case,
//              generate a length with an expected value of 5 (see section
//              4.3 of the DataGen Design Specification for details).  If
//              this is not the default case, then generate a length using
//              the values provided.
//
//      Notes:
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

VOID DG_UNICODE::_LenMem(WCHAR **pwchString,
                         ULONG   *pulLength,
                         ULONG     ulMinLen,
                         ULONG     ulMaxLen)
{
    // This value will produce an expected string length of 5 in
    // the default case.  Hence the name 'E5'.
    //
    const FLOAT E5 = 0.20F;

    // Perform parameter checks.
    //
    if (pwchString == NULL)
    {
        _usRet = DG_RC_BAD_STRING_PTR;
        return;
    }
    else if (pulLength == NULL)
    {
        _usRet = DG_RC_BAD_LENGTH_PTR;
        return;
    }
    else if (ulMinLen > ulMaxLen)
    {
        _usRet = DG_RC_BAD_LENGTHS;
        return;
    }

    // If the default case is being used, then generate a length with the
    // expected value of 5.  Otherwise generate a number from the range
    // values given.  See section 4 of the DataGen Design Specification
    // for details.
    //
    if ((ulMinLen == 1) && (ulMaxLen == DG_DEFAULT_MAXLEN))
    {
        *pulLength = ulMinLen;
        while ((*pulLength < ulMaxLen) && (_Floater() > E5))
        {
            (*pulLength)++;
        }
    }
    else
    {
        ULONG ul;
        _usRet = DG_INTEGER::Generate(&ul, ulMinLen, ulMaxLen);
        if (_usRet == DG_RC_SUCCESS)
        {
            *pulLength = ul;
        }
        else
        {
            // Something went wrong, so stick a NULL
            // into the pointer, and a 0 into the length.
            //
            *pwchString = NULL;
            *pulLength = 0;
            return;
        }
    }

    // Allocate memory based on the length.  If _fNull is true, then add 1
    // extra character for a terminating NULL character.  _fNull will be
    // true whenever we are generating a NULL terminated string.
    //
    if (_fNull == TRUE)
    {
        *pwchString = new WCHAR[*pulLength + 1];
        if (*pwchString != NULL)
        {
            (*pwchString)[*pulLength] = (WCHAR)0;
            _fNull = FALSE;
        }
    }
    else
    {
        *pwchString = new WCHAR[*pulLength];
    }

    // Check for errors.
    //
    if (*pwchString == NULL)
    {
        _usRet = DG_RC_OUT_OF_MEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\datagen\dg_int.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_INTEGER.cxx
//
//   Contents:  Definition for DataGen DG_INTEGER class.
//
//    Classes:  DG_INTEGER    - Class to produce random interegers of any
//                              integer data type.
//
//  Functions:  DG_INTEGER::DG_INTEGER()
//              DG_INTEGER::Generate()        All varieties
//
//    History:  28-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//              11-Mar-92  RonJo     Ported to Win32 and separated DG and
//                                   DataGen functionality.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>
#include <stdlib.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_INTEGER::DG_INTEGER, public
//
//   Synopsis:  Calls the DG_BASE constructor to perform needed setup.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//  Algorithm:  Calls the DG_BASE constructor.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  28-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_INTEGER::DG_INTEGER(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_INTEGER::Generate(ULONG), public
//
//   Synopsis:  Generate a random ULONG number, bounded by ulMinVal and
//              ulMaxVal.
//
//  Arguments:  [*pulNumber] - pointer to where the user wants the random
//                             number stored.
//
//              [ulMinVal] - minimum value desired as a random number.
//
//              [ulMaxVal] - maximum value desired as a random number.
//
//              [bStd] - Use standard 'C' library random number generator
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number argument passed in is
//                                      invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//   Modifies:  _ulNumber
//
//  Algorithm:  Generate a new base number by multiplying it with a constant,
//              add 1, and take the modulo of the maximum unsigned long value.
//              Then take the new base number times the range determined by
//              the values, divide by the maximum unsigned long value and add
//              the minimum desired value.  This will produce a number in the
//              range [ulMinVal, ulMaxVal].
//
//      Notes:  See _Algorithms in C_ by Robert Sedgewick for full algorithm
//              explanation and constant, ulB, selection.
//
//    History:  28-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//              04-March-97  EyalS   modified to use std rand() by default
//                           (added bStd & code to use rand())
//
//
//----------------------------------------------------------------------------

USHORT DG_INTEGER::Generate(ULONG *pulNumber, ULONG ulMinVal, ULONG ulMaxVal, BOOL bStd)
{
    const ULONG ulB = 314159621;
    ULONG ulTmp;

    //
    // Extnesion: Use standard library random # generator
    //
    if(pulNumber != NULL &&
       bStd){
       //
       // use std 'c' library
       //

       //
       // init return number to low bound
       //
       *pulNumber = ulMinVal;
       ULONG ulRange = ulMaxVal - ulMinVal;
       if(ulRange >= RAND_MAX){
          //
          // We make the assumpution that if x = 3*y then
          // rand(x) ~= 3 * rand(y), that is equivalent not equal...
          // - cycle as long as RAND_MAX > remaining range as we subtract it
          //
          //
          for(ulTmp = ulRange;
              ulTmp > RAND_MAX;
              ulTmp-=RAND_MAX){
             *pulNumber += rand();
          }
          //
          // & the last remaining cycle;
          //
          if(ulTmp != 0)
            *pulNumber += rand() % ulTmp;
       }
       else{
          //
          // well the num is an int range, so just use it
          //
          if(ulRange != 0)
            *pulNumber += (ULONG)(rand() % (INT)(1 + ulRange));
       }

    }
    //
    // Original code
    //
    else if (pulNumber != NULL)
    {
        // Make the range a double so that when the multiplication is
        // performed, we will not need to worry about overflow and will
        // get higher precision.
        //
        DOUBLE dblRange = (DOUBLE)(ulMaxVal - ulMinVal);

        if (dblRange > 0.0)
        {
            // Must add 1.0 to the range to change the result from
            // [Min, Max) to [Min, Max].
            //
            dblRange += 1.0;
            _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
            *pulNumber = (ULONG)(((_ulNumber * dblRange) / (double)(unsigned long)ULONG_MAX) + ulMinVal) % ULONG_MAX;
        }
        else if (dblRange == 0.0)
        {
            *pulNumber = ulMinVal;
        }
        else
        {
            _usRet = DG_RC_BAD_VALUES;
        }
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_INTEGER::Generate(@), public
//
//   Synopsis:  All integer data type generator functions operate by calling
//              the ULONG generator function and casting the arguments
//              appropriately.
//
//  Arguments:  [*p@Number] - pointer to storage for the particular data
//                            type desired.
//
//              [@MinVal] - minimum value desired as a random number.
//
//              [@MaxVal] - maximum value desired as a random number.
//
//    Returns:  Returns what is produced by the ULONG Generate member
//              function, cast appropriately.
//
//  Algorithm:  See the Generate(ULONG) member function.
//
//      Notes:
//
//    History:  28-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

USHORT DG_INTEGER::Generate(SCHAR *pschNumber, SCHAR schMinVal, SCHAR schMaxVal)
{
    // Perform argument error checking.
    //
    if (pschNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)schMinVal;
    ULONG ulMaxVal = (ULONG)schMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pschNumber = (SCHAR)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(UCHAR *puchNumber, UCHAR uchMinVal, UCHAR uchMaxVal)
{
    // Perform argument error checking.
    //
    if (puchNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)uchMinVal;
    ULONG ulMaxVal = (ULONG)uchMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *puchNumber = (UCHAR)ulNumber;
    }
    return _usRet;
}

#ifndef WIN16

USHORT DG_INTEGER::Generate(SHORT *psNumber, SHORT sMinVal, SHORT sMaxVal)
{
    // Perform argument error checking.
    //
    if (psNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)sMinVal;
    ULONG ulMaxVal = (ULONG)sMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *psNumber = (SHORT)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(USHORT *pusNumber, USHORT usMinVal, USHORT usMaxVal)
{
    // Perform argument error checking.
    //
    if (pusNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)usMinVal;
    ULONG ulMaxVal = (ULONG)usMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pusNumber = (USHORT)ulNumber;
    }
    return _usRet;
}

#endif

USHORT DG_INTEGER::Generate(INT *pintNumber, INT intMinVal, INT intMaxVal)
{
    // Perform argument error checking.
    //
    if (pintNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)intMinVal;
    ULONG ulMaxVal = (ULONG)intMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pintNumber = (INT)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(UINT *puintNumber, UINT uintMinVal, UINT uintMaxVal)
{
    // Perform argument error checking.
    //
    if (puintNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)uintMinVal;
    ULONG ulMaxVal = (ULONG)uintMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *puintNumber = (UINT)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(LONG *plNumber, LONG lMinVal, LONG lMaxVal)
{
    // Only need to cast the values here since LONGs and ULONGs take
    // up the same amount of space.
    //
    return Generate((ULONG *)plNumber, (ULONG)lMinVal, (ULONG)lMaxVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\h\comtpch.cxx ===
//+------------------------------------------------------------------
//
// File:        comtpch.cxx
//
// Contents:    headers to precompile when building all directories
//              in common.
//
// History:     19-Nov-94   DaveY   Created
//
//-------------------------------------------------------------------

#include <comtpch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\datagen\dg_base.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_BASE.cxx
//
//   Contents:  Definition for DataGen DG_BASE class.
//
//    Classes:  DG_BASE    - Base class for all DataGen classes.
//
//  Functions:  DG_BASE::DG_BASE()
//              DG_BASE::~DG_BASE()
//              DG_BASE::SetSeed()
//              DG_BASE::GetSeed()
//              DG_BASE::Error()
//              DG_BASE::_Multiply()
//              DG_BASE::_Floater()
//              DG_BASE::_BitReverse()
//
//    History:  16-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Moved Error() member function form
//                                   DATAGEN class to DG_BASE class.
//
//              11-Mar-92  RonJo     Ported to Win32 and separated DG and
//                                   DataGen functionality.
//
//              04-Apr-95  DarrylA   Changed ULONG_MAX_SQRT calc to compile
//                                   time bit operation.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


//
// CLASS WIDE VARIABLES
//

// To get the max sqrt, figure as follows.
// 0xffff = (2^16)-1
// sqrt(2^16) = 2^8
// We need the next smallest sqrt which is (2^8)-1, which is half the bits
// set in the original value, or max_sqrt(0xffff) = 0xff.
// So, right shift the number by half the number of bytes * bits-per-byte.

// Note that this is only valid if ULONG_MAX == ~(0U), otherwise the
// result may be too big. While this is probably always true, we will
// guarantee this here.

#if !(ULONG_MAX == 0xffffffffUL)
#error ULONG_MAX not as expected
#endif

ULONG DG_BASE::ULONG_MAX_SQRT = (ULONG_MAX >> ((sizeof(ULONG) * 8) / 2));


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::DG_BASE, public
//
//   Synopsis:  Sets static member data ULONG_MAX_SQRT and calls SetSeed to
//              do the rest.
//
//  Arguments:  [ulNewSeed] -- The seed value to use as the internal seed.
//
//  Algorithm:  Sets ULONG_MAX_SQRT is it has not already been set,
//              initializes the return variable and the error strings,
//              and then calls SetSeed to do the rest of the work.
//
//      Notes:
//
//    History:  16-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Added initialization of return variable
//                                   and the error strings.
//
//----------------------------------------------------------------------------

DG_BASE::DG_BASE(ULONG ulNewSeed)
{
    // Initialize the return variable and the error strings.
    //
    _usRet = DG_RC_SUCCESS;

    // Let SetSeed do the rest of the work.
    //
    (VOID)SetSeed(ulNewSeed);
}


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::~DG_BASE, public
//
//   Synopsis:  Performs no function at this time.
//
//  Arguments:  None.
//
//  Algorithm:
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  16-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_BASE::~DG_BASE(void)
{
    //
    // Implemented as an inline function.
    //
}
#endif  // DOCGEN


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::SetSeed, public
//
//   Synopsis:  Sets up the random number tables based upon the new internal
//              seed.
//
//  Arguments:  [ulNewSeed] - the value to use as the new internal seed,
//                            _ulSeed.
//
//    Returns:  Always DG_RC_SUCCESS
//
//   Modifies:  _ulSeed
//              _ulNumber
//
//  Algorithm:  Sets the _ulSeed to ulNewSeed.  If _ulNewSeed is 0, then set
//              _ulSeed to the time.  Take _ulSeed, reverse the bits and xor
//              the result with _ulSeed to get the base number, _ulNumber.
//
//      Notes:
//
//    History:  16-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BASE::SetSeed(ULONG ulNewSeed)
{

    // If the new seed value is 0, set _ulSeed to the time, otherwise set
    // it to the seed value given.  GetTickCount gives a much more accurate
    // timing value, but it is not available under win16.
    //
#ifdef WIN16
    _ulSeed = (ulNewSeed == 0) ? (ULONG)time(NULL) : ulNewSeed;
#else
    _ulSeed = (ulNewSeed == 0) ? (ULONG)GetTickCount() : ulNewSeed;
#endif

    // Reverse the bits of the _ulSeed.
    //
    ULONG ulRevSeed = 0;
    _BitReverse(&_ulSeed, sizeof(ULONG), &ulRevSeed);
    // The base number is the xor of the _ulSeed and its bit reverse.
    //
    _ulNumber = _ulSeed ^ ulRevSeed;
    //
    // Allow for alternate random # generation
    //
    srand(_ulSeed);

    return DG_RC_SUCCESS;

}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::GetSeed, public
//
//   Synopsis:  Returns the internal seed value using the passed in pointer.
//
//  Arguments:  [*pulSeed] - pointer to where the user wants the internal
//                           seed value stored.
//
//    Returns:  DG_RC_SUCCESS -- if successful.
//
//   Modifies:  _usRet
//
//  Algorithm:  Sets *pulSeed to _ulSeed if pulSeed is not NULL.
//
//      Notes:  Implemented as an inline functions.  See DataGen.hxx.
//
//    History:  16-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BASE::GetSeed(ULONG *pulSeed)
{
    if (pulSeed != NULL)
    {
        *pulSeed = _ulSeed;
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::_Multiply, protected
//
//   Synopsis:  Multiplies 2 unsigned long integers, ensuring that the result
//              does not produce overflow.
//
//  Arguments:  [ul1, ul2] - the 2 multiplication operands.
//
//    Returns:  Returns the result of the multiplication.
//
//  Algorithm:  By breaking down the operands into pieces less than the
//              square root of ULONG_MAX, we can garuantee that we will
//              not overflow.  The various pieces are then multiplied,
//              moduloed again, multiplied by the modulo value, the 2
//              moduloed pieces are mulitplied and added to the first
//              part of the result, and the final result is given a
//              final modulo by the maximum value.
//
//      Notes:  See _Algorithms in C_ by Robert Sedgewick for a full
//              explanation of this algorithm.
//
//    History:  28-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

ULONG DG_BASE::_Multiply(ULONG ulP, ULONG ulQ)
{

    // Assign variables for the different components of the arguement
    // breakdown.
    //
    ULONG ulP1 = ulP / ULONG_MAX_SQRT;
    ULONG ulP0 = ulP % ULONG_MAX_SQRT;
    ULONG ulQ1 = ulQ / ULONG_MAX_SQRT;
    ULONG ulQ0 = ulQ % ULONG_MAX_SQRT;

    // Return the result of the calculation.
    //
    return ((((ulP0 * ulQ1) + (ulP1 * ulQ0)) % ULONG_MAX_SQRT) * ULONG_MAX_SQRT + (ulP0 * ulQ0) % ULONG_MAX);

}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::_Floater, protected
//
//   Synopsis:  Using the base number, returns a floating point number
//              between 0 and 1 [0, 1).
//
//  Arguments:  None.
//
//   Modifies:  _ulNumber
//
//  Algorithm:  Multiply the base number by a constant, add 1, and take the
//              modulo of the maximum unsigned long number.  Replace the
//              base number with this result, then divide the new base number
//              by the maximum unsigned long number to get a number in the
//              range [0, 1).
//
//      Notes:  This function is primarily meant to produce probabilities
//              for selection algorithms used elsewhere.
//
//              See _Algorithms in C_ by Robert Sedgewick for constant, ulB,
//              selection.
//
//    History:  03-Oct-91  RonJo     Created.
//
//----------------------------------------------------------------------------

FLOAT DG_BASE::_Floater()
{
    const ULONG ulB = 602300421;

    _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
    return((FLOAT)_ulNumber / (FLOAT)ULONG_MAX);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::_BitReverse, private
//
//   Synopsis:  Reverses the bit ordering of a byte stream.
//
//  Arguments:  [*pvStream] -- Pointer to the stream of bytes to be bit
//                             reversed.
//
//              [cBytes] -- The number of bytes in the byte stream.
//
//              [pvRevStream] -- Pointer to the caller provided buffer to
//                               return the reversed bit byte stream.
//
//    Returns:  None
//
//   Modifies:  _usRet
//
//  Algorithm:  Reverses the bits in individual bytes while reversing the
//              byte order.
//
//      Notes:
//
//    History:  19-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

VOID DG_BASE::_BitReverse(VOID *pvStream, USHORT cBytes, VOID *pvRevStream)
{
    // Assign a constant to point to the top bit.  This assumes an 8 bit
    // byte and is the only assumption in the routine.  If you are using
    // a platform that has a different size byte, then this constant must
    // be changed.
    //
    const BYTE bTop = 0x80;

    // Assign pointers for overall reference to each byte stream.
    //
    BYTE *pbSrc = (BYTE *)pvStream;
    BYTE *pbDst = (BYTE *)pvRevStream;

    // Assign pointers for reference to each byte in the byte streams.
    // The source pointer starts at the beginning of the source stream,
    // whereas the destination points starts at the end of the destina-
    // tion stream.
    //
    BYTE *pbS = pbSrc;
    BYTE *pbD = pbDst + cBytes - 1;

    // Assign counter variables and a masking variable.
    //
    register i;
    BYTE bMask;

    // Loop through all the bytes in the stream.
    //
    while (cBytes > 0)
    {
        // Loop through the upper nibble of the source byte, putting the
        // bits in the lower nibble of the destination byte.
        //
        i = CHAR_BIT - 1;
        bMask = bTop;
        while (i > 0)
        {
            *pbD |= (*pbS & bMask) >> i;
            i--; i--;  // This is faster than i -= 2
            bMask >>= 1;
        }

        // Loop through the lower nibble of the source byte, putting the
        // bits in the upper nibble of the destination byte.
        //
        i = 1;
        while (i < CHAR_BIT)
        {
            *pbD |= (*pbS & bMask) << i;
            i++; i++;  // This is faster than i += 2
            bMask >>= 1;
        }

        // Move the respective byte pointers "up" their relative streams,
        // and deal with the next pair of bytes.
        //
        pbS++;
        pbD--;
        cBytes--;
    }

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\datagen\dg_bstr.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_BSTR.cxx
//
//   Contents:  Definition for DataGen DG_BSTR class.
//
//    Classes:  DG_BSTR    - Class to generate 16-bit random strings.
//
//  Functions:  DG_BSTR::DG_BSTR()
//              DG_BSTR::Generate()      A few varieties
//
//    History:  21-Mar-94  RickTu     Created. (Taken from DG_UNICODE).
//              12-Apr-96  MikeW      BSTR's are based off of OLECHAR not
//                                    WCHAR (for the Macintosh)
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_BSTR::DG_BSTR, public
//
//   Synopsis:  Calls DG_UNICODE class constructor, and initializes _fNull.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//   Modifies:  _fNull
//
//  Algorithm:  Calls the DG_UNICODE constructor, and initializes _fNull.
//
//      Notes:  Implemented as an inline function.  See dg.hxx.
//
//    History:  21-Mar-94  RickTu     Created. (Taken from DG_UNICODE).
//
//----------------------------------------------------------------------------

DG_BSTR::DG_BSTR(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_BSTR::Generate(range), public
//
//   Synopsis:  Produces a random ole character, random length string.
//              The "randomness" of the characters may be constrained by
//              value parameters passed to the function, and the length
//              by length parameters passed to the function.
//
//  Arguments:  [*pbstrString] - pointer to where the pointer to the string
//                               will be stored upon success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                     allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                    maximum length.
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              use the integer generator to fill in the string.
//
//    History:  21-Mar-94  RickTu     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BSTR::Generate(BSTR   *pbstrString,
                         ULONG    *pulLength,
                         OLECHAR   chMinVal,
                         OLECHAR   chMaxVal,
                         ULONG     ulMinLen,
                         ULONG     ulMaxLen)
{

    OLECHAR * pch;
    USHORT  usRC;

    //
    // DG_ASCII wants unsigned chars not chars and OLECHAR is a char on Mac
    //

#if defined(_MAC)
    typedef UCHAR BSTR_CHAR;
#else // !_MAC
    typedef WCHAR BSTR_CHAR;
#endif // !_MAC

    //
    // The only argument check we need to do is on pbstrString, the
    // rest of the arguments will be validated in the call to
    // DG_INTEGER::Generate
    //

    if (pbstrString==NULL)
    {
        return( DG_RC_BAD_STRING_PTR );
    }

    //
    // We're going to first create an Ole string, and then
    // turn it into a BSTR.
    //

    usRC = DG_BSTR_BASE::Generate((BSTR_CHAR **) &pch,
                                 pulLength,
                                 (BSTR_CHAR) chMinVal,
                                 (BSTR_CHAR) chMaxVal,
                                 ulMinLen,
                                 ulMaxLen
                                );

    if (usRC == DG_RC_SUCCESS)
    {
        *pbstrString = SysAllocStringLen( pch, *pulLength );
        delete [] pch;
        if (*pbstrString)
        {
            return( DG_RC_SUCCESS );
        }
        else
        {
            return( DG_RC_OUT_OF_MEMORY );
        }
    }
    else
    {
        pbstrString = NULL;
        return( usRC );
    }

}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BSTR::Generate(NULL), public
//
//   Synopsis:  Generates a random Ole character BSTR.
//
//  Arguments:  [**pbstrString] - pointer to where the pointer to the BSTR
//                                will be stored upon success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  See the Generate(range) member function.
//
//  Algorithm:  Call the Generate(range) member
//              function to do the actual work.
//
//      Notes:
//
//    History:  21-Mar-94  RickTu     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BSTR::Generate(BSTR  *pbstrString,
                         OLECHAR   chMinVal,
                         OLECHAR   chMaxVal,
                         ULONG     ulMinLen,
                         ULONG     ulMaxLen)
{
    ULONG ulLength;
    return(Generate(pbstrString,
                    &ulLength,
                    chMinVal,
                    chMaxVal,
                    ulMinLen,
                    ulMaxLen));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\datagen\dg_ascii.cxx ===
//+---------------------------------------------------------------------------
// //   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_ASCII.cxx
//
//   Contents:  Definition for DataGen DG_ASCII class.
//
//    Classes:  DG_ASCII    - Class to generate 8-bit random strings.
//
//  Functions:  DG_ASCII::DG_ASCII()
//              DG_ASCII::Generate()      All varieties
//              DG_ASCII::_LenMem()
//
//    History:  03-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//              11-Mar-92  RonJo     Ported to Win32 and separated DG and
//                                   DataGen functionality.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::DG_ASCII, public
//
//   Synopsis:  Calls DG_INTEGER class constructor, and initializes _fNull.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//   Modifies:  _fNull
//
//  Algorithm:  Calls the DG_INTEGER constructor, and initializes _fNull.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  03-Oct-91  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_ASCII::DG_ASCII(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(range), public
//
//   Synopsis:  Produces a random 8-bit character, random length string.
//              The "randomness" of the characters may be constrained by
//              value parameters passed to the function, and the length
//              by length parameters passed to the function.
//
//  Arguments:  [**puchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [uchMinVal] - minimum value that a character may have.
//
//              [uchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                     allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                    maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              use the integer generator to fill in the string.
//
//      Notes:
//
//    History:  03-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(UCHAR **puchString,
                          ULONG   *pulLength,
                          UCHAR    uchMinVal,
                          UCHAR    uchMaxVal,
                          ULONG     ulMinLen,
                          ULONG     ulMaxLen)
{
    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(puchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with random characters.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        UCHAR uch;
        _usRet = DG_INTEGER::Generate(&uch, uchMinVal, uchMaxVal);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*puchString)[i] = uch;
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *puchString;
            *puchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(NULL), public
//
//   Synopsis:  Generates a NULL terminated string by setting the _fNull
//              variable to TRUE, which causes an extra space containing
//              the NULL character to be put at the end the string, casting
//              the appropriate arguments, and calling the Generate(range)
//              member function to perform the actual work.
//
//  Arguments:  [**pszString] - pointer to where the pointer to the string
//                              will be stored up success of the function.
//
//              [uchMinVal] - minimum value that a character may have.
//
//              [uchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  See the Generate(range) member function.
//
//   Modifies:  _fNull
//
//  Algorithm:  Set _fNull to TRUE and call the Generate(range) member
//              function to do the actual work.
//
//      Notes:
//
//    History:  03-Oct-91  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(CHAR **pszString,
                          UCHAR  uchMinVal,
                          UCHAR  uchMaxVal,
                          ULONG   ulMinLen,
                          ULONG   ulMaxLen)
{
    _fNull = TRUE;
    ULONG ulLength;
    return Generate((UCHAR **)pszString,
                              &ulLength,
                              uchMinVal,
                              uchMaxVal,
                               ulMinLen,
                               ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(selection), public
//
//
//   Synopsis:  Produces a random 8-bit character, random length string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**puchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [*puchSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulSelLength] - the length of the selection string.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  04-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(UCHAR **puchString,
                          ULONG   *pulLength,
                          UCHAR  *puchSelection,
                          ULONG     ulSelLength,
                          ULONG     ulMinLen,
                          ULONG     ulMaxLen)
{
    // Handle the special cases of:
    //   1) the puchSelection being NULL
    //   2) the puchSelection argument is empty (ulSelLength = 0)
    //
    if (puchSelection == NULL)
    {
        return Generate(puchString,
                        pulLength,
                        (UCHAR)0,
                        UCHAR_MAX,
                        ulMinLen,
                        ulMaxLen);
    }
    if (ulSelLength == 0)
    {
        *puchString = NULL;
        *pulLength = 0;
        return _usRet;
    }

    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(puchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with characters randomly chosen from
    // the selection string.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        ULONG ul;
        _usRet = DG_INTEGER::Generate(&ul, 0, ulSelLength - 1);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*puchString)[i] = puchSelection[ul];
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *puchString;
            *puchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(selection, NULL), public
//
//
//   Synopsis:  Produces a random 8-bit character, random length, NULL-
//              terminated string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**puszString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*puszSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  04-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//               8-Jun-92  DeanE     Cut & Paste from Generate(NULL)
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(UCHAR **puszString,
                          UCHAR  *puszSelection,
                          ULONG     ulMinLen,
                          ULONG     ulMaxLen)
{
    _fNull = TRUE;
    ULONG   ulLength;
    ULONG   ulSelLength;
    UCHAR *puszTemp = puszSelection;

    // Get length of puszSelection - we aren't linking with C run-time
    // so we have to determine the length ourselves
    //
    while (*puszTemp != NULL)
    {
       puszTemp++;
    }
    ulSelLength = puszTemp - puszSelection;

    return Generate((UCHAR **)puszString,
                              &ulLength,
                              puszSelection,
                               ulSelLength,
                               ulMinLen,
                               ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::_LenMem, private
//
//   Synopsis:  Determine the size needed to create the ASCII string, and
//              then allocate that much memory for it.
//
//  Arguments:  [**puchString] - pointer to the pointer which will point to
//                               the beginning memory for the string.
//
//              [*pulLength] - pointer to the memory in which to store the
//                             length of the string.
//
//              [ulMinLen] - the minimum length of the string.
//
//              [ulMaxLen] - the maximum length of the string.
//
//    Returns:  DG_RC_SUCCESS -- if successful.
//
//              DG_RC_BAD_STRING_PTR -- if the string location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTH_PTR -- if the length location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTHS -- if the minimum length is greater than
//                                   the maximum lengths.
//
//              DG_RC_OUT_OF_MEMORY -- if space for the string cannot be
//                                     allocated.
//
//  Algorithm:  Verify the arguments.  Then if this is the default case,
//              generate a length with an expected value of 5 (see section
//              4.3 of the DataGen Design Specification for details).  If
//              this is not the default case, then generate a length using
//              the values provided.
//
//      Notes:
//
//    History:  03-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

VOID DG_ASCII::_LenMem(UCHAR **puchString,
                       ULONG   *pulLength,
                       ULONG     ulMinLen,
                       ULONG     ulMaxLen)
{
    // This value will produce an expected string length of 5 in
    // the default case.  Hence the name 'E5'.
    //
    const FLOAT E5 = 0.20F;

    // Perform parameter checks.
    //
    if (puchString == NULL)
    {
        _usRet = DG_RC_BAD_STRING_PTR;
    return;
    }
    else if (pulLength == NULL)
    {
        _usRet = DG_RC_BAD_LENGTH_PTR;
    return;
    }
    else if (ulMinLen > ulMaxLen)
    {
        _usRet = DG_RC_BAD_LENGTHS;
    return;
    }

    // If the default case is being used, then generate a length with the
    // expected value of 5.  Otherwise generate a number from the range
    // values given.  See section 4 of the DataGen Design Specification
    // for details.
    //
    if ((ulMinLen == 1) && (ulMaxLen == DG_DEFAULT_MAXLEN))
    {
        *pulLength = ulMinLen;
        while ((*pulLength < ulMaxLen) && (_Floater() > E5))
        {
            (*pulLength)++;
        }
    }
    else
    {
        ULONG ul;
        (VOID)DG_INTEGER::Generate(&ul, ulMinLen, ulMaxLen);
        if (_usRet == DG_RC_SUCCESS)
        {
            *pulLength = ul;
        }
        else
        {
            // Something went wrong, so stick a NULL
            // into the pointer, and a 0 into the length.
            //
            *puchString = NULL;
            *pulLength = 0;
            return;
        }
    }

    // Allocate memory based on the length.  If _fNull is true, then add 1
    // extra character for a terminating NULL character.  _fNull will be
    // true whenever we are generating a NULL terminated string.
    //
    if (_fNull == TRUE)
    {
        *puchString = new UCHAR[*pulLength + 1];
        if (*puchString != NULL)
        {
            (*puchString)[*pulLength] = NULL;
            _fNull = FALSE;
        }
    }
    else
    {
        *puchString = new UCHAR[*pulLength];
    }

    // Check for errors.
    //
    if (*puchString == NULL)
    {
        _usRet = DG_RC_OUT_OF_MEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\datagen\dg_real.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_REAL.cxx
//
//   Contents:  Definition for DataGen DG_REAL class.
//
//    Classes:  DG_REAL    - Class to produce random floating point numbers
//                           for any floating point data type.
//
//  Functions:  DG_REAL::DG_REAL()
//              DG_REAL::Generate()        All varieties
//
//    History:  11-Mar-92  RonJo     Created.
//
//              21-Oct-92  RonJo     ifdef'ed the long double version because
//                                   Win32/NT does not support long doubles.
//                                   Made double version standalone to support
//                                   itself and the float version.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_REAL::DG_REAL, public
//
//   Synopsis:  Calls the DG_BASE constructor to perform needed setup.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//  Algorithm:  Calls the DG_BASE constructor.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  11-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_REAL::DG_REAL(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif



// Take out long double version for Win32/NT because it does not
// support long doubles.
#ifndef FLAT
//+---------------------------------------------------------------------------
//
//     Member:  DG_REAL::Generate(LDOUBLE), public
//
//   Synopsis:  Generate a random LDOUBLE number, bounded by ldblMinVal and
//              ldblMaxVal.
//
//  Arguments:  [*pldblNumber] - pointer to where the user wants the random
//                               number stored.
//
//              [ldblMinVal] - minimum value desired as a random number.
//
//              [ldblMaxVal] - maximum value desired as a random number.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number argument passed in is
//                                      invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//   Modifies:  _ulNumber (through _Floater())
//
//  Algorithm:  Determine the range in which to generate the random number,
//              then use _Floater() to "select" a number within that range
//              and add it to the minimum value.  If the range is 0.0, then
//              simply use the minimum value.
//
//      Notes:
//
//    History:  11-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_REAL::Generate(LDOUBLE *pldblNumber,
                         LDOUBLE ldblMinVal,
                         LDOUBLE ldblMaxVal)
{
    if (pldblNumber != NULL)
    {
        // Get the range.
        //
        LDOUBLE ldblRange = ldblMaxVal - ldblMinVal;

        if (ldblRange > 0.0)
        {
            const ULONG ulB = 602300421;

            _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
            *pldblNumber = ldblRange * _Floater() + ldblMinVal;
        }
        else if (ldblRange == 0.0)
        {
            *pldblNumber = ldblMinVal;
        }
        else
        {
            _usRet = DG_RC_BAD_VALUES;
        }
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}
#endif // FLAT


//+---------------------------------------------------------------------------
//
//     Member:  DG_REAL::Generate(@), public
//
//   Synopsis:  All other floating point data type generator functions
//              operate by calling the LDOUBLE generator function and
//              casting the arguments appropriately.
//
//  Arguments:  [*p@Number] - pointer to storage for the particular data
//                            type desired.
//
//              [@MinVal] - minimum value desired as a random number.
//
//              [@MaxVal] - maximum value desired as a random number.
//
//    Returns:  Returns what is produced by the LDOUBLE Generate member
//              function, cast appropriately.
//
//  Algorithm:  See the Generate(LDOUBLE) member function.
//
//      Notes:
//
//    History:  11-Mar-92  RonJo     Created.
//
//              21-Oct-92  RonJo     Made the DOUBLE version stand alone, and
//                                   the FLOAT version use it because Win32/NT
//                                   does not support long doubles.
//
//----------------------------------------------------------------------------

USHORT DG_REAL::Generate(DOUBLE *pdblNumber, DOUBLE dblMinVal, DOUBLE dblMaxVal)
{
    if (pdblNumber != NULL)
    {
        // Get the range.
        //
        DOUBLE dblRange = dblMaxVal - dblMinVal;

        if (dblRange > 0.0)
        {
            const ULONG ulB = 602300421;

            _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
            *pdblNumber = dblRange * _Floater() + dblMinVal;
        }
        else if (dblRange == 0.0)
        {
            *pdblNumber = dblMinVal;
        }
        else
        {
            _usRet = DG_RC_BAD_VALUES;
        }
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}

USHORT DG_REAL::Generate(FLOAT *pfltNumber, FLOAT fltMinVal, FLOAT fltMaxVal)
{
    // Perform argument error checking.
    //
    if (pfltNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    DOUBLE dblNumber;
    DOUBLE dblMinVal = (DOUBLE)fltMinVal;
    DOUBLE dblMaxVal = (DOUBLE)fltMaxVal;

    // Call the DOUBLE version to do the work.
    //
    (VOID)Generate(&dblNumber, dblMinVal, dblMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pfltNumber = (FLOAT)dblNumber;
    }
    return _usRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\h\dummy.cxx ===
#include "comtpch.hxx"
#pragma hdrstop

void pch_dummy_function()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\log\pch.cxx ===
//+------------------------------------------------------------------
//
// File:        pch.cxx
//
// Contents:    headers to precompile when building cmdline.lib
//
// Synoposis:
//
// Classes:
//
// Functions:
//
// History:     09/18/92 Lizch  Created
//
//-------------------------------------------------------------------
#include "pch.hxx"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\stgbvt\comtools\log\log.cxx ===
//+-------------------------------------------------------------------
//
//  File:       log.cxx
//
//  Contents:   The code for the logging servers client logging methods
//
//  Functions:  Log::Log()
//              Log::Log(int, char *[])
//              Log::Log(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR)
//              Log::Log(LPWSTR, LPWSTR, LPWSTR, LPWSTR, LPWSTR)
//              Log::~Log()
//              Log::Info(inc, char *[])
//              Log::WriteVar(PCHAR, USHORT, PCHAR, ...)
//              Log::WriteVar(LPWSTR, USHORT, LPWSTR, ...)
//              Log::WriteVar(PCHAR, USHORT, USHORT, PVOID, PCHAR, ...)
//              Log::WriteVar(LPWSTR, USHORT, USHORT, PVOID, LPWSTR, ...)
//              Log::WriteVarList(PCHAR, USHORT, PCHAR, va_list)
//              Log::WriteVarList(LPWSTR, USHORT, LPWSTR, va_list)
//              Log::WriteVarList(PCHAR, USHORT, USHORT, PVOID, PCHAR, va_list)
//              Log::WriteVarList(LPWSTR, USHORT, USHORT, PVOID,
//                                LPWSTR, va_list)
//              Log::WriteData(PCHAR, ...)
//              Log::WriteData(LPWSTR, ...)
//              Log::WriteData(USHORT, PVOID, PCHAR, ...)
//              Log::WriteData(USHORT, PVOID, LPWSTR, ...)
//              Log::WriteDataList(PCHAR, va_list)
//              Log::WriteDataList(LPWSTR, va_list)
//              Log::WriteDataList(USHORT, PVOID, PCHAR, va_list)
//              Log::WriteDataList(USHORT, PVOID, LPWSTR, va_list)
//
//  History:    24-Sep-90  DaveWi    Initial Coding
//              15-Aug-91  AliceSe   set local logging if error binding
//              25-Sep-91  BryanT    Converted to C 7.0
//              17-Oct-91  SarahJ    DCR 525 - changed status parm of
//                                    WriteVar methods to USHORT and validated
//                                    parm to be in expected range
//              31-Oct-91  SarahJ    Now takes /L or /mL for server parm
//              10-Feb-92  BryanT    Win32 work and cleanup
//               3-Jul-92  DeanE     Added WriteVarList, WriteDataList, and
//                                   changed existing WriteVar and WriteData
//                                   methods to call them
//               1-Aug-92  DwightKr  Renamed CPCHAR as CPPSZ.  CPCHAR
//                                   conflicted with the 297 version of
//                                   windows.h
//              31-Oct-92  SarahJ    Removed references to tester name
//
//--------------------------------------------------------------------

#include <pch.cxx>
// BUGBUG Precompiled header does not work on Alpha for some unknown reason and
// so we temporarily remove it.
// #pragma hdrstop


// Set up a table of the status text values

const char * aStatus[] = { LOG_PASS_TXT,
                           LOG_FAIL_TXT,
                           LOG_WARN_TXT,
                           LOG_ABORT_TXT,
                           LOG_INFO_TXT,
                           LOG_START_TXT,
                           LOG_DONE_TXT };

LPWSTR waStatus[] = { wLOG_PASS_TXT,
                      wLOG_FAIL_TXT,
                      wLOG_WARN_TXT,
                      wLOG_ABORT_TXT,
                      wLOG_INFO_TXT,
                      wLOG_START_TXT,
                      wLOG_DONE_TXT };


//+----------------------------------------------------------------------------
//
//    Function:  IncLogStats(), static
//
//    Synopsis:  Increments the appropriate member of the passed-in LogStats
//               struct based on value of the usStatus passed in.
//
//    Effects:   Maintains correct status of the LogStats struct so we can
//               keep a running count of the log records written.
//
//    Arguments: [out] LogStats& stStats - structure to modify
//               [in]  ULONG    usStat  - code tells which field to increment
//
//    Returns:   nothing
//
//    Modifies:  stStats
//
//    History:   11-Jun-92  DonCl    first version
//
//    Notes:     Used by different overloaded versions of WriteVar()
//
//-----------------------------------------------------------------------------

static VOID IncLogStats(LogStats& stStats, USHORT usStats)
{
    switch(usStats)
    {
      case LOG_PASS:
        stStats.ulPass++;
        break;

      case LOG_FAIL:
        stStats.ulFail++;
        break;

      case LOG_WARN:
        stStats.ulWarn++;
        break;

      case LOG_ABORT:
        stStats.ulAbort++;
        break;

      case LOG_INFO:
        stStats.ulInfo++;
        break;

      case LOG_START:
        stStats.ulStart++;
        break;

      case LOG_DONE:
        stStats.ulDone++;
        break;

        //
        // No default, if code is unrecognized, there is no appropriate error
        // action to take.
        //
    }
}

//+-------------------------------------------------------------------
//
//  Member:     Log::Log(DWORD)
//
//  Synopsis:   The log file is not opened if this constructor is used -
//              the user must subsequently call the Info() method.
//
//  Arguments:  [fUseUnicode] - whether we should use WCHARs
//
//  Modifies:   fInfoSet
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
Log :: Log(DWORD dwCharType) : fInfoSet(FALSE), ulLastError(NO_ERROR)
{
    if(LOG_ANSI == dwCharType)
    {
        fIsUnicode = FALSE;
    }
    else if(LOG_UNICODE == dwCharType)
    {
        fIsUnicode = TRUE;
    }
    else
    {
        ulLastError = (ULONG) E_INVALIDARG;
        return;
    }

    //
    // zero out the _LogStats member
    //
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(int, char *[], DWORD)
//
//  Synopsis:   Log constructor with command line data given
//
//  Arguments:  [argc]  - Argument count
//              [argv]  - Argument array
//              [fUseUnicode] - whether we should use WCHARs
//
//  Returns:    Results from Info()
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
//--------------------------------------------------------------------
Log :: Log(int argc, char *argv[], DWORD dwCharType) :
  fInfoSet(FALSE),
  ulLastError(NO_ERROR)
{
    if(LOG_ANSI == dwCharType)
    {
        fIsUnicode = FALSE;
    }
    else if(LOG_UNICODE == dwCharType)
    {
        fIsUnicode = TRUE;
    }
    else
    {
        ulLastError = (ULONG) E_INVALIDARG;
        return;
    }

    //
    // zero out the _LogStats member
    //
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));

    ulLastError = Info(argc, argv);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR)
//
//  Synopsis:   Log constructor with internal data given
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of this test
//              [pszName]    - Name of test runner
//              [pszSubPath] - Users log file qualifer
//              [pszObject]  - Name of invoking object
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
// BUGBUG wszName unused - left until all components can co-ordinate
//                         with this. SarahJ
//--------------------------------------------------------------------
Log :: Log(PCHAR pszSrvr,
           PCHAR pszTest,
           PCHAR pszName,
           PCHAR pszSubPath,
           PCHAR pszObject) : fIsUnicode(FALSE), ulLastError(NO_ERROR)
{
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));   // zero out

    InitLogging();

    // Print warning if server name given
    if(NULL != pszSrvr)
    {
        fprintf(stderr, "Remote server not supported with this version of "
                "log.lib. Continuing.\n");
    }

    ulLastError = SetInfo(NULL, pszTest,  pszSubPath, pszObject);
    if(ulLastError == NO_ERROR)
    {
        ulLastError = LogOpen() || WriteVar((PCHAR) NULL, LOG_START);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(LPWSTR, LPWSTR, LPWSTR, LPWSTR, LPWSTR)
//
//  Synopsis:   Log constructor with internal data given
//
//  Arguments:  [wszSrvr]    - Name of logging server
//              [wszTest]    - Name of this test
//              [wszName]    - Name of test runner
//              [wszSubPath] - Users log file qualifer
//              [wszObject]  - Name of invoking object
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
// BUGBUG wszName unused - left until all components can co-ordinate
//                         with this. SarahJ

//--------------------------------------------------------------------
Log :: Log(LPWSTR wszSrvr,
           LPWSTR wszTest,
           LPWSTR wszName,
           LPWSTR wszSubPath,
           LPWSTR wszObject) : fIsUnicode(TRUE), ulLastError(NO_ERROR)

{
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));   // zero out

    InitLogging();

    // Print warning if server name given
    if(NULL != wszSrvr)
    {
        fprintf(stderr, "Remote server not supported with this version of "
                "log.lib. Continuing.\n");
    }

    ulLastError = SetInfo(NULL, wszTest,  wszSubPath, wszObject);
    if (ulLastError == NO_ERROR)
    {
        ulLastError = LogOpen() || WriteVar((LPWSTR) NULL, LOG_START);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::~Log()
//
//  Synopsi