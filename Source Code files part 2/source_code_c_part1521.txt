     ASSERT (pDVROutputPin) ;

            pMediaSampleRec = m_MediaSampleRecPool.Get () ;
            if (pMediaSampleRec) {

                //  set
                pMediaSampleRec -> pIMS2            = pIMS2 ;           //  we'll ref this
                pMediaSampleRec -> pINSSBuffer      = pINSSBuffer ;     //  don't addref
                pMediaSampleRec -> pDVROutputPin    = pDVROutputPin ;   //  don't addref
                pMediaSampleRec -> pmtNew           = pmtNew ;          //  can be NULL

                //  push to queue
                dw = m_pMSRecList -> Push (pMediaSampleRec) ;
                hr = HRESULT_FROM_WIN32 (dw) ;

                if (SUCCEEDED (hr)) {
                    pIMS2 -> AddRef () ;    //  list's
                }
                else {
                    m_MediaSampleRecPool.Recycle (pMediaSampleRec) ;
                }
            }
            else {
                hr = E_OUTOFMEMORY ;
            }

            return hr ;
        }

        HRESULT
        Pop (
            OUT IMediaSample2 **    ppIMS2,
            OUT INSSBuffer **       ppINSSBuffer,       //  OPTIONAL
            OUT CDVROutputPin **    ppDVROutputPin,
            OUT AM_MEDIA_TYPE **    ppmtNew             //  OPTIONAL
            )
        {
            HRESULT                 hr ;
            DVR_MEDIASAMPLE_REC *   pMediaSampleRec ;
            DWORD                   dw ;

            ASSERT (ppIMS2) ;
            ASSERT (ppDVROutputPin) ;

            if (!Empty ()) {
                dw = m_pMSRecList -> Pop (& pMediaSampleRec) ;
                ASSERT (dw == NOERROR) ;        //  queue is not empty

                //  required streams
                (* ppIMS2)          = pMediaSampleRec -> pIMS2 ;            //  list's ref kept as outgoing
                (* ppDVROutputPin)  = pMediaSampleRec -> pDVROutputPin ;    //  no refcounts

                //  optional streams
                if (ppINSSBuffer) {
                    (* ppINSSBuffer) = pMediaSampleRec -> pINSSBuffer ;     //  no refcounts
                }

                if (ppmtNew) {
                    (* ppmtNew) = pMediaSampleRec -> pmtNew ;               //  can be NULL (usually is)
                }

                m_MediaSampleRecPool.Recycle (pMediaSampleRec) ;

                hr = S_OK ;
            }
            else {
                hr = E_UNEXPECTED ;
            }

            return hr ;
        }
} ;

//  ============================================================================
//  CMediaSampleFIFO
//  ============================================================================

class CMediaSampleFIFO :
    public CMediaSampleList
{
    enum {
        ALLOC_QUANTUM = 10
    } ;

    CTDynQueue <DVR_MEDIASAMPLE_REC *>  m_MSRecQueue ;

    public :

        CMediaSampleFIFO (
            ) : m_MSRecQueue        (ALLOC_QUANTUM),
                CMediaSampleList    (& m_MSRecQueue) {}
} ;

//  ============================================================================
//  CMediaSampleLIFO
//  ============================================================================

class CMediaSampleLIFO :
    public CMediaSampleList
{
    enum {
        ALLOC_QUANTUM = 10
    } ;

    CTDynStack <DVR_MEDIASAMPLE_REC *>  m_MSRecStack ;

    public :

        CMediaSampleLIFO (
            ) : m_MSRecStack        (ALLOC_QUANTUM),
                CMediaSampleList    (& m_MSRecStack) {}
} ;

//  ============================================================================
//  CINSSBufferLIFO
//  ============================================================================

class CINSSBufferLIFO
{
    enum {
        ALLOC_QUANTUM = 30
    } ;

    struct INSSBUFFER_REC {
        INSSBuffer *    pINSSBuffer ;
        QWORD           cnsRead ;
        DWORD           dwReadFlags ;
        WORD            wStreamNum ;
    } ;

    TStructPool <INSSBUFFER_REC, ALLOC_QUANTUM> m_INSSBufferRecPool ;
    CTDynStack  <INSSBUFFER_REC *>              m_INSSRecLIFO ;

    public :

        CINSSBufferLIFO (
            ) : m_INSSRecLIFO   (ALLOC_QUANTUM) {}

        ~CINSSBufferLIFO (
            )
        {
            ASSERT (Empty ()) ;
        }

        BOOL Empty ()   { return m_INSSRecLIFO.Empty () ; }

        HRESULT
        Push (
            IN  INSSBuffer *    pINSSBuffer,    //  ref'd during the call
            IN  QWORD           cnsRead,
            IN  DWORD           dwReadFlags,
            IN  WORD            wStreamNum
            )
        {
            HRESULT             hr ;
            INSSBUFFER_REC *    pINSSBufferRec ;
            DWORD               dw ;

            ASSERT (pINSSBuffer) ;

            pINSSBufferRec = m_INSSBufferRecPool.Get () ;
            if (pINSSBufferRec) {
                pINSSBufferRec -> pINSSBuffer   = pINSSBuffer ;
                pINSSBufferRec -> cnsRead       = cnsRead ;
                pINSSBufferRec -> dwReadFlags   = dwReadFlags ;
                pINSSBufferRec -> wStreamNum    = wStreamNum ;

                dw = m_INSSRecLIFO.Push (pINSSBufferRec) ;
                if (dw == NOERROR) {
                    //  stack's ref
                    pINSSBufferRec -> pINSSBuffer -> AddRef () ;
                }
                else {
                    m_INSSBufferRecPool.Recycle (pINSSBufferRec) ;
                }

                hr = HRESULT_FROM_WIN32 (dw) ;
            }
            else {
                hr = E_OUTOFMEMORY ;
            }

            return hr ;
        }

        HRESULT
        Pop (
            IN  INSSBuffer **   ppINSSBuffer,
            IN  QWORD *         pcnsRead,
            IN  DWORD *         pdwReadFlags,
            IN  WORD *          pwStreamNum
            )
        {
            HRESULT             hr ;
            INSSBUFFER_REC *    pINSSBufferRec ;
            DWORD               dw ;

            ASSERT (ppINSSBuffer) ;
            ASSERT (pcnsRead) ;
            ASSERT (pdwReadFlags) ;
            ASSERT (pwStreamNum) ;

            if (!Empty ()) {
                dw = m_INSSRecLIFO.Pop (& pINSSBufferRec) ;
                ASSERT (dw == NOERROR) ;        //  stack is not empty

                (* ppINSSBuffer)    = pINSSBufferRec -> pINSSBuffer ;   //  LIFO's ref is returnd ref
                (* pcnsRead)        = pINSSBufferRec -> cnsRead ;
                (* pdwReadFlags)    = pINSSBufferRec -> dwReadFlags ;
                (* pwStreamNum)     = pINSSBufferRec -> wStreamNum ;

                m_INSSBufferRecPool.Recycle (pINSSBufferRec) ;

                hr = S_OK ;
            }
            else {
                hr = E_UNEXPECTED ;
            }

            return hr ;
        }
} ;

//  ============================================================================
//  CDVRReadController
//  ============================================================================

class CDVRReadController
{
    friend class CDVRReverseSender ;

    DWORD   m_dwMaxSeekFailureProbes ;

    protected :

        CDVRReadManager *       m_pDVRReadManager ;
        CDVRSourcePinManager *  m_pDVRSourcePinManager ;
        CDVRPolicy *            m_pPolicy ;
        CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;

        virtual void    InternalFlush_ ()                       { return ; }
        virtual HRESULT ReadFailure_ (IN HRESULT hr)            { return hr ; }
        virtual void    OnEndOfStream_ ()                       { DeliverEndOfStream_ () ; }

        HRESULT DeliverEndOfStream_ ()                  { return m_pDVRSourcePinManager -> DeliverEndOfStream () ; }
        HRESULT DeliverBeginFlush_ ()                   { return m_pDVRSourcePinManager -> DeliverBeginFlush () ; }
        HRESULT DeliverEndFlush_ ()                     { return m_pDVRSourcePinManager -> DeliverEndFlush () ; }

        HRESULT
        SendSample_ (
            IN  IMediaSample2 * pIMediaSample2,
            IN  CDVROutputPin * pDVROutputPin,
            IN  AM_MEDIA_TYPE * pmtNew,
            IN  QWORD           cnsStreamTime
            ) ;

        virtual
        void
        SampleSent (
            IN  HRESULT         hr,
            IN  IMediaSample2 * pIMediaSample2
            ) {}

        int
        DiscoverPrimaryTrickModeStream_ (
            IN  double  dRate
            ) ;

        virtual
        BOOL
        SeekOnDeviceFailure_Adjust (
            IN OUT QWORD *  pcnsSeek
            ) { return FALSE ; }

        HRESULT
        Seek_ (
            IN OUT  QWORD * pcnsSeekTo
            ) ;

        HRESULT
        SetWithinContentBoundaries_ (
            IN OUT  QWORD * pcnsOffset
            ) ;

    public :

        CDVRReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  DWORD                   dwMaxSeekingProbeMillis
            ) ;

        virtual
        ~CDVRReadController (
            ) ;

        //  flushes & initializes internal state
        virtual HRESULT Reset (IN REFERENCE_TIME rtPTSBase = 0)         { InternalFlush_ () ; return Initialize (rtPTSBase) ; }
        virtual HRESULT Initialize (IN REFERENCE_TIME rtPTSBase = 0)    { return S_OK ; }
        virtual void NotifyNewRate (IN double dRate)                    {}

        //  steady state call
        virtual HRESULT Process () = 0 ;

        //  error-handler
        HRESULT ErrorHandler (IN HRESULT hr) ;

        virtual LONG GetCurPTSPaddingMillis () { return 0 ; }
} ;

//  ============================================================================
//  CDVR_Forward_ReadController
//  forward play; abstract class
//  ============================================================================

class CDVR_Forward_ReadController :
    public CDVRReadController
{
    enum {
        //  this the PTS threshold when we are within this much of playtime,
        //    we revert back to a 1x speed
        BACK_TO_1X_THRESHOLD_MILLIS = 500,
    } ;

    //  this value is set when we set a rate > 1x; we want to check where
    //    the EOF is as we get nearer the end, but not prematurely (too
    //    expensive), so we set this value, and update it with the EOF at
    //    time of call; if EOF is within a threshold
    //    (BACK_TO_1X_THRESHOLD_MILLIS) we revert the playback rate to 1x
    QWORD   m_cnsCheckTimeRemaining ;

    protected :

        void
        UpdateNextOnContentOverrunCheck_ (
            )
        {
            //  init to 0 so we check it right away
            m_cnsCheckTimeRemaining = 0 ;
        }

        void
        InitContentOverrunCheck_ (
            )
        {
            UpdateNextOnContentOverrunCheck_ () ;
        }

        HRESULT
        CheckForContentOverrun_ (
            IN      QWORD   cnsCurrentRead,
            IN OUT  QWORD * pcnsSeekAhead = NULL    OPTIONAL    //  IN  current; OUT new
            ) ;

        virtual
        BOOL
        SeekOnDeviceFailure_Adjust (
            IN OUT QWORD *  pcnsSeek
            ) ;

    public :

        CDVR_Forward_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) ;

        virtual void NotifyNewRate (IN double dRate)
        {
            if (dRate > _1X_PLAYBACK_RATE) {
                InitContentOverrunCheck_ () ;
            }
        }

} ;

//  ============================================================================
//  ============================================================================

class CDVR_F_KeyFrame_ReadController :
    public CDVR_Forward_ReadController
{
    enum KEY_FRAME_STATE {
        WAIT_KEY,
        IN_KEY
    } ;

    enum {
        //  want total of (up to) 5 seconds; see comment for m_dwMaxSeekAheadBoosts
        //    below
        MAX_SEEKAHEAD_BOOSTS = 5000 / REG_DEF_INDEX_GRANULARITY_MILLIS,
    } ;

    KEY_FRAME_STATE m_State ;                   //  state: waiting or processing
    int             m_iPrimaryStream ;          //  the only stream we'll send through
    QWORD           m_cnsIntraKeyFSeek ;        //  seek forward by this in between key frames
    REFERENCE_TIME  m_rtPTSBase ;               //  outgoing PTS baseline
    REFERENCE_TIME  m_rtPTSNormalizer ;         //  first PTS we see when we start
    DWORD           m_dwSamplesDropped ;        //  number of samples dropped; primary
                                                //    stream only; might key, depending on Nth
    DWORD           m_dwKeyFrames ;             //  number of key frames seen
    DWORD           m_dwNthKeyFrame ;           //  we send every Nth keyframe
    REFERENCE_TIME  m_rtLastPTS ;               //  last PTS processed
    QWORD           m_cnsLastSeek ;             //  check for duplicate seeks (i.e. we're rounded down to same offset)
    const DWORD     m_dwMaxSeekAheadBoosts ;    //  if we are repeatedly rounded down to the same offset
                                                //    on our intra-keyframe seeks (because of a timehole
                                                //    or some other condition) we try this many times to
                                                //    boost the seekahead delta to try to get across
                                                //    it (default above is 5 seconds' worth of content

    HRESULT
    FixupAndSend_ (
        IN  IMediaSample2 * pIMediaSample2,
        IN  CDVROutputPin * pDVROutputPin,
        IN  AM_MEDIA_TYPE * pmtNew,
        IN  QWORD           cnsStreamTime
        ) ;

    HRESULT
    Fixup_ (
        IN  IMediaSample2 * pIMediaSample2
        ) ;

    DWORD
    IntraKeyframeSeekMillis_ (
        IN  double  dRate
        ) ;

    DWORD
    NthKeyframe_ (
        IN  double  dRate
        ) ;

    public :

        CDVR_F_KeyFrame_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) ;

        ~CDVR_F_KeyFrame_ReadController (
            ) ;

        virtual HRESULT Initialize (IN REFERENCE_TIME rtPTSBase = 0) ;
        virtual void NotifyNewRate (IN double dRate) ;

        //  steady state call
        virtual HRESULT Process () ;

        HRESULT
        InitFKeyController (
            IN  REFERENCE_TIME  rtPTSBase,
            IN  int             iPrimaryStream
            ) ;
} ;

//  ============================================================================
//  CDVR_F_FullFrame_ReadController
//  forward play
//  ============================================================================

class CDVR_F_FullFrame_ReadController :
    public CDVR_Forward_ReadController
{
    //  we're a FSM; state details :
    //
    //      --------------------------------------------------------------------
    //      DISCOVER_PTS_NORMALIZER
    //      --------------------------------------------------------------------
    //          discover the normalizing PTS value; this is the smallest PTS;
    //          we will subsequently subtract that PTS from all outgoing PTSs
    //          so we start from a 0-based timeline
    //
    //      --------------------------------------------------------------------
    //      DISCOVER_QUEUE_SEND
    //      --------------------------------------------------------------------
    //          send each queued media sample; during the normalizing PTS
    //          discovery process, we read in media samples from our starting
    //          point, but don't send them since we don't know how to normalize
    //          their PTSs; if we get to this step we know the normalizing PTS
    //          value; we pull off each sample from the front of the queue,
    //          normalize its PTS (if it has one) and send it; we do this
    //          iteratively vs. as a batch so we can be stopped without
    //          insisting to send all queued media samples first
    //
    //      --------------------------------------------------------------------
    //      STEADY_STATE
    //      --------------------------------------------------------------------
    //          this is the steady-state routine; we read, wrap, and send samples
    //          downstream
    //

    //  states
    enum F_READ_STATE {
        //  seek to first read offset
        SEEK_TO_SEGMENT_START,

        //  looking for PTS normalizer val
        DISCOVER_PTS_NORMALIZER,

        //  sending out of queue built during pts normalizer val search
        DISCOVER_QUEUE_SEND,

        //  steady state; read, wrap, send
        STEADY_STATE
    } ;

    F_READ_STATE            m_F_ReadState ;
    REFERENCE_TIME          m_rtPTSNormalizer ;
    REFERENCE_TIME          m_rtPTSBase ;
    REFERENCE_TIME          m_rtAVNormalizer ;          //  normalizer val for AV streams
    REFERENCE_TIME          m_rtNonAVNormalizer ;       //  normalizer for non AV streams; we'll use this if there are no AV streams
    CSimpleBitfield *       m_pStreamsBitField ;
    QWORD                   m_cnsLastSeek ;
    QWORD                   m_cnsCMediaSampleFIFOameSkipAhead ;
    REFERENCE_TIME          m_rtLastPTS ;
    REFERENCE_TIME          m_rtNearLivePadding ;               //  might have to pad the PTSs if we're close to live
    LONG                    m_lNearLivePaddingMillis ;
    REFERENCE_TIME          m_rtMinNearLivePTSPadding ;
    QWORD                   m_cnsMinNearLive ;

    //  queue is used when we read media samples to discover normalizing val;
    //   we queue the samples vs. discarding them, then fixup the timestamps and
    //   send them off
    CMediaSampleFIFO        m_PTSNormDiscQueue ;

    HRESULT
    NormalizerDiscPrep_ (
        ) ;

    BOOL
    EndNormalizerDiscover_ (
        ) ;

    HRESULT
    NormalizerDiscTally_ (
        ) ;

    HRESULT
    NormalizerDisc_ (
        ) ;

    HRESULT
    InternalInitialize_ (
        IN  REFERENCE_TIME      rtPTSBase,
        IN  REFERENCE_TIME      rtNormalizer,
        IN  F_READ_STATE        F_ReadState,
        IN  REFERENCE_TIME      rtLastPTS
        ) ;

    protected :

        virtual HRESULT ReadFailure_ (IN HRESULT hr) ;

        BOOL MediaSampleQueueEmpty_ ()          { return m_PTSNormDiscQueue.Empty () ; }

        HRESULT
        FlushMediaSampleQueue_ (
            ) ;

        HRESULT
        SendNextQueued_ (
            ) ;

        HRESULT
        FixupAndSend_ (
            IN  IMediaSample2 * pIMediaSample2,
            IN  CDVROutputPin * pDVROutputPin,
            IN  DWORD           dwMuxedStreamStats,
            IN  AM_MEDIA_TYPE * pmtNew,
            IN  QWORD           cnsStreamTime
            ) ;

        HRESULT
        SeekReader_ (
            IN OUT  QWORD * pcnsTo
            ) ;

        HRESULT
        ReadWrapFixupAndSend_ (
            ) ;

        BOOL
        NearLive_ (
            IN  QWORD   cnsStream
            ) ;

        HRESULT
        Fixup_ (
            IN  CDVROutputPin *,
            IN  IMediaSample2 *,
            IN  QWORD,
            IN  DWORD
            ) ;

    public :

        CDVR_F_FullFrame_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) ;

        virtual HRESULT Process () ;
        virtual HRESULT Initialize (IN REFERENCE_TIME rtPTSBase = 0) ;
        virtual LONG GetCurPTSPaddingMillis () { return m_lNearLivePaddingMillis ; }

} ;

//  ============================================================================
//  CDVRReverseSender
//  ============================================================================

class CDVRReverseSender
{
    REFERENCE_TIME          m_rtMirrorTime ;
    REFERENCE_TIME          m_rtNormalizer ;

    protected :

        CDVRReadController *    m_pHostingReadController ;
        CDVRSourcePinManager *  m_pDVRSourcePinManager ;
        CDVRPolicy *            m_pPolicy ;
        CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;
        CDVRReadManager *       m_pDVRReadManager ;
        WORD                    m_wReadCompleteStream ;     //  first stream we read from

        virtual
        HRESULT
        Fixup_ (
            IN  IMediaSample2 * pIMediaSample2,
            IN  BOOL            fKeyFrame
            ) ;

        HRESULT
        SendSample_ (
            IN  IMediaSample2 * pIMediaSample2,
            IN  CDVROutputPin * pDVROutputPin,
            IN  AM_MEDIA_TYPE * pmtNew,
            IN  QWORD           cnsStreamTime
            ) ;

    public :

        CDVRReverseSender (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRReadController *    pHostingReadController,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : m_pDVRSourcePinManager      (pDVRSourcePinManager),
                m_pDVRReadManager           (pDVRReadManager),
                m_pPolicy                   (pPolicy),
                m_pDVRSendStatsWriter       (pDVRSendStatsWriter),
                m_pHostingReadController    (pHostingReadController)
        {
            ASSERT (m_pPolicy) ;
            ASSERT (m_pDVRSendStatsWriter) ;
            ASSERT (m_pDVRReadManager) ;

            m_pPolicy -> AddRef () ;
        }

        virtual
        ~CDVRReverseSender (
            )
        {
            m_pPolicy -> Release () ;
        }

        void
        Initialize (
            IN  REFERENCE_TIME  rtMirrorTime,
            IN  REFERENCE_TIME  rtNormalizer = UNDEFINED
            )
        {
            m_rtMirrorTime = rtMirrorTime ;
            m_rtNormalizer = rtNormalizer ;

            TRACE_2 (LOG_AREA_DSHOW, 1,
                TEXT ("CDVRReverseSender::Initialize (mirror = %I64d ms, normalizer = %I64d ms)"),
                DShowTimeToMilliseconds (rtMirrorTime),DShowTimeToMilliseconds (rtNormalizer)) ;
        }

        virtual
        HRESULT
        Send (
            IN  IMediaSample2 * pIMediaSample2,
            IN  CDVROutputPin * pDVROutputPin,
            IN  QWORD           cnsCurrentRead
            ) ;

        virtual void Flush () {}
} ;

//  ============================================================================
//  CDVRMpeg2ReverseSender
//  ============================================================================

class CDVRMpeg2ReverseSender :
    public CDVRReverseSender
{
    CMediaSampleLIFO    m_Mpeg2GOP ;

    HRESULT
    SendQueuedGOP_ (
        ) ;

    protected :

        virtual
        BOOL
        IFramesOnly_ (
            ) = 0 ;

        virtual
        HRESULT
        Fixup_ (
            IN  IMediaSample2 * pIMediaSample2,
            IN  BOOL            fKeyFrame
            ) ;

    public :

        CDVRMpeg2ReverseSender (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRReadController *    pHostingReadController,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVRReverseSender   (pDVRReadManager,
                                     pHostingReadController,
                                     pDVRSourcePinManager,
                                     pPolicy,
                                     pDVRSendStatsWriter
                                     ) {}

        virtual
        HRESULT
        Send (
            IN  IMediaSample2 * pIMediaSample2,
            IN  CDVROutputPin * pDVROutputPin,
            IN  QWORD           cnsCurrentRead
            ) ;

        virtual void Flush () ;
} ;

//  ============================================================================
//  CDVRMpeg2_IFrame_ReverseSender
//  ============================================================================

class CDVRMpeg2_IFrame_ReverseSender :
    public CDVRMpeg2ReverseSender
{
    protected :

        virtual BOOL IFramesOnly_ ()    { return TRUE ; }

    public :

        CDVRMpeg2_IFrame_ReverseSender (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRReadController *    pHostingReadController,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVRMpeg2ReverseSender (
                    pDVRReadManager,
                    pHostingReadController,
                    pDVRSourcePinManager,
                    pPolicy,
                    pDVRSendStatsWriter
                    ) {}
} ;

//  ============================================================================
//  CDVRMpeg2_GOP_ReverseSender
//  ============================================================================

class CDVRMpeg2_GOP_ReverseSender :
    public CDVRMpeg2ReverseSender
{
    protected :

        virtual BOOL IFramesOnly_ ()    { return FALSE ; }

    public :

        CDVRMpeg2_GOP_ReverseSender (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRReadController *    pHostingReadController,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVRMpeg2ReverseSender (
                    pDVRReadManager,
                    pHostingReadController,
                    pDVRSourcePinManager,
                    pPolicy,
                    pDVRSendStatsWriter
                    ) {}
} ;

//  ============================================================================
//  CDVR_Reverse_ReadController
//  reverse play
//  ============================================================================

class CDVR_Reverse_ReadController  :
    public CDVRReadController
{
    //
    //  reverse trick mode is controlled by reading forward into a LIFO, then
    //    popping samples from the LIFO and sending them out; we perform this
    //    operation in cycles, each of which is subsequently referred to as a
    //    "read stretch"; at full-stream play, each read stretch is of duration
    //    the index granularity of the ASF file; (post v1) in skip mode, the
    //    index granularity will be > 1 index granularity
    //
    //  during the second phase of the read stretch, when buffers are popped
    //    from our LIFO, they are send via "senders", derived from
    //    CDVRReverseSender; these objects understand the various formats such
    //    as mpeg-2, where the GOP must still be played in forward order (and
    //    if full-frame, then via super sample), etc...
    //
    //  reverse mode posts an EOS when it encounters the start of data
    //

    enum REV_CONTROLLER_STATE {
        STATE_SEEK,                 //  seek to our next read offset
        STATE_READ,                 //  read into our LIFO
        STATE_SEND                  //  send contents of LIFO
    } ;

    TCNonDenseVector <CDVRReverseSender *>  m_Senders ;
    CINSSBufferLIFO                         m_ReadINSSBuffers ;
    REV_CONTROLLER_STATE                    m_State ;
    DWORD                                   m_dwSeekbackMultiplier ;
    QWORD                                   m_cnsIndexGranularity ;
    int                                     m_iPrimaryStream ;

    //  the following 3 members are used to decide when to stop reading
    //    and to start sending; the first time, we use the stream time
    //    where the reader currently is; the next times, we use the more
    //    exact stream number & embedded continuity counter;
    QWORD                                   m_cnsReadStop ;         //  use this the first time
    QWORD                                   m_cnsReadStart ;        //  UNDEFINED after a init
    QWORD                                   m_cnsLastSeekTo ;       //  last seeked to offset
    WORD                                    m_wReadStopStream ;
    DWORD                                   m_dwReadStopCounter ;
    WORD                                    m_wLastReadStream ;

    HRESULT
    SeekReader_ (
        ) ;

    HRESULT
    SendISSBufferLIFO_ (
        ) ;

    HRESULT
    InitializeSenders_ (
        IN  REFERENCE_TIME  rtPTSBase
        ) ;

    protected :

        virtual HRESULT ReadFailure_ (IN HRESULT hr) ;
        virtual void    InternalFlush_ () ;

        virtual BOOL ShouldSend_ (IN int iPinIndex) { return (iPinIndex == m_iPrimaryStream ? TRUE : FALSE) ; }

        virtual
        CDVRReverseSender *
        GetDVRReverseSender_ (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        virtual
        BOOL
        SeekOnDeviceFailure_Adjust (
            IN OUT QWORD *  pcnsSeek
            ) ;

    public :

        CDVR_Reverse_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) ;

        virtual
        ~CDVR_Reverse_ReadController (
            ) ;

        virtual HRESULT Initialize (IN REFERENCE_TIME rtPTSBase = 0) ;
        virtual HRESULT Initialize (IN REFERENCE_TIME rtPTSBase, IN int iPrimaryStream) ;

        virtual void NotifyNewRate (IN double dRate) ;

        //  steady state call
        virtual HRESULT Process () ;
} ;

//  ============================================================================
//  CDVR_R_FullFrame_ReadController
//  ============================================================================

class CDVR_R_FullFrame_ReadController  :
    public CDVR_Reverse_ReadController
{
    protected :

        virtual
        CDVRReverseSender *
        GetDVRReverseSender_ (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

    public :

        CDVR_R_FullFrame_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVR_Reverse_ReadController (
                    pDVRReadManager,
                    pDVRSourcePinManager,
                    pPolicy,
                    pDVRSendStatsWriter
                    ) {}
} ;

//  ============================================================================
//  CDVR_R_KeyFrame_ReadController
//  ============================================================================

class CDVR_R_KeyFrame_ReadController  :
    public CDVR_Reverse_ReadController
{
    protected :

        virtual
        CDVRReverseSender *
        GetDVRReverseSender_ (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

    public :

        CDVR_R_KeyFrame_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVR_Reverse_ReadController (
                    pDVRReadManager,
                    pDVRSourcePinManager,
                    pPolicy,
                    pDVRSendStatsWriter
                    ) {}
} ;

//  ============================================================================
//  CDVRReadManager
//  ============================================================================

class CDVRReadManager
{
    //
    //  seeking policies
    //
    //      1. it is legal to set a stop position that is beyond the current
    //          boundaries of the file; the file may be growing, or the file
    //          size may not have been known at the time that the caller set
    //          the stop value; should the reader run out beyond the file
    //          length, we'll get get an EOS, and pass that through, before the
    //          reader pauses
    //
    //      2. playback duration can change over time, though it will reach a
    //          plateau when our temporary backing store becomes full and the
    //          ringbuffer wraps
    //
    //      3. start position can become stale over time i.e. the ringbuffer
    //          logic may well overwrite it; we won't update in that case
    //

    friend class CDVRDReaderThread ;

    enum CONTROLLER_CATEGORY {
        FORWARD_FULLFRAME,          //  1x or trick; full-frame decode & render
        FORWARD_KEYFRAME,           //  > 1x; key frames only
        BACKWARD_FULLFRAME,         //  < 0; full-frame decode & render
        BACKWARD_KEYFRAME,          //  < 0; key-frame only
    } ;

    enum {
        //  number of controllers (see CONTROLLER_CATEGORY)
        CONTROLLER_COUNT = 4,

        //  this is our default stop time - a time that we'll "never" reach
        FURTHER = MAXQWORD,

        //  if we seek to a stale location i.e. one that has been overwritten
        //   by the ringbuffer logic, we'll loop trying to seek to earliest
        //   time; this is the max number of times we'll retrieve the earliest
        //   non-stale time, and try to seek to it
        MAX_STALE_SEEK_ATTEMPTS = 10,
    } ;

    CDVRDReaderThread       m_ReaderThread ;
    QWORD                   m_cnsCurrentPlayStart ;
    QWORD                   m_cnsCurrentPlayStop ;
    CDVRReadController *    m_ppDVRReadController [CONTROLLER_COUNT] ;
    CONTROLLER_CATEGORY     m_CurController ;
    QWORD                   m_cnsLastReadPos ;
    CDVRDShowReader *       m_pDVRDShowReader ;
    CDVRSourcePinManager *  m_pDVRSourcePinManager ;
    CDVRPolicy *            m_pPolicy ;
    CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;
    IReferenceClock *       m_pIRefClock ;
    CDVRClock *             m_pDVRClock ;
    double                  m_dCurRate ;
    CDVRDShowSeekingCore *  m_pSeekingCore ;
    CRunTimeline            m_Runtime ;
    CRITICAL_SECTION        m_crtTime ;
    CDVRIMediaSamplePool    m_DVRIMediaSamplePool ;
    DWORD                   m_dwMaxBufferPool ;
    QWORD                   m_cnsTimeholeThreshole ;
    double                  m_dDesiredBufferPoolSec ;
    DWORD                   m_cBufferPool ;                 //  buffer pool depth; ratchets up

    void TimeLock_ ()       { EnterCriticalSection (& m_crtTime) ; }
    void TimeUnlock_ ()     { LeaveCriticalSection (& m_crtTime) ; }

    HRESULT CancelReads_ () ;
    HRESULT PauseReaderThread_ () ;
    HRESULT TerminateReaderThread_ () ;
    HRESULT RunReaderThread_ (IN BOOL fRunPaused = FALSE) ;

    BOOL
    SeekIsNoop_ (
        IN  REFERENCE_TIME *    prtSeekTo,
        IN  double              dPlaybackRate
        ) ;

    int
    DiscoverPrimaryTrickModeStream_ (
        IN  double  dRate
        ) ;

    HRESULT
    SetController_ (
        IN  double          dNewRate,
        IN  int             iPrimaryStream,
        IN  BOOL            fFullFramePlay,
        IN  BOOL            fSeekingRateChange,
        IN  CTimelines *    pTimelines,
        IN  BOOL            fReaderActive = TRUE
        ) ;

    HRESULT
    SetPinRates_ (
        IN  double          dRate,
        IN  REFERENCE_TIME  rtRateStart,
        IN  BOOL            fFullFramePlay,
        IN  int             iPrimaryStream
        ) ;

    HRESULT
    FinalizeRateConfig_ (
        IN  double          dActualRate,
        IN  double          dPinRate,
        IN  int             iPrimaryStream,
        IN  BOOL            fFullFramePlay,
        IN  BOOL            fSeekingRateChange,
        IN  REFERENCE_TIME  rtRateStart,
        IN  REFERENCE_TIME  rtRuntimeStart
        ) ;

    HRESULT
    GetRateConfigInfo_ (
        IN  double      dActualRate,
        OUT double *    pdPinRate,
        OUT int *       piPrimaryStream,
        OUT BOOL *      pfFullFramePlay,
        OUT BOOL *      pfSeekingRateChange
        ) ;

    HRESULT
    ReadAndWrapForward_ (
        IN  BOOL                fWaitMediaSample,       //  vs. fail i.e. non-blocking
        OUT INSSBuffer **       ppINSSBuffer,           //  !NOT! ref'd; only indirectly via ppIMS2; undefined if call fails
        OUT IMediaSample2 **    ppIMS2,
        OUT CDVROutputPin **    ppDVROutputPin,
        OUT DWORD *             pdwMuxedStreamStats,
        OUT AM_MEDIA_TYPE **    ppmtNew,                //  dynamic format change; don't free
        OUT QWORD *             pcnsCurrentRead
        ) ;

    //  this method compares the specified start & stop positions to the
    //   readable content; should the start position be bad i.e. either beyond
    //   the end, or before the first, the start is repositioned wrt to the
    //   readable content, as long as this does not violate the specified
    //   stop position.
    HRESULT
    CheckSetStartWithinContentBoundaries_ (
        IN OUT  QWORD * pqwStart,
        IN      QWORD   qwStop
        ) ;

    static
    HRESULT
    GetDVRReadController_ (
        IN  CONTROLLER_CATEGORY     ControllerCat,
        IN  CDVRReadManager *       pDVRReadManager,
        IN  CDVRSourcePinManager *  pDVRSourcePinManager,
        IN  CDVRPolicy *            pPolicy,
        IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
        OUT CDVRReadController **   ppCDVRReadController
        ) ;

    BOOL
    IsFullFrameRate_ (
        IN  CDVROutputPin * pPrimaryPin,
        IN  double          dRate
        ) ;

    BOOL
    ValidRateRequest_ (
        IN  double  dPlaybackRate
        ) ;

    protected :

        CDVRPolicy *
        DVRPolicies_ (
            )
        {
            return m_pPolicy ;
        }

        //  called by child classes to set
        void
        SetReader_ (
            IN CDVRDShowReader *
            ) ;

        virtual
        void
        RecycleReader_  (
            IN  CDVRDShowReader *   pDVRReader
            )
        {
            delete pDVRReader ;
        }

        virtual
        BOOL
        AdjustStaleReaderToEarliest_ (
            )
        {
            return TRUE ;
        }

        virtual
        BOOL
        OnActiveWaitFirstSeek_ (
            )
        {
            return FALSE ;
        }

        double GetMaxReverseRate_ () ;
        double GetMaxForwardRate_ () ;

    public :

        CDVRReadManager (
            IN  CDVRPolicy *,
            IN  CDVRDShowSeekingCore *,
            IN  CDVRSourcePinManager *,
            IN  CDVRSendStatsWriter *,
            IN  CDVRClock *,
            OUT HRESULT *
            ) ;

        virtual
        ~CDVRReadManager (
            ) ;

        //  go/stop
        HRESULT Active (IN IReferenceClock *) ;
        HRESULT Inactive () ;

        void OnStateRunning (IN REFERENCE_TIME rtStart) ;
        void OnStatePaused () ;
        void OnStateStopped () ;

        REFERENCE_TIME RefTime () ;

        //  runtime-thread entry
        HRESULT Process () ;

        //  called by reader thread if there's a problem
        HRESULT
        ErrorHandler (
            IN  HRESULT hr
            ) ;

        void
        OnFatalError (
            IN  HRESULT hr
            ) ;

        BOOL IsLiveSource ()                    { return (m_pDVRDShowReader ? m_pDVRDShowReader -> IsLiveSource () : FALSE) ; }

        BOOL SourceAnchoredToZeroTime ()        { return (m_pDVRDShowReader ? m_pDVRDShowReader -> SourceAnchoredToZeroTime () : TRUE) ; }

        HRESULT
        GetReaderContentBoundaries (
            OUT QWORD * pqwStart,
            OUT QWORD * pqwStop
            ) ;

        //  dshow-based seeking
        HRESULT
        SeekTo (
            IN OUT  REFERENCE_TIME *    prtStart,
            IN OUT  REFERENCE_TIME *    prtStop,            //  OPTIONAL
            IN      double              dPlaybackRate,
            OUT     BOOL *              pfSeekIsNoop
            ) ;

        QWORD   TimeholeThreshold ()    { return m_cnsTimeholeThreshole ; }

        LONG    GetAvailableWrappers () { return m_DVRIMediaSamplePool.GetAvailable () ; }
        DWORD   CurMaxWrapperCount ()   { return m_DVRIMediaSamplePool.GetCurMaxAllocate () ; }
        DWORD   CurWrapperCount ()      { return m_DVRIMediaSamplePool.GetAllocated () ; }
        DWORD   MaxWrapperCount ()      { return m_dwMaxBufferPool ; }
        DWORD   SetMaxWrapperCount  (IN DWORD cNewMax) ;
        void    AdjustBufferPool    (IN DWORD dwMuxBuffersPerSec) ;
        void    AllowMoreWrappers   (IN DWORD cNewAllocate) { SetMaxWrapperCount (CurMaxWrapperCount () + cNewAllocate) ; }
        HRESULT GetCurrentStart     (OUT REFERENCE_TIME * prtStart) ;       //  start might be stale, but that's that the segment start
        HRESULT GetCurrentStop      (OUT REFERENCE_TIME * prtStop) ;        //  stop
        double  GetPlaybackRate     ()  { return m_dCurRate ; }
        HRESULT SetPlaybackRate     (IN double dPlaybackRate) ;
        HRESULT GetContentExtent    (OUT REFERENCE_TIME * prtStart, OUT REFERENCE_TIME * prtStop) ;
        QWORD   GetContentDuration  () ;
        HRESULT SetStop             (IN REFERENCE_TIME rtStop) ;
        HRESULT GetCurRuntime       (OUT REFERENCE_TIME *) ;
        HRESULT GetCurStreamtime    (OUT REFERENCE_TIME *) ;
        HRESULT GetCurPlaytime      (OUT REFERENCE_TIME *) ;
        HRESULT QueueRateSegment    (IN double dRate, IN REFERENCE_TIME rtPTSEffective) ;
        void    SetCurTimelines     (IN OUT CTimelines * pTimelines) ;

        //  not thread safe; if not called on the reader thread, then the reader
        //    thread *must* be stopped
        HRESULT
        ConfigureForRate (
            IN  double          dPlaybackRate,
            IN  CTimelines *    pTimelines      = NULL,
            IN  BOOL            fReaderActive   = TRUE) ;

        HRESULT
        GetMSWrapper (
            IN  BOOL                    fBlocking,
            OUT CMediaSampleWrapper **  ppMSWrapper     //  ref'd if success
            ) ;

        HRESULT GetMSWrapperBlocking    (OUT CMediaSampleWrapper ** ppMSWrapper)    { return GetMSWrapper (TRUE, ppMSWrapper) ; }
        HRESULT GetMSWrapperTry         (OUT CMediaSampleWrapper ** ppMSWrapper)    { return GetMSWrapper (FALSE, ppMSWrapper) ; }

        HRESULT
        SetStreamSegmentStart (
            IN  REFERENCE_TIME  rtStart,
            IN  double          dCurRate
            )
        {
            return m_pSeekingCore -> SetStreamSegmentStart (rtStart, dCurRate) ;
        }

        QWORD   GetCurReadPos ()            { return m_cnsLastReadPos ; }
        QWORD   SetCurReadPos (IN QWORD qw) { m_cnsLastReadPos = qw ; }

        HRESULT GetNextValidRead (IN OUT QWORD * pcns) ;
        HRESULT GetPrevValidTime (IN OUT QWORD * pcns) ;

        int     StreamCount ()              { return m_pDVRSourcePinManager -> PinCount () ; }

        IReferenceClock *   RefClock ()     { return m_pIRefClock ; }

        HRESULT
        SeekReader (
            IN OUT  QWORD * pcnsSeekStreamTime,
            IN      QWORD   qwStop
            ) ;

        HRESULT SeekReader (IN OUT  QWORD * pcnsSeekStreamTime) { return SeekReader (pcnsSeekStreamTime, m_cnsCurrentPlayStop) ; }

        void
        GetCurSegmentBoundaries (
            OUT QWORD * pqwStart,
            OUT QWORD * pqwStop
            )
        {
            (* pqwStart)    = m_cnsCurrentPlayStart ;
            (* pqwStop)     = m_cnsCurrentPlayStop ;
        }

        void
        SetNewSegmentBoundaries (
            IN  QWORD qwStart,
            IN  QWORD qwStop
            )
        {
            m_cnsCurrentPlayStart   = qwStart ;
            m_cnsCurrentPlayStop    = qwStop ;
        }

        void
        SetNewSegmentStart (
            IN  QWORD qwStart
            )
        {
            SetNewSegmentBoundaries (qwStart, m_cnsCurrentPlayStop) ;
        }

        void    ReaderReset () ;

        HRESULT
        CheckSetStartWithinContentBoundaries (
            IN OUT  QWORD * pqwStart
            )
        {
            return CheckSetStartWithinContentBoundaries_ (pqwStart, m_cnsCurrentPlayStop) ;
        }

        //  in-band events
        HRESULT DeliverEndOfStream ()               { return m_pDVRSourcePinManager -> DeliverEndOfStream () ; }
        HRESULT DeliverBeginFlush ()                { return m_pDVRSourcePinManager -> DeliverBeginFlush () ; }
        HRESULT DeliverEndFlush ()                  { return m_pDVRSourcePinManager -> DeliverEndFlush () ; }
        BOOL    IsFlushing ()                       { return m_pDVRSourcePinManager -> IsFlushing () ; }
        void    NotifyNewSegment () ;

        HRESULT
        GetPlayrateRange (
            OUT double *    pdMaxReverseRate,
            OUT double *    pdMaxForwardRate
            ) ;

        //  ability for control thread to grab reader thread lock
        void    ReaderThreadLock ()     { m_ReaderThread.Lock () ; }
        void    ReaderThreadUnlock ()   { m_ReaderThread.Unlock () ; }

        //  profile
        HRESULT GetRefdReaderProfile (OUT CDVRReaderProfile ** ppDVRReaderProfile)
        {
            ASSERT (m_pDVRDShowReader) ;
            return m_pDVRDShowReader -> GetRefdReaderProfile (ppDVRReaderProfile) ;
        }

        HRESULT
        Read (
            OUT INSSBuffer **   ppINSSBuffer,
            OUT QWORD *         pcnsCurrentRead,
            OUT DWORD *         pdwFlags,
            OUT WORD *          pwStreamNum
            ) ;

        HRESULT
        Wrap (
            IN  CMediaSampleWrapper *   pMSWrapper,
            IN  INSSBuffer *            pINSSBuffer,
            IN  WORD                    wStreamNum,
            IN  DWORD                   dwFlags,                //  from the read
            IN  QWORD                   cnsCurrentRead,
            IN  QWORD                   cnsSampleDuration,
            OUT CDVROutputPin **        ppDVROutputPin,
            OUT IMediaSample2 **        ppIMS2,
            OUT DWORD *                 pdwMuxedStreamStats,
            OUT AM_MEDIA_TYPE **        ppmtNew                 //  dynamic format change
            ) ;

        HRESULT
        ReadAndWaitWrapForward (
            OUT IMediaSample2 **    ppIMS2,
            OUT INSSBuffer **       ppINSSBuffer,           //  undefined if call fails; *not* ref'd
            OUT CDVROutputPin **    ppDVROutputPin,
            OUT DWORD *             pdwMuxedStreamStats,
            OUT AM_MEDIA_TYPE **    ppmtNew,                //  dynamic format change; don't free
            OUT QWORD *             pcnsCurrentRead
            )
        {
            //  block if there are no media samples
            return ReadAndWrapForward_ (TRUE, ppINSSBuffer, ppIMS2, ppDVROutputPin, pdwMuxedStreamStats, ppmtNew, pcnsCurrentRead) ;
        }

        HRESULT
        ReadAndTryWrapForward (
            OUT IMediaSample2 **    ppIMS2,
            OUT INSSBuffer **       ppINSSBuffer,           //  undefined if call fails; *not* ref'd
            OUT CDVROutputPin **    ppDVROutputPin,
            OUT DWORD *             pdwMuxedStreamStats,
            OUT AM_MEDIA_TYPE **    ppmtNew,                //  dynamic format change; don't free
            OUT QWORD *             pcnsCurrentRead
            )
        {
            //  don't block if there are no media samples
            return ReadAndWrapForward_ (FALSE, ppINSSBuffer, ppIMS2, ppDVROutputPin, pdwMuxedStreamStats, ppmtNew, pcnsCurrentRead) ;
        }
} ;

//  ============================================================================
//  CDVRRecordingReader
//  ============================================================================

class CDVRRecordingReader :
    public CDVRReadManager
{
    public :

        CDVRRecordingReader (
            IN  WCHAR *,
            IN  CDVRPolicy *,
            IN  CDVRDShowSeekingCore *,
            IN  CDVRSourcePinManager *,
            IN  CDVRSendStatsWriter *,
            IN  CPVRIOCounters *,
            IN  CDVRClock *,
            OUT IDVRIORecordingAttributes **,
            OUT HRESULT *
            ) ;

        virtual
        ~CDVRRecordingReader (
            ) ;
} ;

//  ============================================================================
//  CDVRBroadcastStreamReader
//  ============================================================================

class CDVRBroadcastStreamReader :
    public CDVRReadManager
{
    protected :

        virtual
        BOOL
        OnActiveWaitFirstSeek_ (
            )
        {
            return DVRPolicies_ () -> Settings () -> OnActiveWaitFirstSeek () ;
        }

    public :

        CDVRBroadcastStreamReader (
            IN  IStreamBufferSink *,
            IN  CDVRPolicy *,
            IN  CDVRDShowSeekingCore *,
            IN  CDVRSourcePinManager *,
            IN  CDVRSendStatsWriter *,
            IN  CDVRClock *,
            OUT HRESULT *
            ) ;

        virtual
        ~CDVRBroadcastStreamReader (
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdsread_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrdsrec.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdsrec.h

    Abstract:

        This module contains the declarations for our recording objects

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        23-Apr-2001     created

--*/

#ifndef __tsdvr__shared__dvrdsrec_h
#define __tsdvr__shared__dvrdsrec_h

//  ============================================================================
//  ============================================================================

class CDVRRecordingAttributes :
    public CUnknown,
    public IStreamBufferRecordingAttribute,
    public IFileSourceFilter,
    public IStreamBufferInitialize
{
    IDVRIORecordingAttributes * m_pIDVRIOAttributes ;
    BOOL                        m_fReadonly ;
    CRITICAL_SECTION            m_crt ;
    WCHAR *                     m_pszFilename ;
    CW32SID *                   m_pW32SID ;

    void Lock_ ()           { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()         { ::LeaveCriticalSection (& m_crt) ; }

    HRESULT
    LoadASFFile_ (
        ) ;

    public :

        CDVRRecordingAttributes (
            IN  IUnknown *                  punkOwning,
            IN  IDVRIORecordingAttributes * pIDVRIOAttributes,
            IN  BOOL                        fReadonly
            ) ;

        virtual
        ~CDVRRecordingAttributes (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT VOID ** ppv
            ) ;

        //  ====================================================================
        //  IFileSourceFilter

        STDMETHODIMP
        Load (
            IN  LPCOLESTR               pszFilename,
            IN  const AM_MEDIA_TYPE *   pmt
            ) ;

        STDMETHODIMP
        GetCurFile (
            OUT LPOLESTR *      ppszFilename,
            OUT AM_MEDIA_TYPE * pmt
            ) ;

        //  ====================================================================
        //  IStreamBufferInitialize

        STDMETHODIMP
        SetHKEY (
            IN  HKEY    hkeyRoot
            ) ;

        STDMETHODIMP
        SetSIDs (
            IN  DWORD   cSIDs,
            IN  PSID *  ppSID
            ) ;

        //  IStreamBufferRecordingAttribute

        //  ====================================================================
        //  IStreamBufferRecordingAttribute
        //      these are largely pass-through calls to the DVRIO layer, but
        //      we hook them here; eventually we'll do a pin_id to stream number
        //      translation; also the DVRIO layer does not have an enum layer;
        //      it's also largely a pass-through to the WM interfaces, except
        //      for reference recordings, when it will actually store the
        //      attributes for later storage in ASF files proper

        STDMETHODIMP
        SetAttribute (
            IN  ULONG                       ulReserved,
            IN  LPCWSTR                     pszAttributeName,
            IN  STREAMBUFFER_ATTR_DATATYPE  DVRAttributeType,
            IN  BYTE *                      pbAttribute,
            IN  WORD                        cbAttributeLength
            ) ;

        STDMETHODIMP
        GetAttributeCount (
            IN  ULONG   ulReserved,
            OUT WORD *  pcAttributes
            ) ;

        STDMETHODIMP
        GetAttributeByName (
            IN      LPCWSTR                         pszAttributeName,
            IN      ULONG *                         pulReserved,
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pDVRAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) ;

        STDMETHODIMP
        GetAttributeByIndex (
            IN      WORD                            wIndex,
            IN      ULONG *                         pulReserved,
            OUT     WCHAR *                         pszAttributeName,
            IN OUT  WORD *                          pcchNameLength,
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pDVRAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) ;

        STDMETHODIMP
        EnumAttributes (
            OUT IEnumStreamBufferRecordingAttrib **   ppIEnumDVRAttrib
            ) ;

        //  ====================================================================
        //  class-factory method

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  punkControlling,
            IN  HRESULT *   phr
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRRecording :
    public CUnknown,
    public IStreamBufferRecordControl
{
    IDVRRecorder *              m_pIDVRIORecorder ;
    DWORD                       m_dwWriterID ;
    CDVRWriteManager *          m_pWriteManager ;
    IUnknown *                  m_punkFilter ;
    CDVRPolicy *                m_pDVRPolicy ;
    CCritSec *                  m_pRecvLock ;
    CDVRRecordingAttributes *   m_pDVRRecordingAttributes ;

    void LockRecv_ ()           { m_pRecvLock -> Lock () ; }
    void UnlockRecv_ ()         { m_pRecvLock -> Unlock () ; }

    protected :

        virtual
        BOOL
        ValidateRelativeTime_ (
            IN  REFERENCE_TIME  rtRelative
            ) ;

        virtual
        void
        SetValidStartStopTime_ (
            IN OUT  REFERENCE_TIME *    prtStartStop,
            IN      REFERENCE_TIME      rtLastWrite
            )
        {
            return ;
        }

        virtual
        BOOL
        ImplementRecordingAttributes_ (
            ) = 0 ;

    public :

        CDVRRecording (
            IN  CDVRPolicy *        pDVRPolicy,
            IN  IDVRRecorder *      pIDVRRecorder,
            IN  DWORD               dwWriterID,
            IN  CDVRWriteManager *  pWriteManager,
            IN  CCritSec *          pRecvLock,
            IN  IUnknown *          punkFilter          //  write manager lives as long as filter, so we need to be able to ref
            ) ;

        virtual
        ~CDVRRecording (
            ) ;

        //  ====================================================================
        //  IUnknown

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (REFIID, void **) ;

        //  ====================================================================
        //  IStreamBufferRecordControl

        STDMETHODIMP
        Start (
            IN OUT  REFERENCE_TIME *    prtStart
            ) ;

        STDMETHODIMP
        Stop (
            IN  REFERENCE_TIME  rtStop
            ) ;

        STDMETHODIMP
        GetRecordingStatus (
            OUT HRESULT* phResult   OPTIONAL,
            OUT BOOL*    pbStarted  OPTIONAL,
            OUT BOOL*    pbStopped  OPTIONAL
            ) ;
} ;

//  ============================================================================

class CDVRContentRecording :
    public CDVRRecording
{
    protected :

        virtual
        BOOL
        ValidateRelativeTime_ (
            IN  REFERENCE_TIME  rtRelative
            ) ;

        virtual
        void
        SetValidStartStopTime_ (
            IN OUT  REFERENCE_TIME *    prtStartStop,
            IN      REFERENCE_TIME      rtLastWrite
            ) ;

        virtual
        BOOL
        ImplementRecordingAttributes_ (
            )
        {
            return TRUE ;
        }

    public :

        CDVRContentRecording (
            IN  CDVRPolicy *        pDVRPolicy,
            IN  IDVRRecorder *      pIDVRRecorder,
            IN  DWORD               dwWriterID,
            IN  CDVRWriteManager *  pWriteManager,
            IN  CCritSec *          pRecvLock,
            IN  IUnknown *          punkFilter          //  write manager lives as long as filter, so we need to be able to ref
            ) : CDVRRecording   (pDVRPolicy,
                                 pIDVRRecorder,
                                 dwWriterID,
                                 pWriteManager,
                                 pRecvLock,
                                 punkFilter
                                 ) {}
} ;

//  ============================================================================

class CDVRReferenceRecording :
    public CDVRRecording
{
    protected :

        virtual
        BOOL
        ValidateRelativeTime_ (
            IN  REFERENCE_TIME  rtRelative
            ) ;

        virtual
        BOOL
        ImplementRecordingAttributes_ (
            )
        {
            return TRUE ;
        }

    public :

        CDVRReferenceRecording (
            IN  CDVRPolicy *        pDVRPolicy,
            IN  IDVRRecorder *      pIDVRRecorder,
            IN  DWORD               dwWriterID,
            IN  CDVRWriteManager *  pWriteManager,
            IN  CCritSec *          pRecvLock,
            IN  IUnknown *          punkFilter          //  write manager lives as long as filter, so we need to be able to ref
            ) : CDVRRecording   (pDVRPolicy,
                                 pIDVRRecorder,
                                 dwWriterID,
                                 pWriteManager,
                                 pRecvLock,
                                 punkFilter
                                 ) {}
} ;

//  ============================================================================

class CDVRRecordingAttribEnum :
    public CUnknown,
    public IEnumStreamBufferRecordingAttrib
{
    IDVRIORecordingAttributes * m_pIDVRIOAttributes ;
    WORD                        m_wNextIndex ;
    CRITICAL_SECTION            m_crt ;

    void Lock_ ()               { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()             { ::LeaveCriticalSection (& m_crt) ; }

    public :

        CDVRRecordingAttribEnum (
            IN  IDVRIORecordingAttributes * pIDVRIOAttributes
            ) ;

        CDVRRecordingAttribEnum (
            IN  CDVRRecordingAttribEnum *   pCDVRRecordingAttribEnum
            ) ;

        ~CDVRRecordingAttribEnum (
            ) ;

        //  ====================================================================
        //  IUnknown

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (REFIID, void **) ;

        //  ====================================================================
        //  IEnumStreamBufferRecordingAttrib

        STDMETHODIMP
        Next (
            IN      ULONG                       cRequest,
            IN OUT  STREAMBUFFER_ATTRIBUTE *    pDVRAttribute,
            OUT     ULONG *                     pcReceived
            ) ;

        STDMETHODIMP
        Skip (
            IN  ULONG   cRecords
            ) ;

        STDMETHODIMP
        Reset (
            ) ;

        STDMETHODIMP
        Clone (
            OUT IEnumStreamBufferRecordingAttrib **   ppIEnumDVRAttrib
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CSBECompositionRecording :
    public  CUnknown,
    public  IStreamBufferRecComp
{
    enum {
        //  smallest recording time; if cannot concatenate content specifically
        //   that is smaller than 2 seconds worth of material
        MIN_REC_WINDOW_SEC = 2,

        INSSBUFFERHOLDER_POOL_SIZE = 100
    } ;

    CSBERecordingWriter *       m_pRecordingWriter ;
    CDVRReaderProfile *         m_pRecProfile ;
    CRITICAL_SECTION            m_crt ;
    CPVRIOCounters *            m_pPVRIOCounters ;
    CDVRPolicy *                m_pPolicy ;
    DWORD                       m_cRecSamples ;
    CDVRRecordingAttributes *   m_pDVRRecordingAttributes ;

    //  WMSync reader allocates without bounds; if we read faster than we can
    //    write, net memory usage goes up, unbounded; so we have to have a fixed
    //    size pool that we wrap all the INSSBuffer3's
    CWMINSSBuffer3HolderPool    m_INSSBufferHolderPool ;

    void Lock_ ()           { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()         { LeaveCriticalSection (& m_crt) ; }

    HRESULT
    InitializeWriterLocked_ (
        IN  LPCWSTR pszTargetFilename
        ) ;

    HRESULT
    InitializeProfileLocked_ (
        IN  LPCWSTR pszSBRecording
        ) ;

    HRESULT
    WriteToRecordingLocked_ (
        IN INSSBuffer * pINSSBuffer,
        IN QWORD        cnsStreamTime,
        IN DWORD        dwFlags,
        IN WORD         wStreamNum
        ) ;

    BOOL
    IsValidProfileLocked_ (
        IN  IDVRReader *    pIDVRReader
        ) ;

    BOOL
    IsValidTimeBracketLocked_ (
        IN  IDVRReader *    pIDVRReader,
        IN  REFERENCE_TIME  rtStart,
        IN  REFERENCE_TIME  rtStop
        ) ;

    BOOL
    IsValidLocked_ (
        IN  IDVRReader *    pIDVRReader,
        IN  REFERENCE_TIME  rtStart,
        IN  REFERENCE_TIME  rtStop
        ) ;

    HRESULT
    AppendRecordingLocked_ (
        IN  IDVRReader *    pIDVRReader,
        IN  REFERENCE_TIME  rtStart,
        IN  REFERENCE_TIME  rtStop
        ) ;

    public :

        CSBECompositionRecording (
            IN  IUnknown *  punkControlling,
            IN  HRESULT *   phr
            ) ;

        ~CSBECompositionRecording (
            ) ;

        //  ====================================================================
        //  IUnknown

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (REFIID, void **) ;

        //  ====================================================================
        //  IStreamBufferRecComp

        //  sets the enforcement profile
        virtual
        STDMETHODIMP
        Initialize (
            IN  LPCWSTR pszFilename,
            IN  LPCWSTR pszSBRecording
            ) ;

        //  fails if recording is not closed
        virtual
        STDMETHODIMP
        Append (
            IN  LPCWSTR pszSBRecording
            ) ;

        //  fails if recording is not closed
        virtual
        STDMETHODIMP
        AppendEx (
            IN  LPCWSTR         pszSBRecording,
            IN  REFERENCE_TIME  rtStart,
            IN  REFERENCE_TIME  rtStop
            ) ;

        virtual
        STDMETHODIMP
        GetCurrentLength (
            OUT DWORD * pcSeconds
            ) ;

        virtual
        STDMETHODIMP
        Close (
            ) ;

        virtual
        STDMETHODIMP
        Cancel (
            ) ;

        //  ====================================================================
        //  class-factory method

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  punkControlling,
            IN  HRESULT *   phr
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdsrec_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrdsseek.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dvrdsseek.h

    Abstract:

        This module contains the IMediaSeeking class declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        10-Apr-2001     mgates      created

    Notes:

--*/

#ifndef __tsdvr__shared__dvrdsseek_h
#define __tsdvr__shared__dvrdsseek_h

//
//  TIMES
//  ============================================================================
//      runtime
//          monotonically increases;
//          = TotalGraphRuntime - TotalGraphPausedTime;
//          1x;
//
//      streamtime
//          runtime but with rates applied;
//          can run backwards;
//
//      playtime
//          streamtime computed with ABS(rate);
//          monotonically increases;
//          corresponds to the timestamps that are being sent downstream;
//

class CVarSpeedTimeline
{
    struct RATE_SEGMENT {
        LIST_ENTRY      ListEntry ;
        double          dRate ;             //  segement rate
        REFERENCE_TIME  rtBasetime ;        //  basis time for segment
        REFERENCE_TIME  rtRuntimeStart ;    //  runtime at which this segment starts

        REFERENCE_TIME  CurStreamtime (IN REFERENCE_TIME rtRuntimeNow)
        {
            REFERENCE_TIME  rtBasetimeRet ;

            ASSERT (rtRuntimeNow >= rtRuntimeStart) ;

            rtBasetimeRet = rtBasetime +
                            (REFERENCE_TIME) ((double) (rtRuntimeStart - rtRuntimeNow) * dRate) ;

            //  make sure we don't underflow
            rtBasetimeRet = (rtBasetimeRet >= 0 ? rtBasetimeRet : 0) ;

            return rtBasetimeRet ;
        }

        //  ====================================================================
        //  helpers

        static REFERENCE_TIME StreamtimeBase (IN RATE_SEGMENT * pPrevRateSegment, IN REFERENCE_TIME rtRuntimeStartNext)
        {
            REFERENCE_TIME  rtBasetimeRet ;

            rtBasetimeRet = pPrevRateSegment -> rtBasetime +
                            (REFERENCE_TIME) ((double) (rtRuntimeStartNext - pPrevRateSegment -> rtRuntimeStart) *
                                              pPrevRateSegment -> dRate) ;

            //  make sure we don't underflow
            rtBasetimeRet = (rtBasetimeRet >= 0 ? rtBasetimeRet : 0) ;

            return rtBasetimeRet ;
        }

        static RATE_SEGMENT * Recover (IN LIST_ENTRY * pListEntry)
        {
            RATE_SEGMENT * pRateSegment ;
            pRateSegment = CONTAINING_RECORD (pListEntry, RATE_SEGMENT, ListEntry) ;
            return pRateSegment ;
        }

        static void Disconnect (RATE_SEGMENT * pRateSegment)
        {
            RemoveEntryList (& pRateSegment -> ListEntry) ;
            InitializeListHead (& pRateSegment -> ListEntry) ;
        }

        void InsertBefore (RATE_SEGMENT * pRateSegment)
        {
            InsertHeadList (& ListEntry, & pRateSegment -> ListEntry) ;
        }

        void InsertAfter (RATE_SEGMENT * pRateSegment)
        {
        }
    } ;

    LIST_ENTRY      m_leRateSegmentList ;
    RATE_SEGMENT *  m_pCurRateSegment ;

    RATE_SEGMENT *
    GetNewSegment_ (
        )
    {
        return new RATE_SEGMENT ;
    }

    void
    RecycleSegment_ (
        IN  RATE_SEGMENT *  pRateSegment
        )
    {
        delete pRateSegment ;
    }

    void
    Reset_ (
        ) ;

    void
    UpdateQueue_ (
        IN  REFERENCE_TIME  rtRuntimeNow
        ) ;

    void
    InsertNewSegment_ (
        IN  RATE_SEGMENT *  pNewRateSegment
        ) ;

    void
    FixupSegmentQueue_ (
        IN  RATE_SEGMENT *  pNewRateSegment
        ) ;

    public :

        CVarSpeedTimeline (
            ) ;

        ~CVarSpeedTimeline (
            ) ;

        DWORD
        Start (
            IN  REFERENCE_TIME  rtBasetime,
            IN  REFERENCE_TIME  rtRuntimeStart,
            IN  double          dRate
            ) ;

        void
        Stop (
            ) ;

        void
        SetBase (
            IN  REFERENCE_TIME  rtBasetime,
            IN  REFERENCE_TIME  rtRuntimeNow,
            IN  double          dRate
            ) ;

        REFERENCE_TIME
        Time (
            IN  REFERENCE_TIME  rtRuntimeNow
            ) ;

        DWORD
        QueueRateSegment (
            IN  double          dRate,
            IN  REFERENCE_TIME  rtRuntimeStart
            ) ;

#if 0
        void
        DumpSegments (
            )
        {
            LIST_ENTRY *    pCurListEntry ;
            RATE_SEGMENT *  pCurRateSegment ;

            printf ("\n"
                    "%-15s"
                    "%-15s"
                    "%-4s"
                    "\n",
                    "StreamtimeBase",
                    "RuntimeStart",
                    "Rate"
                    ) ;

            //  fixup list wrt previous
            for (pCurListEntry = m_leRateSegmentList.Flink;
                 pCurListEntry != & m_leRateSegmentList;
                 pCurListEntry = pCurListEntry -> Flink) {

                pCurRateSegment = RATE_SEGMENT::Recover (pCurListEntry) ;

                printf ("%-15I64d"
                        "%-15I64d"
                        "%-2.1f"
                        "\n",
                        pCurRateSegment -> rtBasetime,
                        pCurRateSegment -> rtRuntimeStart,
                        pCurRateSegment -> dRate
                        ) ;
            }
        }
#endif
} ;

//  ============================================================================

class CRunTimeline
{
    //
    //  times:
    //      walltime        advances 100% at fixed rate
    //      runtime         Runtime (walltime) - PausedTime (walltime)
    //

    //
    //  object is not serialized
    //

    enum STATE {
        STOPPED,
        PAUSED,
        RUNNING
    } ;

    STATE           m_State ;               //  timeline state
    REFERENCE_TIME  m_rtFirstRun ;          //  walltime at first run
    REFERENCE_TIME  m_rtLastRunStartNormalized ;
    REFERENCE_TIME  m_rtRuntimeAtPause ;

    void Reset_ ()
    {
        m_State                     = STOPPED ;

        m_rtRuntimeAtPause          = 0 ;           //  of current run stretch; collapses pauses
        m_rtFirstRun                = UNDEFINED ;
        m_rtLastRunStartNormalized  = UNDEFINED ;
    }

    REFERENCE_TIME NormalizeWallTime_ (IN REFERENCE_TIME rtWallTime)
    {
        REFERENCE_TIME   rtRet ;

        if (m_rtFirstRun != UNDEFINED) {
            rtRet = rtWallTime - m_rtFirstRun ;
        }
        else {
            rtRet = 0 ;
        }

        return rtRet ;
    }

    public :

        CRunTimeline (
            )
        {
            Reset_ () ;
        }

        //  ====================================================================

        BOOL HasRun ()    { return (m_rtFirstRun != UNDEFINED ? TRUE : FALSE) ; }

        void Run (REFERENCE_TIME rtStart)
        {
            if (m_rtFirstRun == UNDEFINED) {
                //  first time we've been run
                m_rtFirstRun = rtStart ;
            }

            m_rtLastRunStartNormalized = NormalizeWallTime_ (rtStart) ;

            m_State = RUNNING ;
        }

        void Pause (REFERENCE_TIME rtWallTime)
        {
            //  if we've run once at least, and are not already paused
            if (HasRun ()) {
                //  make sure we're not already paused
                if (m_rtLastRunStartNormalized != UNDEFINED) {
                    ASSERT (m_rtLastRunStartNormalized != UNDEFINED) ;
                    m_rtRuntimeAtPause = NormalizeWallTime_ (rtWallTime) - m_rtLastRunStartNormalized ;
                    m_rtLastRunStartNormalized = UNDEFINED ;
                }
            }

            m_State = PAUSED ;
        }

        void Stop ()
        {
            Reset_ () ;
        }

        //  ====================================================================

        REFERENCE_TIME RunningTime (IN REFERENCE_TIME WallTime)
        {
            REFERENCE_TIME   rtRunningTime ;

            if (HasRun ()) {

                if (m_State == RUNNING) {
                    ASSERT (m_rtLastRunStartNormalized != UNDEFINED) ;
                    rtRunningTime = NormalizeWallTime_ (WallTime) - m_rtLastRunStartNormalized ;
                }
                else {
                    ASSERT (m_State == PAUSED) ;
                    ASSERT (m_rtLastRunStartNormalized == UNDEFINED) ;

                    rtRunningTime = m_rtRuntimeAtPause ;
                }
            }
            else {
                rtRunningTime = 0 ;
            }

            return Max <REFERENCE_TIME> (rtRunningTime, 0) ;
        }
} ;

//  ============================================================================

class CSeekingTimeline
{
    CVarSpeedTimeline       m_StreamTimeline ;
    CVarSpeedTimeline       m_PlayTimeline ;
    CRunTimeline            m_RunTimeline ;         //  wall time - paused time
    IReferenceClock *       m_pIRefClock ;
    CRITICAL_SECTION        m_crt ;
    CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    REFERENCE_TIME
    TimeNow_ (
        )
    {
        HRESULT         hr ;
        REFERENCE_TIME  rtNow ;

        if (m_pIRefClock) {
            hr = m_pIRefClock -> GetTime (& rtNow) ;
            if (FAILED (hr))
            {
                rtNow = 0 ;
            }
        }
        else {
            rtNow = 0 ;
        }

        return rtNow ;
    }

    public :

        CSeekingTimeline (
            ) ;

        ~CSeekingTimeline (
            ) ;

        void SetRefClock (IN IReferenceClock * pIRefClock)
        {
            Lock_ () ;

            RELEASE_AND_CLEAR (m_pIRefClock) ;
            if (pIRefClock) {
                m_pIRefClock = pIRefClock ;
                m_pIRefClock -> AddRef () ;
            }

            Unlock_ () ;
        }

        void SetStatsWriter (CDVRSendStatsWriter * pDVRSendStatsWriter) { m_pDVRSendStatsWriter = pDVRSendStatsWriter ; }

        void Pause () ;
        void Stop () ;
        void Run (IN REFERENCE_TIME rtStartTime, IN REFERENCE_TIME rtStreamStart, IN double dRate = _1X_PLAYBACK_RATE) ;

        void SetStreamStart (IN REFERENCE_TIME rtStreamStat, IN double dRate) ;

        HRESULT GetCurRuntime (OUT REFERENCE_TIME * prt) ;
        HRESULT GetCurStreamTime (OUT REFERENCE_TIME * prtStreamtime, OUT REFERENCE_TIME * prtCurRuntime = NULL) ;
        HRESULT GetCurPlaytime (OUT REFERENCE_TIME * prtPTStime, OUT REFERENCE_TIME * prtCurRuntime = NULL) ;

        HRESULT SetCurStreamPosition (IN REFERENCE_TIME rtStream) ;
        HRESULT QueueRateChange (IN double dRate, IN REFERENCE_TIME rtRuntime) ;

        HRESULT SetCurTimelines (IN OUT CTimelines * pTimelines) ;
} ;

//  ============================================================================

class CDVRDShowSeekingCore
{
    GUID                    m_guidTimeFormat ;
    CRITICAL_SECTION        m_crtSeekingLock ;
    CDVRReadManager *       m_pDVRReadManager ;
    CDVRSourcePinManager *  m_pDVRSourcePinManager ;
    CCritSec *              m_pFilterLock ;
    CBaseFilter *           m_pHostingFilter ;
    CSeekingTimeline        m_SeekingTimeline ;
    CDVRPolicy *            m_pDVRPolicy ;
    CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;

    //  returns the offset last read
    LONGLONG
    GetLastRead_ (
        ) ;

    HRESULT
    TimeToCurrentFormat_ (
        IN  REFERENCE_TIME  rt,
        OUT LONGLONG *      pll
        ) ;

    HRESULT
    CurrentFormatToTime_ (
        IN  LONGLONG            ll,
        OUT REFERENCE_TIME *    prt
        ) ;

    HRESULT
    GetCurSegStart_ (
        OUT REFERENCE_TIME *    prt
        ) ;

    void FilterLock_ ()             { m_pFilterLock -> Lock () ; }
    void FilterUnlock_ ()           { m_pFilterLock -> Unlock () ; }

    public :

        CDVRDShowSeekingCore (
            IN  CCritSec *      pFilterLock,
            IN  CBaseFilter *   pHostingFilter
            ) ;

        ~CDVRDShowSeekingCore (
            ) ;

        //  class methods

        void
        OnFilterStateChange (
            IN  FILTER_STATE    TargetState,
            IN  REFERENCE_TIME  rtRunStart = 0
            ) ;

        void SetRefClock            (IN IReferenceClock * pRefClock)                    { m_SeekingTimeline.SetRefClock (pRefClock) ; }
        void SetDVRSourcePinManager (IN CDVRSourcePinManager *  pDVRSourcePinManager)   { m_pDVRSourcePinManager = pDVRSourcePinManager ; }
        void SetDVRReadManager      (IN CDVRReadManager *       pDVRReadManager)        { m_pDVRReadManager = pDVRReadManager ; }
        void SetDVRPolicy           (IN CDVRPolicy *            pDVRPolicy) ;

        void
        SetStatsWriter (
            IN  CDVRSendStatsWriter * pDVRSendStatsWriter)
        {
            m_pDVRSendStatsWriter = pDVRSendStatsWriter ;
            m_SeekingTimeline.SetStatsWriter (m_pDVRSendStatsWriter) ;
        }

        void Lock ()        { EnterCriticalSection (& m_crtSeekingLock) ; }
        void Unlock ()      { LeaveCriticalSection (& m_crtSeekingLock) ; }

        void
        SetCurTimelines (
            IN OUT  CTimelines *    pTimelines
            ) ;

        HRESULT
        QueueRateSegment (
            IN  double          dRate,
            IN  REFERENCE_TIME  rtRuntime
            )
        {
            HRESULT hr ;

            hr = m_SeekingTimeline.QueueRateChange (dRate, rtRuntime) ;

            return hr ;
        }

        BOOL
        IsSeekingPin (
            IN  CDVROutputPin *
            ) ;

        BOOL
        IsSeekable (
            )
        {
            return (m_pDVRReadManager ? TRUE : FALSE) ;
        }

        HRESULT
        GetSeekingCapabilities (
            OUT DWORD * pCapabilities
            )
        {
            ASSERT (pCapabilities) ;

            (* pCapabilities) = AM_SEEKING_CanSeekForwards
                              | AM_SEEKING_CanSeekBackwards
                              | AM_SEEKING_CanSeekAbsolute
                              | AM_SEEKING_CanGetStopPos
                              | AM_SEEKING_CanGetDuration
                              | AM_SEEKING_CanGetCurrentPos ;

            return S_OK ;
        }

        BOOL
        IsSeekingFormatSupported (
            IN  const GUID *    pFormat
            ) ;

        HRESULT
        QueryPreferredSeekingFormat (
            OUT GUID *
            ) ;

        HRESULT
        SetSeekingTimeFormat (
            IN  const GUID *
            ) ;

        HRESULT
        GetSeekingTimeFormat (
            OUT GUID *
            ) ;

        HRESULT
        GetFileDuration (
            OUT LONGLONG *
            ) ;

        HRESULT
        GetFileStopPosition (
            OUT LONGLONG *
            ) ;

        HRESULT
        GetAvailableContent (
            OUT LONGLONG *  pllStartContent,
            OUT LONGLONG *  pllStopContent
            ) ;

        HRESULT
        GetFileStartPosition (
            OUT LONGLONG *
            ) ;

        HRESULT
        SeekTo (
            IN  LONGLONG *  pllStart
            ) ;

        HRESULT
        SeekTo (
            IN  LONGLONG *  pllStart,
            IN  LONGLONG *  pllStop,            //  NULL means don't set
            IN  double      dPlaybackRate
            ) ;

        HRESULT
        SetStreamSegmentStart (
            IN  REFERENCE_TIME  rtStart,
            IN  double          dCurRate
            ) ;

        HRESULT
        SetFileStopPosition (
            IN  LONGLONG *
            ) ;

        HRESULT
        GetPlayrateRange (
            OUT double *,
            OUT double *
            ) ;

        HRESULT
        SetPlaybackRate (
            IN  double
            ) ;

        HRESULT
        GetPlaybackRate (
            OUT double *
            ) ;

        //  current play position; w/appropriate rate scaling
        HRESULT
        GetStreamTime (
            OUT LONGLONG *
            ) ;

        //  same as above, but in dshow time
        HRESULT
        GetStreamTimeDShow (
            OUT REFERENCE_TIME *
            ) ;

        //  amount of time we've been running @ 1x (w/collapsed pause times)
        HRESULT
        GetRunTime (
            OUT LONGLONG *
            ) ;

        //  same as above, but in dshow time
        HRESULT
        GetRuntimeDShow (
            OUT REFERENCE_TIME *
            ) ;

        HRESULT
        GetCurPlaytime (
            OUT REFERENCE_TIME *    prtPTStime,
            OUT REFERENCE_TIME *    prtCurRuntime = NULL
            ) ;

        HRESULT
        ReaderThreadSetPlaybackRate (
            IN  double
            ) ;

        HRESULT
        ReaderThreadGetSegmentValues (
            OUT REFERENCE_TIME *    prtSegmentStart,
            OUT REFERENCE_TIME *    prtSegmentStop,
            OUT double *            pdSegmentRate
            ) ;
} ;

//  ============================================================================

class CDVRIMediaSeeking :
    public IStreamBufferMediaSeeking,
    public IDVRPlayrate
{
    IUnknown *              m_punkOwning ;          //  weak ref !
    GUID                    m_guidSeekingFormat ;
    CDVRDShowSeekingCore *  m_pSeekingCore ;

    protected :

        void SeekingLock_ ()            { m_pSeekingCore -> Lock () ; }
        void SeekingUnlock_ ()          { m_pSeekingCore -> Unlock () ; }

        CDVRDShowSeekingCore *  SeekingCore_ () { return m_pSeekingCore ; }

    public :

        CDVRIMediaSeeking (
            IN  IUnknown *              punkOwning,
            IN  CDVRDShowSeekingCore *  pSeekingCore
            ) ;

        virtual
        ~CDVRIMediaSeeking (
            ) ;

        //  --------------------------------------------------------------------
        //  IUnknown methods - delegate always

        STDMETHODIMP QueryInterface (REFIID riid, void ** ppv) ;
        STDMETHODIMP_ (ULONG) AddRef () ;
        STDMETHODIMP_ (ULONG) Release () ;

        //  --------------------------------------------------------------------
        //  IDVRPlayrate

        STDMETHODIMP
        GetPlayrateRange (
            OUT double *    pdMaxReverseRate,
            OUT double *    pdMaxForwardRate
            ) ;

        STDMETHODIMP
        SetPlayrate (
            IN  double  dRate
            ) ;

        STDMETHODIMP
        GetPlayrate (
            OUT double *   pdRate
            ) ;

        //  --------------------------------------------------------------------
        //  IMediaSeeking interface methods

        //  Returns the capability flags; S_OK if successful
        STDMETHODIMP
        GetCapabilities (
            OUT DWORD * pCapabilities
            ) ;

        //  And's the capabilities flag with the capabilities requested.
        //  Returns S_OK if all are present, S_FALSE if some are present,
        //  E_FAIL if none.
        //  * pCababilities is always updated with the result of the
        //  'and'ing and can be checked in the case of an S_FALSE return
        //  code.
        STDMETHODIMP
        CheckCapabilities (
            IN OUT  DWORD * pCapabilities
            ) ;

        //  returns S_OK if mode is supported, S_FALSE otherwise
        STDMETHODIMP
        IsFormatSupported (
            IN  const GUID *    pFormat
            ) ;

        //  S_OK if successful
        //  E_NOTIMPL, E_POINTER if unsuccessful
        STDMETHODIMP
        QueryPreferredFormat (
            OUT GUID *  pFormat
            ) ;

        //  S_OK if successful
        STDMETHODIMP
        GetTimeFormat (
            OUT GUID *  pFormat
            ) ;

        //  Returns S_OK if *pFormat is the current time format, otherwise
        //  S_FALSE
        //  This may be used instead of the above and will save the copying
        //  of the GUID
        STDMETHODIMP
        IsUsingTimeFormat (
            IN const GUID * pFormat
            ) ;

        // (may return VFE_E_WRONG_STATE if graph is stopped)
        STDMETHODIMP
        SetTimeFormat (
            IN const GUID * pFormat
            ) ;

        // return current properties
        STDMETHODIMP
        GetDuration (
            OUT LONGLONG *  pDuration
            ) ;

        STDMETHODIMP
        GetStopPosition (
            OUT LONGLONG *  pStop
            ) ;

        STDMETHODIMP
        GetCurrentPosition (
            OUT LONGLONG *  pStart
            ) ;

        //  Convert time from one format to another.
        //  We must be able to convert between all of the formats that we
        //  say we support.  (However, we can use intermediate formats
        //  (e.g. MEDIA_TIME).)
        //  If a pointer to a format is null, it implies the currently selected format.
        STDMETHODIMP
        ConvertTimeFormat(
            OUT LONGLONG *      pTarget,
            IN  const GUID *    pTargetFormat,
            IN  LONGLONG        Source,
            IN  const GUID *    pSourceFormat
            ) ;

        // Set Start and end positions in one operation
        // Either pointer may be null, implying no change
        STDMETHODIMP
        SetPositions (
            IN OUT  LONGLONG *  pStart,
            IN      DWORD       dwStartFlags,
            IN OUT  LONGLONG *  pStop,
            IN      DWORD       dwStopFlags
            ) ;

        // Get StartPosition & StopTime
        // Either pointer may be null, implying not interested
        STDMETHODIMP
        GetPositions (
            OUT LONGLONG *  pStart,
            OUT LONGLONG *  pStop
            ) ;

        //  Get earliest / latest times to which we can currently seek
        //  "efficiently".  This method is intended to help with graphs
        //  where the source filter has a very high latency.  Seeking
        //  within the returned limits should just result in a re-pushing
        //  of already cached data.  Seeking beyond these limits may result
        //  in extended delays while the data is fetched (e.g. across a
        //  slow network).
        //  (NULL pointer is OK, means caller isn't interested.)
        STDMETHODIMP
        GetAvailable (
            OUT LONGLONG *  pEarliest,
            OUT LONGLONG *  pLatest
            ) ;

        // Rate stuff
        STDMETHODIMP
        SetRate (
            IN  double  dRate
            ) ;

        STDMETHODIMP
        GetRate (
            OUT double *    pdRate
            ) ;

        // Preroll
        STDMETHODIMP
        GetPreroll (
            OUT LONGLONG *  pllPreroll
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRFilterIMediaSeeking :
    public CDVRIMediaSeeking
{
    public :

        CDVRFilterIMediaSeeking (
            IN  IUnknown *              punkOwning,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  CBaseFilter *           pBaseFilter
            ) : CDVRIMediaSeeking (
                    punkOwning,
                    pSeekingCore
                    ) {}

} ;

//  ============================================================================
//  ============================================================================

class CDVRPinIMediaSeeking :
    public CDVRIMediaSeeking
{
    CDVROutputPin * m_pOutputPin ;

    public :

        CDVRPinIMediaSeeking (
            IN  CDVROutputPin *         pOutputPin,
            IN  CDVRDShowSeekingCore *  pSeekingCore
            ) ;

        ~CDVRPinIMediaSeeking (
            ) ;

        //  --------------------------------------------------------------------
        //  IMediaSeeking interface methods -- those that must be called on
        //   the seeking pin

        //  returns S_OK if mode is supported, S_FALSE otherwise
        STDMETHODIMP
        IsFormatSupported (
            IN  const GUID *    pFormat
            ) ;

        //  S_OK if successful
        //  E_NOTIMPL, E_POINTER if unsuccessful
        STDMETHODIMP
        QueryPreferredFormat (
            OUT GUID *  pFormat
            ) ;

        //  S_OK if successful
        STDMETHODIMP
        GetTimeFormat (
            OUT GUID *  pFormat
            ) ;

        //  Returns S_OK if *pFormat is the current time format, otherwise
        //  S_FALSE
        //  This may be used instead of the above and will save the copying
        //  of the GUID
        STDMETHODIMP
        IsUsingTimeFormat (
            IN const GUID * pFormat
            ) ;

        // (may return VFE_E_WRONG_STATE if graph is stopped)
        STDMETHODIMP
        SetTimeFormat (
            IN const GUID * pFormat
            ) ;

        STDMETHODIMP
        GetCurrentPosition (
            OUT LONGLONG *  pStart
            ) ;

        // Set Start and end positions in one operation
        // Either pointer may be null, implying no change
        STDMETHODIMP
        SetPositions (
            IN OUT  LONGLONG *  pStart,
            IN      DWORD       dwStartFlags,
            IN OUT  LONGLONG *  pStop,
            IN      DWORD       dwStopFlags
            ) ;

        // Rate stuff
        STDMETHODIMP
        SetRate (
            IN  double  dRate
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdsseek_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrdswrite.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdswrite.cpp

    Abstract:

        This module contains the code for our writing layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"
#include "dvrdsseek.h"          //  pins reference seeking interfaces
#include "dvrpins.h"
#include "dvrdswrite.h"
#include "dvrdsrec.h"

//  ============================================================================
//  CSBERecordingWriter
//  ============================================================================

CSBERecordingWriter::CSBERecordingWriter (
    IN  CPVRIOCounters *    pPVRIOCounters,
    IN  LPCWSTR             pszRecordingFile,
    IN  IWMProfile *        pIWMProfile,
    IN  CDVRPolicy *        pPolicy,
    OUT HRESULT *           phr
    ) : m_pIDVRRecorderWriter   (NULL),
        m_WriterState           (REC_WRITER_STATE_PREPROCESS),
        m_TargetRecTimeline     (MAX_PREPROCESS,
                                 pIWMProfile,
                                 phr
                                 )
{
    HRESULT         hr ;
    SYSTEM_INFO     SystemInfo ;
    DWORD           dwIoSize ;
    DWORD           dwBufferCount ;
    DWORD           dwAlignment ;
    DWORD           dwFileGrowthQuantum ;
    WORD            wIndexStreamId ;
    DWORD           dwIndexGranularityMillis ;
    BOOL            fUseUnbufferedIo ;

    ASSERT (pPolicy) ;

    //  timeline might have failed to initialize
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    dwIndexGranularityMillis    = pPolicy -> Settings () -> IndexGranularityMillis () ;
    fUseUnbufferedIo            = pPolicy -> Settings () -> UseUnbufferedIo () ;
    dwIoSize                    = pPolicy -> Settings () -> AsyncIoBufferLen () ;
    dwBufferCount               = pPolicy -> Settings () -> AsyncIoWriteBufferCount () ;
    dwFileGrowthQuantum         = pPolicy -> Settings () -> FileGrowthQuantum () ;

    //  everything is going to be aligned on page boundaries
    ::GetSystemInfo (& SystemInfo) ;
    dwAlignment = SystemInfo.dwPageSize ;

    //  make the alignments
    dwIoSize            = ::AlignUp (dwIoSize, SystemInfo.dwPageSize) ;
    dwFileGrowthQuantum = ::AlignUp (dwFileGrowthQuantum, dwIoSize) ;

    //  index stream id
    hr = IndexStreamId (pIWMProfile, & wIndexStreamId) ;
    if (FAILED (hr)) { goto cleanup ; }

    (* phr) = ::DVRCreateRecorderWriter (
                    pPVRIOCounters,
                    pszRecordingFile,
                    pIWMProfile,
                    wIndexStreamId,
                    dwIndexGranularityMillis,
                    fUseUnbufferedIo,
                    dwIoSize,
                    dwBufferCount,
                    dwAlignment,
                    dwFileGrowthQuantum,
                    pPolicy -> Settings () -> GetDVRRegKey (),
                    & m_pIDVRRecorderWriter
                    ) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    //  success
    (* phr) = S_OK ;

    cleanup :

    return ;
}

CSBERecordingWriter::~CSBERecordingWriter (
    )
{
    FlushFIFO_ () ;
    RELEASE_AND_CLEAR (m_pIDVRRecorderWriter) ;
}

HRESULT
CSBERecordingWriter::WriteFIFO_ (
    )
{
    HRESULT         hr ;
    WORD            wQueuedStreamNumber ;
    QWORD           cnsQueuedSampleTime ;
    DWORD           dwQueuedFlags ;
    INSSBuffer *    pQueuedINSSBuffer ;
    BOOL            fDropSample ;

    ASSERT (m_TargetRecTimeline.CanShift ()) ;

    hr = S_OK ;

    while (!m_INSSBufferFIFO.Empty () &&
           SUCCEEDED (hr)) {

        hr = m_INSSBufferFIFO.Pop (
                & pQueuedINSSBuffer,
                & wQueuedStreamNumber,
                & cnsQueuedSampleTime,
                & dwQueuedFlags
                ) ;

        if (FAILED (hr)) {
            //  from while-loop
            break ;
        }

        m_TargetRecTimeline.Shift (
            wQueuedStreamNumber,
            dwQueuedFlags,
            pQueuedINSSBuffer,
            & cnsQueuedSampleTime,
            & fDropSample
            ) ;

        //  ***********************************
        //  BUGBUG: discontinuities !!
        //  ***********************************

        if (!fDropSample) {
            //  write it
            hr = m_pIDVRRecorderWriter -> WriteSample (
                        wQueuedStreamNumber,
                        cnsQueuedSampleTime,
                        dwQueuedFlags,
                        pQueuedINSSBuffer
                        ) ;
        }
        else {
            //  drop it
            hr = S_OK ;
        }

        //  done with this regardless
        pQueuedINSSBuffer -> Release () ;
    }

    return hr ;
}

HRESULT
CSBERecordingWriter::FlushFIFO_ (
    )
{
    HRESULT         hr ;
    WORD            wQueuedStreamNumber ;
    QWORD           cnsQueuedSampleTime ;
    DWORD           dwQueuedFlags ;
    INSSBuffer *    pQueuedINSSBuffer ;

    hr = S_OK ;

    while (!m_INSSBufferFIFO.Empty () &&
           SUCCEEDED (hr)) {

        hr = m_INSSBufferFIFO.Pop (
                & pQueuedINSSBuffer,
                & wQueuedStreamNumber,
                & cnsQueuedSampleTime,
                & dwQueuedFlags
                ) ;

        if (FAILED (hr)) {
            //  from while-loop
            break ;
        }

        //  done with this regardless
        pQueuedINSSBuffer -> Release () ;
    }

    return hr ;
}

HRESULT
CSBERecordingWriter::Write (
    IN  DWORD           cRecSamples,    //  starts at 0 for each new recording & increments
    IN  WORD            wStreamNumber,
    IN  QWORD           cnsSampleTime,
    IN  DWORD           dwFlags,
    IN  INSSBuffer *    pINSSBuffer
    )
{
    HRESULT hr ;
    BOOL    fDropSample ;

    ASSERT (m_pIDVRRecorderWriter) ;

    hr = S_OK ;

    if (cRecSamples == 0) {
        m_WriterState = REC_WRITER_STATE_PREPROCESS ;
        m_TargetRecTimeline.InitForNextRec () ;
    }

    switch (m_WriterState) {

        case REC_WRITER_STATE_PREPROCESS :

            //
            //  we're still pre-processing
            //

            //  preprocess
            hr = m_TargetRecTimeline.PreProcess (
                    cRecSamples,
                    wStreamNumber,
                    cnsSampleTime,
                    pINSSBuffer
                    ) ;
            if (FAILED (hr)) {
                break ;
            }

            //  determine if we're ready to fall through yet
            if (!m_TargetRecTimeline.CanShift ()) {

                //  not yet; queue the sample; we'll have to write it later
                hr = m_INSSBufferFIFO.Push (
                        pINSSBuffer,
                        wStreamNumber,
                        cnsSampleTime,
                        dwFlags
                        ) ;

                break ;
            }

            //  ready to start writing the samples to disk

            hr = WriteFIFO_ () ;
            if (FAILED (hr)) {
                break ;
            }

            //  should have written the whole FIFO
            ASSERT (m_INSSBufferFIFO.Empty ()) ;

            //  next state
            m_WriterState = REC_WRITER_STATE_WRITING ;

            //  fall through

        case REC_WRITER_STATE_WRITING :

            ASSERT (m_TargetRecTimeline.CanShift ()) ;

            m_TargetRecTimeline.Shift (
                wStreamNumber,
                dwFlags,
                pINSSBuffer,
                & cnsSampleTime,
                & fDropSample
                ) ;

            if (!fDropSample) {
                hr = m_pIDVRRecorderWriter -> WriteSample (
                            wStreamNumber,
                            cnsSampleTime,
                            dwFlags,
                            pINSSBuffer
                            ) ;
            }
            else {
                hr = S_OK ;
            }

            break ;
    } ;

    return hr ;
}

HRESULT
CSBERecordingWriter::Close (
    )
{
    ASSERT (m_pIDVRRecorderWriter) ;
    return m_pIDVRRecorderWriter -> Close () ;
}

HRESULT
CSBERecordingWriter::QueryWriter (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    return m_pIDVRRecorderWriter -> QueryInterface (riid, ppv) ;
}

QWORD
CSBERecordingWriter::GetLength (
    )
{
    return m_TargetRecTimeline.MaxStreamTime () ;
}

//  ============================================================================
//  CDVRWriter
//  ============================================================================

CDVRWriter::CDVRWriter (
    IN  IUnknown *          punkControlling,            //  weak ref !!
    IN  IWMProfile *        pIWMProfile
    ) : m_punkControlling   (punkControlling),
        m_pIWMProfile       (pIWMProfile),
        m_pDVRIOWriter      (NULL)
{
    ASSERT (m_punkControlling) ;
    ASSERT (m_pIWMProfile) ;

    m_pIWMProfile -> AddRef () ;

    m_dwID = GetTickCount () ;
}

CDVRWriter::~CDVRWriter (
    )
{
    m_pIWMProfile -> Release () ;
    ASSERT (m_pDVRIOWriter == NULL) ;   //  child classes must free all resources
                                        //    associated with the ringbuffer
}

void
CDVRWriter::ReleaseAndClearDVRIOWriter_ (
    )
{
    if (m_pDVRIOWriter) {
        m_pDVRIOWriter -> Close () ;
    }

    RELEASE_AND_CLEAR (m_pDVRIOWriter) ;
}

HRESULT
CDVRWriter::GetDVRRingBufferWriter (
    OUT IDVRRingBufferWriter **   ppIDVRRingBufferWriter
    )
{
    if (!ppIDVRRingBufferWriter) {
        return E_POINTER ;
    }

    if (m_pDVRIOWriter) {
        m_pDVRIOWriter->AddRef();
    }

    *ppIDVRRingBufferWriter = m_pDVRIOWriter;

    return S_OK ;
}

HRESULT
CDVRWriter::CreateRecorder (
    IN  LPCWSTR         pszFilename,
    IN  DWORD           dwReserved,
    OUT IDVRRecorder ** ppIDVRRecorder
    )
{
    HRESULT hr ;

    ASSERT (pszFilename) ;

    (* ppIDVRRecorder) = NULL ;

    if (m_pDVRIOWriter) {
        hr = m_pDVRIOWriter -> CreateRecorder (pszFilename, dwReserved, ppIDVRRecorder) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    if (FAILED (hr)) {
        RELEASE_AND_CLEAR (* ppIDVRRecorder) ;
    }

    return hr ;
}

HRESULT
CDVRWriter::Active (
    )
{
    HRESULT hr ;

    //  everything is 0-based
    ASSERT (m_pDVRIOWriter) ;
    hr = m_pDVRIOWriter -> SetFirstSampleTime (0) ;

    return hr ;
}

//  ============================================================================
//  CDVRIOWriter
//  ============================================================================

CDVRIOWriter::CDVRIOWriter (
    IN  CPVRIOCounters *    pPVRIOCounters,
    IN  IUnknown *          punkControlling,
    IN  CDVRPolicy *        pPolicy,
    IN  IWMProfile *        pIWMProfile,
    IN  LPCWSTR             pszDVRDirectory,
    IN  LPCWSTR             pszDVRFilename,
    OUT HRESULT *           phr
    ) : CDVRWriter          (punkControlling, pIWMProfile)
{
    WORD        wIndexStreamId ;
    BOOL        r ;
    SYSTEM_INFO SystemInfo ;
    DWORD       dwIoSize ;
    DWORD       dwBufferCount ;
    DWORD       dwAlignment ;
    DWORD       dwFileGrowthQuantum ;
    CW32SID *   pW32SID ;
    HRESULT     hr ;

    ASSERT (m_pDVRIOWriter == NULL) ;   //  parent class init
    ASSERT (phr) ;
    ASSERT (m_pIWMProfile) ;            //  parent class should have snarfed this
    ASSERT (pPolicy) ;
    ASSERT (pPVRIOCounters) ;

    pW32SID = NULL ;

    //  timeline might have failed to initialize
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    hr = pPolicy -> GetSIDs (& pW32SID) ;
    if (FAILED (hr)) {
        pW32SID = NULL ;
    }
    else {
        ASSERT (pW32SID) ;
    }

    (* phr) = IndexStreamId (m_pIWMProfile, & wIndexStreamId) ;
    if (FAILED (* phr)) { goto cleanup ; }

    //  collect our async IO settings
    dwIoSize            = pPolicy -> Settings () -> AsyncIoBufferLen () ;
    dwBufferCount       = pPolicy -> Settings () -> AsyncIoWriteBufferCount () ;
    dwFileGrowthQuantum = pPolicy -> Settings () -> FileGrowthQuantum () ;

    //  everything is going to be aligned on page boundaries
    ::GetSystemInfo (& SystemInfo) ;
    dwAlignment = SystemInfo.dwPageSize ;

    //  make the alignments
    dwIoSize            = ::AlignUp (dwIoSize, SystemInfo.dwPageSize) ;
    dwFileGrowthQuantum = ::AlignUp (dwFileGrowthQuantum, dwIoSize) ;

    //  create the ringbuffer object
    (* phr) = DVRCreateRingBufferWriter (
                    pPVRIOCounters,
                    pPolicy -> Settings () -> RingBufferMinNumBackingFiles (),
                    pPolicy -> Settings () -> RingBufferMaxNumBackingFiles (),
                    pPolicy -> Settings () -> RingBufferMaxNumBackingFiles (),      //  don't hold more than max
                    pPolicy -> Settings () -> RingBufferGrowBy (),
                    SecondsToWMSDKTime (pPolicy -> Settings () -> RingBufferBackingFileDurSecEach ()),
                    m_pIWMProfile,
                    wIndexStreamId,
                    pPolicy -> Settings () -> IndexGranularityMillis (),
                    pPolicy -> Settings () -> UseUnbufferedIo (),
                    dwIoSize,
                    dwBufferCount,
                    dwAlignment,
                    dwFileGrowthQuantum,
                    CDVREventSink::DVRIOCallback,
                    (LPVOID) pPolicy -> EventSink (),
                    pPolicy -> Settings () -> GetDVRRegKey (),
                    pszDVRDirectory,
                    pszDVRFilename,
                    (pW32SID ? pW32SID -> Count () : 0),
                    (pW32SID ? pW32SID -> ppSID () : NULL),
                    & m_pDVRIOWriter
                    ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pDVRIOWriter -> SetMaxStreamDelta (
                MillisToWMSDKTime  (pPolicy -> Settings () -> MaxStreamDeltaMillis ())
                ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    cleanup :

    RELEASE_AND_CLEAR (pW32SID) ;

    return ;
}

CDVRIOWriter::~CDVRIOWriter (
    )
{
    ReleaseAndClearDVRIOWriter_ () ;
}

HRESULT
CDVRIOWriter::Write (
    IN      WORD            wStreamNumber,
    IN OUT  QWORD *         pcnsSampleTime,
    IN      QWORD           msSendTime,
    IN      QWORD           cnsSampleDuration,
    IN      DWORD           dwFlags,
    IN      INSSBuffer *    pINSSBuffer
    )
{
    HRESULT hr ;

    ASSERT (m_pDVRIOWriter) ;
    hr = m_pDVRIOWriter -> WriteSample (
            wStreamNumber,
            pcnsSampleTime,
            dwFlags,
            pINSSBuffer
            ) ;

    return hr ;
}

//  ============================================================================
//  CDVRWriteManager
//  ============================================================================

CDVRWriteManager::CDVRWriteManager (
    IN  CDVRPolicy *    pPolicy,
    OUT HRESULT *       phr
    ) : m_pDVRWriter                    (NULL),
        m_pIRefClock                    (NULL),
        m_rtStartTime                   (UNDEFINED),
        m_rtActualLastWriteStreamTime   (0L),
        m_pPVRIOCounters                (NULL),
        m_SampleRate                    (UNDEFINED)
{
    InitializeCriticalSection (& m_crt) ;

    m_pPVRIOCounters = new CPVRIOCounters () ;
    if (!m_pPVRIOCounters) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    //  ours
    m_pPVRIOCounters -> AddRef () ;

    //  ignore the return code here - we don't want to fail the load of
    //   the filter because our stats failed to init
    ASSERT (pPolicy) ;
    m_DVRReceiveStatsWriter.Initialize  (pPolicy -> Settings () -> StatsEnabled ()) ;
    m_pPVRIOCounters -> Initialize      (pPolicy -> Settings () -> StatsEnabled ()) ;

    cleanup :

    return ;
}

CDVRWriteManager::~CDVRWriteManager (
    )
{
    Inactive () ;

    if (m_pPVRIOCounters) {
        m_pPVRIOCounters -> Release () ;
    }

    DeleteCriticalSection (& m_crt) ;
}

HRESULT
CDVRWriteManager::Active (
    IN  CDVRWriter *        pDVRWriter,
    IN  IReferenceClock *   pIRefClock
    )
{
    if (pIRefClock == NULL) {
        //  must have a clock
        return E_FAIL ;
    }

    LockWriter_ () ;

    ASSERT (pDVRWriter) ;
    ASSERT (m_pDVRWriter == NULL) ;
    ASSERT (m_pIRefClock == NULL) ;
    ASSERT (m_rtActualLastWriteStreamTime == 0L) ;

    m_pDVRWriter    = pDVRWriter ;
    m_pIRefClock    = pIRefClock ;

    m_pIRefClock -> AddRef () ;

    m_pDVRWriter -> Active () ;

    m_SampleRate.Reset () ;

    UnlockWriter_ () ;

    return S_OK ;
}

HRESULT
CDVRWriteManager::Inactive (
    )
{
    LockWriter_ () ;

    m_pDVRWriter = NULL ;
    RELEASE_AND_CLEAR (m_pIRefClock) ;

    m_rtStartTime                   = UNDEFINED ;
    m_rtActualLastWriteStreamTime   = 0L ;

    UnlockWriter_ () ;

    return S_OK ;
}

HRESULT
CDVRWriteManager::RecordingStreamTime (
    IN  DWORD               dwWriterID,
    OUT REFERENCE_TIME *    prtStream,
    OUT REFERENCE_TIME *    prtLastWriteStreamTime
    )
{
    HRESULT         hr ;

    LockWriter_ () ;

    //  must validate these before calling
    if (m_pIRefClock                &&
        m_rtStartTime != UNDEFINED  &&
        m_pDVRWriter) {

        //  make sure the writers are the same i.e. the DVRIO ring buffer
        //    is the same object
        ASSERT (m_pDVRWriter) ;

        //  make sure writer is the same
        if (m_pDVRWriter -> GetID () == dwWriterID) {
            hr = CaptureStreamTime_ (prtStream) ;
            (* prtLastWriteStreamTime) = m_rtActualLastWriteStreamTime ;
        }
        else {
            //  caller got a recording object from a ringbuffer that is no
            //    longer in use & stopped
            hr = E_UNEXPECTED ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    UnlockWriter_ () ;

    return hr ;
}

HRESULT
CDVRWriteManager::CaptureStreamTime_ (
    OUT REFERENCE_TIME *    prtNow
    )
{
    HRESULT hr ;

    ASSERT (prtNow) ;
    ASSERT (m_pIRefClock) ;
    ASSERT (m_rtStartTime != UNDEFINED) ;

    hr = m_pIRefClock -> GetTime (prtNow) ;
    if (SUCCEEDED (hr)) {
        //  make sure that we monotonically increase
        (* prtNow) = Max <REFERENCE_TIME> ((* prtNow) - m_rtStartTime, 0) ;

        TRACE_2 (LOG_AREA_TIME, 4,
             TEXT ("CDVRWriteManager::CaptureStreamTime_ () returning %I64d (%I64d ms)"),
             (* prtNow), ::DShowTimeToMilliseconds (* prtNow)) ;
    }

    return hr ;
}

HRESULT
CDVRWriteManager::OnReceive (
    IN  int                             iPinIndex,
    IN  CDVRDShowToWMSDKTranslator *    pTranslator,
    IN  IMediaSample *                  pIMediaSample
    )
{
    HRESULT                 hr ;
    CWMINSSBuffer3Wrapper * pINSSBuffer3Wrapper ;
    DWORD                   dwFlags ;
    BYTE *                  pbBuffer ;
    DWORD                   dwLength ;
    REFERENCE_TIME          rtCaptureStreamTime ;
    QWORD                   cnsCaptureStreamTime ;

    m_DVRReceiveStatsWriter.SampleIn (iPinIndex, pIMediaSample) ;

    //
    //  no need to lock the writer across this call; caller is the filter
    //    and it will quench the sample flow before inactivating
    //

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;

        pINSSBuffer3Wrapper = m_INSSBuffer3Wrappers.Get () ;
        if (pINSSBuffer3Wrapper) {

            pIMediaSample -> GetPointer (& pbBuffer) ;
            dwLength = pIMediaSample -> GetActualDataLength () ;

            hr = pINSSBuffer3Wrapper -> Init (
                    pIMediaSample,
                    pbBuffer,
                    dwLength
                    ) ;

            if (SUCCEEDED (hr)) {

                #ifdef SBE_PERF
                ::OnCaptureInstrumentPerf_ (
                    pIMediaSample,
                    pINSSBuffer3Wrapper,
                    iPinIndex
                    ) ;
                #endif  //  SBE_PERF

                hr = pTranslator -> SetAttributesWMSDK (
                        & m_DVRReceiveStatsWriter,
                        m_SampleRate.OnSample (::timeGetTime ()),
                        m_pIRefClock,
                        pIMediaSample,
                        pINSSBuffer3Wrapper,
                        & dwFlags
                        ) ;
                if (SUCCEEDED (hr)) {
                    hr = CaptureStreamTime_ (& rtCaptureStreamTime) ;
                    if (SUCCEEDED (hr)) {
                        cnsCaptureStreamTime = ::DShowToWMSDKTime (rtCaptureStreamTime) ;

                        hr = m_pDVRWriter -> Write (
                                DShowWMSDKHelpers::PinIndexToWMStreamNumber (iPinIndex),
                                & cnsCaptureStreamTime,
                                0,
                                1,
                                dwFlags,
                                pINSSBuffer3Wrapper
                                ) ;
                        m_DVRReceiveStatsWriter.SampleWritten (iPinIndex, hr) ;

                        if (SUCCEEDED (hr)) {
                            m_rtActualLastWriteStreamTime = ::WMSDKToDShowTime (cnsCaptureStreamTime) ;
                        }
                    }
                }

                pINSSBuffer3Wrapper -> Release () ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriteManager::OnBeginFlush (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriteManager::OnEndFlush (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriteManager::OnEndOfStream (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrdswrite.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdswrite.h

    Abstract:

        This module contains the declarations for our writing layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__shared__dvrdswrite_h
#define __tsdvr__shared__dvrdswrite_h

//  ============================================================================
//  CSBERecordingWriter
//  ============================================================================

struct DVR_INSSBUFFER_REC {
    INSSBuffer *    pINSSBuffer ;
    WORD            wStreamNumber ;
    QWORD           cnsSampleTime ;
    DWORD           dwFlags ;
} ;

class CINSSBufferList
{
    enum {
        ALLOC_QUANTUM = 10
    } ;

    TStructPool <DVR_INSSBUFFER_REC, ALLOC_QUANTUM> m_INSSBufferRecPool ;
    CTDynArray <DVR_INSSBUFFER_REC *> *             m_pINSSBufferRecList ;

    public :

        CINSSBufferList (
            IN  CTDynArray <DVR_INSSBUFFER_REC *> * pINSSBufferRecList
            ) : m_pINSSBufferRecList (pINSSBufferRecList) {}

        BOOL Empty ()   { return m_pINSSBufferRecList -> Empty () ; }

        //  does not refcount either !!
        HRESULT
        Push (
            IN  INSSBuffer *    pINSSBuffer,
            IN  WORD            wStreamNumber,
            IN  QWORD           cnsSampleTime,
            IN  DWORD           dwFlags
            )
        {
            HRESULT                 hr ;
            DVR_INSSBUFFER_REC *    pINSSBufferRec ;
            DWORD                   dw ;

            ASSERT (pINSSBuffer) ;

            pINSSBufferRec = m_INSSBufferRecPool.Get () ;
            if (pINSSBufferRec) {

                //  set
                pINSSBufferRec -> pINSSBuffer   = pINSSBuffer ;     //  we'll ref
                pINSSBufferRec -> wStreamNumber = wStreamNumber ;
                pINSSBufferRec -> cnsSampleTime = cnsSampleTime ;
                pINSSBufferRec -> dwFlags       = dwFlags ;

                //  push to queue
                dw = m_pINSSBufferRecList -> Push (pINSSBufferRec) ;
                hr = HRESULT_FROM_WIN32 (dw) ;

                if (SUCCEEDED (hr)) {
                    pINSSBufferRec -> pINSSBuffer -> AddRef () ;    //  list's
                }
                else {
                    m_INSSBufferRecPool.Recycle (pINSSBufferRec) ;
                }
            }
            else {
                hr = E_OUTOFMEMORY ;
            }

            return hr ;
        }

        HRESULT
        Pop (
            OUT INSSBuffer **   ppINSSBuffer,
            OUT WORD *          pwStreamNumber,
            OUT QWORD *         pcnsSampleTime,
            OUT DWORD *         pdwFlags
            )
        {
            HRESULT                 hr ;
            DVR_INSSBUFFER_REC *    pINSSBufferRec ;
            DWORD                   dw ;

            ASSERT (ppINSSBuffer) ;
            ASSERT (pwStreamNumber) ;
            ASSERT (pcnsSampleTime) ;
            ASSERT (pdwFlags) ;

            if (!Empty ()) {
                dw = m_pINSSBufferRecList -> Pop (& pINSSBufferRec) ;
                ASSERT (dw == NOERROR) ;        //  queue is not empty

                (* ppINSSBuffer)    = pINSSBufferRec -> pINSSBuffer ;      //  keep list's ref as outgoing
                (* pwStreamNumber)  = pINSSBufferRec -> wStreamNumber ;
                (* pcnsSampleTime)  = pINSSBufferRec -> cnsSampleTime ;
                (* pdwFlags)        = pINSSBufferRec -> dwFlags ;

                m_INSSBufferRecPool.Recycle (pINSSBufferRec) ;

                hr = S_OK ;
            }
            else {
                hr = E_UNEXPECTED ;
            }

            return hr ;
        }
} ;

class CINSSBufferFIFO :
    public CINSSBufferList
{
    enum {
        ALLOC_QUANTUM = 10
    } ;

    CTDynQueue <DVR_INSSBUFFER_REC *>  m_INSSBufferRecQueue ;

    public :

        CINSSBufferFIFO (
            ) : m_INSSBufferRecQueue    (ALLOC_QUANTUM),
                CINSSBufferList         (& m_INSSBufferRecQueue) {}
} ;

//  ============================================================================
//  ============================================================================

class CSBERecordingWriter
{
    enum REC_WRITER_STATE {
        REC_WRITER_STATE_PREPROCESS,    //  preprocessing; discovering the recording's timeline
        REC_WRITER_STATE_WRITING        //  timeline discovered; writing to disk
    } ;

    enum {
        //  this is the maximum number of buffers we'll preprocess when we're
        //    discovering the next recording's timeline
        MAX_PREPROCESS = 50
    } ;

    IDVRRecorderWriter *    m_pIDVRRecorderWriter ;
    REC_WRITER_STATE        m_WriterState ;
    CINSSBufferFIFO         m_INSSBufferFIFO ;
    CConcatRecTimeline      m_TargetRecTimeline ;

    HRESULT
    WriteFIFO_ (
        ) ;

    HRESULT
    FlushFIFO_ (
        ) ;

    public :

        CSBERecordingWriter (
            IN  CPVRIOCounters *    pPVRIOCounters,
            IN  LPCWSTR             pszRecordingFile,
            IN  IWMProfile *        pIWMProfile,
            IN  CDVRPolicy *        pPolicy,
            OUT HRESULT *           phr
            ) ;

        ~CSBERecordingWriter (
            ) ;

        HRESULT
        Write (
            IN  DWORD           cRecSamples,    //  starts at 0 for each new recording & increments
            IN  WORD            wStreamNumber,
            IN  QWORD           cnsSampleTime,
            IN  DWORD           dwFlags,
            IN  INSSBuffer *    pINSSBuffer
            ) ;

        HRESULT
        Close (
            ) ;

        HRESULT
        QueryWriter (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  instantaneous length
        QWORD
        GetLength (
            ) ;
} ;

//  ============================================================================
//  CDVRWriter
//  ============================================================================

class CDVRWriter :
    public IDVRStreamSinkPriv
{
    IUnknown *      m_punkControlling ;         //  controlling unknown - we
                                                //   delegate everything; weak ref !!
                                                //   can be NULL i.e. we're standalone (in which case we're not really a COM object)

    DWORD           m_dwID ;                    //  tickcount at instantiation; doesn't need to
                                                //    be GUID-strong

    protected :

        IDVRRingBufferWriter *  m_pDVRIOWriter ;
        IWMProfile *            m_pIWMProfile ;

        void ReleaseAndClearDVRIOWriter_ () ;

    public :

        CDVRWriter (
            IN  IUnknown *          punkControlling,            //  weak ref !!
            IN  IWMProfile *        pIWMProfile
            ) ;

        virtual
        ~CDVRWriter (
            ) ;

        STDMETHODIMP_ (ULONG)   AddRef ()                                   { if (m_punkControlling) { return m_punkControlling -> AddRef () ; } else { return 1 ; }}
        STDMETHODIMP_ (ULONG)   Release ()                                  { if (m_punkControlling) { return m_punkControlling -> Release () ; } else { return 1 ; }}
        STDMETHODIMP            QueryInterface (REFIID riid, void ** ppv)   { if (m_punkControlling) { return m_punkControlling -> QueryInterface (riid, ppv) ; } else { return E_NOINTERFACE ; }}

        IMPLEMENT_IDVRSTREAMSINKPRIV () ;

        DWORD GetID ()      { return m_dwID ; }

        virtual
        HRESULT
        Write (
            IN      WORD            wStreamNumber,
            IN OUT  QWORD *         pcnsSampleTime,
            IN      QWORD           msSendTime,
            IN      QWORD           cnsSampleDuration,
            IN      DWORD           dwFlags,
            IN      INSSBuffer *    pINSSBuffer
            ) = 0 ;

        HRESULT
        CreateRecorder (
            IN  LPCWSTR         pszFilename,
            IN  DWORD           dwReserved,
            OUT IDVRRecorder ** ppIDVRRecorder
            ) ;

        HRESULT
        Active (
            ) ;
} ;

//  ============================================================================
//  CDVRIOWriter
//  ============================================================================

class CDVRIOWriter :
    public CDVRWriter
{
    public :

        CDVRIOWriter (
            IN  CPVRIOCounters *    pPVRIOCounters,
            IN  IUnknown *          punkControlling,
            IN  CDVRPolicy *        pPolicy,
            IN  IWMProfile *        pIWMProfile,
            IN  LPCWSTR             pszDVRDirectory,        //  can be NULL
            IN  LPCWSTR             pszDVRFilename,         //  can be NULL
            OUT HRESULT *           phr
            ) ;

        virtual
        ~CDVRIOWriter (
            ) ;

        virtual
        HRESULT
        Write (
            IN      WORD            wStreamNumber,
            IN OUT  QWORD *         pcnsSampleTime,
            IN      QWORD           msSendTime,
            IN      QWORD           cnsSampleDuration,
            IN      DWORD           dwFlags,
            IN      INSSBuffer *    pINSSBuffer
            ) ;
} ;

//  ============================================================================
//  CDVRWriteManager
//  ============================================================================

class CDVRWriteManager :
    public CIDVRDShowStream
{
    CWMINSSBuffer3WrapperPool   m_INSSBuffer3Wrappers ;
    CDVRWriter *                m_pDVRWriter ;
    IReferenceClock *           m_pIRefClock ;
    REFERENCE_TIME              m_rtStartTime ;
    CDVRReceiveStatsWriter      m_DVRReceiveStatsWriter ;
    CPVRIOCounters *            m_pPVRIOCounters ;
    CRITICAL_SECTION            m_crt ;
    REFERENCE_TIME              m_rtActualLastWriteStreamTime ;

    enum {
        BRACKET_DURATION_MILLIS     = 100,      //  100 ms granularity
        MAX_BRACKET_COUNT           = 20,       //  last 2 seconds' of data
        MIN_BRACKET_COUNT           = 5,        //  no less than last 500 ms
    } ;

    CTSampleRate <
        DWORD,
        MAX_BRACKET_COUNT,
        BRACKET_DURATION_MILLIS,
        MIN_BRACKET_COUNT>      m_SampleRate ;

    void LockWriter_ ()         { EnterCriticalSection (& m_crt) ; }
    void UnlockWriter_ ()       { LeaveCriticalSection (& m_crt) ; }

    HRESULT
    CaptureStreamTime_ (
        OUT REFERENCE_TIME *    prtNow
        ) ;

    public :

        CDVRWriteManager (
            IN  CDVRPolicy *,
            OUT HRESULT *
            ) ;

        ~CDVRWriteManager (
            ) ;

        CPVRIOCounters * PVRIOCounters ()   { return m_pPVRIOCounters ; }

        HRESULT
        Active (
            IN  CDVRWriter *        pDVRWriter,
            IN  IReferenceClock *   pIRefClock
            ) ;

        HRESULT
        Inactive (
            ) ;

        BOOL IsActive ()
        {
            return (m_pIRefClock &&
                    m_rtStartTime != UNDEFINED ? TRUE : FALSE) ;
        }

        void
        StartStreaming (
            )
        {
            ASSERT (m_pIRefClock) ;
            m_pIRefClock -> GetTime (& m_rtStartTime) ;
        }

        HRESULT
        RecordingStreamTime (
            IN  DWORD               dwWriterID,
            OUT REFERENCE_TIME *    prtStream,
            OUT REFERENCE_TIME *    prtLastWriteStreamTime
            ) ;

        //  --------------------------------------------------------------------
        //  CIDVRDShowStream

        virtual
        HRESULT
        OnReceive (
            IN  int                             iPinIndex,
            IN  CDVRDShowToWMSDKTranslator *    pTranslator,
            IN  IMediaSample *                  pIMediaSample
            ) ;

        virtual
        HRESULT
        OnBeginFlush (
            IN  int iPinIndex
            ) ;

        virtual
        HRESULT
        OnEndFlush (
            IN  int iPinIndex
            ) ;

        virtual
        HRESULT
        OnEndOfStream (
            IN  int iPinIndex
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdswrite_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrprof.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrprof.h

    Abstract:

        This module contains the declarations for our DShow - WMSDK_Profiles
         layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__shared__dvrprof_h
#define __tsdvr__shared__dvrprof_h

//  ============================================================================
//  CDVRWriterProfile
//  ============================================================================

class CDVRWriterProfile
{
    IWMProfile *    m_pIWMProfile ;
    BOOL            m_fInlineDShowProps ;
    DWORD           m_dwDefaultAvgBitRate ;

    //  each stream has a buffering window; this is the time that is
    //   added to the timestamps, in the MUXing layer of the WMSDK; on
    //   the way back out, timestamps will be offset by this amount to
    //   provide a buffering time e.g. delta between transmission start
    //   time over network and rendering on the client;
    DWORD   m_dwBufferWindow ;

    public :

        CDVRWriterProfile (
            IN  CDVRPolicy *        pPolicy,
            IN  const WCHAR *       szName,
            IN  const WCHAR *       szDescription,
            OUT HRESULT *           phr
            ) ;

        CDVRWriterProfile (
            IN  CDVRPolicy *        pPolicy,
            IN  IWMProfile *        pIWMProfile,
            OUT HRESULT *           phr
            ) ;

        ~CDVRWriterProfile (
            ) ;

        HRESULT
        AddStream (
            IN  LONG            lIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        DeleteStream (
            IN  LONG    lIndex
            ) ;

        HRESULT
        GetStream (
            IN  LONG            lIndex,
            OUT CMediaType **   ppmt
            ) ;

        DWORD
        GetStreamCount (
            ) ;

        HRESULT
        GetRefdWMProfile (
            OUT IWMProfile **   ppIWMProfile
            )
        {
            HRESULT hr ;

            if (m_pIWMProfile) {
                (* ppIWMProfile) = m_pIWMProfile ;
                (* ppIWMProfile) -> AddRef () ;
                hr = S_OK ;
            }
            else {
                hr = E_UNEXPECTED ;
            }

            return hr ;
        }
} ;

//  ============================================================================
//  CDVRReaderProfile
//  ============================================================================

class CDVRReaderProfile
{
    LONG                m_lRef ;
    IWMProfile *        m_pIWMProfile ;
    IDVRReader *        m_pIDVRReader ;
    CDVRPolicy *        m_pPolicy ;     //  can be NULL

    public :

        CDVRReaderProfile (
            IN  CDVRPolicy *    pPolicy,
            IN  IDVRReader *    pIDVRReader,
            OUT HRESULT *       phr
            ) ;

        CDVRReaderProfile (
            IN  CDVRPolicy *    pPolicy,
            IN  IWMProfile *    pIWMProfile,
            OUT HRESULT *       phr
            ) ;

        virtual
        ~CDVRReaderProfile (
            ) ;

        ULONG AddRef () { return InterlockedIncrement (& m_lRef) ; }
        ULONG Release () ;

        HRESULT
        EnumWMStreams (
            OUT DWORD *
            ) ;

        HRESULT
        GetStream (
            IN  DWORD           dwIndex,
            OUT WORD *          pwStreamNum,
            OUT AM_MEDIA_TYPE * pmt                 //  call FreeMediaType () on
            ) ;

        BOOL
        IsEqual (
            IN  CDVRReaderProfile * pReaderProfile
            ) ;

        IWMProfile *
        GetRefdProfile (
            )
        {
            if (m_pIWMProfile) {
                m_pIWMProfile -> AddRef () ;
            }

            return m_pIWMProfile ;
        }
} ;

//  ============================================================================
//  ============================================================================

#endif  //  __tsdvr__shared__dvrprof_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrpins.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrpins.cpp

    Abstract:

        This module contains the DVR filters' pin-related code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"
#include "dvrdsseek.h"
#include "dvrpins.h"
#include "dvrdsread.h"

#pragma warning (disable:4355)


//  so we can send out free bits with timestamp tracing etc.. to external
//    vendors we can enable/disable some tracing in free bits
#undef FREE_BITS_TRACING
//#define FREE_BITS_TRACING   1

#ifdef FREE_BITS_TRACING
#pragma message("free bits tracing is ON")

static
void
DVRDebugOut_ (
    IN  TCHAR * szfmt,
    ...
    )
{
    static  TCHAR achbuffer [512] ;
    va_list va ;
    int     i ;

    va_start (va, szfmt) ;
    i = wnvsprintf (achbuffer, 512, szfmt, va) ;
    if (i > 0) {
        achbuffer [512 - 1] = TEXT ('\0') ;
        OutputDebugString (achbuffer) ;
        OutputDebugString (__T("\n")) ;
    }
}

#endif

//  ============================================================================
//  ============================================================================

static
HRESULT
NewDVROutputPin (
    IN  AM_MEDIA_TYPE *         pmt,
    IN  CDVRPolicy *            pPolicy,
    IN  TCHAR *                 pszPinName,
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pFilterLock,
    IN  CDVRDShowSeekingCore *  pSeekingCore,
    IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
    IN  CDVRSourcePinManager *  pOwningPinBank,
    OUT CDVROutputPin **        ppDVROutputPin
    )
{
    HRESULT hr ;

    ASSERT (pmt) ;
    ASSERT (ppDVROutputPin) ;

    hr = S_OK ;

    //  ========================================================================
    //  video
    if (pmt -> majortype  == MEDIATYPE_Video) {

        //  mpeg-2
        if (IsMpeg2Video (pmt)) {
            (* ppDVROutputPin) = new CDVRMpeg2VideoOutputPin (
                                        pPolicy,
                                        pszPinName,
                                        pOwningFilter,
                                        pFilterLock,
                                        pSeekingCore,
                                        pDVRSendStatsWriter,
                                        pOwningPinBank,
                                        & hr
                                        ) ;
        }

        //  other - assumes all samples carry key frames; frame-semantics vs.
        //    bytestream semantics
        else {
            (* ppDVROutputPin) = new CDVRVideoOutputPin (
                                        pPolicy,
                                        pszPinName,
                                        pOwningFilter,
                                        pFilterLock,
                                        pSeekingCore,
                                        pDVRSendStatsWriter,
                                        pOwningPinBank,
                                        & hr
                                        ) ;
        }
    }

    //  ========================================================================
    //  mpeg-2 audio
    else if (IsMpeg2Audio (pmt)) {

        (* ppDVROutputPin) = new CDVRMpeg2AudioOutputPin (
                                    pPolicy,
                                    pszPinName,
                                    pOwningFilter,
                                    pFilterLock,
                                    pSeekingCore,
                                    pDVRSendStatsWriter,
                                    pOwningPinBank,
                                    & hr
                                    ) ;
    }

    //  ========================================================================
    //  dolby ac-3 audio
    else if (IsDolbyAc3Audio (pmt)) {

        (* ppDVROutputPin) = new CDVRDolbyAC3AudioOutputPin (
                                    pPolicy,
                                    pszPinName,
                                    pOwningFilter,
                                    pFilterLock,
                                    pSeekingCore,
                                    pDVRSendStatsWriter,
                                    pOwningPinBank,
                                    & hr
                                    ) ;
    }

    //  ========================================================================
    //  everything else - generic
    else {
        //  generic
        (* ppDVROutputPin) = new CDVROutputPin (
                                    pPolicy,
                                    pszPinName,
                                    pOwningFilter,
                                    pFilterLock,
                                    pSeekingCore,
                                    pDVRSendStatsWriter,
                                    pOwningPinBank,
                                    & hr
                                    ) ;
    }

    if ((* ppDVROutputPin) == NULL ||
        FAILED (hr)) {

        hr = ((* ppDVROutputPin) ? hr : E_OUTOFMEMORY) ;
        DELETE_RESET (* ppDVROutputPin) ;
    }

    return hr ;
}

static
TCHAR *
CreatePinName (
    IN  int             iPinIndex,
    IN  PIN_DIRECTION   PinDirection,
    IN  int             iBufferLen,
    OUT TCHAR *         pchBuffer
    )
{
    int i ;

    ASSERT (pchBuffer) ;
    ASSERT (iBufferLen >= 32) ;

    //  security note: this is an internal call; the buffer length is fixed by
    //    caller, and must be fixed of a size that is sufficiently long to
    //    accomodate the base name + a max integer value; if this length is
    //    ever insufficent we'll ASSERT i.e. it is an *internal* bug and has
    //    nothing to do with some COM-caller-supplied parameter value

    if (PinDirection == PINDIR_INPUT) {
        //  input
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR In - %d"),
                iPinIndex
                ) ;
    }
    else {
        //  output
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR Out - %d"),
                iPinIndex
                ) ;
    }

    ASSERT (i > 0) ;

    //  make sure it's capped off
    i = ::Min <int> (i, iBufferLen - 1) ;
    pchBuffer [i] = TEXT ('\0') ;

    return pchBuffer ;
}

TCHAR *
CreateOutputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_OUTPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

TCHAR *
CreateInputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_INPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRPin::SetPinMediaType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::SetPinMediaType ()")) ;

    ASSERT (pmt) ;

    FreeMediaType (m_mtDVRPin) ;
    m_mtDVRPin.ResetFormatBuffer () ;

    m_pFilterLock -> Lock () ;

    CopyMediaType (& m_mtDVRPin, pmt) ;
    hr = S_OK ;

    m_fIsAudioOrVideo = (IsAudio (& m_mtDVRPin) ||
                         IsVideo (& m_mtDVRPin)) ;

    m_pFilterLock -> Unlock () ;

    return hr ;
}

HRESULT
CDVRPin::GetPinMediaType (
    OUT AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::GetPinMediaType ()")) ;

    ASSERT (pmt) ;

    m_pFilterLock -> Lock () ;

    hr = CopyMediaType (pmt, & m_mtDVRPin) ;

    m_pFilterLock -> Unlock () ;

    return hr ;
}

HRESULT
CDVRPin::GetPinMediaTypeCopy (
    OUT CMediaType **   ppmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::GetPinMediaType ()")) ;

    ASSERT (ppmt) ;

    (* ppmt) = new CMediaType ;
    if (!(* ppmt)) {
        return E_OUTOFMEMORY ;
    }

    m_pFilterLock -> Lock () ;

    hr = CopyMediaType ((* ppmt), & m_mtDVRPin) ;

    m_pFilterLock -> Unlock () ;

    if (FAILED (hr)) {
        DELETE_RESET (* ppmt) ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRInputPin::CDVRInputPin (
    IN  TCHAR *                     pszPinName,
    IN  CBaseFilter *               pOwningFilter,
    IN  CIDVRPinConnectionEvents *  pIPinConnectEvent,
    IN  CIDVRDShowStream *          pIDShowStream,
    IN  CCritSec *                  pFilterLock,
    IN  CCritSec *                  pRecvLock,
    IN  CDVRPolicy *                pPolicy,
    OUT HRESULT *                   phr
    ) : CBaseInputPin       (NAME ("CDVRInputPin"),
                             pOwningFilter,
                             pFilterLock,
                             phr,
                             pszPinName
                             ),
        CDVRPin             (pFilterLock,
                             pPolicy
                             ),
        m_pIPinConnectEvent (pIPinConnectEvent),
        m_pIDShowStream     (pIDShowStream),
        m_pRecvLock         (pRecvLock),
        m_pTranslator       (NULL)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRInputPin")) ;

    ASSERT (m_pIPinConnectEvent) ;
    ASSERT (m_pIDShowStream) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    cleanup :

    return ;
}

CDVRInputPin::~CDVRInputPin (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRInputPin")) ;
    delete m_pTranslator ;
}

HRESULT
CDVRInputPin::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    if (IsConnected () &&
        iPosition == 0) {

        hr = GetPinMediaType (pmt) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRInputPin::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRInputPin::CheckMediaType ()")) ;

    if (IsStopped ()) {
        //  we're stopped - accept everything
        hr = S_OK ;
    }
    else {
        //  we're running - this is a dynamic format change - punt
        //    pass/fail
        hr = m_pIPinConnectEvent -> OnQueryAccept (pmt) ;
    }

    return hr ;
}

HRESULT
CDVRInputPin::BreakConnect (
    )
{
    HRESULT hr ;

    hr = CBaseInputPin::BreakConnect () ;
    if (SUCCEEDED (hr)) {
        //  ignore the return; if WMSDK fails the complete connect
        //    call i.e. does not try to create a streams, we'll get
        //    a failure here when we try to delete a non-existent
        //    stream, and the baseclass code will annoyingly ASSERT
        m_pIPinConnectEvent -> OnInputBreakConnect (
                GetBankStoreIndex ()
                ) ;

        FreePinMediaType_ () ;
        DELETE_RESET (m_pTranslator) ;
    }

    return hr ;
}

HRESULT
CDVRInputPin::CompleteConnect (
    IN  IPin *  pReceivePin
    )
{
    HRESULT hr ;
    int     i ;

    TRACE_ENTER_0 (TEXT ("CDVRInputPin::CompleteConnect ()")) ;

    hr = CBaseInputPin::CompleteConnect (pReceivePin) ;
    if (SUCCEEDED (hr)) {
        hr = m_pIPinConnectEvent -> OnInputCompleteConnect (
                GetBankStoreIndex (),
                & m_mt
                ) ;

        if (SUCCEEDED (hr)) {
            SetPinMediaType (& m_mt) ;
            m_pTranslator = DShowWMSDKHelpers::GetDShowToWMSDKTranslator (
                                & m_mt,
                                m_pPolicy,
                                GetBankStoreIndex ()
                                ) ;
        }
    }

    return hr ;
}

STDMETHODIMP
CDVRInputPin::QueryAccept (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    return m_pIPinConnectEvent -> OnQueryAccept (pmt) ;
}

STDMETHODIMP
CDVRInputPin::Receive (
    IN  IMediaSample *  pIMS
    )
{
    HRESULT hr ;

    LockRecv_ ();

#ifdef EHOME_WMI_INSTRUMENTATION
    PERFLOG_STREAMTRACE( 1, PERFINFO_STREAMTRACE_SBE_DVRINPUTPIN_RECEIVE,
        0, 0, 0, 0, 0 );
#endif
    hr = CBaseInputPin::Receive (pIMS) ;
    if (hr == S_OK &&
        m_pIDShowStream) {

        hr = m_pIDShowStream -> OnReceive (
                GetBankStoreIndex (),
                m_pTranslator,
                pIMS
                ) ;
    }

    UnlockRecv_ () ;

    return hr ;
}

HRESULT
CDVRInputPin::Active (
    IN  BOOL    fInlineProps
    )
{
    HRESULT                 hr ;
    IDVRAnalysisConfig *    pIDVRAnalysisConfig ;

    LockRecv_ () ;

    if (IsConnected ()) {
        hr = CBaseInputPin::Active () ;

        if (SUCCEEDED (hr)) {
            hr = GetConnected () -> QueryInterface (
                    IID_IDVRAnalysisConfig,
                    (void **) & pIDVRAnalysisConfig
                    ) ;
            if (FAILED (hr)) {
                pIDVRAnalysisConfig = NULL ;

                //  don't fail the Active call because the interface is not there
                hr = S_OK ;
            }

            m_pTranslator -> SetAnalysisPresent (pIDVRAnalysisConfig ? TRUE : FALSE) ;

            RELEASE_AND_CLEAR (pIDVRAnalysisConfig) ;
        }
    }
    else {
        hr = S_OK ;
    }

    ASSERT (m_pTranslator) ;
    m_pTranslator -> SetInlineProps (TRUE) ;

    UnlockRecv_ () ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVROutputPin::CDVROutputPin (
    IN  CDVRPolicy *            pPolicy,
    IN  TCHAR *                 pszPinName,
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pFilterLock,
    IN  CDVRDShowSeekingCore *  pSeekingCore,
    IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
    IN  CDVRSourcePinManager *  pOwningPinBank,
    OUT HRESULT *               phr
    ) : CBaseOutputPin          (NAME ("CDVROutputPin"),
                                 pOwningFilter,
                                 pFilterLock,
                                 phr,
                                 pszPinName
                                 ),
        CDVRPin                 (pFilterLock,
                                 pPolicy
                                 ),
        m_pOutputQueue          (NULL),
        m_IMediaSeeking         (this,
                                 pSeekingCore
                                 ),
        m_fTimestampedMedia     (FALSE),
        m_DVRSegOutputPinState  (STATE_WAIT_NEW_SEGMENT),
        m_pSeekingCore          (pSeekingCore),
        m_pOwningPinBank        (pOwningPinBank),
        m_fIsPlayrateCompatible (TRUE),
        m_pTranslator           (NULL),
        m_fMediaCompatible      (TRUE),
        m_rtNewRateStart        (0),
        m_PTSRate               (::SecondsToDShowTime (5))
{
    TRACE_CONSTRUCTOR (TEXT ("CDVROutputPin")) ;

    ASSERT (m_pSeekingCore) ;
    ASSERT (m_pPolicy) ;
    ASSERT (m_pOwningPinBank) ;
    ASSERT (pDVRSendStatsWriter) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    m_cbBuffer  = (long) m_pPolicy -> Settings () -> AllocatorGetBufferSize () ;
    m_cBuffers  = (long) m_pPolicy -> Settings () -> AllocatorGetBufferCount () ;
    m_cbAlign   = (long) m_pPolicy -> Settings () -> AllocatorGetAlignVal () ;
    m_cbPrefix  = (long) m_pPolicy -> Settings () -> AllocatorGetPrefixVal () ;

    if (m_cbBuffer  <= 0 ||     //  buffer size
        m_cBuffers  <= 0 ||     //  number of buffers in pool
        m_cbAlign   <= 0 ||     //  alignment must be >= 1
        m_cbPrefix  < 0) {      //  prefix

        (* phr) = E_INVALIDARG ;
        goto cleanup ;
    }

    (* phr) = S_OK ;

    cleanup :

    return ;
}

CDVROutputPin::~CDVROutputPin (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVROutputPin")) ;
    delete m_pTranslator ;
}

STDMETHODIMP
CDVROutputPin::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IMemAllocator) {

        return GetInterface (
                    (IMemAllocator *) this,
                    ppv
                    ) ;
    }
    /*
    else if (riid == IID_IMediaSeeking &&
             m_pPolicy -> Settings () -> ImplementIMediaSeekingOnPin ()) {

        return GetInterface (
                    (IMediaSeeking *) & m_IMediaSeeking,
                    ppv
                    ) ;
    }
    */
    else if (riid == IID_IAMPushSource              &&
             m_pOwningPinBank -> IsLiveSource ()    &&
             m_pPolicy -> Settings () -> CanImplementIReferenceClock ()) {

        return GetInterface (
                    (IAMPushSource *) this,
                    ppv
                    ) ;
    }

    return CBaseOutputPin::NonDelegatingQueryInterface (riid, ppv) ;
}

HRESULT
CDVROutputPin::DecideAllocator (
    IN  IMemInputPin *      pPin,
    IN  IMemAllocator **    ppAlloc
    )
{
    HRESULT                 hr ;
    ALLOCATOR_PROPERTIES    AllocProp ;

    ASSERT (pPin) ;
    ASSERT (ppAlloc) ;

    (* ppAlloc) = this ;
    (* ppAlloc) -> AddRef () ;

    ZeroMemory (& AllocProp, sizeof AllocProp) ;

    //  ignore return value, as base class does
    pPin -> GetAllocatorRequirements (& AllocProp) ;

    hr = DecideBufferSize ((* ppAlloc), & AllocProp) ;
    if (SUCCEEDED (hr)) {
        hr = pPin -> NotifyAllocator ((* ppAlloc), TRUE) ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::DecideBufferSize (
    IN  IMemAllocator *         pAlloc,
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    ALLOCATOR_PROPERTIES    propActual = {0} ;

    TRACE_ENTER_0 (TEXT ("CDVROutputPin::DecideBufferSize ()")) ;

    ppropInputRequest -> cbBuffer   = Max <long> (m_cbBuffer, ppropInputRequest -> cbBuffer) ;
    ppropInputRequest -> cBuffers   = Max <long> (m_cBuffers, ppropInputRequest -> cBuffers) ;
    ppropInputRequest -> cbAlign    = m_cbAlign ;
    ppropInputRequest -> cbPrefix   = m_cbPrefix ;

    return pAlloc -> SetProperties (ppropInputRequest, & propActual) ;
}

HRESULT
CDVROutputPin::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    if (iPosition == 0) {
        hr = GetPinMediaType (pmt) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVROutputPin::CheckMediaType ()")) ;

    LockFilter_ () ;

    hr = ((* GetMediaType_ ()) == (* pmt) ? S_OK : S_FALSE) ;

    UnlockFilter_ () ;

    return hr ;
}

BOOL
CDVROutputPin::FirstSegmentSampleOk_ (
    IN OUT  IMediaSample2 * pIMS2
    )
{
    BOOL            r ;
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    if (m_fTimestampedMedia) {
        hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
        if (SUCCEEDED (hr)) {
            //  we're resuming play - make sure we don't start until we're
            //    into the new rate boundary
            r = (rtStart >= m_rtNewRateStart ? TRUE : FALSE) ;
        }
        else {
            r = FALSE ;
        }
    }
    else {
        //  non-timestamped media; anything is fine to start a segment
        r = TRUE ;
    }

    return r ;
}

BOOL
CDVROutputPin::QueryAcceptDynamicChange (
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT         hr ;
    BOOL            r ;

    //  first make sure this is just a format block change
    if (pmtNew -> majortype == GetMediaType_ () -> majortype &&
        pmtNew -> subtype == GetMediaType_ () -> subtype) {

        TRACE_1 (LOG_AREA_DSHOW, 1,
            TEXT ("CDVROutputPin::QueryAcceptDynamicChange () called; pin [%d] checking media type"),
            GetBankStoreIndex ()) ;

        LockFilter_ () ;

        if (IsConnected ()) {
            r = (GetConnected () -> QueryAccept (pmtNew) == S_OK ? TRUE : FALSE) ;
        }
        else {
            r = TRUE ;
        }

        if (r) {

            TRACE_1 (LOG_AREA_DSHOW, 1,
                TEXT ("CDVROutputPin::QueryAcceptDynamicChange (); pin [%d] new media acceptable; calling SetPinMediaType()"),
                GetBankStoreIndex ()) ;

            hr = SetPinMediaType (pmtNew) ;
            r = SUCCEEDED (hr) ;
        }

        UnlockFilter_ () ;
    }
    else {
        //  more than just a format block change; don't even check; there are
        //    too many issues to count
        r = FALSE ;

        TRACE_1 (LOG_AREA_DSHOW, 1,
            TEXT ("CDVROutputPin::QueryAcceptDynamicChange (); pin [%d] failing because it's not just a format block change"),
            GetBankStoreIndex ()) ;
    }

    return r ;
}

HRESULT
CDVROutputPin::SendSample (
    IN  IMediaSample2 * pIMS2,
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT hr ;

    ASSERT (pIMS2) ;

    if (IsPlayrateCompatible ()) {

        hr = S_OK ;

        LockFilter_ () ;

        ASSERT (m_pOutputQueue) ;
        ASSERT (IsConnected ()) ;
        ASSERT (IsMediaCompatible ()) ;

        //  we're a small state machine - either at the start of a new segment
        //    (STATE_WAIT_NEW_SEGMENT) or sending away inside a segment (STATE_SEG_IN_
        //    SEGMENT); if we're just starting a new segment, there are some
        //    actions we must take
        switch (m_DVRSegOutputPinState) {

            case STATE_WAIT_NEW_SEGMENT :

                //  if we cannot try to set a new segment, reject
                if (!FirstSegmentSampleOk_ (pIMS2)) {

                    TRACE_2 (LOG_AREA_DSHOW, 2,
                        TEXT ("CDVROutputPin::SendSample (); pin [%d] sample rejected -- not suitable as new segment (disc: %d)"),
                        GetBankStoreIndex (), pIMS2 -> IsDiscontinuity () == S_OK) ;

                    //  sample rejected
                    hr = VFW_E_SAMPLE_REJECTED ;
                    break ;
                }

                #ifdef DEBUG
                REFERENCE_TIME  rtStart, rtStop ;
                if (FAILED (pIMS2 -> GetTime (& rtStart, & rtStop))) {
                    rtStart = rtStop = -1 ;
                }

                TRACE_3 (LOG_AREA_DSHOW, 2,
                    TEXT ("CDVROutputPin::SendSample (); pin [%d] sample suitable as first sample in segment (start = %I64d ms, stop = %I64d ms)"),
                    GetBankStoreIndex (), ::DShowTimeToMilliseconds (rtStart), ::DShowTimeToMilliseconds (rtStop)) ;
                #endif

                //  new segment has been sent; fall through; state is
                //   updated lower

            case STATE_IN_SEGMENT :

                if (m_fFlagDiscontinuityNext) {
                    pIMS2 -> SetDiscontinuity (TRUE) ;

                    TRACE_1 (LOG_AREA_DSHOW, 2,
                        TEXT ("CDVROutputPin::SendSample (); pin [%d]; explicitely toggling discontinuity ON"),
                        GetBankStoreIndex (), ) ;
                }

                //  adjust these for rate changes
                ScaleTimestamps_ (pIMS2) ;

                //
                //  COutputQueue Release's the media sample's refcount after this
                //  call completes, so we make sure that we keep 1 count across the
                //  call
                //
                pIMS2 -> AddRef () ;

#ifdef EHOME_WMI_INSTRUMENTATION
                PERFLOG_STREAMTRACE( 1, PERFINFO_STREAMTRACE_SBE_DVROUTPUTPIN_RECEIVE,
                    0, 0, 0, 0, 0 );
#endif
                hr = m_pOutputQueue -> Receive (pIMS2) ;

                if (hr != S_OK) {
                    TRACE_ERROR_1 (TEXT ("CDVROutputPin::SendSample () : m_pOutputQueue -> Receive (pIMS2) returned %08xh"), hr) ;
                }

                //  COutputQueue does not return FAILED HRESULTs in the case of a failure
                hr = (hr == S_OK ? S_OK : E_FAIL) ;

                //  if we sent successfully and we were waiting, we are
                //    on our way
                if (SUCCEEDED (hr)) {
                    //  turn this off
                    m_fFlagDiscontinuityNext = FALSE ;

                    if (m_DVRSegOutputPinState == STATE_WAIT_NEW_SEGMENT) {
                        m_DVRSegOutputPinState = STATE_IN_SEGMENT ;
                    }

                    #ifdef DEBUG
                    REFERENCE_TIME  rtStart1, rtStop1 ;
                    if (FAILED (pIMS2 -> GetTime (& rtStart1, & rtStop1))) {
                        rtStart1 = rtStop1 = -1 ;
                    }

                    TRACE_4 (LOG_AREA_TIME, 7,
                        TEXT ("CDVROutputPin::SendSample (); pin [%d] sent (start = %I64d ms, stop = %I64d ms, %d)"),
                        GetBankStoreIndex (), ::DShowTimeToMilliseconds (rtStart1), ::DShowTimeToMilliseconds (rtStop1), pIMS2 -> IsDiscontinuity () == S_OK) ;
                    #endif

                    TRACE_1 (LOG_AREA_DSHOW, 8,
                        TEXT ("CDVROutputPin::SendSample (); pin [%d] sample sent; STATE_IN_SEGMENT"),
                        GetBankStoreIndex ()) ;
                }

                break ;
        }

        UnlockFilter_ () ;
    }
    else {
        //  drop the sample silently
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::Active (
    )
{
    HRESULT hr ;

    m_PTSRate.Clear () ;

    if (!IsConnected ()) {
        return S_OK ;
    }

    hr = CBaseOutputPin::Active () ;
    if (SUCCEEDED (hr)) {
        ASSERT (IsConnected ()) ;

        TRACE_2 (LOG_TRACE, 1, TEXT ("CDVROutputPin::Active(); this=%p; m_pOutputQueue=%p"), this, m_pOutputQueue) ;

        if (!m_pOutputQueue) {
            m_pOutputQueue = new COutputQueue (
                                    GetConnected (),        //  input pin
                                    & hr,                   //  retval
                                    FALSE,                  //  auto detect
                                    TRUE,                   //  send directly
                                    1,                      //  batch size
                                    FALSE,                  //  exact batch
                                    1                       //  queue length
                                    ) ;
        }

        if (m_pOutputQueue &&
            SUCCEEDED (hr)) {

            //  first always goes out as discontinuity
            FlagDiscontinuityNext (TRUE) ;
        }
        else {
            hr = (m_pOutputQueue ? hr : E_OUTOFMEMORY) ;
            DELETE_RESET (m_pOutputQueue) ;
        }
    }

    return hr ;
}

HRESULT
CDVROutputPin::Inactive (
    )
{
    HRESULT hr ;

    TRACE_1 (LOG_TRACE, 1, TEXT ("CDVROutputPin::Inactive(); this=%p"), this) ;

    if (!IsConnected ()) {
        return S_OK ;
    }

    if (SupportTrickMode ()) {
        SetCurRate (_1X_PLAYBACK_RATE, 0) ;
    }

    hr = CBaseOutputPin::Inactive () ;
    if (SUCCEEDED (hr)) {
        DELETE_RESET (m_pOutputQueue) ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::SetPinMediaType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    hr = CDVRPin::SetPinMediaType (pmt) ;
    if (SUCCEEDED (hr)) {
        DELETE_RESET (m_pTranslator) ;
        m_pTranslator = DShowWMSDKHelpers::GetWMSDKToDShowTranslator (
                            pmt,
                            m_pPolicy,
                            GetBankStoreIndex ()
                            ) ;
        ASSERT (m_pTranslator) ;

        m_fTimestampedMedia = AMMediaIsTimestamped (pmt) ;
    }

    return hr ;
}

STDMETHODIMP
CDVROutputPin::SetProperties (
    IN  ALLOCATOR_PROPERTIES *  pRequest,
    OUT ALLOCATOR_PROPERTIES *  pActual
    )
{
    if (!pActual) {
        return E_POINTER ;
    }

    //  ignore the request

    pActual -> cbBuffer   = m_cbBuffer ;
    pActual -> cBuffers   = m_cBuffers ;
    pActual -> cbAlign    = m_cbAlign ;
    pActual -> cbPrefix   = m_cbPrefix ;

    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::GetProperties (
    OUT ALLOCATOR_PROPERTIES *  pProps
    )
{
    if (!pProps) {
        return E_POINTER ;
    }

    pProps -> cbBuffer   = m_cbBuffer ;
    pProps -> cBuffers   = m_cBuffers ;
    pProps -> cbAlign    = m_cbAlign ;
    pProps -> cbPrefix   = m_cbPrefix ;

    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::Commit (
    )
{
    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::Decommit (
    )
{
    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::GetBuffer (
    OUT IMediaSample **     ppBuffer,
    IN  REFERENCE_TIME *    pStartTime,
    IN  REFERENCE_TIME *    pEndTime,
    IN  DWORD               dwFlags
    )
{
    HRESULT hr ;

    if (!ppBuffer) {
        return E_POINTER ;
    }

    //  low frequency code path -- should it turn out not to be, we should
    //   cache cache the scracth media samples, but for now we don't track
    //   them, just allocate, pass out, and forget.

    (* ppBuffer) = new CScratchMediaSample (
                        m_cbBuffer,
                        pStartTime,
                        pEndTime,
                        dwFlags,
                        & hr
                        ) ;

    if (!(* ppBuffer) ||
        FAILED (hr)) {

        hr = ((* ppBuffer) ? hr : E_OUTOFMEMORY) ;
        DELETE_RESET (* ppBuffer) ;
    }

    return hr ;
}

STDMETHODIMP
CDVROutputPin::ReleaseBuffer (
    IN  IMediaSample *  pBuffer
    )
{
    if (!pBuffer) {
        return E_POINTER ;
    }

    pBuffer -> Release () ;

    return S_OK ;
}

HRESULT
CDVROutputPin::DeliverEndOfStream (
    )
{
    HRESULT hr ;

    LockFilter_ () ;

    TRACE_2 (LOG_TRACE, 1, TEXT ("CDVROutputPin::DeliverEndOfStream (); this=%p; m_pOutputQueue=%p"),
        this, m_pOutputQueue
        ) ;

    if (m_pOutputQueue) {

        ASSERT (IsConnected ()) ;
        m_pOutputQueue -> EOS () ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_NOT_CONNECTED ;
    }

    UnlockFilter_ () ;

    return hr ;
}

HRESULT
CDVROutputPin::DeliverBeginFlush (
    )
{
    HRESULT hr ;

    LockFilter_ () ;

    TRACE_2 (LOG_TRACE, 1, TEXT ("CDVROutputPin::DeliverBeginFlush (); this=%p; m_pOutputQueue=%p"),
        this, m_pOutputQueue
        ) ;

    if (m_pOutputQueue) {

        ASSERT (IsConnected ()) ;
        m_pOutputQueue -> BeginFlush () ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_NOT_CONNECTED ;
    }

    UnlockFilter_ () ;

    return hr ;
}

HRESULT
CDVROutputPin::DeliverEndFlush (
    )
{
    HRESULT hr ;

    LockFilter_ () ;

    TRACE_2 (LOG_TRACE, 1, TEXT ("CDVROutputPin::DeliverEndFlush (); this=%p; m_pOutputQueue=%p"),
        this, m_pOutputQueue
        ) ;

    if (m_pOutputQueue) {

        ASSERT (IsConnected ()) ;
        m_pOutputQueue -> EndFlush () ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_NOT_CONNECTED ;
    }

    UnlockFilter_ () ;

    return hr ;
}

void
CDVROutputPin::ScaleTimestamps_ (
    IN OUT  IMediaSample2 * pIMS2
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    DWORD           dw ;

    ASSERT (pIMS2) ;
    hr = pIMS2 -> GetTime (
            & rtStart,
            & rtStop
            ) ;
    if (SUCCEEDED (hr)) {

        TRACE_3 (LOG_AREA_TIME, 8,
            TEXT ("scaling PTS (%08xh): ,%I64d,%d,"),
            this, rtStart, DShowTimeToMilliseconds (rtStart)) ;

        //  scale start/stop
        dw = m_PTSRate.ScalePTS (& rtStart) ;
        if (dw == NOERROR &&
            hr == S_OK) {
            //  valid stop value; scale it as well
            dw = m_PTSRate.ScalePTS (& rtStop) ;
        }

        //  if the value(s) were scaled properly
        if (dw == NOERROR) {
            //  set
            pIMS2 -> SetTime (
                & rtStart,
                (hr == S_OK ? & rtStop : NULL)
                ) ;
        }

        TRACE_3 (LOG_AREA_TIME, 8,
            TEXT ("scaled PTS (%08xh): ,,,%I64d,%d,"),
            this, rtStart, DShowTimeToMilliseconds (rtStart)) ;
    }
}

HRESULT
CDVROutputPin::SetCurRate (
    IN  double          dRate,
    IN  REFERENCE_TIME  rtNewRateStart
    )
{
    HRESULT hr ;
    DWORD   dw ;

    ASSERT (dRate != 0) ;

    if (m_pPolicy -> Settings () -> AllNotifiedRatesPositive ()) {
        dRate = (dRate > 0 ? dRate : 0 - dRate) ;
    }

    dw = m_PTSRate.NewSegment (rtNewRateStart, ::CompatibleRateValue (dRate)) ;

    hr = HRESULT_FROM_WIN32 (dw) ;
    if (SUCCEEDED (hr)) {
        //  log the start
        m_rtNewRateStart = rtNewRateStart ;

        //  toggle ourselves if we're going to be rate-compatible; if we're not
        //    we'll drop everything without sending
        SetPlayrateCompatible (IsFrameRateSupported (dRate)) ;
    }

    TRACE_5 (LOG_AREA_SEEKING_AND_TRICK, 1,
        TEXT ("queued new rate segment: [%p] %I64d (%I64d ms), %2.1f; hr = %08xh"),
        this, rtNewRateStart, DShowTimeToMilliseconds (rtNewRateStart), dRate, hr) ;

    return hr ;
}

HRESULT
CDVROutputPin::NotifyNewSegment (
    IN  REFERENCE_TIME  rtStart,
    IN  REFERENCE_TIME  rtStop,
    IN  double          dRate
    )
{
    LockFilter_ () ;

    if (m_pOutputQueue) {

        TRACE_4 (LOG_AREA_DSHOW, 2,
            TEXT ("CDVROutputPin::NotifyNewSegment (); [%d] %I64d, %I64d, %2.1f"),
            GetBankStoreIndex (), rtStart, rtStop, dRate) ;

        m_pOutputQueue -> NewSegment (
            rtStart,
            rtStop,
            dRate
            ) ;

        SetNewSegmentBoundary () ;

        //  new segment -- timestamps will start off from 0
        m_rtNewRateStart = 0 ;
    }

    UnlockFilter_ () ;

    return S_OK ;
}

void
CDVROutputPin::SendAllQueued (
    )
{
    LockFilter_ () ;

    if (m_pOutputQueue) {
        m_pOutputQueue -> SendAnyway () ;
    }

    UnlockFilter_ () ;
}

void
CDVROutputPin::SetNewSegmentBoundary (
    )
{
    TRACE_1 (LOG_AREA_DSHOW, 2,
        TEXT ("CDVROutputPin::SetNewSegmentBoundary ()"),
        GetBankStoreIndex ()) ;

    //  safe because the reader thread should never be active on this call, or
    //   the reader thread is the one making the call
    m_DVRSegOutputPinState = STATE_WAIT_NEW_SEGMENT ;

    //  segments start on discontinuities
    FlagDiscontinuityNext (TRUE) ;
}

BOOL
CDVROutputPin::IsKeyFrameStart (
    IN  INSSBuffer *    pINSSBuffer
    )
{
    HRESULT                     hr ;
    INSSBuffer3 *               pINSSBuffer3 ;
    BOOL                        r ;
    DWORD                       dwSize ;
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttrib ;

    hr = pINSSBuffer -> QueryInterface (IID_INSSBuffer3, (void **) & pINSSBuffer3) ;
    if (SUCCEEDED (hr)) {
        if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, INSSBuffer3Prop_SBE_Attributes)) {

            dwSize = sizeof SBEAttrib ;
            hr = DVRAttributeHelpers::GetAttribute (
                    pINSSBuffer3,
                    INSSBuffer3Prop_SBE_Attributes,
                    & dwSize,
                    (BYTE *) & SBEAttrib
                    ) ;
            if (SUCCEEDED (hr)) {
                r = (SBEAttrib.rtStart != -1 ? TRUE : FALSE) ;
            }
            else {
                r = FALSE ;
            }
        }
        else {
            r = FALSE ;
        }

        pINSSBuffer3 -> Release () ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

void
CDVROutputPin::SetPlayrateCompatible (
    IN BOOL f
    )
{
    if (m_fIsPlayrateCompatible &&
        !f) {
        //  we are being toggled ON => OFF;
        //    flush downstream
        DeliverBeginFlush () ;
        DeliverEndFlush () ;

        TRACE_2 (LOG_AREA_SEEKING_AND_TRICK, 1,
            TEXT ("CDVROutputPin::SetPlayrateCompatible (%d); pin [%d] ON => OFF; flushed"),
            f, GetBankStoreIndex ()) ;
    }
    else if (!m_fIsPlayrateCompatible &&
             f) {
        //  we are being toggled OFF => ON;
        //    make sure we start on a good boundary
        SetNewSegmentBoundary () ;

        TRACE_2 (LOG_AREA_SEEKING_AND_TRICK, 1,
            TEXT ("CDVROutputPin::SetPlayrateCompatible (%d); pin [%d] OFF ==> ON; SetNewSegmentBoundary"),
            f, GetBankStoreIndex ()) ;
    }

    m_fIsPlayrateCompatible = f ;
}

void
CDVROutputPin::OnPTSPaddingIncrement (
    )
{
    if (::IsAudio (GetMediaType_ ())) {
        //  av sync is better if an artifially padded audio sample is explicitely
        //    marked as a discontinuity
        m_fFlagDiscontinuityNext = TRUE ;
    }
}

//  ============================================================================
//  ============================================================================

BOOL
CDVRVideoOutputPin::IsFullFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL    r ;

    //  BUGBUG: look at the media type bitrate
    //

    if (dRate > 0 &&
        dRate <= m_pPolicy -> Settings () -> MaxFullFrameRate ()) {

        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
CDVRVideoOutputPin::IsFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL    r ;

    r = IsFullFrameRateSupported (dRate) ;
    if (!r) {

        if (dRate > 0 &&
            dRate <= m_pPolicy -> Settings () -> MaxKeyFrameForwardRate ()) {

            r = TRUE ;
        }

        //  nothing else is supported; r is already FALSE
    }

    return r ;
}

//  ============================================================================
//  ============================================================================

double
CDVDRateChange::MaxForwardFullFrameRate (
    IN  IMemInputPin *  pInputPin
    )
{
    AM_MaxFullDataRate  RateValue ;
    HRESULT             hr ;
    DWORD               dw ;

    ASSERT (pInputPin) ;

    if (!m_fMaxForwardRateQueried) {
        hr = ::KSPropertyGet_ (
                pInputPin,
                & AM_KSPROPSETID_TSRateChange,
                AM_RATE_MaxFullDataRate,
                (BYTE *) & RateValue,
                sizeof RateValue,
                & dw
                ) ;
        if (SUCCEEDED (hr) &&
            dw == sizeof RateValue) {

            m_dMaxForwardRate = ((double) RateValue) / 10000.0 ;
        }
        else {
            //  fallback to default
            m_dMaxForwardRate = _1X_PLAYBACK_RATE ;
        }

        //  regardless of success or failure, no need to query again
        m_fMaxForwardRateQueried = TRUE ;
    }

    return m_dMaxForwardRate ;
}

double
CDVDRateChange::MaxReverseFullFrameRate (
    IN  IMemInputPin *  pInputPin
    )
{
    AM_MaxFullDataRate  RateValue ;
    LONG                lCanReverse ;
    HRESULT             hr ;
    DWORD               dw ;

    ASSERT (pInputPin) ;

    if (!m_fMaxReverseRateQueried) {
#if 1
        //  cannot do full-frame reverse mode at all - must be all I-frames
        m_dMaxReverseRate = 0 ;
#else
        //  v2 rate change is dead
        hr = ::KSPropertyGet_ (
                pInputPin,
                & AM_KSPROPSETID_DVD_RateChange,
                AM_RATE_ReverseDecode,
                (BYTE *) & lCanReverse,
                sizeof lCanReverse,
                & dw
                ) ;
        if (SUCCEEDED (hr)              &&
            dw == sizeof lCanReverse    &&
            lCanReverse) {

            m_dMaxReverseRate = 0 - MaxForwardFullFrameRate () ;
        }
        else {
            //  failed to obtain a reverse mode reading; if forward full-frame
            //   is > 1, then most likely the decoder will handle frame-rates
            //   that are < 1, so we bound it at forward, but slow
            if (MaxForwardFullFrameRate () > _1X_PLAYBACK_RATE) {
                m_dMaxReverseRate = 0 ;
            }
            else {
                m_dMaxReverseRate = _1X_PLAYBACK_RATE ;
            }
        }
#endif

        m_fMaxReverseRateQueried = TRUE ;
    }

    return m_dMaxReverseRate ;
}

HRESULT
CDVDRateChange::NotifyMpeg2DecoderNewRate (
    IN  IMemInputPin *  pInputPin,
    IN  double          dNewRate,
    IN  REFERENCE_TIME  rtStartNewRate
    )
{
    AM_SimpleRateChange RateChange ;
    HRESULT             hr ;

    ASSERT (pInputPin) ;

    RateChange.Rate         = (LONG) (10000.0 / dNewRate) ;
    RateChange.StartTime    = rtStartNewRate ;

    hr = ::KSPropertySet_ (
            pInputPin,
            & AM_KSPROPSETID_TSRateChange,
            AM_RATE_SimpleRateChange,
            (BYTE *) & RateChange,
            sizeof RateChange
            ) ;

    TRACE_5 (LOG_AREA_SEEKING_AND_TRICK, 1,
        TEXT ("new rate set downstream; rate = %2.2f; RateChange.Rate = %d; rtStart = %I64d (%d ms); hr = %08xh)"),
        dNewRate, RateChange.Rate, rtStartNewRate, DShowTimeToMilliseconds (rtStartNewRate), hr) ;

    if (FAILED (hr)) {
        //  set well-known error
        hr = VFW_E_DVD_WRONG_SPEED ;
    }

    return hr ;
}

BOOL
CDVDRateChange::PinSupportsRateChange (
    IN  IMemInputPin *  pInputPin,
    IN  BOOL            fCheckVersion
    )
{
    AM_MaxFullDataRate  RateValue ;
    HRESULT             hr ;
    DWORD               dw ;
    BOOL                r ;
    WORD                wVersion ;

    if (!m_fTrickSupportQueried) {
        ASSERT (pInputPin) ;

        if (fCheckVersion) {
            wVersion = (WORD) COMPATIBLE_TRICK_MODE_VERSION ;
            hr = ::KSPropertySet_ (
                    pInputPin,
                    & AM_KSPROPSETID_TSRateChange,
                    AM_RATE_UseRateVersion,
                    (BYTE *) & wVersion,
                    sizeof wVersion
                    ) ;

            r = (SUCCEEDED (hr) ? TRUE : FALSE) ;
        }
        else {
            //  bypass this check
            r = TRUE ;
        }

        //  make 1 more check
        if (r) {
            //  we detect the old-fashioned way
            hr = ::KSPropertyGet_ (
                    pInputPin,
                    & AM_KSPROPSETID_TSRateChange,
                    AM_RATE_MaxFullDataRate,
                    (BYTE *) & RateValue,
                    sizeof RateValue,
                    & dw
                    ) ;

            r = (SUCCEEDED (hr) && dw == sizeof RateValue ? TRUE : FALSE) ;
        }

        m_fTrickSupportQueried = TRUE ;
        m_fTrickSupport = r ;
    }
    else {
        r = m_fTrickSupport ;
    }

    return r ;
}

//  ============================================================================
//  ============================================================================

void
CDVRMpeg2AudioOutputPin::ScaleTimestamps_ (
    IN OUT  IMediaSample2 * pIMS2
    )
{
#ifdef DEBUG
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    HRESULT         hr ;

    hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
    if (SUCCEEDED (hr)) {
        //  start is valid at least

        TRACE_3 (LOG_AREA_TIME, 8,
            TEXT ("PTS (%08xh): %I64d,%d,"),
            this, rtStart, DShowTimeToMilliseconds (rtStart)) ;
    }
#endif

    return ;
}

HRESULT
CDVRMpeg2AudioOutputPin::Active (
    )
{
    HRESULT hr ;

    hr = CDVROutputPin::Active () ;

    return hr ;
}

BOOL
CDVRMpeg2AudioOutputPin::IsFrameRateSupported (
    IN  double  dRate
    )
{
    return IsFullFrameRateSupported (dRate) ;
}

BOOL
CDVRMpeg2AudioOutputPin::IsFullFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL    r ;

    ASSERT (PinSupportsRateChange (m_pInputPin, m_pPolicy -> Settings () -> CheckTricMpeg2TrickModeInterface ())) ;

    //  make sure we're connected & ready to send
    if (IsConnected ()) {

        //  if the policy says we should always query, do so and base the
        //    result on the query
        if (m_pPolicy -> Settings () -> QueryAllForRateCompatibility () &&
            dRate != 0                                              &&
            dRate <= MaxForwardFullFrameRate (m_pInputPin)) {

            r = TRUE ;
        }
        //  otherwise, accept just 1x
        else if (dRate == 1.0) {
            r = TRUE ;
        }
        //  and nothing else
        else {
            r = FALSE ;
        }
    }
    else {
        r = FALSE ;
    }

    return r ;
}

HRESULT
CDVRMpeg2AudioOutputPin::SetCurRate (
    IN double           dRate,
    IN REFERENCE_TIME   rtNewRateStart
    )
{
    HRESULT hr ;

    if (m_pPolicy -> Settings () -> AllNotifiedRatesPositive ()) {
        dRate = (dRate > 0 ? dRate : 0 - dRate) ;
    }

    hr = NotifyMpeg2DecoderNewRate (m_pInputPin, dRate, rtNewRateStart) ;
    if (SUCCEEDED (hr)) {
        m_rtNewRateStart = rtNewRateStart ;

        //  toggle ourselves if we're going to be rate-compatible; if we're not
        //    we'll drop everything without sending
        SetPlayrateCompatible (IsFrameRateSupported (dRate)) ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

void
CDVRDolbyAC3AudioOutputPin::ScaleTimestamps_ (
    IN OUT  IMediaSample2 * pIMS2
    )
{
#ifdef DEBUG
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    HRESULT         hr ;

    hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
    if (SUCCEEDED (hr)) {
        //  start is valid at least

        TRACE_3 (LOG_AREA_TIME, 8,
            TEXT ("ac-3 audio: PTS = %I64d (%I64d ms); discontinuity = %d"),
                   rtStart, DShowTimeToMilliseconds (rtStart), pIMS2 -> IsDiscontinuity () == S_OK ? 1 : 0) ;
    }
#elif FREE_BITS_TRACING
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    HRESULT         hr ;

    hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
    if (SUCCEEDED (hr)) {
        //  start is valid at least

        DVRDebugOut_ (TEXT ("TSDVR ac-3 audio: PTS = %I64d (%I64d ms); discontinuity = %d"),
                      rtStart, DShowTimeToMilliseconds (rtStart), pIMS2 -> IsDiscontinuity () == S_OK ? 1 : 0) ;
    }
#endif

    return ;
}

HRESULT
CDVRDolbyAC3AudioOutputPin::Active (
    )
{
    HRESULT hr ;

    hr = CDVROutputPin::Active () ;

    return hr ;
}

BOOL
CDVRDolbyAC3AudioOutputPin::IsFrameRateSupported (
    IN  double  dRate
    )
{
    return IsFullFrameRateSupported (dRate) ;
}

BOOL
CDVRDolbyAC3AudioOutputPin::IsFullFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL    r ;

    ASSERT (PinSupportsRateChange (m_pInputPin, m_pPolicy -> Settings () -> CheckTricMpeg2TrickModeInterface ())) ;

    //  make sure we're connected & ready to send
    if (IsConnected ()) {

        //  if the policy says we should always query, do so and base the
        //    result on the query
        if (m_pPolicy -> Settings () -> QueryAllForRateCompatibility () &&
            dRate != 0                                              &&
            dRate <= MaxForwardFullFrameRate (m_pInputPin)) {

            r = TRUE ;
        }
        //  otherwise, accept just 1x
        else if (dRate == 1.0) {
            r = TRUE ;
        }
        //  and nothing else
        else {
            r = FALSE ;
        }
    }
    else {
        r = FALSE ;
    }

    return r ;
}

HRESULT
CDVRDolbyAC3AudioOutputPin::SetCurRate (
    IN double           dRate,
    IN REFERENCE_TIME   rtNewRateStart
    )
{
    HRESULT hr ;

    if (m_pPolicy -> Settings () -> AllNotifiedRatesPositive ()) {
        dRate = (dRate > 0 ? dRate : 0 - dRate) ;
    }

    hr = NotifyMpeg2DecoderNewRate (m_pInputPin, dRate, rtNewRateStart) ;
    if (SUCCEEDED (hr)) {
        m_rtNewRateStart = rtNewRateStart ;

        //  toggle ourselves if we're going to be rate-compatible; if we're not
        //    we'll drop everything without sending
        SetPlayrateCompatible (IsFrameRateSupported (dRate)) ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

void
CDVRMpeg2VideoOutputPin::ScaleTimestamps_ (
    IN OUT  IMediaSample2 * pIMS2
    )
{
#ifdef DEBUG
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    HRESULT         hr ;

    hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
    if (SUCCEEDED (hr)) {
        //  start is valid at least
        TRACE_3 (LOG_AREA_TIME, 8,
            TEXT ("mpeg-2 video: PTS = %I64d (%I64d ms); discontinuity = %d"),
                   rtStart, DShowTimeToMilliseconds (rtStart), pIMS2 -> IsDiscontinuity () == S_OK ? 1 : 0) ;
    }
#elif FREE_BITS_TRACING
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    HRESULT         hr ;

    hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
    if (SUCCEEDED (hr)) {
        //  start is valid at least

        DVRDebugOut_ (TEXT ("TSDVR mpeg-2 video: PTS = %I64d (%I64d ms); discontinuity = %d"),
                      rtStart, DShowTimeToMilliseconds (rtStart), pIMS2 -> IsDiscontinuity () == S_OK ? 1 : 0) ;
    }
#endif

    return ;
}

HRESULT
CDVRMpeg2VideoOutputPin::Active (
    )
{
    HRESULT hr ;

    hr = CDVRVideoOutputPin::Active () ;

    return hr ;
}

BOOL
CDVRMpeg2VideoOutputPin::IsFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL    r ;

    ASSERT (PinSupportsRateChange (m_pInputPin, m_pPolicy -> Settings () -> CheckTricMpeg2TrickModeInterface ())) ;

    if (IsConnected ()) {
        if (dRate > 0 && dRate <= m_pPolicy -> Settings () -> MaxForwardRate ()) {
            r = TRUE ;
        }
        else if (dRate < 0 && Abs <double> (dRate) <= m_pPolicy -> Settings () -> MaxReverseRate ()) {
            r = TRUE ;
        }
        else if (dRate == _1X_PLAYBACK_RATE) {
            r = TRUE ;
        }
        else {
            r = FALSE ;
        }
    }
    else {
        r = FALSE ;
    }

    return r ;
}

HRESULT
CDVRMpeg2VideoOutputPin::SetCurRate (
    IN double           dRate,
    IN REFERENCE_TIME   rtNewRateStart
    )
{
    HRESULT hr ;

    ASSERT (IsConnected ()) ;
    hr = NotifyMpeg2DecoderNewRate (
            m_pInputPin,
            dRate,
            rtNewRateStart
            ) ;
    if (SUCCEEDED (hr)) {
        m_rtNewRateStart = rtNewRateStart ;

        //  toggle ourselves if we're going to be rate-compatible; if we're not
        //    we'll drop everything without sending
        SetPlayrateCompatible (IsFrameRateSupported (dRate)) ;
    }

    return hr ;
}

BOOL
CDVRMpeg2VideoOutputPin::IsFullFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL    r ;

    ASSERT (PinSupportsRateChange (m_pInputPin, m_pPolicy -> Settings () -> CheckTricMpeg2TrickModeInterface ())) ;

    //  make sure we're connected & ready to send
    if (IsConnected ()) {

        if (dRate > 0 &&
            dRate <= MaxForwardFullFrameRate (m_pInputPin)) {

            //  and a bit more restrictive
            r = CDVRVideoOutputPin::IsFullFrameRateSupported (dRate) ;
        }
        else {
            //  no negative rates currently are supported fullframe
            r = FALSE ;
        }
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
CDVRMpeg2VideoOutputPin::GenerateTimestamps_ (
    IN OUT  IMediaSample2 * pIMS2
    )
{
    TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 2,
        TEXT ("pin [%d]: media sample has no timestamp -- need to generate one)"),
        GetBankStoreIndex ()) ;

    //  BUGBUG: implement
    ASSERT (0) ;
    return FALSE ;
}

BOOL
CDVRMpeg2VideoOutputPin::IsKeyFrameStart (
    IN  IMediaSample2 *     pIMS2
    )
{
    BOOL    r ;
    HRESULT hr ;
    DWORD   dwDVRMpeg2Analysis ;
    DWORD   dwSize ;

    //  mpeg-2 requires some frame analysis for frame boundaries; if there's no
    //    analysis present, we go back to 1x mode
    if (DVRAttributeHelpers::IsAnalysisPresent (pIMS2)) {

        if (DVRAttributeHelpers::IsAttributePresent (pIMS2, DVRAnalysis_Mpeg2Video)) {

            dwSize = sizeof dwDVRMpeg2Analysis ;
            hr = DVRAttributeHelpers::GetAttribute (
                    pIMS2,
                    DVRAnalysis_Mpeg2Video,
                    & dwSize,
                    (BYTE *) & dwDVRMpeg2Analysis
                    ) ;
            if (SUCCEEDED (hr)                                      &&
                DVR_ANALYSIS_MP2_IS_BOUNDARY (dwDVRMpeg2Analysis) &&
                DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwDVRMpeg2Analysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER) {

                r = TRUE ;
            }
            else {
                r = FALSE ;
            }

            TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 8,
                TEXT ("pin [%d] OBSERVED found %s frame, boundary = %d; %08xh"),
                GetBankStoreIndex (),
                (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwDVRMpeg2Analysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER ? TEXT ("I") :
                 (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwDVRMpeg2Analysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_B_FRAME ? TEXT ("B") :
                  TEXT ("P")
                 )
                ),
                DVR_ANALYSIS_MP2_IS_BOUNDARY (dwDVRMpeg2Analysis) ? 1 : 0,
                dwDVRMpeg2Analysis
                ) ;
        }
        else {
            r = FALSE ;
        }
    }
    else {
        TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 2,
            TEXT ("pin [%d]: hunting for an mpeg-2 GOP boundary and found there's no analysis in the stream)"),
            GetBankStoreIndex ()) ;

        //  there's no global analysis flag stuff, or there is specifically
        //    no analysis -- set the rate to 1x because we're dead in the
        //    water if we do trick mode playback with video stream
        //    analysis; if we try to grab the seeking lock in the process,
        //    we can deadlock: we wait on the seeking lock & a control
        //    thread with the seeking lock synchronously waits for us
        //    to pause
        m_pSeekingCore -> ReaderThreadSetPlaybackRate (_1X_PLAYBACK_RATE) ;

        //  then artificially set the flag iff we're timestamped
        r = CDVROutputPin::IsKeyFrameStart (pIMS2) ;
    }

    return r ;
}

BOOL
CDVRMpeg2VideoOutputPin::IsKeyFrame (
    IN  IMediaSample2 *     pIMS2
    )
{
    BOOL    r ;
    HRESULT hr ;
    DWORD   dwDVRMpeg2Analysis ;
    DWORD   dwSize ;

    //  mpeg-2 requires some frame analysis for frame boundaries; if there's no
    //    analysis present, we go back to 1x mode
    if (DVRAttributeHelpers::IsAnalysisPresent (pIMS2)) {

        if (DVRAttributeHelpers::IsAttributePresent (pIMS2, DVRAnalysis_Mpeg2Video)) {

            dwSize = sizeof dwDVRMpeg2Analysis ;
            hr = DVRAttributeHelpers::GetAttribute (
                    pIMS2,
                    DVRAnalysis_Mpeg2Video,
                    & dwSize,
                    (BYTE *) & dwDVRMpeg2Analysis
                    ) ;
            if (SUCCEEDED (hr) &&
                DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwDVRMpeg2Analysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER) {
                r = TRUE ;
            }
            else {
                r = FALSE ;
            }

            TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 8,
                TEXT ("pin [%d] OBSERVED found %s frame, boundary = %d; %08xh"),
                GetBankStoreIndex (),
                (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwDVRMpeg2Analysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER ? TEXT ("I") :
                 (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwDVRMpeg2Analysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_B_FRAME ? TEXT ("B") :
                  TEXT ("P")
                 )
                ),
                DVR_ANALYSIS_MP2_IS_BOUNDARY (dwDVRMpeg2Analysis) ? 1 : 0,
                dwDVRMpeg2Analysis
                ) ;
        }
        else {
            r = FALSE ;
        }
    }
    else {
        TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 2,
            TEXT ("pin [%d]: hunting for an mpeg-2 GOP boundary and found there's no analysis in the stream)"),
            GetBankStoreIndex ()) ;

        //  there's no global analysis flag stuff, or there is specifically
        //    no analysis -- set the rate to 1x because we're dead in the
        //    water if we do trick mode playback with video stream
        //    analysis; if we try to grab the seeking lock in the process,
        //    we can deadlock: we wait on the seeking lock & a control
        //    thread with the seeking lock synchronously waits for us
        //    to pause
        m_pSeekingCore -> ReaderThreadSetPlaybackRate (_1X_PLAYBACK_RATE) ;

        //  then artificially set the flag iff we're timestamped
        r = CDVROutputPin::IsKeyFrameStart (pIMS2) ;
    }

    return r ;
}

BOOL
CDVRMpeg2VideoOutputPin::IsKeyFrameStart (
    IN  INSSBuffer *    pINSSBuffer
    )
{
    BOOL    r ;
    HRESULT hr ;
    DWORD   dwDVRMpeg2Analysis ;
    DWORD   dwSize ;

    //  mpeg-2 requires some frame analysis for frame boundaries; if there's no
    //    analysis present, we go back to 1x mode
    if (DVRAttributeHelpers::IsAnalysisPresent (pINSSBuffer)) {

        if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer, DVRAnalysis_Mpeg2Video)) {

            dwSize = sizeof dwDVRMpeg2Analysis ;
            hr = DVRAttributeHelpers::GetAttribute (
                    pINSSBuffer,
                    DVRAnalysis_Mpeg2Video,
                    & dwSize,
                    (BYTE *) & dwDVRMpeg2Analysis
                    ) ;
            if (SUCCEEDED (hr)                                      &&
                DVR_ANALYSIS_MP2_IS_BOUNDARY (dwDVRMpeg2Analysis) &&
                DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwDVRMpeg2Analysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER) {

                r = TRUE ;

                TRACE_2 (LOG_AREA_SEEKING_AND_TRICK, 8,
                    TEXT ("pin [%d]: mpeg-2 GOP boundary found; %08xh"),
                    GetBankStoreIndex (), dwDVRMpeg2Analysis) ;
            }
            else {
                r = FALSE ;
            }
        }
        else {
            r = FALSE ;
        }
    }
    else {
        TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 2,
            TEXT ("pin [%d]: hunting for an mpeg-2 GOP boundary and found there's no analysis in the stream)"),
            GetBankStoreIndex ()) ;

        //  there's no global analysis flag stuff, or there is specifically
        //    no analysis -- set the rate to 1x because we're dead in the
        //    water if we do trick mode playback with video stream
        //    analysis; if we try to grab the seeking lock in the process,
        //    we can deadlock: we wait on the seeking lock & a control
        //    thread with the seeking lock synchronously waits for us
        //    to pause
        m_pSeekingCore -> ReaderThreadSetPlaybackRate (_1X_PLAYBACK_RATE) ;

        //  then artificially set the flag iff we're timestamped
        r = CDVROutputPin::IsKeyFrameStart (pINSSBuffer) ;
    }

    return r ;
}

BOOL
CDVRMpeg2VideoOutputPin::FirstSegmentSampleOk_ (
    IN OUT  IMediaSample2 * pIMS2
    )
{
    BOOL    r ;

    //  rate change need not happen on a GOP boundary !
    r = (pIMS2 -> IsSyncPoint () == S_OK ? TRUE : FALSE) ;

#ifdef DEBUG
    if (r) {
        REFERENCE_TIME  rtStart, rtStop ;
        HRESULT         hr ;

        hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
        ASSERT (SUCCEEDED (hr)) ;
    }
#endif

    return r ;
}

//  ============================================================================
//  ============================================================================

CDVRSinkPinManager::CDVRSinkPinManager (
    IN  CDVRPolicy *            pPolicy,
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pFilterLock,
    IN  CCritSec *              pRecvLock,
    IN  CIDVRDShowStream *      pIDVRDShowStream,
    OUT HRESULT *               phr
    ) : m_pIDVRDShowStream      (pIDVRDShowStream),
        m_pFilterLock           (pFilterLock),
        m_pOwningFilter         (pOwningFilter),
        m_cMaxInputPins         (MAX_PIN_BANK_SIZE),
        m_pRecvLock             (pRecvLock),
        m_pPolicy               (pPolicy),
        m_DVRWriterProfile      (pPolicy,
                                 DVR_STREAM_SINK_PROFILE_NAME,
                                 DVR_STREAM_SINK_PROFILE_DESCRIPTION,
                                 phr
                                 )
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSinkPinManager")) ;

    ASSERT (m_pRecvLock) ;
    ASSERT (m_pPolicy) ;

    m_pPolicy -> AddRef () ;

    CreateNextInputPin_ () ;
}

CDVRSinkPinManager::~CDVRSinkPinManager (
    )
{
    m_pPolicy -> Release () ;
}

HRESULT
CDVRSinkPinManager::CreateNextInputPin_ (
    )
{
    TCHAR           achBuffer [32] ;
    CDVRInputPin *  pInputPin ;
    HRESULT         hr ;
    int             iBankIndex ;

    TRACE_ENTER_0 (TEXT ("CDVRSinkPinManager::CreateNextInputPin_ ()")) ;

    //  init
    pInputPin = NULL ;

    FilterLock_ () ;

    if (m_cMaxInputPins > PinCount ()) {

        hr = S_OK ;

        //  create the pin; we're appending, so pin name will be based on the
        //   number of pins in the bank
        pInputPin = new CDVRInputPin (
                            CreateInputPinName (
                                PinCount () + 1,                        //  don't 0-base names
                                sizeof achBuffer / sizeof TCHAR,
                                & achBuffer [0]
                                ),
                            m_pOwningFilter,
                            this,                   //  events; we hook these always
                            m_pIDVRDShowStream,     //  stream events
                            m_pFilterLock,
                            m_pRecvLock,
                            m_pPolicy,
                            & hr
                            ) ;
        if (!pInputPin) {
            hr = E_OUTOFMEMORY ;
            goto cleanup ;
        }
        else if (FAILED (hr)) {
            goto cleanup ;
        }

        //  add it to the bank
        hr = AddPin (
                pInputPin,
                & iBankIndex
                ) ;
        if (FAILED (hr)) {
            goto cleanup ;
        }

        //  set the pin's bank index
        pInputPin -> SetBankStoreIndex (iBankIndex) ;

        m_pOwningFilter -> IncrementPinVersion () ;
    }
    else {
        hr = E_FAIL ;
    }

    cleanup :

    FilterUnlock_ () ;

    if (FAILED (hr)) {
        delete pInputPin ;
    }

    return hr ;
}

BOOL
CDVRSinkPinManager::DisconnectedPins_ (
    )
{
    BOOL            r ;
    int             i ;
    CDVRInputPin *  pPin ;

    r = FALSE ;
    for (i = 0, r = FALSE;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (!pPin -> IsConnected ()) {
                r = TRUE ;
                break ;
            }
        }
        else {
            break ;
        }
    }

    return r ;
}

HRESULT
CDVRSinkPinManager::OnInputCompleteConnect (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_1 (
        TEXT ("CDVRSinkPinManager::OnInputCompleteConnect (%d)"),
        iPinIndex
        ) ;

    //  make sure the stream can be added to the profile
    hr = m_DVRWriterProfile.AddStream (iPinIndex, pmt) ;
    if (SUCCEEDED (hr)) {
        if (!DisconnectedPins_ ()) {
            //  ignore the return value on this; creation of the next input pin
            //   should not affect completion of the previous pin's connection
            CreateNextInputPin_ () ;
        }
    }

    return hr ;
}

HRESULT
CDVRSinkPinManager::OnInputBreakConnect (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    hr = m_DVRWriterProfile.DeleteStream (iPinIndex) ;

    return hr ;
}

HRESULT
CDVRSinkPinManager::OnQueryAccept (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    return (m_pPolicy -> Settings () -> SucceedQueryAccept () ? S_OK : S_FALSE) ;
}

BOOL
CDVRSinkPinManager::InlineDShowProps_ (
    )
{
    return m_pPolicy -> Settings () -> InlineDShowProps () ;
}

HRESULT
CDVRSinkPinManager::Active (
    )
{
    HRESULT         hr ;
    int             i ;
    CDVRInputPin *  pPin ;
    BOOL            fInlineProps ;

    //  applies to all or none
    fInlineProps = InlineDShowProps_ () ;

    hr = S_OK ;
    for (i = 0;SUCCEEDED (hr);i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                hr = pPin -> Active (fInlineProps) ;
            }
        }
        else {
            break ;
        }
    }

    return hr ;
}

HRESULT
CDVRSinkPinManager::Inactive (
    )
{
    CDVRInputPin *  pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                pPin -> Inactive () ;
            }
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRThroughSinkPinManager::OnInputCompleteConnect (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_1 (
        TEXT ("CDVRThroughSinkPinManager::OnInputCompleteConnect (%d)"),
        iPinIndex
        ) ;

    //  make sure the stream can be added to the profile
    hr = m_DVRWriterProfile.AddStream (iPinIndex, pmt) ;
    if (SUCCEEDED (hr)) {

        ASSERT (m_pIDVRInputPinConnectEvents) ;
        hr = m_pIDVRInputPinConnectEvents -> OnInputCompleteConnect (iPinIndex, pmt) ;
        if (SUCCEEDED (hr)) {
            //  ignore the return value on this; creation of the next input pin
            //   should not affect completion of the previous pin's connection
            CreateNextInputPin_ () ;
        }
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRSourcePinManager::CDVRSourcePinManager (
    IN  CDVRPolicy *            pPolicy,
    IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pFilterLock,
    IN  CDVRDShowSeekingCore *  pSeekingCore,
    IN  BOOL                    fIsLiveSource
    ) : m_pOwningFilter         (pOwningFilter),
        m_pFilterLock           (pFilterLock),
        m_pWMReaderProfile      (NULL),
        m_pPolicy               (pPolicy),
        m_pSeekingCore          (pSeekingCore),
        m_iVideoPinIndex        (UNDEFINED),
        m_pDVRSendStatsWriter   (pDVRSendStatsWriter),
        m_fIsLiveSource         (fIsLiveSource),
        m_lFlushingRef          (0)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSourcePinManager")) ;

    ASSERT (m_pSeekingCore) ;
    ASSERT (m_pDVRSendStatsWriter) ;

    ASSERT (m_pPolicy) ;
    m_pPolicy -> AddRef () ;
}

CDVRSourcePinManager::~CDVRSourcePinManager (
    )
{
    CBasePin *  pPin ;
    int         i ;

    TRACE_DESTRUCTOR (TEXT ("CDVRSourcePinManager")) ;

    i = 0 ;
    do {
        pPin = GetPin (i++) ;
        delete pPin ;
    } while (pPin) ;

    RELEASE_AND_CLEAR (m_pWMReaderProfile) ;

    ASSERT (m_pPolicy) ;
    m_pPolicy -> Release () ;
}

HRESULT
CDVRSourcePinManager::SetReaderProfile (
    IN  CDVRReaderProfile * pWMReaderProfile
    )
{
    DWORD           dwPinCount ;
    WORD            wStreamNum ;
    DWORD           dwIndex ;
    HRESULT         hr ;
    CMediaType *    pmt ;
    BOOL            r ;

    ASSERT (pWMReaderProfile) ;

    hr = pWMReaderProfile -> EnumWMStreams (& dwPinCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    for (dwIndex = 0; dwIndex < dwPinCount && SUCCEEDED (hr); dwIndex++) {
        pmt = new CMediaType ;
        if (pmt) {
            hr = pWMReaderProfile -> GetStream (dwIndex, & wStreamNum, pmt) ;
            if (SUCCEEDED (hr)) {
                hr = CreateOutputPin (dwIndex, pmt) ;
            }

            //  we copy the media type in the output pin, so we must free this
            FreeMediaType (* pmt) ;
            delete pmt ;

            //  create out stream num -> index map
            r = m_StreamNumToPinIndex.CreateMap (wStreamNum, dwIndex) ;
            if (!r) {
                hr = E_OUTOFMEMORY ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }

    cleanup :

    return hr ;
}

HRESULT
CDVRSourcePinManager::CreateOutputPin (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    TCHAR           achBuffer [32] ;
    CDVROutputPin * pOutputPin ;
    HRESULT         hr ;

    TRACE_ENTER_2 (
        TEXT ("CDVRSourcePinManager::CreateOutputPin (%d, %08xh)"),
        iPinIndex,
        pmt
        ) ;

    FilterLock_ () ;

    hr = ::NewDVROutputPin (
                pmt,
                m_pPolicy,
                CreateOutputPinName (
                    iPinIndex + 1,          //  index is 0-based
                    sizeof (achBuffer) / sizeof (TCHAR),
                    & achBuffer [0]
                    ),
                m_pOwningFilter,
                m_pFilterLock,
                m_pSeekingCore,
                m_pDVRSendStatsWriter,
                this,
                & pOutputPin                //  get the pin here
                ) ;

    if (FAILED (hr)) {
        ASSERT (pOutputPin == NULL) ;
        goto cleanup ;
    }

    ASSERT (pOutputPin) ;

    //  add it to the bank
    hr = AddPin (
            pOutputPin,
            iPinIndex
            ) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  set the pin's bank index
    pOutputPin -> SetBankStoreIndex (iPinIndex) ;

    //  set the media type on the pin
    //  !NOTE! : add this after setting the bank store index, or the flow id
    //   will not be set correctly in the attribute translator
    hr = pOutputPin -> SetPinMediaType (pmt) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  if we still haven't received a video pin index, check if we've just
    //    added one; use this for seeking purposes; if we have no video pins
    //    the 0th pin is the seeking pin
    if (m_iVideoPinIndex == UNDEFINED &&
        IsAMVideo (pmt)) {

        //  found it
        m_iVideoPinIndex = iPinIndex ;
    }

    //  success !
    m_pOwningFilter -> IncrementPinVersion () ;

    cleanup :

    FilterUnlock_ () ;

    if (FAILED (hr)) {
        delete pOutputPin ;
    }

    return hr ;
}

HRESULT
CDVRSourcePinManager::Active (
    )
{
    HRESULT         hr ;
    int             i ;
    CDVROutputPin * pPin ;

    hr = S_OK ;

    for (i = 0; SUCCEEDED (hr);i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            hr = pPin -> Active () ;
        }
        else {
            break ;
        }
    }

    if (FAILED (hr)) {
        Inactive () ;
    }

    return hr ;
}

HRESULT
CDVRSourcePinManager::Inactive (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            pPin -> Inactive () ;
        }
        else {
            break ;
        }
    }

    m_lFlushingRef = 0 ;

    return S_OK ;
}

int
CDVRSourcePinManager::PinIndexFromStreamNumber (
    IN  WORD    wStreamNum
    )
{
    BOOL    r ;
    int     iPinIndex ;

    r = m_StreamNumToPinIndex.Find (wStreamNum, & iPinIndex) ;

    if (!r) {
        iPinIndex = UNDEFINED ;
    }

    return iPinIndex ;
}

CDVROutputPin *
CDVRSourcePinManager::GetNonRefdOutputPin (
    IN  WORD    wStreamNum
    )
{
    CDVROutputPin * pDVROutputPin ;
    int             iPinIndex ;

    iPinIndex = PinIndexFromStreamNumber (wStreamNum) ;
    if (iPinIndex != UNDEFINED) {
        pDVROutputPin = GetPin (iPinIndex) ;
    }
    else {
        pDVROutputPin = NULL ;
    }

    return pDVROutputPin ;
}

HRESULT
CDVRSourcePinManager::DeliverBeginFlush (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    FilterLock_ () ;

    //  only deliver if we're the first to begin
    if (::InterlockedIncrement (& m_lFlushingRef) == 1) {
        for (i = 0;;i++) {
            pPin = GetPin (i) ;
            if (pPin) {
                if (pPin -> IsConnected ()) {
                    pPin -> DeliverBeginFlush () ;
                }
            }
            else {
                break ;
            }
        }
    }

    FilterUnlock_ () ;

    return S_OK ;
}

BOOL
CDVRSourcePinManager::IsFlushing (
    )
{
    return m_lFlushingRef > 0 ;
}

HRESULT
CDVRSourcePinManager::DeliverEndFlush (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    FilterLock_ () ;

    ASSERT (m_lFlushingRef > 0) ;

    //  only deliver if we're the last to end
    if (::InterlockedDecrement (& m_lFlushingRef) == 0) {
        for (i = 0;;i++) {
            pPin = GetPin (i) ;
            if (pPin) {
                if (pPin -> IsConnected ()) {
                    pPin -> DeliverEndFlush () ;
                }
            }
            else {
                break ;
            }
        }
    }

    FilterUnlock_ () ;

    return S_OK ;
}

HRESULT
CDVRSourcePinManager::DeliverEndOfStream (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                pPin -> DeliverEndOfStream () ;
            }
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

HRESULT
CDVRSourcePinManager::NotifyNewSegment (
    IN  REFERENCE_TIME  rtStart,
    IN  REFERENCE_TIME  rtStop,
    IN  double          dRate
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            pPin -> NotifyNewSegment (rtStart, rtStop, dRate) ;
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

void
CDVRSourcePinManager::SetNewSegmentBoundary (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            pPin -> SetNewSegmentBoundary () ;
        }
        else {
            break ;
        }
    }
}

BOOL
CDVRSourcePinManager::IsSeekingPin (
    CDVROutputPin * pDVROutputPin
    )
{
    CDVROutputPin * pPin ;
    int             i ;
    BOOL            r ;

    ASSERT (pDVROutputPin) ;
    if (m_iVideoPinIndex != UNDEFINED) {
        r = (pDVROutputPin -> GetBankStoreIndex () == m_iVideoPinIndex ? TRUE : FALSE) ;
    }
    else {
        //  there's no video pin; 0th pin is the default
        r = (pDVROutputPin -> GetBankStoreIndex () == 0 ? TRUE : FALSE) ;
    }

    return r ;
}

BOOL
CDVRSourcePinManager::IsFullFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL            fSupported ;
    CDVROutputPin * pPin ;
    int             i ;

    fSupported = FALSE ;

    for (i = 0;!fSupported;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            fSupported = pPin -> IsFullFrameRateSupported (dRate) ;
        }
        else {
            break ;
        }
    }

    return fSupported ;
}

BOOL
CDVRSourcePinManager::IsFrameRateSupported (
    IN  double  dRate
    )
{
    BOOL            fSupported ;
    CDVROutputPin * pPin ;
    int             i ;

    fSupported = FALSE ;

    for (i = 0;!fSupported;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            fSupported = pPin -> IsFrameRateSupported (dRate) ;
        }
        else {
            break ;
        }
    }

    return fSupported ;
}

BOOL
CDVRSourcePinManager::SupportTrickMode (
    )
{
    BOOL            fSupported ;
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0, fSupported = FALSE;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            fSupported = pPin -> SupportTrickMode () ;
            if (!fSupported) {
                //  all or nothing : here's one that doesn't and that's enough
                break ;
            }
        }
        else {
            break ;
        }
    }

    return fSupported ;
}

int
CDVRSourcePinManager::SendingPinCount (
    )
{
    int             iSending ;
    CDVROutputPin * pPin ;
    int             i ;

    iSending = 0 ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsPlayrateCompatible () &&
                pPin -> IsConnected ()          &&
                pPin -> IsMediaCompatible ()) {

                iSending++ ;
            }
        }
        else {
            break ;
        }
    }

    return iSending ;
}

int
CDVRSourcePinManager::ConnectedCount (
    )
{
    int             iConnected ;
    CDVROutputPin * pPin ;
    int             i ;

    iConnected = 0 ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                iConnected++ ;
            }
        }
        else {
            break ;
        }
    }

    return iConnected ;
}

void
CDVRSourcePinManager::SendAllQueued (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            pPin -> SendAllQueued () ;
        }
        else {
            break ;
        }
    }
}

void
CDVRSourcePinManager::OnPTSPaddingIncrement (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            pPin -> OnPTSPaddingIncrement () ;
        }
        else {
            break ;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrdsseek.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dvrdsseek.h

    Abstract:

        This module contains the IMediaSeeking-related code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        10-Apr-2001     mgates      created

    Notes:

--*/

#include "dvrall.h"

#include "dvrprof.h"
#include "dvrdsseek.h"
#include "dvrpins.h"
#include "dvrdsread.h"

CVarSpeedTimeline::CVarSpeedTimeline (
    ) : m_pCurRateSegment   (NULL)
{
    InitializeListHead (& m_leRateSegmentList) ;
    Reset_ () ;
}

CVarSpeedTimeline::~CVarSpeedTimeline (
    )
{
    Reset_ () ;
}

void
CVarSpeedTimeline::Reset_ (
    )
{
    RATE_SEGMENT *  pRateSegment ;

    while (!IsListEmpty (& m_leRateSegmentList)) {
        pRateSegment = RATE_SEGMENT::Recover (m_leRateSegmentList.Flink) ;
        RATE_SEGMENT::Disconnect (pRateSegment) ;
        RecycleSegment_ ( pRateSegment) ;
    }

    m_pCurRateSegment = NULL ;
}

void
CVarSpeedTimeline::UpdateQueue_ (
    IN  REFERENCE_TIME  rtRuntimeNow
    )
{
    RATE_SEGMENT *  pRateSegment ;
    LIST_ENTRY *    pCurListEntry ;

    ASSERT (!IsListEmpty (& m_leRateSegmentList)) ;
    ASSERT (m_pCurRateSegment) ;
    ASSERT (& m_pCurRateSegment -> ListEntry == m_leRateSegmentList.Flink) ;

    for (pCurListEntry = m_pCurRateSegment -> ListEntry.Flink;
         pCurListEntry != & m_leRateSegmentList;
         pCurListEntry = pCurListEntry -> Flink) {

        pRateSegment = RATE_SEGMENT::Recover (pCurListEntry) ;
        if (pRateSegment -> rtRuntimeStart <= rtRuntimeNow) {
            //  first in list has become stale; remove it
            RATE_SEGMENT::Disconnect (m_pCurRateSegment) ;

            TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 1,
                TEXT ("CVarSpeedTimeline::UpdateQueue_ () -- OUT : segment (runtime start = %I64d ms, base = %I64d ms, rate = %2.1f); now = %I64d ms"),
                DShowTimeToMilliseconds (m_pCurRateSegment -> rtRuntimeStart),
                DShowTimeToMilliseconds (m_pCurRateSegment -> rtBasetime),
                m_pCurRateSegment -> dRate,
                DShowTimeToMilliseconds (rtRuntimeNow)
                ) ;

            //  recycle
            RecycleSegment_ (m_pCurRateSegment) ;

            //  replace
            m_pCurRateSegment = pRateSegment ;

            TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 1,
                TEXT ("CVarSpeedTimeline::UpdateQueue_ () -- IN : segment (runtime start = %I64d ms, base = %I64d ms, rate = %2.1f); now = %I64d ms"),
                DShowTimeToMilliseconds (m_pCurRateSegment -> rtRuntimeStart),
                DShowTimeToMilliseconds (m_pCurRateSegment -> rtBasetime),
                m_pCurRateSegment -> dRate,
                DShowTimeToMilliseconds (rtRuntimeNow)
                ) ;
        }
        else {
            //  list is sorted and first is not stale; list is current
            break ;
        }
    }

    ASSERT (!IsListEmpty (& m_leRateSegmentList)) ;
    ASSERT (m_pCurRateSegment) ;
    ASSERT (& m_pCurRateSegment -> ListEntry == m_leRateSegmentList.Flink) ;
}

void
CVarSpeedTimeline::InsertNewSegment_ (
    IN  RATE_SEGMENT *  pNewRateSegment
    )
{
    LIST_ENTRY *    pCurListEntry ;
    RATE_SEGMENT *  pPrevRateSegment ;

    //  list might be empty when we enter here

    //  start from the tail; sorted on runtimestart
    for (pCurListEntry = m_leRateSegmentList.Blink;
         pCurListEntry != & m_leRateSegmentList;
         pCurListEntry = pCurListEntry -> Blink) {

        pPrevRateSegment = RATE_SEGMENT::Recover (pCurListEntry) ;
        if (pPrevRateSegment -> rtRuntimeStart <= pNewRateSegment -> rtRuntimeStart) {
            //  found our slot
            break ;
        }
    }

    //  insert after
    InsertHeadList (pCurListEntry, & pNewRateSegment -> ListEntry) ;
}

void
CVarSpeedTimeline::FixupSegmentQueue_ (
    IN  RATE_SEGMENT *  pNewRateSegment
    )
{
    LIST_ENTRY *    pCurListEntry ;
    RATE_SEGMENT *  pPrevRateSegment ;
    RATE_SEGMENT *  pCurRateSegment ;

    ASSERT (!IsListEmpty (& m_leRateSegmentList)) ;
    ASSERT (m_pCurRateSegment) ;
    ASSERT (& m_pCurRateSegment -> ListEntry == m_leRateSegmentList.Flink) ;

    pPrevRateSegment = m_pCurRateSegment ;

    //  fixup list wrt previous
    for (pCurListEntry = m_pCurRateSegment -> ListEntry.Flink;
         pCurListEntry != & m_leRateSegmentList;
         pCurListEntry = pCurListEntry -> Flink) {

        pCurRateSegment = RATE_SEGMENT::Recover (pCurListEntry) ;
        pCurRateSegment -> rtBasetime = RATE_SEGMENT::StreamtimeBase (pPrevRateSegment, pCurRateSegment -> rtRuntimeStart) ;

        pPrevRateSegment = pCurRateSegment ;
    }
}

DWORD
CVarSpeedTimeline::Start (
    IN  REFERENCE_TIME  rtBasetime,
    IN  REFERENCE_TIME  rtRuntimeStart,
    IN  double          dRate
    )
{
    DWORD   dw ;

    Stop () ;

    ASSERT (IsListEmpty (& m_leRateSegmentList)) ;
    ASSERT (!m_pCurRateSegment) ;

    m_pCurRateSegment = GetNewSegment_ () ;
    if (m_pCurRateSegment) {

        m_pCurRateSegment -> rtBasetime     = rtBasetime ;
        m_pCurRateSegment -> rtRuntimeStart = rtRuntimeStart ;
        m_pCurRateSegment -> dRate          = dRate ;

        InsertNewSegment_ (m_pCurRateSegment) ;
        ASSERT (!IsListEmpty (& m_leRateSegmentList)) ;

        //  m_pCurRateSegment will have been inserted into front of
        //    list; since it's the only segment in the list, there are
        //    no others to fixup; we're done

        dw = NOERROR ;
    }
    else {
        dw = ERROR_NOT_ENOUGH_MEMORY ;
    }

    return dw ;
}

void
CVarSpeedTimeline::Stop (
    )
{
    Reset_ () ;
}

void
CVarSpeedTimeline::SetBase (
    IN  REFERENCE_TIME  rtBasetime,
    IN  REFERENCE_TIME  rtRuntimeNow,
    IN  double          dRate
    )
{
    if (m_pCurRateSegment) {
        UpdateQueue_ (rtRuntimeNow) ;

        ASSERT (m_pCurRateSegment) ;
        ASSERT (& m_pCurRateSegment -> ListEntry == m_leRateSegmentList.Flink) ;

        m_pCurRateSegment -> rtBasetime     = rtBasetime ;
        m_pCurRateSegment -> rtRuntimeStart = rtRuntimeNow ;

        FixupSegmentQueue_ (m_pCurRateSegment) ;

        TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 1,
            TEXT ("CVarSpeedTimeline::SetBase () -- basetime = %I64d ms, runtime = %I64d ms, %2.1f, segment = %08xh"),
            ::DShowTimeToMilliseconds (m_pCurRateSegment -> rtBasetime),
            ::DShowTimeToMilliseconds (m_pCurRateSegment -> rtRuntimeStart),
            m_pCurRateSegment -> dRate,
            m_pCurRateSegment
            ) ;
    }
    else {
        //  first
        Start (rtBasetime, rtRuntimeNow, dRate) ;
    }
}

REFERENCE_TIME
CVarSpeedTimeline::Time (
    IN  REFERENCE_TIME  rtRuntimeNow
    )
{
    REFERENCE_TIME  rtTime ;

    if (m_pCurRateSegment) {
        //  update while we're at it
        UpdateQueue_ (rtRuntimeNow) ;

        rtTime = m_pCurRateSegment -> rtBasetime +
                 (REFERENCE_TIME) ((double) (rtRuntimeNow - m_pCurRateSegment -> rtRuntimeStart) *
                                   m_pCurRateSegment -> dRate) ;
    }
    else {
        //  not yet started
        rtTime = 0 ;
    }

    //  intra & same-stream jitter could underflow this right at start
    return Max <REFERENCE_TIME> (rtTime, 0) ;
}

DWORD
CVarSpeedTimeline::QueueRateSegment (
    IN  double          dRate,
    IN  REFERENCE_TIME  rtRuntimeStart
    )
{
    RATE_SEGMENT *  pNewRateSegment ;
    DWORD           dw ;

    if (m_pCurRateSegment) {
        if (m_pCurRateSegment -> rtRuntimeStart <= rtRuntimeStart) {
            pNewRateSegment = GetNewSegment_ () ;
            if (pNewRateSegment) {
                //  initialize the fields we can
                pNewRateSegment -> dRate = dRate ;
                pNewRateSegment -> rtRuntimeStart = rtRuntimeStart ;

                //  we know the time equals or follows the time of the cur
                //    segment, so we can safely insert it into the queue
                InsertNewSegment_ (pNewRateSegment) ;
                FixupSegmentQueue_ (pNewRateSegment) ;

                //  don't update the queue; runtimestart may well be in the
                //    future vs. now

                TRACE_3 (LOG_AREA_SEEKING_AND_TRICK, 1,
                    TEXT ("CVarSpeedTimeline::QueueRateSegment () -- runtime = = %I64d ms, %2.1f, segment = %08xh"),
                    ::DShowTimeToMilliseconds (pNewRateSegment -> rtRuntimeStart),
                    pNewRateSegment -> dRate,
                    pNewRateSegment
                    ) ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_NOT_ENOUGH_MEMORY ;
            }
        }
        else {
            //  time has already passed
            dw = ERROR_GEN_FAILURE ;
        }
    }
    else {
        //  no rate segment exists, which means
        dw = Start (0, rtRuntimeStart, dRate) ;
    }

    return dw ;
}

//  ============================================================================

CSeekingTimeline::CSeekingTimeline (
    ) : m_pIRefClock            (NULL),
        m_pDVRSendStatsWriter   (NULL)
{
    InitializeCriticalSection (& m_crt) ;
}

CSeekingTimeline::~CSeekingTimeline (
    )
{
    SetRefClock (NULL) ;
    DeleteCriticalSection (& m_crt) ;
}

void
CSeekingTimeline::Pause (
    )
{
    Lock_ () ;

    ASSERT (m_pIRefClock) ;
    m_RunTimeline.Pause (TimeNow_ ()) ;

    Unlock_ () ;

    TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 1,
        TEXT ("Paused %I64d ms"),
        DShowTimeToMilliseconds (TimeNow_ ())) ;
}

void
CSeekingTimeline::Stop (
    )
{
    Lock_ () ;

    m_RunTimeline.Stop () ;
    m_StreamTimeline.Stop () ;
    m_PlayTimeline.Stop () ;

    Unlock_ () ;
}

void
CSeekingTimeline::Run (
    IN  REFERENCE_TIME  rtStart,
    IN  REFERENCE_TIME  rtStreamStart,
    IN  double          dRate
    )
{
    BOOL            fStartStream ;
    REFERENCE_TIME  rtRunningTime ;

    Lock_ () ;

    ASSERT (m_pIRefClock) ;

    //  only start the stream if we've never been run
    fStartStream = (m_RunTimeline.HasRun () ? FALSE : TRUE) ;

    m_RunTimeline.Run (rtStart) ;

    if (fStartStream) {

        rtRunningTime = m_RunTimeline.RunningTime (rtStart) ;

        //  start the stream timeline
        m_StreamTimeline.Start (
            rtStreamStart,                              //  may have been seeked
            rtRunningTime,                              //  get the running time
            dRate                                       //  start with this rate
            ) ;

        //  start the play timeline
        m_PlayTimeline.Start (
            0,                                          //  always starts at 0
            rtRunningTime,                              //  get the running time
            Abs <double> (dRate)                        //  always > 0 i.e PTS don't go backwards
            ) ;
    }

    Unlock_ () ;

    TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 1,
        TEXT ("Run %I64d ms"),
        DShowTimeToMilliseconds (rtStart)) ;
}

void
CSeekingTimeline::SetStreamStart (
    IN  REFERENCE_TIME  rtStreamStart,
    IN  double          dRate
    )
{
    REFERENCE_TIME  rtNow ;

    Lock_ () ;

    rtNow = TimeNow_ () ;

    //  only rebase the stream time; this is because of seeks
    m_StreamTimeline.SetBase (rtStreamStart, m_RunTimeline.RunningTime (rtNow), dRate) ;

    //  playtime always advances from graph start.. alongside running time, but
    //    scale for rates (+ only)

    Unlock_ () ;
}

HRESULT
CSeekingTimeline::GetCurPlaytime (
    OUT REFERENCE_TIME *    prtPlaytime,
    OUT REFERENCE_TIME *    prtNow
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtRuntime ;

    ASSERT (prtPlaytime) ;

    Lock_ () ;

    hr = GetCurRuntime (& rtRuntime) ;
    if (SUCCEEDED (hr)) {
        (* prtPlaytime) = m_PlayTimeline.Time (rtRuntime) ;

        if (prtNow) {
            (* prtNow) = rtRuntime ;
        }
    }

    TRACE_2 (LOG_AREA_TIME, 8,
        TEXT ("playtime,runtime = ,%I64d,%I64d, ms"),
        DShowTimeToMilliseconds (* prtPlaytime), DShowTimeToMilliseconds (rtRuntime)) ;

    Unlock_ () ;

    return hr ;
}

HRESULT
CSeekingTimeline::GetCurStreamTime (
    OUT REFERENCE_TIME *    prtStreamtime,
    OUT REFERENCE_TIME *    prtNow
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtRuntime ;

    ASSERT (prtStreamtime) ;

    Lock_ () ;

    hr = GetCurRuntime (& rtRuntime) ;
    if (SUCCEEDED (hr)) {
        (* prtStreamtime) = m_StreamTimeline.Time (rtRuntime) ;

        if (prtNow) {
            (* prtNow) = rtRuntime ;
        }
    }

    TRACE_3 (LOG_AREA_TIME, 8,
        TEXT ("streamtime,playtime,runtime = ,%I64d,%I64d,%I64d,"),
        DShowTimeToMilliseconds (* prtStreamtime),
        DShowTimeToMilliseconds (m_PlayTimeline.Time (rtRuntime)),
        DShowTimeToMilliseconds (rtRuntime)) ;

    Unlock_ () ;

    return hr ;
}

HRESULT
CSeekingTimeline::GetCurRuntime (
    IN REFERENCE_TIME * prt
    )
{
    REFERENCE_TIME  rtNow ;

    ASSERT (prt) ;

    Lock_ () ;

    rtNow = TimeNow_ () ;
    (* prt) = m_RunTimeline.RunningTime (rtNow) ;

    Unlock_ () ;

    return S_OK ;

}

HRESULT
CSeekingTimeline::SetCurTimelines (
    IN OUT  CTimelines *    pTimelines
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtRuntime ;

    pTimelines -> Reset () ;

    Lock_ () ;

    hr = GetCurRuntime (& rtRuntime) ;
    if (SUCCEEDED (hr)) {
        pTimelines -> put_Streamtime    (m_StreamTimeline.Time (rtRuntime)) ;
        pTimelines -> put_Playtime      (m_PlayTimeline.Time (rtRuntime)) ;
        pTimelines -> put_Runtime       (rtRuntime) ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CSeekingTimeline::SetCurStreamPosition (
    IN REFERENCE_TIME rtStream
    )
{
    return E_NOTIMPL ;
}

HRESULT
CSeekingTimeline::QueueRateChange (
    IN  double          dRate,
    IN  REFERENCE_TIME  rtPTSEffective
    )
{
    DWORD   dw ;

    Lock_ () ;

    dw = m_StreamTimeline.QueueRateSegment (
            dRate,
            rtPTSEffective
            ) ;
    if (dw == NOERROR) {
        //  playtime never runs backwards
        dw = m_PlayTimeline.QueueRateSegment (
                Abs <double> (dRate),
                rtPTSEffective
                ) ;
    }

    TRACE_3 (LOG_AREA_SEEKING_AND_TRICK, 1,
        TEXT ("CSeekingTimeline::QueueRateChange (%2.1f, %I64d ms); dw = %08xh"),
        dRate, DShowTimeToMilliseconds (rtPTSEffective), dw) ;

    Unlock_ () ;

    return HRESULT_FROM_WIN32 (dw) ;
}

//  ============================================================================

CDVRDShowSeekingCore::CDVRDShowSeekingCore (
    IN  CCritSec *      pFilterLock,
    IN  CBaseFilter *   pHostingFilter
    ) : m_pDVRReadManager       (NULL),
        m_guidTimeFormat        (TIME_FORMAT_MEDIA_TIME),   //  this is it, always
        m_pFilterLock           (pFilterLock),
        m_pHostingFilter        (pHostingFilter),
        m_pDVRPolicy            (NULL),
        m_pDVRSendStatsWriter   (NULL)
{
    ASSERT (m_pFilterLock) ;
    ASSERT (m_pHostingFilter) ;

    InitializeCriticalSection (& m_crtSeekingLock) ;
}

CDVRDShowSeekingCore::~CDVRDShowSeekingCore (
    )
{
    RELEASE_AND_CLEAR (m_pDVRPolicy) ;
    DeleteCriticalSection (& m_crtSeekingLock) ;
}

void
CDVRDShowSeekingCore::SetDVRPolicy (
    IN  CDVRPolicy *    pDVRPolicy
    )
{
    RELEASE_AND_CLEAR (m_pDVRPolicy) ;
    m_pDVRPolicy = pDVRPolicy ;
    if (m_pDVRPolicy) {
        m_pDVRPolicy -> AddRef () ;
    }
}

BOOL CDVRDShowSeekingCore::IsSeekingPin (IN CDVROutputPin * pPin)
{
    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::IsSeekingPin ()")) ;
    ASSERT (m_pDVRSourcePinManager) ;
    return m_pDVRSourcePinManager -> IsSeekingPin (pPin) ;
}

void
CDVRDShowSeekingCore::SetCurTimelines (
    IN OUT  CTimelines *    pTimelines
    )
{
    m_SeekingTimeline.SetCurTimelines (pTimelines) ;
}

HRESULT
CDVRDShowSeekingCore::TimeToCurrentFormat_ (
    IN  REFERENCE_TIME  rt,
    OUT LONGLONG *      pll
    )
{
    ASSERT (pll) ;

    //  only support time for now
    (* pll) = rt ;

    return S_OK ;
}

HRESULT
CDVRDShowSeekingCore::CurrentFormatToTime_ (
    IN  LONGLONG            ll,
    OUT REFERENCE_TIME *    prt
    )
{
    ASSERT (prt) ;

    //  only support time for now
    (* prt) = ll ;

    return S_OK ;
}

BOOL
CDVRDShowSeekingCore::IsSeekingFormatSupported (
    IN  const GUID *    pFormat
    )
/*++
    Description:

        Called by the seeking pin in response to an IMediaSeeking format
        query.

    Parameters:

        pFormat     The following are defined in MSDN:

                        TIME_FORMAT_NONE
                        TIME_FORMAT_FRAME
                        TIME_FORMAT_SAMPLE
                        TIME_FORMAT_FIELD
                        TIME_FORMAT_BYTE
                        TIME_FORMAT_MEDIA_TIME

                    This list is not restrictive however.  MSDN states that 3rd
                    parties are encouraged to define their own GUIDs for
                    seeking granularities.

    Return Values:

        TRUE        format is supported
        FALSE       format is not supported

--*/
{
    BOOL    r ;

    TRACE_ENTER_0 (TEXT ("CDVRDShowSeekingCore::IsSeekingFormatSupported ()")) ;

    //  support only time
    if ((* pFormat) == TIME_FORMAT_MEDIA_TIME) {

        //  time-based seeking is ok
        r = TRUE ;
    }
    else {
        //  everything else is not ok
        r = FALSE ;
    }

    return r ;
}

HRESULT
CDVRDShowSeekingCore::QueryPreferredSeekingFormat (
    OUT GUID * pFormat
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::QueryPreferredSeekingFormat ()")) ;

    //  caller should have screened for bad parameters
    ASSERT (pFormat) ;

    (* pFormat) == TIME_FORMAT_MEDIA_TIME ;
    return S_OK ;
}

HRESULT
CDVRDShowSeekingCore::SetSeekingTimeFormat (
    IN  const GUID *    pguidTimeFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::SetSeekingTimeFormat ()")) ;

    FilterLock_ () ;

    ASSERT (pguidTimeFormat) ;

    if (m_pHostingFilter -> IsStopped ()) {
        if (IsSeekingFormatSupported (pguidTimeFormat)) {
            //  looks ok; set it
            m_guidTimeFormat = (* pguidTimeFormat) ;
            hr = S_OK ;
        }
        else {
            //  error: not supported
            hr = E_INVALIDARG ;
        }
    }
    else {
        //  error: gotta be stopped
        hr = VFW_E_WRONG_STATE ;
    }

    FilterUnlock_ () ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetSeekingTimeFormat (
    OUT GUID *  pguidTimeFormat
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetSeekingTimeFormat ()")) ;

    ASSERT (pguidTimeFormat) ;

    (* pguidTimeFormat) = m_guidTimeFormat ;

    return S_OK ;
}

//  BUGBUG: total file duration or start -> stop duration ?????
HRESULT
CDVRDShowSeekingCore::GetFileDuration (
    OUT LONGLONG *  pllDuration
    )
{
    HRESULT     hr ;
    LONGLONG    llStartContent ;
    LONGLONG    llStopContent ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetFileDuration ()")) ;

    ASSERT (pllDuration) ;

    hr = GetAvailableContent (& llStartContent, & llStopContent) ;
    if (SUCCEEDED (hr)) {
        ASSERT (llStopContent >= llStartContent) ;  //  can be equal
        (* pllDuration) = llStopContent - llStartContent ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetAvailableContent (
    OUT LONGLONG *  pllStartContent,
    OUT LONGLONG *  pllStopContent
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    if (IsSeekable ()) {
        ASSERT (pllStartContent) ;
        ASSERT (pllStopContent) ;
        ASSERT (m_pDVRReadManager) ;

        hr = m_pDVRReadManager -> GetContentExtent (
                & rtStart,
                & rtStop
                ) ;
        if (SUCCEEDED (hr)) {
            ASSERT (rtStart <= rtStop) ;    //  can be equal

            hr = TimeToCurrentFormat_ (rtStop, pllStopContent) ;
            if (SUCCEEDED (hr)) {
                hr = TimeToCurrentFormat_ (rtStart, pllStartContent) ;
            }
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetFileStopPosition (
    OUT LONGLONG *  pllStop
    )
{
    REFERENCE_TIME  rtStop ;
    HRESULT         hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetFileStopPosition ()")) ;

    if (IsSeekable ()) {
        ASSERT (pllStop) ;
        ASSERT (m_pDVRReadManager) ;

        hr = m_pDVRReadManager -> GetCurrentStop (& rtStop) ;
        if (SUCCEEDED (hr)) {
            hr = TimeToCurrentFormat_ (rtStop, pllStop) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetFileStartPosition (
    OUT LONGLONG *  pllStart
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetFileStartPosition ()")) ;

    if (IsSeekable ()) {
        ASSERT (m_pDVRReadManager) ;
        ASSERT (pllStart) ;

        hr = m_pDVRReadManager -> GetCurrentStart (& rtStart) ;
        if (SUCCEEDED (hr)) {
            hr = TimeToCurrentFormat_ (rtStart, pllStart) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetCurSegStart_ (
    OUT REFERENCE_TIME *    prtStart
    )
{
    HRESULT         hr ;

    if (IsSeekable ()) {
        hr = m_pDVRReadManager -> GetCurrentStart (prtStart) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SetStreamSegmentStart (
    IN  REFERENCE_TIME  rtStart,
    IN  double          dCurRate
    )
{
    TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 1,
        TEXT ("PostSeekStreamTimeFixupLocked_ () : new stream time = %I64d ms"),
        DShowTimeToMilliseconds (rtStart)) ;

    m_SeekingTimeline.SetStreamStart (rtStart, dCurRate) ;

    return S_OK ;
}

HRESULT
CDVRDShowSeekingCore::SeekTo (
    IN  LONGLONG *      pllStart
    )
{
    HRESULT hr ;
    double  dCurRate ;

    O_TRACE_ENTER_1 (TEXT("CDVRDShowSeekingCore::SeekTo (%I64d)"), (* pllStart)) ;

    hr = GetPlaybackRate (& dCurRate) ;
    if (SUCCEEDED (hr)) {
        hr = SeekTo (pllStart, NULL, dCurRate) ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SeekTo (
    IN  LONGLONG *      pllStart,
    IN  LONGLONG *      pllStop,
    IN  double          dPlaybackRate
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    BOOL            fSeekIsNoop ;

    if (IsSeekable ()) {

        ASSERT (pllStart) ;
        //  pllStop can be NULL

        hr = CurrentFormatToTime_ ((* pllStart), & rtStart) ;
        if (SUCCEEDED (hr)) {

            //  if specified, convert
            if (pllStop) {
                hr = CurrentFormatToTime_ ((* pllStop), & rtStop) ;
            }

            //  make the call
            if (SUCCEEDED (hr)) {

                //  always return to 1.0 on seeks
                dPlaybackRate = _1X_PLAYBACK_RATE ;

                hr = m_pDVRReadManager -> SeekTo (
                            & rtStart,
                            (pllStop ? & rtStop : NULL),
                            dPlaybackRate,
                            & fSeekIsNoop
                            ) ;
            }
        }

        if (SUCCEEDED (hr) &&
            !fSeekIsNoop) {

            hr = SetStreamSegmentStart (rtStart, dPlaybackRate) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SetFileStopPosition (
    IN  LONGLONG *  pllStop
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStop ;

    if (IsSeekable ()) {
        hr = CurrentFormatToTime_ ((* pllStop), & rtStop) ;
        if (SUCCEEDED (hr)) {
            hr = m_pDVRReadManager -> SetStop (rtStop) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SetPlaybackRate (
    IN  double  dPlaybackRate
    )
{
    HRESULT hr ;
    double  dMaxReverseRate ;
    double  dMaxForwardRate ;

    //  make sure we support trick modes
    if (dPlaybackRate != 1.0 &&
        !m_pDVRSourcePinManager -> SupportTrickMode ()) {

        TRACE_1 (LOG_ERROR,1,
            TEXT ("CDVRDShowSeekingCore::SetPlaybackRate () : don't support trick mode; %2.1f"),
            dPlaybackRate) ;

        hr = E_NOTIMPL ;
        return hr ;
    }

    if (::Abs <double> (dPlaybackRate) < TRICK_PLAY_LOWEST_RATE) {

        TRACE_2 (LOG_ERROR,1,
            TEXT ("CDVRDShowSeekingCore::SetPlaybackRate () : invalid trick mode rate requested; %2.1f vs. %2.1f"),
            dPlaybackRate, TRICK_PLAY_LOWEST_RATE) ;

        hr = E_INVALIDARG ;
        return hr ;
    }

    if (IsSeekable () &&
        !m_pHostingFilter -> IsStopped ()) {

        //
        //  the seeking lock is held across state transitions; we know we have
        //    it right now, so we're ok - no state will change as long as we
        //    hold the seeking lock
        //

        hr = GetPlayrateRange (& dMaxReverseRate, & dMaxForwardRate) ;
        if (SUCCEEDED (hr)) {

            if ((dPlaybackRate < 0 && Abs <double> (dPlaybackRate) > dMaxReverseRate)   ||
                (dPlaybackRate > 0 && dPlaybackRate > dMaxForwardRate)                  ||
                dPlaybackRate == 0) {

                hr = E_INVALIDARG ;
            }

            if (SUCCEEDED (hr)) {

                TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 1,
                    TEXT ("CDVRDShowSeekingCore::SetPlaybackRate () : requested %2.1f"),
                    dPlaybackRate) ;

                Lock () ;
                hr = m_pDVRReadManager -> SetPlaybackRate (dPlaybackRate) ;
                Unlock () ;
            }
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetPlaybackRate (
    OUT double *    pdPlaybackRate
    )
{
    HRESULT hr ;

    if (IsSeekable ()) {
        ASSERT (pdPlaybackRate) ;
        (* pdPlaybackRate) = m_pDVRReadManager -> GetPlaybackRate () ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetPlayrateRange (
    OUT double *    pdMaxReverseRate,
    OUT double *    pdMaxForwardRate
    )
{
    HRESULT hr ;

    if (IsSeekable ()) {
        ASSERT (pdMaxReverseRate) ;
        ASSERT (pdMaxForwardRate) ;

        m_pDVRReadManager -> GetPlayrateRange (pdMaxReverseRate, pdMaxForwardRate) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

void
CDVRDShowSeekingCore::OnFilterStateChange (
    IN  FILTER_STATE    TargetState,
    IN  REFERENCE_TIME  rtRunStart
    )
{
    REFERENCE_TIME  rtStreamStart ;
    HRESULT         hr ;

    switch (TargetState) {
        case State_Stopped :
            m_SeekingTimeline.Stop () ;
            break ;

        case State_Paused :
            m_SeekingTimeline.Pause () ;
            break ;

        case State_Running :
            hr = GetCurSegStart_ (& rtStreamStart) ;
            if (SUCCEEDED (hr)) {
                m_SeekingTimeline.Run (rtRunStart, rtStreamStart) ;
            }

            break ;
    } ;
}

HRESULT
CDVRDShowSeekingCore::GetStreamTime (
    OUT LONGLONG *  pllCurPos
    )
{
    REFERENCE_TIME  rtStreamNow ;
    HRESULT         hr ;
    double          dRate ;
    REFERENCE_TIME  rtContentStart ;
    REFERENCE_TIME  rtContentStop ;

    hr = GetStreamTimeDShow (& rtStreamNow) ;
    if (SUCCEEDED (hr)) {

        //  if we're running, make sure we're within bounds
        if (m_pDVRReadManager) {

            dRate = m_pDVRReadManager -> GetPlaybackRate () ;

            //  for trick mode play, it's possible that a correction has not yet
            //    kicked in, in which case we might momentarily overrun the actual
            //    content; check for this condition now
            if (dRate > _1X_PLAYBACK_RATE) {
                //  check for overrun
                hr = m_pDVRReadManager -> GetContentExtent (& rtContentStart, & rtContentStop) ;
                if (SUCCEEDED (hr)) {
                    //  set to min of current content END
                    rtStreamNow = Min <REFERENCE_TIME> (rtStreamNow, rtContentStop) ;
                }
                else {
                    goto cleanup ;
                }
            }
            else if (dRate < _1X_PLAYBACK_RATE) {
                //  check for "underrun" - we're too slow, or running backwards,
                //    and we start reporting that we're in no man's land
                hr = m_pDVRReadManager -> GetContentExtent (& rtContentStart, & rtContentStop) ;
                if (SUCCEEDED (hr)) {
                    //  set to max of current content START
                    rtStreamNow = Max <REFERENCE_TIME> (rtStreamNow, rtContentStart) ;
                }
                else {
                    goto cleanup ;
                }
            }
        }

        hr = TimeToCurrentFormat_ (rtStreamNow, pllCurPos) ;
    }

    cleanup :

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetStreamTimeDShow (
    OUT REFERENCE_TIME *    prtStream
    )
{
    HRESULT hr ;

    hr = m_SeekingTimeline.GetCurStreamTime (prtStream) ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetRuntimeDShow (
    OUT REFERENCE_TIME *    prtRuntime
    )
{
    HRESULT hr ;

    hr = m_SeekingTimeline.GetCurRuntime (prtRuntime) ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetCurPlaytime (
    OUT REFERENCE_TIME *    prtPlaytime,
    OUT REFERENCE_TIME *    prtCurRuntime
    )
{
    HRESULT hr ;

    hr = m_SeekingTimeline.GetCurPlaytime (prtPlaytime, prtCurRuntime) ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetRunTime (
    OUT LONGLONG *  pllRunTime
    )
{
    REFERENCE_TIME  rtRuntime ;
    HRESULT         hr ;

    hr = GetRuntimeDShow (& rtRuntime) ;
    if (SUCCEEDED (hr)) {
        hr = TimeToCurrentFormat_ (rtRuntime, pllRunTime) ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::ReaderThreadSetPlaybackRate (
    IN  double  dPlayrate
    )
{
    HRESULT hr ;

    //  if we try to grab the seeking lock in the process, we can deadlock:
    //    we wait on the seeking lock & a control thread with the seeking lock
    //    synchronously waits for us to pause don't grab the lock

    ASSERT (m_pDVRReadManager) ;
    hr = m_pDVRReadManager -> ConfigureForRate (dPlayrate) ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::ReaderThreadGetSegmentValues (
    OUT REFERENCE_TIME *    prtSegmentStart,
    OUT REFERENCE_TIME *    prtSegmentStop,
    OUT double *            pdSegmentRate
    )
{
    HRESULT hr ;

    ASSERT (prtSegmentStart) ;
    ASSERT (prtSegmentStop) ;
    ASSERT (pdSegmentRate) ;

    //  don't grab the media seeking lock; downstream threads call into object
    //   to perform seeking operations; if the bracket (start -> stop) changes,
    //   the locking order is such that the seeking lock is grabbed, and the
    //   receiver thread is signaled SYNCHRONOUSLY to pause, the playback
    //   bracket is reset, the receiver thread resumed, and the seeking
    //   lock released; if we (receiver thread) grab the seeking lock, or
    //   rather, block on the seeking lock, with a seeking thread waiting on
    //   us to pause, we get a deadlock; so we don't grab the lock; return
    //   values are valid because they won't be reset unless receiver thread
    //   is paused.

    ASSERT (m_pDVRReadManager) ;

    //  start - in the current units
    hr = m_pDVRReadManager -> GetCurrentStart (prtSegmentStart) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  stop - in the current units
    hr = m_pDVRReadManager -> GetCurrentStop (prtSegmentStop) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = GetPlaybackRate (pdSegmentRate) ;
    if (FAILED (hr)) { goto cleanup ; }

    cleanup :

    return hr ;
}

//  ============================================================================
//  ============================================================================
//  ============================================================================

CDVRIMediaSeeking::CDVRIMediaSeeking (
    IN  IUnknown *              punkOwning,
    IN  CDVRDShowSeekingCore *  pSeekingCore
    ) : m_punkOwning            (punkOwning),
        m_guidSeekingFormat     (GUID_NULL),
        m_pSeekingCore          (pSeekingCore)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRIMediaSeeking")) ;

    ASSERT (m_punkOwning) ;
    ASSERT (m_pSeekingCore) ;
}

CDVRIMediaSeeking::~CDVRIMediaSeeking (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRIMediaSeeking")) ;
}

//  ----------------------------------------------------------------------------
//  IUnknown interface methods - delegate always

STDMETHODIMP
CDVRIMediaSeeking::QueryInterface (
    REFIID riid,
    void ** ppv
    )
{
    return m_punkOwning -> QueryInterface (riid, ppv) ;
}

STDMETHODIMP_ (ULONG)
CDVRIMediaSeeking::AddRef (
    )
{
    return m_punkOwning -> AddRef () ;
}

STDMETHODIMP_ (ULONG)
CDVRIMediaSeeking::Release (
    )
{
    return m_punkOwning -> Release () ;
}

//  ----------------------------------------------------------------------------

HRESULT
CDVRIMediaSeeking::GetPlayrateRange (
    OUT double *    pdMaxReverseRate,
    OUT double *    pdMaxForwardRate
    )
{
    HRESULT hr ;

    if (!pdMaxReverseRate ||
        !pdMaxForwardRate) {

        return E_POINTER ;
    }

    hr = m_pSeekingCore -> GetPlayrateRange (pdMaxReverseRate, pdMaxForwardRate) ;

    return hr ;
}

HRESULT
CDVRIMediaSeeking::SetPlayrate (
    IN  double  dRate
    )
{
    HRESULT hr ;
    double  dMaxReverseRate ;
    double  dMaxForwardRate ;

    O_TRACE_ENTER_1 (TEXT("CDVRIMediaSeeking::SetPlaybackRate (%2.1f)"), dRate) ;

    SeekingLock_ () ;

    //  call validates the parameter
    hr = SetRate (dRate) ;

    SeekingUnlock_ () ;

    TRACE_2 (LOG_AREA_SEEKING_AND_TRICK, 1,
        TEXT ("CDVRIMediaSeeking::SetPlayrate () : got %2.1f; returning %08xh"),
        dRate, hr) ;

    return hr ;
}

HRESULT
CDVRIMediaSeeking::GetPlayrate (
    OUT double *    pdRate
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetPlayrate ()")) ;

    SeekingLock_ () ;

    //  call validates the parameters
    hr = GetRate (pdRate) ;

    SeekingUnlock_ () ;

    return hr ;
}

//  ----------------------------------------------------------------------------
//  IMediaSeeking interface methods

//  Returns the capability flags; S_OK if successful
STDMETHODIMP
CDVRIMediaSeeking::GetCapabilities (
    OUT DWORD * pCapabilities
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetCapabilities ()")) ;

    if (!pCapabilities) {
        return E_POINTER ;
    }

    return m_pSeekingCore -> GetSeekingCapabilities (
                                pCapabilities
                                ) ;
}

//  And's the capabilities flag with the capabilities requested.
//  Returns S_OK if all are present, S_FALSE if some are present,
//  E_FAIL if none.
//  * pCababilities is always updated with the result of the
//  'and'ing and can be checked in the case of an S_FALSE return
//  code.
STDMETHODIMP
CDVRIMediaSeeking::CheckCapabilities (
    IN OUT  DWORD * pCapabilities
    )
{
    HRESULT hr ;
    DWORD   dwCapabilities ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::CheckCapabilities ()")) ;

    if (!pCapabilities) {
        return E_POINTER ;
    }

    hr = GetCapabilities (& dwCapabilities) ;
    if (SUCCEEDED(hr))
    {
        dwCapabilities &= (* pCapabilities) ;
        hr =  dwCapabilities ? ( dwCapabilities == (* pCapabilities) ? S_OK : S_FALSE ) : E_FAIL ;
        (* pCapabilities) = dwCapabilities ;
    }
    else {
        (* pCapabilities) = 0 ;
    }

    return hr;
}

//  returns S_OK if mode is supported, S_FALSE otherwise
STDMETHODIMP
CDVRIMediaSeeking::IsFormatSupported (
    IN  const GUID *    pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::IsFormatSupported ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    if (m_pSeekingCore -> IsSeekingFormatSupported (pFormat)) {
        hr = S_OK ;
    }
    else {
        hr = S_FALSE ;
    }

    return hr ;
}

//  S_OK if successful
//  E_NOTIMPL, E_POINTER if unsuccessful
STDMETHODIMP
CDVRIMediaSeeking::QueryPreferredFormat (
    OUT GUID *  pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::QueryPreferredFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    //  comment copied .. :-)
    /*  Don't care - they're all just as bad as one another */

    hr = m_pSeekingCore -> QueryPreferredSeekingFormat (pFormat) ;

    return hr ;
}

//  S_OK if successful
STDMETHODIMP
CDVRIMediaSeeking::GetTimeFormat (
    OUT GUID *  pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    hr = m_pSeekingCore -> GetSeekingTimeFormat (pFormat) ;

    return hr ;
}

//  Returns S_OK if *pFormat is the current time format, otherwise
//  S_FALSE
//  This may be used instead of the above and will save the copying
//  of the GUID
STDMETHODIMP
CDVRIMediaSeeking::IsUsingTimeFormat (
    IN const GUID * pFormat
    )
{
    HRESULT hr ;
    GUID    guidFormat ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::IsUsingTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    hr = m_pSeekingCore -> GetSeekingTimeFormat (& guidFormat) ;

    if (SUCCEEDED (hr)) {
        hr = (guidFormat == (* pFormat) ? S_OK : S_FALSE) ;
    }

    return hr ;
}

// (may return VFE_E_WRONG_STATE if graph is stopped)
STDMETHODIMP
CDVRIMediaSeeking::SetTimeFormat (
    IN const GUID * pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::SetTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    hr = m_pSeekingCore -> SetSeekingTimeFormat (pFormat) ;

    return hr ;
}

// return current properties
STDMETHODIMP
CDVRIMediaSeeking::GetDuration (
    OUT LONGLONG *  pDuration
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetDuration ()")) ;

    if (!pDuration) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetFileDuration (pDuration) ;

    SeekingUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRIMediaSeeking::GetStopPosition (
    OUT LONGLONG *  pStop
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetStopPosition ()")) ;

    if (!pStop) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetFileStopPosition (pStop) ;

    SeekingUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRIMediaSeeking::GetCurrentPosition (
    OUT LONGLONG *  pCur
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetCurrentPosition ()")) ;

    if (!pCur) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetStreamTime (pCur) ;

    SeekingUnlock_ () ;

    return hr ;
}

//  Convert time from one format to another.
//  We must be able to convert between all of the formats that we
//  say we support.  (However, we can use intermediate formats
//  (e.g. MEDIA_TIME).)
//  If a pointer to a format is null, it implies the currently selected format.
STDMETHODIMP
CDVRIMediaSeeking::ConvertTimeFormat(
    OUT LONGLONG *      pTarget,
    IN  const GUID *    pTargetFormat,
    IN  LONGLONG        Source,
    IN  const GUID *    pSourceFormat
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::ConvertTimeFormat ()")) ;

    return E_NOTIMPL ;
}

// Set Start and end positions in one operation
// Either pointer may be null, implying no change
STDMETHODIMP
CDVRIMediaSeeking::SetPositions (
    IN OUT  LONGLONG *  pStart,
    IN      DWORD       dwStartFlags,
    IN OUT  LONGLONG *  pStop,
    IN      DWORD       dwStopFlags
    )
{
    HRESULT         hr ;
    LONGLONG        llStart ;
    LONGLONG        llStop ;
    DWORD           dwPosStartBits ;
    DWORD           dwPosStopBits ;
    BOOL            r ;
    double          dCurRate ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::SetPositions ()")) ;

    SeekingLock_ () ;

    //  ------------------------------------------------------------------------
    //  obtain some preliminary values we'll use during the course of this
    //   call

    //  the stop position
    hr = GetStopPosition (& llStop) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  the Start position as well
    hr = SeekingCore_ () -> GetFileStartPosition (& llStart) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  process "Start"

    dwPosStartBits = dwStartFlags & AM_SEEKING_PositioningBitsMask ;

    //  validate the pointer
    if (dwPosStartBits != AM_SEEKING_NoPositioning &&
        !pStart) {
        hr = E_POINTER ;
        goto cleanup ;
    }

    switch (dwPosStartBits) {
        case AM_SEEKING_NoPositioning :
            hr = S_OK ;
            break ;

        case AM_SEEKING_AbsolutePositioning :
            //  make sure it doesn't exceed the duration
            llStart = (* pStart) ;
            hr = S_OK ;
            break ;

        case AM_SEEKING_RelativePositioning :
            //  pStart is relative to Start position
            llStart += (* pStart) ;
            hr = S_OK ;
            break ;

        case AM_SEEKING_IncrementalPositioning :
            //  flag only applies to stop position; fall through

        default :
            hr = E_INVALIDARG ;
            break ;
    } ;

    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  process "stop"

    dwPosStopBits = dwStopFlags & AM_SEEKING_PositioningBitsMask ;

    //  validate the pointer
    if (dwPosStopBits != AM_SEEKING_NoPositioning &&
        !pStop) {

        hr = E_POINTER ;
        goto cleanup ;
    }

    switch (dwPosStopBits) {
        case AM_SEEKING_NoPositioning :
            if (dwPosStartBits != AM_SEEKING_NoPositioning) {
                hr = S_OK ;
            }
            else {
                //  huh ? not sure what the purpose of this call is.. nothing
                //   is valid
                hr = E_INVALIDARG ;
            }

            break ;

        case AM_SEEKING_AbsolutePositioning :
            //  since we can be dynamic, stop can exceed the current duration
            hr = S_OK ;
            break ;

        case AM_SEEKING_RelativePositioning :
            //  pStop is relative to Startly used stop position
            llStop += (* pStop) ;
            hr = S_OK ;
            break ;

        case AM_SEEKING_IncrementalPositioning :
            //  stop is relative to pStart
            if (dwPosStartBits != AM_SEEKING_NoPositioning &&
                pStart) {

                llStop = (* pStart) + (* pStop) ;
                hr = S_OK ;
            }
            else {
                hr = E_INVALIDARG ;
            }

            break ;

        default :
            hr = E_INVALIDARG ;
            break ;
    } ;

    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  ok, llStart and llStop now are offsets that bracket our desired
    //   playback


    //  make sure llStart and llStop make sense
    r = (dwPosStartBits != AM_SEEKING_NoPositioning) && (llStart < 0 || (dwPosStopBits != AM_SEEKING_NoPositioning) && llStart > llStop) ;
    if (!r) {
        if (dwPosStartBits != AM_SEEKING_NoPositioning) {
            //  we have a Start value; may or may not have a stop value
            if (dwPosStopBits == AM_SEEKING_NoPositioning) {
                //  not stop value; seek just to Start

                TRACE_2 (LOG_AREA_SEEKING_AND_TRICK, 1,
                    TEXT ("IMediaSeeking::SetPosition(); llStart = %I64d (%d sec)"),
                    llStart, DShowTimeToSeconds (llStart)) ;

                hr = m_pSeekingCore -> SeekTo (& llStart) ;
            }
            else {
                //  stop value is present; seek to a Start and specify a stop

                TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 1,
                    TEXT ("IMediaSeeking::SetPosition(); llStart = %I64d (%d sec); llStop = %I64d (%d sec)"),
                    llStart, DShowTimeToSeconds (llStart), llStop, DShowTimeToSeconds (llStop)) ;

                hr = GetRate (& dCurRate) ;
                if (SUCCEEDED (hr)) {
                    hr = m_pSeekingCore -> SeekTo (& llStart, & llStop, dCurRate) ;
                }
            }
        }
        else {
            //  set only the end point
            hr = m_pSeekingCore -> SetFileStopPosition (& llStop) ;
        }
    }
    else {
        //  specified parameters that don't make sense
        hr = E_INVALIDARG ;
    }

    //  ------------------------------------------------------------------------
    //  set outgoing, if desired
    //

    if (SUCCEEDED (hr) &&
        (dwStartFlags & AM_SEEKING_ReturnTime)) {

        ASSERT (pStart) ;
        hr = GetCurrentPosition (pStart) ;

        TRACE_2 (LOG_AREA_SEEKING_AND_TRICK, 1,
            TEXT ("IMediaSeeking::SetPosition(); returning llStart = %I64d (%d sec)"),
            (* pStart), DShowTimeToSeconds (* pStart)) ;
    }

    if (SUCCEEDED (hr) &&
        (dwStopFlags & AM_SEEKING_ReturnTime)) {

        ASSERT (pStop) ;
        hr = GetStopPosition (pStop) ;

        TRACE_2 (LOG_AREA_SEEKING_AND_TRICK, 1,
            TEXT ("IMediaSeeking::SetPosition(); returning llStop = %I64d (%d sec)"),
            (* pStop), DShowTimeToSeconds (* pStop)) ;
    }

    cleanup :

    SeekingUnlock_ () ;

    return hr ;
}

// Get StartPosition & StopTime
// Either pointer may be null, implying not interested
STDMETHODIMP
CDVRIMediaSeeking::GetPositions (
    OUT LONGLONG *  pStart,
    OUT LONGLONG *  pStop
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetPositions ()")) ;

    hr = S_OK ;

    SeekingLock_ () ;

    if (pStart) {
        hr = GetCurrentPosition (pStart) ;
    }

    if (pStop &&
        SUCCEEDED (hr)) {
        hr = GetStopPosition (pStop) ;
    }

    SeekingUnlock_ () ;

    return hr ;
}

//  Get earliest / latest times to which we can currently seek
//  "efficiently".  This method is intended to help with graphs
//  where the source filter has a very high latency.  Seeking
//  within the returned limits should just result in a re-pushing
//  of already cached data.  Seeking beyond these limits may result
//  in extended delays while the data is fetched (e.g. across a
//  slow network).
//  (NULL pointer is OK, means caller isn't interested.)
STDMETHODIMP
CDVRIMediaSeeking::GetAvailable (
    OUT LONGLONG *  pEarliest,
    OUT LONGLONG *  pLatest
    )
{
    HRESULT     hr ;
    LONGLONG    llContentStart ;
    LONGLONG    llContentStop ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetAvailable ()")) ;

    hr = S_OK ;

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetAvailableContent (& llContentStart, & llContentStop) ;
    if (SUCCEEDED (hr)) {
        if (pEarliest) {
            (* pEarliest) = llContentStart ;
        }

        if (pLatest) {
            (* pLatest) = llContentStop ;
        }
    }

    SeekingUnlock_ () ;

    return hr ;
}

// Rate stuff
STDMETHODIMP
CDVRIMediaSeeking::SetRate (
    IN  double  dRate
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::SetRate ()")) ;

    if (dRate == 0.0) {
        return E_INVALIDARG ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> SetPlaybackRate (dRate) ;

    SeekingUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRIMediaSeeking::GetRate (
    OUT double *    pdRate
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetRate ()")) ;

    if (!pdRate) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetPlaybackRate (pdRate) ;

    SeekingUnlock_ () ;

    return hr ;
}

// Preroll
STDMETHODIMP
CDVRIMediaSeeking::GetPreroll (
    OUT LONGLONG *  pllPreroll
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRIMediaSeeking::GetPreroll ()")) ;

    if (!pllPreroll) {
        return E_POINTER ;
    }

    return E_NOTIMPL ;
}

//  ============================================================================
//  ============================================================================
//  ============================================================================

CDVRPinIMediaSeeking::CDVRPinIMediaSeeking (
    IN  CDVROutputPin *         pOutputPin,
    IN  CDVRDShowSeekingCore *  pSeekingCore
    ) : CDVRIMediaSeeking   (pOutputPin -> GetOwner (),
                             pSeekingCore),
        m_pOutputPin        (pOutputPin)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRPinIMediaSeeking")) ;

    ASSERT (m_pOutputPin) ;
}

CDVRPinIMediaSeeking::~CDVRPinIMediaSeeking (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRPinIMediaSeeking")) ;
}

//  ----------------------------------------------------------------------------
//  IMediaSeeking interface methods

//  returns S_OK if mode is supported, S_FALSE otherwise
STDMETHODIMP
CDVRPinIMediaSeeking::IsFormatSupported (
    IN  const GUID *    pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRPinIMediaSeeking::IsFormatSupported ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    //
    //  Designated seeking pin will be video, but we have 1 pin that is the
    //   designated seeking pin; all others don't do much
    //
    //  However, we need to support TIME_FORMAT_MEDIA_TIME or the graph
    //   code gets confused and starts using IMediaPosition
    if (SeekingCore_ () -> IsSeekingPin (m_pOutputPin)) {
        hr = CDVRIMediaSeeking::IsFormatSupported (pFormat) ;
    }
    else {
        hr = (pFormat == NULL || (* pFormat) == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE) ;
    }

    return hr ;
}

//  S_OK if successful
//  E_NOTIMPL, E_POINTER if unsuccessful
STDMETHODIMP
CDVRPinIMediaSeeking::QueryPreferredFormat (
    OUT GUID *  pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRPinIMediaSeeking::QueryPreferredFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    //  comment copied .. :-)
    /*  Don't care - they're all just as bad as one another */

    if (SeekingCore_ () -> IsSeekingPin (m_pOutputPin)) {
        hr = CDVRIMediaSeeking::QueryPreferredFormat (pFormat) ;
    }
    else {
        //  not the seeking pin, then we don't support anything
        (* pFormat) = TIME_FORMAT_NONE ;
        hr = S_OK ;
    }

    return hr ;
}

//  S_OK if successful
STDMETHODIMP
CDVRPinIMediaSeeking::GetTimeFormat (
    OUT GUID *  pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRPinIMediaSeeking::GetTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    if (SeekingCore_ () -> IsSeekingPin (m_pOutputPin)) {
        hr = CDVRIMediaSeeking::GetTimeFormat (pFormat) ;
    }
    else {
        (* pFormat) = TIME_FORMAT_NONE ;
        hr = S_OK ;
    }

    return hr ;
}

//  Returns S_OK if *pFormat is the current time format, otherwise
//  S_FALSE
//  This may be used instead of the above and will save the copying
//  of the GUID
STDMETHODIMP
CDVRPinIMediaSeeking::IsUsingTimeFormat (
    IN const GUID * pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRPinIMediaSeeking::IsUsingTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    if (SeekingCore_ () -> IsSeekingPin (m_pOutputPin)) {
        hr = CDVRIMediaSeeking::IsUsingTimeFormat (pFormat) ;
    }
    else {
        hr = (TIME_FORMAT_NONE == (* pFormat) ? S_OK : S_FALSE) ;
    }

    return hr ;
}

// (may return VFE_E_WRONG_STATE if graph is stopped)
STDMETHODIMP
CDVRPinIMediaSeeking::SetTimeFormat (
    IN const GUID * pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRPinIMediaSeeking::SetTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    //  first make sure we're the seeking pin
    if (SeekingCore_ () -> IsSeekingPin (m_pOutputPin)) {
        hr = CDVRIMediaSeeking::SetTimeFormat (pFormat) ;
    }
    else {
        //  ya sure.. no one cares what this is
        hr = ((* pFormat) == TIME_FORMAT_NONE ? S_OK : E_FAIL) ;
    }

    return hr ;
}

STDMETHODIMP
CDVRPinIMediaSeeking::GetCurrentPosition (
    OUT LONGLONG *  pStart
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRPinIMediaSeeking::GetCurrentPosition ()")) ;

    if (!pStart) {
        return E_POINTER ;
    }

    //
    //  existing implementations (e.g. mpeg-1 splitter) interpret this call
    //  as the start position
    //

    SeekingLock_ () ;

    hr = SeekingCore_ () -> GetFileStartPosition (pStart) ;

    SeekingUnlock_ () ;

    return hr ;
}

// Set Start and end positions in one operation
// Either pointer may be null, implying no change
STDMETHODIMP
CDVRPinIMediaSeeking::SetPositions (
    IN OUT  LONGLONG *  pStart,
    IN      DWORD       dwStartFlags,
    IN OUT  LONGLONG *  pStop,
    IN      DWORD       dwStopFlags
    )
{
    HRESULT     hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRPinIMediaSeeking::SetPositions ()")) ;

    //  must be the seeking pin
    if (!SeekingCore_ () -> IsSeekingPin (m_pOutputPin)) {
        return E_UNEXPECTED ;
    }

    hr = CDVRIMediaSeeking::SetPositions (
                pStart,
                dwStartFlags,
                pStop,
                dwStopFlags
                ) ;

    return hr ;
}

STDMETHODIMP
CDVRPinIMediaSeeking::SetRate (
    IN  double  dRate
    )
{
    HRESULT hr ;
    double  dCurRate ;

    //  cannot set the rate on this interface
    hr = GetRate (& dCurRate) ;
    if (SUCCEEDED (hr)) {
        hr = (dCurRate == dRate ? S_OK : E_NOTIMPL) ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrpins.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrpins.h

    Abstract:

        This module contains the DVR filters' pin-related declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__shared__dvrpins_h
#define __tsdvr__shared__dvrpins_h

//  ============================================================================
//  ============================================================================

TCHAR *
CreateOutputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    ) ;

TCHAR *
CreateInputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    ) ;

//  ============================================================================
//  ============================================================================

class CDVRTrickModeTime
{
} ;

//  ============================================================================
//  ============================================================================

class CIDVRPinConnectionEvents
{
    public :

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) = 0 ;

        virtual
        HRESULT
        OnInputBreakConnect (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        HRESULT
        OnQueryAccept (
            IN  const AM_MEDIA_TYPE *   pmt
            ) = 0 ;
} ;

//  ============================================================================
//  ============================================================================

class CIDVRDShowStream
{
    public :

        virtual
        HRESULT
        OnReceive (
            IN  int                             iPinIndex,
            IN  CDVRDShowToWMSDKTranslator *    pTranslator,
            IN  IMediaSample *                  pIMediaSample
            ) = 0 ;

        virtual
        HRESULT
        OnBeginFlush (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        HRESULT
        OnEndFlush (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        HRESULT
        OnEndOfStream (
            IN  int iPinIndex
            ) = 0 ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRPin
{
    int                     m_iBankStoreIndex ;     //  index into the holding bank
    CCritSec *              m_pFilterLock ;
    CMediaType              m_mtDVRPin ;            //  if connected : == m_mt
    BOOL                    m_fIsAudioOrVideo ;

    protected :

        CDVRPolicy *    m_pPolicy ;

        CMediaType * GetMediaType_ ()   { return & m_mtDVRPin ; }

        void FreePinMediaType_ ()       { ::FreeMediaType (m_mtDVRPin) ; }

        BOOL IsEqual_ (IN const AM_MEDIA_TYPE * pmt)
        {
            CMediaType  mt ;

            mt = (* pmt) ;

            return (mt == m_mtDVRPin ? TRUE : FALSE) ;
        }

    public :

        CDVRPin (
            IN  CCritSec *          pFilterLock,
            IN  CDVRPolicy *        pPolicy
            ) : m_iBankStoreIndex   (UNDEFINED),
                m_pFilterLock       (pFilterLock),
                m_pPolicy           (pPolicy),
                m_fIsAudioOrVideo   (FALSE)
        {
            ASSERT (m_pFilterLock) ;
            ASSERT (m_pPolicy) ;

            m_pPolicy -> AddRef () ;

            m_mtDVRPin.InitMediaType () ;
            m_mtDVRPin.majortype    = GUID_NULL ;
            m_mtDVRPin.subtype      = GUID_NULL ;
            m_mtDVRPin.formattype   = GUID_NULL ;
        }

        virtual
        ~CDVRPin ()
        {
            m_pPolicy -> Release () ;
        }

        //  --------------------------------------------------------------------
        //  class methods

        void SetBankStoreIndex (IN int iIndex)  { m_iBankStoreIndex = iIndex ; }
        int  GetBankStoreIndex ()               { return m_iBankStoreIndex ; }

        BOOL IsAV ()                            { return m_fIsAudioOrVideo ; }

        HRESULT
        SetPinMediaType (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        GetPinMediaType (
            OUT AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        GetPinMediaTypeCopy (
            OUT CMediaType **   ppmt
            ) ;
} ;

//  ============================================================================
//  ============================================================================

template <class T>
class CTDVRPinBank
{
    enum {
        //  this our allocation unit i.e. pin pointers are allocated 1 block
        //   at a time and this is the block size
        PIN_BLOCK_SIZE = 5
    } ;

    TCNonDenseVector <CBasePin *>   m_Pins ;

    public :

        CTDVRPinBank (
            ) : m_Pins  (NULL,
                         PIN_BLOCK_SIZE
                         ) {}

        virtual
        ~CTDVRPinBank (
            ) {}

        int PinCount ()     { return m_Pins.ValCount () ; }

        T *
        GetPin (
            IN int iIndex
            )
        {
            DWORD       dw ;
            CBasePin *  pPin ;

            dw = m_Pins.GetVal (
                    iIndex,
                    & pPin
                    ) ;

            if (dw != NOERROR) {
                //  most likely out of range
                pPin = NULL ;
            }

            return reinterpret_cast <T *> (pPin) ;
        }

        HRESULT
        AddPin (
            IN  CBasePin *  pPin,
            IN  int         iPinIndex
            )
        {
            HRESULT hr ;
            DWORD   dw ;

            dw = m_Pins.SetVal (
                    pPin,
                    iPinIndex
                    ) ;

            hr = HRESULT_FROM_WIN32 (dw) ;

            return hr ;
        }

        HRESULT
        AddPin (
            IN  CBasePin *  pPin,
            OUT int *       piPinIndex
            )
        {
            DWORD   dw ;

            dw = m_Pins.AppendVal (
                    pPin,
                    piPinIndex
                    ) ;

            return HRESULT_FROM_WIN32 (dw) ; ;
        }

        virtual
        HRESULT
        OnCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            )
        {
            return S_OK ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CDVRInputPin :
    public CBaseInputPin,
    public CDVRPin
{
    CIDVRPinConnectionEvents *      m_pIPinConnectEvent ;
    CIDVRDShowStream *              m_pIDShowStream ;
    CCritSec *                      m_pRecvLock ;
    CDVRDShowToWMSDKTranslator  *   m_pTranslator ;

    void LockFilter_ ()         { CBaseInputPin::m_pLock -> Lock () ;      }
    void UnlockFilter_ ()       { CBaseInputPin::m_pLock -> Unlock () ;    }

    void LockRecv_ ()           { m_pRecvLock -> Lock () ; }
    void UnlockRecv_ ()         { m_pRecvLock -> Unlock () ; }

    public :

        CDVRInputPin (
            IN  TCHAR *                     pszPinName,
            IN  CBaseFilter *               pOwningFilter,
            IN  CIDVRPinConnectionEvents *  pIPinConnectEvent,
            IN  CIDVRDShowStream *          pIDShowStream,
            IN  CCritSec *                  pFilterLock,
            IN  CCritSec *                  pRecvLock,
            IN  CDVRPolicy *                pPolicy,
            OUT HRESULT *                   phr
            ) ;

        ~CDVRInputPin (
            ) ;

        void SetPinConnectEvent (CIDVRPinConnectionEvents * pIPinConnectEvent)      { m_pIPinConnectEvent      = pIPinConnectEvent ; }
        void SetDShowStreamEvent (CIDVRDShowStream * pIDShowStream)                 { m_pIDShowStream   = pIDShowStream ; }

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        virtual
        HRESULT
        CompleteConnect (
            IN  IPin *  pReceivePin
            ) ;

        virtual
        HRESULT
        BreakConnect (
            ) ;

        STDMETHODIMP
        QueryAccept (
            IN  const AM_MEDIA_TYPE *   pmt
            ) ;

        STDMETHODIMP
        Receive (
            IN  IMediaSample *  pIMS
            ) ;

        HRESULT
        Active (
            IN  BOOL    fInlineProps
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVROutputPin :
    public CBaseOutputPin,
    public CDVRPin,
    public IMemAllocator,
    public IAMPushSource
{
    protected :

        enum DVR_SEG_OUTPUT_PIN_STATE {
            //  drops a media sample if in this state and not a suitable segment
            //    boundary packet, as determined by FirstSegmentSampleOk_ ());
            //    default state after a seek occurs
            STATE_WAIT_NEW_SEGMENT,

            //  sends all media samples sent; never posts a new segment
            //    notification
            STATE_IN_SEGMENT,
        } ;

        enum {
            MAX_RATE_SEGMENTS = 32
        } ;

        COutputQueue *                      m_pOutputQueue ;
        long                                m_cbBuffer ;
        long                                m_cBuffers ;
        long                                m_cbAlign ;
        long                                m_cbPrefix ;
        CDVRPinIMediaSeeking                m_IMediaSeeking ;
        BOOL                                m_fTimestampedMedia ;
        DVR_SEG_OUTPUT_PIN_STATE            m_DVRSegOutputPinState ;
        CDVRDShowSeekingCore *              m_pSeekingCore ;
        CDVRSourcePinManager *              m_pOwningPinBank ;
        BOOL                                m_fIsPlayrateCompatible ;
        CDVRWMSDKToDShowTranslator *        m_pTranslator ;
        BOOL                                m_fFlagDiscontinuityNext ;
        BOOL                                m_fMediaCompatible ;
        REFERENCE_TIME                      m_rtNewRateStart ;
        CTTimestampRate <REFERENCE_TIME>    m_PTSRate ;

        void LockFilter_ ()       { CBaseOutputPin::m_pLock -> Lock () ;      }
        void UnlockFilter_ ()     { CBaseOutputPin::m_pLock -> Unlock () ;    }

        virtual
        BOOL
        FirstSegmentSampleOk_ (
            IN OUT  IMediaSample2 * pIMS2
            ) ;

        virtual
        void
        ScaleTimestamps_ (
            IN OUT  IMediaSample2 * pIMS2
            ) ;

        REFERENCE_TIME
        RateStartPTS_ (
            )
        {
            REFERENCE_TIME  rtRateStartPTS ;
            m_pSeekingCore -> GetCurPlaytime (& rtRateStartPTS) ;
            return rtRateStartPTS ;
        }

    public :

        CDVROutputPin (
            IN  CDVRPolicy *            pPolicy,
            IN  TCHAR *                 pszPinName,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  CDVRSourcePinManager *  pOwningPinBank,
            OUT HRESULT *               phr
            ) ;

        virtual
        ~CDVROutputPin (
            ) ;

        DECLARE_IUNKNOWN ;

        //  for IMemAllocator, IAMPushSource, IMediaSeeking
        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        virtual
        BOOL
        IsFullFrameRateSupported (
            IN  double  dRate
            )
        {
            return (dRate == _1X_PLAYBACK_RATE ? TRUE : FALSE) ;
        }

        virtual
        BOOL
        IsFrameRateSupported (
            IN  double  dRate
            )
        {
            return IsFullFrameRateSupported (dRate) ;
        }

        virtual BOOL SupportTrickMode ()    { return TRUE ; }

        //  we don't morph the timestamps, so the decoders must be told of the
        //    new rate, even if they are muted
        virtual HRESULT SetCurRate (IN double dRate, IN REFERENCE_TIME rtNewRateStart) ;

        //  assume frame-semantics for the media samples
        virtual BOOL IsKeyFrameStart (IN IMediaSample2 * pIMS2) { return (pIMS2 -> IsSyncPoint () == S_OK ? TRUE : FALSE) ; }
        virtual BOOL IsKeyFrame (IN IMediaSample2 * pIMS2)      { return IsKeyFrameStart (pIMS2) ; }

        virtual
        BOOL
        IsKeyFrameStart (
            IN  INSSBuffer *    pINSSBuffer
            ) ;

        virtual BOOL IsPrimaryTrickModeStream ()    { return FALSE ; }
        virtual BOOL AlwaysSeekOnRateChange ()      { return TRUE ; }
        virtual BOOL IsRateStartPTSDiscStream ()    { return ::IsAudio (GetMediaType_ ()) ; }

        HRESULT
        SendSample (
            IN  IMediaSample2 * pIMS2,
            IN  AM_MEDIA_TYPE * pmtNew
            ) ;

        CDVRWMSDKToDShowTranslator * GetTranslator ()  { return m_pTranslator ; }

        void SetPlayrateCompatible (IN BOOL f) ;
        BOOL IsPlayrateCompatible ()                { return m_fIsPlayrateCompatible ; }
        BOOL IsNotPlayrateCompatible ()             { return !IsPlayrateCompatible () ; }

        BOOL CannotSend ()                          { return (!CanSend ()) ; }
        BOOL CanSend ()                             { return IsConnected ()          &&
                                                             IsMediaCompatible () ; }

        void
        OnPTSPaddingIncrement (
            ) ;

        BOOL IsMediaCompatible ()                   { return m_fMediaCompatible ; }
        void SetMediaCompatible (IN BOOL f)         { m_fMediaCompatible = f ; }

        void FlagDiscontinuityNext (IN BOOL f)      { m_fFlagDiscontinuityNext = f ; }

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        SetPinMediaType (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        virtual
        HRESULT
        Active (
            ) ;

        HRESULT
        Inactive (
            ) ;

        HRESULT
        DecideAllocator (
            IN  IMemInputPin *      pPin,
            IN  IMemAllocator **    ppAlloc
            ) ;

        HRESULT
        DecideBufferSize (
            IN  IMemAllocator *         pAlloc,
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        BOOL
        QueryAcceptDynamicChange (
            IN  AM_MEDIA_TYPE * pmtNew
            ) ;

        HRESULT
        DeliverEndOfStream (
            ) ;

        HRESULT
        DeliverBeginFlush (
            ) ;

        HRESULT
        DeliverEndFlush (
            ) ;

        HRESULT
        NotifyNewSegment (
            IN  REFERENCE_TIME  rtStart,
            IN  REFERENCE_TIME  rtStop,
            IN  double          dRate
            ) ;

        void
        SetNewSegmentBoundary (
            ) ;

        void
        SendAllQueued (
            ) ;

        //  ====================================================================
        //  IMemAllocator

        STDMETHODIMP
        SetProperties(
            IN  ALLOCATOR_PROPERTIES *  pRequest,
            OUT ALLOCATOR_PROPERTIES *  pActual
            ) ;

        STDMETHODIMP
        GetProperties(
            OUT ALLOCATOR_PROPERTIES *  pProps
            ) ;

        STDMETHODIMP
        Commit (
            ) ;

        STDMETHODIMP
        Decommit (
            ) ;

        STDMETHODIMP
        GetBuffer (
            OUT IMediaSample **     ppBuffer,
            OUT REFERENCE_TIME *    pStartTime,
            OUT REFERENCE_TIME *    pEndTime,
            IN  DWORD               dwFlags
            ) ;

        STDMETHODIMP
        ReleaseBuffer (
            IN  IMediaSample *  pBuffer
            ) ;

        //  ====================================================================
        //  IAMPushSource

        STDMETHODIMP
        GetPushSourceFlags (
            OUT ULONG * pFlags
            )
        {
            //  set this purely to get around an ASSERT in quartz
            if (pFlags == NULL) {
                return E_POINTER ;
            }

            //  we're not live in the strict sense; strict sense is that we are
            //   received stored content i.e. non-live content is being pushed
            //   (broadcast) to us.
            (* pFlags) = AM_PUSHSOURCECAPS_NOT_LIVE ;

            return S_OK ;
        }

        STDMETHODIMP
        SetPushSourceFlags (
            IN  ULONG Flags
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        SetStreamOffset (
            IN  REFERENCE_TIME  rtOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        GetStreamOffset (
            OUT REFERENCE_TIME  * prtOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        GetMaxStreamOffset (
            OUT REFERENCE_TIME  * prtMaxOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        SetMaxStreamOffset (
            IN  REFERENCE_TIME  rtMaxOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        GetLatency(
            IN  REFERENCE_TIME  * prtLatency
            )
        {
            return E_NOTIMPL ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CDVDRateChange
{
    enum {
        COMPATIBLE_TRICK_MODE_VERSION = 0x0101
    } ;

    BOOL            m_fMaxForwardRateQueried ;  //  query just once; first time we are asked
    double          m_dMaxForwardRate ;         //  signed value

    BOOL            m_fMaxReverseRateQueried ;  //  query just once; first time we are asked
    double          m_dMaxReverseRate ;         //  signed value i.e. -1 is 1x reverse mode playback

    BOOL            m_fTrickSupportQueried ;
    BOOL            m_fTrickSupport ;

    public :

        CDVDRateChange (
            ) : m_dMaxForwardRate           (_1X_PLAYBACK_RATE),
                m_dMaxReverseRate           (m_dMaxForwardRate),        //  init the same
                m_fMaxReverseRateQueried    (FALSE),
                m_fMaxForwardRateQueried    (FALSE),
                m_fTrickSupportQueried      (FALSE),
                m_fTrickSupport             (FALSE) {}

        HRESULT
        NotifyMpeg2DecoderNewRate (
            IN  IMemInputPin *  pInputPin,
            IN  double          dNewRate,
            IN  REFERENCE_TIME  rtStartNewRate
            ) ;

        double
        MaxForwardFullFrameRate (
            IN  IMemInputPin *  pInputPin
            ) ;

        double
        MaxReverseFullFrameRate (
            IN  IMemInputPin *  pInputPin
            ) ;

        BOOL
        PinSupportsRateChange (
            IN  IMemInputPin *  pInputPin,
            IN  BOOL            fCheckVersion
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRMpeg2AudioOutputPin :
    public      CDVROutputPin,
    protected   CDVDRateChange
{
    protected :

        virtual
        void
        ScaleTimestamps_ (
            IN OUT  IMediaSample2 * pIMS2
            ) ;

    public :

        CDVRMpeg2AudioOutputPin (
            IN  CDVRPolicy *            pPolicy,
            IN  TCHAR *                 pszPinName,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  CDVRSourcePinManager *  pOwningPinBank,
            OUT HRESULT *               phr
            ) : CDVROutputPin   (pPolicy,
                                 pszPinName,
                                 pOwningFilter,
                                 pFilterLock,
                                 pSeekingCore,
                                 pDVRSendStatsWriter,
                                 pOwningPinBank,
                                 phr
                                 )
        {
            g_fUseRateChange11 = TRUE ;
        }

        virtual BOOL AlwaysSeekOnRateChange ()          { return FALSE ; }

        virtual BOOL SupportTrickMode ()
        {
            if (IsConnected ()) {
                ASSERT (m_pInputPin) ;
                return PinSupportsRateChange (m_pInputPin, m_pPolicy -> Settings () -> CheckTricMpeg2TrickModeInterface ()) ;
            }
            else {
                return FALSE ;
            }
        }

        virtual
        HRESULT
        Active (
            ) ;

        virtual
        BOOL
        IsFullFrameRateSupported (
            IN  double  dRate
            ) ;

        virtual
        BOOL
        IsFrameRateSupported (
            IN  double  dRate
            ) ;

        virtual
        HRESULT
        SetCurRate (
            IN double           dRate,
            IN REFERENCE_TIME   rtNewRateStart
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRDolbyAC3AudioOutputPin :
    public      CDVROutputPin,
    protected   CDVDRateChange
{
    protected :

        virtual
        void
        ScaleTimestamps_ (
            IN OUT  IMediaSample2 * pIMS2
            ) ;

    public :

        CDVRDolbyAC3AudioOutputPin (
            IN  CDVRPolicy *            pPolicy,
            IN  TCHAR *                 pszPinName,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  CDVRSourcePinManager *  pOwningPinBank,
            OUT HRESULT *               phr
            ) : CDVROutputPin   (pPolicy,
                                 pszPinName,
                                 pOwningFilter,
                                 pFilterLock,
                                 pSeekingCore,
                                 pDVRSendStatsWriter,
                                 pOwningPinBank,
                                 phr
                                 )
        {
            g_fUseRateChange11 = TRUE ;
        }

        virtual BOOL AlwaysSeekOnRateChange ()          { return FALSE ; }

        virtual BOOL SupportTrickMode ()
        {
            if (IsConnected ()) {
                ASSERT (m_pInputPin) ;
                return PinSupportsRateChange (m_pInputPin, m_pPolicy -> Settings () -> CheckTricMpeg2TrickModeInterface ()) ;
            }
            else {
                return FALSE ;
            }
        }

        virtual
        HRESULT
        Active (
            ) ;

        virtual
        BOOL
        IsFrameRateSupported (
            IN  double  dRate
            ) ;

        virtual
        BOOL
        IsFullFrameRateSupported (
            IN  double  dRate
            ) ;

        virtual
        HRESULT
        SetCurRate (
            IN double           dRate,
            IN REFERENCE_TIME   rtNewRateStart
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRVideoOutputPin :
    public CDVROutputPin
{
    public :

        CDVRVideoOutputPin (
            IN  CDVRPolicy *            pPolicy,
            IN  TCHAR *                 pszPinName,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  CDVRSourcePinManager *  pOwningPinBank,
            OUT HRESULT *               phr
            ) : CDVROutputPin   (pPolicy,
                                 pszPinName,
                                 pOwningFilter,
                                 pFilterLock,
                                 pSeekingCore,
                                 pDVRSendStatsWriter,
                                 pOwningPinBank,
                                 phr
                                 ) {}

        virtual BOOL IsPrimaryTrickModeStream ()    { return TRUE ; }

        virtual
        BOOL
        IsFullFrameRateSupported (
            IN  double  dRate
            ) ;

        virtual
        BOOL
        IsFrameRateSupported (
            IN  double  dRate
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRMpeg2VideoOutputPin :
    public      CDVRVideoOutputPin,
    protected   CDVDRateChange
{
    BOOL
    GenerateTimestamps_ (
        IN OUT  IMediaSample2 * pIMS2
        ) ;

    protected :

        virtual
        BOOL
        FirstSegmentSampleOk_ (
            IN OUT  IMediaSample2 * pIMS2
            ) ;

        virtual
        void
        ScaleTimestamps_ (
            IN OUT  IMediaSample2 * pIMS2
            ) ;

    public :

        CDVRMpeg2VideoOutputPin (
            IN  CDVRPolicy *            pPolicy,
            IN  TCHAR *                 pszPinName,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  CDVRSourcePinManager *  pOwningPinBank,
            OUT HRESULT *               phr
            ) : CDVRVideoOutputPin  (pPolicy,
                                     pszPinName,
                                     pOwningFilter,
                                     pFilterLock,
                                     pSeekingCore,
                                     pDVRSendStatsWriter,
                                     pOwningPinBank,
                                     phr
                                     )
        {
            g_fUseRateChange11 = TRUE ;
        }

        virtual BOOL AlwaysSeekOnRateChange ()          { return FALSE ; }

        virtual BOOL SupportTrickMode ()
        {
            if (IsConnected ()) {
                ASSERT (m_pInputPin) ;
                return PinSupportsRateChange (m_pInputPin, m_pPolicy -> Settings () -> CheckTricMpeg2TrickModeInterface ()) ;
            }
            else {
                return FALSE ;
            }
        }

        virtual
        HRESULT
        Active (
            ) ;

        virtual
        BOOL
        IsFullFrameRateSupported (
            IN  double  dRate
            ) ;

        virtual
        BOOL
        IsFrameRateSupported (
            IN  double  dRate
            ) ;

        virtual
        HRESULT
        SetCurRate (
            IN double           dRate,
            IN REFERENCE_TIME   rtNewRateStart
            ) ;

        virtual
        BOOL
        IsKeyFrameStart (
            IN  IMediaSample2 *     pIMS2
            ) ;

        virtual
        BOOL
        IsKeyFrame (
            IN  IMediaSample2 *     pIMS2
            ) ;

        virtual
        BOOL
        IsKeyFrameStart (
            IN  INSSBuffer *    pINSSBuffer
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRSinkPinManager :
    public CTDVRPinBank <CDVRInputPin>,
    public CIDVRPinConnectionEvents
{
    BOOL
    InlineDShowProps_ (
        ) ;

    protected :

        CIDVRDShowStream *          m_pIDVRDShowStream ;        //  set on pins we create
        CBaseFilter *               m_pOwningFilter ;           //  owning filter
        CCritSec *                  m_pFilterLock ;             //  owning filter lock
        CCritSec *                  m_pRecvLock ;
        CDVRWriterProfile           m_DVRWriterProfile ;               //  WM profile
        int                         m_cMaxInputPins ;
        CDVRPolicy *                m_pPolicy ;

        void FilterLock_ ()     { m_pFilterLock -> Lock () ;      }
        void FilterUnlock_ ()   { m_pFilterLock -> Unlock () ;    }

        HRESULT
        CreateNextInputPin_ (
            ) ;

        BOOL
        DisconnectedPins_ (
            ) ;

    public :

        CDVRSinkPinManager (
            IN  CDVRPolicy *            pPolicy,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CCritSec *              pRecvLock,
            IN  CIDVRDShowStream *      pIDVRDShowStream,
            OUT HRESULT *               phr
            ) ;

        ~CDVRSinkPinManager (
            ) ;

        HRESULT
        Active (
            ) ;

        HRESULT
        Inactive (
            ) ;

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        virtual
        HRESULT
        OnInputBreakConnect (
            IN  int iPinIndex
            ) ;

        virtual
        HRESULT
        OnQueryAccept (
            IN  const AM_MEDIA_TYPE *   pmt
            ) ;

        HRESULT GetRefdWMProfile (OUT IWMProfile ** ppIWMProfile)   { return m_DVRWriterProfile.GetRefdWMProfile (ppIWMProfile) ; }
        DWORD GetProfileStreamCount ()                              { return m_DVRWriterProfile.GetStreamCount () ; }
} ;

class CDVRThroughSinkPinManager :
    public CDVRSinkPinManager
{
    CIDVRPinConnectionEvents *  m_pIDVRInputPinConnectEvents ;

    public :

        CDVRThroughSinkPinManager (
            IN  CDVRPolicy *                pPolicy,
            IN  CBaseFilter *               pOwningFilter,
            IN  CCritSec *                  pFilterLock,
            IN  CCritSec *                  pRecvLock,
            IN  CIDVRDShowStream *          pIDVRDShowStream,
            IN  CIDVRPinConnectionEvents *  pIDVRInputPinConnectEvents,
            OUT HRESULT *               phr
            ) : CDVRSinkPinManager      (pPolicy,
                                         pOwningFilter,
                                         pFilterLock,
                                         pRecvLock,
                                         pIDVRDShowStream,
                                         phr
                                         ),
                m_pIDVRInputPinConnectEvents (pIDVRInputPinConnectEvents)
        {
            ASSERT (m_pIDVRInputPinConnectEvents) ;
        }

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;
} ;

class CDVRSourcePinManager :
    public CTDVRPinBank <CDVROutputPin>
{
    CBaseFilter *           m_pOwningFilter ;
    CCritSec *              m_pFilterLock ;
    CDVRReaderProfile *     m_pWMReaderProfile ;
    CTSmallMap <WORD, int>  m_StreamNumToPinIndex ;
    CDVRPolicy *            m_pPolicy ;
    CDVRDShowSeekingCore *  m_pSeekingCore ;
    int                     m_iVideoPinIndex ;
    CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;
    BOOL                    m_fIsLiveSource ;
    LONG                    m_lFlushingRef ;

    void FilterLock_ ()     { m_pFilterLock -> Lock () ;      }
    void FilterUnlock_ ()   { m_pFilterLock -> Unlock () ;    }

    public :

        CDVRSourcePinManager (
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  BOOL                    fIsLiveSource = FALSE
            ) ;

        virtual
        ~CDVRSourcePinManager (
            ) ;

        BOOL IsSeekingPin (CDVROutputPin *) ;

        void SetLiveSource (IN BOOL f)  { m_fIsLiveSource = f ; }
        BOOL IsLiveSource ()            { return m_fIsLiveSource ; }

        HRESULT
        SetReaderProfile (
            IN  CDVRReaderProfile * pWMReaderProfile
            ) ;

        //  accumulates sending flag & format-compatible connected pins
        int
        SendingPinCount (
            ) ;

        int
        ConnectedCount (
            ) ;

        BOOL
        IsFullFrameRateSupported (
            IN  double  dRate
            ) ;

        BOOL
        IsFrameRateSupported (
            IN  double  dRate
            ) ;

        BOOL
        SupportTrickMode (
            ) ;

        HRESULT
        CreateOutputPin (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        Active (
            ) ;

        HRESULT
        Inactive (
            ) ;

        int
        PinIndexFromStreamNumber (
            IN  WORD    wStreamNum
            ) ;

        CDVROutputPin *
        GetNonRefdOutputPin (
            IN  int iPinIndex
            )
        {
            return reinterpret_cast <CDVROutputPin *> (GetPin (iPinIndex)) ;
        }

        CDVROutputPin *
        GetNonRefdOutputPin (
            IN  WORD    wStreamNum
            ) ;

        HRESULT
        DeliverBeginFlush (
            ) ;

        HRESULT
        DeliverEndFlush (
            ) ;

        BOOL
        IsFlushing (
            ) ;

        HRESULT
        DeliverEndOfStream (
            ) ;

        void
        SetNewSegmentBoundary (
            ) ;

        HRESULT
        NotifyNewSegment (
            IN  REFERENCE_TIME  rtStart,
            IN  REFERENCE_TIME  rtStop,
            IN  double          dRate
            ) ;

        void
        SendAllQueued (
            ) ;

        void
        OnPTSPaddingIncrement (
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrpins_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrfilters\shared\dvrprof.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrprof.cpp

    Abstract:

        This module contains the code for our DShow - WMSDK_Profiles layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"

HRESULT
IndexStreamId (
    IN  IWMProfile *    pIWMProfile,
    OUT WORD *          pwStreamId
    )
{
    IWMStreamConfig *   pIWMStreamConfig ;
    DWORD               dwStreamCount ;
    HRESULT             hr ;
    WORD                w ;
    GUID                guidStreamType ;

    ASSERT (pIWMProfile) ;
    ASSERT (pwStreamId) ;

    hr = pIWMProfile -> GetStreamCount (& dwStreamCount) ;

    //  default to 1
    (* pwStreamId) = 1 ;

    //  but look for a video stream
    for (w = 1; w <= dwStreamCount && SUCCEEDED (hr); w++) {
        hr = pIWMProfile -> GetStreamByNumber (w, & pIWMStreamConfig) ;
        if (SUCCEEDED (hr)) {
            hr = pIWMStreamConfig -> GetStreamType (& guidStreamType) ;
            if (SUCCEEDED (hr)) {
                if (DShowWMSDKHelpers::IsWMVideoStream (guidStreamType)) {
                    (* pwStreamId) = w ;
                    pIWMStreamConfig -> Release () ;
                    break ;
                }
            }

            pIWMStreamConfig -> Release () ;
        }
    }

    return hr ;
}

static
REFGUID
WMStreamType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    static GUID     guidStreamType ;
    HRESULT         hr ;
    WM_MEDIA_TYPE   Wmt ;

    hr = DShowWMSDKHelpers::TranslateDShowToWM (
            pmt,
            & Wmt
            ) ;

    if (SUCCEEDED (hr)) {
        guidStreamType = Wmt.majortype ;

        FreeMediaType (* (AM_MEDIA_TYPE *) & Wmt) ;
    }
    else {
        //  pass it straight through
        guidStreamType = pmt -> majortype ;
    }

    return guidStreamType ;
}

//  don't suck in ws2_32.dll just to do this
#define DVR_NTOHL(l)                                    \
                    ( (((l) & 0xFF000000) >> 24)    |   \
                      (((l) & 0x00FF0000) >> 8)     |   \
                      (((l) & 0x0000FF00) << 8)     |   \
                      (((l) & 0x000000FF) << 24) )

static
BOOL
IsFourCCVBR (
    IN  DWORD   biCompression       //  from BITMAPINFOHEADER
    )
{
    BOOL    r ;

    //  see http://www.microsoft.com/hwdev/devdes/fourcc.htm

    //  make sure we're big-endian
    biCompression = DVR_NTOHL (biCompression) ;

    if (biCompression == 0x4D503432) {      //  MP42
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

static
DWORD
GetStreamAvgBitRate (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    DWORD   dwRet ;

    ASSERT (pmt) ;

    //  ========================================================================
    //  mpeg-1 video
    if (pmt -> formattype   == FORMAT_MPEGVideo         &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof MPEG1VIDEOINFO) {

        dwRet = reinterpret_cast <MPEG1VIDEOINFO *> (pmt -> pbFormat) -> hdr.dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-2 video
    else if (pmt -> formattype == FORMAT_MPEG2Video     &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof MPEG2VIDEOINFO) {

        dwRet = reinterpret_cast <MPEG2VIDEOINFO *> (pmt -> pbFormat) -> hdr.dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-2 video
    else if (pmt -> formattype == FORMAT_VideoInfo      &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof MPEG2VIDEOINFO) {

        dwRet = reinterpret_cast <VIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-2 video
    else if (pmt -> formattype == FORMAT_VideoInfo2     &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof VIDEOINFOHEADER2) {

        dwRet = reinterpret_cast <VIDEOINFOHEADER2 *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  audio
    else if (pmt -> formattype == FORMAT_WaveFormatEx   &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof WAVEFORMATEX) {

        dwRet = reinterpret_cast <WAVEFORMATEX *> (pmt -> pbFormat) -> nAvgBytesPerSec * 8 ;
    }
    //  ========================================================================
    //  dv
    else if (pmt -> majortype == MEDIATYPE_Interleaved  &&
             pmt -> subtype   == MEDIASUBTYPE_dvsd      &&
             pmt -> formattype == FORMAT_DvInfo         &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof DVINFO) {

        // Type 1 DV - will be saved as a generic stream
        dwRet = 25000000;
    }
    //  ========================================================================
    //  dvsd
    else if (pmt -> majortype == MEDIATYPE_Video         &&
             pmt -> subtype   == MEDIASUBTYPE_dvsd       &&
             pmt -> formattype == FORMAT_VideoInfo       &&
             pmt -> pbFormat                             &&
             pmt -> cbFormat >= sizeof FORMAT_VideoInfo) {

        // Type 2 DV

        VIDEOINFO* pFormat = (VIDEOINFO*) pmt -> pbFormat;

        pFormat -> dwBitRate = 25000000;
        pFormat -> bmiHeader.biCompression = pmt -> subtype.Data1;

        dwRet = 25000000;
    }
    //  ========================================================================
    //  mpeg-4 - 3
    else if (pmt -> majortype   == MEDIATYPE_Video          &&
             pmt -> subtype     == WMMEDIASUBTYPE_MP43      &&
             pmt -> formattype  == WMFORMAT_VideoInfo       &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-4 - S
    else if (pmt -> majortype   == MEDIATYPE_Video          &&
             pmt -> subtype     == WMMEDIASUBTYPE_MP4S      &&
             pmt -> formattype  == WMFORMAT_VideoInfo       &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  wmv1
    else if (pmt -> majortype   == MEDIATYPE_Video          &&
             pmt -> subtype     == WMMEDIASUBTYPE_WMV1      &&
             pmt -> formattype  == WMFORMAT_VideoInfo       &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  fourcc
    else if (IsVideo (pmt)                                      &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER    &&
             IsFourCCVBR (reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> bmiHeader.biCompression)) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  other ??
    else {
        dwRet = UNDEFINED ; //  this means we don't know
    }

    //  don't return 0; WMSDK will divide by 0
    return (dwRet != 0 ? dwRet : 1) ;
}

static
DWORD
MinBitrate (
    IN AM_MEDIA_TYPE * pmt
    )
{
    DWORD   dwRet ;

    ASSERT (pmt) ;

    //  ========================================================================
    //  mpeg-2
    if (IsVideo (pmt)                                   &&
        pmt -> subtype      == MEDIASUBTYPE_MPEG2_VIDEO &&
        pmt -> formattype   == FORMAT_MPEG2Video        &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof FORMAT_MPEG2Video) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  mpeg-4 - 3
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP43     &&
             pmt -> formattype   == WMFORMAT_VideoInfo      &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  mpeg-4 - S
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP4S     &&
             pmt -> formattype   == WMFORMAT_VideoInfo      &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  wmv1
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype      == WMMEDIASUBTYPE_WMV1     &&
             pmt -> formattype   == WMFORMAT_VideoInfo      &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  wmv2
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype      == WMMEDIASUBTYPE_WMV2     &&
             pmt -> formattype   == WMFORMAT_VideoInfo      &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  wmv3
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype     == WMMEDIASUBTYPE_WMV3      &&
             pmt -> formattype  == WMFORMAT_VideoInfo       &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  fourcc
    else if (IsVideo (pmt)                                      &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER    &&
             IsFourCCVBR (reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> bmiHeader.biCompression)) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  other - default to avg
    else {
        dwRet = GetStreamAvgBitRate (pmt) ;
    }

    return dwRet ;
}

static
DWORD
MaxBitrate (
    IN AM_MEDIA_TYPE * pmt
    )
{
    MPEG2VIDEOINFO *    pMpeg2videoInfo ;
    WMVIDEOINFOHEADER * pWMVideoInfoHeader ;
    DWORD               dwRet ;
    DWORD               dwBitsPerFrame ;
    DWORD               dwFramesPerSecond ;

    ASSERT (pmt) ;

    //  ========================================================================
    //  mpeg-2
    if (IsVideo (pmt)                                   &&
        pmt -> subtype      == MEDIASUBTYPE_MPEG2_VIDEO &&
        pmt -> formattype   == FORMAT_MPEG2Video        &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof FORMAT_MPEG2Video) {

        pMpeg2videoInfo = reinterpret_cast <MPEG2VIDEOINFO *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pMpeg2videoInfo -> hdr.bmiHeader.biWidth *
                         pMpeg2videoInfo -> hdr.bmiHeader.biHeight *
                         (pMpeg2videoInfo -> hdr.bmiHeader.biBitCount != 0 ? pMpeg2videoInfo -> hdr.bmiHeader.biBitCount : 8) ;

        if (pMpeg2videoInfo -> hdr.AvgTimePerFrame != 0) {
            dwFramesPerSecond = (DWORD) (UNITS / pMpeg2videoInfo -> hdr.AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  mpeg-4 - 3
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP43         &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  mpeg-4 - S
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP4S         &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  wmv1
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype      == WMMEDIASUBTYPE_WMV1         &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  wmv2
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype      == WMMEDIASUBTYPE_WMV2         &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  wmv3
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype     == WMMEDIASUBTYPE_WMV3          &&
             pmt -> formattype  == WMFORMAT_VideoInfo           &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  fourcc
    else if (IsVideo (pmt)                                      &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER    &&
             IsFourCCVBR (reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> bmiHeader.biCompression)) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  other - default to avg
    else {
        dwRet = GetStreamAvgBitRate (pmt) ;
    }

    //  don't return 0; WMSDK faults with divide by 0 error
    return (dwRet > 0 ? dwRet : 1) ;
}

static
WCHAR *
GetWMStreamName (
    IN  LONG            lIndex,
    IN  AM_MEDIA_TYPE * pmt,
    IN  WCHAR *         achBuffer,
    IN  LONG            lBufferLen
    )
{
    int     i ;
    WCHAR * pszRet ;

    i = _snwprintf (
                achBuffer,
                lBufferLen,
                L"%s (%d)",
                (pmt -> majortype == MEDIATYPE_Video ? WM_MEDIA_VIDEO_TYPE_NAME :
                 (pmt -> majortype == MEDIATYPE_Audio ? WM_MEDIA_AUDIO_TYPE_NAME : WM_MEDIA_DATA_TYPE_NAME
                  )
                 ),
                lIndex
                ) ;

    //  if there was no buffer overrun, and
    //      we have room for a NULL terminator
    if (i > 0 &&
        i < lBufferLen) {

        //  cap it off and succeed
        achBuffer [i] = L'\0' ;
        pszRet = achBuffer ;
    }
    else {
        //  else fail the call
        pszRet = NULL ;
    }

    return pszRet ;
}

static
WCHAR *
GetWMConnectionName (
    IN  LONG            lIndex,
    IN  AM_MEDIA_TYPE * pmt,
    IN  WCHAR *         achBuffer,
    IN  LONG            lBufferLen
    )
{
    int     i ;
    WCHAR * pszRet ;

    pszRet = GetWMStreamName (
                    lIndex,
                    pmt,
                    achBuffer,
                    lBufferLen
                    ) ;
    if (pszRet) {
        i = _snwprintf (
                    achBuffer,
                    lBufferLen,
                    L"%s Connection",
                    pszRet
                    ) ;

        //  if there was no buffer overrun, and
        //      we have room for a NULL terminator
        if (i > 0 &&
            i < lBufferLen) {

            //  cap it off and succeed
            achBuffer [i] = L'\0' ;
            pszRet = achBuffer ;
        }
        else {
            //  else fail the call
            pszRet = NULL ;
        }
    }

    return pszRet ;
}

static
HRESULT
GetStreamMediaType (
    IN  IWMStreamConfig *   pIWMStreamConfig,
    OUT WM_MEDIA_TYPE **    ppWmt                   //  CoTaskMemFree to free
    )
{
    HRESULT         hr ;
    IWMMediaProps * pIWMMediaProps ;
    DWORD           dwSize ;
    BYTE *          pb ;

    ASSERT (ppWmt) ;
    ASSERT (pIWMStreamConfig) ;

    pb          = NULL ;
    (* ppWmt)   = NULL ;

    hr = pIWMStreamConfig -> QueryInterface (
            IID_IWMMediaProps,
            (void **) & pIWMMediaProps
            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (pIWMMediaProps) ;

        //  get the size
        hr = pIWMMediaProps -> GetMediaType (NULL, & dwSize) ;

        if (SUCCEEDED (hr)) {

            //  validate basic size
            if (dwSize >= sizeof WM_MEDIA_TYPE) {
                //  allocate
                pb = reinterpret_cast <BYTE *> (CoTaskMemAlloc (dwSize)) ;
                if (pb) {
                    //  and retrieve
                    hr = pIWMMediaProps -> GetMediaType ((WM_MEDIA_TYPE *) pb, & dwSize) ;

                    if (SUCCEEDED (hr)) {

                        //  set outgoing
                        (* ppWmt) = reinterpret_cast <WM_MEDIA_TYPE *> (pb) ;

                        //  is there a format block ?
                        if ((* ppWmt) -> cbFormat > 0) {
                            //  validate the size again; check at least that it's
                            //   bounded
                            if ((* ppWmt) -> cbFormat <= dwSize - sizeof WM_MEDIA_TYPE) {

                                //  set pbFormat member
                                (* ppWmt) -> pbFormat = pb + sizeof WM_MEDIA_TYPE ;
                            }
                            else {
                                hr = E_FAIL ;
                            }
                        }
                        else {
                            //  no format block exists
                            (* ppWmt) -> pbFormat = NULL ;
                        }
                    }
                }
            }
            else {
                //  size doesn't make sense
                hr = E_FAIL ;
            }
        }

        pIWMMediaProps -> Release () ;
    }

    //  if anything failed
    if (FAILED (hr)) {
        CoTaskMemFree (pb) ;
        (* ppWmt) = NULL ;
    }

    return hr ;
}

static
void
FreeWMMediaType (
    IN  WM_MEDIA_TYPE * pwmt
    )
{
    //
    //  don't free the pbFormat because we allocated a contiguous block of
    //   memory to hold it.. per the WMSDK instructions
    //

    if (pwmt -> pUnk) {
        pwmt -> pUnk -> Release () ;
    }

    CoTaskMemFree (pwmt) ;

    return ;
}

static
HRESULT
SetWMStreamMediaType (
    IN  IWMStreamConfig *   pIWMStreamConfig,
    IN  AM_MEDIA_TYPE *     pmt
    )
{
    HRESULT         hr ;
    IWMMediaProps * pIWMMediaProps ;
    WM_MEDIA_TYPE   Wmt ;

    ASSERT (pmt) ;
    ASSERT (pIWMStreamConfig) ;

    hr = DShowWMSDKHelpers::TranslateDShowToWM (
            pmt,
            & Wmt
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIWMStreamConfig -> QueryInterface (
                IID_IWMMediaProps,
                (void **) & pIWMMediaProps
                ) ;
        if (SUCCEEDED (hr)) {
            ASSERT (pIWMMediaProps) ;

            hr = pIWMMediaProps -> SetMediaType (& Wmt) ;

            pIWMMediaProps -> Release () ;
        }

        FreeMediaType (* (AM_MEDIA_TYPE *) & Wmt) ;
    }

    return hr ;
}

static
HRESULT
SetDSMediaType (
    IN  AM_MEDIA_TYPE *     pmt,
    IN  IWMStreamConfig *   pIWMStreamConfig
    )
{
    HRESULT         hr ;
    WM_MEDIA_TYPE * pWmt ;

    ASSERT (pmt) ;
    ASSERT (pIWMStreamConfig) ;

    hr = GetStreamMediaType (pIWMStreamConfig, & pWmt) ;
    if (SUCCEEDED (hr)) {
        ASSERT (pWmt) ;

        hr = DShowWMSDKHelpers::TranslateWMToDShow (
                pWmt,
                pmt
                ) ;

        FreeWMMediaType (pWmt) ;
    }

    return hr ;
}

static
BOOL
IsVBRStream (
    IN AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (MinBitrate (pmt) != MaxBitrate (pmt) ? TRUE : FALSE) ;
}

static
HRESULT
SetVBRProps (
    IN  CMediaType *        pmt,
    IN  IWMStreamConfig *   pIWMStreamConfig
    )
{
    HRESULT             hr ;
    IWMPropertyVault *  pIVMPropertyVault ;
    BOOL                f ;
    DWORD               dwMax ;

    ASSERT (pIWMStreamConfig) ;
    ASSERT (pmt) ;

    hr = pIWMStreamConfig -> QueryInterface (IID_IWMPropertyVault, (void **) & pIVMPropertyVault) ;
    if (SUCCEEDED (hr)) {

        f = TRUE ;
        hr = pIVMPropertyVault -> SetProperty (g_wszVBREnabled, WMT_TYPE_BOOL, (BYTE *) & f, sizeof BOOL) ;
        if (SUCCEEDED (hr)) {
            dwMax = MaxBitrate (pmt) ;
            hr = pIVMPropertyVault -> SetProperty (g_wszVBRBitrateMax, WMT_TYPE_DWORD, (BYTE *) & dwMax, sizeof DWORD) ;
            if (SUCCEEDED (hr)) {
                hr = pIWMStreamConfig -> SetBitrate (dwMax) ;
            }
        }

        pIVMPropertyVault -> Release () ;
    }

    return hr ;
}

//  ============================================================================

CDVRWriterProfile::CDVRWriterProfile (
    IN  CDVRPolicy *        pPolicy,
    IN  const WCHAR *       szName,
    IN  const WCHAR *       szDescription,
    OUT HRESULT *           phr
    ) : m_pIWMProfile       (NULL),
        m_dwBufferWindow    (REG_DEF_WM_BUFFER_WINDOW)
{
    IWMProfileManager * pIWMProfileManager ;
    BOOL                r ;
    IWMPacketSize2 *    pWMPacketSize ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRWriterProfile")) ;

    ASSERT (pPolicy) ;
    m_fInlineDShowProps     = pPolicy -> Settings () -> InlineDShowProps () ;
    m_dwBufferWindow        = pPolicy -> Settings () -> WMBufferWindowMillis () ;
    m_dwDefaultAvgBitRate   = pPolicy -> Settings () -> DefaultAverageBitRate () ;

    pIWMProfileManager = NULL ;

    (* phr) = WMCreateProfileManager (& pIWMProfileManager) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ASSERT (pIWMProfileManager) ;
    (* phr) = pIWMProfileManager -> CreateEmptyProfile (
                WMSDK_COMPATIBILITY_VERSION,
                & m_pIWMProfile
                ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIWMProfile -> SetName (szName) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIWMProfile -> SetDescription (szDescription) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIWMProfile -> QueryInterface (
                IID_IWMPacketSize2,
                (void **) & pWMPacketSize
                ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ( *phr) = pWMPacketSize -> SetMinPacketSize (pPolicy -> Settings () -> WMPacketSize ()) ;
    pWMPacketSize -> Release ();
    if (FAILED (* phr)) { goto cleanup ; }

    cleanup :

    RELEASE_AND_CLEAR (pIWMProfileManager) ;

    return ;
}

CDVRWriterProfile::CDVRWriterProfile (
    IN  CDVRPolicy *        pPolicy,
    IN  IWMProfile *        pIWMProfile,
    OUT HRESULT *           phr
    ) : m_pIWMProfile   (pIWMProfile)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRWriterProfile")) ;

    ASSERT (m_pIWMProfile) ;
    m_pIWMProfile -> AddRef () ;
}

CDVRWriterProfile::~CDVRWriterProfile (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRWriterProfile")) ;

    RELEASE_AND_CLEAR (m_pIWMProfile) ;
}

HRESULT
CDVRWriterProfile::AddStream (
    IN  LONG            lIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT             hr ;
    IWMStreamConfig *   pIWMStreamConfig ;
    IWMStreamConfig2 *  pIWMStreamConfig2 ;
    WCHAR               ach [64] ;
    CMediaType          mtCopy ;
    DWORD               dwAvgBitRate ;
    WCHAR *             psz ;

    O_TRACE_ENTER_2 (
        TEXT ("CDVRWriterProfile::AddStream"),
        lIndex,
        pmt
        ) ;

    ASSERT (pmt) ;
    ASSERT (m_pIWMProfile) ;

    pIWMStreamConfig    = NULL ;
    pIWMStreamConfig2   = NULL ;

    //  copy the media type so we don't change the actual media type on the pin
    hr = CopyMediaType (& mtCopy, pmt) ;
    if (FAILED (hr)) { goto cleanup ; }

    EncryptedSubtypeHack_IN (& mtCopy) ;

    //  make sure media type is ok
    hr = DShowWMSDKHelpers::MediaTypeSetValidForWMSDK (& mtCopy) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = m_pIWMProfile -> CreateNewStream (WMStreamType (& mtCopy), & pIWMStreamConfig) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (pIWMStreamConfig) ;

    hr = pIWMStreamConfig -> QueryInterface (IID_IWMStreamConfig2, (void **) & pIWMStreamConfig2) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (pIWMStreamConfig2) ;

    hr = pIWMStreamConfig -> SetBufferWindow (m_dwBufferWindow) ;
    if (FAILED (hr)) { goto cleanup ; }

    if (!IsVBRStream (& mtCopy)) {
        dwAvgBitRate = GetStreamAvgBitRate (& mtCopy) ;
        dwAvgBitRate = (dwAvgBitRate != UNDEFINED ? dwAvgBitRate : m_dwDefaultAvgBitRate) ;
        hr = pIWMStreamConfig -> SetBitrate (dwAvgBitRate) ;
        if (FAILED (hr)) { goto cleanup ; }
    }
    else {
        hr = SetVBRProps (& mtCopy, pIWMStreamConfig) ;
        if (FAILED (hr)) { goto cleanup ; }
    }

    psz = GetWMConnectionName (lIndex, & mtCopy, & ach [0], sizeof ach / sizeof WCHAR) ;
    if (!psz) { hr = E_FAIL ; goto cleanup ; }
    hr = pIWMStreamConfig -> SetConnectionName (psz) ;
    if (FAILED (hr)) { goto cleanup ; }

    psz = GetWMStreamName (lIndex, & mtCopy, & ach [0], sizeof ach / sizeof WCHAR) ;
    if (!psz) { hr = E_FAIL ; goto cleanup ; }
    hr = pIWMStreamConfig -> SetStreamName (psz) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = SetWMStreamMediaType (pIWMStreamConfig, & mtCopy) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = pIWMStreamConfig -> SetStreamNumber (DShowWMSDKHelpers::PinIndexToWMStreamNumber (lIndex)) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ========================================================================
    //  INSSBuffer3 props

    //  dynamic format changes (dshow layer); 0xffff means arbitrary size
    hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_DShowNewMediaType, 0xffff, NULL, 0) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  dshow properties
    hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_SBE_Attributes, sizeof INSSBUFFER3PROP_SBE_ATTRIB, NULL, 0) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  format specific e.g. mpeg-2
    hr = DShowWMSDKHelpers::AddFormatSpecificExtensions (pIWMStreamConfig2, pmt) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  DVR analysis extensions
    hr = DShowWMSDKHelpers::AddDVRAnalysisExtensions (pIWMStreamConfig2, pmt) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  always have the encryption attribute; it's variable size
    hr = pIWMStreamConfig2 -> AddDataUnitExtension (ATTRID_ENCDEC_BLOCK_SBE, 0xffff, NULL, 0) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  perf
    #ifdef SBE_PERF
    hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_Perf, sizeof INSSBUFFER3PROP_PERF, NULL, 0) ;
    if (FAILED (hr)) { goto cleanup ; }
    #endif  //  SBE_PERF

    //  finally: add it to the profile
    hr = m_pIWMProfile -> AddStream (pIWMStreamConfig) ;

    cleanup :

    RELEASE_AND_CLEAR (pIWMStreamConfig) ;
    RELEASE_AND_CLEAR (pIWMStreamConfig2) ;

    return hr ;
}

DWORD
CDVRWriterProfile::GetStreamCount (
    )
{
    DWORD   dwStreamCount ;
    HRESULT hr ;

    ASSERT (m_pIWMProfile) ;
    hr = m_pIWMProfile -> GetStreamCount (& dwStreamCount) ;
    if (FAILED (hr)) {
        dwStreamCount = 0 ;
    }

    return dwStreamCount ;
}

HRESULT
CDVRWriterProfile::DeleteStream (
    IN  LONG    lIndex
    )
{
    ASSERT (m_pIWMProfile) ;

    //
    //  BUGBUG
    //  what about an arbitrary profile that doesn't have contiguous
    //   stream numbers; should lIndex be the Nth stream, regardless
    //   of the stream numbers ???
    //

    return m_pIWMProfile -> RemoveStreamByNumber (DShowWMSDKHelpers::PinIndexToWMStreamNumber (lIndex)) ;
}

HRESULT
CDVRWriterProfile::GetStream (
    IN  LONG            lIndex,
    OUT CMediaType **   ppmt
    )
{
    HRESULT             hr ;
    IWMStreamConfig *   pIWMStreamConfig ;

    O_TRACE_ENTER_2 (
        TEXT ("CDVRWriterProfile::GetStream"),
        lIndex,
        ppmt
        ) ;

    ASSERT (ppmt) ;
    ASSERT (m_pIWMProfile) ;

    //
    //  BUGBUG
    //  what about an arbitrary profile that doesn't have contiguous
    //   stream numbers; should lIndex be the Nth stream, regardless
    //   of the stream numbers ???
    //

    hr = m_pIWMProfile -> GetStreamByNumber (
                DShowWMSDKHelpers::PinIndexToWMStreamNumber (lIndex),
                & pIWMStreamConfig
                ) ;
    if (SUCCEEDED (hr)) {

        (* ppmt) = new CMediaType ;
        if (* ppmt) {
            hr = SetDSMediaType ((* ppmt), pIWMStreamConfig) ;
            if (FAILED (hr)) {
                delete (* ppmt) ;
                (* ppmt) = NULL ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }

        pIWMStreamConfig -> Release () ;
    }

    return hr ;
}


//  ============================================================================
//  ============================================================================

CDVRReaderProfile::CDVRReaderProfile (
    IN  CDVRPolicy *        pPolicy,
    IN  IDVRReader *        pIDVRReader,
    OUT HRESULT *           phr
    ) : m_lRef          (1),
        m_pIDVRReader   (pIDVRReader),
        m_pIWMProfile   (NULL),
        m_pPolicy       (pPolicy)
{
    ASSERT (phr) ;
    ASSERT (m_pIDVRReader) ;

    m_pIDVRReader -> AddRef () ;

    if (m_pPolicy) {
        m_pPolicy -> AddRef () ;
    }

    (* phr) = m_pIDVRReader -> GetProfile (& m_pIWMProfile) ;
}

CDVRReaderProfile::CDVRReaderProfile (
    IN  CDVRPolicy *    pPolicy,
    IN  IWMProfile *    pIWMProfile,
    OUT HRESULT *       phr
    ) : m_lRef          (1),
        m_pIDVRReader   (NULL),
        m_pIWMProfile   (pIWMProfile),
        m_pPolicy       (pPolicy)
{
    ASSERT (phr) ;
    ASSERT (m_pIWMProfile) ;

    m_pIWMProfile -> AddRef () ;

    if (m_pPolicy) {
        m_pPolicy -> AddRef () ;
    }

    (* phr) = S_OK ;
}

CDVRReaderProfile::~CDVRReaderProfile (
    )
{
    if (m_pIWMProfile &&
        m_pIDVRReader) {

        m_pIDVRReader -> ReleaseProfile (m_pIWMProfile) ;
    }
    else if (m_pIWMProfile) {
        m_pIWMProfile -> Release () ;
    }

    RELEASE_AND_CLEAR (m_pIDVRReader) ;
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

ULONG
CDVRReaderProfile::Release ()
{
    LONG    lRef ;

    lRef = InterlockedDecrement (& m_lRef) ;
    if (lRef == 0) {
        m_lRef = 1 ;
        delete this ;
        return 0 ;
    }

    ASSERT (lRef > 0) ;
    return lRef ;
}

HRESULT
CDVRReaderProfile::EnumWMStreams (
    OUT DWORD * pdwCount
    )
{
    HRESULT hr ;

    ASSERT (m_pIWMProfile) ;
    hr = m_pIWMProfile -> GetStreamCount (pdwCount) ;

    return hr ;
}

HRESULT
CDVRReaderProfile::GetStream (
    IN  DWORD           dwIndex,
    OUT WORD *          pwStreamNum,
    OUT AM_MEDIA_TYPE * pmt                 //  call FreeMediaType () on
    )
{
    HRESULT             hr ;
    IWMStreamConfig *   pIWMStreamConfig ;
    WM_MEDIA_TYPE *     pWmt ;
    WORD                cDataExtensions ;
    WORD                i ;
    GUID                guidExtensionSystemID ;
    WORD                cbExtensionDataSize ;
    BYTE                bExtensionSystemInfo ;
    DWORD               cbExtensionSystemInfo ;


    ASSERT (pwStreamNum) ;
    ASSERT (pmt) ;
    ASSERT (m_pIWMProfile) ;

    ASSERT (pmt -> pbFormat == NULL) ;
    ZeroMemory (pmt, sizeof AM_MEDIA_TYPE) ;

    pIWMStreamConfig    = NULL ;
    pWmt                = NULL ;

    //  ------------------------------------------------------------------------
    //  get the stream
    hr = m_pIWMProfile -> GetStream (
            dwIndex,
            & pIWMStreamConfig
            ) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (pIWMStreamConfig) ;

    //  ------------------------------------------------------------------------
    //  stream media type
    hr = GetStreamMediaType (
            pIWMStreamConfig,
            & pWmt
            ) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  translate the media type up to dshow
    hr = DShowWMSDKHelpers::TranslateWMToDShow (pWmt, pmt) ;
    if (FAILED (hr)) {
        FreeMediaType (* pmt) ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  stream number
    hr = pIWMStreamConfig -> GetStreamNumber (pwStreamNum) ;
    if (FAILED (hr)) { goto cleanup ; }

    EncryptedSubtypeHack_OUT (pmt) ;

    cleanup :

    CoTaskMemFree (pWmt) ;
    RELEASE_AND_CLEAR (pIWMStreamConfig) ;

    return hr ;
}

BOOL
CDVRReaderProfile::IsEqual (
    IN  CDVRReaderProfile * pReaderProfile
    )
{
    HRESULT     hr ;
    BOOL        r ;
    DWORD       i ;
    DWORD       dwStreamCountThis, dwStreamCountComp ;
    WORD        wStreamThis, wStreamComp ;
    CMediaType  mtThis, mtComp ;


    //  default to FALSE
    r = FALSE ;

    //  ------------------------------------------------------------------------
    //  first compare the stream count

    hr = pReaderProfile -> EnumWMStreams (& dwStreamCountComp) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = EnumWMStreams (& dwStreamCountThis) ;
    if (FAILED (hr)) { goto cleanup ; }

    if (dwStreamCountThis != dwStreamCountComp) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  we now enumerate through the streams to make sure they are the same
    //    media types & stream numbers

    for (i = 0; i < dwStreamCountThis; i++) {

        //  reset these before starting
        FreeMediaType (mtComp) ;
        FreeMediaType (mtThis) ;

        //  get comp media type
        hr = pReaderProfile -> GetStream (i, & wStreamComp, & mtComp) ;
        if (FAILED (hr)) { goto cleanup ; }

        //  this media type
        hr = GetStream (i, & wStreamThis, & mtThis) ;
        if (FAILED (hr)) { goto cleanup ; }

        //  compare media types
        if (mtThis != mtComp) { goto cleanup ; }

        //  compare stream numbers
        if (wStreamComp != wStreamThis) { goto cleanup ; }
    }

    //  success
    r = TRUE ;

    cleanup :

    FreeMediaType (mtComp) ;
    FreeMediaType (mtThis) ;

    return r ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CopyWMProfile (
    IN  CDVRPolicy *    pPolicy,
    IN  IWMProfile *    pIWMMasterProfile,
    OUT IWMProfile **   ppIWMCopiedProfile
    )
{
    HRESULT             hr ;
    CDVRReaderProfile * pMasterProfile ;
    CDVRWriterProfile * pCopiedProfile ;
    WCHAR *             pszName ;
    WCHAR *             pszDescription ;
    DWORD               dwCount ;
    DWORD               dwStreamCount ;
    DWORD               i ;
    AM_MEDIA_TYPE       mt ;
    WORD                wStreamNum ;

    ASSERT (pIWMMasterProfile) ;
    ASSERT (ppIWMCopiedProfile) ;

    pCopiedProfile  = NULL ;
    pMasterProfile  = NULL ;
    pszName         = NULL ;
    pszDescription  = NULL ;

    ::ZeroMemory (& mt, sizeof mt) ;

    //  returning
    (* ppIWMCopiedProfile)  = NULL ;

    //  ------------------------------------------------------------------------
    //  retrieve the profile name

    hr = pIWMMasterProfile -> GetName (NULL, & dwCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    pszName = new WCHAR [dwCount] ;
    if (!pszName) { hr = E_OUTOFMEMORY ; goto cleanup ; }

    hr = pIWMMasterProfile -> GetName (pszName, & dwCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  the description

    hr = pIWMMasterProfile -> GetDescription (NULL, & dwCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    pszDescription = new WCHAR [dwCount] ;
    if (!pszName) { hr = E_OUTOFMEMORY ; goto cleanup ; }

    hr = pIWMMasterProfile -> GetDescription (pszDescription, & dwCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  instantiate our master profile object

    pMasterProfile = new CDVRReaderProfile (
                            pPolicy,
                            pIWMMasterProfile,
                            & hr
                            ) ;
    if (!pMasterProfile) {
        hr = E_OUTOFMEMORY ;
        goto cleanup ;
    }
    else if (FAILED (hr)) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  instantiate our copy-to profile object

    pCopiedProfile = new CDVRWriterProfile (
                            pPolicy,
                            pszName,
                            pszDescription,
                            & hr
                            ) ;
    if (!pCopiedProfile) {
        hr = E_OUTOFMEMORY ;
        goto cleanup ;
    }
    else if (FAILED (hr)) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  now transfer the streams over; the attributes are created per the
    //    policy object

    hr = pMasterProfile -> EnumWMStreams (& dwStreamCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    for (i = 0; i < dwStreamCount; i++) {
        FreeMediaType (mt) ;

        hr = pMasterProfile -> GetStream ((LONG) i, & wStreamNum, & mt) ;
        if (FAILED (hr)) { goto cleanup ; }

        //  this should create the same stream number
        if (DShowWMSDKHelpers::PinIndexToWMStreamNumber (i) != wStreamNum) {
            hr = E_INVALIDARG ;
            goto cleanup ;
        }

        hr = pCopiedProfile -> AddStream ((LONG) i, & mt) ;
        if (FAILED (hr)) { goto cleanup ; }
    }

    //  ------------------------------------------------------------------------
    //  set outgoing

    hr = pCopiedProfile -> GetRefdWMProfile (ppIWMCopiedProfile) ;
    if (FAILED (hr)) { goto cleanup ; }

    cleanup :

    FreeMediaType (mt) ;

    //  only reader profiles released
    RELEASE_AND_CLEAR (pMasterProfile) ;
    delete pCopiedProfile ;
    delete [] pszDescription ;
    delete [] pszName ;

    return hr ;
}

HRESULT
DiscoverTimelineStream (
    IN  IWMProfile *    pIWMProfile,
    OUT WORD *          pwTimelineStream
    )
{
    HRESULT             hr ;
    CDVRReaderProfile * pProfile ;
    DWORD               dwStreamCount ;
    DWORD               i ;
    AM_MEDIA_TYPE       mt ;

    ASSERT (pIWMProfile) ;
    ASSERT (pwTimelineStream) ;

    ZeroMemory (& mt, sizeof mt) ;

    pProfile = NULL ;

    pProfile = new CDVRReaderProfile (
                        NULL,           //  no policy
                        pIWMProfile,
                        & hr
                        ) ;
    if (!pProfile) {
        hr = E_OUTOFMEMORY ;
        goto cleanup ;
    }
    else if (FAILED (hr)) {
        goto cleanup ;
    }

    hr = pProfile -> EnumWMStreams (& dwStreamCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  check for an empty profile
    if (dwStreamCount == 0) {
        hr = E_INVALIDARG ;
        goto cleanup ;
    }

    //
    //  opportunistically pick off a stream if there's no audio; if there is
    //  audio, we bail because we found what we wanted
    //

    for (i = 0; i < dwStreamCount; i++) {

        FreeMediaType (mt) ;

        hr = pProfile -> GetStream (
                i,
                pwTimelineStream,
                & mt
                ) ;
        if (FAILED (hr)) { goto cleanup ; }

        if (IsAudio (& mt)) {
            //  we're done
            break ;
        }

        //  only allow a video or an audio stream
        if (!IsVideo (& mt)) {
            (* pwTimelineStream) = UNDEFINED ;
        }
    }

    if ((* pwTimelineStream) != UNDEFINED) {
        hr = S_OK ;
    }
    else {
        hr = E_FAIL ;
    }

    cleanup :

    RELEASE_AND_CLEAR (pProfile) ;
    FreeMediaType (mt) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvrasyncio.h ===
#ifndef __dvrasyncio_h
#define __dvrasyncio_h

//  forward declarations
struct PVR_WRITE_BUFFER ;
template <DWORD dwTableSize> class CPVRReadCache ;
struct PVR_ASYNCREADER_WAIT_COUNTER ;
struct PVR_ASYNCREADER_COUNTER ;
class CPVRWriteBufferStream ;
class CPVRWriteBufferStreamReader ;
class CPVRWriteBufferStreamWriter ;
class CIoCompletion ;
class CAsyncIo ;
class CPVRAsyncReader ;
class CPVRAsyncReaderCOM ;
class CPVRAsyncWriter ;
class CPVRAsyncWriterCOM ;
class CPVRAsyncWriterSharedMem ;

//  ============================================================================
//  ============================================================================

enum BUFFER_STATE {
    BUFFER_STATE_INVALID        = 0,
    BUFFER_STATE_FILLING        = 1,
    BUFFER_STATE_IO_PENDING     = 2,
    BUFFER_STATE_IO_COMPLETED   = 3
} ;

//  ============================================================================
//  ============================================================================

struct PVR_WRITE_BUFFER {
    DWORD           dwIndex ;
    BUFFER_STATE    BufferState ;
    ULONGLONG       ullBufferOffset ;   //  to [0]th byte of PVR_WRITE_BUFFER
    DWORD           dwData ;
    OVERLAPPED      Overlapped ;

    static
    BYTE *
    PVRDataBuffer (
        IN  ULONGLONG * pullBufferOffset
        )
    {
        PVR_WRITE_BUFFER *    pPVRBuffer ;
        BYTE *          pbPVRDataBuffer ;

        pPVRBuffer = CONTAINING_RECORD (pullBufferOffset, PVR_WRITE_BUFFER, ullBufferOffset) ;

        pbPVRDataBuffer = ((BYTE *) pPVRBuffer) + (* pullBufferOffset) ;

        return pbPVRDataBuffer ;
    }

    static
    PVR_WRITE_BUFFER *
    Recover (
        IN  OVERLAPPED *    pOverlapped
        )
    {
        PVR_WRITE_BUFFER *    pPVRBuffer ;

        pPVRBuffer = CONTAINING_RECORD (pOverlapped, PVR_WRITE_BUFFER, Overlapped) ;
        return pPVRBuffer ;
    }
} ;

//  this structure is a *directory* to the write buffers; note that the
//    PVR_WRITE_BUFFER struct is not a buffer itself, but rather an offset,
//    relative to the first byte of this struct, to the actual buffer; we do
//    this so cross-proc, this struct can be shared, and all buffer addresses
//    are relative to the offset address of each process's mapping
struct PVR_WRITE_BUFFER_STREAM {
    BOOL                fWriterActive ;
    GUID                StreamId ;              //  unique per stream; use StringFromIID to create mutex
    DWORD               dwSharedMemSize ;
    DWORD               dwIoLength ;
    DWORD               dwBufferCount ;
    DWORD               dwCurrentWriteIndex ;
    DWORD               dwMaxContiguousCompletedIndex ;
    ULONGLONG           ullMaxCopied ;
    ULONGLONG           ullMaxContiguousCompleted ;
    PVR_WRITE_BUFFER    PVRBuffer [1] ;     //  of dwBufferCount
} ;


/*++
    PVR_READ_BUFFER states

        BUFFER_STATE_INVALID        can pend reads; not in cache
        BUFFER_STATE_IO_PENDING     read pending; in cache
        BUFFER_STATE_IO_COMPLETED   read completed ok; in cache
--*/
struct PVR_READ_BUFFER {
    LPVOID                  pWaitForCompletion ;    //  BUGBUG: make list entry
    LIST_ENTRY              le ;
    ULONGLONG               ullStream ;
    DWORD                   dwMaxLength ;
    DWORD                   dwValidLength ;
    DWORD                   dwReqLength ;
    DWORD                   dwIoRet ;
    BUFFER_STATE            BufferState ;
    BYTE *                  pbBuffer ;
    CPVRAsyncReader *       pOwningReader ;
    LONG                    cRef ;

    PVR_READ_BUFFER (
        ) : pWaitForCompletion  (NULL),
            ullStream           (0),
            dwMaxLength         (0),
            dwValidLength       (0),
            dwReqLength         (0),
            dwIoRet             (NOERROR),
            BufferState         (BUFFER_STATE_INVALID),
            pbBuffer            (NULL),
            pOwningReader       (NULL),
            cRef                (0)
    {
    }

    LONG AddRef () ;
    LONG Release () ;

    void SetOwningReader (IN CPVRAsyncReader * pReader)  { ASSERT (!pOwningReader) ; pOwningReader = pReader ; }

    LIST_ENTRY * ListEntry ()               { return & le ; }

    BYTE * Buffer ()                        { return pbBuffer ; }
    void SetBuffer (IN BYTE * pb)           { pbBuffer = pb ; }

    LONG Ref ()                             { return cRef ; }
    BOOL IsRef ()                           { return (Ref () != 0 ? TRUE : FALSE) ; }

    void SetValidLength (IN DWORD dwBytes)  { ASSERT (dwBytes <= dwMaxLength) ; dwValidLength = dwBytes ; }
    DWORD ValidLength ()                    { return dwValidLength ; }

    void SetRequestLength (IN DWORD dwReq)  { ASSERT (dwReq <= dwMaxLength) ; dwReqLength = dwReq ; }
    DWORD RequestLength ()                  { return dwReqLength ; }

    void SetMaxLength (IN DWORD dwLen)      { dwMaxLength = dwLen ; }
    DWORD MaxLength ()                      { return dwMaxLength ; }

    void SetStreamOffset (IN ULONGLONG ull) { ullStream = ull ; }
    ULONGLONG StreamOffset ()               { return ullStream ; }

    void SetIoRet (IN DWORD dwIoRetParam)   { dwIoRet = dwIoRetParam ; SetValid (dwIoRet == NOERROR) ; }
    DWORD IoRet ()                          { return dwIoRet ; }

    void SetInvalid ()                      { SetValid (FALSE) ; }
    BOOL IsInvalid ()                       { return (BufferState == BUFFER_STATE_INVALID ? TRUE : FALSE) ; }

    void SetPending ()                      { ASSERT (IsInvalid ()) ; BufferState = BUFFER_STATE_IO_PENDING ; }
    BOOL IsPending ()                       { return (BufferState == BUFFER_STATE_IO_PENDING ? TRUE : FALSE) ; }

    void SetValid (IN BOOL f = TRUE)        { if (f) { BufferState = BUFFER_STATE_IO_COMPLETED ; } else { BufferState = BUFFER_STATE_INVALID ; } }
    BOOL IsValid ()                         { return (BufferState == BUFFER_STATE_IO_COMPLETED ? TRUE : FALSE) ; }

    static PVR_READ_BUFFER * Recover (IN LIST_ENTRY * ple) {
        PVR_READ_BUFFER *   pPVRReadBuffer ;
        pPVRReadBuffer = CONTAINING_RECORD (ple, PVR_READ_BUFFER, le) ;
        return pPVRReadBuffer ;
    }
} ;

//  ============================================================================
//  ============================================================================

class CIoCompletion
{
    public :

        virtual
        void
        IOCompleted (
            IN  DWORD       dwIoBytes,
            IN  DWORD_PTR   dwpContext,
            IN  DWORD       dwIOReturn
            ) = 0 ;
} ;

//  ============================================================================
//  CPVRWriteBufferStream
//      helper class to process the mapping structures
//  ============================================================================

class CPVRWriteBufferStream
{
    protected :

        CMutexLock *                m_pMutex ;
        PVR_WRITE_BUFFER_STREAM *   m_pPVRWriteBufferStream ;
        DWORD                       m_dwMaxBufferingBytes ;         //  max capacity of the buffering
        DWORD                       m_dwMaxBufferingBytesFilling ;  //  max buffered bytes with a buffer filling (excluding it)

        CPVRWriteBufferStream (
            ) ;

        virtual
        ~CPVRWriteBufferStream (
            ) ;

        ULONGLONG MaxCopied_ ()                     { ASSERT (m_pPVRWriteBufferStream) ; return m_pPVRWriteBufferStream -> ullMaxCopied ; }
        ULONGLONG MaxContiguousCompleted_ ()        { ASSERT (m_pPVRWriteBufferStream) ; return m_pPVRWriteBufferStream -> ullMaxContiguousCompleted ; }
        DWORD     BufferLength_ ()                  { ASSERT (m_pPVRWriteBufferStream) ; return m_pPVRWriteBufferStream -> dwIoLength ; }
        DWORD     BufferCount_ ()                   { ASSERT (m_pPVRWriteBufferStream) ; return m_pPVRWriteBufferStream -> dwBufferCount ; }
        DWORD     BufferIndex_ (IN DWORD dwIndex)   { ASSERT (m_pPVRWriteBufferStream) ; return dwIndex % m_pPVRWriteBufferStream -> dwBufferCount ; }

        ULONGLONG
        MinStreamOffsetInBuffer_ (
            )
        {
            ULONGLONG   ullStreamFilling ;
            ULONGLONG   ullMinStreamOffset ;

            ullStreamFilling = ::AlignDown <ULONGLONG> (MaxCopied_ (), m_pPVRWriteBufferStream -> dwIoLength) ;

            ullMinStreamOffset = ullStreamFilling - ::Min <ULONGLONG> (m_dwMaxBufferingBytesFilling, ullStreamFilling) ;

            return ullMinStreamOffset ;
        }

        BYTE *
        Buffer_ (
            IN  DWORD   dwAbsoluteIndex     //  will be modulus'd
            )
        {
            return Buffer (PVRWriteBuffer (dwAbsoluteIndex)) ; ;
        }

        DWORD
        ValidLength_ (
            IN  DWORD   dwAbsoluteIndex     //  will be modulus'd
            )
        {
            return m_pPVRWriteBufferStream -> PVRBuffer [BufferIndex_ (dwAbsoluteIndex)].dwData ;
        }

        DWORD
        InvalidBytesInBuffer_ (
            IN  DWORD   dwAbsoluteIndex
            )
        {
            ASSERT (m_pPVRWriteBufferStream) ;
            return m_pPVRWriteBufferStream -> dwIoLength - PVRWriteBuffer (dwAbsoluteIndex) -> dwData ;
        }

        BOOL
        AreBytesInWriteBuffer_ (
            IN ULONGLONG    ullStream,
            IN DWORD        dwLength
            )
        {
            BOOL    r ;

            ASSERT (m_pPVRWriteBufferStream) ;
            ASSERT (CallerOwnsLock ()) ;

            r = (ullStream >= MinStreamOffsetInBuffer_ () && ullStream + dwLength <= MaxCopied_ () ? TRUE : FALSE) ;

            return r ;
        }

        DWORD
        FirstByteIndex_ (
            IN  ULONGLONG   ullStream
            )
        {
            DWORD   dwFirstByteIndex ;

            ASSERT (m_pPVRWriteBufferStream) ;
            ASSERT (CallerOwnsLock ()) ;
            ASSERT (AreBytesInWriteBuffer_ (ullStream, 1)) ;

            //  align down
            dwFirstByteIndex = (DWORD) (ullStream / BufferLength_ ()) ;

            return dwFirstByteIndex ;
        }

        DWORD
        FirstByteBufferOffset_ (
            IN  ULONGLONG   ullStream,
            IN  DWORD       dwFirstByteBufferIndex
            )
        {
            ULONGLONG   ullBuffer ;
            DWORD       dwBufferOffset ;

            ullBuffer = dwFirstByteBufferIndex * BufferLength_ () ;
            dwBufferOffset = (DWORD) (ullStream - ullBuffer) ;

            return dwBufferOffset ;
        }

        DWORD
        Initialize (
            IN  HANDLE                      hWriteBufferMutex,
            IN  PVR_WRITE_BUFFER_STREAM *   pPVRWriteBufferStream
            ) ;

    public :

        BOOL    Lock ()             { if (m_pMutex) { return m_pMutex -> Lock () ; } else { return TRUE ; }}
        void    Unlock ()           { if (m_pMutex) { m_pMutex -> Unlock () ; }}
        BOOL    CallerOwnsLock ()   { if (m_pMutex) { return m_pMutex -> IsLockedByCallingThread () ; } else { return TRUE ; }}

        PVR_WRITE_BUFFER_STREAM * WriteBufferStream ()  { return m_pPVRWriteBufferStream ; }

        PVR_WRITE_BUFFER *
        PVRWriteBuffer (
            IN  DWORD   dwAbsoluteIndex     //  will be modulus'd
            )
        {
            return & m_pPVRWriteBufferStream -> PVRBuffer [BufferIndex_ (dwAbsoluteIndex)] ;
        }

        BYTE *
        Buffer (
            IN  PVR_WRITE_BUFFER *  pPVRWriteBuffer
            )
        {
            return PVR_WRITE_BUFFER::PVRDataBuffer (& pPVRWriteBuffer -> ullBufferOffset) ;
        }

        BOOL WriterActive ()
        {
            BOOL    r ;

            //
            //  NOTE: serialization to initialize, uninitialize, and call this
            //    method must be done outside of this object !!!
            //

            if (m_pPVRWriteBufferStream) {
                r = m_pPVRWriteBufferStream -> fWriterActive ;
            }
            else {
                r = FALSE ;
            }

            return r ;
        }

        BOOL IsLive ()      { return WriterActive () ; }
        BOOL IsNotLive ()   { return !IsLive () ; }

        ULONGLONG CurBytesCopied ()
        {
            ULONGLONG   ullBytesCopied ;

            ASSERT (m_pPVRWriteBufferStream) ;

            Lock () ;
            ullBytesCopied = MaxCopied_ () ;
            Unlock () ;

            return ullBytesCopied ;
        }

        virtual
        void
        Uninitialize (
            )
        {
            //
            //  NOTE: serialization to initialize, uninitialize, and call this
            //    method must be done outside of this object !!!
            //

            if (m_pMutex) {
                delete m_pMutex ;
                m_pMutex = NULL ;
            }

            m_pPVRWriteBufferStream = NULL ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CPVRWriteBufferStreamReader :
    public CPVRWriteBufferStream
{
    CWin32SharedMem *   m_pPVRWriteBufferMM ;

    DWORD
    RetrieveMutex_ (
        IN  SECURITY_ATTRIBUTES *   pSec,
        IN  REFGUID                 StreamId,
        OUT HANDLE *                phMutex
        ) ;

    public :

        CPVRWriteBufferStreamReader (
            ) : m_pPVRWriteBufferMM     (NULL),
                CPVRWriteBufferStream   () {}

        ~CPVRWriteBufferStreamReader (
            )
        {
            ASSERT (!m_pPVRWriteBufferMM) ;
        }

        DWORD
        Initialize (
            IN  SECURITY_ATTRIBUTES *   pSec,
            IN  LPWSTR                  pszWriteBufferMapping
            ) ;

        BOOL
        CopyAllBytes (
            IN  ULONGLONG   ullStream,
            IN  DWORD       dwLength,
            OUT BYTE *      pbBuffer
            ) ;

        virtual
        void
        Uninitialize (
            )
        {
            if (m_pPVRWriteBufferMM) {
                delete m_pPVRWriteBufferMM ;
                m_pPVRWriteBufferMM = NULL ;
            }

            CPVRWriteBufferStream::Uninitialize () ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CPVRWriteBufferStreamWriter :
    public CPVRWriteBufferStream
{
    DWORD
    CreateUniqueMutex_ (
        IN  SECURITY_ATTRIBUTES *   pSec,
        IN  REFGUID                 StreamId,
        OUT HANDLE *                phMutex
        ) ;

    public :

        CPVRWriteBufferStreamWriter (
            ) : CPVRWriteBufferStream   () {}

        ~CPVRWriteBufferStreamWriter (
            )
        {
        }

        DWORD
        Initialize (
            IN  SECURITY_ATTRIBUTES *   pSec,
            IN  BYTE *                  pbMemory,       //  base pointer to memory (PVR_WRITE_BUFFER_STREAM *)
            IN  DWORD                   dwLength,       //  of memory
            IN  DWORD                   dwAlignment,    //  buffer alignment
            IN  DWORD                   dwIoSize,       //  IO size
            IN  DWORD                   dwBufferCount   //  number of buffers
            ) ;

        virtual
        void
        Uninitialize (
            ) ;

        //  appends max # of bytes to cur write buffer
        DWORD
        AppendToCurPVRWriteBuffer (
            IN OUT  BYTE ** ppbBuffer,                      //  [in] buffer before copy; [out] buffer after copy
            IN OUT  DWORD * pdwBufferLength,                //  [in] bytes to copy; [out] bytes remaining (if buffer becomes full)
            OUT     DWORD * pdwCurWriteBufferBytesLeft      //  after the write
            ) ;

        void
        UpdateMaxContiguousLocked (
            PVR_WRITE_BUFFER *  pPVRWriteBufferJustCompleted
            ) ;

        BYTE *
        CurWriteBuffer (
            )
        {
            return Buffer (CurPVRWriteBuffer ()) ;
        }

        PVR_WRITE_BUFFER *
        CurPVRWriteBuffer (
            )
        {
            return PVRWriteBuffer (m_pPVRWriteBufferStream -> dwCurrentWriteIndex) ;
        }

        PVR_WRITE_BUFFER *
        NextPVRWriteBuffer (
            )
        {
            return PVRWriteBuffer (m_pPVRWriteBufferStream -> dwCurrentWriteIndex + 1) ;
        }

        void
        AdvancePVRWriteBufferLocked (
            ) ;

        ULONGLONG
        CurPVRWriteBufferStreamOffset (
            )
        {
            return ((ULONGLONG) m_pPVRWriteBufferStream -> dwCurrentWriteIndex) * ((ULONGLONG) m_pPVRWriteBufferStream -> dwIoLength) ;
        }

        //  checks the passed in memory wrt the number of buffers, alignment, and
        //    available size
        static
        BOOL
        MemoryOk (
            IN  BYTE *  pbMemory,                           //  base memory pointer
            IN  DWORD   dwLength,                           //  amount of memory to play with
            IN  DWORD   dwAlignment,                        //  required PVR_WRITE_BUFFER's buffer alignment
            IN  DWORD   dwIoSize,                           //  size of each buffer
            IN  DWORD   dwBufferCount,                      //  number of buffers
            OUT DWORD * pdwExtraMemory  = NULL OPTIONAL,    //  returns the extra memory required
            OUT BYTE ** ppbBuffers      = NULL OPTIONAL     //  points to first backing buffer (PVR_WRITE_BUFFER [0]'s)
            ) ;
} ;

//  ============================================================================
//  ============================================================================

//  NOT serialized !
class CWait
{
    LIST_ENTRY          m_ListEntry ;
    HANDLE              m_hEvent ;              //  completion signals this when a buffer is available
    DWORD               m_dwRet ;               //  return; if NOERROR, ASSERT (pPVRReadBuffer)
    PVR_READ_BUFFER *   m_pPVRReadBuffer ;      //  buffer

    public :

        CWait (
            OUT DWORD * pdwRet
            ) : m_dwRet             (NOERROR),
                m_pPVRReadBuffer    (NULL),
                m_hEvent            (NULL)
        {
            InitializeListHead (& m_ListEntry) ;

            (* pdwRet) = NOERROR ;

            m_hEvent = ::CreateEvent (NULL, TRUE, FALSE, NULL) ;
            if (!m_hEvent) {
                (* pdwRet) = ::GetLastError () ;
                goto cleanup ;
            }

            cleanup :

            return ;
        }

        ~CWait (
            )
        {
            ASSERT (IsListEmpty (& m_ListEntry)) ;
            if (m_hEvent) {
                ::CloseHandle (m_hEvent) ;
            }
        }

        PVR_READ_BUFFER * PVRReadBuffer ()  { return m_pPVRReadBuffer ; }

        PVR_READ_BUFFER *
        WaitForReadBuffer (
            )
        {
            //  must have manually reset the event first
            ::WaitForSingleObject (m_hEvent, INFINITE) ;
            return m_pPVRReadBuffer ;
        }

        void
        Reset (
            )
        {
            m_dwRet             = NULL ;
            m_pPVRReadBuffer    = NULL ;
            ::ResetEvent (m_hEvent) ;           //  explicitely clear the event
        }

        void
        Clear (
            )
        {
            if (m_pPVRReadBuffer) {
                //  our's
                m_pPVRReadBuffer -> Release () ;
            }
        }

        void
        SetPVRReadBuffer (
            IN  PVR_READ_BUFFER *   pPVRReadBuffer
            )
        {
            //  note that it is legal to explicitely fail this wait by setting
            //    the read buffer as NULL; that is considered a failure by the
            //    waiting thread
            m_pPVRReadBuffer = pPVRReadBuffer ;

            if (m_pPVRReadBuffer) {
                //  our's
                m_pPVRReadBuffer -> AddRef () ;
            }

            ::SetEvent (m_hEvent) ;
        }

        static CWait * Recover (IN LIST_ENTRY * ple) {
            CWait *   pWaitForBuffer ;
            pWaitForBuffer = CONTAINING_RECORD (ple, CWait, m_ListEntry) ;
            return pWaitForBuffer ;
        }

        static void ListInsertHead (IN LIST_ENTRY * pleHead, IN CWait * pWaitForBuffer) {
            ASSERT (IsListEmpty (& (pWaitForBuffer -> m_ListEntry))) ;
            InsertHeadList (pleHead, & (pWaitForBuffer -> m_ListEntry)) ;
        }

        static void ListInsertTail (IN LIST_ENTRY * pleHead, IN CWait * pWaitForBuffer) {
            ASSERT (IsListEmpty (& (pWaitForBuffer -> m_ListEntry))) ;
            InsertTailList (pleHead, & (pWaitForBuffer -> m_ListEntry)) ;
        }

        static void ListRemove (IN CWait * pWaitForBuffer) {
            RemoveEntryList (& (pWaitForBuffer -> m_ListEntry)) ;
            InitializeListHead (& (pWaitForBuffer -> m_ListEntry)) ;
        }
} ;

//  ============================================================================
//  ============================================================================

//
//  NOT serialized
//
template <DWORD dwTableSize>
class CPVRReadCache :
    public TGenericMap <
                PVR_READ_BUFFER *,
                ULONGLONG,
                FALSE,
                50,
                dwTableSize
                >
{
    protected :

        //  length of buffers is 64k, so we mask off those bits (alignment)
        //    and hash on what's left
        virtual
        ULONG
        Value (
            IN  ULONGLONG   ullStream
            )
        {
            return (ULONG) (ullStream >> 16) ;
        }

    public :

        CPVRReadCache (
            )
        {
        }

        ~CPVRReadCache (
            )
        {
        }

        DWORD
        Find (
            IN  ULONGLONG           ullHash,
            OUT PVR_READ_BUFFER **  ppPVRReadBuffer
            )
        {
            DWORD   dwRet ;

            dwRet = TGenericMap <
                        PVR_READ_BUFFER *,
                        ULONGLONG,
                        FALSE,
                        50,
                        dwTableSize
                        >::Find (ullHash, ppPVRReadBuffer) ;

            if (dwRet == NOERROR) {
                //  set outgoing ref
                ASSERT (ppPVRReadBuffer) ;
                (* ppPVRReadBuffer) -> AddRef () ;
            }

            return dwRet ;
        }

        DWORD
        RemoveFirst (
            OUT PVR_READ_BUFFER **  ppPVRReadBuffer = NULL
            )
        {
            DWORD   dwRet ;

            dwRet = TGenericMap <
                        PVR_READ_BUFFER *,
                        ULONGLONG,
                        FALSE,
                        50,
                        dwTableSize
                        >::RemoveFirst (ppPVRReadBuffer) ;

            if (dwRet == NOERROR &&
                ppPVRReadBuffer) {

                //  set outgoing ref
                ASSERT (ppPVRReadBuffer) ;
                (* ppPVRReadBuffer) -> AddRef () ;
            }

            return dwRet ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CPVRAsyncReader :
    public CIoCompletion
{
    friend struct PVR_READ_BUFFER ;

    enum {
        //  MAX_READ_AHEADS is the maximum number of reads we'll ever pend
        //    ahead of the last read offset; we don't want to pend too many
        //    nor too few; the typical number will be somewhere in between
        MAX_READ_AHEADS = 10,
    } ;

    LIST_ENTRY                      m_leWaitForAnyBufferLIFO ;
    LIST_ENTRY                      m_leWaitForPool ;

    //  allocates these in quantums vs. 1 at a time; we'll still maintain a
    TStructPool <PVR_READ_BUFFER, 50>   m_PVRReadBufferPool ;

    CPVRReadCache <151>             m_PVRReadCache ;
    LPVOID                          m_pvBuffer ;                //  via VirtualAlloc
    DWORD                           m_dwBufferLen ;
    DWORD                           m_dwIoLen ;
    DWORD                           m_dwBackingLenTotal ;
    DWORD                           m_dwBackingLenAvail ;

    CPVRWriteBufferStreamReader     m_WriteBufferReader ;
    CAsyncIo *                      m_pAsyncIo ;
    ULONGLONG                       m_ullCurRead ;
    ULONGLONG                       m_ullMaxIOReadAhead ;       //  max read ahead; reset on seek
    CRITICAL_SECTION                m_crt ;
    HANDLE                          m_hFile ;                   //  duplicated in constructor
    LONG                            m_cIoPending ;
    ULONGLONG                       m_ullFileLength ;           //  UNDEFINED if unknown
    DWORD                           m_dwMaxReadAheadLimit ;     //  ahead of
    DWORD                           m_dwCurMaxReadAhead ;
    CPVRIOCounters *                m_pPVRIOCounters ;

    HANDLE                          m_hDrainIo ;
    BOOL                            m_fDraining ;

    void Lock_ ()           { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()         { ::LeaveCriticalSection (& m_crt) ; }

    //  ------------------------------------------------------------------------
    //  lists

    //  buffer lists
    LIST_ENTRY      m_leValid ;         //  valid; ref = 0
    LIST_ENTRY      m_leInvalid ;       //  invalid; ref = 0
    LIST_ENTRY      m_leInUse ;         //  ref > 0

    void
    BufferPop_ (
        IN  PVR_READ_BUFFER *
        ) ;

    PVR_READ_BUFFER *
    ListEntryPop_ (
        IN  LIST_ENTRY *
        ) ;

    void
    HeadPush_ (
        IN  LIST_ENTRY *    pleHead,
        IN  LIST_ENTRY *    plePush
        ) ;

    PVR_READ_BUFFER *
    HeadPop_ (
        IN  LIST_ENTRY *    pleHead
        ) ;

    void
    TailPush_ (
        IN  LIST_ENTRY *    pleHead,
        IN  LIST_ENTRY *    plePush
        ) ;

    PVR_READ_BUFFER *
    FIFOPop_ (
        IN  LIST_ENTRY *    pleHead
        )
    {
        return HeadPop_ (pleHead) ;
    }

    void
    FIFOPush_ (
        IN  LIST_ENTRY *    pleHead,
        IN  LIST_ENTRY *    plePush
        )
    {
        TailPush_ (pleHead, plePush) ;
    }

    PVR_READ_BUFFER *
    LIFOPop_ (
        IN  LIST_ENTRY *    pleHead
        )
    {
        return HeadPop_ (pleHead) ;
    }

    void
    LIFOPush_ (
        IN  LIST_ENTRY *    pleHead,
        IN  LIST_ENTRY *    plePush
        )
    {
        HeadPush_ (pleHead, plePush) ;
    }

    //  ------------------------------------------------------------------------
    //  invalid list; LIFO

    void
    InvalidPush_ (
        IN  PVR_READ_BUFFER *   pPVRReadBuffer
        )
    {
        LIFOPush_ (& m_leInvalid, pPVRReadBuffer -> ListEntry ()) ;
    }

    PVR_READ_BUFFER *
    InvalidPop_ (
        )
    {
        return LIFOPop_ (& m_leInvalid) ;
    }

    //  ------------------------------------------------------------------------
    //  valid list; FIFO

    void
    ValidPush_ (
        IN  PVR_READ_BUFFER *   pPVRReadBuffer
        )
    {
        FIFOPush_ (& m_leValid, pPVRReadBuffer -> ListEntry ()) ;
    }

    PVR_READ_BUFFER *
    ValidPop_ (
        )
    {
        return FIFOPop_ (& m_leValid) ;
    }

    //  ------------------------------------------------------------------------
    //  InUse; LIFO (doesn't matter really)

    void
    InUsePush_ (
        IN  PVR_READ_BUFFER *   pPVRReadBuffer
        )
    {
        LIFOPush_ (& m_leInUse, pPVRReadBuffer -> ListEntry ()) ;
    }

    PVR_READ_BUFFER *
    InUsePop_ (
        )
    {
        return LIFOPop_ (& m_leInUse) ;
    }

    //  must hold the lock
    ULONGLONG
    BytesCopied_ (
        ) ;

    //  must hold the lock
    void
    PendMaxReads_ (
        IN  ULONGLONG   ullStreamRead
        ) ;

    //  must hold the lock
    //  caller must cleanup in case of failure
    DWORD
    PendReadIntoBuffer_ (
        IN  PVR_READ_BUFFER *   pPVRReadBuffer,
        IN  ULONGLONG           ullStream
        ) ;

    //  must hold the lock
    DWORD
    TryPendRead_ (
        IN  ULONGLONG   ullStream
        ) ;

    //  must hold the lock
    CWait *
    GetWaitObject_ (
        ) ;

    //  must hold the lock
    PVR_READ_BUFFER *
    GetBufferBlocking_ (
        ) ;

    //  must hold the lock
    PVR_READ_BUFFER *
    TryGetBuffer_ (
        ) ;

    //  must hold the lock
    void
    RecycleWaitFor_ (
        IN  CWait *
        ) ;

    //  must hold the lock
    CWait *
    GetWaitForAnyBuffer_ (
        ) ;

    //  must hold the lock
    CWait *
    GetWaitForReadCompletion_ (
        IN  PVR_READ_BUFFER *   pPVRReadBuffer
        ) ;

    //  must hold the lock
    void
    SignalWaitForAnyBuffer_ (
        IN  PVR_READ_BUFFER *
        ) ;

    //  must hold the lock
    void
    SignalWaitForReadCompletion_ (
        IN  PVR_READ_BUFFER *
        ) ;

    //  caller must set the buffer state correctly if a buffer is retrieved;
    //    might have to remove it from the cache
    DWORD
    TryGetPVRReadBufferForRead_ (
        OUT PVR_READ_BUFFER **  ppPVRReadBuffer
        ) ;

    //  buffer contains valid data, and we can make sure that it's kept
    //    for as long as possible by touching in
    void
    Touch_ (
        IN  PVR_READ_BUFFER *   pPVRReadBuffer
        ) ;

    public :

        CPVRAsyncReader (
            IN  HANDLE              hFile,                      //  duplicated; must be bound to async io obj
            IN  LPWSTR              pszWriteBufferMapping,
            IN  DWORD               dwIoSize,
            IN  CAsyncIo *          pAsyncIo,
            IN  DWORD               dwTotalBuffering,
            IN  CPVRIOCounters *    pPVRIOCounters,
            OUT DWORD *             pdwRet
            ) ;

        ~CPVRAsyncReader (
            ) ;

        //  will not lock
        void
        Snapshot (
            IN OUT  PVR_ASYNCREADER_COUNTER *   pPVRAsyncReaderCounters
            ) ;

        ULONGLONG
        CurLength (
            ) ;

        DWORD
        DrainPendedIo (
            ) ;

        DWORD
        ReadBytes (
            IN      ULONGLONG   ullStreamRead,
            IN OUT  DWORD *     pdwLength,
            OUT     BYTE *      pbBuffer
            ) ;

        void
        Seek (
            IN OUT  ULONGLONG * pullStreamTo
            ) ;

        virtual
        void
        IOCompleted (
            IN  DWORD       dwIoBytes,
            IN  DWORD_PTR   dwpContext,
            IN  DWORD       dwIOReturn
            ) ;

        static
        HANDLE
        OpenFile (
            IN  LPCWSTR                 pszFilename,
            IN  DWORD                   dwFileSharingFlags,
            IN  DWORD                   dwFileCreation,
            IN  SECURITY_ATTRIBUTES *   pSec        = NULL
            )
        {
            return ::CreateFile (
                        pszFilename,                                                //  fn
                        GENERIC_READ,                                               //  desired access
                        dwFileSharingFlags,                                         //  share
                        pSec,                                                       //  security
                        dwFileCreation,                                             //  maybe clobber
                        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,              //  flags
                        NULL
                        ) ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CPVRAsyncReaderCOM :
    public IDVRAsyncReader
{
    DWORD               m_dwIOSize ;
    DWORD               m_dwBufferCount ;
    CAsyncIo *          m_pAsyncIo ;
    LONG                m_cRef ;
    CPVRAsyncReader *   m_pPVRAsyncReader ;
    CRITICAL_SECTION    m_crt ;
    ULONGLONG           m_ullCurReadPosition ;
    CPVRIOCounters *    m_pPVRIOCounters ;

    void Lock_()        { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_()      { ::LeaveCriticalSection (& m_crt) ; }

    public :

        CPVRAsyncReaderCOM (
            IN  DWORD               dwIOSize,
            IN  DWORD               dwBufferCount,
            IN  CAsyncIo *          pAsyncIo,
            IN  CPVRIOCounters *    pPVRIOCounters
            ) ;

        ~CPVRAsyncReaderCOM (
            ) ;

        //  --------------------------------------------------------------------
        //  IUnknown methods

        virtual STDMETHODIMP_(ULONG) AddRef () ;
        virtual STDMETHODIMP_(ULONG) Release () ;
        virtual STDMETHODIMP QueryInterface (IN REFIID, OUT void **) ;

        //  --------------------------------------------------------------------
        //  IDVRAsyncReader

        virtual
        STDMETHODIMP
        OpenFile (
            IN  GUID *  pguidWriterId,              //  if NULL, file is not live
            IN  LPCWSTR pszFilename,                //  target file
            IN  DWORD   dwFileSharingFlags,         //  file sharing flags
            IN  DWORD   dwFileCreation              //  file creation
            ) ;

        virtual
        STDMETHODIMP
        CloseFile (
            ) ;

        virtual
        STDMETHODIMP
        ReadBytes (
            IN OUT  DWORD * pdwLength,
            OUT     BYTE *  pbBuffer
            ) ;

        //  1. it is legal to specify a position > than current max of the file;
        //      when this happens, the position is snapped to the EOF, and the
        //      EOF at time-of-call, is returned in the pliSeekedTo member;
        //  2. if (* pliSeekTo) == 0, (* pliSeekedTo) will return the time-of-call
        //      EOF
        //  3. (* pliSeekTo) need not be sector-aligned
        virtual
        STDMETHODIMP
        Seek (
            IN  LARGE_INTEGER * pliSeekTo,
            IN  DWORD           dwMoveMethod,   //  FILE_BEGIN, FILE_CURRENT, FILE_END
            OUT LARGE_INTEGER * pliSeekedTo     //  can be NULL
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CAsyncIo
{
    enum {
        THREAD_PULSE_MILLIS         = 100,      //  completion thread pulses often
        MAX_DRAIN_WAIT_ITERATIONS   = 20,       //  when we drain the IOs, we iterate this max times
        DRAIN_WAIT_ITERATION_PAUSE  = 50,       //  when we drain the IOs, we pause fo this many millis
    } ;

    struct ASYNC_IO_CONTEXT {
        LIST_ENTRY      ListEntry ;
        OVERLAPPED      Overlapped ;
        DWORD_PTR       dwpContext ;
        CIoCompletion * pIoCompletion ;

        void SetOverlappedOffset (IN ULONGLONG ullIoOffset) {
            Overlapped.Offset       = (DWORD) (0x00000000ffffffff & ullIoOffset) ;
            Overlapped.OffsetHigh   = (DWORD) (0x00000000ffffffff & (ullIoOffset >> 32)) ;
        }

        static ASYNC_IO_CONTEXT * Recover (IN LIST_ENTRY * pListEntry) {
            ASYNC_IO_CONTEXT *  pAsyncIoContext ;

            pAsyncIoContext = CONTAINING_RECORD (pListEntry, ASYNC_IO_CONTEXT, ListEntry) ;
            return pAsyncIoContext ;
        }

        static ASYNC_IO_CONTEXT * Recover (IN OVERLAPPED * pOverlapped) {
            ASYNC_IO_CONTEXT *  pAsyncIoContext ;

            pAsyncIoContext = CONTAINING_RECORD (pOverlapped, ASYNC_IO_CONTEXT, Overlapped) ;
            return pAsyncIoContext ;
        }
    } ;

    TStructPool <ASYNC_IO_CONTEXT, 50>  m_IoContextPool ;
    CRITICAL_SECTION                    m_crt ;
    LONG                                m_cIoPending ;
    LIST_ENTRY                          m_leIoPending ;
    HANDLE                              m_hCompletionThread ;
    BOOL                                m_fThreadExit ;
    HANDLE                              m_hIoCompletionPort ;
    LONG                                m_cRef ;

    void Lock_ ()       { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { ::LeaveCriticalSection (& m_crt) ; }

    void
    ThreadProc_ (
        ) ;

    DWORD
    ConfirmCompletionThreadRunning_ (
        )
    {
        DWORD   dwRet ;

        dwRet = NOERROR ;

        if (!m_hCompletionThread) {
            ASSERT (m_hIoCompletionPort) ;
            m_hCompletionThread = ::CreateThread (
                    NULL,
                    0,
                    CAsyncIo::ThreadEntry,
                    (LPVOID) this,
                    NULL,
                    NULL
                    ) ;
            if (!m_hCompletionThread) {
                dwRet = ::GetLastError () ;
            }
        }

        return dwRet ;
    }

    DWORD
    DrainPendedIo_ (
        ) ;

    public :

        CAsyncIo (
            ) ;

        ~CAsyncIo (
            ) ;

        LONG AddRef () ;
        LONG Release () ;

        DWORD
        Bind (
            IN  HANDLE      hFileHandle,
            IN  ULONG_PTR   ulpContext = 0
            ) ;

        DWORD
        Stop (
            ) ;

        static
        DWORD
        WINAPI
        ThreadEntry (
            IN  LPVOID  pv
            )
        {
            reinterpret_cast <CAsyncIo *> (pv) -> ThreadProc_ () ;
            return EXIT_SUCCESS ;
        }

        DWORD
        DrainPendedIo (
            ) ;

        void
        ProcessIOCompletion (
            IN  DWORD           dwBytes,
            IN  OVERLAPPED *    pOverlapped,
            IN  DWORD           dwIoRet
            ) ;

        DWORD
        PendRead (
            IN  HANDLE          hFile,
            IN  ULONGLONG       ullReadOffset,
            IN  BYTE *          pbBuffer,
            IN  DWORD           dwBufferLength,
            IN  DWORD_PTR       dwpContext,
            IN  CIoCompletion * pIOCompletion
            ) ;

        DWORD
        PendWrite (
            IN  HANDLE          hFile,
            IN  ULONGLONG       ullWriteOffset,
            IN  BYTE *          pbBuffer,
            IN  DWORD           dwBufferLength,
            IN  DWORD_PTR       dwpContext,
            IN  CIoCompletion * pIOCompletion
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CPVRAsyncWriter :
    public CIoCompletion
{
    enum  {
        WAIT_FOR_DRAIN,             //  dwWaitContext ignored
        WAIT_FOR_COMPLETION         //  dwWaitContext is the buffer index we're waiting for
    } ;

    struct PVR_WRITE_WAIT {
        BOOL    fWaiting ;
        DWORD   PVRWriteWaitFor ;
        DWORD   dwWaitContext ;
        DWORD   dwWaitRet ;
    } ;

    CAsyncIo *                  m_pAsyncIo ;
    HANDLE                      m_hFileIo ;         //  file handle for IO; alignment restrictions
    HANDLE                      m_hFileLen ;        //  file handle use to set file length; no alignment restrictions on this one
    LONG                        m_cIoPending ;
    CRITICAL_SECTION            m_crt ;
    CPVRWriteBufferStreamWriter m_WriteBufferWriter ;
    DWORD                       m_dwAlignment ;
    DWORD                       m_dwFileGrowthQuantum ;
    ULONGLONG                   m_ullCurFileLength ;
    CPVRIOCounters *            m_pPVRIOCounters ;

    PVR_WRITE_WAIT              m_PVRWriteWait ;
    HANDLE                      m_hWaiting ;

    void Lock_ ()               { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()             { LeaveCriticalSection (& m_crt) ; }

    void
    CheckForWaits_ (
        IN  PVR_WRITE_BUFFER *  pPVRCompletedWriteBuffer
        ) ;

    static
    DWORD
    SetFilePointer_ (
        IN  HANDLE      hFile,
        IN  ULONGLONG   ullOffset
        ) ;

    DWORD
    MaybeGrowFile_ (
        IN  ULONGLONG   ullCurValidLen,
        IN  DWORD       cBytesToWrite
        ) ;

    protected :

    DWORD                       m_dwNumSids ;
    PSID*                       m_ppSids ;

        void
        UninitializeWriter_ (
            )
        {
            m_WriteBufferWriter.Uninitialize () ;
        }

        DWORD
        InitializeWriter_ (
            IN  BYTE *  pbMemory,
            IN  DWORD   dwMemoryLength,
            IN  DWORD   dwIOSize,
            IN  DWORD   dwBufferCount,
            IN  DWORD   dwAlignment
            ) ;

        DWORD
        SetPVRFileLength_ (
            IN  ULONGLONG   ullTargetLength     //  can be unaligned
            ) ;

    public :

        CPVRAsyncWriter (
            IN  HANDLE              hFileIo,                        //  duplicated
            IN  HANDLE              hFileLen,                       //  duplicated; buffered so no alignment restrictions; this handle will be used to set length
            IN  DWORD               dwIOSize,
            IN  DWORD               dwBufferCount,
            IN  DWORD               dwAlignment,
            IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
            IN  CAsyncIo *          pAsyncIo,
            IN  CPVRIOCounters *    pPVRIOCounters,
            IN  DWORD               dwNumSids,
            IN  PSID*               ppSids,
            OUT DWORD *             pdwRet
            ) ;

        CPVRAsyncWriter (
            IN  BYTE *              pbMemory,
            IN  DWORD               dwMemoryLength,
            IN  HANDLE              hFileIo,                        //  duplicated
            IN  HANDLE              hFileLen,                       //  duplicated; buffered so no alignment restrictions; this handle will be used to set length
            IN  DWORD               dwIOSize,
            IN  DWORD               dwBufferCount,
            IN  DWORD               dwAlignment,
            IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
            IN  CAsyncIo *          pAsyncIo,
            IN  CPVRIOCounters *    pPVRIOCounters,
            OUT DWORD *             pdwRet
            ) ;

        virtual
        ~CPVRAsyncWriter (
            ) ;

        PVR_WRITE_BUFFER_STREAM *
        PVRBufferStream ()
        {
            return m_WriteBufferWriter.WriteBufferStream () ;
        }

        DWORD
        Flush (
            OUT ULONGLONG * pullFileLength = NULL  OPTIONAL
            ) ;

        static
        DWORD
        SetFileLength (
            IN  HANDLE      hFile,          //  use buffered file handle if not sector-aligned length
            IN  ULONGLONG   ullLength
            ) ;

        DWORD
        AppendBytes (
            IN OUT  BYTE ** ppbBuffer,
            IN OUT  DWORD * pdwBufferLength
            ) ;

        ULONGLONG
        BytesAppended (
            ) ;

        //  CIoCompletion method
        virtual
        void
        IOCompleted (
            IN  DWORD       dwIoBytes,
            IN  DWORD_PTR   dwpContext,
            IN  DWORD       dwIOReturn
            ) ;

        static
        BOOL
        MemoryOk (
            IN  BYTE *  pbMemory,                           //  base memory pointer
            IN  DWORD   dwLength,                           //  amount of memory to play with
            IN  DWORD   dwAlignment,                        //  required PVR_WRITE_BUFFER's buffer alignment
            IN  DWORD   dwIoSize,                           //  size of each buffer
            IN  DWORD   dwBufferCount,                      //  number of buffers
            OUT DWORD * pdwExtraMemory  = NULL OPTIONAL,    //  returns the extra memory required
            OUT BYTE ** ppbBuffers      = NULL OPTIONAL     //  points to first backing buffer (PVR_WRITE_BUFFER [0]'s)
            )
        {
            return CPVRWriteBufferStreamWriter::MemoryOk (
                        pbMemory,
                        dwLength,
                        dwAlignment,
                        dwIoSize,
                        dwBufferCount,
                        pdwExtraMemory,
                        ppbBuffers
                        ) ;
        }

        static
        HANDLE
        OpenFile (
            IN  LPCWSTR                 pszFilename,
            IN  DWORD                   dwFileSharingFlags,
            IN  DWORD                   dwFileCreation,
            IN  BOOL                    fBuffered = FALSE,
            IN  SECURITY_ATTRIBUTES *   pSec        = NULL
            )
        {
            return ::CreateFile (
                        pszFilename,                                                    //  fn
                        GENERIC_WRITE,                                                  //  desired access
                        dwFileSharingFlags,                                             //  share
                        pSec,                                                           //  security
                        dwFileCreation,                                                 //  maybe clobber
                        (fBuffered ? FILE_ATTRIBUTE_NORMAL :
                                     FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED),    //  flags
                        NULL
                        ) ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CPVRAsyncWriterSharedMem :
    public CPVRAsyncWriter
{
    enum {
        //
        //  given alignment requirements, we must make sure that the buffers
        //    are properly aligned; this can mean that we must allocate more
        //    than precisely header size + data buffers i.e. there can be a gap
        //    between the headers and the data buffers, just because the latter
        //    must be properly aligned; this constant is the max number of
        //    iterations during which we grow the desired total mapping size,
        //    map, and check for containment
        MAX_MEM_FRAMING_TRIES   = 5,
    } ;

    CWin32SharedMem *   m_pSharedMem ;

    public :

        CPVRAsyncWriterSharedMem (
            IN  HANDLE              hFileIo,                        //  duplicated
            IN  HANDLE              hFileLen,                       //  duplicated; buffered so no alignment restrictions; this handle will be used to set length
            IN  LPWSTR              pszPVRBufferStreamMap,
            IN  DWORD               dwIOSize,
            IN  DWORD               dwBufferCount,
            IN  DWORD               dwAlignment,
            IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
            IN  CAsyncIo *          pAsyncIo,
            IN  CPVRIOCounters *    pPVRIOCounters,
            IN  DWORD               dwNumSids,
            IN  PSID*               ppSids,
            OUT DWORD *             pdwRet
            ) ;

        virtual
        ~CPVRAsyncWriterSharedMem (
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CPVRAsyncWriterCOM :
    public IDVRAsyncWriter
{
    DWORD               m_dwIOSize ;
    DWORD               m_dwBufferCount ;
    DWORD               m_dwAlignment ;
    DWORD               m_dwFileGrowthQuantum ;
    CAsyncIo *          m_pAsyncIo ;
    LONG                m_cRef ;
    CPVRAsyncWriter *   m_pPVRAsyncWriter ;
    CRITICAL_SECTION    m_crt ;
    GUID                m_guidWriterId ;
    CPVRIOCounters *    m_pPVRIOCounters ;
    DWORD               m_dwNumSids ;
    PSID*               m_ppSids ;

    void Lock_()        { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_()      { ::LeaveCriticalSection (& m_crt) ; }

    public :

        CPVRAsyncWriterCOM (
            IN  DWORD               dwIOSize,
            IN  DWORD               dwBufferCount,
            IN  DWORD               dwAlignment,
            IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
            IN  CAsyncIo *          pAsyncIo,
            IN  CPVRIOCounters *    pPVRIOCounters,
            IN  DWORD               dwNumSids,
            IN  PSID*               ppSids,
            OUT DWORD *             pdwRet
            ) ;

        ~CPVRAsyncWriterCOM (
            ) ;

        static
        DWORD
        NewGUID (
            OUT GUID    guidNew
            ) ;

        //  --------------------------------------------------------------------
        //  IUnknown methods

        virtual STDMETHODIMP_(ULONG) AddRef () ;
        virtual STDMETHODIMP_(ULONG) Release () ;
        virtual STDMETHODIMP QueryInterface (IN REFIID, OUT void **) ;

        //  --------------------------------------------------------------------
        //  IDVRAsyncWriter

        virtual
        STDMETHODIMP
        GetWriterId (
            OUT GUID *  pguidWriterId
            ) ;

        virtual
        STDMETHODIMP
        SetWriterActive (
            IN  LPCWSTR pszFilename,                //  should already have been created
            IN  DWORD   dwFileSharingFlags,         //  file sharing flags
            IN  DWORD   dwFileCreation              //  file creation
            ) ;

        virtual
        STDMETHODIMP
        SetWriterInactive (
            ) ;

        virtual
        STDMETHODIMP
        AppendBytes (
            IN OUT  BYTE ** ppbBuffer,
            IN OUT  DWORD * pdwBufferLength
            ) ;

        virtual
        STDMETHODIMP
        FlushToDisk (
            ) ;

        virtual
        STDMETHODIMP
        TotalBytes (
            OUT ULONGLONG * pullTotalBytesAppended
            ) ;
} ;

#endif  //  __dvrasyncio_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvrasyncio.cpp ===
#include <precomp.h>
#pragma hdrstop

//  ============================================================================
//  ============================================================================

CAsyncIo::CAsyncIo (
    ) : m_cIoPending        (0),
        m_fThreadExit       (FALSE),
        m_hCompletionThread (NULL),
        m_hIoCompletionPort (NULL),
        m_cRef              (0)
{
    ::InitializeCriticalSection (& m_crt) ;
    InitializeListHead (& m_leIoPending) ;
}

CAsyncIo::~CAsyncIo (
    )
{
    ASSERT (m_cIoPending == 0) ;
    ASSERT (IsListEmpty (& m_leIoPending)) ;

    Stop () ;

    ASSERT (!m_hCompletionThread) ;

    if (m_hIoCompletionPort) {
        ::CloseHandle (m_hIoCompletionPort) ;
    }

    ::DeleteCriticalSection (& m_crt) ;
}

LONG
CAsyncIo::AddRef (
    )
{
    return ::InterlockedIncrement (& m_cRef) ;
}

LONG
CAsyncIo::Release (
    )
{
    if (::InterlockedDecrement (& m_cRef) == 0) {
        delete this ;
        return 0 ;
    }

    return 1 ;
}

DWORD
CAsyncIo::Bind (
    IN  HANDLE      hFileHandle,
    IN  ULONG_PTR   ulpContext
    )
{
    DWORD   dwRet ;
    HANDLE  hRet ;

    if (!m_hIoCompletionPort) {
        m_hIoCompletionPort = ::CreateIoCompletionPort (
                                    INVALID_HANDLE_VALUE,
                                    NULL,
                                    (ULONG_PTR) this,
                                    1
                                    ) ;
        if (!m_hIoCompletionPort) {
            dwRet = ::GetLastError () ;
        }
    }

    if (m_hIoCompletionPort) {
        hRet = ::CreateIoCompletionPort (
                    hFileHandle,
                    m_hIoCompletionPort,
                    ulpContext,
                    1
                    ) ;
        if (hRet == m_hIoCompletionPort) {
            dwRet = NOERROR ;
        }
        else {
            dwRet = ::GetLastError () ;
        }
    }
    else {
        dwRet = ERROR_GEN_FAILURE ;
    }

    return dwRet ;
}

void
CAsyncIo::ThreadProc_ (
    )
{
    BOOL            r ;
    DWORD           dwBytes ;
    ULONG_PTR       ulpContext ;
    OVERLAPPED *    pOverlapped ;
    DWORD           dwIoRet ;

    ASSERT (m_hIoCompletionPort) ;

    while (!m_fThreadExit) {
        r = ::GetQueuedCompletionStatus (
                    m_hIoCompletionPort,
                    & dwBytes,
                    & ulpContext,
                    & pOverlapped,
                    THREAD_PULSE_MILLIS
                    ) ;

        if (pOverlapped) {

            if (r) {
                dwIoRet = NOERROR ;
            }
            else {
                dwIoRet = ::GetLastError () ;
            }

            ProcessIOCompletion (
                dwBytes,
                pOverlapped,
                dwIoRet
                ) ;
        }
    } ;
}

DWORD
CAsyncIo::Stop (
    )
{
    DWORD   dwRet ;

    if (m_hCompletionThread) {

        DrainPendedIo () ;

        m_fThreadExit = TRUE ;

        ::WaitForSingleObject (m_hCompletionThread, INFINITE) ;
        ::CloseHandle (m_hCompletionThread) ;
        m_hCompletionThread = NULL ;

        dwRet = NOERROR ;
    }
    else {
        dwRet = NOERROR ;
    }

    return dwRet ;
}

DWORD
CAsyncIo::DrainPendedIo (
    )
{
    int     i ;
    LONG    c ;

    for (i = 0; i < MAX_DRAIN_WAIT_ITERATIONS; i++) {

        Lock_ () ;

        c = m_cIoPending ;

        if (c == 0) {
            Unlock_ () ;
            break ;
        }

        Unlock_ () ;

        ::Sleep (DRAIN_WAIT_ITERATION_PAUSE) ;
    }

    return (c == 0 ? NOERROR : ERROR_GEN_FAILURE) ;
}

void
CAsyncIo::ProcessIOCompletion (
    IN  DWORD           dwBytes,
    IN  OVERLAPPED *    pOverlapped,
    IN  DWORD           dwIoRet
    )
{
    ASYNC_IO_CONTEXT *  pAsyncIOContext ;
    DWORD_PTR           dwpContext ;
    CIoCompletion *     pIoCompletion ;

    pAsyncIOContext = ASYNC_IO_CONTEXT::Recover (pOverlapped) ;

    Lock_ () ;

    RemoveEntryList (& pAsyncIOContext -> ListEntry) ;

    dwpContext      = pAsyncIOContext -> dwpContext ;
    pIoCompletion   = pAsyncIOContext -> pIoCompletion ;

    m_IoContextPool.Recycle (pAsyncIOContext) ;

    Unlock_ () ;

    pIoCompletion -> IOCompleted (
        dwBytes,
        dwpContext,
        dwIoRet
        ) ;

    ::InterlockedDecrement (& m_cIoPending) ;
    Release () ;
}

DWORD
CAsyncIo::PendRead (
    IN  HANDLE          hFile,
    IN  ULONGLONG       ullReadOffset,
    IN  BYTE *          pbBuffer,
    IN  DWORD           dwBufferLength,
    IN  DWORD_PTR       dwpContext,
    IN  CIoCompletion * pIOCompletion
    )
{
    DWORD               dwRet ;
    ASYNC_IO_CONTEXT *  pAsyncIOContext ;
    BOOL                r ;
    DWORD               dwRead ;

    dwRet = ConfirmCompletionThreadRunning_ () ;
    if (dwRet == NOERROR) {

        ASSERT (m_hIoCompletionPort) ;
        ASSERT (m_hCompletionThread) ;

        pAsyncIOContext = m_IoContextPool.Get () ;
        if (pAsyncIOContext) {

            pAsyncIOContext -> SetOverlappedOffset (ullReadOffset) ;
            pAsyncIOContext -> Overlapped.hEvent    = 0 ;
            pAsyncIOContext -> dwpContext           = dwpContext ;
            pAsyncIOContext -> pIoCompletion        = pIOCompletion ;

            Lock_ () ;

            InsertHeadList (& m_leIoPending, & pAsyncIOContext -> ListEntry) ;
            ::InterlockedIncrement (& m_cIoPending) ;

            Unlock_ () ;

            AddRef () ;

            r = ::ReadFile (
                        hFile,
                        pbBuffer,
                        dwBufferLength,
                        & dwRead,
                        & pAsyncIOContext -> Overlapped
                        ) ;

            if (r) {
                dwRet = NOERROR ;
            }
            else {
                dwRet = ::GetLastError () ;
                if (dwRet != ERROR_IO_PENDING) {
                    //  failed outright; recycle the context
                    m_IoContextPool.Recycle (pAsyncIOContext) ;

                    Lock_ () ;
                    RemoveEntryList (& pAsyncIOContext -> ListEntry) ;
                    Unlock_ () ;

                    ::InterlockedDecrement (& m_cIoPending) ;
                    Release () ;
                }
            }
        }
        else {
            dwRet = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }

    TRACE_3 (LOG_AREA_PVRIO, 6,
        TEXT ("CAsyncIo::PendRead () ullReadOffset = %I64u; dwBufferLength = %u; dwRet = %u"),
        ullReadOffset, dwBufferLength, dwRet) ;

    return dwRet ;
}

DWORD
CAsyncIo::PendWrite (
    IN  HANDLE          hFile,
    IN  ULONGLONG       ullWriteOffset,
    IN  BYTE *          pbBuffer,
    IN  DWORD           dwBufferLength,
    IN  DWORD_PTR       dwpContext,
    IN  CIoCompletion * pIOCompletion
    )
{
    DWORD               dwRet ;
    ASYNC_IO_CONTEXT *  pAsyncIOContext ;
    BOOL                r ;
    DWORD               dwWritten ;

    dwRet = ConfirmCompletionThreadRunning_ () ;
    if (dwRet == NOERROR) {
        ASSERT (m_hIoCompletionPort) ;
        ASSERT (m_hCompletionThread) ;

        pAsyncIOContext = m_IoContextPool.Get () ;
        if (pAsyncIOContext) {

            pAsyncIOContext -> SetOverlappedOffset (ullWriteOffset) ;
            pAsyncIOContext -> Overlapped.hEvent    = 0 ;
            pAsyncIOContext -> dwpContext           = dwpContext ;
            pAsyncIOContext -> pIoCompletion        = pIOCompletion ;

            Lock_ () ;

            InsertHeadList (& m_leIoPending, & pAsyncIOContext -> ListEntry) ;
            ::InterlockedIncrement (& m_cIoPending) ;

            Unlock_ () ;

            AddRef () ;

            r = ::WriteFile (
                        hFile,
                        pbBuffer,
                        dwBufferLength,
                        & dwWritten,
                        & pAsyncIOContext -> Overlapped
                        ) ;
            if (r) {
                dwRet = NOERROR ;
            }
            else {
                dwRet = ::GetLastError () ;
                if (dwRet != ERROR_IO_PENDING) {
                    m_IoContextPool.Recycle (pAsyncIOContext) ;

                    //  failed outright; recycle the context
                    Lock_ () ;
                    m_IoContextPool.Recycle (pAsyncIOContext) ;
                    Unlock_ () ;

                    ::InterlockedDecrement (& m_cIoPending) ;
                    Release () ;
                }
            }
        }
        else {
            dwRet = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }

    TRACE_3 (LOG_AREA_PVRIO, 6,
        TEXT ("CAsyncIo::PendWrite () ullWriteOffset = %I64u; dwBufferLength = %u; dwRet = %u"),
        ullWriteOffset, dwBufferLength, dwRet) ;

    return dwRet ;
}

//  ============================================================================
//  ============================================================================

CPVRWriteBufferStream::CPVRWriteBufferStream (
    ) : m_pMutex                        (NULL),
        m_pPVRWriteBufferStream         (NULL),
        m_dwMaxBufferingBytes           (0),
        m_dwMaxBufferingBytesFilling    (0)
{
}

CPVRWriteBufferStream::~CPVRWriteBufferStream (
    )
{
    Uninitialize () ;

    ASSERT (!m_pMutex) ;
}

DWORD
CPVRWriteBufferStream::Initialize (
    IN  HANDLE                      hWriteBufferMutex,
    IN  PVR_WRITE_BUFFER_STREAM *   pPVRWriteBufferStream
    )
{
    DWORD   dwRet ;

    ASSERT (hWriteBufferMutex) ;
    ASSERT (!m_pMutex) ;
    ASSERT (pPVRWriteBufferStream) ;
    ASSERT (!m_pPVRWriteBufferStream) ;

    //  mutex first
    m_pMutex = new CMutexLock (
                        hWriteBufferMutex,
                        & dwRet
                        ) ;
    if (!m_pMutex) {
        dwRet = ERROR_NOT_ENOUGH_MEMORY ;
        goto cleanup ;
    }
    else if (dwRet != NOERROR) {
        delete m_pMutex ;
        m_pMutex = NULL ;
        goto cleanup ;
    }

    m_pPVRWriteBufferStream = pPVRWriteBufferStream ;

    //  compute a couple of values we use all the time
    m_dwMaxBufferingBytes = m_pPVRWriteBufferStream -> dwBufferCount * m_pPVRWriteBufferStream -> dwIoLength ;
    m_dwMaxBufferingBytesFilling = m_dwMaxBufferingBytes - m_pPVRWriteBufferStream -> dwIoLength ;

    cleanup :

    return dwRet ;
}

//  ============================================================================
//  ============================================================================

DWORD
CPVRWriteBufferStreamReader::RetrieveMutex_ (
    IN  SECURITY_ATTRIBUTES *   pSec,
    IN  REFGUID                 StreamId,
    OUT HANDLE *                phMutex
    )
{
    HANDLE  hMutex ;
    WCHAR   szStreamId [HW_PROFILE_GUIDLEN] ;
    WCHAR   szMutex [HW_PROFILE_GUIDLEN+10] ;
    int     k ;
    DWORD   dwRet ;

    ASSERT (phMutex) ;
    (* phMutex) = NULL ;

    //  create our mutex name
    k = ::StringFromGUID2 (
            StreamId,
            szStreamId,
            sizeof szStreamId / sizeof WCHAR
            ) ;
    if (k == 0) {
        //  a GUID is a GUID; this should not happen
        dwRet = ERROR_GEN_FAILURE ;
        goto cleanup ;
    }

    //  explicitely null-terminate this
    szStreamId [HW_PROFILE_GUIDLEN - 1] = L'\0' ;
    wcscpy(szMutex, L"Global\\");
    wcscat(szMutex, szStreamId);

    //  now create the mutex; don't race to own; serialization at this point
    //    should be done outside of this object
    (* phMutex) = ::OpenMutex (
                        SYNCHRONIZE,
                        FALSE,          // Inheritable
                        szMutex
                        ) ;
    if (* phMutex) {
        //  don't check for the case where it doesn't exist; we could be 2nd
        //    if someone is giving us a piece of memory with an inactive writer
        dwRet = NOERROR ;
    }
    else {
        //  some other error
        dwRet = ::GetLastError () ;
    }

    cleanup :

    return dwRet ;
}

DWORD
CPVRWriteBufferStreamReader::Initialize (
    IN  SECURITY_ATTRIBUTES *   pSec,
    IN  LPWSTR                  pszWriteBufferMapping
    )
{
    DWORD   dwRet ;
    DWORD   dwLen ;
    HRESULT hr ;
    HANDLE  hMutex ;

    ASSERT (pszWriteBufferMapping) ;
    ASSERT (!m_pPVRWriteBufferMM) ;

    //
    //  NOTE: serialization to initialize, uninitialize, and call this
    //    method must be done outside of this object !!!
    //

    //  file is live; set it all up;

    //  first map in the minimum so we can learn how much we'll need to map
    //    to get the whole thing

    m_pPVRWriteBufferMM = new CWin32SharedMem (
                                    pszWriteBufferMapping,
                                    sizeof PVR_WRITE_BUFFER_STREAM, //  we're first going to discover how much we'll need to map
                                    & hr
                                    ) ;
    if (!m_pPVRWriteBufferMM) {
        dwRet = ERROR_NOT_ENOUGH_MEMORY ;
        goto cleanup ;
    }
    else if (FAILED (hr)) {
        delete m_pPVRWriteBufferMM ;
        m_pPVRWriteBufferMM = NULL ;
        dwRet = ERROR_GEN_FAILURE ;
        goto cleanup ;
    }

    dwLen = ((PVR_WRITE_BUFFER_STREAM *) m_pPVRWriteBufferMM -> GetSharedMem ()) -> dwSharedMemSize ;
    ASSERT (dwLen > sizeof PVR_WRITE_BUFFER_STREAM) ;

    //  we should not have a race, according to our locking scheme
    ASSERT (((PVR_WRITE_BUFFER_STREAM *) m_pPVRWriteBufferMM -> GetSharedMem ()) -> fWriterActive) ;

    delete m_pPVRWriteBufferMM ;

    //  we now know how much memory we'll need

    m_pPVRWriteBufferMM = new CWin32SharedMem (
                                    pszWriteBufferMapping,
                                    dwLen,
                                    & hr
                                    ) ;
    if (!m_pPVRWriteBufferMM) {
        dwRet = ERROR_NOT_ENOUGH_MEMORY ;
        goto cleanup ;
    }
    else if (FAILED (hr)) {
        delete m_pPVRWriteBufferMM ;
        m_pPVRWriteBufferMM = NULL ;
        dwRet = ERROR_GEN_FAILURE ;
        goto cleanup ;
    }

    //  success

    //  get the mutex
    dwRet = RetrieveMutex_ (
                pSec,
                ((PVR_WRITE_BUFFER_STREAM *) m_pPVRWriteBufferMM -> GetSharedMem ()) -> StreamId,
                & hMutex
                ) ;
    if (dwRet != NOERROR) {
        goto cleanup ;
    }

    dwRet = CPVRWriteBufferStream::Initialize (
                hMutex,
                (PVR_WRITE_BUFFER_STREAM *) m_pPVRWriteBufferMM -> GetSharedMem ()
                ) ;

    //  done with this regardless of success/failure
    ::CloseHandle (hMutex) ;

    cleanup :

    if (dwRet != NOERROR) {
        Uninitialize () ;
    }

    return dwRet ;
}

BOOL
CPVRWriteBufferStreamReader::CopyAllBytes (
    IN  ULONGLONG   ullStream,
    IN  DWORD       dwLength,
    OUT BYTE *      pbBuffer
    )
{
    BOOL    r ;
    DWORD   dwBufferIndex ;
    DWORD   dwBufferOffset ;
    DWORD   dwCopy ;
    BOOL    fWriterActive ;

    r = FALSE ;

    //
    //  NOTE: serialization to initialize, uninitialize, and call this method
    //    must be done outside of this object !!!
    //

    if (m_pPVRWriteBufferStream) {

        Lock () ;
        ASSERT (CallerOwnsLock ()) ;

        r = AreBytesInWriteBuffer_ (ullStream, dwLength) ;

        if (r) {
            //  content is in the write buffer; setup to copy it out
            //  now walk through the write buffers and copy out the content

            //  determine the starting buffer, and offset into
            dwBufferIndex   = FirstByteIndex_ (ullStream) ;
            dwBufferOffset  = FirstByteBufferOffset_ (ullStream, dwBufferIndex) ;

            for (; dwLength > 0; dwBufferIndex++) {

                //  don't copy more than the bytes of interest in the buffer i.e.
                //    what's left after the offset, or the requested length
                dwCopy = Min <DWORD> (ValidLength_ (dwBufferIndex) - dwBufferOffset, dwLength) ;

                ::CopyMemory (
                        pbBuffer,
                        Buffer_ (dwBufferIndex) + dwBufferOffset,
                        dwCopy
                        ) ;

                //  advance
                dwLength -= dwCopy ;
                pbBuffer += dwCopy ;

                //  after the first buffer, this offset is always 0
                dwBufferOffset = 0 ;
            }
        }

        fWriterActive = WriterActive () ;

        Unlock () ;
        ASSERT (!CallerOwnsLock ()) ;

        //  if the writer is no longer active, we unmap everything; since we
        //    use the buffering passively, we don't need the lock to clear our
        //    refs from it
        if (!fWriterActive) {
            Uninitialize () ;
        }
    }

    return r ;
}

//  ============================================================================
//  ============================================================================

DWORD
CPVRWriteBufferStreamWriter::CreateUniqueMutex_ (
    IN  SECURITY_ATTRIBUTES *   pSec,
    IN  REFGUID                 StreamId,
    OUT HANDLE *                phMutex
    )
{
    WCHAR   szStreamId [HW_PROFILE_GUIDLEN] ;
    WCHAR   szMutex [HW_PROFILE_GUIDLEN+10] ;
    int     k ;
    DWORD   dwRet ;

    ASSERT (phMutex) ;
    (* phMutex) = NULL ;

    //  create our mutex name
    k = ::StringFromGUID2 (
            StreamId,
            szStreamId,
            sizeof szStreamId / sizeof WCHAR
            ) ;
    if (k == 0) {
        //  a GUID is a GUID; this should not happen
        dwRet = ERROR_GEN_FAILURE ;
        goto cleanup ;
    }

    //  explicitely null-terminate this
    szStreamId [HW_PROFILE_GUIDLEN - 1] = L'\0' ;
    wcscpy(szMutex, L"Global\\");
    wcscat(szMutex, szStreamId);

    //  now create the mutex; don't race to own; serialization at this point
    //    should be done outside of this object

    (* phMutex) = ::CreateMutex (
                        pSec, 
                        FALSE,
                        szMutex
                        ) ;
    if (* phMutex) {
        //  make sure that it did not exist already
        dwRet = ::GetLastError () ;
        if (dwRet != ERROR_ALREADY_EXISTS) {
            //  success
            dwRet = NOERROR ;
        }
        else {
            //  constitutes a failure; we should be the first as the writer
            ::CloseHandle (* phMutex) ;
            (* phMutex) = NULL ;

            //  leave the error; send itback out
        }
    }
    else {
        //  some other error
        dwRet = ::GetLastError () ;
    }

cleanup :

    return dwRet ;
}

DWORD
CPVRWriteBufferStreamWriter::Initialize (
    IN  SECURITY_ATTRIBUTES *   pSec,
    IN  BYTE *                  pbMemory,       //  base pointer to memory (PVR_WRITE_BUFFER_STREAM *)
    IN  DWORD                   dwLength,       //  of memory
    IN  DWORD                   dwAlignment,    //  buffer alignment
    IN  DWORD                   dwIoSize,       //  IO size
    IN  DWORD                   dwBufferCount   //  number of buffers
    )
{
    DWORD   dwRet ;
    DWORD   i ;
    BYTE *  pbBuffers ;
    BOOL    r ;
    GUID    guidStreamId ;
    HANDLE  hMutex ;

    ASSERT (!(dwIoSize % dwAlignment)) ;

    r = MemoryOk (
            pbMemory,
            dwLength,
            dwAlignment,
            dwIoSize,
            dwBufferCount,
            NULL,
            & pbBuffers
            ) ;
    if (r) {

        //  obtain the GUID that will uniquely identify this stream
        dwRet = ::UuidCreate (& guidStreamId) ;
        if (dwRet != NOERROR) {
            goto cleanup ;
        }

        dwRet = CreateUniqueMutex_ (pSec, guidStreamId, & hMutex) ;
        if (dwRet != NOERROR) {
            goto cleanup ;
        }

        ASSERT (hMutex) ;

        //  we can now initialize our base class
        dwRet = CPVRWriteBufferStream::Initialize (
                    hMutex,
                    (PVR_WRITE_BUFFER_STREAM *) pbMemory
                    ) ;

        //  we are done with the mutex regardless of success/failure
        ::CloseHandle (hMutex) ;

        if (dwRet == NOERROR) {

            //  initialize the data structures

            ASSERT (m_pPVRWriteBufferStream) ;

            m_pPVRWriteBufferStream -> fWriterActive                    = TRUE ;
            m_pPVRWriteBufferStream -> StreamId                         = guidStreamId ;
            m_pPVRWriteBufferStream -> dwSharedMemSize                  = dwLength ;
            m_pPVRWriteBufferStream -> dwIoLength                       = dwIoSize ;
            m_pPVRWriteBufferStream -> dwBufferCount                    = dwBufferCount ;
            m_pPVRWriteBufferStream -> dwCurrentWriteIndex              = 0 ;
            m_pPVRWriteBufferStream -> dwMaxContiguousCompletedIndex    = 0 ;
            m_pPVRWriteBufferStream -> ullMaxCopied                     = 0L ;
            m_pPVRWriteBufferStream -> ullMaxContiguousCompleted        = 0L ;

            for (i = 0; i < dwBufferCount; i++) {
                m_pPVRWriteBufferStream -> PVRBuffer [i].dwIndex            = UNDEFINED ;
                m_pPVRWriteBufferStream -> PVRBuffer [i].BufferState        = BUFFER_STATE_INVALID ;
                m_pPVRWriteBufferStream -> PVRBuffer [i].ullBufferOffset    = (ULONGLONG) ((pbBuffers + (i * m_pPVRWriteBufferStream -> dwIoLength)) -
                                                                                   (BYTE *) (& m_pPVRWriteBufferStream -> PVRBuffer [i])) ;
                m_pPVRWriteBufferStream -> PVRBuffer [i].dwData             = 0 ;
            }

            //  initialize our first buffer
            CurPVRWriteBuffer () -> BufferState = BUFFER_STATE_FILLING ;
            CurPVRWriteBuffer () -> dwIndex     = m_pPVRWriteBufferStream -> dwCurrentWriteIndex ;
        }
    }
    else {
        dwRet = ERROR_INVALID_PARAMETER ;
    }

    cleanup :

    return dwRet ;
}

void
CPVRWriteBufferStreamWriter::Uninitialize (
    )
{
    Lock () ;

    //  flag the writer OFF
    if (m_pPVRWriteBufferStream) {
        m_pPVRWriteBufferStream -> fWriterActive = FALSE ;
    }

    Unlock () ;

    CPVRWriteBufferStream::Uninitialize () ;
}

//  appends max # of bytes to cur write buffer
DWORD
CPVRWriteBufferStreamWriter::AppendToCurPVRWriteBuffer (
    IN OUT  BYTE ** ppbBuffer,                      //  [in] buffer before copy; [out] buffer after copy
    IN OUT  DWORD * pdwBufferLength,                //  [in] bytes to copy; [out] bytes remaining (if buffer becomes full)
    OUT     DWORD * pdwCurWriteBufferBytesLeft      //  after the write
    )
{
    DWORD       dwRet ;
    BYTE *      pbCopyTo ;
    DWORD       dwCopyBytes ;

    if ((* pdwBufferLength) == 0) {
        return NOERROR ;
    }

    dwRet = NOERROR ;

    ASSERT (!CallerOwnsLock ()) ;

    if (Lock ()) {

        ASSERT (CallerOwnsLock ()) ;
        ASSERT (CurPVRWriteBuffer () -> BufferState == BUFFER_STATE_FILLING) ;

        //  figure out how many bytes we're going to copy
        dwCopyBytes = Min <DWORD> (
                        InvalidBytesInBuffer_ (CurPVRWriteBuffer () -> dwIndex),
                        (* pdwBufferLength)
                        ) ;

        if (dwCopyBytes > 0) {

            //  offset into the write buffer
            pbCopyTo = Buffer (CurPVRWriteBuffer ()) + CurPVRWriteBuffer () -> dwData ;

            //  copy it in
            ::CopyMemory (
                pbCopyTo,
                (* ppbBuffer),
                dwCopyBytes
                ) ;

            //  advance
            (* ppbBuffer)       += dwCopyBytes ;
            (*pdwBufferLength)  -= dwCopyBytes ;

            //  update state
            CurPVRWriteBuffer () -> dwData          += dwCopyBytes ;
            m_pPVRWriteBufferStream -> ullMaxCopied += dwCopyBytes ;

            //  return param: bytes remaining in write buffer
            (* pdwCurWriteBufferBytesLeft) = InvalidBytesInBuffer_ (CurPVRWriteBuffer () -> dwIndex) ;

            //  success
            dwRet = NOERROR ;
        }
        else {
            //  we're out of room.. for some reason; caller did not call to
            //    append 0 bytes (we filter on that above); return an error
            dwRet = ERROR_GEN_FAILURE ;
        }

        //  release our lock
        Unlock () ;
    }
    else {
        //  failed to grab the lock
        dwRet = ERROR_GEN_FAILURE ;
    }

    ASSERT (!CallerOwnsLock ()) ;

    return dwRet ;
}

void
CPVRWriteBufferStreamWriter::AdvancePVRWriteBufferLocked (
    )
{
    ASSERT (CallerOwnsLock ()) ;

    //  should not be advancing if the next buffer is not ready
    ASSERT (NextPVRWriteBuffer () -> BufferState != BUFFER_STATE_IO_PENDING) ;

    //  global - advance
    m_pPVRWriteBufferStream -> dwCurrentWriteIndex++ ;

    //  specific buffer
    CurPVRWriteBuffer () -> BufferState = BUFFER_STATE_FILLING ;
    CurPVRWriteBuffer () -> dwData      = 0 ;
    CurPVRWriteBuffer () -> dwIndex     = m_pPVRWriteBufferStream -> dwCurrentWriteIndex ;
}

void
CPVRWriteBufferStreamWriter::UpdateMaxContiguousLocked (
    PVR_WRITE_BUFFER *  pPVRWriteBufferJustCompleted
    )
{
    ASSERT (CallerOwnsLock ()) ;

    //  all our bytes might be flushed out, so we either stop when we reach our current write index,
    //    or an uncompleted buffer
    while (m_pPVRWriteBufferStream -> dwMaxContiguousCompletedIndex < m_pPVRWriteBufferStream -> dwCurrentWriteIndex) {

        //  if the *next* buffer has completed, or we're the very first
        if (PVRWriteBuffer (m_pPVRWriteBufferStream -> dwMaxContiguousCompletedIndex + 1) -> BufferState == BUFFER_STATE_IO_COMPLETED) {

            //  advance the index
            m_pPVRWriteBufferStream -> dwMaxContiguousCompletedIndex++ ;

            //  ** DON'T ** update the data bytes because we might be flushing and have written
            //    out more bytes than we have (this is the likely case)

            //  advance the contiguous stream total
            m_pPVRWriteBufferStream -> ullMaxContiguousCompleted += PVRWriteBuffer (m_pPVRWriteBufferStream -> dwMaxContiguousCompletedIndex) -> dwData ;
        }
        //  this is the first completion
        else if (m_pPVRWriteBufferStream -> dwMaxContiguousCompletedIndex == 0) {
            m_pPVRWriteBufferStream -> ullMaxContiguousCompleted = pPVRWriteBufferJustCompleted -> dwData ;
            break ;
        }
        else {
            //  buffer has not yet completed; we advance only for contiguous completions
            break ;
        }
    }
}

BOOL
CPVRWriteBufferStreamWriter::MemoryOk (
    IN  BYTE *  pbMemory,       //  base pointer to memory (PVR_WRITE_BUFFER_STREAM *)
    IN  DWORD   dwLength,       //  of memory
    IN  DWORD   dwAlignment,
    IN  DWORD   dwIoSize,
    IN  DWORD   dwBufferCount,
    OUT DWORD * pdwExtraMemory,
    OUT BYTE ** ppbBuffers      //  points to first backing buffer (PVR_WRITE_BUFFER [0]'s)
    )
{
    BOOL    r ;
    DWORD   dwHeaderLength ;
    DWORD   dwTotalBufferLength ;

    ASSERT (!(dwIoSize % dwAlignment)) ;

    //  compute raw header length
    dwHeaderLength = (sizeof PVR_WRITE_BUFFER_STREAM - sizeof PVR_WRITE_BUFFER) +
                     dwBufferCount * sizeof PVR_WRITE_BUFFER ;

    //  if the total header length is not aligned, we need to align up
    dwHeaderLength = ::AlignUp (dwHeaderLength, dwAlignment) ;

    //  compute total buffering
    ASSERT (!(((((ULONGLONG) dwIoSize) * (ULONGLONG) (dwBufferCount))) & 0xffffffff00000000)) ;
    dwTotalBufferLength = dwIoSize * dwBufferCount ;

    //  so total file size will be dwHeaderLength + ullTotalBufferLength ;
    dwTotalBufferLength = dwHeaderLength + dwTotalBufferLength ;

    if (dwTotalBufferLength <= dwLength) {
        //  we're ok

        //  if this is requested, return it
        if (ppbBuffers) {
            (* ppbBuffers) = pbMemory + dwHeaderLength ;
        }

        //  if this is requested, return it
        if (pdwExtraMemory) {
            (* pdwExtraMemory) = 0 ;
        }

        //  success
        r = TRUE ;
    }
    else {
        //  not long enough
        if (pdwExtraMemory) {
            (* pdwExtraMemory) = dwTotalBufferLength - dwLength ;
        }

        r = FALSE ;
    }

    return r ;
}

//  ============================================================================
//  ============================================================================

LONG
PVR_READ_BUFFER::AddRef (
    )
{
    ::InterlockedIncrement (& cRef) ;
    ASSERT (pOwningReader) ;
    pOwningReader -> Touch_ (this) ;

    return cRef ;
}

LONG
PVR_READ_BUFFER::Release (
    )
{
    ::InterlockedDecrement (& cRef) ;
    ASSERT (pOwningReader) ;
    pOwningReader -> Touch_ (this) ;

    return cRef ;
}

//  ============================================================================
//  ============================================================================

CPVRAsyncReader::CPVRAsyncReader (
    IN  HANDLE              hFile,                      //  duplicated; must be bound to async io obj
    IN  LPWSTR              pszWriteBufferMapping,
    IN  DWORD               dwIoSize,
    IN  CAsyncIo *          pAsyncIo,
    IN  DWORD               dwTotalBuffering,
    IN  CPVRIOCounters *    pPVRIOCounters,
    OUT DWORD *             pdwRet
    ) : m_pvBuffer          (NULL),
        m_dwBufferLen       (dwTotalBuffering),
        m_pAsyncIo          (pAsyncIo),
        m_ullMaxIOReadAhead (0L),
        m_cIoPending        (0),
        m_dwIoLen           (dwIoSize),
        m_hFile             (INVALID_HANDLE_VALUE),
        m_ullFileLength     (UNDEFINED),
        m_hDrainIo          (NULL),
        m_fDraining         (FALSE),
        m_pPVRIOCounters    (pPVRIOCounters)
{
    BOOL                        r ;
    BY_HANDLE_FILE_INFORMATION  FileInfo ;

    ASSERT (hFile != INVALID_HANDLE_VALUE) ;
    ASSERT (m_pAsyncIo) ;
    ASSERT (m_pPVRIOCounters) ;

    //  ------------------------------------------------------------------------
    //  non-failables first

    ::InitializeCriticalSection (& m_crt) ;
    InitializeListHead (& m_leWaitForAnyBufferLIFO) ;
    InitializeListHead (& m_leWaitForPool) ;
    InitializeListHead (& m_leValid) ;
    InitializeListHead (& m_leInvalid) ;
    InitializeListHead (& m_leInUse) ;

    m_pAsyncIo -> AddRef () ;
    m_pPVRIOCounters -> AddRef () ;

    //  ------------------------------------------------------------------------
    //  create our drain event

    m_hDrainIo = ::CreateEvent (NULL, TRUE, FALSE, NULL) ;
    if (!m_hDrainIo) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    m_fDraining = FALSE ;

    //  ------------------------------------------------------------------------
    //  create our write buffer reader, if there's a writer to work with

    if (pszWriteBufferMapping) {
        (* pdwRet) = m_WriteBufferReader.Initialize (
                                            NULL,
                                            pszWriteBufferMapping
                                            ) ;

        if ((* pdwRet) != NOERROR) {
            m_WriteBufferReader.Uninitialize () ;
            goto cleanup ;
        }
    }

    //  ------------------------------------------------------------------------
    //  allocate our buffering

    ASSERT ((dwTotalBuffering % m_dwIoLen) == 0) ;
    m_pvBuffer = ::VirtualAlloc (
                        NULL,                   //  base address
                        dwTotalBuffering,       //  size
                        MEM_COMMIT,             //  we'll use it all
                        PAGE_READWRITE
                        ) ;
    if (!m_pvBuffer) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    m_dwBackingLenTotal = m_dwBackingLenAvail = dwTotalBuffering ;

    //  ------------------------------------------------------------------------
    //  duplicate the file handle (so we can do read aheads)

    r = ::DuplicateHandle (
            ::GetCurrentProcess (),
            hFile,
            ::GetCurrentProcess (),
            & m_hFile,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ) ;
    if (!r) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  bind the handle to the completion port

    (* pdwRet) = m_pAsyncIo -> Bind (m_hFile) ;
    if ((* pdwRet) != NOERROR) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  if the file is not live figure out how long; note that the structure
    //    will not transition live -> non-live during the constructor because
    //    of our locking scheme; the file can never transition non-live -> live

    if (m_WriteBufferReader.IsNotLive ()) {

        //  first time we've found that the file is not live; get the length
        //    of the file
        ASSERT (m_hFile) ;
        r = ::GetFileInformationByHandle (
                    m_hFile,
                    & FileInfo
                    ) ;
        if (r) {
            m_ullFileLength = FileInfo.nFileSizeHigh ;
            m_ullFileLength <<= 32 ;

            m_ullFileLength += FileInfo.nFileSizeLow ;
        }
        else {
            (* pdwRet) = ::GetLastError () ;
            goto cleanup ;
        }
    }

    //  ------------------------------------------------------------------------
    //  perform other random initializations

    //  max read aheads is half of our buffering
    m_dwMaxReadAheadLimit = dwTotalBuffering / 2 ;

    //  this can become increasingly aggressive, but never tops the max read ahead
    m_dwCurMaxReadAhead = Max <DWORD> (m_dwMaxReadAheadLimit / 2, m_dwIoLen) ;

    //  success
    (* pdwRet) = NOERROR ;

    cleanup :

    return ;
}

CPVRAsyncReader::~CPVRAsyncReader (
    )
{
    DWORD               dwRet ;
    PVR_READ_BUFFER *   pPVRReadBuffer ;
    CWait *             pWaitForBuffer ;

    DrainPendedIo () ;

    ASSERT (m_cIoPending == 0) ;
    ASSERT (IsListEmpty (& m_leWaitForAnyBufferLIFO)) ;
    ASSERT (IsListEmpty (& m_leInUse)) ;

    //  purge our waitforbuffer pool
    while (!IsListEmpty (& m_leWaitForPool)) {
        pWaitForBuffer = CWait::Recover (m_leWaitForPool.Flink) ;
        CWait::ListRemove (pWaitForBuffer) ;

        delete pWaitForBuffer ;
    }

    //  empty the cache
    while (!m_PVRReadCache.IsEmpty ()) {
        dwRet = m_PVRReadCache.RemoveFirst (
                    & pPVRReadBuffer
                    ) ;
        if (dwRet == NOERROR) {
            ASSERT (pPVRReadBuffer) ;
            ASSERT (pPVRReadBuffer -> IsRef ()) ;
            pPVRReadBuffer -> Release () ;
        }
        else {
            break ;
        }
    }

    while (pPVRReadBuffer = ValidPop_ ()) {
        ASSERT (!pPVRReadBuffer -> IsRef ()) ;
        m_PVRReadBufferPool.Recycle (pPVRReadBuffer) ;
    }

    while (pPVRReadBuffer = InvalidPop_ ()) {
        ASSERT (!pPVRReadBuffer -> IsRef ()) ;
        m_PVRReadBufferPool.Recycle (pPVRReadBuffer) ;
    }

    ASSERT (m_pAsyncIo) ;
    m_pAsyncIo -> Release () ;

    m_pPVRIOCounters -> Release () ;

    if (m_pvBuffer) {
        ::VirtualFree (
            m_pvBuffer,
            0,
            MEM_RELEASE
            ) ;
    }

    if (m_hFile != INVALID_HANDLE_VALUE) {
        ::CloseHandle (m_hFile) ;
    }

    m_WriteBufferReader.Uninitialize () ;

    ::DeleteCriticalSection (& m_crt) ;
}

DWORD
CPVRAsyncReader::DrainPendedIo (
    )
{
    DWORD   dwRet ;

    Lock_ () ;

    //  one at a time
    ASSERT (!m_fDraining) ;

    if (m_cIoPending != 0) {
        //  have to wait

        //  non-signal
        ::ResetEvent (m_hDrainIo) ;
        m_fDraining = TRUE ;

        //  wait
        Unlock_ () ;
        dwRet = ::WaitForSingleObject (m_hDrainIo, INFINITE) ;
        Lock_ () ;

        if (dwRet == WAIT_OBJECT_0) {
            dwRet = NOERROR ;
        }
        else {
            dwRet = ERROR_GEN_FAILURE ;
        }

        //  done with this
        m_fDraining = FALSE ;
    }
    else {
        //  nothing to wait for
        dwRet = NOERROR ;
    }

    Unlock_ () ;

    return dwRet ;
}

DWORD
CPVRAsyncReader::ReadBytes (
    IN      ULONGLONG   ullStreamRead,
    IN OUT  DWORD *     pdwLength,
    OUT     BYTE *      pbBuffer
    )
{
    DWORD               dwRet ;
    ULONGLONG           ullBuffer ;
    DWORD               dwBytesRemaining ;
    PVR_READ_BUFFER *   pPVRReadBuffer ;
    DWORD               dwCopy ;
    CWait *             pWaitForBuffer ;
    BOOL                fBufferRead ;
    ULONGLONG           ullAvailableForRead ;

    //  should not be called to read anything that starts > than the file; that
    //    side is managed by the caller
    ASSERT (ullStreamRead <= BytesCopied_ ()) ;

    TRACE_2 (LOG_AREA_PVRIO, 7,
        TEXT ("CPVRAsyncReader::ReadBytes called: stream = %I64d, length = %d"),
        ullStreamRead, (* pdwLength)) ;

    m_pPVRIOCounters -> AsyncReader_LastReadout (ullStreamRead) ;

    Lock_ () ;

    //  trim to the file length, if necessary; it's possible to get an
    //  "overread" i.e. caller knows that there are x bytes in the file,
    //  and they still call read with a starting offset within file, but
    //  plus the buffer length is off file; so we trim here

    ullAvailableForRead = BytesCopied_ () - ullStreamRead ;
    if (ullAvailableForRead < (* pdwLength)) {
        //  gotta trim
        (* pdwLength) = (DWORD) ullAvailableForRead ;
    }

    //  first try to read it in directly from the writer's buffering
    fBufferRead = m_WriteBufferReader.CopyAllBytes (
        ullStreamRead,
        (* pdwLength),
        pbBuffer
        ) ;

    if (fBufferRead) {
        //  --------------------------------------------------------------------
        //  read into outgoing buffer directly; no need to read from disk,
        //    etc...

        TRACE_1 (LOG_AREA_PVRIO, 7,
            TEXT ("CPVRAsyncReader::ReadBytes; write buffers hit for %I64d"),
            ullStreamRead) ;

        m_pPVRIOCounters -> AsyncReader_ReadoutWriteBufferHit () ;

        //  success
        dwRet = NOERROR ;
    }
    else {

        //  --------------------------------------------------------------------
        //  could not read the content out of the write's buffers, so read from
        //    from file

        //  init how many bytes we want
        dwBytesRemaining = (* pdwLength) ;

        //  initialize this in case we're at EOF and will read 0 bytes
        dwRet = NOERROR ;

        while (dwBytesRemaining > 0) {

            //  compute the buffer offset (aligned on the io length)
            ullBuffer = ::AlignDown <ULONGLONG> (ullStreamRead, m_dwIoLen) ;

            //  is it in the cache ?
            dwRet = m_PVRReadCache.Find (
                        ullBuffer,
                        & pPVRReadBuffer
                        ) ;

            if (dwRet != NOERROR) {

                TRACE_1 (LOG_AREA_PVRIO, 3,
                    TEXT ("CPVRAsyncReader::ReadBytes; cache miss for %I64d"),
                    ullBuffer) ;

                m_pPVRIOCounters -> AsyncReader_ReadoutCacheMiss () ;

                //
                //  not in the cache; we have to pend a read
                //

                //  get a buffer to read into
                pPVRReadBuffer = GetBufferBlocking_ () ;
                if (!pPVRReadBuffer) {
                    dwRet = ERROR_NOT_ENOUGH_MEMORY ;
                    break ;
                }

                ASSERT (pPVRReadBuffer -> IsInvalid ()) ;

                //  buffer should at least be ours
                ASSERT (pPVRReadBuffer -> IsRef ()) ;

                dwRet = PendReadIntoBuffer_ (pPVRReadBuffer, ullBuffer) ;
                if (dwRet != NOERROR) {
                    //  this should not have changed
                    ASSERT (pPVRReadBuffer -> IsInvalid ()) ;

                    //  get rid of our ref on the read buffer
                    pPVRReadBuffer -> Release () ;

                    //  bail
                    break ;
                }
            }
            else {
                m_pPVRIOCounters -> AsyncReader_ReadoutCacheHit () ;

                TRACE_1 (LOG_AREA_PVRIO, 7,
                    TEXT ("CPVRAsyncReader::ReadBytes; cache hit for %I64d"),
                    ullBuffer) ;

                //  cache should ref returned buffer
                ASSERT (pPVRReadBuffer -> IsRef ()) ;
            }

            ASSERT (pPVRReadBuffer) ;

            //  if the buffer is pending, we'll have to wait for it to complete
            if (pPVRReadBuffer -> IsPending ()) {

                TRACE_1 (LOG_AREA_PVRIO, 3,
                    TEXT ("CPVRAsyncReader::ReadBytes; wait for completion of %I64d"),
                    ullBuffer) ;

                //  get a waitforbuffer object; this will ref the buffer (wait's)
                pWaitForBuffer = GetWaitForReadCompletion_ (pPVRReadBuffer) ;
                if (!pWaitForBuffer) {
                    //  done with this
                    pPVRReadBuffer -> Release () ;

                    //  let the read complete as it was pended
                    dwRet = ERROR_GEN_FAILURE ;
                    break ;
                }

                //
                //  keep our ref to the buffer; we own the wait object, and at
                //    least have 1 ref on the read buffer; IO should have at
                //    least 1 as well
                //

                //  now wait for it to complete
                Unlock_ () ;
                pWaitForBuffer -> WaitForReadBuffer () ;
                Lock_ () ;

                //  we should get our original buffer back out, even if the IO
                //    failed
                ASSERT (pWaitForBuffer -> PVRReadBuffer ()) ;

                //  we're done with this; this will unref the buffer (wait's)
                RecycleWaitFor_ (pWaitForBuffer) ;

                m_pPVRIOCounters -> AsyncReader_WaitReadCompletion_BufferDequeued () ;

                if (pPVRReadBuffer -> IsInvalid ()) {
                    //  read completed and failed probably; buffer is invalid;
                    //    release our ref and bail
                    pPVRReadBuffer -> Release () ;
                    dwRet = ERROR_GEN_FAILURE ;
                }

                TRACE_2 (LOG_AREA_PVRIO, 4,
                    TEXT ("CPVRAsyncReader::ReadBytes; incrementing the read ahead from %d to %d bytes"),
                    m_dwCurMaxReadAhead, Min <DWORD> (m_dwCurMaxReadAhead + m_dwIoLen, m_dwMaxReadAheadLimit)) ;

                m_dwCurMaxReadAhead = Min <DWORD> (m_dwCurMaxReadAhead + m_dwIoLen, m_dwMaxReadAheadLimit) ;
            }

            ASSERT (ullStreamRead >= pPVRReadBuffer -> StreamOffset ()) ;
            ASSERT (pPVRReadBuffer -> IsValid ()) ;
            ASSERT (m_PVRReadCache.Exists (pPVRReadBuffer -> StreamOffset ())) ;
            ASSERT (pPVRReadBuffer -> IsRef ()) ;

            //  if this buffer is partially filled handle it appropriately
            if (pPVRReadBuffer -> ValidLength () < pPVRReadBuffer -> MaxLength ()) {

                //  make sure that there's in fact data that we can use this time
                //    around
                if (ullStreamRead >= pPVRReadBuffer -> StreamOffset () + pPVRReadBuffer -> ValidLength ()) {

                    //  buffer offset (stream + maxlength) "has" content that
                    //    we want but since it's partially filled, it really
                    //    does not hold what we want;

                    m_pPVRIOCounters -> AsyncReader_PartiallyFilledBuffer () ;

                    //  is the real content there to be read ?
                    if (BytesCopied_ () > ullStreamRead) {
                        //  pull it from the cache
                        ASSERT (m_PVRReadCache.Exists (pPVRReadBuffer -> StreamOffset ())) ;
                        m_PVRReadCache.Remove (pPVRReadBuffer -> StreamOffset ()) ;

                        //  invalidate the buffer & release our ref on it
                        pPVRReadBuffer -> SetInvalid () ;
                        pPVRReadBuffer -> Release () ;

                        m_pPVRIOCounters -> AsyncReader_PartialReadAgain () ;

                        //  loop again; should force a read
                        continue ;
                    }
                    else {
                        //  we're trying to read beyond the end of actual content;
                        //    bail from the loop here with what we could get
                        break ;
                    }
                }
            }

            ASSERT (pPVRReadBuffer -> IsRef ()) ;

            //  now figure out how much we'll copy from this buffer
            dwCopy = Min <DWORD> (
                        dwBytesRemaining,
                        pPVRReadBuffer -> ValidLength () - (DWORD) (ullStreamRead - pPVRReadBuffer -> StreamOffset ())
                        ) ;

            ASSERT (dwCopy != 0) ;

            //  copy into outgoing; better not be bigger than 2^32-1
            ASSERT (!((ullStreamRead - pPVRReadBuffer -> StreamOffset ()) & 0xffffffff00000000)) ;
            ::CopyMemory (
                pbBuffer,
                pPVRReadBuffer -> Buffer () + (DWORD) (ullStreamRead - pPVRReadBuffer -> StreamOffset ()),
                dwCopy
                ) ;

            //  done with the buffer
            pPVRReadBuffer -> Release () ;

            //  update method state
            dwBytesRemaining    -= dwCopy ;
            pbBuffer            += dwCopy ;

            TRACE_2 (LOG_AREA_PVRIO, 7,
                TEXT ("CPVRAsyncReader::ReadBytes; copied %d bytes from %I64d"),
                dwCopy, ullStreamRead) ;

            //  advance read offset; note this may be different from the buffer offset
            ullStreamRead += dwCopy ;

            //  make sure these are roughly in sync
            m_ullMaxIOReadAhead = Max <ULONGLONG> (m_ullMaxIOReadAhead, ullStreamRead) ;

            //  try to pend some more reads, no matter what
            PendMaxReads_ (ullStreamRead) ;
        }

        //  update outgoing valid length
        (* pdwLength) -= dwBytesRemaining ;
    }

    Unlock_ () ;

    return dwRet ;
}

void
CPVRAsyncReader::PendMaxReads_ (
    IN  ULONGLONG   ullStreamRead
    )
{
    DWORD   dw ;
    DWORD   i ;
    DWORD   cReads ;

    TRACE_4 (LOG_AREA_PVRIO, 7,
        TEXT ("CPVRAsyncReader::PendMaxReads_; m_ullMaxIOReadAhead = %I64d, m_dwIoLen = %d, ullStreamRead = %I64d, m_dwCurMaxReadAhead = %d"),
        m_ullMaxIOReadAhead, m_dwIoLen, ullStreamRead, m_dwCurMaxReadAhead) ;

    if (m_ullMaxIOReadAhead + m_dwIoLen <= ullStreamRead + m_dwCurMaxReadAhead &&
        ullStreamRead + m_dwIoLen <= BytesCopied_ ()) {

        //  cap this in case these counters get out of whack; this ought to
        //    be an assert however ...

        //  align this on a buffer boundary
        ullStreamRead = ::AlignDown <ULONGLONG> (ullStreamRead, m_dwIoLen) ;

        //  now figure out how many reads we'll make
        cReads = (DWORD) (Min <ULONGLONG> (m_dwCurMaxReadAhead, (ullStreamRead + m_dwCurMaxReadAhead) - m_ullMaxIOReadAhead)) / m_dwIoLen ;

        for (i = 0 ;
             i < cReads && ullStreamRead + m_dwIoLen <= BytesCopied_ () ;
             i++) {

            //  don't process anything that is already in the cache
            if (!m_PVRReadCache.Exists (ullStreamRead)) {

                TRACE_3 (LOG_AREA_PVRIO, 7,
                    TEXT ("CPVRAsyncReader::PendMaxReads_; trying to READ AHEAD [%d] : ullStreamRead = %I64d, m_ullMaxIOReadAhead = %I64d"),
                    i, ullStreamRead, m_ullMaxIOReadAhead) ;

                dw = TryPendRead_ (ullStreamRead) ;
                if (dw != NOERROR) {
                    //  might have failed to get a buffer;
                    //  might have read to max of file

                    TRACE_0 (LOG_AREA_PVRIO, 7,
                        TEXT ("CPVRAsyncReader::PendMaxReads_; breaking (TryPendRead_ () returned error)")) ;

                    break ;
                }

                m_pPVRIOCounters -> AsyncReader_LastDiskRead (ullStreamRead) ;
            }

            //
            //  really ought to assert somehow that the read aheads (per m_ullMaxIOReadAhead)
            //    is incrementing
            //

            //  advance so we can try another read
            ullStreamRead += m_dwIoLen ;
        }
    }
}

ULONGLONG
CPVRAsyncReader::CurLength (
    )
{
    ULONGLONG   ullCurLength ;

    Lock_ () ;

    ullCurLength = BytesCopied_ () ;

    Unlock_ () ;

    return ullCurLength ;
}

void
CPVRAsyncReader::Seek (
    IN OUT  ULONGLONG * pullStreamTo
    )
{
    ASSERT (pullStreamTo) ;

    Lock_ () ;

    //  cannot seek to more than the file content
    (* pullStreamTo) = ::Min <ULONGLONG> ((* pullStreamTo), BytesCopied_ ()) ;

    //  reset all the counters
    m_ullCurRead            = (* pullStreamTo) ;
    m_ullMaxIOReadAhead     = 0 ;           //  will cause readaheads to start right away
    m_dwCurMaxReadAhead     = ::AlignUp <DWORD> (Max <DWORD> (m_dwMaxReadAheadLimit / 2, m_dwIoLen), m_dwIoLen) ;  //  cur max readahead

    TRACE_1 (LOG_AREA_PVRIO, 2,
        TEXT ("CPVRAsyncReader::Seek to %I64d"),
        (* pullStreamTo)) ;

    //  get started; this is non-blocking
    PendMaxReads_ (m_ullCurRead) ;

    Unlock_ () ;
}

CWait *
CPVRAsyncReader::GetWaitObject_ (
    )
{
    CWait * pWaitForBuffer ;
    DWORD   dwRet ;

    if (!IsListEmpty (& m_leWaitForPool)) {
        //  remove from the head
        pWaitForBuffer = CWait::Recover (m_leWaitForPool.Flink) ;
        CWait::ListRemove (pWaitForBuffer) ;
    }
    else {
        pWaitForBuffer = new CWait (& dwRet) ;
        if (!pWaitForBuffer ||
            dwRet != NOERROR) {

            delete pWaitForBuffer ;
            pWaitForBuffer = NULL ;

            goto cleanup ;
        }
    }

    ASSERT (pWaitForBuffer) ;
    pWaitForBuffer -> Reset () ;

    cleanup :

    return pWaitForBuffer ;
}

CWait *
CPVRAsyncReader::GetWaitForReadCompletion_ (
    IN  PVR_READ_BUFFER *   pPVRReadBuffer
    )
{
    CWait * pWaitForReadCompletion ;

    ASSERT (pPVRReadBuffer) ;

    pWaitForReadCompletion = GetWaitObject_ () ;
    if (pWaitForReadCompletion) {
        ASSERT (!pPVRReadBuffer -> pWaitForCompletion) ;
        pPVRReadBuffer -> pWaitForCompletion = pWaitForReadCompletion ;
    }

    return pWaitForReadCompletion ;
}

CWait *
CPVRAsyncReader::GetWaitForAnyBuffer_ (
    )
{
    CWait * pWaitForAnyBuffer ;

    pWaitForAnyBuffer = GetWaitObject_ () ;
    if (pWaitForAnyBuffer) {
        //  put it on the list so completions will be able to Signal the req
        CWait::ListInsertTail (& m_leWaitForAnyBufferLIFO, pWaitForAnyBuffer) ;
    }

    return pWaitForAnyBuffer ;
}

void
CPVRAsyncReader::SignalWaitForAnyBuffer_ (
    IN  PVR_READ_BUFFER *   pPVRReadBuffer
    )
{
    CWait * pWaitForBuffer ;

    ASSERT (pPVRReadBuffer) ;
    ASSERT (!IsListEmpty (& m_leWaitForAnyBufferLIFO)) ;
    ASSERT (!pPVRReadBuffer -> IsRef ()) ;

    //  buffer could be valid; whoever is waiting for it should remove
    //    it from the cache if is valid, just like a non-blocking wait

    //  from the head (LIFO)
    pWaitForBuffer = CWait::Recover (m_leWaitForAnyBufferLIFO.Flink) ;
    CWait::ListRemove (pWaitForBuffer) ;

    if (pPVRReadBuffer) {
        m_pPVRIOCounters -> AsyncReader_WaitAnyBuffer_SignalSuccess () ;
    }
    else {
        m_pPVRIOCounters -> AsyncReader_WaitAnyBuffer_SignalFailure () ;
    }

    //  pPVRReadBuffer can be NULL if we're explicitely failing the request;
    //    buffer gets ref'd in the wait object
    pWaitForBuffer -> SetPVRReadBuffer (pPVRReadBuffer) ;

    //  let the entity that queued the reqest recycle the waitforbuffer; they'll
    //    also get the ref
}

void
CPVRAsyncReader::SignalWaitForReadCompletion_ (
    IN  PVR_READ_BUFFER *   pPVRReadBuffer
    )
{
    CWait * pWaitForBuffer ;

    //  recover the wait object
    pWaitForBuffer = (CWait *) pPVRReadBuffer -> pWaitForCompletion ;

    //  signal the waiter; if we io failed, they'll get NULL
    pWaitForBuffer -> SetPVRReadBuffer (pPVRReadBuffer) ;

    m_pPVRIOCounters -> AsyncReader_WaitReadCompletion_SignalSuccess () ;

    //  clear this out as well
    pPVRReadBuffer -> pWaitForCompletion = NULL ;
}

void
CPVRAsyncReader::RecycleWaitFor_ (
    IN  CWait * pWaitFor
    )
{
    //  this one goes into the pool of waitforbuffers
    pWaitFor -> Clear () ;
    CWait::ListInsertHead (& m_leWaitForPool, pWaitFor) ;
}

void
CPVRAsyncReader::BufferPop_ (
    IN  PVR_READ_BUFFER *   pPVRReadBuffer
    )
{
    RemoveEntryList (pPVRReadBuffer -> ListEntry ()) ;
    InitializeListHead (pPVRReadBuffer -> ListEntry ()) ;
}

PVR_READ_BUFFER *
CPVRAsyncReader::ListEntryPop_ (
    IN  LIST_ENTRY *    ple
    )
{
    RemoveEntryList (ple) ;
    InitializeListHead (ple) ;
    return PVR_READ_BUFFER::Recover (ple) ;
}

void
CPVRAsyncReader::TailPush_ (
    IN  LIST_ENTRY *    pleHead,
    IN  LIST_ENTRY *    plePush
    )
{
    ASSERT (IsListEmpty (plePush)) ;

    //  on at TAIL
    InsertTailList (pleHead, plePush) ;
}

void
CPVRAsyncReader::HeadPush_ (
    IN  LIST_ENTRY *    pleHead,
    IN  LIST_ENTRY *    plePush
    )
{
    ASSERT (IsListEmpty (plePush)) ;

    //  on at HEAD
    InsertHeadList (pleHead, plePush) ;
}

PVR_READ_BUFFER *
CPVRAsyncReader::HeadPop_ (
    IN  LIST_ENTRY *    pleHead
    )
{
    PVR_READ_BUFFER *   pPVRReadBuffer ;

    if (!IsListEmpty (pleHead)) {
        //  off at HEAD
        pPVRReadBuffer = ListEntryPop_ (pleHead -> Flink) ;
    }
    else {
        pPVRReadBuffer = NULL ;
    }

    return pPVRReadBuffer ;
}

//  must hold the lock
DWORD
CPVRAsyncReader::TryGetPVRReadBufferForRead_ (
    OUT PVR_READ_BUFFER **  ppPVRReadBuffer
    )
{
    DWORD   dwRet ;

    ASSERT (ppPVRReadBuffer) ;

    dwRet = NOERROR ;

    //  first check the invalid list
    (* ppPVRReadBuffer) = InvalidPop_ () ;
    if (!(* ppPVRReadBuffer)) {
        //  next check if we can allocate any more
        if (m_dwBackingLenAvail > 0) {

            ASSERT (m_dwBackingLenAvail >= m_dwIoLen) ;

            (* ppPVRReadBuffer) = m_PVRReadBufferPool.Get () ;

            if (* ppPVRReadBuffer) {
                //  set it up
                InitializeListHead ((* ppPVRReadBuffer) -> ListEntry ()) ;
                (* ppPVRReadBuffer) -> SetStreamOffset (0) ;
                (* ppPVRReadBuffer) -> SetMaxLength (m_dwIoLen) ;
                (* ppPVRReadBuffer) -> SetValidLength (0) ;
                (* ppPVRReadBuffer) -> SetInvalid () ;
                (* ppPVRReadBuffer) -> SetBuffer (((BYTE *) m_pvBuffer) + (m_dwBackingLenTotal - m_dwBackingLenAvail)) ;
                (* ppPVRReadBuffer) -> SetOwningReader (this) ;

                //  one more buffer allocated
                m_dwBackingLenAvail -= m_dwIoLen ;
            }
            else {
                //  error !
                dwRet = ERROR_OUTOFMEMORY ;
            }
        }
        else {
            //  try the Valid; we try to keep buffers in the Valid for as long
            //    as possible
            (* ppPVRReadBuffer) = ValidPop_ () ;
            if (!(* ppPVRReadBuffer)) {
                //  still not; this is a well-known error
                dwRet = ERROR_INSUFFICIENT_BUFFER ;
            }
        }
    }

    if (* ppPVRReadBuffer) {
        //  caller must either set the buffer as valid or invalid; we leave the
        //    buffer flagged as is so the caller knows to remove it from the
        //    cache if necessary
        ASSERT (!(* ppPVRReadBuffer) -> IsRef ()) ;
        (* ppPVRReadBuffer) -> AddRef () ;
    }

    return dwRet ;
}

void
CPVRAsyncReader::Touch_ (
    IN  PVR_READ_BUFFER *   pPVRReadBuffer
    )
{
    BufferPop_ (pPVRReadBuffer) ;

    if (pPVRReadBuffer -> IsRef ()) {
        InUsePush_ (pPVRReadBuffer) ;
    }
    else if (IsListEmpty (& m_leWaitForAnyBufferLIFO)) {
        //  nobody is waiting; push onto the right list
        if (pPVRReadBuffer -> IsValid ()) {
            ValidPush_ (pPVRReadBuffer) ;
        }
        else {
            InvalidPush_ (pPVRReadBuffer) ;
        }
    }
    else {
        //  someone is waiting; ref and send it back out
        SignalWaitForAnyBuffer_ (pPVRReadBuffer) ;
    }
}

PVR_READ_BUFFER *
CPVRAsyncReader::GetBufferBlocking_ (
    )
{
    DWORD               dwRet ;
    PVR_READ_BUFFER *   pPVRReadBuffer ;
    CWait *             pWaitForBuffer ;

    //
    //  must hold the lock !!
    //

    pPVRReadBuffer = NULL ;

    //  get a buffer to pend a read on
    dwRet = TryGetPVRReadBufferForRead_ (& pPVRReadBuffer) ;

    if (dwRet == NOERROR) {
        ASSERT (pPVRReadBuffer) ;
        ASSERT (!pPVRReadBuffer -> IsPending ()) ;
    }
    else if (dwRet == ERROR_INSUFFICIENT_BUFFER) {
        //  this is a well-known error; it means that all the buffers in
        //    our pool are outstanding right now, and we cannot retrieve
        //    one to read into; setup for the wait; note this wait cannot
        //    be aborted because we really expect at least 1 buffer to
        //    come back as a success or a failure; if none ever come back
        //    we've got other problems

        pWaitForBuffer = GetWaitForAnyBuffer_ () ;
        if (pWaitForBuffer) {

            m_pPVRIOCounters -> AsyncReader_WaitAnyBuffer_Queued () ;

            Unlock_ () ;
            pPVRReadBuffer = pWaitForBuffer -> WaitForReadBuffer () ;
            Lock_ () ;

            if (pPVRReadBuffer) {

                //  buffer should not be pending, and should have been explicitely
                //    marked as invalid; this means that it's not in the cache;
                //    we don't ASSERT for that because there are races for
                //    the buffer's stream offset between when we were signaled,
                //    and when we got this buffer i.e. it's possible for the
                //    cache to now hold a buffer with the same stream offset
                //    as the cache we are holding - not efficient of course, but
                //    we do take precedence over a waiter waiting for any buffer
                ASSERT (!pPVRReadBuffer -> IsPending ()) ;

                //  outgoing
                pPVRReadBuffer -> AddRef () ;

                //  the bufferpool should be tracking this one as outstanding

                m_pPVRIOCounters -> AsyncReader_WaitAnyBuffer_Dequeued () ;
            }

            //  wait to recycle this until we've ref'd our buffer
            RecycleWaitFor_ (pWaitForBuffer) ;
        }
    }

    if (pPVRReadBuffer) {
            //  might have to remove it from the cache
        if (pPVRReadBuffer -> IsValid ()) {
            ASSERT (m_PVRReadCache.Exists (pPVRReadBuffer -> StreamOffset ())) ;
            m_PVRReadCache.Remove (pPVRReadBuffer -> StreamOffset ()) ;
            pPVRReadBuffer -> SetInvalid () ;

            TRACE_1 (LOG_AREA_PVRIO, 7,
                TEXT ("CPVRAsyncReader::GetBufferBlocking_; removing %I64d from the cache"),
                pPVRReadBuffer -> StreamOffset ()) ;
        }
    }

    return pPVRReadBuffer ;
}

PVR_READ_BUFFER *
CPVRAsyncReader::TryGetBuffer_ (
    )
{
    DWORD               dwRet ;
    PVR_READ_BUFFER *   pPVRReadBuffer ;

    dwRet = TryGetPVRReadBufferForRead_ (& pPVRReadBuffer) ;
    if (dwRet == NOERROR) {
        //  buffer is either invalid or valid; if it's valid, it's in the cache
        //    which is what we check for now; if it's not valid, then it's not
        //    in the cache; regardless, we should never get a buffer that is
        //    pending

        ASSERT (pPVRReadBuffer) ;
        ASSERT (!pPVRReadBuffer -> IsPending ()) ;

        if (pPVRReadBuffer -> IsValid ()) {
            ASSERT (m_PVRReadCache.Exists (pPVRReadBuffer -> StreamOffset ())) ;
            m_PVRReadCache.Remove (pPVRReadBuffer -> StreamOffset ()) ;

            //  update the buffer state
            pPVRReadBuffer -> SetInvalid () ;

            TRACE_1 (LOG_AREA_PVRIO, 7,
                TEXT ("CPVRAsyncReader::TryGetBuffer_; removing %I64d from the cache"),
                pPVRReadBuffer -> StreamOffset ()) ;
        }

        ASSERT (pPVRReadBuffer -> IsRef ()) ;
    }
    else {
        pPVRReadBuffer = NULL ;
    }

    return pPVRReadBuffer ;
}

DWORD
CPVRAsyncReader::TryPendRead_ (
    IN  ULONGLONG   ullStream
    )
{
    DWORD               dwRet ;
    PVR_READ_BUFFER *   pPVRReadBuffer ;

    Lock_ () ;

    ASSERT (ullStream < BytesCopied_ ()) ;          //  < because we should have at least 1 byte to read
    ASSERT (!m_PVRReadCache.Exists (ullStream)) ;

    m_pPVRIOCounters -> AsyncReader_ReadAhead () ;

    //  non-blocking call; if there are no buffers available i.e. all
    //    are outstanding, this call will fail
    pPVRReadBuffer = TryGetBuffer_ () ;
    if (pPVRReadBuffer) {
        //  we've now got a buffer, which may or may not be in the cache

        ASSERT (pPVRReadBuffer) ;
        ASSERT (pPVRReadBuffer -> MaxLength () == m_dwIoLen) ;
        ASSERT (pPVRReadBuffer -> IsInvalid ()) ;
        ASSERT (pPVRReadBuffer -> IsRef ()) ;                           //  ours

        TRACE_1 (LOG_AREA_PVRIO, 7,
            TEXT ("CPVRAsyncReader::TryPendRead_; got a buffer; pending read for %I64d"),
            ullStream) ;

        dwRet = PendReadIntoBuffer_ (pPVRReadBuffer, ullStream) ;

        if (dwRet != NOERROR) {
            //  failed; buffer should still be invalid
            ASSERT (pPVRReadBuffer -> IsInvalid ()) ;
        }

        //  we're done with it regardless of success/failure
        pPVRReadBuffer -> Release () ;
    }
    else {

        TRACE_1 (LOG_AREA_PVRIO, 7,
            TEXT ("CPVRAsyncReader::TryPendRead_; failed to get a buffer (%I64d)"),
            ullStream) ;

        dwRet = ERROR_INSUFFICIENT_BUFFER ;
    }

    Unlock_ () ;

    return dwRet ;
}

ULONGLONG
CPVRAsyncReader::BytesCopied_ (
    )
{
    BOOL                        r ;
    BY_HANDLE_FILE_INFORMATION  FileInfo ;
    ULONGLONG                   ullBytesCopied ;

    if (m_WriteBufferReader.IsNotLive ()) {
        //  might need to compute the length of the file
        if (m_ullFileLength == UNDEFINED) {
            m_WriteBufferReader.Uninitialize () ;

            //  first time we've found that the file is not live; get the length
            //    of the file
            ASSERT (m_hFile) ;
            r = ::GetFileInformationByHandle (
                        m_hFile,
                        & FileInfo
                        ) ;
            if (r) {
                m_ullFileLength = FileInfo.nFileSizeHigh ;
                m_ullFileLength <<= 32 ;

                m_ullFileLength += FileInfo.nFileSizeLow ;

                ullBytesCopied = m_ullFileLength ;
            }
            else {
                ullBytesCopied = 0 ;
            }
        }
        else {
            ullBytesCopied = m_ullFileLength ;
        }
    }
    else {
        ullBytesCopied = m_WriteBufferReader.CurBytesCopied () ;
    }

    return ullBytesCopied ;
}

DWORD
CPVRAsyncReader::PendReadIntoBuffer_ (
    IN  PVR_READ_BUFFER *   pPVRReadBuffer,
    IN  ULONGLONG           ullStream
    )
{
    DWORD   dwRet ;
    BOOL    fBufferRead ;

    ASSERT (ullStream < BytesCopied_ ()) ;  //  < because we should have at least 1 byte to read

    //  should not be pending or be valid
    ASSERT (pPVRReadBuffer -> IsInvalid ()) ;
    ASSERT (pPVRReadBuffer -> IsRef ()) ;

    //  set the buffer up for the read
    pPVRReadBuffer -> SetStreamOffset (ullStream) ;

    //  set the request length to either the entire buffer, or to what's currently
    //    available
    if (pPVRReadBuffer -> StreamOffset () + pPVRReadBuffer -> MaxLength () <= BytesCopied_ ()) {
        //  max buffer length
        pPVRReadBuffer -> SetRequestLength (pPVRReadBuffer -> MaxLength ()) ;
    }
    else {
        //  what's available, but still gotta align up - we'll get less
        pPVRReadBuffer -> SetRequestLength (::AlignUp <DWORD> ((DWORD) (BytesCopied_ () - pPVRReadBuffer -> StreamOffset ()), m_dwIoLen)) ;
    }

    //  store it into the cache; the cache does NOT get a ref; it's used purely
    //    as a directory to valid & pending buffers
    dwRet = m_PVRReadCache.Store (
                pPVRReadBuffer,
                pPVRReadBuffer -> StreamOffset ()
                ) ;
    if (dwRet != NOERROR) {
        //  could be out of memory; caller must cleanup
        goto cleanup ;
    }

    ASSERT (m_PVRReadCache.Exists (pPVRReadBuffer -> StreamOffset ())) ;

    //  set the buffer state
    pPVRReadBuffer -> SetPending () ;

    //  IO's
    pPVRReadBuffer -> AddRef () ;

    ::InterlockedIncrement (& m_cIoPending) ;

    //
    //  buffer is now configured and in the cache waiting to be read into
    //

    //  try the write buffers first
    fBufferRead = m_WriteBufferReader.CopyAllBytes (
            pPVRReadBuffer -> StreamOffset (),
            pPVRReadBuffer -> RequestLength (),
            pPVRReadBuffer -> Buffer ()
            ) ;

    if (fBufferRead) {
        //  --------------------------------------------------------------------
        //  content was still in the write buffers; no need to hit the disk

        TRACE_1 (LOG_AREA_PVRIO, 7,
            TEXT ("CPVRAsyncReader::PendReadIntoBuffer_; read all from write buffers for %I64d"),
            pPVRReadBuffer -> StreamOffset ()) ;

        m_pPVRIOCounters -> AsyncReader_ReadAheadWriteBufferHit () ;

        //  update
        m_ullMaxIOReadAhead = Max <ULONGLONG> (m_ullMaxIOReadAhead, pPVRReadBuffer -> StreamOffset ()) ;

        //  everything completes the same way; we've got the critical section
        //    already
        IOCompleted (
            pPVRReadBuffer -> RequestLength (),
            (DWORD_PTR) pPVRReadBuffer,
            NOERROR
            ) ;

        dwRet = NOERROR ;
    }
    else {
        //  --------------------------------------------------------------------
        //  gotta go to the disk, but not over what's currently available

        //  pend a read on the buffer
        dwRet = m_pAsyncIo -> PendRead (
                    m_hFile,
                    pPVRReadBuffer -> StreamOffset (),
                    pPVRReadBuffer -> Buffer (),
                    pPVRReadBuffer -> RequestLength (),
                    (DWORD_PTR) pPVRReadBuffer,
                    this
                    ) ;
        if (dwRet != NOERROR) {
            if (dwRet == ERROR_IO_PENDING) {

                //  update
                m_ullMaxIOReadAhead = Max <ULONGLONG> (m_ullMaxIOReadAhead, pPVRReadBuffer -> StreamOffset ()) ;

                TRACE_1 (LOG_AREA_PVRIO, 7,
                    TEXT ("CPVRAsyncReader::PendReadIntoBuffer_; read pended for %I64d"),
                    pPVRReadBuffer -> StreamOffset ()) ;

                //  don't send pending error back out; we're ok
                dwRet = NOERROR ;
                m_pPVRIOCounters -> AsyncReader_IOPended () ;
            }
            else {
                ::InterlockedDecrement (& m_cIoPending) ;

                //  IO's
                pPVRReadBuffer -> Release () ;

                //  true error ;
                //  recycle the buffer; caller must cleanup

                //  remove from the cache (we put it in above)
                ASSERT (m_PVRReadCache.Exists (pPVRReadBuffer -> StreamOffset ())) ;
                m_PVRReadCache.Remove (pPVRReadBuffer -> StreamOffset ()) ;

                //  set the state to invalid
                pPVRReadBuffer -> SetInvalid () ;

                m_pPVRIOCounters -> AsyncReader_IOPendedError () ;
            }
        }
        else {
            m_pPVRIOCounters -> AsyncReader_IOPended () ;
        }
    }

    cleanup :

    return dwRet ;
}

void
CPVRAsyncReader::IOCompleted (
    IN  DWORD       dwIoBytes,
    IN  DWORD_PTR   dwpContext,
    IN  DWORD       dwIOReturn
    )
{
    PVR_READ_BUFFER *   pPVRReadBuffer ;

    pPVRReadBuffer = (PVR_READ_BUFFER *) dwpContext ;

    Lock_ () ;

    //  if it's been pended, it must be in the cache
    ASSERT (m_PVRReadCache.Exists (pPVRReadBuffer -> StreamOffset ())) ;
    ASSERT (pPVRReadBuffer -> IsPending ()) ;
    ASSERT (pPVRReadBuffer -> IsRef ()) ;           //  IO's

    ASSERT (m_cIoPending > 0) ;
    ::InterlockedDecrement (& m_cIoPending) ;

    //  we're still working with the buffer; don't release our ref on it yet

    //  update buffer state
    pPVRReadBuffer -> SetIoRet (dwIOReturn) ;           //  updates valid flag as well

    //  buffer will be touched when we release our ref to it; if it's invalid
    //    it'll go in the right list

    if (pPVRReadBuffer -> IsValid ()) {

        //  ----------------------------------------------------------------
        //  IO succeeded

        pPVRReadBuffer -> SetValidLength (dwIoBytes) ;      //  good length

        //  buffer is now referenced in our cache, where we can find it
        //    fast, given a stream offset; and it's been touched in our
        //    pool, so it will stay in the cache for a while
    }
    else {
        //  ----------------------------------------------------------------
        //  IO failed

        m_PVRReadCache.Remove (pPVRReadBuffer -> StreamOffset ()) ; //  out of the cache
    }

    TRACE_3 (LOG_AREA_PVRIO, 6,
        TEXT ("CPVRAsyncReader::IOCompleted for %I64d, %u bytes; %s"),
        pPVRReadBuffer -> StreamOffset (), dwIoBytes, pPVRReadBuffer -> IsValid () ? TEXT ("OK") : TEXT ("ERROR")) ;

    m_pPVRIOCounters -> AsyncReader_IOCompletion (dwIOReturn) ;

    //
    //  buffer is now either good or bad; if it's good, it's also in the
    //    cache; if it's bad, it's been removed
    //

    /*
    //  don't let these get way out of whack; last IO really should be >=
    //    to this completion
    m_ullMaxIOReadAhead = Max <ULONGLONG> (m_ullMaxIOReadAhead, pPVRReadBuffer -> StreamOffset ()) ;

    //  now pend max reads
    PendMaxReads_ (pPVRReadBuffer -> StreamOffset ()) ;
    */

    //  if someone is waiting for this specific buffer, signal them
    if (pPVRReadBuffer -> pWaitForCompletion) {
        //  if the buffer is invalid this will fail the wait
        SignalWaitForReadCompletion_ (pPVRReadBuffer) ;
    }

    //  we're now done with the buffer; release the IO's ref
    pPVRReadBuffer -> Release () ;

    //  if we're draining and all IOs are now done, signal
    if (m_fDraining &&
        m_cIoPending == 0) {

        ::SetEvent (m_hDrainIo) ;
    }

    Unlock_ () ;
}

//  ============================================================================
//  ============================================================================

CPVRAsyncReaderCOM::CPVRAsyncReaderCOM (
    IN  DWORD               dwIOSize,
    IN  DWORD               dwBufferCount,
    IN  CAsyncIo *          pAsyncIo,
    IN  CPVRIOCounters *    pPVRIOCounters
    ) : m_dwIOSize              (dwIOSize),
        m_dwBufferCount         (dwBufferCount),
        m_pAsyncIo              (pAsyncIo),
        m_ullCurReadPosition    (0),
        m_cRef                  (0),
        m_pPVRAsyncReader       (NULL),
        m_pPVRIOCounters        (pPVRIOCounters)

{
    ASSERT (m_pAsyncIo) ;
    ASSERT (m_pPVRIOCounters) ;

    ::InitializeCriticalSection (& m_crt) ;

    m_pAsyncIo -> AddRef () ;
    m_pPVRIOCounters -> AddRef () ;
}

CPVRAsyncReaderCOM::~CPVRAsyncReaderCOM (
    )
{
    CloseFile () ;

    if (m_pPVRAsyncReader) {
        delete m_pPVRAsyncReader ;
    }

    m_pAsyncIo -> Release () ;

    m_pPVRIOCounters -> Release () ;

    ::DeleteCriticalSection (& m_crt) ;
}

//  --------------------------------------------------------------------
//  IUnknown methods

STDMETHODIMP_(ULONG)
CPVRAsyncReaderCOM::AddRef (
    )
{
    return ::InterlockedIncrement (& m_cRef) ;
}

STDMETHODIMP_(ULONG)
CPVRAsyncReaderCOM::Release (
    )
{
    if (::InterlockedDecrement (& m_cRef) == 0) {
        delete this ;
        return 0 ;
    }

    return 1 ;
}

STDMETHODIMP
CPVRAsyncReaderCOM::QueryInterface (
    IN REFIID   riid,
    OUT void ** ppv
    )
{
    if (!ppv) {
        return E_POINTER ;
    }

    if (riid == IID_IUnknown) {

        (* ppv) = static_cast <IUnknown *> (this) ;
    }
    else if (riid == IID_IDVRAsyncReader) {
        (* ppv) = static_cast <IDVRAsyncReader *> (this) ;
    }
    else {
        return E_NOINTERFACE ;
    }

    ASSERT (* ppv) ;

    //  outgoing
    ((IUnknown *) (* ppv)) -> AddRef () ;

    return S_OK ;
}

//  --------------------------------------------------------------------
//  IDVRAsyncReader

STDMETHODIMP
CPVRAsyncReaderCOM::OpenFile (
    IN  GUID *  pguidWriterId,              //  if NULL, file is not live
    IN  LPCWSTR pszFilename,                //  target file
    IN  DWORD   dwFileSharingFlags,         //  file sharing flags
    IN  DWORD   dwFileCreation              //  file creation
    )
{
    HRESULT hr ;
    HANDLE  hFile ;
    DWORD   dwRet ;
    WCHAR   szSharedMemName [HW_PROFILE_GUIDLEN] ;
    WCHAR   szGlobalSharedMemName [HW_PROFILE_GUIDLEN+10] ;
    WCHAR * pszSharedMemName ;
    int     k ;

    if (!pszFilename) {
        return E_POINTER ;
    }

    Lock_ () ;

    if (!m_pPVRAsyncReader) {

        hFile = CPVRAsyncReader::OpenFile (
                    pszFilename,
                    dwFileSharingFlags,
                    dwFileCreation
                    ) ;

        if (hFile != INVALID_HANDLE_VALUE) {

            //  set things up if there's a writer with shared memory to use
            if (pguidWriterId) {
                //  create our shared memory name (writer id is unique)
                k = ::StringFromGUID2 (
                        (* pguidWriterId),
                        szSharedMemName,
                        sizeof szSharedMemName / sizeof WCHAR
                        ) ;
                if (k == 0) {
                    //  a GUID is a GUID; this should not happen
                    hr = E_FAIL ;
                    goto cleanup ;
                }

                //  explicitely null-terminate this
                szSharedMemName [HW_PROFILE_GUIDLEN - 1] = L'\0' ;
                
                wcscpy(szGlobalSharedMemName, L"Global\\");
                wcscat(szGlobalSharedMemName, szSharedMemName);

                //  set this to non-NULL (writer's shared mem)
                pszSharedMemName = & szGlobalSharedMemName [0] ;

            }
            else {
                //  no writer shared mem to use
                pszSharedMemName = NULL ;
            }

            //  instantiate our async reader
            m_pPVRAsyncReader = new CPVRAsyncReader (
                                        hFile,
                                        pszSharedMemName,
                                        m_dwIOSize,
                                        m_pAsyncIo,
                                        m_dwIOSize * m_dwBufferCount,
                                        m_pPVRIOCounters,
                                        & dwRet
                                        ) ;

            //  we're done with this handle regardless
            ::CloseHandle (hFile) ;

            //  check for failures
            if (!m_pPVRAsyncReader) {
                hr = E_OUTOFMEMORY ;
                goto cleanup ;
            }
            else if (dwRet != NOERROR) {
                hr = HRESULT_FROM_WIN32 (dwRet) ;
                delete m_pPVRAsyncReader ;
                m_pPVRAsyncReader = NULL ;
                goto cleanup ;
            }

            //  try to seek; this will immediately pend some reads if there's
            //    content in the file
            m_ullCurReadPosition = 0 ;

            m_pPVRAsyncReader -> Seek (& m_ullCurReadPosition) ;

            //  success
            hr = S_OK ;
        }
        else {
            dwRet = ::GetLastError () ;
            hr = HRESULT_FROM_WIN32 (dwRet) ;
        }
    }
    else {
        //  already initialized
        hr = E_UNEXPECTED ;
    }

    cleanup :

    Unlock_ () ;

    return hr ;
}

STDMETHODIMP
CPVRAsyncReaderCOM::CloseFile (
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (m_pPVRAsyncReader) {
        m_pPVRAsyncReader -> DrainPendedIo () ;
        delete m_pPVRAsyncReader ;
        m_pPVRAsyncReader = NULL ;
    }

    Unlock_ () ;

    return S_OK ;
}

STDMETHODIMP
CPVRAsyncReaderCOM::ReadBytes (
    IN OUT  DWORD * pdwLength,
    OUT     BYTE *  pbBuffer
    )
{
    HRESULT hr ;
    DWORD   dwRet ;

    if (!pdwLength ||
        !pbBuffer) {

        return E_POINTER ;
    }

    Lock_ () ;

    if (m_pPVRAsyncReader) {
        dwRet = m_pPVRAsyncReader -> ReadBytes (m_ullCurReadPosition, pdwLength, pbBuffer) ;

        TRACE_5 (LOG_AREA_PVRIO, 4,
            TEXT ("CPVRAsyncReaderCOM::ReadBytes () ; offset = %I64u; length = %u; [0] = %02xh; [last] = %02xh; returned %u"),
            m_ullCurReadPosition, (* pdwLength),
            dwRet == 0 && (* pdwLength) > 0 ? pbBuffer [0] : 0,
            dwRet == 0 && (* pdwLength) > 0 ? pbBuffer [(* pdwLength) - 1] : 0,
            dwRet) ;

        if (dwRet == NOERROR) {
            m_ullCurReadPosition += (* pdwLength) ;
        }
        else {
            TRACE_ERROR_3 (
                TEXT ("CPVRAsyncReaderCOM::ReadBytes; error reading %d from %I64d (dwRet = %d)"),
                (* pdwLength), m_ullCurReadPosition, dwRet) ;
        }

        hr = HRESULT_FROM_WIN32 (dwRet) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    if (FAILED (hr)) {
        TRACE_ERROR_1 (TEXT ("Async Reader Failed to read: %08xh"), hr) ;
    }

    return hr ;
}

//  1. it is legal to specify a position > than current max of the file;
//      when this happens, the position is snapped to the EOF, and the
//      EOF at time-of-call, is returned in the pliSeekedTo member;
//  2. if (* pliSeekTo) == 0, (* pliSeekedTo) will return the time-of-call
//      EOF
//  3. (* pliSeekTo) need not be sector-aligned
STDMETHODIMP
CPVRAsyncReaderCOM::Seek (
    IN  LARGE_INTEGER * pliSeekTo,
    IN  DWORD           dwMoveMethod,   //  FILE_BEGIN, FILE_CURRENT, FILE_END
    OUT LARGE_INTEGER * pliSeekedTo     //  can be NULL
    )
{
    HRESULT     hr ;
    DWORD       dwRet ;
    ULONGLONG   ullSeekTo ;

    if (!pliSeekTo) {
        return E_POINTER ;
    }

    TRACE_3 (LOG_AREA_PVRIO, 1,
        TEXT ("CPVRAsyncReaderCOM::Seek (%I64u, %u, %016x); "),
        pliSeekTo -> QuadPart, dwMoveMethod, pliSeekedTo ? pliSeekedTo -> QuadPart : 0L) ;

    Lock_ () ;

    if (m_pPVRAsyncReader) {

        //  figure out what the absolute seekpoint offset is, based on
        //    the move method param
        switch (dwMoveMethod) {
            case FILE_BEGIN :
                //  absolute address
                ullSeekTo = (ULONGLONG) pliSeekTo -> QuadPart ;
                break ;

            case FILE_CURRENT :
                //  add/subtract by the requested amount
                ullSeekTo = (ULONGLONG) ((LONGLONG) m_ullCurReadPosition + pliSeekTo -> QuadPart) ;
                break ;

            case FILE_END :
                //  relative to the end
                ullSeekTo = (ULONGLONG) ((LONGLONG) m_pPVRAsyncReader -> CurLength () + pliSeekTo -> QuadPart) ;
                break ;

            default :
                //  bail
                hr = E_INVALIDARG ;
                goto cleanup ;
        } ;

        m_pPVRAsyncReader -> Seek (& ullSeekTo) ;

        //  set outgoing, if it was requested
        if (pliSeekedTo) {

            switch (dwMoveMethod) {
                case FILE_BEGIN :
                    //  absolute address
                    pliSeekedTo -> QuadPart = (LONGLONG) ullSeekTo ;
                    break ;

                case FILE_CURRENT :
                    //  new position relative to old; > 0 if forward; < 0 if backward
                    pliSeekedTo -> QuadPart = (LONGLONG) ullSeekTo - (LONGLONG) m_ullCurReadPosition ;
                    break ;

                case FILE_END :
                    //  relative to the end
                    pliSeekedTo -> QuadPart = (LONGLONG) m_pPVRAsyncReader -> CurLength () - (LONGLONG) ullSeekTo ;
                    break ;

                default :
                    //  should have caught this above
                    ASSERT (0) ;
                    break ;
            } ;
        }

        //  update member property
        m_ullCurReadPosition = ullSeekTo ;

        //  success
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    cleanup :

    Unlock_ () ;

    if (FAILED (hr)) {
        TRACE_ERROR_1 (TEXT ("Async Reader Failed to Seek: %08xh"), hr) ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

CPVRAsyncWriter::CPVRAsyncWriter (
    IN  HANDLE              hFileIo,                        //  duplicated
    IN  HANDLE              hFileLen,                       //  duplicated; buffered so no alignment restrictions; this handle will be used to set length
    IN  DWORD               dwIOSize,
    IN  DWORD               dwBufferCount,
    IN  DWORD               dwAlignment,
    IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
    IN  CAsyncIo *          pAsyncIo,
    IN  CPVRIOCounters *    pPVRIOCounters,
    IN  DWORD               dwNumSids,
    IN  PSID*               ppSids,
    OUT DWORD *             pdwRet
    ) : m_pAsyncIo              (pAsyncIo),
        m_hFileIo               (INVALID_HANDLE_VALUE),
        m_hFileLen              (INVALID_HANDLE_VALUE),
        m_cIoPending            (0),
        m_dwAlignment           (dwAlignment),
        m_hWaiting              (NULL),
        m_dwFileGrowthQuantum   (dwFileGrowthQuantum),
        m_ullCurFileLength      (0),
        m_pPVRIOCounters        (pPVRIOCounters),
        m_dwNumSids             (dwNumSids),
        m_ppSids                (ppSids) // We do not make a copy or free these SIDs

{
    DWORD   dwHeaderLength ;
    DWORD   dwTotalBufferLength ;
    DWORD   dwMappingLength ;
    DWORD   i ;
    BOOL    r ;
    DWORD   dwExtraMemoryNeeded ;
    HRESULT hr ;

    ASSERT ((dwIOSize % dwAlignment) == 0) ;
    ASSERT ((m_dwFileGrowthQuantum % dwIOSize) == 0) ;
    ASSERT (m_pPVRIOCounters) ;
    if (dwNumSids)
    {
        ASSERT(ppSids);

    }
    else
    {
        ASSERT(!ppSids);
    }

    //  ------------------------------------------------------------------------
    //  unfailable initializations first

    InitializeCriticalSection (& m_crt) ;

    ASSERT (m_pAsyncIo) ;
    m_pAsyncIo -> AddRef () ;

    m_pPVRIOCounters -> AddRef () ;

    m_PVRWriteWait.fWaiting = FALSE ;

    //  ------------------------------------------------------------------------
    //  duplicate the file length handle

    r = ::DuplicateHandle (
            ::GetCurrentProcess (),
            hFileLen,
            ::GetCurrentProcess (),
            & m_hFileLen,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ) ;
    if (!r) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  duplicate the IO file handle

    r = ::DuplicateHandle (
            ::GetCurrentProcess (),
            hFileIo,
            ::GetCurrentProcess (),
            & m_hFileIo,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ) ;
    if (!r) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  bind the IO handle to the completion port

    (* pdwRet) = m_pAsyncIo -> Bind (m_hFileIo) ;
    if ((* pdwRet) != NOERROR) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  create our draining event

    m_hWaiting = ::CreateEvent (NULL, TRUE, FALSE, NULL) ;
    if (!m_hWaiting) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    cleanup :

    return ;
}

CPVRAsyncWriter::CPVRAsyncWriter (
    IN  BYTE *              pbMemory,
    IN  DWORD               dwMemoryLength,
    IN  HANDLE              hFileIo,                        //  duplicated
    IN  HANDLE              hFileLen,                       //  duplicated; buffered so no alignment restrictions; this handle will be used to set length
    IN  DWORD               dwIOSize,
    IN  DWORD               dwBufferCount,
    IN  DWORD               dwAlignment,
    IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
    IN  CAsyncIo *          pAsyncIo,
    IN  CPVRIOCounters *    pPVRIOCounters,
    OUT DWORD *             pdwRet
    ) : m_pAsyncIo              (pAsyncIo),
        m_hFileIo               (INVALID_HANDLE_VALUE),
        m_hFileLen              (INVALID_HANDLE_VALUE),
        m_cIoPending            (0),
        m_dwAlignment           (dwAlignment),
        m_hWaiting              (NULL),
        m_dwFileGrowthQuantum   (dwFileGrowthQuantum),
        m_ullCurFileLength      (0),
        m_pPVRIOCounters        (pPVRIOCounters),
        m_dwNumSids             (0),
        m_ppSids                (NULL)
{
    DWORD   dwHeaderLength ;
    DWORD   dwTotalBufferLength ;
    DWORD   dwMappingLength ;
    DWORD   i ;
    BOOL    r ;
    DWORD   dwExtraMemoryNeeded ;
    HRESULT hr ;

    ASSERT ((dwIOSize % dwAlignment) == 0) ;
    ASSERT ((m_dwFileGrowthQuantum % dwIOSize) == 0) ;
    ASSERT (m_pPVRIOCounters) ;

    //  ------------------------------------------------------------------------
    //  unfailable initializations first

    InitializeCriticalSection (& m_crt) ;

    ASSERT (m_pAsyncIo) ;
    m_pAsyncIo -> AddRef () ;

    m_pPVRIOCounters -> AddRef () ;

    m_PVRWriteWait.fWaiting = FALSE ;

    //  ------------------------------------------------------------------------
    //  make sure that the memory provided meets the requirements

    r = MemoryOk (
            pbMemory,
            dwMemoryLength,
            dwAlignment,
            dwIOSize,
            dwBufferCount,
            NULL
            ) ;
    if (!r) {
        (* pdwRet) = ERROR_INVALID_PARAMETER ;
    }

    //  ------------------------------------------------------------------------
    //  duplicate the file length handle

    r = ::DuplicateHandle (
            ::GetCurrentProcess (),
            hFileLen,
            ::GetCurrentProcess (),
            & m_hFileLen,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ) ;
    if (!r) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  duplicate the IO file handle

    r = ::DuplicateHandle (
            ::GetCurrentProcess (),
            hFileIo,
            ::GetCurrentProcess (),
            & m_hFileIo,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ) ;
    if (!r) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  bind the IO handle to the completion port

    (* pdwRet) = m_pAsyncIo -> Bind (m_hFileIo) ;
    if ((* pdwRet) != NOERROR) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  create our draining event

    m_hWaiting = ::CreateEvent (NULL, TRUE, FALSE, NULL) ;
    if (!m_hWaiting) {
        (* pdwRet) = ::GetLastError () ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  initialize the memory

    (* pdwRet) = InitializeWriter_ (
                    pbMemory,
                    dwMemoryLength,
                    dwIOSize,
                    dwBufferCount,
                    dwAlignment
                    ) ;

    cleanup :

    return ;
}

CPVRAsyncWriter::~CPVRAsyncWriter (
    )
{
    ASSERT (!m_PVRWriteWait.fWaiting) ;
    ASSERT (m_cIoPending == 0) ;

    UninitializeWriter_ () ;

    m_pAsyncIo -> Release () ;

    m_pPVRIOCounters -> Release () ;

    if (m_hFileIo != INVALID_HANDLE_VALUE) {
        ::CloseHandle (m_hFileIo) ;
    }

    if (m_hFileLen != INVALID_HANDLE_VALUE) {
        ::CloseHandle (m_hFileLen) ;
    }

    if (m_hWaiting) {
        ::CloseHandle (m_hWaiting) ;
    }

    DeleteCriticalSection (& m_crt) ;
}

DWORD
CPVRAsyncWriter::InitializeWriter_ (
    IN  BYTE *  pbMemory,
    IN  DWORD   dwMemoryLength,
    IN  DWORD   dwIOSize,
    IN  DWORD   dwBufferCount,
    IN  DWORD   dwAlignment
    )
{
    BOOL    r ;
    DWORD   dwRet ;

    r = MemoryOk (
            pbMemory,
            dwMemoryLength,
            dwAlignment,
            dwIOSize,
            dwBufferCount,
            NULL
            ) ;
    if (r) {
        UninitializeWriter_ () ;

        SECURITY_ATTRIBUTES  sa;
        PACL                 pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;

        if (m_dwNumSids > 0)
        {
            DWORD                dwAclCreationStatus;

            dwAclCreationStatus = ::CreateACL(m_dwNumSids,
                                              m_ppSids,
                                              SET_ACCESS, MUTEX_ALL_ACCESS,
                                              SET_ACCESS, SYNCHRONIZE,
                                              pACL,
                                              pSD
                                             );

            if (dwAclCreationStatus != ERROR_SUCCESS)
            {
                dwRet = dwAclCreationStatus;
                goto cleanup;
            }

            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
        }

        dwRet = m_WriteBufferWriter.Initialize (
                        m_dwNumSids > 0? &sa : NULL,
                        pbMemory,
                        dwMemoryLength,
                        dwAlignment,
                        dwIOSize,
                        dwBufferCount
                        ) ;
        
        if (m_dwNumSids > 0)
        {
            ::FreeSecurityDescriptors(pACL, pSD);
        }
    }
    else {
        dwRet = ERROR_INVALID_PARAMETER ;
    }

    cleanup:

    return dwRet ;
}

DWORD
CPVRAsyncWriter::Flush (
    OUT ULONGLONG * pullFileLength
    )
{
    DWORD           dwWriteBytes ;
    DWORD           dwRet ;
    ULONGLONG       ullStreamWrite ;

    BOOL                fWriteBufferFlushed ;
    PVR_WRITE_BUFFER *  pPVRWriteBuffer ;

    dwRet = ERROR_GEN_FAILURE ;

    //  serialize this so no one can write during a flushing call; no need to hold
    //    the shared memory lock because we only expect 1 writer, and the readers
    //    read passively
    Lock_ () ;

    ASSERT (!m_PVRWriteWait.fWaiting) ;

    if (m_WriteBufferWriter.Lock ()) {

        ASSERT (m_WriteBufferWriter.CallerOwnsLock ()) ;

        pPVRWriteBuffer = m_WriteBufferWriter.CurPVRWriteBuffer () ;

        if (pPVRWriteBuffer -> BufferState == BUFFER_STATE_FILLING) {

            //  write buffer will be flushed
            fWriteBufferFlushed = TRUE ;

            //  might need to align
            dwWriteBytes = ::AlignUp (pPVRWriteBuffer -> dwData, m_dwAlignment) ;
            ASSERT (m_WriteBufferWriter.WriteBufferStream () -> dwIoLength >= dwWriteBytes) ;

            //  stream offset
            ullStreamWrite = m_WriteBufferWriter.CurPVRWriteBufferStreamOffset () ;

            //  still perhaps align upwards, since we'd have an index to write, etc..
            dwRet = MaybeGrowFile_ (ullStreamWrite, dwWriteBytes) ;
            if (dwRet != NOERROR) {
                //  the only failure case occurs if we had to extend the file
                //    and failed to do so; try to do it by less than the
                //    growth quantum
                ASSERT (m_ullCurFileLength < ::AlignUp <ULONGLONG> (ullStreamWrite + dwWriteBytes, m_dwAlignment)) ;
                dwRet = SetPVRFileLength_ (ullStreamWrite + dwWriteBytes) ;
                if (dwRet != NOERROR) {
                    //  we're out of room altogether; fail the flush
                    goto cleanup ;
                }
            }

            //  file should be sufficiently long
            ASSERT (m_ullCurFileLength >= ullStreamWrite + dwWriteBytes) ;

            TRACE_2 (LOG_AREA_PVRIO, 4,
                TEXT ("CPVRAsyncWriter::Flush; flushing buffer[%d], with %d bytes"),
                pPVRWriteBuffer -> dwIndex, dwWriteBytes) ;

            //  state is now pending IO; we'll reset it after completion
            pPVRWriteBuffer -> BufferState = BUFFER_STATE_IO_PENDING ;

            //  pend it
            ::InterlockedIncrement (& m_cIoPending) ;

            dwRet = m_pAsyncIo -> PendWrite (
                        m_hFileIo,
                        ullStreamWrite,
                        m_WriteBufferWriter.Buffer (pPVRWriteBuffer),
                        dwWriteBytes,
                        reinterpret_cast <DWORD_PTR> (pPVRWriteBuffer),
                        this
                        ) ;

            if (dwRet != NOERROR) {
                //  might be pending
                if (dwRet == ERROR_IO_PENDING) {
                    dwRet = NOERROR ;
                }
                else {
                    //  true error
                    ::InterlockedDecrement (& m_cIoPending) ;

                    //  reset the state and let the caller deal with the error
                    pPVRWriteBuffer -> BufferState = BUFFER_STATE_FILLING ;

                    goto cleanup ;
                }
            }

            ASSERT (dwRet == NOERROR) ;
        }
        else {
            fWriteBufferFlushed = FALSE ;
        }

        //  if anything is still outstanding (as our partially full write buffer perhaps)
        //    wait for the completions
        if (m_cIoPending != 0) {
            ::ResetEvent (m_hWaiting) ;
            m_PVRWriteWait.fWaiting         = TRUE ;
            m_PVRWriteWait.PVRWriteWaitFor  = WAIT_FOR_DRAIN ;  //  what we're waiting for

            //  and wait
            m_WriteBufferWriter.Unlock () ;
            dwRet = WaitForSingleObject (m_hWaiting, INFINITE) ;
            m_WriteBufferWriter.Lock () ;

            dwRet = (dwRet == WAIT_OBJECT_0 ? NOERROR : m_PVRWriteWait.dwWaitRet) ;
        }

        if (fWriteBufferFlushed) {
            //  reset the current write buffer state
            pPVRWriteBuffer -> BufferState = BUFFER_STATE_FILLING ;
        }

        //  set the file length
        dwRet = SetPVRFileLength_ (m_WriteBufferWriter.CurBytesCopied ()) ;
        if (dwRet == NOERROR) {
            ASSERT (m_ullCurFileLength == m_WriteBufferWriter.CurBytesCopied ()) ;

            if (pullFileLength) {
                (* pullFileLength) = m_ullCurFileLength ;
            }
        }

        cleanup :

        m_WriteBufferWriter.Unlock () ;
    }
    else {
        //  failed to obtain the lock
        dwRet = ERROR_GEN_FAILURE ;
    }

    Unlock_ () ;

    ASSERT (!m_WriteBufferWriter.CallerOwnsLock ()) ;

    return dwRet ;
}

ULONGLONG
CPVRAsyncWriter::BytesAppended (
    )
{
    ULONGLONG   ullBytes ;

    Lock_ () ;

    ullBytes = m_WriteBufferWriter.CurBytesCopied () ;

    Unlock_ () ;

    return ullBytes ;
}

DWORD
CPVRAsyncWriter::SetFilePointer_ (
    IN  HANDLE      hFile,
    IN  ULONGLONG   ullOffset
    )
{
    DWORD           dwRet ;
    BOOL            r ;
    LARGE_INTEGER   li ;

    li.LowPart  = (DWORD) (0x00000000ffffffff & ullOffset) ;
    li.HighPart = (LONG) (0x00000000ffffffff & (ullOffset >> 32)) ;

    r = ::SetFilePointerEx (
                hFile,
                li,
                NULL,
                FILE_BEGIN
                ) ;
    if (r) {
        dwRet = NOERROR ;
    }
    else {
        dwRet = ::GetLastError () ;
    }

    return dwRet ;
}

DWORD
CPVRAsyncWriter::SetFileLength (
    IN  HANDLE      hFile,
    IN  ULONGLONG   ullLength
    )
{
    BOOL    r ;
    DWORD   dwRet ;

    ASSERT (hFile != INVALID_HANDLE_VALUE) ;
    dwRet = SetFilePointer_ (hFile, ullLength) ;
    if (dwRet == NOERROR) {
        r = ::SetEndOfFile (hFile) ;
        if (!r) {
            dwRet = ::GetLastError () ;
        }
    }

    return dwRet ;
}

DWORD
CPVRAsyncWriter::SetPVRFileLength_ (
    IN  ULONGLONG   ullTargetLength
    )
{
    DWORD   dwRet ;

    dwRet = CPVRAsyncWriter::SetFileLength (m_hFileLen, ullTargetLength) ;
    if (dwRet == NOERROR) {

        TRACE_2 (LOG_AREA_PVRIO, 4,
            TEXT ("CPVRAsyncWriter::SetPVRFileLength_; set file size from %I64d to %I64d"),
            m_ullCurFileLength, ullTargetLength) ;

        m_ullCurFileLength = ullTargetLength ;
    }
    else {
        TRACE_3 (LOG_ERROR, 1,
            TEXT ("CPVRAsyncWriter::SetPVRFileLength_; failed to change the file size from %I64d to %I64d; dwRet = %d"),
            m_ullCurFileLength, ullTargetLength, dwRet) ;
    }

    return dwRet ;
}

DWORD
CPVRAsyncWriter::MaybeGrowFile_ (
    IN  ULONGLONG   ullCurValidLen,
    IN  DWORD       cBytesToWrite
    )
{
    DWORD   dwRet ;
    DWORD   dwGrowBy ;

    //  check if we first must grow the file
    if (ullCurValidLen + cBytesToWrite > m_ullCurFileLength) {

        if (m_dwFileGrowthQuantum >= cBytesToWrite) {
            dwGrowBy = m_dwFileGrowthQuantum ;
        }
        else {
            dwGrowBy = ::AlignUp <DWORD> (cBytesToWrite, m_dwFileGrowthQuantum) ;
        }

        dwRet = SetPVRFileLength_ (m_ullCurFileLength + dwGrowBy) ;

        m_pPVRIOCounters -> AsyncWriter_FileExtended () ;
    }
    else {
        dwRet = NOERROR ;
    }

    return dwRet ;
}

DWORD
CPVRAsyncWriter::AppendBytes (
    IN OUT  BYTE ** ppbBuffer,
    IN OUT  DWORD * pdwBufferLength
    )
{
    DWORD       dwRet ;
    ULONGLONG   ullStreamWriteTo ;

    DWORD               dwWriteBufferRemaining ;
    PVR_WRITE_BUFFER *  pPVRWriteBuffer ;
    DWORD               dwBytes ;

    dwRet = NOERROR ;

    ASSERT (!m_WriteBufferWriter.CallerOwnsLock ()) ;
    ASSERT (m_hFileIo != INVALID_HANDLE_VALUE) ;

    //  lock here in case someone tries to write while a previous call is waiting
    Lock_ () ;

    ASSERT (!m_PVRWriteWait.fWaiting) ;

    while ((* pdwBufferLength) > 0) {

        dwBytes = (* pdwBufferLength) ;

        //  append
        dwRet = m_WriteBufferWriter.AppendToCurPVRWriteBuffer (
                        ppbBuffer,
                        pdwBufferLength,
                        & dwWriteBufferRemaining
                        ) ;

        if (dwRet == NOERROR) {

            m_pPVRIOCounters -> AsyncWriter_BytesAppended (dwBytes - (* pdwBufferLength)) ;

            //  check if the write buffer is full
            if (dwWriteBufferRemaining == 0) {

                //
                //  current write buffer is full; need to write it out to disk
                //

                //  recover it
                pPVRWriteBuffer = m_WriteBufferWriter.CurPVRWriteBuffer () ;

                //  make sure state is as we expect it
                ASSERT (m_WriteBufferWriter.WriteBufferStream () -> dwIoLength == pPVRWriteBuffer -> dwData) ;
                ASSERT (pPVRWriteBuffer -> BufferState == BUFFER_STATE_FILLING) ;

                //  compute the stream offset it will go to
                ullStreamWriteTo = m_WriteBufferWriter.CurPVRWriteBufferStreamOffset () ;

                //  might need to grow file (always go 1 extra, so we can flush ok if we run out)
                dwRet = MaybeGrowFile_ (
                            ullStreamWriteTo + m_WriteBufferWriter.WriteBufferStream () -> dwIoLength,
                            pPVRWriteBuffer -> dwData
                            ) ;
                if (dwRet != NOERROR) {
                    break ;
                }

                //  so far everything has been passive, but now that we start
                //    updating state in the buffer, we must grab the lock
                if (m_WriteBufferWriter.Lock ()) {

                    //  buffer state is now pending IO
                    pPVRWriteBuffer -> BufferState = BUFFER_STATE_IO_PENDING ;

                    //  one more IO pending
                    ::InterlockedIncrement (& m_cIoPending) ;

                    //  pend the write
                    dwRet = m_pAsyncIo -> PendWrite (
                                m_hFileIo,
                                ullStreamWriteTo,
                                m_WriteBufferWriter.Buffer (pPVRWriteBuffer),
                                pPVRWriteBuffer -> dwData,
                                reinterpret_cast <DWORD_PTR> (pPVRWriteBuffer),
                                this
                                ) ;

                    TRACE_4 (LOG_AREA_PVRIO, 4,
                        TEXT ("CPVRAsyncWriter::AppendBytes; buffer[%d] %I64u : %d bytes; ret = %u"),
                        pPVRWriteBuffer -> dwIndex, ullStreamWriteTo, pPVRWriteBuffer -> dwData, dwRet) ;

                    if (dwRet != NOERROR &&
                        dwRet != ERROR_IO_PENDING) {

                        //  check for an outright failure

                        ::InterlockedDecrement (& m_cIoPending) ;

                        //  reset the state and let the caller deal with the error
                        pPVRWriteBuffer -> BufferState = BUFFER_STATE_FILLING ;

                        TRACE_2 (LOG_ERROR, 1,
                            TEXT ("CPVRAsyncWriter::AppendBytes; IO pend failed; buffer[%d]; dwRet = %d"),
                            pPVRWriteBuffer -> dwIndex, dwRet) ;

                        //  release the lock
                        m_WriteBufferWriter.Unlock () ;

                        m_pPVRIOCounters -> AsyncWriter_IOPendedError () ;

                        break ;
                    }

                    m_pPVRIOCounters -> AsyncWriter_IOPended () ;

                    //  don't force the caller to deal with IO pending etc...
                    dwRet = NOERROR ;

                    //  if the next buffer is unavailable, we're going to have
                    //    to wait for it
                    if (m_WriteBufferWriter.NextPVRWriteBuffer () -> BufferState == BUFFER_STATE_IO_PENDING) {

                        m_pPVRIOCounters -> AsyncWriter_WaitNextBuffer () ;

                        //  object critsec should prevent this from happening
                        ASSERT (!m_PVRWriteWait.fWaiting) ;

                        //  setup our wait context
                        m_PVRWriteWait.fWaiting         = TRUE ;
                        m_PVRWriteWait.PVRWriteWaitFor  = WAIT_FOR_COMPLETION ;
                        m_PVRWriteWait.dwWaitContext    = m_WriteBufferWriter.NextPVRWriteBuffer () -> dwIndex ;

                        //  non-signal
                        ::ResetEvent (m_hWaiting) ;

                        //  release the lock and wait to be signaled
                        m_WriteBufferWriter.Unlock () ;
                        dwRet = ::WaitForSingleObject (m_hWaiting, INFINITE) ;
                        m_WriteBufferWriter.Lock () ;

                        if (dwRet == WAIT_OBJECT_0) {
                            dwRet = NOERROR ;
                        }
                        else {
                            dwRet = ERROR_GEN_FAILURE ;
                        }
                    }
                    else {
                        dwRet = NOERROR ;
                    }

                    if (dwRet == NOERROR) {
                        //  if all is ok, advance
                        m_WriteBufferWriter.AdvancePVRWriteBufferLocked () ;
                    }

                    m_WriteBufferWriter.Unlock () ;
                }
            }
        }
        else {
            //  error occured during write; bail
            break ;
        }
    }

    //  should never own the lock all the way out here
    ASSERT (!m_WriteBufferWriter.CallerOwnsLock ()) ;

    Unlock_ () ;

    return dwRet ;
}

void
CPVRAsyncWriter::CheckForWaits_ (
    IN  PVR_WRITE_BUFFER *  pPVRCompletedWriteBuffer
    )
{
    BOOL    fWaitConditionMet ;
    DWORD   dwRet ;

    ASSERT (m_WriteBufferWriter.CallerOwnsLock ()) ;

    if (m_PVRWriteWait.fWaiting) {
        //  someone is waiting check what they are waiting for
        switch (m_PVRWriteWait.PVRWriteWaitFor) {
            case WAIT_FOR_DRAIN :
                fWaitConditionMet = (m_cIoPending == 0 ? TRUE : FALSE) ;
                dwRet = NOERROR ;
                break ;

            case WAIT_FOR_COMPLETION :
                fWaitConditionMet = (pPVRCompletedWriteBuffer -> dwIndex == m_PVRWriteWait.dwWaitContext ? TRUE : FALSE) ;
                dwRet = NOERROR ;
                break ;

            default :
                fWaitConditionMet = FALSE ;
        } ;

        if (fWaitConditionMet) {
            //  reset and set outgoing
            m_PVRWriteWait.fWaiting     = FALSE ;
            m_PVRWriteWait.dwWaitRet    = dwRet ;

            //  check please
            ::SetEvent (m_hWaiting) ;
        }
    }
}

void
CPVRAsyncWriter::IOCompleted (
    IN  DWORD       dwIoBytes,
    IN  DWORD_PTR   dwpContext,
    IN  DWORD       dwIOReturn
    )
{
    PVR_WRITE_BUFFER *    pPVRWriteBuffer ;

    //  recover the buffer
    pPVRWriteBuffer = reinterpret_cast <PVR_WRITE_BUFFER *> (dwpContext) ;

    //  grab the lock
    ASSERT (!m_WriteBufferWriter.CallerOwnsLock ()) ;
    m_WriteBufferWriter.Lock () ;

    //  update state on completed buffer
    ASSERT (pPVRWriteBuffer -> BufferState == BUFFER_STATE_IO_PENDING) ;
    pPVRWriteBuffer -> BufferState = BUFFER_STATE_IO_COMPLETED ;

    //  one less IO pending
    ASSERT (m_cIoPending > 0) ;
    ::InterlockedDecrement (& m_cIoPending) ;

    //  update contiguous bytes on disk
    m_WriteBufferWriter.UpdateMaxContiguousLocked (pPVRWriteBuffer) ;

    TRACE_2 (LOG_AREA_PVRIO, 8,
        TEXT ("CPVRAsyncWriter::IOCompleted; buffer[%d] %d bytes"),
        pPVRWriteBuffer -> dwIndex, pPVRWriteBuffer -> dwData) ;

    //  check if anyone is waiting for something
    CheckForWaits_ (pPVRWriteBuffer) ;

    m_pPVRIOCounters -> AsyncWriter_IOCompletion (dwIOReturn) ;

    //  we are done; release the lock
    ASSERT (m_WriteBufferWriter.CallerOwnsLock ()) ;
    m_WriteBufferWriter.Unlock () ;
}

//  ============================================================================
//  ============================================================================

CPVRAsyncWriterSharedMem::CPVRAsyncWriterSharedMem (
    IN  HANDLE              hFileIo,                        //  duplicated
    IN  HANDLE              hFileLen,                       //  duplicated; buffered so no alignment restrictions; this handle will be used to set length
    IN  LPWSTR              pszPVRBufferStreamMap,
    IN  DWORD               dwIOSize,
    IN  DWORD               dwBufferCount,
    IN  DWORD               dwAlignment,
    IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
    IN  CAsyncIo *          pAsyncIo,
    IN  CPVRIOCounters *    pPVRIOCounters,
    IN  DWORD               dwNumSids,
    IN  PSID *              ppSids,
    OUT DWORD *             pdwRet
    ) : m_pSharedMem        (NULL),
        CPVRAsyncWriter     (hFileIo,
                             hFileLen,
                             dwIOSize,
                             dwBufferCount,
                             dwAlignment,
                             dwFileGrowthQuantum,
                             pAsyncIo,
                             pPVRIOCounters,
                             dwNumSids,
                             ppSids,
                             pdwRet
                             )
{
    DWORD   dwHeaderLength ;
    DWORD   dwTotalBufferLength ;
    DWORD   dwMappingLength ;
    DWORD   i ;
    BOOL    r ;
    DWORD   dwExtraMemoryNeeded ;
    HRESULT hr ;

    SECURITY_ATTRIBUTES  sa;
    PACL                 pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;

    if ((* pdwRet) != NOERROR) {
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  compute the mapping length

    dwHeaderLength = (sizeof PVR_WRITE_BUFFER_STREAM - sizeof PVR_WRITE_BUFFER) +
                     dwBufferCount * sizeof PVR_WRITE_BUFFER ;

    //  this is the offset to the actual buffers
    dwHeaderLength = ::AlignUp (dwHeaderLength, dwAlignment) ;

    ASSERT (!(((((ULONGLONG) dwIOSize) * (ULONGLONG) (dwBufferCount))) & 0xffffffff00000000)) ;
    dwTotalBufferLength = dwIOSize * dwBufferCount ;

    //  so total file size will be dwHeaderLength + ullTotalBufferLength ;
    dwMappingLength = dwHeaderLength + dwTotalBufferLength ;

    //  ------------------------------------------------------------------------
    //  create the mapping

    if (dwNumSids > 0)
    {
        DWORD                dwAclCreationStatus;

        // Note: This file mapping is backed by the paging file. Removing WRITE_DAC and WRITE_OWNER
        // for the non-CREATOR_OWNER SIDs does not work: the mapping cannot be opened by other
        // users (and not even by the user that creates the mapping if he's not an admin).
        dwAclCreationStatus = ::CreateACL(m_dwNumSids,
                                          m_ppSids,
                                          SET_ACCESS, SECTION_ALL_ACCESS & ~(SECTION_EXTEND_SIZE|SECTION_MAP_EXECUTE),
                                          SET_ACCESS, SECTION_ALL_ACCESS & ~(SECTION_EXTEND_SIZE|SECTION_MAP_EXECUTE),
                                          pACL,
                                          pSD
                                         );

        if (dwAclCreationStatus != ERROR_SUCCESS)
        {
            (* pdwRet) = dwAclCreationStatus;
            goto cleanup;
        }

        sa.nLength = sizeof (SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;
    }

    for (i = 0; i < MAX_MEM_FRAMING_TRIES; i++) {
        m_pSharedMem = new CWin32SharedMem (
                                pszPVRBufferStreamMap,
                                dwMappingLength,
                                & hr,
                                m_dwNumSids > 0 ? &sa : NULL
                                ) ;
        if (!m_pSharedMem) {
            (* pdwRet) = ERROR_NOT_ENOUGH_MEMORY ;
            goto cleanup ;
        }
        else if (FAILED (hr)) {
            delete m_pSharedMem ;
            m_pSharedMem = NULL ;
            (* pdwRet) = ERROR_GEN_FAILURE ;
            goto cleanup ;
        }

        if ((* pdwRet) != NOERROR ||
            !m_pSharedMem) {

            (* pdwRet) = (m_pSharedMem ? (* pdwRet) : ERROR_NOT_ENOUGH_MEMORY) ;
            goto cleanup ;
        }

        r = MemoryOk (
                m_pSharedMem -> GetSharedMem (),
                m_pSharedMem -> GetSharedMemSize (),
                dwAlignment,
                dwIOSize,
                dwBufferCount,
                & dwExtraMemoryNeeded
                ) ;
        if (r) {
            //  memory will do
            break ;
        }

        delete m_pSharedMem ;
        m_pSharedMem = NULL ;

        //  add on the extra memory and try again
        dwMappingLength += dwExtraMemoryNeeded ;
    }

    if (!m_pSharedMem) {
        (* pdwRet) = ERROR_GEN_FAILURE ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  initialize the writer

    (* pdwRet) = InitializeWriter_ (
                    m_pSharedMem -> GetSharedMem (),
                    m_pSharedMem -> GetSharedMemSize (),
                    dwIOSize,
                    dwBufferCount,
                    dwAlignment
                    ) ;

    cleanup :

        
    if (m_dwNumSids > 0)
    {
        ::FreeSecurityDescriptors(pACL, pSD);
    }

    return ;
}

CPVRAsyncWriterSharedMem::~CPVRAsyncWriterSharedMem (
    )
{
    UninitializeWriter_ () ;
    delete m_pSharedMem ;
}

//  ============================================================================
//  ============================================================================

CPVRAsyncWriterCOM::CPVRAsyncWriterCOM (
    IN  DWORD               dwIOSize,
    IN  DWORD               dwBufferCount,
    IN  DWORD               dwAlignment,
    IN  DWORD               dwFileGrowthQuantum,            //  must be a multiple of the IO size
    IN  CAsyncIo *          pAsyncIo,
    IN  CPVRIOCounters *    pPVRIOCounters,
    IN  DWORD               dwNumSids,
    IN  PSID*               ppSids,        
    OUT DWORD *             pdwRet
    ) : m_dwIOSize              (dwIOSize),
        m_dwBufferCount         (dwBufferCount),
        m_dwAlignment           (dwAlignment),
        m_dwFileGrowthQuantum   (dwFileGrowthQuantum),
        m_pAsyncIo              (pAsyncIo),
        m_cRef                  (0),
        m_pPVRAsyncWriter       (NULL),
        m_pPVRIOCounters        (pPVRIOCounters),
        m_dwNumSids             (dwNumSids),
        m_ppSids                (ppSids) // We do not make a copy or free these SIDs
                                         
{
    ASSERT (m_pAsyncIo) ;
    ASSERT (m_pPVRIOCounters) ;

    if (dwNumSids)
    {
        ASSERT(ppSids);

    }
    else
    {
        ASSERT(!ppSids);
    }

    ::InitializeCriticalSection (& m_crt) ;

    m_pAsyncIo -> AddRef () ;
    m_pPVRIOCounters -> AddRef () ;

    (* pdwRet) = ::UuidCreate (& m_guidWriterId) ;
}

CPVRAsyncWriterCOM::~CPVRAsyncWriterCOM (
    )
{
    SetWriterInactive () ;
    ASSERT (!m_pPVRAsyncWriter) ;

    m_pAsyncIo -> Release () ;

    m_pPVRIOCounters -> Release () ;

    ::DeleteCriticalSection (& m_crt) ;
}

//  --------------------------------------------------------------------
//  IUnknown methods

STDMETHODIMP_(ULONG)
CPVRAsyncWriterCOM::AddRef (
    )
{
    return ::InterlockedIncrement (& m_cRef) ;
}

STDMETHODIMP_(ULONG)
CPVRAsyncWriterCOM::Release (
    )
{
    if (::InterlockedDecrement (& m_cRef) == 0) {
        delete this ;
        return 0 ;
    }

    return 1 ;
}

STDMETHODIMP
CPVRAsyncWriterCOM::QueryInterface (
    IN REFIID   riid,
    OUT void ** ppv
    )
{
    if (!ppv) {
        return E_POINTER ;
    }

    if (riid == IID_IUnknown) {

        (* ppv) = static_cast <IUnknown *> (this) ;
    }
    else if (riid == IID_IDVRAsyncWriter) {
        (* ppv) = static_cast <IDVRAsyncWriter *> (this) ;
    }
    else {
        return E_NOINTERFACE ;
    }

    ASSERT (* ppv) ;

    //  outgoing
    ((IUnknown *) (* ppv)) -> AddRef () ;

    return S_OK ;
}

//  --------------------------------------------------------------------
//  IDVRAsyncWriter

STDMETHODIMP
CPVRAsyncWriterCOM::SetWriterActive (
    IN  LPCWSTR pszFilename,                //  should already have been created
    IN  DWORD   dwFileSharingFlags,         //  file sharing flags
    IN  DWORD   dwFileCreation              //  file creation
    )
{
    HRESULT                     hr ;
    DWORD                       dwRet ;
    HANDLE                      hFileIo ;
    HANDLE                      hFileLen ;
    CPVRAsyncWriterSharedMem *  pPVRAsyncWriterSharedMem ;
    WCHAR                       szSharedMemName [HW_PROFILE_GUIDLEN] ;
    WCHAR                       szGlobalSharedMemName [HW_PROFILE_GUIDLEN+10] ;
    int                         k ;

    hFileIo     = INVALID_HANDLE_VALUE ;
    hFileLen    = INVALID_HANDLE_VALUE ;

    Lock_ ()  ;

    if (!m_pPVRAsyncWriter) {

        hFileIo = CPVRAsyncWriter::OpenFile (
                    pszFilename,
                    dwFileSharingFlags,
                    dwFileCreation,
                    FALSE                       //  not buffered
                    ) ;

        hFileLen = CPVRAsyncWriter::OpenFile (
                    pszFilename,
                    dwFileSharingFlags,
                    dwFileCreation,
                    TRUE                        //  buffered
                    ) ;

        if (hFileIo     != INVALID_HANDLE_VALUE &&
            hFileLen    != INVALID_HANDLE_VALUE) {

            //  create our shared memory name (writer id is unique)
            k = ::StringFromGUID2 (
                    m_guidWriterId,
                    szSharedMemName,
                    sizeof szSharedMemName / sizeof WCHAR
                    ) ;
            if (k == 0) {
                //  a GUID is a GUID; this should not happen
                hr = E_FAIL ;
                goto cleanup ;
            }

            //  explicitely null-terminate this
            szSharedMemName [HW_PROFILE_GUIDLEN - 1] = L'\0' ;

            wcscpy(szGlobalSharedMemName, L"Global\\");
            wcscat(szGlobalSharedMemName, szSharedMemName);

            //  instantiate
            pPVRAsyncWriterSharedMem = new CPVRAsyncWriterSharedMem (
                                                hFileIo,
                                                hFileLen,
                                                szGlobalSharedMemName,
                                                m_dwIOSize,
                                                m_dwBufferCount,
                                                m_dwAlignment,
                                                m_dwFileGrowthQuantum,
                                                m_pAsyncIo,
                                                m_pPVRIOCounters,
                                                m_dwNumSids,
                                                m_ppSids,
                                                & dwRet
                                                ) ;

            //  check for errors
            if (!pPVRAsyncWriterSharedMem) {
                hr = E_OUTOFMEMORY ;
            }
            else if (dwRet != NOERROR) {
                delete pPVRAsyncWriterSharedMem ;
                pPVRAsyncWriterSharedMem = NULL ;
                hr = HRESULT_FROM_WIN32 (dwRet) ;
            }
            else {
                //  success !
                m_pPVRAsyncWriter = pPVRAsyncWriterSharedMem ;
                hr = S_OK ;
            }
        }
        else {
            //  failed to open the target
            dwRet = ::GetLastError () ;
            hr = HRESULT_FROM_WIN32 (dwRet) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    cleanup :

    Unlock_ ()  ;

    if (hFileIo != INVALID_HANDLE_VALUE) {
        ::CloseHandle (hFileIo) ;
    }

    if (hFileLen != INVALID_HANDLE_VALUE) {
        ::CloseHandle (hFileLen) ;
    }

    return hr ;
}

STDMETHODIMP
CPVRAsyncWriterCOM::GetWriterId (
    OUT GUID *  pguidWriterId
    )
{
    if (!pguidWriterId) {
        return E_POINTER ;
    }

    //  GUID never changes after we are instantiated
    (* pguidWriterId) = m_guidWriterId ;

    return S_OK ;
}

STDMETHODIMP
CPVRAsyncWriterCOM::SetWriterInactive (
    )
{
    Lock_ ()  ;

    if (m_pPVRAsyncWriter) {
        delete m_pPVRAsyncWriter ;
        m_pPVRAsyncWriter = NULL ;
    }

    Unlock_ ()  ;

    return S_OK ;
}

STDMETHODIMP
CPVRAsyncWriterCOM::AppendBytes (
    IN OUT  BYTE ** ppbBuffer,
    IN OUT  DWORD * pdwBufferLength
    )
{
    HRESULT hr ;
    DWORD   dwRet ;

    if (!ppbBuffer ||
        !pdwBufferLength) {

        return E_POINTER ;
    }

    Lock_ ()  ;

    if (m_pPVRAsyncWriter) {
        dwRet = m_pPVRAsyncWriter -> AppendBytes (ppbBuffer, pdwBufferLength) ;
        hr = HRESULT_FROM_WIN32 (dwRet) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ ()  ;

    return hr ;
}

STDMETHODIMP
CPVRAsyncWriterCOM::FlushToDisk (
    )
{
    HRESULT hr ;
    DWORD   dwRet ;

    Lock_ ()  ;

    if (m_pPVRAsyncWriter) {
        dwRet = m_pPVRAsyncWriter -> Flush () ;
        hr = HRESULT_FROM_WIN32 (dwRet) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ ()  ;

    return hr ;
}

STDMETHODIMP
CPVRAsyncWriterCOM::TotalBytes (
    OUT ULONGLONG * pullTotalBytesAppended
    )
{
    HRESULT hr ;

    if (!pullTotalBytesAppended) {
        return E_POINTER ;
    }

    Lock_ ()  ;

    if (m_pPVRAsyncWriter) {
        (* pullTotalBytesAppended) = m_pPVRAsyncWriter -> BytesAppended () ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ ()  ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvrdebug.cpp ===
//------------------------------------------------------------------------------
// File: dvrDebug.cpp
//
// Description: Implements debugging functions.
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

#include <stdio.h>

#if defined(DEBUG)

#define DVRIO_DUMP_THIS_FORMAT_STR ""
#define DVRIO_DUMP_THIS_VALUE

// Global variables
DWORD g_nDvrIopDbgCommandLineAssert = 0;
DWORD g_nDvrIopDbgInDllEntryPoint = 0;
DWORD g_nDvrIopDbgOutputLevel = 0; // Higher is more verbose
DWORD g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_LAST_LEVEL] = {
    0,          // Internal error
    0,          // Client Error
    0,          // Internal Warning
    10          // Trace
};

// Debug registry key's value  names
static const WCHAR* g_awszDvrIopDbgLevelRegValueNames[] = {
    L"CommandLineAssert",
    L"DebugOutputLevel",
    L"InternalErrorLevel",
    L"ClientErrorLevel",
    L"InternalWarningLevel",
    L"TraceLevel"
};

static DWORD* g_apdwDvrIopDbgLevelVariables
        [sizeof(g_awszDvrIopDbgLevelRegValueNames)/sizeof(g_awszDvrIopDbgLevelRegValueNames[0])] = {
    &g_nDvrIopDbgCommandLineAssert,
    &g_nDvrIopDbgOutputLevel,
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_ERROR_LEVEL],
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_CLIENT_ERROR_LEVEL],
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_WARNING_LEVEL],
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_TRACE_LEVEL]
};

void DvrIopDbgInit(IN HKEY hRegistryDVRRootKey)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopDbgInit"

    // Has no effect for the first call to this fn since we are
    // using default values for the levels.
    DVRIO_TRACE_ENTER();

    static LONG g_nInit = -1;
    static HANDLE volatile g_hEvent = NULL;

    if (::InterlockedIncrement(&g_nInit))
    {
        // Already intialized
        ::InterlockedDecrement(&g_nInit);

        // It is not critical that we avoid race conditions here,
        // i.e., we suspend this thread until the thread that
        // started executing this function first completes.

        DWORD dwRet;
        DWORD i = 0;
        while ((dwRet = ::WaitForSingleObject(g_hEvent, INFINITE)) != WAIT_OBJECT_0)
        {
            // Looks like the event hasn't yet been created, poll.
            DVR_ASSERT(dwRet == WAIT_FAILED && GetLastError() == ERROR_INVALID_HANDLE, "");
            ::Sleep(200);
            i += 1;
            if (i == 20)
            {
                // hmmm....
                DVR_ASSERT(0, "Waited too long ...");
                break;
            }
        }
        return;
    }

    // We never close this handle since we don't have a shutdown routine.
    // Also, we don't care if this fails, just go on
    g_hEvent = ::CreateEventW(NULL, TRUE, FALSE, NULL);
    DVR_ASSERT(g_hEvent, "Event creation failed?!");

    // Override default settings from registry
    DvrIopDbgInitFromRegistry(hRegistryDVRRootKey,
                              sizeof(g_awszDvrIopDbgLevelRegValueNames)/sizeof(g_awszDvrIopDbgLevelRegValueNames[0]),
                              g_awszDvrIopDbgLevelRegValueNames,
                              g_apdwDvrIopDbgLevelVariables);

    ::SetEvent(g_hEvent);

    DVRIO_TRACE_LEAVE0();

    return;

} // DvrIopDbgInit

// A lot of this lifted from DShow base classes

typedef struct
{
    HWND  hwnd;
    PCHAR pszTitle;
    PCHAR pszMessage;
    DWORD dwFlags;
    DWORD iResult;
} DVRIO_DEBUG_MSG;

//
// create a thread to call MessageBox(). Calling MessageBox() on
// random threads at bad times can confuse the host app.
//
static DWORD WINAPI
DvrIopMsgBoxThread(
    IN OUT LPVOID lpParameter
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopMsgBoxThread"

    DVRIO_DEBUG_MSG *pMsg = (DVRIO_DEBUG_MSG *)lpParameter;
    pMsg->iResult = MessageBoxA(pMsg->hwnd,
                                pMsg->pszTitle,
                                pMsg->pszMessage,
                                pMsg->dwFlags);

    return 0;
}

static DWORD
DvrIopMessageBoxOtherThread(
    IN  HWND  hwnd,
    IN  PCHAR pszTitle,
    IN  PCHAR pszMessage,
    IN  DWORD dwFlags
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopMessageBoxOtherThread"

    if(g_nDvrIopDbgInDllEntryPoint)
    {
        // can't wait on another thread because we have the loader
        // lock held in the dll entry point.
        return MessageBoxA(hwnd, pszTitle, pszMessage, dwFlags);
    }
    else
    {
        DVRIO_DEBUG_MSG msg = {hwnd, pszTitle, pszMessage, dwFlags, 0};
        DWORD dwid;
        HANDLE hThread;

        hThread = CreateThread(0,                      // security
                               0,                      // stack size
                               DvrIopMsgBoxThread,
                               (LPVOID) &msg,          // arg
                               0,                      // flags
                               &dwid);

        if(hThread)
        {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
            return msg.iResult;
        }

        // break into debugger on failure.
        return IDCANCEL;
    }
} // DvrIopMessageBoxOtherThread

void DvrIopDbgAssert(
    IN const PCHAR pszMsg,
    IN const PCHAR pszCondition,
    IN const PCHAR pszFileName,
    IN DWORD iLine,
    IN LPVOID pThis /* = NULL */,
    IN DWORD  dwThisId /* = 0 */
    )
{
    // RTL's DbgPrint takes only PCHAR arguments

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopDbgAssert"

    CHAR szInfo[512];
    int nRet;

    //  security: bail if any of these strings are ever overrun

    if (pThis)
    {
        CHAR szFormat[512];
        nRet = _snprintf(szFormat, sizeof szFormat / sizeof CHAR,
                         "%hs\n*** Assertion: \"%hs\" failed\nat line %u of %hs\n",
                         pszMsg, pszCondition, iLine, pszFileName);
        if (nRet < 0 || nRet == sizeof szFormat / sizeof CHAR) { return ; }

        nRet = _snprintf(szInfo, sizeof szInfo / sizeof CHAR,
                          szFormat, pThis, dwThisId);
        if (nRet < 0 || nRet == sizeof szInfo / sizeof CHAR) { return ; }
    }
    else
    {
        nRet = _snprintf(szInfo, sizeof szInfo / sizeof CHAR,
                         "%hs\n*** Assertion: \"%hs\" failed\nat line %u of %hs\n",
                         pszMsg, pszCondition, iLine, pszFileName);
        if (nRet < 0 || nRet == sizeof szInfo / sizeof CHAR) { return ; }
    }

    DbgPrint(szInfo);

    if (g_nDvrIopDbgCommandLineAssert)
    {
        DebugBreak();
    }
    else
    {
        lstrcatA(szInfo, "\nContinue? (Cancel to debug)");

        DWORD MsgId = DvrIopMessageBoxOtherThread(NULL,
                                                  szInfo,
                                                  "DVR IO Assert Failed",
                                                  MB_SYSTEMMODAL | MB_ICONHAND |
                                                  MB_YESNOCANCEL | MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExitW(0, L"Application terminated");
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore assertion continue execution */
              break;
        }
    }
} // DvrIopDbgAssert

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvriorecorder.cpp ===
//------------------------------------------------------------------------------
// File: dvrIORecorder.cpp
//
// Description: Implements the class CDVRRecorder
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

#if defined(DEBUG)
DWORD CDVRRecorder::m_dwNextClassInstanceId = 0;
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif


// ====== Constructor, destructor

CDVRRecorder::CDVRRecorder(IN CDVRRingBufferWriter*  pWriter,
                           IN  LPVOID                pWriterProvidedId,
                           OUT HRESULT*              phr)
    : m_pWriter(pWriter)
    , m_pWriterProvidedId(pWriterProvidedId)
    , m_cnsStartTime(MAXQWORD)  // Same default as ASF_RECORDER_NODE
    , m_cnsEndTime(MAXQWORD)  // Same default as ASF_RECORDER_NODE
    ,m_nRefCount(0)
    , m_pIWMHeaderInfo(NULL)
    , m_pSBERecordingAttributes(NULL)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::CDVRRecorder"

    DVRIO_TRACE_ENTER();

    ::InitializeCriticalSection(&m_csLock);

    DVR_ASSERT(pWriter, "");

    m_pWriter->AddRef();

    if (phr)
    {
        *phr = S_OK;
    }

    DVRIO_TRACE_LEAVE0();
    return;

} // CDVRRecorder::CDVRRecorder

CDVRRecorder::~CDVRRecorder()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::~CDVRRecorder"

    DVRIO_TRACE_ENTER();

    HRESULT hr;

    if (m_cnsStartTime != MAXQWORD && m_cnsEndTime == MAXQWORD)
    {
        // StopRecording at the current time instant

        hr = m_pWriter->StopRecording(m_pWriterProvidedId, 0, TRUE, TRUE);

        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "Recording had not been stopped; stopped at \"now\"; "
                        "ring buffer writer returned hr = 0x%x",
                        hr);
    }

    hr = m_pWriter->DeleteRecorder(m_pWriterProvidedId);

    m_pWriter->Release();

    if (m_pIWMHeaderInfo) {
        m_pIWMHeaderInfo -> Release () ;
    }

    delete m_pSBERecordingAttributes ;

    ::DeleteCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE0();

} // CDVRRecorder::~CDVRRecorder()


// ====== IUnknown

STDMETHODIMP CDVRRecorder::QueryInterface(IN  REFIID riid,
                                          OUT void   **ppv)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::QueryInterface"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!ppv || DvrIopIsBadWritePtr(ppv, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        hrRet = E_POINTER;
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast <IDVRRecorder *> (this) ;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRRecorder)
    {
        *ppv = static_cast <IDVRRecorder *> (this) ;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRIORecordingAttributes)
    {
        *ppv = static_cast <IDVRIORecordingAttributes *> (this) ;
        hrRet = S_OK;
    }
    else
    {
        *ppv = NULL;
        hrRet = E_NOINTERFACE;
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "no such interface");
    }

    if (SUCCEEDED(hrRet))
    {
        ((IUnknown *) (*ppv))->AddRef();
    }

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;

} // CDVRRecorder::QueryInterface


STDMETHODIMP_(ULONG) CDVRRecorder::AddRef()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::AddRef"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0,
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRecorder::AddRef


STDMETHODIMP_(ULONG) CDVRRecorder::Release()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::Release"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0,
              "m_nRefCount < 0 after InterlockedDecrement");

    if (nNewRef == 0)
    {
        // Must call DebugOut before the delete because the
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }


    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRecorder::Release


// ====== IDVRRecorder

STDMETHODIMP CDVRRecorder::StartRecording(IN OUT QWORD * pcnsStartTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::StartRecording"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ASSERT (pcnsStartTime) ;

    ::EnterCriticalSection(&m_csLock);

    __try {
        if (m_cnsStartTime != MAXQWORD)
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording started once before on this recorder instance");
            hrRet = E_UNEXPECTED;
        }
        else
        {
            if (m_pSBERecordingAttributes) {
                hrRet = m_pSBERecordingAttributes -> Flush () ;
                if (FAILED (hrRet)) {
                    __leave ;
                }
            }

            hrRet = m_pWriter->StartRecording(m_pWriterProvidedId, pcnsStartTime);

            if (SUCCEEDED(hrRet))
            {
                m_cnsStartTime = (* pcnsStartTime);
            }
        }
    }
    __finally {
        ::LeaveCriticalSection(&m_csLock);
    }

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;

} // CDVRRecorder::StartRecording

STDMETHODIMP CDVRRecorder::StopRecording(IN QWORD cnsStopTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::StopRecording"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    if (m_cnsStartTime == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording not started on this recorder instance");
        hrRet = E_UNEXPECTED;
    }
    else if (m_cnsEndTime != MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording has been stopped on this recorder instance");
        hrRet = E_UNEXPECTED;
    }
    else if (cnsStopTime <= m_cnsStartTime)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "stop time must be > start time");
        hrRet = E_INVALIDARG;
    }
    else
    {
        hrRet = m_pWriter->StopRecording(m_pWriterProvidedId, cnsStopTime, FALSE, FALSE);

        if (SUCCEEDED(hrRet))
        {
            m_cnsEndTime = cnsStopTime;
        }
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;

} // CDVRRecorder::StopRecording

STDMETHODIMP CDVRRecorder::CancelRecording()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::CancelRecording"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    if (m_cnsStartTime == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "recording not started on this recorder instance");
        hrRet = E_UNEXPECTED;
    }
    else if (m_cnsEndTime == m_cnsStartTime)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording has previously been cancelled on this recorder instance");
        hrRet = E_UNEXPECTED;
    }
    else
    {
        hrRet = m_pWriter->StopRecording(m_pWriterProvidedId, m_cnsStartTime, FALSE, FALSE);

        if (SUCCEEDED(hrRet))
        {
            m_cnsEndTime = m_cnsStartTime;
        }
        else if (hrRet == E_INVALIDARG)
        {
            hrRet = E_UNEXPECTED;
        }
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;

} // CDVRRecorder::CancelRecording

STDMETHODIMP CDVRRecorder::GetRecordingStatus(OUT HRESULT* phResult OPTIONAL,
                                              OUT BOOL* pbStarted OPTIONAL,
                                              OUT BOOL* pbStopped OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::GetRecordingStatus"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;
    BOOL pbSet;

    ::EnterCriticalSection(&m_csLock);

    hrRet = m_pWriter->GetRecordingStatus(m_pWriterProvidedId,
                                          phResult,
                                          m_cnsStartTime != m_cnsEndTime?  pbStarted : NULL,
                                          m_cnsStartTime != m_cnsEndTime?  pbStopped : NULL,
                                          &pbSet);


    if (SUCCEEDED(hrRet))
    {
        if (!pbSet && (pbStarted || pbStopped))
        {
            BOOL bStopped;

            if (m_cnsStartTime != m_cnsEndTime)
            {
                // Ring buffer writer did not set the values, so it must have
                // stopped writing. So the recording has been closed.
                bStopped = 1;
            }
            else
            {
                // Recording has not been started or has been cancelled
                bStopped = 0;
            }
            if (pbStarted)
            {
                *pbStarted = bStopped;
            }
            if (pbStopped)
            {
                *pbStopped = bStopped;
            }
        }
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;

} // CDVRRecorder::GetRecordingStatus

CSBERecordingAttributes *
CDVRRecorder::RecordingAttributes (
    )
{
    HRESULT hr ;
    LPWSTR  pszAttrFile ;

    if (!m_pSBERecordingAttributes) {
        if (IsReferenceRecording ()) {
            pszAttrFile = NULL ;

            hr = m_pWriter -> CreateAttributeFilename (
                        m_pWriterProvidedId,
                        & pszAttrFile
                        ) ;
            if (SUCCEEDED (hr)) {

                DVR_ASSERT (pszAttrFile, "") ;

                m_pSBERecordingAttributes = new CSBERecordingAttributesFile (
                                                    pszAttrFile,
                                                    & hr
                                                    ) ;
                if (!m_pSBERecordingAttributes) {
                    hr = E_OUTOFMEMORY ;
                    goto cleanup ;
                }
                else if (FAILED (hr)) {
                    goto cleanup ;
                }

                hr = m_pWriter -> SetAttributeFile (
                                    m_pWriterProvidedId,
                                    pszAttrFile) ;
            }

            cleanup :

            delete [] pszAttrFile ;

            if (FAILED (hr)) {
                delete m_pSBERecordingAttributes ;
                m_pSBERecordingAttributes = NULL ;
            }
        }
        else if (IsContentRecording ()) {
            DVR_ASSERT (m_pIWMHeaderInfo, "") ;
            m_pSBERecordingAttributes = new CSBERecordingAttributesWM (m_pIWMHeaderInfo) ;
        }
    }

    return m_pSBERecordingAttributes ;
}

STDMETHODIMP
CDVRRecorder::SetDVRIORecordingAttribute (
    IN  LPCWSTR                     pszAttributeName,
    IN  WORD                        wStreamNumber,
    IN  STREAMBUFFER_ATTR_DATATYPE  DataType,
    IN  BYTE *                      pbAttribute,
    IN  WORD                        wAttributeLength
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::SetDVRIORecordingAttribute"

    DVRIO_TRACE_ENTER();

    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> SetAttribute (
                    wStreamNumber,
                    pszAttributeName,
                    DataType,
                    pbAttribute,
                    wAttributeLength
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;
} // CDVRRecorder::SetDVRIORecordingAttribute

STDMETHODIMP
CDVRRecorder::GetDVRIORecordingAttributeCount (
    IN  WORD    wStreamNumber,
    OUT WORD *  pcAttributes
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::GetDVRIORecordingAttributeCount"

    DVRIO_TRACE_ENTER();

    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> GetAttributeCount (
                    wStreamNumber,
                    pcAttributes
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;
} // CDVRRecorder::GetDVRIORecordingAttributeCount

STDMETHODIMP
CDVRRecorder::GetDVRIORecordingAttributeByName (
    IN      LPCWSTR                         pszAttributeName,
    IN OUT  WORD *                          pwStreamNumber,
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::GetDVRIORecordingAttributeByName"

    DVRIO_TRACE_ENTER();

    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> GetAttributeByName (
                    pszAttributeName,
                    pwStreamNumber,
                    pDataType,
                    pbAttribute,
                    pcbLength
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;
} // CDVRRecorder::GetDVRIORecordingAttributeByName

STDMETHODIMP
CDVRRecorder::GetDVRIORecordingAttributeByIndex (
    IN      WORD                            wIndex,
    IN OUT  WORD *                          pwStreamNumber,
    OUT     WCHAR *                         pszAttributeName,
    IN OUT  WORD *                          pcchNameLength,
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::GetDVRIORecordingAttributeByIndex"

    DVRIO_TRACE_ENTER();

    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> GetAttributeByIndex (
                    wIndex,
                    pwStreamNumber,
                    pszAttributeName,
                    pcchNameLength,
                    pDataType,
                    pbAttribute,
                    pcbLength
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;
} // CDVRRecorder::GetDVRIORecordingAttributeByIndex

STDMETHODIMP CDVRRecorder::HasFileBeenClosed()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::HasFileBeenClosed"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    hrRet = m_pWriter->HasRecordingFileBeenClosed(m_pWriterProvidedId);

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);

    return hrRet;

} // CDVRRecorder::HasFileBeenClosed
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvriop.h ===
//------------------------------------------------------------------------------
// File: dvrIOp.h
//
// Description: Private DVR IO API definition
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#ifndef _DVR_IOP_H_
#define _DVR_IOP_H_

#if _MSC_VER > 1000
#pragma once
#endif

// Following are free'd (unless NULL) and set to NULL
void FreeSecurityDescriptors(IN OUT PACL&  rpACL,
                             IN OUT PSECURITY_DESCRIPTOR& rpSD
                            );

// ppSid[0] is assumed to be that of CREATOR_OWNER and is set/granted/denied
// (depending on what ownerAccessMode is) ownerAccessPermissions. The other
// otherAccessMode and otherAccessPermissions are used with the other SIDs
// in ppSids.
// We assume that object handle cannot be inherited.
DWORD CreateACL(IN  DWORD dwNumSids,
                IN  PSID* ppSids,
                IN  ACCESS_MODE ownerAccessMode,
                IN  DWORD ownerAccessPermissions,
                IN  ACCESS_MODE otherAccessMode,
                IN  DWORD otherAccessPermissions,
                OUT PACL&  rpACL,
                OUT PSECURITY_DESCRIPTOR& rpSD
               );

// Flags for IDVRStreamSink::CreateRecorder. These are ALSO declared
// in dvrds.idl (since they are public). Keep the two sets of definitions
// in sync.
#define DVR_RECORDING_FLAG_MULTI_FILE_RECORDING  (1)
#define DVR_RECORDING_FLAG_PERSISTENT_RECORDING  (2)


// Forward declarations
class CDVRFileCollection;
class CDVRRingBufferWriter;
class CDVRRecorder;
class CDVRReader;
class CDVRRecorderWriter ;

// Macros
#define NEXT_LIST_NODE(p) ((p)->Flink)
#define PREVIOUS_LIST_NODE(p) ((p)->Blink)
#define NULL_LIST_NODE_POINTERS(p) (p)->Flink = (p)->Blink = NULL;
#define LIST_NODE_POINTERS_NULL(p) ((p)->Flink == NULL || (p)->Blink == NULL)
#define LIST_NODE_POINTERS_BOTH_NULL(p) ((p)->Flink == NULL && (p)->Blink == NULL)

// ============ Debug functions

#if defined(DEBUG)

// Debug levels
typedef enum {
    DVRIO_DBG_LEVEL_INTERNAL_ERROR_LEVEL = 0,
    DVRIO_DBG_LEVEL_CLIENT_ERROR_LEVEL,
    DVRIO_DBG_LEVEL_INTERNAL_WARNING_LEVEL,
    DVRIO_DBG_LEVEL_TRACE_LEVEL,
    DVRIO_DBG_LEVEL_LAST_LEVEL
} DVRIO_DBG_LEVEL_CONSTANTS;

// Global variables
extern DWORD g_nDvrIopDbgCommandLineAssert;
extern DWORD g_nDvrIopDbgInDllEntryPoint;
extern DWORD g_nDvrIopDbgOutputLevel;
extern DWORD g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_LAST_LEVEL];

#define DvrIopIsBadStringPtr(p) (IsBadStringPtrW((p), MAXUINT_PTR))
#define DvrIopIsBadReadPtr(p, n) (IsBadReadPtr((p), (n)? (n) :sizeof(*(p))))
#define DvrIopIsBadVoidPtr(p) (IsBadReadPtr(((LPVOID) p), sizeof(LPVOID)))
#define DvrIopIsBadWritePtr(p, n) (IsBadWritePtr((p), (n)? (n) :sizeof(*(p))))

#define DVR_ASSERT(x, m) if (!(x)) DvrIopDbgAssert("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m, #x, __FILE__, __LINE__ DVRIO_DUMP_THIS_VALUE)
#define DVR_EXECUTE_ASSERT(x, m) DVR_ASSERT(x, m)

#if 0
#define DvrIopDebugOut0(level, m) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE)
#define DvrIopDebugOut1(level, m, a) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a)
#define DvrIopDebugOut2(level, m, a, b) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b)
#define DvrIopDebugOut3(level, m, a, b, c) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c)
#define DvrIopDebugOut4(level, m, a, b, c, d) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d)
#define DvrIopDebugOut5(level, m, a, b, c, d, e) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d, e)
#define DvrIopDebugOut6(level, m, a, b, c, d, e, f) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f)
#define DvrIopDebugOut7(level, m, a, b, c, d, e, f, g) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f, g)
#define DvrIopDebugOut8(level, m, a, b, c, d, e, f, g, h) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f, g, h)
#else
#define DvrIopDebugOut0(level, m)                           TRACE_0(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE)
#define DvrIopDebugOut1(level, m, a)                        TRACE_1(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a)
#define DvrIopDebugOut2(level, m, a, b)                     TRACE_2(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a, b)
#define DvrIopDebugOut3(level, m, a, b, c)                  TRACE_3(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a, b, c)
#define DvrIopDebugOut4(level, m, a, b, c, d)               TRACE_4(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a, b, c, d)
#define DvrIopDebugOut5(level, m, a, b, c, d, e)            TRACE_5(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a, b, c, d, e)
#define DvrIopDebugOut6(level, m, a, b, c, d, e, f)         TRACE_6(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f)
#define DvrIopDebugOut7(level, m, a, b, c, d, e, f, g)      TRACE_7(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f, g)
#define DvrIopDebugOut8(level, m, a, b, c, d, e, f, g, h)   TRACE_8(LOG_TRACE, level, "DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f, g, h)
#endif

#define DVRIO_TRACE_ENTER() DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, "Entering")
#define DVRIO_TRACE_LEAVE0() DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, "Leaving")
#define DVRIO_TRACE_LEAVE1(n) DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, "Leaving, returning %d", n)
#define DVRIO_TRACE_LEAVE1_HR(n) DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, "Leaving, returning hr=0x%x", n)
#define DVRIO_TRACE_LEAVE1_ERROR(n, dwError) DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, "Leaving, returning %d, last error=0x%x", n, dwError)

#define DVRIO_DBG_LEVEL_INTERNAL_ERROR              (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_ERROR_LEVEL])
#define DVRIO_DBG_LEVEL_CLIENT_ERROR                (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_CLIENT_ERROR_LEVEL])
#define DVRIO_DBG_LEVEL_INTERNAL_WARNING            (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_WARNING_LEVEL])
#define DVRIO_DBG_LEVEL_TRACE                       (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_TRACE_LEVEL])

void DvrIopDbgInit(IN HKEY hRegistryDVRIORootKey);

// Implemented in dvrReg.cpp
void DvrIopDbgInitFromRegistry(
    IN  HKEY  hRegistryKey,
    IN  DWORD dwNumValues,
    IN  const WCHAR* awszValueNames[],
    OUT DWORD* apdwVariables[])
    ;

void DvrIopDbgAssert(
    IN const PCHAR pszMsg,
    IN const PCHAR pszCondition,
    IN const PCHAR pszFileName,
    IN DWORD iLine,
    IN LPVOID pThis = NULL,
    IN DWORD  dwThisId = 0
    );

#else

#define DvrIopIsBadStringPtr(p)     (0)
#define DvrIopIsBadReadPtr(p, n)    (0)
#define DvrIopIsBadVoidPtr(p)   (0)
#define DvrIopIsBadWritePtr(p, n)   (0)

#define DVR_ASSERT(x, m)
#define DVR_EXECUTE_ASSERT(x, m) ((void) (x))
#define DvrIopDebugOut0(level, m)
#define DvrIopDebugOut1(level, m, a)
#define DvrIopDebugOut2(level, m, a, b)
#define DvrIopDebugOut3(level, m, a, b, c)
#define DvrIopDebugOut4(level, m, a, b, c, d)
#define DvrIopDebugOut5(level, m, a, b, c, d, e)
#define DvrIopDebugOut6(level, m, a, b, c, d, e, f)
#define DvrIopDebugOut7(level, m, a, b, c, d, e, f, g)
#define DvrIopDebugOut8(level, m, a, b, c, d, e, f, g, h)
#define DVRIO_TRACE_ENTER()
#define DVRIO_TRACE_LEAVE0()
#define DVRIO_TRACE_LEAVE1(n)
#define DVRIO_TRACE_LEAVE1_HR(n)
#define DVRIO_TRACE_LEAVE1_ERROR(n, dwError)

#endif // DEBUG

// a = b + c, but capped at MAXQWORD
_inline void SafeAdd(QWORD& a, QWORD b, QWORD c)
{
    a = b + c;
    if (a < b)
    {
        // Overflowed. Cap it at MAXQWORD
        a = MAXQWORD;
    }
}

const DWORD k_dwMilliSecondsToCNS = 1000 * 10;
const QWORD k_qwSecondsToCNS = (QWORD) 1000 * k_dwMilliSecondsToCNS;

static const WCHAR* g_kwszDVRIndexGranularity = L"DVR Index Granularity";
const  DWORD g_kmsDVRDefaultIndexGranularity = 1000;        // 1 second

static const WCHAR* g_kwszDVRFileVersion = L"DVR File Version";

// Registry Constants
const HKEY g_hDefaultRegistryHive = HKEY_CURRENT_USER;
static const WCHAR* kwszRegDvrKey     = L"Software\\Microsoft\\DVR";
static const WCHAR* kwszRegDvrIoReaderKey   = L"IO\\Reader";
static const WCHAR* kwszRegDvrIoWriterKey   = L"IO\\Writer";

#if defined(DEBUG)

static const WCHAR* kwszRegDvrIoDebugKey    = L"IO\\Debug";

#endif // if defined(DEBUG)

// Values - writer
static const WCHAR* kwszRegDataDirectoryValue = L"DVRDirectory";

static const WCHAR* kwszRegDeleteRingBufferFilesValue = L"DeleteRingBufferFiles";
const DWORD kdwRegDeleteRingBufferFilesDefault = 1;

static const WCHAR* kwszRegCreateValidationFilesValue = L"CreateValidationFiles";
const DWORD kdwRegCreateValidationFilesDefault = 0;

static const WCHAR* kwszRegSyncToleranceValue = L"SyncTolerance";
const DWORD kdwRegSyncToleranceDefault = 0;

static const WCHAR* kwszRegFirstTemporaryBackingFileNameValue = L"FirstTemporaryBackingFileName";
static const WCHAR* kwszRegRingBufferFileNameValue = L"RingBufferFileName";

#if defined(DVRIO_FABRICATE_SIDS)
static const WCHAR* kwszRegFabricateSidsValue = L"FabricateSids";
const DWORD kdwRegFabricateSidsDefault = 0;
#endif // #if defined(DVRIO_FABRICATE_SIDS)

#if defined(DVR_UNOFFICIAL_BUILD)

static const WCHAR* kwszRegEnforceIncreasingTimestampsValue = L"EnforceIncreasingTimestamps";
const DWORD kdwRegEnforceIncreasingTimestampsDefault = 1;

#endif // defined(DVR_UNOFFICIAL_BUILD)

// Values - reader

static const WCHAR* kwszRegCloseReaderFilesAfterConsecutiveReadsValue = L"CloseReaderFilesAfterConsecutiveReads";
const DWORD kdwRegCloseReaderFilesAfterConsecutiveReadsDefault = 25;    // 25 is arbitrary

// Global private functions
DWORD GetRegDWORD(IN HKEY hKey, IN LPCWSTR pwszValueName, IN DWORD dwDefaultValue);

HRESULT GetRegString(IN HKEY hKey,
                     IN LPCWSTR pwszValueName,
                     OUT LPWSTR pwszValue OPTIONAL,
                     IN OUT DWORD* pdwSize);

// We define this here for methods inlined in this file
#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif


// Doubly-linked shared list macros. Adapted from ntrtl.h
// The "shared" list is maintained in a shared memory data
// section. The pool of list nodes is fixed and is allocated
// as an array. Pointers to the next node are indices into
// the array.

// For our implementation, it's enough to have up to 64K - 2
// list entries
typedef WORD        SharedListPointer;

#define SHARED_LIST_NULL_POINTER    ((SharedListPointer) ((1 << 8*sizeof(SharedListPointer)) - 1))


typedef struct _SHARED_LIST_ENTRY {
   SharedListPointer Flink;
   SharedListPointer Blink;
   SharedListPointer Index;
} SHARED_LIST_ENTRY, *PSHARED_LIST_ENTRY;

#define InitializeSharedListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead)->Index = SHARED_LIST_NULL_POINTER)

#define IsSharedListEmpty(ListHead) \
    ((ListHead)->Flink == SHARED_LIST_NULL_POINTER && (ListHead)->Blink == SHARED_LIST_NULL_POINTER)

#define RemoveEntrySharedList(RealListHead, ListBase, Entry) {\
    SharedListPointer _EX_Blink;\
    SharedListPointer _EX_Flink;\
    PSHARED_LIST_ENTRY _EX_RealListHead;\
    _EX_RealListHead = (RealListHead);\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    if (_EX_Blink == SHARED_LIST_NULL_POINTER) {\
        _EX_RealListHead->Flink = _EX_Flink;\
    } else {\
        ListBase[_EX_Blink].leListEntry.Flink = _EX_Flink;\
    }\
    if (_EX_Flink == SHARED_LIST_NULL_POINTER) {\
        _EX_RealListHead->Blink = _EX_Blink;\
    } else {\
        ListBase[_EX_Flink].leListEntry.Blink = _EX_Blink;\
    }\
    }

#define RemoveHeadSharedList(RealListHead, ListBase, ListHead) \
    &ListBase[(ListHead)->Flink].leListEntry;\
    {RemoveEntrySharedList(RealListHead, ListBase, &ListBase[(ListHead)->Flink].leListEntry);}

#define RemoveTailSharedList(RealListHead, ListBase, ListHead) \
    &ListBase[(ListHead)->Blink].leListEntry;\
    {RemoveEntrySharedList(RealListHead, ListBase, &ListBase[(ListHead)->Blink].leListEntry);}

#define InsertTailSharedList(RealListHead, ListBase, ListHead, Entry) {\
    SharedListPointer _EX_Blink;\
    PSHARED_LIST_ENTRY _EX_RealListHead;\
    PSHARED_LIST_ENTRY _EX_ListHead;\
    _EX_RealListHead = (RealListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead->Index;\
    (Entry)->Blink = _EX_Blink;\
    if (_EX_Blink == SHARED_LIST_NULL_POINTER) {\
        _EX_RealListHead->Flink = (Entry)->Index;\
    } else {\
        ListBase[_EX_Blink].leListEntry.Flink = (Entry)->Index;\
    }\
    _EX_ListHead->Blink = (Entry)->Index;\
    }

#define InsertHeadSharedList(RealListHead, ListBase, ListHead, Entry) {\
    SharedListPointer _EX_Flink;\
    PSHARED_LIST_ENTRY _EX_RealListHead;\
    PSHARED_LIST_ENTRY _EX_ListHead;\
    _EX_RealListHead = (RealListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead->Index;\
    if (_EX_Flink == SHARED_LIST_NULL_POINTER) {\
        _EX_RealListHead->Blink = (Entry)->Index;\
    } else {\
        ListBase[_EX_Flink].leListEntry.Blink = (Entry)->Index;\
    }\
    _EX_ListHead->Flink = (Entry)->Index;\
    }

#define NEXT_SHARED_LIST_NODE(RealListHead, ListBase, p) (((p)->Flink == SHARED_LIST_NULL_POINTER)? RealListHead : &ListBase[(p)->Flink].leListEntry)
#define PREVIOUS_SHARED_LIST_NODE(RealListHead, ListBase, p) (((p)->Blink == SHARED_LIST_NULL_POINTER)? RealListHead : &ListBase[(p)->Blink].leListEntry)
#define NULL_SHARED_LIST_NODE_POINTERS(p) (p)->Flink = (p)->Blink = SHARED_LIST_NULL_POINTER;

//  ============================================================================
//  ============================================================================

class CDVRRecorderWriter :
    public IDVRRecorderWriter,
    public IWMStatusCallback,
    public IDVRIORecordingAttributes
{
    LONG                        m_cRef ;

    CAsyncIo *                  m_pAsyncIo ;

    DWORD                       m_dwIoSize ;
    DWORD                       m_dwBufferCount ;
    DWORD                       m_dwAlignment ;
    DWORD                       m_dwFileGrowthQuantum ;

    DWORD                       m_dwIndexStreamId ;
    DWORD                       m_msIndexGranularity ;

    IWMWriter *                 m_pIWMWriter ;
    IWMWriterAdvanced3 *        m_pIWMWriterAdvanced ;
    IWMHeaderInfo *             m_pIWMHeaderInfo ;
    IDVRFileSink *              m_pIDVRFileSink ;
    IWMWriterSink *             m_pIWMWriterSink ;
    IWMWriterFileSink *         m_pIWMWriterFileSink ;

    CSBERecordingAttributes *   m_pSBERecordingAttributes ;

    BOOL                        m_fWritingState ;

    CRITICAL_SECTION            m_crt ;

    void Lock_ ()           { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()         { ::LeaveCriticalSection (& m_crt) ; }

    HRESULT
    InitUnbufferedIo_ (
        IN  BOOL    fUnbuffered
        ) ;

    HRESULT
    InitDVRSink_ (
        IN  HKEY                hkeyRoot,
        IN  CPVRIOCounters *    pPVRIOCounters
        ) ;

    HRESULT
    InitWM_ (
        IN  IWMProfile *
        ) ;

    HRESULT
    ReleaseAll_ (
        ) ;

    public :

        CDVRRecorderWriter (
            IN  CPVRIOCounters *    pPVRIOCounters,
            IN  LPCWSTR             pszRecordingName,
            IN  IWMProfile *        pProfile,
            IN  DWORD               dwIndexStreamId,
            IN  DWORD               msIndexGranularity,
            IN  BOOL                fUnbufferedIo,
            IN  DWORD               dwIoSize,
            IN  DWORD               dwBufferCount,
            IN  DWORD               dwAlignment,
            IN  DWORD               dwFileGrowthQuantum,
            IN  HKEY                hkeyRoot,
            OUT HRESULT *           phr
            ) ;

        virtual
        ~CDVRRecorderWriter (
            ) ;

        //  --------------------------------------------------------------------
        //  IUnknown

        STDMETHODIMP
        QueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        STDMETHODIMP_(ULONG)
        AddRef(
            ) ;

        STDMETHODIMP_(ULONG)
        Release(
            ) ;

        //  --------------------------------------------------------------------
        //  IDVRRecorderWriter

        STDMETHODIMP
        WriteSample (
            IN  WORD            wStreamNum,
            IN  QWORD           cnsStreamTime,
            IN  DWORD           dwFlags,
            IN  INSSBuffer *    pSample );

        STDMETHODIMP
        Close (
            ) ;

        //  --------------------------------------------------------------------
        //  IWMStatsCallback

        STDMETHODIMP
        OnStatus (
            IN  WMT_STATUS          Status,
            IN  HRESULT             hr,
            IN  WMT_ATTR_DATATYPE   dwType,
            IN  BYTE *              pbValue,
            IN  void *              pvContext
            ) ;

        //  --------------------------------------------------------------------
        //  IDVRRecordingAttribute

        STDMETHODIMP
        SetDVRIORecordingAttribute (
            IN  LPCWSTR                     pszAttributeName,
            IN  WORD                        wStreamNumber,
            IN  STREAMBUFFER_ATTR_DATATYPE  DataType,
            IN  BYTE *                      pbAttribute,
            IN  WORD                        wAttributeLength
            ) ;

        STDMETHODIMP
        GetDVRIORecordingAttributeCount (
            IN  WORD    wStreamNumber,
            OUT WORD *  pcAttributes
            ) ;

        STDMETHODIMP
        GetDVRIORecordingAttributeByName (
            IN      LPCWSTR                         pszAttributeName,
            IN OUT  WORD *                          pwStreamNumber,
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) ;

        STDMETHODIMP
        GetDVRIORecordingAttributeByIndex (
            IN      WORD                            wIndex,
            IN OUT  WORD *                          pwStreamNumber,
            OUT     WCHAR *                         pszAttributeName,
            IN OUT  WORD *                          pcchNameLength,
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) ;
} ;

//  ============================================================================
//  ============================================================================

// The DVR file collection object, aka the "ring buffer"

class CDVRFileCollection {

public:
    typedef DWORD       DVRIOP_FILE_ID;
    enum {DVRIOP_INVALID_FILE_ID = 0};

private:

    // The maximum number of files that this file collection can currently have
    DWORD                           m_dwMaxFiles;

    // When the number of file nodes in the file collection should be increased,
    // the free list grows by m_dwGrowBy file nodes. If this value is 0, the
    // the free list does not grow.
    DWORD                           m_dwGrowBy;

    typedef DWORD                   READER_BITMASK;

    static const LPCWSTR            m_kwszSharedMutexPrefix;
    static const LPCWSTR            m_kwszSharedEventPrefix;

public:
    enum {MAX_READERS = 8 * sizeof(READER_BITMASK)};

    static const SharedListPointer  m_kMaxFilesLimit;

    static const GUID               m_guidV1;
    static const GUID               m_guidV2;
    static const GUID               m_guidV3;
    static const GUID               m_guidV4 ;
    static const GUID               m_guidV5 ;

    static const DWORD              m_dwInvalidReaderIndex;

    // The name of the subdirectory of the DVR directory
    // that holds the temporary files
    static const LPCWSTR            m_kwszDVRTempDirectory;

    // Every reader and writer creates one of these and passes it in
    // to the member functions of CDVRFileCollection to identify itself
    struct CClientInfo
    {
        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        // All members of this struct except dwReaderIndex must
        // be initialized before the file collection object's
        // constructor is called.
        //
        // None of the members should be changed after being set the
        // first time.

        // Note that a client can be both a reader and a writer. This
        // happens in only one case: when an ASF single file recording
        // is opened. The reader creates a file collection object and
        // also pretends to be its writer. In this case, the client
        // should set up two CClinetInfo objects and use the appropriate
        // one depending on whether it is acting as a reader or as a writer.
        BOOL        bAmWriter;     // Is a writer
        DWORD       dwReaderIndex; // Index of reader if it is a reader.
        DWORD       dwNumSids;     // Number of elements in ppSids
        PSID*       ppSids;        // SIDs to which cooperative access is to
                                   // be given for the transient shared kernel
                                   // objects created by this client. (Transient
                                   // ==> all non-file objects such as mutexes,
                                   // events and memory mapped section.)

        CClientInfo(BOOL bAmWriterParam)
            : ppSids(NULL)
            , dwNumSids(0)
            , bAmWriter(bAmWriterParam)
            , dwReaderIndex(CDVRFileCollection::m_dwInvalidReaderIndex)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CClientInfo::CClientInfo"
        }

        void DeleteSids()
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CClientInfo::DeleteSids"

            if (ppSids)
            {
                DVR_ASSERT(dwNumSids, "ppSids is not NULL");
                for (DWORD i = 0; i < dwNumSids; i++)
                {
                    delete [] (ppSids[i]);
                }
                delete [] ppSids;
                ppSids = NULL;
                dwNumSids = 0;
            }
            else
            {
                DVR_ASSERT(dwNumSids == 0, "");
            }
        }

        ~CClientInfo()
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CClientInfo::~CClientInfo"

            DeleteSids();
        }

        void SetReaderIndex(DWORD dwReaderIndexParam)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CClientInfo::SetReaderIndex"

            DVR_ASSERT(!bAmWriter, "");
            DVR_ASSERT(dwReaderIndexParam <= MAX_READERS, "");

            dwReaderIndex = dwReaderIndexParam;
        }

        // the following function validates the Sids and copies them
        // If bGenerateCreatorOwnerSID is zero, the SIDs are copied. If it is
        // non-zero, the SID for CREATOR_OWNER is generated and stored and
        // the SIDs in ppSidsParam are then copied.
        HRESULT SetSids(IN DWORD dwNumSidsParam, IN PSID* ppSidsParam, IN BOOL bGenerateCreatorOwnerSID = 0)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CClientInfo::SetSids"

            if (dwNumSidsParam == 0 && ppSidsParam)
            {
                return E_INVALIDARG;
            }
            if (dwNumSidsParam > 0 && ppSidsParam == NULL)
            {
                return E_INVALIDARG;
            }

            DVR_ASSERT(ppSids == NULL, "Call DeleteSids() first");
            DVR_ASSERT(dwNumSids == 0, "Call DeleteSids() first");

            if (dwNumSidsParam == 0)
            {
                // Assuming above two asserts hold:
                return S_OK;
            }

            if (::IsBadReadPtr(ppSidsParam, dwNumSidsParam*sizeof(PSID)))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "dwNumSidsParam = %u, IsBadReadPtr(ppSidsParam) is true",
                                dwNumSidsParam);

                return E_INVALIDARG;
            }
            ppSids = new PSID[dwNumSidsParam + (bGenerateCreatorOwnerSID? 1 : 0)];
            if (ppSids == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - ppSids - PSID[%u]",
                                dwNumSidsParam);

                return E_OUTOFMEMORY;
            }

            HRESULT hrRet;
            DWORD dwLastError;

            __try
            {
                dwNumSids = dwNumSidsParam + (bGenerateCreatorOwnerSID? 1 : 0);

                ::ZeroMemory(ppSids, dwNumSids*sizeof(PSID));

                if (bGenerateCreatorOwnerSID)
                {
                    PSID    pOwnerSID;
                    SID_IDENTIFIER_AUTHORITY SIDAuthCreator = SECURITY_CREATOR_SID_AUTHORITY;

                    // Create owner SID
                    if (!::AllocateAndInitializeSid(&SIDAuthCreator, 1,
                                                    SECURITY_CREATOR_OWNER_RID,
                                                    0, 0, 0, 0, 0, 0, 0,
                                                    &pOwnerSID))
                    {
                        dwLastError = GetLastError();
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "::AllocateAndInitializeSid of creator SID failed; last error = 0x%x",
                                        dwLastError);
                        hrRet = HRESULT_FROM_WIN32(dwLastError);
                        __leave;
                    }
                    DWORD dwSidLength = ::GetLengthSid(pOwnerSID);

                    ppSids[0] = new BYTE[dwSidLength];
                    if (ppSids[0] == NULL)
                    {
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "alloc via new failed - ppSids[0] - BYTE[%u]",
                                        dwSidLength);

                        hrRet = E_OUTOFMEMORY;
                        FreeSid(pOwnerSID);
                        __leave;
                    }
                    if (!::CopySid(dwSidLength, ppSids[0], pOwnerSID))
                    {
                        dwLastError = ::GetLastError();
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                        "CopySid failed on pOwnerSID, last error = 0x%x",
                                        dwLastError);
                        hrRet = HRESULT_FROM_WIN32(dwLastError);
                        FreeSid(pOwnerSID);
                        __leave;
                    }
                    FreeSid(pOwnerSID);
                }
                DWORD i, j;
                for (i = 0, j = (bGenerateCreatorOwnerSID? 1 : 0); i < dwNumSidsParam; i++, j++)
                {
                    if (!ppSidsParam[i] || !::IsValidSid(ppSidsParam[i]))
                    {
                        dwLastError = ::GetLastError();

                        if (!ppSidsParam[i])
                        {
                            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                            "dwNumSidsParam = %u, ppSidsParam[%u] is NULL",
                                            dwNumSidsParam, i);
                            hrRet = E_INVALIDARG;
                            __leave;
                        }
                        else
                        {
                            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                            "dwNumSidsParam = %u, ppSidsParam[%u] is invalid, dwLastError = 0x%x",
                                            dwNumSidsParam, i, dwLastError);
                            hrRet = HRESULT_FROM_WIN32(dwLastError);
                            __leave;
                        }
                    }

                    DWORD dwSidLength = ::GetLengthSid(ppSidsParam[i]);

                    ppSids[j] = new BYTE[dwSidLength];
                    if (ppSids[j] == NULL)
                    {
                        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "alloc via new failed - ppSids[%u] - BYTE[%u]",
                                        j, dwSidLength);

                        hrRet = E_OUTOFMEMORY;
                        __leave;
                    }
                    if (!::CopySid(dwSidLength, ppSids[j], ppSidsParam[i]))
                    {
                        dwLastError = ::GetLastError();
                        DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                        "CopySid failed on sid ppSidsParam[%u], last error = 0x%x",
                                        i, dwLastError);
                        hrRet = HRESULT_FROM_WIN32(dwLastError);
                        __leave;
                    }
                }
                hrRet = S_OK;
            }
            __finally
            {
                if (FAILED(hrRet))
                {
                    DeleteSids();
                }
            }
            return hrRet;
        } // CClientInfo::SetSIDs()

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };

private:
    struct CSharedData {

        struct CFileInfo
        {
            #if defined(DEBUG)
            #undef DVRIO_DUMP_THIS_FORMAT_STR
            #define DVRIO_DUMP_THIS_FORMAT_STR ""
            #undef DVRIO_DUMP_THIS_VALUE
            #define DVRIO_DUMP_THIS_VALUE
            #endif

            QWORD               cnsStartTime;
            QWORD               cnsEndTime;

            // Note: the following field is SIGNED. This means that the
            // first sample written to any ASF file in the ring buffer
            // must have a time (relative to that start of the file) of
            // at most MAXLONGLONG
            LONGLONG            cnsFirstSampleTimeOffsetFromStartOfFile;

            DVRIOP_FILE_ID      nFileId;
            BOOL                bPermanentFile;

            // bWithinExtent is non zero iff the file is in the ring
            // buffer's extent. The file node can be removed from m_leFileList iff
            // !bWithinExtent && bmOpenByReader == 0; this is regardless
            // of whether the file is temporary or permanent.
            //
            // When bWithinExtent == 0, the disk file can be deleted iff
            // !bPermanentFile && bmOpenByReader == 0.
            //
            // Note that we do not maintain a writer ref count. Because
            // of the conditions imposed on the minimum value of
            // the number of temp files that may be supplied when
            // the ring buffer writer is created and because of the design
            // of how the ring buffer writer opens and closes files,
            // any file opened by the writer will have bWithinExtent set
            // to a non-zero value. The exception to this is that the writer may
            // call SetFileTimes with the start and end times equal for
            // a file that it has open. We will set bWithinExtent to 0
            // though the writer has the file open. The writer will close
            // the file soon after the call to SetFileTimes, however.

            // Note: The enforcement of:
            //  Max stream delta time < (dwNumberOfFiles-3)*cnsTimeExtentOfEachFile
            // by the ring buffer writer is what lets us get away with not
            // maintaining a writer ref count. The writer will not have more
            // than dwMinNumberOfTempFiles-1 files open (dwMinNumberOfTempFiles-3
            // plus one that it is opening and one that it is closing). So any file
            // the writer has open will have bWithinExtent set to a non-zero value.

            typedef enum  {
                // DVRIO_EXTENT_NOT_IN_RING_BUFFER should never change from 0
                // We often use the test if (bWithinExtent) to determine if the
                // file is in the ring buffer.
                DVRIO_EXTENT_NOT_IN_RING_BUFFER = 0,
                DVRIO_EXTENT_IN_RING_BUFFER = 1,
                DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER = 2,
                DVRIO_EXTENT_LAST = DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER
            } DVRIO_EXTENT;

            DVRIO_EXTENT        bWithinExtent;

            // Bit i of the mask is set iff reader i has this file open. Note that
            // we have only 1 bit (not a ref count) per reader, so readers should
            // ask that a file be opened only if they don't have it open and closed
            // only if they don't need it any more.
            //
            // This member is updated only if m_dwMutexSuffix != 0 at the time the reader
            // opens the file collection file; see comments for m_dwMutexSuffix below.
            READER_BITMASK      bmOpenByReader;

            WCHAR               wszFileName[MAX_PATH];

            enum {
                // If OpenFromFileCollectionDirectory is set, the file name is not fully
                // qualified. It is expected to be found in the directory that the file
                // collection file is in (i.e., in m_pwszRingBufferFilePath)
                OpenFromFileCollectionDirectory = 1,

                // If FileDeleted is set, the file has been deleted. This is set
                // only for temp files whose bWithinExtent is DVRIO_EXTENT_NOT_IN_RING_BUFFER.
                FileDeleted                     = 2,

                // If DoNotDeleteFile is set, the file is not deleted. This flags is
                // set only on temporary files.
                DoNotDeleteFile                 = 4
            };
            WORD                wFileFlags;

            // Pointers to the next and previous nodes in the file collection
            // Note: Member name is used in the SHARED_LIST macros above
            SHARED_LIST_ENTRY   leListEntry;

            // Methods

            BOOL IsFlagSet(WORD f)
            {
                return (f & wFileFlags)? 1 : 0;
            }

            void SetFlags(WORD f)
            {
                wFileFlags |= f;
            }

            void ClearFlags(WORD f)
            {
                wFileFlags &= ~f;
            }

            HRESULT Initialize(IN LPCWSTR           pwszFileNameParam,
                               IN BOOL              bOpenFromFileCollectionDirectoryParam,
                               IN QWORD             cnsStartTimeParam,
                               IN QWORD             cnsEndTimeParam,
                               IN LONGLONG          cnsFirstSampleTimeOffsetFromStartOfFileParam,
                               IN BOOL              bPermanentFileParam,
                               IN BOOL              bDeleteTemporaryFile,
                               IN DVRIOP_FILE_ID    nFileIdParam,
                               IN DVRIO_EXTENT      nWithinExtentParam)
            {
                NULL_SHARED_LIST_NODE_POINTERS(&leListEntry);
                if (!pwszFileNameParam)
                {
                    return E_POINTER;
                }
                if (wcslen(pwszFileNameParam) >= sizeof(wszFileName)/sizeof(WCHAR))
                {
                    return E_OUTOFMEMORY;
                }
                wcscpy(wszFileName, pwszFileNameParam);
                wFileFlags = bOpenFromFileCollectionDirectoryParam? OpenFromFileCollectionDirectory : 0;
                if (!bDeleteTemporaryFile && !bPermanentFileParam)
                {
                    SetFlags(DoNotDeleteFile);
                }
                cnsStartTime = cnsStartTimeParam;
                cnsEndTime = cnsEndTimeParam;
                cnsFirstSampleTimeOffsetFromStartOfFile = cnsFirstSampleTimeOffsetFromStartOfFileParam;
                nFileId = nFileIdParam;
                bmOpenByReader = 0;
                bPermanentFile = bPermanentFileParam;
                bWithinExtent = nWithinExtentParam;
                return S_OK;
            };
            void Cleanup()
            {
                wszFileName[0] = L'\0';
            };

            #if defined(DEBUG)
            #undef DVRIO_DUMP_THIS_FORMAT_STR
            #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
            #undef DVRIO_DUMP_THIS_VALUE
            #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
            #endif

        }; // CFileInfo

        // ======== Data members

        // Version id
        GUID                    m_guidVersion;

        // The file collection has a time extent. Files in the collection
        // are either within the extent or outside it. Files nodes outside the
        // extent are candidates for removal from the collection; usually
        // they are in the collection only because they have (reader) clients.
        // These files are removed as soon as they have no clients. (As we
        // shall see later, there could be files whose start time = end time
        // = T and T is within the collection's extent; however, these nodes
        // are always considered "outside" the collection and are marked
        // for removal. The exception to this is if T is MAXQWORD; it
        // is legit to set start time = end time = MAXQWORD)

        // Each file in the collection is a "temp" or a "permanent" file. Permanent
        // files are not deleted. A temp file is deleted when its extent falls
        // outside the collection's extent and it has no clients, i.e., when the
        // file node is removed from the collection. There are two points to note
        // here: 1. Occasionally a temp file cannot be deleted even if its extent
        // is outside the collection's extent and it has no clients because
        // DeleteFile fails; in this case the temp file is kept in the collection
        // till DeleteFile succeeds. 2. The collection's extent is actually
        // determined by the number of temp files in it: the collection's extent
        // can have at most m_dwMaxTempFiles temp files (but any number of
        // permanent files).
        //
        // A file is said to be INVALID if its extent falls outside the
        // collection.
        DWORD                   m_dwMinTempFiles;
        DWORD                   m_dwMaxTempFiles;

        // The time extent of the ring buffer is demarcated by its start
        // and the end times, m_cnsStartTime and m_cnsEndTime.
        //
        // m_cnsLastStreamTime has the last time for which there is data (for a
        // live source, this variable is continually updated by the writer client
        // with each write), and, from a client's viewpoint the actual time
        // extent is through m_cnsLastStreamTime. m_cnsEndTime is the max time
        // extent for the last file in the ring buffer. In practice, m_cnsEndTime
        // has little utility, but it's low cost keeping it around. For a source
        // that is not live, m_cnsEndTime == m_cnsLastStreamTime.
        //
        // All these times are set to 0 in the constructor. The start and end
        // times are updated by AddFile() and SetFileTimes(). A pointer to
        // m_cnsLastStreamTime is handed back to the client in the constructor
        // and the client is expected to update it. Reader clients reading
        // non-live files set it once for all at the start; writer clients
        // MUST update it continually with each write, and reader clients that
        // read live files can set it to MAXQWORD and update it as
        // and when they desire - this works only because in that case the
        // file collection object is used exclusively by the reader - it is not
        // shared. NONE of the methods in this class update m_cnsLastStreamTime
        // and none of them check whether m_cnsLastStreamTime lies within
        // the m_cnsStartTime - m_cnsEndTime range when the latter two members
        // are updated. It is the client's responsibility to do things "right"
        //
        // Our implementation allows time "holes" in the file collection, i.e.,
        // intervals of time that are not backed by any file. This feature is
        // necessary to support recordings that start in the future; however,
        // holes between m_cnsStartTime and m_cnsLastStreamTime could confound
        // the reader because if the reader assumes that file times are contiguous,
        // e.g., a Seek to a time in the hole will fail and the reader has no
        // way to find the first time after the hole except by polling all times.
        // So the writer should be careful of never creating time holes between
        // m_cnsStartTime and m_cnsLastStreamTime. The reader is provided with
        // a function, GetFirstValidTimeAfter() to skip over holes.
        //
        QWORD                   m_cnsStartTime;
        QWORD                   m_cnsEndTime;
        QWORD                   m_cnsLastStreamTime;

        // The current number of clients. This is useful for file collections that
        // have temporary files: when the last client releases the file collection, it
        // deletes all temporary files (including those within the ring buffer's
        // extent).
        //
        // This member is updated by a reader when it opens/closes the collection but only
        // if m_dwMutexSuffix is not 0 at the time the file collection is opened/closed.
        // Once m_dwMutexSuffix is set to 0, the file collection has been fully written
        // and can be freely accessed. (m_dwMutexSuffix will always be non-zero for
        // file collections that are still open by the writer and for all file collections
        // that have temporary files regardless of whether the writer has the file
        // collection open or not.)
        //
        // Although this member is not useful when the file collection has only permanent
        // files (multi-file recordings), it is always updated by every reader that opens
        // or closes any file collection whose m_dwMutexSuffix is not 0. The
        // main reason we do this is that the writer client can call SetNumTempFiles
        // to change the number of temp files (from 0 to a non-zero value) after the
        // file collection has been created and a reader has opened it. (This will not
        // happen for our scenarios, but we may as well handle it.)
        //
        DWORD                   m_dwNumClients;

        // The named mutex used to protect this shared memory section is derived
        // by suffixing m_dwMutexSuffix to m_kwszSharedMutexPrefix.
        //
        // If this member is 0, the shared section has been fully written to and does
        // not need to be protected by a mutex. This will happen only for multi-file recordings.
        //
        // Note that readers can write to the shared section, but this is true only
        // for file collections that have temporary files. (In this case files can
        // fall out of the collection when readers close files and the file node
        // may have to be moved to the free list and the extent of the ring buffer
        // updated.)
        //
        // This member is set to 0 when the writer completes IF there are no temporary
        // files in the collection at that time (as will be the case for multi-file
        // recordings; at that time m_dwNumClients is also set to 0 and the bmOpenByReader
        // of all file nodes is reset to 0).
        //
        // If there are temporary files when the writer completes, this member is never
        // reset to 0. Readers that open the file collection file try to open the shared
        // mutex (not create it) using this suffix. If that fails, they bail. If it
        // succeeds, they check if m_dwNumClients is 0 and if it is, they bail. (The temporary
        // files are deleted when m_dwNumClients is set to 0, so opening a shared section that
        // has m_dwNumClients = 0 means that the temp files are no longer around.)
        //
        // We could have chosen to set this member to 0 only when the last client was closed.
        // However, that opens the possiblity that this member is not reset if the last
        // reader terminates ungracefully. We don't want that for multi-file recordings
        // because then all subsequent readers will try to open this mutex - the member
        // would never be cleared..(If the writer of multi-file recordings dies without
        // properly closing the recording, this member will not be set to 0; we try to
        // handle this as best as we can when a reader opens the file subsequently.)
        //
        // Clearly that this member is doing double duty: if non-zero it determines the
        // mutex name, and, if 0, it signals that no mutex be used. An alternative is to
        // derive the mutex name from the file name (in the same way the shared memory map's
        // name is derived from the file name) and maintain a flag that tells us whether to open
        // the mutex or not.
        //
        // There are cases when this member has a non-zero value but m_hSharedMutex is
        // NULL. In these cases the NoSharedMutex flag is set in m_dwFlags. See the comments
        // near the definition of NoSharedMutex below.
        //
        DWORD                   m_dwMutexSuffix;

        // Shared data section has inconsistent data. This member is incremented by functions
        // that write to the shared section and it is decremented when they finish. If a process is
        // killed while it is writing data, this member will be non-zero. (This assumes that instructions
        // bracketed by the Increment/Decrement are not reordered by the compiler.)
        //
        // An alternative approach to determining if data is inconsistent would be to change the calls
        // to increment/decrement to lock/unlock a shared mutex and if anyone locks an abandoned mutex,
        // the data is inconsistent. This member could be set at that time to 1 and never changed.
        //
        // Updates of the following members are "protected":
        //  - any of the list insert/remove operations,
        //  - changes to any of the members of a CFileInfo node while the node is in m_leFileList
        //    (The exception is bmOpenByReader, which is updated in CloseReaderFile and GetFileAtTime
        //    without incrementing/decrementing m_nDataInconsistent; see comments in those two fns)
        //  - m_dwMinTempFiles, m_dwMaxTempFiles, m_cnsStartTime, m_cnsLastStreamTime and m_cnsEndTime
        //
        // Changes to the Readers[] member are not protected. All other members are
        //  - changed in the constructor (so don't need to be protected) or
        //  - are changed alone (without changing other members of the shared section). In these cases,
        //    we assume that the changes are atomic and use Interlocked fns to the extent possible
        //    to ensure atomicity. Examples are: m_dwNumClients, m_dwMutexSuffix, m_dwWriterPid,
        //    m_nWriterHasBeenClosed, and m_dwSharedMemoryMapCounter.
        //
        // Note that this member is relevant only as long as there are writers of the shared data,
        // i.e. only as long as m_dwMutexSuffix is not 0. This member is always changed using
        // Interlocked functions
        //
        // @@@@ The code does not check whether this counter overflows.
        LONG                    m_nDataInconsistent;

        // Process id of the process that writes the collection file, Set to 0 when
        // the writer has completed, i.e., when writer releases its last reference on
        // the file collection object. m_nWriterHasBeenClosed would have been set to
        // a non-zero value before that. Note that m_nWriterHasBeenClosed is used by
        // the reader and writer clients and is not maintained for or used by the
        // file collection object.
        DWORD                   m_dwWriterPid;

        // A pointer to m_nWriterHasBeenClosed is handed back to the caller that
        // creates the file collection. The caller is responsible for updating it.
        LONG                    m_nWriterHasBeenClosed;

        // Index granularity in msec. This is stored here because readers round
        // seek times to the index granularity before calling IWMSyncReader::SetRange
        // and use this value when the ring buffer file is opened (and when overlapped
        // recording are opened).
        DWORD                   m_msIndexGranularity;

        // m_dwSharedMemoryMapCounter is the number of times that shared memory section has
        // been remapped. This member is suffixed to the shared memory mapping name to get the
        // name of the most current mapping.
        //
        // The shared memory mapping is fixed size. This limits the number of file nodes that
        // can be present in the map. If the file list gets full and the client permits the
        // shared memory section to grow, m_leFreeList is expanded, this counter is bumped up
        // and a new mapping is created. Each client of the map tracks whether it needs to remap
        // by comparing this member to a locally cached member (m_dwCurrentMemoryMapCounter)
        //
        // Note that size/contents of the CSharedData struct does not change when the shared
        // memory section is remapped (except for the value of m_dwSharedMemoryMapCounter). Also,
        // the number of available list nodes never shrinks (the memory map sizes never decreases).
        //
        // The writer creates the first memory map with a value of 0 in this member and sets it
        // to a non-zero value after the memory map has been initialized. Readers poll this member
        // for a non-zero value before accessing the rest of the memory map. (So 0 is an invalid
        // value for this member.) Some assumptions are made about NT's zeroing memory pages for
        // memory maps - see the comments in CreateMemoryMap()
        DWORD                   m_dwSharedMemoryMapCounter;

        //  reference recordings have attributes in a separate file; if the
        //  length > 0 then there's an attribute filename
        DWORD                   m_dwAttributeFilenameLength ;   //  in WCHAR; does not include NULL char
        WCHAR                   m_szAttributeFile [MAX_PATH] ;

        typedef enum {

            // If set, m_cnsStartTime is always 0

            StartTimeFixedAtZero       = 1

        } DVRIOP_FILE_COLLECTION_SHARED_FLAGS;

        DWORD                   m_nFlags;

        BOOL IsFlagSet(DVRIOP_FILE_COLLECTION_SHARED_FLAGS f)
        {
            return (f & m_nFlags)? 1 : 0;
        }

        void SetFlags(DVRIOP_FILE_COLLECTION_SHARED_FLAGS f)
        {
            m_nFlags |= f;
        }

        void ClearFlags(DVRIOP_FILE_COLLECTION_SHARED_FLAGS f)
        {
            m_nFlags &= ~f;
        }

        // Readers. Note that ALL handles stored in this shared memory struct
        // are wrt to the writer process. Readers register here whenever
        // m_dwMutexSuffix != 0. The index they register at determines the bit
        // they flip (in bmOpenByReader) when they open and close files.
        //
        // If m_dwMutexSuffix is 0, readers do not register here and do not update
        // the bmOpenByReader member on file nodes. (A consequence of this is that
        // files opened by such readers are not refcounted at all, but that's ok
        // since m_dwMutexSuffix will be set to 0 only after the writer has finished
        // and the collection only has permanent files at the time the writer completes.)
        struct CReaderInfo {

            // Readers create an event name by prefixing a fixed string to the
            // dwEventSuffix member. They create the event. Then they set the dwEventSuffix member
            // to the chosen value but only if m_dwWriterPid != 0.
            //
            // This design implicitly assumes that only the writer
            // needs to notify the readers, i.e., readers don't need to notify other readers,
            //
            // The writer opens the event the first time it wants to notify the reader.
            //
            // The writer closes the reader handles either when it seees the
            // DVRIO_READER_REQUEST_DONE flag or when it completes.

            HANDLE  hReaderEvent;  // Handle is wrt to the writer process and used only by the writer. This can be moved out of the shared memory section
            DWORD   dwEventSuffix; // A zero value does NOT mean that this reader slot is not in use; the DVRIO_READER_FLAG_IN_USE flag is set when this slot is in use.
                                   // Zero is the "null" value for this field, i.e., if the reader asks the writer to create an event, it will not choose 0 for the event suffix

            // dwMsg is 0 or any combination of these flags
            typedef enum {
                DVRIO_READER_MSG_NONE = 0,
                DVRIO_READER_REQUEST_DONE = 1, // Reader notification to the writer that it has terminated
                DVRIO_READER_WARNING_CATCH_UP = 2, // A file that the reader has open falls within the min..max range.
                DVRIO_READER_WARNING_FILE_GONE = 4 // A file that the reader has open has been removed from the ring buffer
            } DVRIO_READER_MSG;

            WORD   dwMsg;

            typedef enum {
                DVRIO_READER_FLAG_IN_USE = 1,   // this element in the array is occupied. WRITER clears this flag if hReaderEvent != NULL
                                                // READER clears this flag if hReaderEvent == NULL (writer has terminated)

                // The following flags are used to track if we've already sent out the
                // corresponding warning messages (so that warnings are sent only once
                // for each "violation")
                DVRIO_READER_FLAG_CAUGHT_UP = 2, // all files open by the reader are within the 0..min range
                DVRIO_READER_FLAG_NONE_GONE = 4, // all files open by the reader are within the 0..max range, i.e., none is outside the ring buffer extent
                DVRIO_READER_FLAG_EVENT_OPEN_FAILED = 8  // The writer tried to open the reader event once, but the open failed; the writer does not re-try if this flag is set.
            } DVRIO_READER_FLAGS;

            WORD   dwFlags;

        } Readers[MAX_READERS];

        SHARED_LIST_ENTRY       m_leFileList;
        SHARED_LIST_ENTRY       m_leFreeList;  // Unused CFileInfo nodes

        // The nodes in m_leFreeList and m_leFileList are allocated immediately
        // after this struct. m_dwMaxFiles nodes are allocated in the memory
        // section

    }; // CSharedData

    CClientInfo*                m_pClientInfo; // hack - see Release()

    CSharedData*                m_pShared;
    CSharedData::CFileInfo*     m_pListBase; // pointer to the allocated array of CFileInfo nodes

    // The lock that is held by all public methods. This lock is always
    // obtained before acquiring m_hSharedMutex and released after that
    // is released. We ues a two-level locking scheme because
    // m_hSharedMutex is NULL if we are opening a file collection that
    // has no writer or that is not shared.
    //
    // NOTE: The lock must be obtained ONLY by calling Lock() and
    // released only by calling Unlock()
    CRITICAL_SECTION            m_csLock;

    // The shared memory mutex; the name of the mutex is got from
    // m_dwMutexSuffix and m_kwszSharedMutexPrefix  This member is NULL
    // if m_dwMutexSuffix is 0 when the file collection file is opened;
    // in that case we do not need a shared memory lock. This member is
    // also NULL if the NoSharedMutex flag is set.
    HANDLE                      m_hSharedMutex;

    // The directory that holds the temporary data files
    LPWSTR                      m_pwszTempFilePath;

    // The collection file's name and directory
    LPWSTR                      m_pwszRingBufferFileName;
    LPWSTR                      m_pwszRingBufferFilePath;

    //  handle to the ring buffer context file; this is non-NULL iff we're
    //    explicitely initialized with a ringbuffer file
    HANDLE                      m_hRingBufferFile ;


    // Next usable file id, initialized to DVRIOP_INVALID_FILE_ID + 1
    DVRIOP_FILE_ID              m_nNextFileId;

    // The value of m_dwSharedMemoryMapCounter when this client created
    // the memory mapping.
    DWORD                       m_dwCurrentMemoryMapCounter;

    // Ref count on this object.
    LONG                        m_nRefCount;

     // The thread id that owns m_csLock. This value is not used unless
    // m_dwNumTimesOwned >= 1
    DWORD                       m_dwLockOwner;

    // The number of times the thread has called Lock() without a corresponding
    // call to Unlock()
    DWORD                       m_dwNumTimesOwned;

    typedef enum {

        // Only one of Delete or Mapped should be set.

        // If set, the shared memory section has been mapped. Otherwise,
        // it has been new'd and is not really shared
        Mapped                  = 1 << 0,

        // If set, m_pShared should be cast to a BYTE* and the cast pointer
        // should be passed as an argument to delete [].
        Delete                  = 1 << 1,

        // If set the file collection object was constructed with a DVR file
        // Some operations such as AddFile and SetNumTempFiles are not permitted
        OpenedAsAFile           = 1 << 2,

        // If set, RegisterReader does not register the reader for notifications.
        // This flag is only to allow reading partially created (aborted) multi-file
        // recordings; in that case, m_dwWriterPid may not be valid.
        SideStepReaderRegistration = 1  << 3,

        // If the following flag is set, m_hSharedMutex is NULL and is not required
        // either because the file collection is not shared across processes or
        // because the SideStepReaderRegistration has been set (we have opened an
        // aborted multi-file recording). In both cases, m_dwMutexSuffix will NOT be 0.
        //
        // Currently, this flag is set, but used only in ASSERTS. Also, it happens to be
        // set iff Delete is set (and, consequently, Mapped is not set).
        NoSharedMutex           = 1 << 4,

        // Used in debug builds to limit the inconsistent data debug output in Lock()
        WarnedAboutInconsistentData = 1 << 5,

        // Writer grew the memory map and reader failed to reopen the new one.
        // See comment where this flag is set in Lock()
        ReopenMemoryMapFailed = 1 << 6,

        // The first mapping has been opened. ReopenMemoryMap calls ValidateSharedMemory
        // only if this flag is set; otherwise the constructor validates the sharedmemory.
        FirstMappingOpened = 1 << 7,

        //  This flag is used in the destructor to decide if the m_pShared content
        //    is valid; it is possible for the pointer to be non-NULL but to not
        //    point to valid content e.g. not an ASF file or a stub file, but
        //    some random file; rather than trusting that it points to something
        //    valid, we flag it as such with this flag
        ShareValid = 1 << 8,

    } DVRIOP_FILE_COLLECTION_FLAGS;

    DWORD                   m_nFlags;

    BOOL IsFlagSet(DVRIOP_FILE_COLLECTION_FLAGS f)
    {
        return (f & m_nFlags)? 1 : 0;
    }

    void SetFlags(DVRIOP_FILE_COLLECTION_FLAGS f)
    {
        m_nFlags |= f;
    }

    void ClearFlags(DVRIOP_FILE_COLLECTION_FLAGS f)
    {
        m_nFlags &= ~f;
    }

    // For reader notifications

    struct NotificationContext {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        CDVRFileCollection*          m_pFileCollection;
        CDVRFileCollection::CClientInfo m_FileCollectionInfo;
        HANDLE                       m_hReaderEvent;
        HANDLE                       m_hWaitObject;
        DVRIO_NOTIFICATION_CALLBACK  m_pfnCallback;
        LPVOID                       m_pvContext;

        // Methods

        NotificationContext(IN CDVRFileCollection*          pFileCollection,
                            IN HANDLE                       hEvent,
                            IN DVRIO_NOTIFICATION_CALLBACK  pfnCallback,
                            IN LPVOID                       pvContext,
                            IN CDVRFileCollection::CClientInfo* pFileCollectionClientInfo,
                            IN DWORD                        dwReaderIndex,
                            OUT HRESULT*                    phr)
            : m_pFileCollection(pFileCollection)
            , m_hReaderEvent(hEvent)
            , m_FileCollectionInfo(FALSE)
            , m_hWaitObject(NULL)
            , m_pfnCallback(pfnCallback)
            , m_pvContext(pvContext)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "NotificationContext::NotificationContext"

            DVR_ASSERT(pFileCollection != NULL, "");
            DVR_ASSERT(phr, ""); // This argument should be supplied
            m_pFileCollection->AddRef(&m_FileCollectionInfo);

            // Set up the client context for m_pFileCollection
            m_FileCollectionInfo.SetReaderIndex(dwReaderIndex);

            // NOTE: Currently the notification routines call Lock,
            // which might recreate the memory map. In principle, the SIDs
            // are not required for that since the reader opens an existing
            // memory map (that the writer creates) while holding on to the
            // memory map mutex. However, copying the SIDs here is safer.
            HRESULT hr = m_FileCollectionInfo.SetSids(pFileCollectionClientInfo->dwNumSids,
                                                      pFileCollectionClientInfo->ppSids);
            if (phr)
            {
                *phr = hr;
            }
            if (FAILED(hr))
            {
                // Caller should close it on failure.
                m_hReaderEvent = NULL;
            }
        }

        ~NotificationContext()
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "NotificationContext::~NotificationContext"

            if (m_hReaderEvent)
            {
                ::CloseHandle(m_hReaderEvent);
            }
            if (m_pFileCollection)
            {
                m_pFileCollection->Release(&m_FileCollectionInfo);
            }
        }

        void SetWaitObject(IN HANDLE hWaitObject)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "NotificationContext::SetWaitObject"

            DVR_ASSERT(hWaitObject, "");
            DVR_ASSERT(m_hWaitObject == NULL, "");
            m_hWaitObject = hWaitObject;
        }

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };

    NotificationContext         *m_apNotificationContext[MAX_READERS];

    // Debug data members
#if defined(DEBUG)
    static DWORD                m_dwNextClassInstanceId;
    DWORD                       m_dwClassInstanceId;
#endif

    // ====== Protected methods
protected:
    // Instances of this class are refcounted and can be deleted only
    // by calling Release(). A non-public destructor helps enforce this
    virtual ~CDVRFileCollection();

    // Only the writer should call this function. It opens the
    // specified reader's event for the writer
    HRESULT OpenEvent(IN DWORD i /* index of reader whose event should be opened */);

    // Only the writer should call this function
    HRESULT CreateMemoryMap(IN      const           CClientInfo* pClientInfo,
                            IN      DWORD           dwSharedMemoryBytes, // for the existing mapping
                            IN      BYTE*           pbShared,            // existing mapping
                            IN      DWORD           dwNewSharedMemoryBytes,
                            IN OUT  DWORD&          dwCurrentMemoryMapCounter,
                            IN      DWORD           dwCreationDisposition,
                            IN      DWORD           dwFlagsAndAttributes,
                            OUT     CSharedData*&   pSharedParam,
                            OUT     HANDLE *        phFile OPTIONAL
                            );

    // Following function should be called only by the readers (by design)
    HRESULT ReopenMemoryMap(IN      const           CClientInfo* pClientInfo);

    // Following function should be called only by the readers (by design)
    HRESULT ValidateSharedMemory(IN CSharedData*               pShared,
                                 IN CSharedData::CFileInfo*    pListBase,
                                 IN DWORD                      dwMaxFiles);

    // DeleteUnusedInvalidFileNodes():
    //
    // The following method is called in:
    // - AddFile
    // - CloseReaderFile
    // - SetFileTimes (unlikely to cause files to be deleted unless start ==
    //   end time was specified for some file)
    // - the ring buffer's destructor when the number of clients of the shared
    //   memory section falls to 0. The destructor sets bWithinExtent to 0 on each
    //   temp file node before the call is made. The destructor should ASSERT:
    //   bmOpenByReader == 0.
    //
    // The first argument is set to TRUE to force removal of nodes from the
    // list. Ordinarily, the node is left in the list if the file is
    // temporary, its bmOpenByReader == 0, and the disk file could not be
    // deleted.
    //
    // The second argument can be used in the destructor to verify that files
    // all been deleted.
    //
    // This routine removes nodes from m_leFileList if the file ss successfully
    // deleted.
    //
    // Note that if DeleteFileW fails, this routine should actually verify that
    // the file exists; if it does not, the node is removed from the list.
    void DeleteUnusedInvalidFileNodes(
        BOOL   bRemoveAllNodes,
        DWORD* pdwNumInvalidUndeletedTempFiles OPTIONAL);

    // UpdateTimeExtent():
    //
    // The following method updates the ring buffer's extent and also the
    // bWithinExtent member of each node in m_leFileList. It does not
    // validate that m_cnsLastStreamTime is within the new extent; the caller
    // must make sure that things make sense. In particular, the writer must
    // make sure that m_cnsLastStreamTime >= m_cnsStartTime so that if the
    // reader calls GetTimeExtent(), the values are reasonable. For example,
    // when SetFirstSampleTime() is called, the writer should lock the file
    // collection object, call SetFileTimes, change m_cnsLastStreamTime and
    // then unlock the file collection object to prevent readers from
    // getting inconsistent values from GetTimeExtent() or promising
    // an extent larger than backed by files (so that calls that the reader
    // makes to Seek fail). See SetFileTimes() for more info on why the
    // writer would call that function when SetFirstSampleTime() is called.
    //
    // Conceptually, this function creates a subcollection S of the file
    // collection by eliminating all nodes whose start times equal their end
    // times (and this time is NOT MAXQWORD, start time = end time =
    // MAXQWORD is legit and for us will happen only when recording is
    // in progress, so the recorded node's end time will be MAXQWORD).
    // It sets bWithinExtent of all nodes not in S to 0. If S is empty, it
    // sets m_cnsStartTime = m_cnsEndTime = 0 and returns S_FALSE.
    //
    // Otherwise, it sets m_cnsEndTime to the end time of the last node of S.
    // It then forms two more subsollections S' and S'' from S: S' and S'' have
    // the following characteristics:
    //  - if a node is in S' (S'')then all nodes whose times are > that node are in S' (S'')
    //  - if a temp node is in S' (S'') then all perm nodes just before that temp node are in S' (S'')
    // Further
    //  - S' has at most m_dwMinTempFiles temp nodes.
    //  - S'' has at most m_dwMaxTempFiles temp nodes.
    // If all the nodes in S'' that are not in S' have bmOpenByReader = 0, then S''' is S'.
    // Otherwise, the oldest (time-wise) node in S'' that has bmOpenByReader != 0 is found
    // all perm nodes just before that node are added to S'' and all nodes after that node are
    // added to S'''.
    // m_cnsStartTime is then set to the start time of the first node of S''',
    // In this case, it returns S_OK.
    // bWithinExtent of nodes in S' is set to DVRIO_EXTENT_IN_RING_BUFFER.
    // bWithinExtent of nodes in S''' but not in S' is set to DVRIO_EXTENT_FALLING OUT_OF_RING_BUFFER.
    //
    // Every call to this function recomputes both m_cnsStartTime and
    // m_cnsEndTime. It also recomputes the bWithinExtent member of every
    // node in the collection.
    //
    // If bNotifyReaders is non-zero, this function also notifies readers that are
    // falling behind. Note that bNotifyReaders may be set to 0 only if the call
    // is made in the writer's process.
    //
    HRESULT UpdateTimeExtent(BOOL bNotifyReaders);

    // Callback routine supplied to RegisterWaitForSingleObject
    static VOID CALLBACK RegisterWaitCallback(PVOID lpvParam, BOOLEAN bTimerOut);

    // Routine called by RegisterWaitCallback; invokes the clients'
    // callback routine
    HRESULT NotificationRoutine(IN NotificationContext* p);

    // ====== Public methods
public:

    // Constructors.
    //
    // pwszDVRDirectory must be specified if dwMaxTempFiles > 0 or
    // will be set to a value > 0 by calling SetNumTempFiles().
    // The temporary ring buffer files will be created in a subdirectory
    // of this directory - the subdirectory's name is in m_kwszDVRTempDirectory.
    //
    // If pwszRingBufferFileName is specified, the file is created and the shared
    // memory is mapped. Otherwise, the memory for the ring buffer is not shared.
    // If AddFile() is called with a non-zero value for bOpenFromFileCollectionDirectory,
    // the files in the ring buffer are assumed to reside in the same directory as the
    // ring buffer file.
    //
    // dwMaxFiles is the maximum number of nodes in the file list.
    //
    CDVRFileCollection(IN  const CClientInfo* pClientInfo,
                       IN  DWORD       dwMinTempFiles,
                       IN  DWORD       dwMaxTempFiles,
                       IN  DWORD       dwMaxFiles,
                       IN  DWORD       dwGrowBy,
                       IN  BOOL        bStartTimeFixedAtZero,
                       IN  DWORD       msIndexGranularity,
                       IN  LPCWSTR     pwszDVRDirectory OPTIONAL,
                       IN  LPCWSTR     pwszRingBufferFileName OPTIONAL,
                       IN  BOOL        fMultifileRecording,
                       OUT HRESULT*    phr OPTIONAL);


    CDVRFileCollection(IN  const CClientInfo* pClientInfo,
                       IN  LPCWSTR     pwszRingBufferFileName,
                       OUT DWORD*      pmsIndexGranularity OPTIONAL,  // Contains the index granularity on output
                       OUT HRESULT*    phr OPTIONAL);

    // ====== Refcounting

    ULONG AddRef(IN const CClientInfo* pClientInfo);

    ULONG Release(IN const CClientInfo* pClientInfo);

    // ====== For the ring buffer writer

    HRESULT
    SetAttributeFile (
        IN  const CClientInfo* pClientInfo,
        IN  LPWSTR  pszAttributeFile    //  NULL to explicitely clear
        ) ;

    HRESULT
    GetAttributeFile (
        IN  const CClientInfo* pClientInfo,
        OUT LPWSTR *    ppszAttributeFile   //  NULL if there is none
        ) ;

    // Lock and Unlock.
    //
    // These functions grab and release m_csLock. This allows the writer to
    // prevent readers from accessing the ring buffer. Writers need this
    // when they call SetFirstSampleTime(). They have to update
    // m_cnsLastStreamTime and may also have to call SetFileTimes() to
    // change the ring buffer's time extent. Doing either of these without
    // locking the file collection exposes the reader to inconsistencies:
    // if m_cnsLastStreamTime is updated first, the reader may Seek() to
    // m_cnsLastStreamTime and no file may have been created yet for that
    // time and if SetFileTimes is called first GetTimeExtent will return a
    // time extent (T1, T2) where T1 > T2 (T2 is m_cnsLastStreamTime, which
    // will still be 0.)
    //
    // These methods are also used by both the writer and the reader to guard
    // against concurrent access to shared variables stored in the file
    // collection. Examples of these variables are m_cnsLastStreamTime and
    // CFileInfo::cnsFirstSampleTimeOffsetFromStartOfFile
    //
    // If bIncrementInconsistentDataCounter is non-zero, m_pShared->m_nDataInconsistent
    // is incremented, but only in cases Lock() returns a success status. In these
    // cases, the caller is responsible for calling Unlock() with a non-zero value
    // for bDecrementInconsistentDataCounter.

    HRESULT Lock(IN  const CClientInfo* pClientInfo,
                 OUT BOOL& bReleaseSharedMemoryLock,
                 IN  BOOL  bIncrementInconsistentDataCounter = 0);

    HRESULT Unlock(IN  const CClientInfo* pClientInfo,
                   IN BOOL bReleaseSharedMemoryLock,
                   IN BOOL bDecrementInconsistentDataCounter = 0);

    // AddFile():
    //
    // If the name is supplied in ppwszFileName (i.e., *ppwszFileName != NULL),
    // that file is added to the file collection. It is recommended that the
    // name be a fully qualified one. In this case, *ppwszFileName is not
    // changed by the function and it does not create the file on disk.
    //
    // If *ppwszFileName is NULL when the function is called, a temp file name
    // is generated and added; in this case the temp file name (fully
    // qualified) is returned in ppwszFileName and the file is created on disk
    // if the function returns S_OK. If the function returns S_FALSE or an
    // error, no file is created on disk, *pnFileId is not set and *ppwszFileName
    // remains NULL on.return If the function returns S_OK, the caller must free
    // *ppwszFileName using delete.
    //
    // cnsFirstSampleTimeOffsetFromStartOfFile supplied by the caller is used
    // to set CFileInfo::cnsFirstSampleTimeOffsetFromStartOfFile for the corresponding
    // node.
    //
    // The call fails if (a) start time > end time or (b) if start time = end
    // time and start time != MAXQWORD. The call also fails if
    // the start-end time interval overlaps the start-end time interval of
    // any other file already in the file collection. It is the caller's
    // responsibility to adjust the file time extents of those files using
    // SetFileTimes() before calling AddFile().
    //
    // Note: samples in the file have (stream) times >= start time and < (not
    // <=) end time.
    //
    // The start and end times of the ring buffer are updated on successful
    // addition of the file by calling UpdateTimeExtent() from AddFiles().
    //
    // Note that AddFile places no restriction that the time extent of the added
    // file be at the end of the file collection or that the addition of this
    // file not cause "holes" in the ring buffer's time extent.
    //
    // Because AddFile places no restriction on the time extent of the added
    // file relative to the time extent of the ring buffer, it could happen
    // that the file is added at a point where it does not either fall into the
    // ring buffer's time extent or extend it. For example, the ring buffer
    // may already have m_dwMaxTempFiles temp files and it's time extent could
    // be 500-900 and the added file could be a temp file with extent 400-500.
    // As another example, the ring buffer may have m_dwMaxTempFiles temp files
    // with extent 500-900 a temp file with extent 400-500 waiting to be
    // deleted and a permanent file could be added with extent 200-300. In these
    // cases, the file is added and deleted immediately by AddFile. And the
    // function returns S_FALSE. For our scenarios, this case will never arise.
    //
    // Another consequence of allowing holes in the ring buffer is the following:
    // if the ring buffer has m_dwMaxTempFiles temp files with extent 500-900 a
    // temp file with extent 400-500 waiting to be deleted, adding a *permanent*
    // file with extent 300-400 returns S_FALSE. However, if the temp file with
    // extent 400-500 had already been deleted, it would be possible to add the
    // permanent file and the ring buffer's extent would change to 300-900 with
    // a hole at 400-500. We allow this because our clients will never actually
    // do this for the scenarios of interest.
    //
    // If bOpenFromFileCollectionDirectory is non-zero, the file name saved is
    // not the full path name. The file is assumed to reside in m_pwszRingBufferFilePath.
    // GetFileAtTime tries to return a full path name using m_pwszRingBufferFilePath in this case.
    // Note that AddFile does not validate whether m_pwszRingBufferFilePath is set or not
    // when the file is added. GetFileAtTime prefixes the file name with m_pwszRingBufferFilePath
    // only if m_pwszRingBufferFilePath has been set; if it has not, only the file name (without
    // a directory component) is returned.
    //
    // bDeleteTemporaryFile is ignored if bPermanentFile is non-zero. If bPermanentFile is 0,
    // the temporary file is not deleted when it falls out of the ring buffer extent.

    HRESULT AddFile(IN  const       CClientInfo* pClientInfo,
                    IN OUT LPWSTR*      ppwszFileName OPTIONAL,
                    IN BOOL             bOpenFromFileCollectionDirectory,
                    IN QWORD            cnsStartTime,
                    IN QWORD            cnsEndTime,
                    IN BOOL             bPermanentFile,
                    IN BOOL             bDeleteTemporaryFile,
                    IN LONGLONG         cnsFirstSampleTimeOffsetFromStartOfFile,
                    OUT DVRIOP_FILE_ID* pnFileId);

    typedef struct {
        DVRIOP_FILE_ID  nFileId;
        QWORD           cnsStartTime;
        QWORD           cnsEndTime;
    } DVRIOP_FILE_TIME, *PDVRIOP_FILE_TIME;

    // SetFileTimes():
    //
    // File times of files in the file collection can be changed by calling
    // SetFileTimes. This call will fail if the applying this change would
    // leave two files with overlapping file times or if it requires
    // interchanging the relative order of the files in the collection, e.g.,
    // file A's time extent was 100-200, file B's was 200-300 and the call
    // changes file A's time extent to 300-400 without changing B's.
    // The call also fails if the start time > the end time in any of
    // of the input DVRIOP_FILE_TIME elements. Start time == end time is
    // allowed; this is useful if we had added a node whose extent was
    // T1 to T1+T and a recording node is added with start recording time
    // at T1. In this case, we set the file times of the first node to
    // T1,T1. The call fails if one of the supplied file ids is not
    // in the file collection. The call also fails if one of the
    // supplied file ids had its start time == end time (as a result of
    // a previous call to SetFileTimes).
    //
    // This function automatically updates m_cnsStartTime and m_cnsEndTime
    // by calling UpdateExtent(). Although the order of files cannot be changed
    // by this call, the bWithinExtent member of files in the collection
    // could change as a result of calling this function because start time ==
    // end time for one of the input DVRIOP_FILE_TIME elements.
    //
    // If UpdateExtent returns S_FALSE because the subcollection S' is empty
    // (see UpdateExtent), this function makes the changes to the file times
    // and returns S_FALSE. Note that m_cnsStartTime and m_cnsEndTime
    // would have been set to 0 in this case.
    //
    // As explained in AddFile, it is possible to create holes in the
    // collection for times between m_cnsStartTime and m_cnsLastStreamTime
    // by calling this function. We will not forbid that, but
    // this will cause problems for readers. We do not expect this will
    // happen for our scenarios.
    //
    // The function only changes data members in the file collection; sample
    // times already written to ASF files are not changed. This function
    // should not change file times of a file that has or is being written.
    // The only exception ot this is if the start time equals the end time
    // for such files (and if the file is being written, it should be closed
    // at once). Setting the start time to the end time forces the file node
    // to be deleted from the collection.
    //
    // There are three practical uses of this function: 1. A writer
    // wants to start recording at time T1 but T1 is already in the time extent
    // of another file - in that case that file's extent is reduced to T1 (and
    // if its start time was T1 the file node would be deleted from the
    // collection). 2. The writer initially sets up to start writing at time 0.
    // It knows the starting time only when its client gets the first sample
    // (and calls SetFirstSampleTime()). It would use this function to adjust
    // the times appropriately. 3. On completion of recording, the writer sets
    // the end time of the recorded node and the start and end times of any
    // subsequent nodes (all these times were MAXQWORD while recording
    // was in progress).
    //
    // Final note: It's easy for the writer (the client of this function) to
    // create the pFileTimes argument so that the file ids in the argument are
    // in the same order as file ids in the file collection. This simplifies
    // the code in this function, so we fail the call if this assumption is
    // violated (we assert in this case).

    HRESULT SetFileTimes(IN  const CClientInfo* pClientInfo,
                         IN DWORD dwNumElements,
                         IN PDVRIOP_FILE_TIME pFileTimes);


    // Change the min and max number of temp files in the file collection
    HRESULT SetNumTempFiles(IN  const CClientInfo* pClientInfo,
                            IN DWORD dwMinNumberOfTempFilesParam,
                            IN DWORD dwMaxNumberOfTempFilesParam);

    // Closes event handles of readers that have completed and frees up the
    // corresponding element of the Readers array. Currently, this fn is
    // called from WriteSample. If the writer can be starved of data for
    // long periods, it may be necessary to call this function from a timer
    // loop; use CreateTimerQueueTimer() in that case.
    //
    // This function is also called by Release() when Release() is called by
    // the writer fo the file collection object.
    HRESULT FreeTerminatedReaderSlots(IN  const CClientInfo* pClientInfo,
                                      IN BOOL bLock = 1,
                                      IN BOOL bCloseAllHandles = 0);

    // Sets the last stream time. The caller must hold the lock; it can specify bLock
    // as 0 if it has already obtained the lock.
    HRESULT SetLastStreamTime(IN  const CClientInfo* pClientInfo,
                              IN QWORD    cnsLastStreamTime,
                              IN BOOL     bLock = 1);

    // Sets m_nWriterHasBeenClosed. The caller must hold the lock; it can specify bLock
    // as 0 if it has already obtained the lock.
    HRESULT SetWriterHasBeenClosed(IN  const CClientInfo* pClientInfo,
                                   IN BOOL bLock = 1);

    // Sets the first sample's time offset; the offset is from the start time
    // extent of the file. The caller must hold the lock; it can specify bLock
    // as 0 if it has already obtained the lock.
    HRESULT SetFirstSampleTimeOffsetForFile(IN  const CClientInfo* pClientInfo,
                                            IN DVRIOP_FILE_ID nFileId,
                                            IN LONGLONG       cnsFirstSampleOffset,
                                            IN BOOL           bLock = 1);

    // ====== For the reader

    // Returns the file id and optionally the name of the file corresponding
    // to a stream time. The reader bit in bmOpenByReader on the file is set if
    // bFileWillBeOpened is non-zero. Note that this argument ought to be 0 if
    // the reader already has the file open (since we maintain a bit per reader
    // rather than a ref count).If bFileWillBeOpened is 0, pClientInfo->dwReaderIndex is unused.
    //
    // The caller must free *ppwszFileName using delete. The file name returned
    // depends on the value of OpenFromFileCollectionDirectory flag (which is set
    // when the file was added to the collection; see the comment in AddFile()).
    //
    // GetFileAtTime fails if the file corresponding to the time has the
    // bWithinExtent member set to 0. If there is >1 file which matches
    // the time (as could happen if one of them had start time = end time,
    // in which case it is invalid), it returns the valid one. (Note that
    // there will be at most 1 valid file.)
    //
    // If given MAXQWORD, the function returns the first file whose start
    // time is MAXQWORD. Note that there could be several files in the
    // collection whose start and end times are MAXQWORD (won't happen
    // for our scenarios).
    //
    // Stream times of samples in files are >= start time and < end time,
    // so if the time presented is the endpoint of a file's extent, the
    // file with the start time is picked. However, the function fails
    // if the presented time matches the end time of a file and no valid file
    // has it as the start time.
    //
    // Note: CDVRRingBufferWriter uses this function
    //
    HRESULT GetFileAtTime(IN  const CClientInfo* pClientInfo,
                          IN QWORD              cnsStreamTime,
                          OUT LPWSTR*           ppwszFileName OPTIONAL,
                          OUT LONGLONG*         pcnsFirstSampleTimeOffsetFromStartOfFile OPTIONAL,
                          OUT DVRIOP_FILE_ID*   pnFileId OPTIONAL,
                          IN BOOL               bFileWillBeOpened);

    // Informs the file collection that the file is no longer being used by the
    // reader.
    HRESULT CloseReaderFile(IN  const CClientInfo* pClientInfo,
                            IN DVRIOP_FILE_ID nFileId);

    // Returns the start and end times of the file. Note that the end time is
    // maximum time extent of the file, even if this value is greater than
    // the stream time of the last sample that was written. Times returned are
    // stream times. This call works even if the file is invalid, but returns
    // S_FALSE. It returns S_OK if the file is valid.
    HRESULT GetTimeExtentForFile(IN  const CClientInfo* pClientInfo,
                                 IN DVRIOP_FILE_ID nFileId,
                                 OUT QWORD*        pcnsStartStreamTime OPTIONAL,
                                 OUT QWORD*        pcnsEndStreamTime OPTIONAL);


    // Returns the time extent of the buffer as stream times. Note that
    // m_cnsStartTime and m_cnsLastStreamTime are returned.
    HRESULT GetTimeExtent(IN  const CClientInfo* pClientInfo,
                          OUT QWORD*        pcnsStartStreamTime OPTIONAL,
                          OUT QWORD*        pcnsLastStreamTime OPTIONAL);

    // Returns the first valid stream time after cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    // We return E_FAIL if cnsStreamTime = MAXQWORD and m_cnsEndTime
    //
    // Note: Ring Buffer writer uses this function
    //
    HRESULT GetFirstValidTimeAfter(IN  const CClientInfo* pClientInfo,
                                   IN  QWORD    cnsStreamTime,
                                   OUT QWORD*   pcnsNextValidStreamTime);

    // Returns the last valid stream time before cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    // We return E_FAIL if cnsStreamTime = 0 and m_cnsStartTime
    //
    // Note: Ring Buffer writer uses this function
    //
    HRESULT GetLastValidTimeBefore(IN  const CClientInfo* pClientInfo,
                                   IN  QWORD    cnsStreamTime,
                                   OUT QWORD*   pcnsLastValidStreamTime);

    // Returns a non-zero value iff the source's start time is always 0.
    ULONG StartTimeAnchoredAtZero(IN  const CClientInfo* pClientInfo);

    // Gets the last stream time. The caller must hold the lock; it can specify bLock
    // as 0 if it has already obtained the lock.
    HRESULT GetLastStreamTime(IN  const CClientInfo* pClientInfo,
                              OUT QWORD*   pcnsLastStreamTime,
                              IN  BOOL     bLock = 1);

    // Gets m_nWriterHasBeenClosed. The caller must hold the lock; it can specify bLock
    // as 0 if it has already obtained the lock.
    HRESULT GetWriterHasBeenClosed(IN  const CClientInfo* pClientInfo,
                                   OUT  LONG*   pnWriterCompleted,
                                   IN   BOOL    bLock = 1);

    // Gets the first sample's time offset; the offset is from the start time
    // extent of the file. The caller must hold the lock; it can specify bLock
    // as 0 if it has already obtained the lock.
    HRESULT GetFirstSampleTimeOffsetForFile(IN  const CClientInfo* pClientInfo,
                                            IN  DVRIOP_FILE_ID nFileId,
                                            OUT LONGLONG*      pcnsFirstSampleOffset,
                                            IN  BOOL           bLock = 1);

    // Each reader must call this method to retrieve a reader index. The
    // reader index is used when files are opened and closed (GetFileAtTime
    // and CloseReaderFile). The reader can also optionally specify a
    // callback function and context when it registers. This function sets the
    // dwReaderIndex member of pClientInfo.
    //
    // UnregisterReader must be called with the reader index that is returned
    // by this function.
    //
    HRESULT RegisterReader(CClientInfo* pClientInfo,
                           IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                           IN  LPVOID                       pvContext OPTIONAL);

    HRESULT UnregisterReader(IN  const CClientInfo* pClientInfo);

}; // class CDVRFileCollection


class CDVRRingBufferWriter :
    public IDVRRingBufferWriter,
    public IWMStatusCallback
{

public:

    static LONGLONG     kInvalidFirstSampleOffsetTime;
    static QWORD        kcnsIndexEntriesPadding ;

private:

    // ======== Data members

    // ====== For the writer

    // The following are set in the constructor and never change
    // after that
    QWORD           m_cnsTimeExtentOfEachFile;  // in nanoseconds
    IWMProfile*     m_pProfile;                 // addref'd and released in
                                                // Close().
    LPWSTR          m_pwszDVRDirectory;
    LPWSTR          m_pwszRingBufferFileName;   // Fully qualified name; non-NULL
                                                // iff ring buffer is backed by a file

    DWORD           m_dwMinNumberOfTempFiles;   // in the DVR file collection
                                                // backing the ring buffer
    DWORD           m_dwMaxNumberOfTempFiles;
    DWORD           m_dwMaxNumberOfFiles;
    DWORD           m_dwIndexStreamId;          // id of index stream, set to MAXDWORD
                                                // if no stream should be indexed.
    DWORD           m_msIndexGranularity;       // Granularity of index in msec

    HKEY            m_hRegistryRootKey;         // DVR registry key
    HKEY            m_hDvrIoKey;                // DVR\IO registry key

    DVRIO_NOTIFICATION_CALLBACK m_pfnCallback ;
    LPVOID                      m_pvCallbackContext ;

    //  async IO object; has the completion port, etc...; 1 of these objects
    //    is shared across all the writers
    CAsyncIo *      m_pAsyncIo ;

    //  async io settings (writer)
    DWORD           m_dwIoSize ;
    DWORD           m_dwBufferCount ;
    DWORD           m_dwAlignment ;
    DWORD           m_dwFileGrowthQuantum ;

    CPVRIOCounters *    m_pPVRIOCounters ;

    // Each ASF_WRITER_NODE represents an ASF writer object and could be
    // associated with an ASF file that is being written to at any instant.
    //
    // m_leWritersList has a list of nodes that actually correspond to ASF
    // files being written; this list is sorted in increasing order of the
    // stream time corresponding to the ASF file.
    //
    // The constructor adds one node to m_leWritersList by calling
    // AddATemporaryFile so that the file creation overhead is not
    // incurred when writing the first sample.
    //
    // WriteSample detects when an open file should be closed by checking
    // if the sample's time exceeds the file's extent by more than
    // m_cnsMaxStreamDelta. A request is issued to close the file
    // asynchronously by calling CloseAllWriterFilesBefore and the list node
    // is transferred to the head of m_leFreeList.
    //
    // WriteSample also detects when a file should be opened - it always
    // verifies that there is a node, q, in m_leWritersList after the node, p,
    // it is writing to and either (a) p's end time is MAXQWORD (i.e., p
    // is a DVR recording file - note that StartingStreamTimeKnown flag cannot
    // be 0 in WriteSample) or (b) q's start time is contiguous with p's end
    // time. (In case (a), q's start and end times would both be set to
    // MAXQWORD.) Note that the node after p could be a a DVR
    // recording whose start time is "well into the future"; in this case
    // WriteSample should add a node, q, after p. If a node has to be added,
    // WriteSample removes a node from m_leFreeList, inserts it to
    // m_leWritersList and issues a request to asynchronously open the file
    // by calling AddATemporaryFile.
    //
    // All clean up is done in the Close method.

    struct ASF_RECORDER_NODE;       // Forward reference

    struct ASF_WRITER_NODE
    {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        // Data members

        QWORD               cnsStartTime;   // stream time
        QWORD               cnsEndTime;     // stream time

#if defined(DVR_UNOFFICIAL_BUILD)
        QWORD               cnsLastStreamTime; // last stream time written to this file;
                                               // used only when a validation file is written
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        LIST_ENTRY          leListEntry;
        IWMWriter*          pWMWriter;
        IWMWriterAdvanced3*  pWMWriterAdvanced;
        IWMHeaderInfo *     pIWMHeaderInfo ;
        IDVRFileSink*       pDVRFileSink;

#if defined(DVR_UNOFFICIAL_BUILD)
        // hVal is the handle to the validation file: All data sent to
        // WriteSample is dumped to this file along with the stream number
        // and stream times
        HANDLE              hVal;
        HKEY                hDvrIoKey;
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        // pwszFileName is set only so that the file anme can be passed
        // on to the ProcessOpenRequest (a static member function) to
        // open the file. It is set only for temporary nodes.
        // ProcessOpenRequest frees this member by calling delete and sets
        // it to NULL. For permanent nodes, ProcessOpenRequest uses
        // pRecorderNode->pwszFileName to open the file.
        LPCWSTR                 pwszFileName;

        // NULL if this node is a temporary node; else a pointer
        // to the node in the recorders list
        struct ASF_RECORDER_NODE* pRecorderNode;

        // The ring buffer's file identifier
        CDVRFileCollection::DVRIOP_FILE_ID nFileId;

        // hReadyToWriteTo is set after the file has been opened.
        // WriteSample blocks on this event till it is set. The event
        // is reset after the node has been removed from m_leWritersList
        // and before the close file request is issued.
        HANDLE              hReadyToWriteTo;

        // hFileClosed is set when nodes are created and reset when the
        // node is removed from m_leFreeList. It remains reset when the
        // close file request is issued and the node is returned to
        // m_leFreeList. After the file has been closed, the event is
        // signaled again. The Close() method moves all nodes from
        // m_leWritersList to m_leFreeList and issues asynchronous close
        // requests for all of them by calling CloseAllWriterFilesBefore.
        // it then waits till the hFileClosed event of each node in
        // m_leFreeList is signaled. Similarly, when a node has to be
        // removed from m_leFreeList to be added to m_leWritersList,
        // it is verified that hFileClosed is set.
        HANDLE              hFileClosed;

        // The returned results of the asynchronous open/close (BeginWriting/
        // EndWriting) operations are stored in hrRet.
        HRESULT             hrRet;

        typedef enum {
            FileStartOffsetSet          = 1,

            //  if we're a content recording, we should not call
            //    IWMWriter::BeginWriting until our start method is called;
            //    we do this because hosting app may want to set attributes
            //    in the ASF header; if this flag is set, we do not call the
            //    method in the ::ProcessOpenRequest method, which is called
            //    when the recording is created, but instead when the recording
            //    is started
            WriterNodeContentRecording  = 2
        } DVRIOP_WRITER_FLAGS ;

        DWORD                   m_nFlags;

        // Methods

        BOOL IsFlagSet(DVRIOP_WRITER_FLAGS f)
        {
            return (f & m_nFlags)? 1 : 0;
        }

        void SetFlags(DVRIOP_WRITER_FLAGS f)
        {
            m_nFlags |= f;
        }

        void ClearFlags(DVRIOP_WRITER_FLAGS f)
        {
            m_nFlags &= ~f;
        }

        ASF_WRITER_NODE(HRESULT* phr = NULL)
            : cnsStartTime(0)
            , cnsEndTime(0)
            , pWMWriter(NULL)
            , pWMWriterAdvanced(NULL)
            , pIWMHeaderInfo(NULL)
            , nFileId(CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
            , pRecorderNode(NULL)
            , pwszFileName(NULL)
            , pDVRFileSink(NULL)
            , m_nFlags(0)

#if defined(DVR_UNOFFICIAL_BUILD)

            , hVal(NULL)
            , cnsLastStreamTime(0)

#endif // if defined(DVR_UNOFFICIAL_BUILD)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CDVRRingBufferWriter::CDVRRingBufferWriter"

            DVRIO_TRACE_ENTER();

            HRESULT hrRet;

            __try
            {
                NULL_LIST_NODE_POINTERS(&leListEntry);

                hReadyToWriteTo = ::CreateEvent(NULL, TRUE, FALSE, NULL);
                if (hReadyToWriteTo == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "CreateEvent (hReadyToWriteTo) failed; last error = 0x%x",
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    hFileClosed = NULL;
                    __leave;
                }

                // Manual reset event, initially set
                hFileClosed = ::CreateEvent(NULL, TRUE, TRUE, NULL);
                if (hFileClosed == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "CreateEvent (hFileClosed) failed; last error = 0x%x",
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);

                    __leave;
                }
                hrRet = S_OK;
            }
            __finally
            {
                if (phr)
                {
                    *phr = hrRet;
                }
                DVRIO_TRACE_LEAVE0();
            }
        }

        ~ASF_WRITER_NODE()
        {
            // These handles could be NULL, that's ok - CloseHandle will fail
            ::CloseHandle(hReadyToWriteTo);
            ::CloseHandle(hFileClosed);
            DVR_ASSERT(pRecorderNode == NULL, "");

            // pwszFileName is set to NULL in ProcessOpenRequest
            DVR_ASSERT(pwszFileName == NULL, "");

            DVR_ASSERT(pDVRFileSink == NULL, "");

#if defined(DVR_UNOFFICIAL_BUILD)
            DVR_ASSERT(hVal == NULL, "");
#endif // if defined(DVR_UNOFFICIAL_BUILD)

            if (pWMWriter)
            {
                pWMWriter->Release();
            }
            if (pWMWriterAdvanced)
            {
                pWMWriterAdvanced->Release();
            }
            if (pIWMHeaderInfo)
            {
                pIWMHeaderInfo->Release() ;
            }
        }

        void SetRecorderNode(struct ASF_RECORDER_NODE* p)
        {
            DVR_ASSERT(p == NULL || pRecorderNode == NULL,
                       "pRecorderNode being set a second time.");
            pRecorderNode = p;
        }

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };

    typedef ASF_WRITER_NODE *PASF_WRITER_NODE;

    LIST_ENTRY              m_leWritersList;
    LIST_ENTRY              m_leFreeList;

    // The maximum stream time delta, initially set to 0 and initialized by the
    // client's calling SetMaxStreamDelta.
    QWORD                   m_cnsMaxStreamDelta;

    // The constructor calls AddATemporaryFile so that we do not incur the
    // overhead of "priming a file" when the first sample is written. However,
    // the stream times of the list node in m_leWritersList cannot be set in the
    // constructor - they are unknown till the first sample is written. Tbe
    // StartingStreamTimeKnown flag tracks this. It is set to 0 in
    // the constructor and set to 1 when SetFirstSampleTime is called.
    // SetFirstSampleTime cannot be called more than once successfully..
    QWORD                   m_cnsFirstSampleTime;

    // Calls to WriteSample succeed only if m_cnsMaxStreamDelta has been set
    // and the Close method has not been called. m_nNotOkToWrite is set to -2
    // in the constructor, incremented in the first successful calls to
    // SetMaxStreamDelta and SetFirstSampleTime, and decremented in Close.
    // It's okay to write iff m_nNotOkToWrite == 0. If internal errors
    // have occurred, m_nNotOfToWrite is set to MINLONG; if it is MINLONG,
    // it is never changed.
    LONG                    m_nNotOkToWrite;

    typedef enum {
        StartingStreamTimeKnown = 1,
        WriterClosed            = 2,    // Has Close() been successfully called?
        MaxStreamDeltaSet       = 4,
        SampleWritten           = 8,    // 1 sample has been successfully written or
                                        // we hit an irrecoverable error in the first
                                        // call to WriteSample (and so m_nNotOkToWrite is
                                        // set to MINLONG).
        FirstTempFileCreated    = 16,   // Used to query kwszFirstTemporaryBackingFileNameValue
        EnforceIncreasingTimeStamps = 32// Time stamps provided to the SDK are monotonically
                                        // increasing with a spread of at least 1 msec; if
                                        // timestamps provided to the writer are <=
                                        // the last stream time, the sample's time is bumped
                                        // up to the last stream time + 1 msec
    } DVRIOP_WRITER_FLAGS ;

    DWORD                   m_nFlags;

    BOOL IsFlagSet(DVRIOP_WRITER_FLAGS f)
    {
        return (f & m_nFlags)? 1 : 0;
    }

    void SetFlags(DVRIOP_WRITER_FLAGS f)
    {
        m_nFlags |= f;
    }

    void ClearFlags(DVRIOP_WRITER_FLAGS f)
    {
        m_nFlags &= ~f;
    }

    // The lock that is held by WriteSample, Close, CreateRecorder,
    // Start/StopRecording.
    CRITICAL_SECTION        m_csLock;

    // Ref count on this object
    LONG                    m_nRefCount;

    // ====== For the Recorder

    // We support two kinds of recordings: single file and multi file. A
    // single file recording is written to a single ASF file; the recording
    // is the ASF file. These recorders have an associated ASF_WRITER_NODE
    // which is added to m_leWritersList with time extents that match the
    // recorder's start/stop times. The start/stop times of single file
    // recordings cannot overlap the start/stop times of other single file
    // recordings.

    // Multi file recordings are file collections; the recording is the file
    // collection file. These recorders have an associated CDVRFileCollection
    // object. Each file in the writer's ring buffer that falls within the time
    // span of a multi file recording is also added to the recorder's file
    // collection object. This is done by creating a hard link (CreateHardLink)
    // to the file in the writer's ring buffer. The hard link is created in the
    // same directory as the recording. This means that,if a multi file recording
    // is created:
    // (a) the recording file should be created on NTFS (a volume that support hard links)
    // (b) all files (including single file recordings) that are added to the
    //     writer's ring buffer for the duration of the multi file recording
    //     should be on the same volume as the recording file (so that CreateHardLink
    //     succeeds).

    // m_leRecordersList has a list of recorders, both single and multi-file,
    // that have been created and
    // a) the recording has not been started or
    // b) if the recording has been started, it has not been stopped or cancelled
    // c) if the recording has been stopped, all samples written have times <=
    //    the end recording time.
    //
    // When a recording is cancelled and when a recording is complete (the
    // recording file is closed because no more samples will go into the
    // file), the recorder is pulled out of m_leRecordersList.
    // The recorder node is not deleted till DeleteRecording is called.
    //
    // If DeleteRecording is called when a) is true, the recording node is
    // deleted at once and the node is pulled out of the list. If
    // DeleteRecording is called when b) or c) is true, the node is marked
    // for deletion but not deleted till the recording is cancelled or
    // the recorded file has been closed.
    //
    // Each node in this list is an ASF_RECORDER_NODE. All single file
    // recordings are at the start of the list and all multi file recordings
    // follow the single file recordings. The mutli file recordings are not
    // stored in any specific order. The single file recordings are
    // sorted in the order of start times; nodes whose start times
    // are not set yet are put at the end of the list. (Start and stop
    // times of nodes are initialized to MAXQWORD.)
    //
    // CreateRecorder adds a node to m_leRecordersList. For single file
    // recordings it also pulls a node of m_leFreeList and saves it in the
    // pWriterNode member of the node it just added to m_leRecordersList.
    // It then primes the file for recording and calls BeginWriting
    // synchronously. It returns any error returned by BeginWriting. Note
    // that the start and end stream times on the recorder node are unknown
    // at this point.
    //
    // For multi file recordings, CreateRecording adds a node to m_leRecordersList
    // and creates an associated file collection object, which is saved to the
    // pMultiFileRecorder member of the node added to m_leRecordersList. The recording
    // file (the file collection file) is created synchronously in the file
    // collection object's constructor; errors are returned through the function's
    // return value. CreateRecording also pulls a node of m_leFreeList and saves it
    // in the pWriterNode member of the node it just added to m_leRecordersList.
    // It then primes the file for recording and calls BeginWriting synchronously.
    // (This is a hack. The file we prime is added to the multi-file file collection
    // as a temp file. This is so that any reader that opens the multi-file recording
    // before a sample is written to the recording will wait for a smaple to be
    // written. This saves us from having to build a special reader/writer synchronization
    // mechanism to handle this case. That could get complicated because if no file
    // were in the multi-file recording, its tiem extent would be returned as (0, 0)
    // and calls to Seek/GetProfile etc would fail.)
    //
    // When StartRecording is called, the start time is set and end time is
    // set to infinite.
    //
    // For single file recordings the ASF_WRITER_NODE (saved in the pWriterNode
    // member) is carefully inserted into m_leWritersList based on its start time and
    // the start/end times on the previous and next nodes in m_leWritersList
    // are set correctly. (Note: start time of recording may be well into the
    // future, if so the writer node, q, that had been primed in WriteSample
    // goes before the recording node, else it goes after the recording
    // node. Also take care of boundary case when recording node is
    // added and the StartingStreamTimeKnown flag is 0 and in general when the
    // start recording time is the same as the start time of a node in the
    // writers list.) After inserting the node, a file is added to the writer's
    // file collection object (ring buffer). The pWriterNode member is still
    // set to the recorder ASF_WRITER_NODE. This allows the ASF_WRITER_NODE
    // to be accessed later.
    //
    // For multi file recordings, files are added to the recorder's file collection
    // object if the start time is earlier than the last sample's time and the temp file
    // is removed. The recorder file collection object is then added to
    // m_leActiveMultiFileRecordersList. The writer updates the recorder file collection
    // objects in this list as samples are written. (If the start time is > last
    // sample's write time, the temp file remains in the multi-file recording. It gets
    // pulled out only when the first "real" file is added to that file collection.)
    //
    // When StopRecording is called, the end time is set on the recorder node.
    // StopRecording fails if the end time is less than the start recording
    // time, and for single file recordings, it also fails if the start recording
    // time is less than or equal to the current stream time. If the time
    // supplied to StopRecording is the same as the start recording time, the
    // recording is cancelled (provided that no samples have been written to the
    // recording, else the call fails). For single file recordings, StopRecording
    // adjusts the times in all nodes in the writers list after the writer node
    // corresponding to the recorder node. For multi file recordings, if the
    // stop time is earlier than the time of the last sample written, it removes
    // the recorder's file collection object from m_leActiveMultiFileRecordersList
    // and removes files from the recorder's file collection if necessary. So
    // multi file recordings that are being viewed live could "shrink".
    //
    // Files of recordings that are cancelled should be deleted by the client.
    //
    // DeleteRecorder marks a node for recording; as described above the node
    // might either be deleted right away or after the recording is completed
    // or cancelled.
    //
    // If Start and Stop Recording are called on a single file recorder with times
    // T1 and T2 and then SetFirstSampleTime is called with time = T3 > T2, the recording
    // file is closed when SetFirstSampleTime is called. If T1 < T3 < T2, the
    // recorder's start time is changed from T1 to T3.
    //

    struct ASF_MULTI_FILE_RECORDER_NODE;     // Forward reference

    typedef ASF_MULTI_FILE_RECORDER_NODE *PASF_MULTI_FILE_RECORDER_NODE;

    struct ASF_RECORDER_NODE
    {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        // Data members

        // For single file recoriings, the following are generally in sync
        // with the start, end times on pWriterNode. However, pWriterNode is
        // set to NULL when the recording file is closed (i.e., when the
        // recording has completed). or when recording is cancelled. So we
        // maintain the values here as well.
        //
        // For multi-file recordings, the start and end times are saved here
        // only. In the case that the recording has started (completed), these
        // values will be in sync with the extent returned by pMultiFileRecorder.
        QWORD                   cnsStartTime;
        QWORD                   cnsEndTime;

        // For single file recordings, this is the ASF file. For multi file recordings,
        // this contains the inital temp file and will be NULL once that file is
        // removed.
        PASF_WRITER_NODE        pWriterNode;

        // For multi file recordings (will be NULL for single file recordings)
        PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorder;

        // A pointer to the recorder instance. We do NOT addref this
        // member since the recorder instance holds a ref count on the
        // ring buffer writer. The recorder instance calls DeleteRecording
        // before it is destroyed at which time we delete this node and
        // will not use pRecorderInstance any more.
        CDVRRecorder*           pRecorderInstance;

        LIST_ENTRY              leListEntry;

        LPCWSTR                 pwszFileName;

        typedef enum {
            DeleteRecorderNode      = 1,    // Recorder's file has been written and
                                            // closed or StartRecording has not been
                                            // called. If this flag is set,
                                            // recorder node will be
                                            // deleted when DeleteRecorder is called

            RecorderNodeDeleted     = 2,    // DeleteRecorder sets this flag. It
                                            // deletes the recorder node only if
                                            // the DeleteRecorderNode flag is set.

            // If this flag is set, this node holds a refcount on
            // pRecorderInstance and it is released when this object is
            // destroyed. This refcount is held on behalf of the creator
            // and allows the creator to release its refcount on the
            // object without destroying pRecorderInstance. (Destroying
            // pRecorderInstance has the side effect of stopping the recording
            // immediately if it is in progress and just deleting the
            // recording if it has not been started.) The creator must
            // ensure that it has set the start and stop times on the
            // recording before releasing its refcount; if it does not,
            // it has to call GetRecordings to get back an IDVRRecorder.
            //
            // Note that this object is destroyed when the recording file
            // is closed (which happens when the writer is closed or the
            // the sample time goes past the recorder's stop time). This is
            // when the refcount on pRecorderInstance is released.
            PersistentRecording     = 4,

            // If this flag is set, this is a multi-file recording. pMultiFileRecorder
            // is non-NULL for multi-file recordings.
            MultiFileRecording      = 8

        } DVRIOP_ASF_RECORDER_NODE_FLAGS;

        DWORD                   m_nFlags;

        // Result of the recording, viz., of BeginWriting, WriteSample
        // EndWriting, etc.
        HRESULT                 hrRet;

        // Methods
        ASF_RECORDER_NODE(LPCWSTR           pwszFileNameParam,  // MUST be new'd, destructor deletes
                          HRESULT*          phr = NULL)
            : cnsStartTime(MAXQWORD)
            , cnsEndTime(MAXQWORD)
            , pRecorderInstance(NULL)                 // Set later
            , pWriterNode(NULL)                       // Set later
            , pMultiFileRecorder(NULL)                // Set later
            , pwszFileName(pwszFileNameParam)
            , m_nFlags(DeleteRecorderNode)
            , hrRet(S_OK)
        {
            NULL_LIST_NODE_POINTERS(&leListEntry);

            if (phr)
            {
                *phr = S_OK;
            }
        }

        ~ASF_RECORDER_NODE();

        void SetRecorderInstance(CDVRRecorder* p)
        {
            DVR_ASSERT(pRecorderInstance == NULL,
                       "pRecorderInstance being set a second time.");
            pRecorderInstance = p;
        }

        void SetWriterNode(PASF_WRITER_NODE p)
        {
            DVR_ASSERT(p == NULL || pWriterNode == NULL,
                       "pWriterNode being set a second time.");
            pWriterNode = p;
        }

        void SetMultiFileRecorderNode(PASF_MULTI_FILE_RECORDER_NODE p)
        {
            DVR_ASSERT(p == NULL || pMultiFileRecorder == NULL,
                       "pMultiFileRecorder being set a second time.");
            SetFlags(MultiFileRecording);
            pMultiFileRecorder = p;
        }

        BOOL IsFlagSet(DVRIOP_ASF_RECORDER_NODE_FLAGS f)
        {
            return (f & m_nFlags)? 1 : 0;
        }

        void SetFlags(DVRIOP_ASF_RECORDER_NODE_FLAGS f)
        {
            m_nFlags |= f;
        }

        void ClearFlags(DVRIOP_ASF_RECORDER_NODE_FLAGS f)
        {
            m_nFlags &= ~f;
        }

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };

    typedef ASF_RECORDER_NODE *PASF_RECORDER_NODE;

    struct ASF_MULTI_FILE_RECORDER_NODE
    {
        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        QWORD                   cnsLastFileStartTime;
        CDVRFileCollection*     pFileCollection;
        PASF_RECORDER_NODE      pRecorderNode;
        DWORD                   nNextFileSuffix;
        CDVRFileCollection::CClientInfo FileCollectionInfo;
        CDVRFileCollection::DVRIOP_FILE_ID nLastWriterFileId; // file id in writer's ring buffer of last file that was added to this recording
        CDVRFileCollection::DVRIOP_FILE_ID nLastFileId; // file id in multi file recorder's ring buffer of last file added to this recording

        LIST_ENTRY              leListEntry;

        ASF_MULTI_FILE_RECORDER_NODE(PASF_RECORDER_NODE  pRecorderNodeParam,
                                     DWORD               dwNumSids,
                                     PSID*               ppSids,
                                     HRESULT*            phr)
            : pFileCollection(NULL)
            , FileCollectionInfo(TRUE)
            , pRecorderNode(pRecorderNodeParam)
            , nNextFileSuffix(1)                // 0 is invalid - implies that all suffixes have been exhausted
            , nLastFileId(CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
            , nLastWriterFileId(CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
            , cnsLastFileStartTime(0)
        {
            NULL_LIST_NODE_POINTERS(&leListEntry);

            DVR_ASSERT(pRecorderNode, "");
            DVR_ASSERT(phr, "");

            HRESULT hr = FileCollectionInfo.SetSids(dwNumSids, ppSids);

            if (phr)
            {
                *phr = hr;
            }
        }

        void SetFileCollection(CDVRFileCollection* pFileCollectionParam)
        {
            DVR_ASSERT(pFileCollection == NULL, "SetFileCollection is being called a second time");

            DVR_ASSERT(pFileCollectionParam, "");

            pFileCollection = pFileCollectionParam;
        }

        ~ASF_MULTI_FILE_RECORDER_NODE()
        {
            if (pFileCollection)
            {
                pFileCollection->SetWriterHasBeenClosed(&FileCollectionInfo);
                pFileCollection->Release(&FileCollectionInfo);
            }
        }

        HRESULT
        SetAttributeFile (
            IN  LPWSTR  pszAttributeFile
            ) ;

        HRESULT
        CreateAttributeFilename (
            OUT LPWSTR *    ppszFilename    //  use delete [] to free
            ) ;

        HRESULT
        GetExistingAttributeFilename (
            OUT LPWSTR *    ppszFilename    //  use delete [] to free
            ) ;

        // AddFile creates a hard link to the writer's file and adds it to the
        // multi file recording's file collection.
        //
        // It updates the following members (if it succeeds):
        // nLastFileId, nLastWriterFileId, cnsLastFileStartTime, nNextFileSuffix
        HRESULT AddFile(IN LPCWSTR  pwszWriterFileName, // of the file in the writer's file collection. This file is hard linked
                        IN CDVRFileCollection::DVRIOP_FILE_ID nWriterFileId,
                        IN QWORD    cnsFileStartTime,
                        IN QWORD    cnsFileEndTime,
                        IN LONGLONG cnsFirstSampleTimeOffsetFromStartOfFile);

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif
    };

    LIST_ENTRY        m_leRecordersList;
    LIST_ENTRY        m_leActiveMultiFileRecordersList;

    // ====== For the Ring Buffer
    // We need a method on the ring buffer that returns a pointer to
    // its member that holds the max stream time of any written sample (i.e.,
    // max time extent of the ring buffer). WriteSample updates this variable

    CDVRFileCollection*     m_pDVRFileCollection;   // The ring buffer's
                                                    // collection of files
    CDVRFileCollection::CClientInfo m_FileCollectionInfo;

    // ====== Debug data members
#if defined(DEBUG)
    static DWORD            m_dwNextClassInstanceId;
    DWORD                   m_dwClassInstanceId;
#endif

    // ====== Protected methods
protected:

    // Called asynchronously by a worker thread to "open" ASF files
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls BeginWriting, sets open event.
    // Parameter is actually ASF_WRITER_NODE*
    static DWORD WINAPI ProcessOpenRequest(LPVOID);

    // Removes a free node from the free list (or allocs one), sets outputfilename,
    // sets WM profile and issues request to call BeginWriting async by calling
    // QueueUserWorkItem with ProcessOpenRequest as the callback function.
    // On failure, sets rpFreeNode to NULL, cleans up the free node's members and
    // leaves the node in the free list.
    HRESULT PrepareAFreeWriterNode(IN  LPCWSTR                            pwszFileName,
                                   IN  DWORD                              dwNumSids,
                                   IN  PSID*                              ppSids,
                                   IN  DWORD                              dwDeleteTemporaryFiles,
                                   IN  QWORD                              cnsStartTime,
                                   IN  QWORD                              cnsEndTime,
                                   IN  CDVRFileCollection::DVRIOP_FILE_ID nFileId,
                                   IN PASF_RECORDER_NODE                  pRecorderNode,
                                   OUT LIST_ENTRY*&                       rpFreeNode);

    // Adds pCurrent to the writer's list. Start and end times must be set
    // on the writer node corresponding to pCurrent. If these times overlap
    // the start, end times of any other node already in m_leWritersList,
    // the node is not added.
    HRESULT AddToWritersList(IN LIST_ENTRY*   pCurrent);

    // Adds a temporary file to the file collection object by calling AddFile
    // (file collection may remove other temporary files as a result of this call)
    // and to the writer's list. Calls PrepareAFreeWriterNode to get and prep
    // a free node. Calls AddToWritersList to add the node to m_leWritersList
    HRESULT AddATemporaryFile(IN QWORD   cnsStartTime,
                              IN QWORD   cnsEndTime);

    // Called asynchronously by a worker thread to close ASF files
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls EndWriting, set closed event.
    // Parameter is actually ASF_WRITER_NODE*
    static DWORD WINAPI ProcessCloseRequest(LPVOID);

    // Call this function to close a writer node after the work item to
    // ProcessOpenRequest has been queued. The call to BeginWriting
    // need not have been successful. This function closes the file if
    // BeginWriting succeeded and adds the node to the free list. It
    // deletes the writer node if it hits any error. The argument is a
    // pointer to the writer node's leListEntry member.
    HRESULT CloseWriterFile(LIST_ENTRY* pCurrent);

    // Call this function to close all writer files in m_leWritersList
    // whose end times are <= cnsStreamTime.
    //
    // Called in WriteSample if the first node's
    // endtime < sampletime-maxstreamdelta.
    // Called in Close to close all files, supply INFINITE for the argument,
    HRESULT CloseAllWriterFilesBefore(QWORD cnsStreamTime);

    // ====== Protected methods to support recorders

    // Adds pCurrent to the recorder's list. Start and end times must be set
    // on the recorder node corresponding to pCurrent. If these times overlap
    // the start, end times of any other node already in m_leRecordersList,
    // the node is not added.
    HRESULT AddToRecordersList(IN LIST_ENTRY*   pCurrent);

    // ====== Protected methods to support multi file recordings

    // Extends a multi file recording. Adds a file to it if the writer has
    // written a sample to a new file, else extends the time extent of the
    // last file in the recording. Also, if the recording's start time is
    // in the past, adds the files from the past to the recording.
    //
    // This function is called from StartRecording and WriteSample
    HRESULT ExtendMultiFileRecording(IN  PASF_RECORDER_NODE pRecorderNode,
                                     OUT BOOL&              bRecordingCompleted);

    // Closes the inital priming temp file that is created when the multi file
    // recording is created. Returns S_FALSE if the file has already been closed.
    HRESULT CloseTempFileOfMultiFileRecording(IN PASF_RECORDER_NODE pRecorderNode);

    // Closes a multi file recording
    HRESULT CloseMultiFileRecording(IN PASF_RECORDER_NODE pRecorderNode);

    // Multi file recordings grow as the writer writes samples. This is so that
    // live viewers see the recording. However, the recording can be stopped with
    // a time earlier than the time of the last sample written to the file. In that
    // case, files may have to be removed from the recording.
    //
    // Note: It is expected that the recording will be closed after this method completes
    // (without writing any more samples to it). The nLastFileId in pMultiFileRecorderNode
    // is NOT changed in this method, but that file could have been deleted and removed from the
    // file collection.
    //
    //This function is called from StopRecording.
    HRESULT DeleteFilesFromMultiFileRecording(IN PASF_RECORDER_NODE pRecorderNode);

    // ====== Public methods
public:

    // ====== For the Recorder

    // The recorder identifier is handed over to the recorder object
    // when it is constructed. This is not really necessary now as
    // we support only 1 recorder object at any time. pRecorderId
    // is a pointer to the ASF_RECORDER_NODE's leListEntry member.

    //  create a filename that has the right association with the multi-file
    //    recording; fill it; then set it; set it to NULL to explicitely clear it
    HRESULT
    CreateAttributeFilename (
        IN  LPVOID      pRecorderId,
        OUT LPWSTR *    pszAttrFilename
        ) ;

    HRESULT
    SetAttributeFile (
        IN  LPVOID  pRecorderId,
        IN  LPWSTR  pszAttrFilename
        ) ;

    HRESULT
    GetExistingAttributeFile (
        IN  LPVOID      pRecorderId,
        OUT LPWSTR *    pszAttrFilename
        ) ;

    // If this is a recording file, we call ring buffer ONLY at start recording
    // time and supply file name and start stream time, ring buffer just adds
    // file to list. We would already have called BeginWriting before this when
    // recorder is created.
    HRESULT StartRecording(IN LPVOID pRecorderId, IN OUT QWORD *    pcnsStartTime);

    // To stop recording at the next time instant (current stream time + 1),
    // cnsStopTime can be 0 and a non-zero value is passed in for bNow.
    // Send in recorder's start time to cancel the recording.
    HRESULT StopRecording(IN LPVOID pRecorderId, IN QWORD cnsStopTime, IN BOOL bNow,
                          IN BOOL bCancelIfNotStarted);

    HRESULT DeleteRecorder(IN LPVOID pRecorderId);

    HRESULT GetRecordingStatus(IN LPVOID pRecorderId,
                               OUT HRESULT* phResult OPTIONAL,
                               OUT BOOL*  pbStarted OPTIONAL,
                               OUT BOOL*  pbStopped OPTIONAL,
                               OUT BOOL*  pbSet);

    HRESULT HasRecordingFileBeenClosed(IN LPVOID pRecorderId);

    // Constructor: arguments same as DVRCreateRingBufferWriter,
    // except that the OUT param is a HRESULT rather than an
    // IDVRRingBufferWriter
    CDVRRingBufferWriter(IN  CPVRIOCounters *               pPVRIOCounters,
                         IN  DWORD                          dwMinNumberOfTempFiles,
                         IN  DWORD                          dwMaxNumberOfTempFiles,
                         IN  DWORD                          dwMaxNumberOfFiles,
                         IN  DWORD                          dwGrowBy,
                         IN  QWORD                          cnsTimeExtentOfEachFile,
                         IN  IWMProfile*                    pProfile,
                         IN  DWORD                          dwIndexStreamId,
                         IN  DWORD                          msIndexGranularity,
                         IN  BOOL                           fUnbufferedIo,
                         IN  DWORD                          dwIoSize,
                         IN  DWORD                          dwBufferCount,
                         IN  DWORD                          dwAlignment,
                         IN  DWORD                          dwFileGrowthQuantum,
                         IN  DVRIO_NOTIFICATION_CALLBACK    pfnCallback OPTIONAL,
                         IN  LPVOID                         pvContext,
                         IN  HKEY                           hRegistryRootKey,
                         IN  HKEY                           hDvrIoKey,
                         IN  LPCWSTR                        pwszDVRDirectory OPTIONAL,
                         IN  LPCWSTR                        pwszRingBufferFileName OPTIONAL,
                         IN  DWORD                          dwNumSids,
                         IN  PSID*                          ppSids,
                         OUT HRESULT*                       phr);

    virtual ~CDVRRingBufferWriter();

    // ====== COM interface methods
public:

    // IUnknown

    STDMETHODIMP QueryInterface(IN REFIID riid, OUT void **ppv);

    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    //  IWMStatsCallback

    STDMETHODIMP
    OnStatus (
        IN  WMT_STATUS          Status,
        IN  HRESULT             hr,
        IN  WMT_ATTR_DATATYPE   dwType,
        IN  BYTE *              pbValue,
        IN  void *              pvContext
        ) ;

    // IDVRRingBufferWriter

    STDMETHODIMP SetFirstSampleTime(IN QWORD cnsStreamTime);

    STDMETHODIMP WriteSample(IN     WORD            wStreamNum,
                             IN OUT QWORD *         pcnsStreamTime,
                             IN     DWORD           dwFlags,
                             IN     INSSBuffer *    pSample);

    STDMETHODIMP SetMaxStreamDelta(IN QWORD  cnsMaxStreamDelta);

    STDMETHODIMP GetNumTempFiles(OUT DWORD* pdwMinNumberOfTempFiles,
                                 OUT DWORD* pdwMaxNumberOfTempFiles);

    STDMETHODIMP SetNumTempFiles(IN DWORD dwMinNumberOfTempFiles,
                                 IN DWORD dwMaxNumberOfTempFiles);

    STDMETHODIMP Close(void);


    // Note that this primes a writer node, but does not add it
    // to the writers list. StartRecording does that.
    STDMETHODIMP CreateRecorder(IN  LPCWSTR             pwszDVRFileName,
                                IN  DWORD               dwFlags,
                                OUT IDVRRecorder**      ppDVRRecorder);

    STDMETHODIMP CreateReader(IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                              IN  LPVOID                       pvContext OPTIONAL,
                              OUT IDVRReader**                 ppDVRReader);

    STDMETHODIMP GetDVRDirectory(OUT LPWSTR* ppwszDirectoryName);

    STDMETHODIMP GetRingBufferFileName(OUT LPWSTR* ppwszFileName);

    STDMETHODIMP GetRecordings(OUT DWORD*   pdwCount,
                               OUT IDVRRecorder*** pppIDVRRecorder OPTIONAL,
                               OUT LPWSTR** pppwszFileName OPTIONAL,
                               OUT QWORD**  ppcnsStartTime OPTIONAL,
                               OUT QWORD**  ppcnsStopTime OPTIONAL,
                               OUT BOOL**   ppbStarted OPTIONAL,
                               OUT DWORD**  ppdwFlags OPTIONAL);

    STDMETHODIMP GetStreamTimeExtent(OUT  QWORD*  pcnsStartStreamTime,
                                     OUT  QWORD*  pcnsEndStreamTime);
}; // class CDVRRingBufferWriter

class CDVRRecorder :
    public IDVRRecorder,
    public IDVRIORecordingAttributes    //  same as IDVRRecordingAttributes, but with stream number vs. pin
{

private:
    // ======== Data members

    // m_cnsStartTime is set to MAXQWORD till recording is
    // started and m_cnsEndTime is set to MAXQWORD till
    // recording is stoppped
    QWORD                   m_cnsStartTime;
    QWORD                   m_cnsEndTime;

    // ====== For the writer

    // The following are set in the constructor and never change
    // after that
    CDVRRingBufferWriter*   m_pWriter;
    LPVOID                  m_pWriterProvidedId;

    // The lock that is held by Start/StopRecording.
    CRITICAL_SECTION        m_csLock;

    // Ref count on this object
    LONG                    m_nRefCount;

    //  the recording's IWMHeaderInfo pointer
    //  for content recordings
    IWMHeaderInfo *         m_pIWMHeaderInfo ;

    //  for reference recordings only
    CSBERecordingAttributes *   m_pSBERecordingAttributes ;

    CSBERecordingAttributes *
    RecordingAttributes (
        ) ;

    BOOL IsContentRecording ()      { return (m_pIWMHeaderInfo ? TRUE : FALSE) ; }
    BOOL IsReferenceRecording ()    { return !IsContentRecording () ; }


    // Debug data members
#if defined(DEBUG)
    static DWORD            m_dwNextClassInstanceId;
    DWORD                   m_dwClassInstanceId;
#endif

public:

    // Constructor
    CDVRRecorder(IN     CDVRRingBufferWriter*   pWriter,
                 IN     LPVOID                  pWriterProvidedId,
                 OUT    HRESULT*                phr);

    virtual ~CDVRRecorder();

    void SetIWMHeaderInfo (IN IWMHeaderInfo * pIWMHeaderInfo)
    {
        if (m_pIWMHeaderInfo) {
            m_pIWMHeaderInfo -> Release () ;
            m_pIWMHeaderInfo = NULL ;
        }

        m_pIWMHeaderInfo = pIWMHeaderInfo ;
        if (m_pIWMHeaderInfo) {
            m_pIWMHeaderInfo -> AddRef () ;
        }

        //  this is how we know we're a content recording
        if (!m_pSBERecordingAttributes) {
            m_pSBERecordingAttributes = new CSBERecordingAttributesWM (m_pIWMHeaderInfo) ;
            //  don't fail the call outright if we fail to instantiate; the
            //      result is we won't be able to set attributes
        }
    }

    // ====== COM interface methods
public:

    // IUnknown

    STDMETHODIMP QueryInterface(IN REFIID riid, OUT void **ppv);

    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    // IDVRRecorder

    STDMETHODIMP StartRecording(IN OUT QWORD * pcnsRecordingStartStreamTime);

    STDMETHODIMP StopRecording(IN QWORD cnsRecordingStopStreamTime);

    STDMETHODIMP CancelRecording();

    STDMETHODIMP GetRecordingStatus(OUT HRESULT* phResult OPTIONAL,
                                    OUT BOOL* pbStarted OPTIONAL,
                                    OUT BOOL* pbStopped OPTIONAL);

    STDMETHODIMP HasFileBeenClosed();

    //  IDVRRecordingAttribute

    STDMETHODIMP
    SetDVRIORecordingAttribute (
        IN  LPCWSTR                     pszAttributeName,
        IN  WORD                        wStreamNumber,
        IN  STREAMBUFFER_ATTR_DATATYPE  DataType,
        IN  BYTE *                      pbAttribute,
        IN  WORD                        wAttributeLength
        ) ;

    STDMETHODIMP
    GetDVRIORecordingAttributeCount (
        IN  WORD    wStreamNumber,
        OUT WORD *  pcAttributes
        ) ;

    STDMETHODIMP
    GetDVRIORecordingAttributeByName (
        IN      LPCWSTR                         pszAttributeName,
        IN OUT  WORD *                          pwStreamNumber,     //  must be 0
        OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
        OUT     BYTE *                          pbAttribute,
        IN OUT  WORD *                          pcbLength
        ) ;

    STDMETHODIMP
    GetDVRIORecordingAttributeByIndex (
        IN      WORD                            wIndex,
        IN OUT  WORD *                          pwStreamNumber,     //  must be 0
        OUT     WCHAR *                         pszAttributeName,
        IN OUT  WORD *                          pcchNameLength,
        OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
        OUT     BYTE *                          pbAttribute,
        IN OUT  WORD *                          pcbLength
        ) ;
}; //class CDVRRecorder

class CDVRReader :
    public IDVRReader,
    public IDVRSourceAdviseSink,
    public IDVRIORecordingAttributes
{

private:
    // ======== Data members

    // Following members are set in the constructor and not changed
    // after that
    QWORD           m_cnsIndexGranularity;      // Granularity of index in msec
    HKEY            m_hRegistryRootKey;         // DVR registry key
    HKEY            m_hDvrIoKey;                // DVR\IO registry key
    CAsyncIo *      m_pAsyncIo ;
    DWORD           m_dwIoSize ;
    DWORD           m_dwBufferCount ;

    CPVRIOCounters *    m_pPVRIOCounters ;

    CSBERecordingAttributes *   m_pSBERecordingAttributes ;

    // ====== For the reader

    // Each ASF_READER_NODE represents an ASF reader object and could be
    // associated with an ASF file that is being read or with an ASF file
    // whose IWMProfile has been handed out via GetProfile()..
    //
    // m_leFreeList keeps a list of unused ASF_READER_NODE objects.
    // m_leReadersList has a list of nodes that actually correspond to ASF
    // files being read or whose profiles are in use; this list is sorted
    // by increasing file ids of the ASF files. Note that we do not
    // maintain the stream times in the nodes since they could be changed
    // if the writer calls SetFileTime. We always call into the associated
    // ring buffer if we wish to determine the time extent of a reader node.
    //
    // GetNextSample detects when an open file should be closed. If
    // GetNextSample is called consecutively more than m_dwMinConsecutiveReads
    // times without an intervening call to Seek, all open files that have an
    // earlier end time than the file being read (except any file whose profile
    // object is in use) are asynchronously closed by calling CloseReaderFiles
    // and the nodes are transferred to m_leFreeList:
    //
    // GetNextSample tests if the current file is valid in the ring buffer
    // before reading; if the file has been removed from the ring buffer,
    // it fails the call. In these cases and in all cases that the read fails,
    // it calls CloseReaderFiles to close all files (except any file whose
    // profile object is in use). Note that in these cases, m_leReadersList
    // could become empty.
    //
    // Also, if the ASF read call made by GetNextSample returns end-of-file,
    // GetNextSample tests if the file is valid. If it is not, it fails
    // the call and, as before, calls CloseReaderFiles to close all files.
    // The reason we do this is that the reader of a live source may start
    // reading from time 0 and the writer may write the first sample at
    // time T1 > 0 to a file different from the one to which the reader was
    // reading (the one that the reader was reading has its start time set to
    // its end time and is closed by the writer - see SetFileTimes). Typically
    // this will happen only if a StartRecording(T1) command was issued before
    // the first sample was written and the first sample's time was >= T1
    // (where T1 > the extent of each writer file, i.e., the writer's
    // m_cnsTimeExtentOfEachFile member).
    //
    // Files are NOT closed asynchronously in ReleaseProfile(), see that
    // function for an explanation.
    //
    // GetNextSample also detects when a file should be opened - it checks
    // that there is a node, q, in m_leReadersList after the node p
    // it is reading such that q's stream times immediately follows p's.
    // Of course, this is possible only if the reader is reading a live source
    // and is trailing the writer by a file or more. GetNextSample calls the
    // its GetFileAtTime() method to determine if a file can be
    // opened; and if so, to open it asynchronously.  Note that the reader
    // may be keeping up with the writer, so it may not be possible to
    // open a file ahead of time. For this reason, GetNextSample tries to
    // open the next reader file only every m_dwMinConsecutiveReads calls.
    // Also, the open next reader file stuff is done only if the source
    // is live (till we support ASX files, it is not done for live files).
    //
    // Files are also opened synchronously in Seek() in GetProfile().
    //
    // All clean up is done in the Close method, which is called by the
    // destructor.

    struct ASF_READER_NODE
    {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        LIST_ENTRY          leListEntry;
        IWMSyncReader*      pWMReader;
        IDVRFileSource*     pDVRFileSource;
        IWMHeaderInfo *     pIWMHeaderInfo ;

        // Must be alloc'd with new; destructor deletes this member
        LPCWSTR             pwszFileName;

        // The ring buffer's file identifier
        CDVRFileCollection::DVRIOP_FILE_ID nFileId;

        // hReadyToReadFrom is set after the file has been opened.
        // GetNextSample and GetProfile block on this event till it is set.
        // The event is reset after the node has been removed from
        // m_leReadersList and before the close file request is issued.
        HANDLE              hReadyToReadFrom;

        // hFileClosed is set when nodes are created and reset when the
        // node is removed from m_leFreeList. It remains reset when the
        // close file request is issued and the node is returned to
        // m_leFreeList. After the file has been closed, the event is
        // signaled again. The Close() method moves all nodes from
        // m_leReadersList to m_leFreeList and issues asynchronous close
        // requests for all of them by calling CloseReaderFiles. It then
        // waits till the hFileClosed event of each node in m_leFreeList
        // is signaled. Similarly, when a node has to be removed from
        // m_leFreeList to be added to m_leReadersList, it is verified
        // that hFileClosed is set.
        HANDLE              hFileClosed;

        // The returned results of the asynchronous open/close
        // operations are stored in hrRet.
        HRESULT             hrRet;

        // These members are needed only to pass the timeout value to
        // ProcessOpenRequest, which is a static member function.
        // These variable are always initialized in PrepareAFreeReaderNode
        // before they are used in ProcessOpenRequest and they are not used
        // after that.
        DWORD               msTimeOut;
        HANDLE              hCancel;

        ASF_READER_NODE(HRESULT* phr = NULL)
            : pWMReader(NULL)
            , pDVRFileSource(NULL)
            , pIWMHeaderInfo(NULL)
            , pwszFileName(NULL)
            , nFileId(CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CDVRRingBufferWriter::CDVRRingBufferWriter"

            DVRIO_TRACE_ENTER();

            HRESULT hrRet;

            __try
            {
                NULL_LIST_NODE_POINTERS(&leListEntry);

                hReadyToReadFrom = ::CreateEvent(NULL, TRUE, FALSE, NULL);
                if (hReadyToReadFrom == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "CreateEvent (hReadyToReadFrom) failed; last error = 0x%x",
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    hFileClosed = NULL;
                    __leave;
                }

                // Manual reset event, initially set
                hFileClosed = ::CreateEvent(NULL, TRUE, TRUE, NULL);
                if (hFileClosed == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "CreateEvent (hFileClosed) failed; last error = 0x%x",
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);

                    __leave;
                }
                hrRet = S_OK;
            }
            __finally
            {
                if (phr)
                {
                    *phr = hrRet;
                }
                DVRIO_TRACE_LEAVE0();
            }
        }

        ~ASF_READER_NODE()
        {
            // These handles could be NULL, that's ok - CloseHandle will fail
            ::CloseHandle(hReadyToReadFrom);
            ::CloseHandle(hFileClosed);

            if (pIWMHeaderInfo)
            {
                pIWMHeaderInfo->Release () ;
            }
            if (pWMReader)
            {
                pWMReader->Release();
            }
            if (pDVRFileSource)
            {
                pDVRFileSource->Release();
            }
            delete [] pwszFileName;
        }

        void SetFileName(IN LPCWSTR pwszFileNameParam)
        {
            delete [] pwszFileName;
            pwszFileName = pwszFileNameParam;
        }

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };

    typedef ASF_READER_NODE *PASF_READER_NODE;

    // The minimum number of consecutive reads on a file (without intervening
    // seeks) that are necessary before other open files are closed
    DWORD                   m_dwMinConsecutiveReads;
    // The number of consecutive reads so far. The "open one file ahead of
    // the current reader file" logic is suppressed if this member variable
    // is set to INFINTIE - which it is if the reader corresponds to a non-live
    // file (and till we support ASX files, to a live file)
    DWORD                   m_dwConsecutiveReads;
    LIST_ENTRY              m_leReadersList;
    LIST_ENTRY              m_leFreeList;

    // Pointer to file currently being read by GetNextSample; NULL
    // if none. Set by Seek and automatically changed by GetNextSample if
    // it hits end-of-file on a read call and file is still valid after
    // the read call returns end-of-file.
    ASF_READER_NODE*        m_pCurrentNode;

    // The lock that is held by Seek, GetNextSample, GetProfile,
    // ReleaeProfile, GetStreamTimeExtent.
    CRITICAL_SECTION        m_csLock;

    // Ref count on this object
    LONG                    m_nRefCount;

    // If we have issued a profile object via GetProfile to our client,
    // we set m_pProfileNode to the corresponding node. Any calls to
    // GetProfile while this pointer is set return the profile object
    // associated with that ASF file and m_dwOutstandingProfileCount
    // is incremented. When m_dwOutstandingProfileCount falls to 0,
    // m_pProfileNode is set to NULL. Note that the node pointed to
    // by m_pProfileNode always remains in m_leReadersList and the
    // ASF file is remains open as long as m_pProfileNode is not NULL.
    // When m_pProfileNode is reset to NULL, the file is closed in the
    // usual way either because of a call to GetNextSample or to Close
    //
    // Note that if GetProfile succeeds, it AddRef's the reader object to
    // prevent the client from destroying the reader object while it has
    // an outstanding profile object pointer.
    ASF_READER_NODE*        m_pProfileNode;
    IWMProfile*             m_pWMProfile;
    DWORD                   m_dwOutstandingProfileCount;

    // The following member is non NULL iff m_bDVRProgramFileIsLive is non-zero,
    // i.e., in the case we are reading a live file.
    // For ASX files, the code that uses this member will require some changes.
    ASF_READER_NODE*        m_pLiveFileReaderNode;

    // ====== For the Ring Buffer
    CDVRFileCollection*     m_pDVRFileCollection;   // The ring buffer's
                                                    // collection of files

    // Note: dwReaderIndex member of the file collection info is set by calling
    // the file collection's RegisterReader()
    CDVRFileCollection::CClientInfo m_FileCollectionInfo;

    // In one case, when the reader has to open up an ASF file (recorded previously),
    // the reader creates a file collection object and pretends to be the writer of
    // that object. The following member is used when the file collection is accessed
    // as a writer. This member is new'd on demand (iff m_bAmWriter is set to TRUE)
    CDVRFileCollection::CClientInfo* m_pFileCollectionInfoAsWriter;

    BOOL                    m_bDVRProgramFileIsLive;// 0 if we are reading a
                                                    // live source or a closed file,
                                                    // 1 if we are reading a live file
    BOOL                    m_bSourceIsAnASFFile;   // 1 if we reading a file, 0 if we
                                                    // reading a live source (ring buffer)
    BOOL                    m_bAmWriter;            // 1 if we are serving as the "writer"
                                                    // for this file collection object.
                                                    // This happens only when ASF files are
                                                    // opened.

    // To support Cancel()
    HANDLE                  m_hCancel;

    // Debug data members
#if defined(DEBUG)
    static DWORD            m_dwNextClassInstanceId;
    DWORD                   m_dwClassInstanceId;
#endif

    // ====== Protected methods
protected:

    CSBERecordingAttributes *
    RecordingAttributes (
        ) ;

    BOOL IsContentRecording ()      { return (m_bSourceIsAnASFFile ? TRUE : FALSE) ; }
    BOOL IsReferenceRecording ()    { return !IsContentRecording () ; }

    // Called asynchronously by a worker thread to open ASF files
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls Open, other stuff such as SetReadCompressedSamples, sets open event.
    // Parameter is actually ASF_READER_NODE*
    static DWORD WINAPI ProcessOpenRequest(LPVOID);

    // Removes a free node from the free list (or allocs one) and issues request
    // to open the ASF by calling QueueUserWorkItem with ProcessOpenRequest as
    // the callback function.
    //
    // pwszFileName must be alloc'd with new. The function takes care of calling
    // delete on pwszFileName. Note that the pointer pwszFileName may be invalid
    // when the function returns - the file name could have been deleted if the
    // function failed.
    //
    // On failure, sets rpFreeNode to NULL, cleans up the free node's members and
    // leaves the node in the free list.
    HRESULT PrepareAFreeReaderNode(IN LPCWSTR                              pwszFileName,
                                   IN DWORD                                msTimeOut,
                                   IN CDVRFileCollection::DVRIOP_FILE_ID   nFileId,
                                   OUT LIST_ENTRY*&                        rpFreeNode);

    // Adds pCurrent to the reader's list. The file id must be set
    // on the reader node corresponding to pCurrent. If the id is
    // the same as the id of any other node already in m_leReadersList,
    // the node is not added.
    HRESULT AddToReadersList(IN LIST_ENTRY*   pCurrent);

    // Opens a permanent file for reading (by calling PrepareAFreeReaderNode),
    // queries the file for it's time extent (and whether it is live), adds
    // the file collection object by calling AddFile, and also adds the file
    // to the reader's list by calling AddToReadersList.
    //
    // Currently, this funciton is called only from teh constructor; this will
    // change if we support ASX files (particularly live ASX files that are
    // opened for reading). This function will require some modifications in
    // that case.
    HRESULT AddAPermanentFile(IN LPCWSTR pwszFileNameParam);

    // If a file corrsponding to cnsStreamTime is already in m_leReadersList,
    // this function returns a pointer to the list entry of the reader node.
    // Else, this function calls the file collection object to determine the
    // file corresponding to cnsStreamTime (fails if there is none), opens
    // the file for reading (by calling PrepareAFreeReaderNode), and adds the
    // file to the reader's list by calling AddToReadersList. It returns a
    // a pointer to the list entry of the reader node if it succeeds or NULL
    // if it fails in *pleReaderParam.
    HRESULT GetFileAtTime(IN  QWORD         cnsStreamTime,
                          IN  BOOL          bWaitTillFileIsOpened,
                          OUT LIST_ENTRY**  pleReaderParam);

    // Called asynchronously by a worker thread to close ASF files
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls Close (only if the open succeeeded - as indicated by
    // the reader node's hrRet member), sets closed event.
    // Parameter is actually ASF_READER_NODE*
    static DWORD WINAPI ProcessCloseRequest(LPVOID);

    // Call this function to close a reader node file if PrepareAFreeReaderNode
    // succeeded and returned that reader node. The call to Open (the ASF file)
    // need not have been successful. This function closes the ASF file if Open
    // adds the node to the free list. It also clears the reader bit in bmOpenByReader
    // for this file on the file collection object provided the file id of the
    // reader node is not CDVRFileCollection::DVRIOP_INVALID_FILE_ID. (Note that
    // ProcessCloseRequest cannot do this because it is a static member function
    // and the file collection object is a member fo this class.) If this
    // function hits an error, it still attempts to close the ASF file and then
    // it deletes the reader node
    //
    // The argument is a pointer to the reader node's leListEntry member.
    HRESULT CloseReaderFile(LIST_ENTRY* pCurrent);

    // Call this function to close all reader files in m_leReadersList
    // whose end times are <= cnsStreamTime.
    //
    // Called in GetNextSample as described above
    // Called in Close to close all files, supply INFINITE for the argument,
    HRESULT CloseAllReaderFilesBefore(QWORD cnsStreamTime);

    // Called by the destructor to close all files and clean up.
    // We do not expose this method in IDVRReader because then we'll
    // have to check if the object's being used after being closed.
    HRESULT Close(void);

    // Sets m_pCurrentNode and resets all associated the member variables
    void ResetReader(IN PASF_READER_NODE pReaderNode = NULL);

    // Updates the time extent (the last stream time) for live DVR program files.
    // If the time extent has not changed, verifies if the file is still live and
    // updates m_bDVRProgramFileIsLive.
    //
    // If the file is not live or the source is not a file (i.e., m_bDVRProgramFileIsLive
    // is 0, the function returns S_FALSE without doing anything)
    HRESULT UpdateTimeExtent();

    // ====== Public methods
public:

    // Constructor used by the ring buffer writer to read a live source
    // Constructor addrefs pRingBuffer
    CDVRReader(IN  CPVRIOCounters *             pPVRIOCounters,
               IN  CDVRFileCollection*          pRingBuffer,
               IN  DWORD                        dwNumSids,
               IN  PSID*                        ppSids,
               IN  DWORD                        msIndexGranularity,
               IN  CAsyncIo *                   pAsyncIo,               //  if this is NULL, no async io
               IN  DWORD                        dwIoSize,
               IN  DWORD                        dwBufferCount,
               IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
               IN  LPVOID                       pvContext OPTIONAL,
               IN  HKEY                         hRegistryRootKey,
               IN  HKEY                         hDvrIoKey,
               OUT HRESULT*                     phr);

    // Constructor used to read a DVR program file or an ASF file
    // that has DVR content
    CDVRReader(IN  CPVRIOCounters *             pPVRIOCounters,
               IN  LPCWSTR                      pwszFileName,
               IN  DWORD                        dwNumSids,
               IN  PSID*                        ppSids,
               IN  BOOL                         fUnbufferedIo,
               IN  DWORD                        dwIoSize,
               IN  DWORD                        dwBufferCount,
               IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
               IN  LPVOID                       pvContext OPTIONAL,
               IN  HKEY                         hRegistryRootKey,
               IN  HKEY                         hDvrIoKey,
               OUT HRESULT*                     phr);

    virtual ~CDVRReader();

    // ====== COM interface methods
public:

    // IUnknown

    STDMETHODIMP QueryInterface(IN REFIID riid, OUT void **ppv);

    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    //  IDVRRecordingAttribute

    STDMETHODIMP
    SetDVRIORecordingAttribute (
        IN  LPCWSTR                     pszAttributeName,
        IN  WORD                        wStreamNumber,
        IN  STREAMBUFFER_ATTR_DATATYPE  DataType,
        IN  BYTE *                      pbAttribute,
        IN  WORD                        wAttributeLength
        ) ;

    STDMETHODIMP
    GetDVRIORecordingAttributeCount (
        IN  WORD    wStreamNumber,
        OUT WORD *  pcAttributes
        ) ;

    STDMETHODIMP
    GetDVRIORecordingAttributeByName (
        IN      LPCWSTR                         pszAttributeName,
        IN OUT  WORD *                          pwStreamNumber,
        OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
        OUT     BYTE *                          pbAttribute,
        IN OUT  WORD *                          pcbLength
        ) ;

    STDMETHODIMP
    GetDVRIORecordingAttributeByIndex (
        IN      WORD                            wIndex,
        IN OUT  WORD *                          pwStreamNumber,
        OUT     WCHAR *                         pszAttributeName,
        IN OUT  WORD *                          pcchNameLength,
        OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
        OUT     BYTE *                          pbAttribute,
        IN OUT  WORD *                          pcbLength
        ) ;

    // IDVRReader

    STDMETHODIMP GetProfile(OUT IWMProfile** ppWMProfile);

    STDMETHODIMP ReleaseProfile(IN IWMProfile* pWMProfile);

    STDMETHODIMP Seek(IN QWORD cnsSeekStreamTime);

    // Fails if m_pCurrentNode is NULL, so the reader has to Seek
    // before issuing the first call to GetNextSample. We do not
    // want to special case the first call to GetNextSample.
    // Also, after the very first call to GetNextSample, the reader
    // should call GetStreamTimeExtent. The reason is that the
    // reader may do the following:
    // - call GetStreamTimeExtent - returns (0, T)
    // - Seek(0)
    // - GetNextSample - returns sample time > 0 and either > or < T
    // - the reader should NOT assume that the start time of the stream
    //   is still 0. The writer could have changed it  after the call
    //   that the reader made to GetStreamTimeExtent and Seek because
    //   the writer may have written the first sample only after then.
    //   So the reader should call GetStreamTimeExtent to determine
    //   the correct start stream time. (Note also that the call to
    //   GetNextSample could fail if the writer invalidated that file -
    //   this is described in the section that spells out when reader
    //   files are closed.)
    STDMETHODIMP GetNextSample(OUT INSSBuffer**    ppSample,
                               OUT QWORD*          pcnsStreamTimeOfSample,
                               OUT QWORD*          pcnsSampleDuration,
                               OUT DWORD*          pdwFlags,
                               OUT WORD*           pwStreamNum);

    // For the end time, returns last stream time, which is not
    // the end time returned by the file collection object's GetTimeExtent()
    STDMETHODIMP GetStreamTimeExtent(OUT QWORD*  pcnsStartStreamTime,
                                     OUT QWORD*  pcnsEndStreamTime);

    // Returns the first valid stream time after cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    //
    // Returns E_FAIL if cnsStreamTime = MAXQWORD and m_cnsEndTime
    STDMETHODIMP GetFirstValidTimeAfter(IN  QWORD    cnsStreamTime,
                                        OUT QWORD*   pcnsNextValidStreamTime);

    // Returns the last valid stream time before cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    //
    // Returns E_FAIL if cnsStreamTime = 0 and m_cnsStartTime
     STDMETHODIMP GetLastValidTimeBefore(IN  QWORD    cnsStreamTime,
                                         OUT QWORD*   pcnsLastValidStreamTime);

    // Cancels a pending and all subsequent calls to GetNextSample in
    // which the reader blocks (waiting for the writer to catch up).
    // Has no effect if the reader is reading a fully written file or
    // is lagging behind the reader.
    STDMETHODIMP Cancel();

    // Cancels a previous call to Cancel
    STDMETHODIMP ResetCancel();

    // Returns a non-zero value iff the source is live.
    STDMETHODIMP_(ULONG) IsLive();

    // Returns a non-zero value iff the source's start time is always 0.
    STDMETHODIMP_(ULONG) StartTimeAnchoredAtZero();

    // IDVRSourceAdviseSink

    STDMETHODIMP ReadIsGoingToPend();

}; // class CDVRReader

#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR ""
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE
#endif

_inline CDVRRingBufferWriter::ASF_RECORDER_NODE::~ASF_RECORDER_NODE()
{
    delete [] pwszFileName;
    DVR_ASSERT(pWriterNode == NULL, "");
    if (IsFlagSet(PersistentRecording))
    {
        // The way the recorder node is deleted when the PersistentRecording flag is set
        // is by releasing pRecorderInstance. This calls DeleteRecorder() which deletes
        // this node. Before releasing pRecorderInstance, the PersistentRecording flag
        // should be cleared. So we should not get here.
        DVR_ASSERT(0, "PersistentRecording flag expected to have been cleared before destructor is called");
        DVR_ASSERT(pRecorderInstance, "");
        pRecorderInstance->Release();
    }
    if (pMultiFileRecorder)
    {
        delete pMultiFileRecorder;
    }
}

#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif

#undef DVRIO_DUMP_THIS_FORMAT_STR
#undef DVRIO_DUMP_THIS_VALUE

#endif // _DVR_IOP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvriofilecollection.cpp ===
//------------------------------------------------------------------------------
// File: dvrIOFileCollection.cpp
//
// Description: Implements the class CDVRFileCollection
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

const LPCWSTR CDVRFileCollection::m_kwszDVRTempDirectory = L"TempSBE";

const SharedListPointer CDVRFileCollection::m_kMaxFilesLimit = SHARED_LIST_NULL_POINTER - 1;

const LPCWSTR CDVRFileCollection::m_kwszSharedMutexPrefix = L"Global\\_MS_TSDVR_MUTEX_";
const DWORD MAX_MUTEX_NAME_LEN = 23 + 10 + 1 + 6; // 23 is the length of "Global\\_MS_TSDVR_MUTEX_", 10 is #digits in MAXDWORD, 1 for NULL, 6 as a safety net
const LPCWSTR CDVRFileCollection::m_kwszSharedEventPrefix = L"Global\\_MS_TSDVR_EVENT_";
const DWORD MAX_EVENT_NAME_LEN = 23 + 10 + 1 + 6; // 23 is the length of "Global\\_MS_TSDVR_EVENT_", 10 is #digits in MAXDWORD, 1 for NULL, 6 as a safety net

// The format of the shared memory data section changed in going from v1 to v2.
// A new member, dwEventSufffix was added to each member of m_pShared->Readers.
// Also, the file name that is used for the attributes for the ring buffer was
// added to the shared memory.
//
// This code can't read v1 files any more.
//
// v1 was shipped with XP Embedded.
const GUID CDVRFileCollection::m_guidV1 = { /* c61208a6-799b-4565-ac13-e232a9e6ab9c */
    0xc61208a6,
    0x799b,
    0x4565,
    {0xac, 0x13, 0xe2, 0x32, 0xa9, 0xe6, 0xab, 0x9c}
};

// v2 shipped with XP SP1.
const GUID CDVRFileCollection::m_guidV2  = { /* 12e38c5b-b618-4463-b5a0-ca8d2ecf2c57 */
    0x12e38c5b,
    0xb618,
    0x4463,
    {0xb5, 0xa0, 0xca, 0x8d, 0x2e, 0xcf, 0x2c, 0x57}
};

// v3 shipped with freestyle beta
const GUID CDVRFileCollection::m_guidV3 = { /* D9963C38-AEEA-4c00-805B-7B6DBEF7D19F */
    0xD9963C38,
    0xAEEA,
    0x4c00,
    {0x80, 0x5B, 0x7B, 0x6D, 0xBE, 0xF7, 0xD1, 0x9F}
};

// {5BD6A607-02E4-4054-9D3D-6D32F04BA52C}
const GUID CDVRFileCollection::m_guidV4 = { /* {5BD6A607-02E4-4054-9D3D-6D32F04BA52C} */
    0x5bd6a607,
    0x2e4,
    0x4054,
    {0x9d, 0x3d, 0x6d, 0x32, 0xf0, 0x4b, 0xa5, 0x2c}
} ;

//  v4 shipped with windows XP sp1
//  v4 => v5 because of new default ASF packet size
const GUID CDVRFileCollection::m_guidV5 = { /* {F055E4F0-E308-4f0e-A00E-17D048872D25} */
    0xf055e4f0,
    0xe308,
    0x4f0e,
    {0xa0, 0xe, 0x17, 0xd0, 0x48, 0x87, 0x2d, 0x25}
};

const DWORD CDVRFileCollection::m_dwInvalidReaderIndex = MAXDWORD;

#if defined(DEBUG)
DWORD   CDVRFileCollection::m_dwNextClassInstanceId = 0;
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif

void FreeSecurityDescriptors(IN OUT PACL&  rpACL,
                             IN OUT PSECURITY_DESCRIPTOR& rpSD
                            )
{
    if (rpACL)
    {
        LocalFree(rpACL);
        rpACL = NULL;
    }
    if (rpSD)
    {
        LocalFree(rpSD);
        rpSD = NULL;
    }
} // FreeSecurityDescriptors

// ppSid[0] is assumed to be that of CREATOR_OWNER and is set/granted/denied
// (depending on what ownerAccessMode is) ownerAccessPermissions. The other
// otherAccessMode and otherAccessPermissions are used with the other SIDs
// in ppSids.
// We assume that object handle cannot be inherited.
DWORD CreateACL(IN  DWORD dwNumSids,
                IN  PSID* ppSids,
                IN  ACCESS_MODE ownerAccessMode,
                IN  DWORD ownerAccessPermissions,
                IN  ACCESS_MODE otherAccessMode,
                IN  DWORD otherAccessPermissions,
                OUT PACL&  rpACL,
                OUT PSECURITY_DESCRIPTOR& rpSD
               )
{
    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    if (dwNumSids == 0 || !ppSids)
    {
        return ERROR_INVALID_PARAMETER;
    }

    EXPLICIT_ACCESS* ea = NULL;

    DWORD dwLastError;

    rpACL = NULL;
    rpSD = NULL;

    __try
    {
        ea = new EXPLICIT_ACCESS[dwNumSids];

        if (ea == NULL)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - m_pwszTempFilePath - EXPLICIT_ACCESS[%u]",
                            dwNumSids);
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }


        // Initialize an EXPLICIT_ACCESS structure for ACEs.

        ZeroMemory(ea, dwNumSids * sizeof(EXPLICIT_ACCESS));

        ea[0].grfAccessPermissions = ownerAccessPermissions;
        ea[0].grfAccessMode = ownerAccessMode;
        ea[0].grfInheritance= NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName  = (LPTSTR) ppSids[0];

        for (DWORD i = 1; i < dwNumSids; i++)
        {
            ea[i].grfAccessPermissions = otherAccessPermissions;
            ea[i].grfAccessMode = otherAccessMode;
            ea[i].grfInheritance= NO_INHERITANCE;
            ea[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
            ea[i].Trustee.ptstrName  = (LPTSTR) ppSids[i];
        }

        // Create a new ACL that contains the new ACEs.

        DWORD dwRet = ::SetEntriesInAcl(dwNumSids, ea, NULL, &rpACL);
        if (ERROR_SUCCESS != dwRet)
        {
            dwLastError = dwRet;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "::SetEntriesInAcl failed; last error = 0x%x",
                            dwLastError);
            __leave;
        }

        // Initialize a security descriptor.

        rpSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
                                                 SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (rpSD == NULL)
        {
            dwLastError = GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "::LocalAlloc of SECURITY_DESCRIPTOR failed; last error = 0x%x",
                            dwLastError);
            __leave;
        }

        if (!::InitializeSecurityDescriptor(rpSD, SECURITY_DESCRIPTOR_REVISION))
        {
            dwLastError = GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "::InitializeSecurityDescriptor failed; last error = 0x%x",
                            dwLastError);
            __leave;
        }

        // Add the ACL to the security descriptor.

        if (!::SetSecurityDescriptorDacl(rpSD,
                                         TRUE,     // fDaclPresent flag
                                         rpACL,
                                         FALSE))   // not a default DACL
        {
            dwLastError = GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "::SetSecurityDescriptorDacl failed; last error = 0x%x",
                            dwLastError);
            __leave;
        }
        dwLastError = ERROR_SUCCESS;
    }
    __finally
    {
        delete [] ea;
        if (dwLastError != ERROR_SUCCESS)
        {
            ::FreeSecurityDescriptors(rpACL, rpSD);
        }
    }

    return dwLastError;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CreateACL

// ====== Constructors, destructor

// This constructor is called by writers (including writers that create
// multi-file recordings). It is also called by readers that open up
// single-file recordings (ASF files that are recordings).
// As an aside, note that file collection objects created by writers can be
// addref'd by in-proc readers that open the file colelction using
// CDVRRingBufferWriter::CreateReader

CDVRFileCollection::CDVRFileCollection(IN  const CClientInfo* pClientInfo,
                                       IN  DWORD       dwMinTempFiles,
                                       IN  DWORD       dwMaxTempFiles,
                                       IN  DWORD       dwMaxFiles,
                                       IN  DWORD       dwGrowBy,
                                       IN  BOOL        bStartTimeFixedAtZero,
                                       IN  DWORD       msIndexGranularity,
                                       IN  LPCWSTR     pwszDVRDirectory OPTIONAL,
                                       IN  LPCWSTR     pwszRingBufferFileName OPTIONAL,
                                       IN  BOOL        fMultifileRecording,
                                       OUT HRESULT*    phr OPTIONAL)
    : m_pShared(NULL)
    , m_dwMaxFiles(dwMaxFiles)
    , m_dwGrowBy(dwGrowBy)
    , m_pListBase(NULL)
    , m_hSharedMutex(NULL)
    , m_pwszTempFilePath(NULL)
    , m_pwszRingBufferFileName(NULL)
    , m_pwszRingBufferFilePath(NULL)
    , m_hRingBufferFile(INVALID_HANDLE_VALUE)
    , m_nNextFileId(DVRIOP_INVALID_FILE_ID + 1)
    , m_nRefCount(0)
    , m_dwCurrentMemoryMapCounter(0)
    , m_nFlags(0)
    , m_dwNumTimesOwned(0)
    , m_dwLockOwner(0)           // This value is not valid unles m_dwNumTimesOwned >= 1
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::CDVRFileCollection"

    DVRIO_TRACE_ENTER();

    if (dwMaxTempFiles > 0 || pwszDVRDirectory)
    {
        DVR_ASSERT(pwszDVRDirectory && !DvrIopIsBadStringPtr(pwszDVRDirectory), "");
    }
    DVR_ASSERT(!pwszRingBufferFileName || !DvrIopIsBadStringPtr(pwszRingBufferFileName), "");
    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");
    DVR_ASSERT(pClientInfo, "");

    // Note that we permit dwMinTempFiles == 0 and dwMaxTempFiles > 0 although
    // callers are unlikely to use that setting.

    DVR_ASSERT(dwMaxTempFiles >= dwMinTempFiles, "");
    DVR_ASSERT(dwMaxFiles >= dwMaxTempFiles, "");
    DVR_ASSERT(dwMaxFiles >  0, "");
    DVR_ASSERT(dwMaxFiles <= CDVRFileCollection::m_kMaxFilesLimit, "");

    HRESULT     hrRet;
    BOOL        bRemoveDirectory = 0;
    BOOL        bReleaseMutex = 0;

    ::InitializeCriticalSection(&m_csLock);
    ::ZeroMemory(m_apNotificationContext, sizeof(m_apNotificationContext));


    __try
    {
        HRESULT     hr;
        DWORD       nLen;
        DWORD       dwLastError;

        // Must do this first since the client will Release it if the
        // constructor fails and we want Release() to call the destructor
        AddRef(pClientInfo); // on behalf of the creator of this object

        if (pwszDVRDirectory)
        {
            nLen = wcslen(pwszDVRDirectory);

            nLen += wcslen(m_kwszDVRTempDirectory) + 2;

            m_pwszTempFilePath = new WCHAR[nLen];

            if (!m_pwszTempFilePath)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - m_pwszTempFilePath - WCHAR[%u]",
                                nLen);
                __leave;
            }
            wsprintf(m_pwszTempFilePath, L"%s\\%s", pwszDVRDirectory, m_kwszDVRTempDirectory);

            // TODO: @@@@ DACL this directory
            //
            // Consider this approach (does it save us any real work?):
            // Once this is done, we should assume there is no need to dacl any file that
            // goes into this directory (the temp files) because these files should
            // inherit the right acls from the directory. If the directory is created by
            // the client, assume that they will dacl it accordingly. If the directory
            // dacls are changed after creation so that temp files are not shareable
            // across user contexts - too bad.
            //
            // We only dacl files that do *not* go into this directory.

            if (!::CreateDirectoryW(m_pwszTempFilePath, NULL))
            {
                DWORD dwAttrib = ::GetFileAttributesW(m_pwszTempFilePath);
                if (dwAttrib == (DWORD) (-1))
                {
                    dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "::GetFileAttributesW of m_pwszTempFilePath failed; last error = 0x%x",
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                   __leave;
                }
                if ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
                {
                    dwLastError = ERROR_DIRECTORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "m_pwszTempFilePath not a directory; last error = 0x%x (ERROR_DIRECTORY)",
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                   __leave;
                }
            }
            else
            {
                bRemoveDirectory = 1; // in case we have errors after this
            }

            // Ignore returned status
            ::SetFileAttributesW(m_pwszTempFilePath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }

        if (pwszRingBufferFileName)
        {
            // Convert the supplied argument to a fully qualified path

            WCHAR   wTempChar;
            WCHAR*  pDir;
            DWORD   nLen2;

            nLen = ::GetFullPathNameW(pwszRingBufferFileName, 0, &wTempChar, NULL);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "First GetFullPathNameW (for pwszRingBufferFileName) failed, nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }

            m_pwszRingBufferFileName = new WCHAR[nLen+1];
            if (m_pwszRingBufferFileName == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - m_pwszRingBufferFileName - WCHAR[%u]",
                                nLen+1);

                hrRet = E_OUTOFMEMORY;
                __leave;
            }

            nLen2 = ::GetFullPathNameW(pwszRingBufferFileName, nLen+1, m_pwszRingBufferFileName, &pDir);
            if (nLen2 == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Second GetFullPathNameW (for pwszRingBufferFileName) failed, first call returned nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
            else if (nLen2 > nLen)
            {
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Second GetFullPathNameW (for pwszRingBufferFileName) returned nLen = %u > first call, which returned %u",
                                nLen2, nLen);
                hrRet = E_FAIL;
                __leave;
            }
            DVR_ASSERT(pDir, "");
            DVR_ASSERT(pDir > m_pwszRingBufferFileName, "");
            DVR_ASSERT(pDir[-1] == L'\\' || pDir[-1] == L'/', "");

            // m_pwszRingBufferFilePath has a trailing \ or /. This is so that we won't have to
            // special case files in the root directory of a drive.
            nLen = pDir - m_pwszRingBufferFileName;
            m_pwszRingBufferFilePath = new WCHAR[nLen + 1];
            if (m_pwszRingBufferFilePath == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - m_pwszRingBufferFilePath - WCHAR[%u]",
                                nLen + 1);

                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            wcsncpy(m_pwszRingBufferFilePath, m_pwszRingBufferFileName, nLen);
            m_pwszRingBufferFilePath[nLen] = L'\0';
        }

        DWORD dwSharedMemoryBytes = sizeof(CSharedData) + m_dwMaxFiles*sizeof(CSharedData::CFileInfo);
        DWORD dwCurrentMemoryMapCounter = m_dwCurrentMemoryMapCounter;

        if (pwszRingBufferFileName)
        {
            // Both have been zero'd, we only care that they are equal

            // Create the file and map the section. This creates the disk file and grows
            // it to dwSharedMemoryBytes. Readers will wait till we set m_dwSharedMemoryMapCounter
            // to a non-zero value (see comment in CreateMemoryMap)
            hr = CreateMemoryMap(pClientInfo,
                                 0,
                                 NULL,
                                 dwSharedMemoryBytes,
                                 dwCurrentMemoryMapCounter,
                                 CREATE_NEW,
                                 (fMultifileRecording ? FILE_ATTRIBUTE_NORMAL : FILE_FLAG_DELETE_ON_CLOSE),
                                 m_pShared,
                                 & m_hRingBufferFile
                                 );
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            DVR_ASSERT(m_pShared, "");
            DVR_ASSERT(dwCurrentMemoryMapCounter > 0, "");
            SetFlags(Mapped);
        }
        else
        {

            BYTE* pbShared = new BYTE[dwSharedMemoryBytes];
            if (!pbShared)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - pbShared - BYTE[%u], dwMaxFile s= %u",
                                dwSharedMemoryBytes, dwMaxFiles);
                __leave;
            }
            m_pShared = (CSharedData *) pbShared;
            SetFlags(Delete);
        }

        ::ZeroMemory((BYTE*) m_pShared, dwSharedMemoryBytes);

        m_pListBase = (CSharedData::CFileInfo*) (m_pShared + 1);

        m_pShared->m_guidVersion = m_guidV5;
        m_pShared->m_dwMinTempFiles = dwMinTempFiles;
        m_pShared->m_dwMaxTempFiles = dwMaxTempFiles;
        m_pShared->m_dwNumClients = 1;
        m_pShared->m_dwWriterPid = ::GetCurrentProcessId();
        m_pShared->m_msIndexGranularity = msIndexGranularity;
        m_pShared->m_dwAttributeFilenameLength=0 ;
        m_pShared->m_szAttributeFile [0] = L'\0' ;
        if (bStartTimeFixedAtZero)
        {
            m_pShared->SetFlags(CSharedData::StartTimeFixedAtZero);
        }

        InitializeSharedListHead(&m_pShared->m_leFileList);
        InitializeSharedListHead(&m_pShared->m_leFreeList);

        for (DWORD i = 0; i < m_dwMaxFiles; i++)
        {
            m_pListBase[i].leListEntry.Index = (SharedListPointer) i;
            InsertTailSharedList(&m_pShared->m_leFreeList, m_pListBase, &m_pShared->m_leFreeList, &m_pListBase[i].leListEntry);
        }

        if (pwszRingBufferFileName)
        {
            WCHAR wszMutex[MAX_MUTEX_NAME_LEN];
            wcscpy(wszMutex, CDVRFileCollection::m_kwszSharedMutexPrefix);
            nLen = wcslen(CDVRFileCollection::m_kwszSharedMutexPrefix);

            PACL                 pACL = NULL;
            PSECURITY_DESCRIPTOR pSD = NULL;
            DWORD                dwAclCreationStatus;
            SECURITY_ATTRIBUTES  sa;

            if (pClientInfo->dwNumSids > 0)
            {
                dwAclCreationStatus = ::CreateACL(pClientInfo->dwNumSids, pClientInfo->ppSids,
                                                SET_ACCESS, MUTEX_ALL_ACCESS,
                                                SET_ACCESS, SYNCHRONIZE,
                                                pACL,
                                                pSD
                                                );

                if (dwAclCreationStatus != ERROR_SUCCESS)
                {
                    hrRet = HRESULT_FROM_WIN32(dwAclCreationStatus);
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "::CreateAcl failed, returning hr = 0x%x",
                                    hrRet);
                    __leave;
                }

                sa.nLength = sizeof (SECURITY_ATTRIBUTES);
                sa.lpSecurityDescriptor = pSD;
                sa.bInheritHandle = FALSE;
            }

            for (i = 1; i != 0; i++)
            {
                wsprintf(wszMutex + nLen, L"%u", i);

                HANDLE h = ::CreateMutexW(pClientInfo->dwNumSids > 0? &sa : NULL, TRUE /* Initially owned */, wszMutex);

                dwLastError = ::GetLastError();

                if (h == NULL || dwLastError == ERROR_ALREADY_EXISTS)
                {
                    if (h)
                    {
                        ::CloseHandle(h);
                    }
                    else
                    {
                        // It's ok if we failed for any other reason - just go on.
                    }
                }
                else
                {
                    // Done
                    m_pShared->m_dwMutexSuffix = i;
                    m_hSharedMutex = h;
                    break;
                }
            }
            if (pClientInfo->dwNumSids > 0)
            {
                ::FreeSecurityDescriptors(pACL, pSD);
            }

            if (i == 0)
            {
                DVR_ASSERT(0, "Failed to find a suitable value for m_dwMutexSuffix?!");
                hrRet = E_FAIL;
                __leave;
            }
            bReleaseMutex = 1;

            // All done
            m_dwCurrentMemoryMapCounter = dwCurrentMemoryMapCounter;
            SetFlags(FirstMappingOpened);
            ::InterlockedExchange((PLONG) &m_pShared->m_dwSharedMemoryMapCounter, dwCurrentMemoryMapCounter);
        }
        else
        {
            m_pShared->m_dwMutexSuffix = 1; // any non-zero value is ok
            SetFlags(NoSharedMutex);
            DVR_ASSERT(m_hSharedMutex == NULL, "");
        }

        SetFlags (ShareValid) ;

        hrRet = S_OK;
    }
    __finally
    {
        if (bReleaseMutex)
        {
            ::ReleaseMutex(m_hSharedMutex);
        }
        if (SUCCEEDED(hrRet))
        {
            DVR_ASSERT((IsFlagSet(Delete) && IsFlagSet(NoSharedMutex)) ||
                       (!IsFlagSet(Delete) && !IsFlagSet(NoSharedMutex)), "");
            DVR_ASSERT((IsFlagSet(Delete) && !IsFlagSet(Mapped)) ||
                       (!IsFlagSet(Delete) && IsFlagSet(Mapped)), "");
        }
        else
        {
            if (bRemoveDirectory)
            {
                ::RemoveDirectoryW(m_pwszTempFilePath);
            }
            // To ensure that the ASSERT in Release() succeeds:
            if (m_pShared)
            {
                m_pShared->m_nWriterHasBeenClosed = 1;
            }
        }
        if (phr)
        {
            *phr = hrRet;
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRFileCollection::CDVRFileCollection

// This constructor is called only by readers.
//
// Note: m_dwMaxFiles is computed in this fn based on the file size: this is
// not very reliable. This member is used only in SetNumTempFiles,
// which should not be called on file collection objects opened using this
// constructor. We could add this member to the shared memory section, but it
// has not been necessary so far.
//
// Similarly, m_nNextFileId is not set correctly. This member is used only in
// AddFile and we don't allow AddFile to be called on objects opened by this
// constructor.
//
CDVRFileCollection::CDVRFileCollection(IN  const CClientInfo* pClientInfo,
                                       IN  LPCWSTR     pwszRingBufferFileName,
                                       OUT DWORD*      pmsIndexGranularity OPTIONAL,
                                       OUT HRESULT*    phr OPTIONAL)
    : m_pShared(NULL)
    , m_dwMaxFiles(0)       // Revised below
    , m_dwGrowBy(0)         // Not changed after this - this collection cannot be grown by this client
    , m_pListBase(NULL)
    , m_hSharedMutex(NULL)
    , m_pwszTempFilePath(NULL)
    , m_pwszRingBufferFileName(NULL)
    , m_pwszRingBufferFilePath(NULL)
    , m_hRingBufferFile(INVALID_HANDLE_VALUE)
    , m_nNextFileId(DVRIOP_INVALID_FILE_ID + 1)
    , m_nRefCount(0)
    , m_dwCurrentMemoryMapCounter(1)
    , m_nFlags(OpenedAsAFile)
    , m_dwNumTimesOwned(0)
    , m_dwLockOwner(0)           // This value is not valid unles m_dwNumTimesOwned >= 1
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::CDVRFileCollection (DVR File)"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(!pmsIndexGranularity || !DvrIopIsBadWritePtr(pmsIndexGranularity, 0), "");
    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");
    DVR_ASSERT(pClientInfo, "");

    DVR_ASSERT(!pClientInfo->bAmWriter, "");

    HRESULT     hrRet;
    BOOL        bReleaseSharedMemoryLock = 0;
    BOOL        bLocked = 0;
    HANDLE      hMMFile = NULL;

    ::InitializeCriticalSection(&m_csLock);
    ::ZeroMemory(m_apNotificationContext, sizeof(m_apNotificationContext));

    __try
    {
        HRESULT     hr;
        DWORD       nLen;
        DWORD       nLen2;
        DWORD       dwLastError;
        DWORD       i;

        // Must do this first since the client will Release it if the
        // constructor fails and we want Release() to call the destructor
        AddRef(pClientInfo); // on behalf of the creator of this object

        if (!pwszRingBufferFileName || DvrIopIsBadStringPtr(pwszRingBufferFileName))
        {
            hrRet = E_INVALIDARG;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
            __leave;
        }

        // Convert the supplied argument to a fully qualified path

        WCHAR   wTempChar;
        WCHAR*  pDir;

        nLen = ::GetFullPathNameW(pwszRingBufferFileName, 0, &wTempChar, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "First GetFullPathNameW (for pwszRingBufferFileName) failed, nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            hrRet = (FAILED (hrRet) ? hrRet : E_FAIL) ; //  PREFIX
            __leave;
        }

        m_pwszRingBufferFileName = new WCHAR[nLen+1];
        if (m_pwszRingBufferFileName == NULL)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - m_pwszRingBufferFileName - WCHAR[%u]",
                            nLen+1);

            hrRet = E_OUTOFMEMORY;
            __leave;
        }

        nLen2 = ::GetFullPathNameW(pwszRingBufferFileName, nLen+1, m_pwszRingBufferFileName, &pDir);
        if (nLen2 == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Second GetFullPathNameW (for pwszRingBufferFileName) failed, first call returned nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            hrRet = (FAILED (hrRet) ? hrRet : E_FAIL) ; //  PREFIX
            __leave;
        }
        else if (nLen2 > nLen)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Second GetFullPathNameW (for pwszRingBufferFileName) returned nLen = %u > first call, which returned %u",
                            nLen2, nLen);
            hrRet = E_FAIL;
            __leave;
        }
        DVR_ASSERT(pDir, "");
        DVR_ASSERT(pDir > m_pwszRingBufferFileName, "");
        DVR_ASSERT(pDir[-1] == L'\\' || pDir[-1] == L'/', "");

        // m_pwszRingBufferFilePath has a trailing \ or /. This is so that we won't have to
        // special case files in the root directory of a drive.
        nLen = pDir - m_pwszRingBufferFileName;
        m_pwszRingBufferFilePath = new WCHAR[nLen + 1];
        if (m_pwszRingBufferFilePath == NULL)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - m_pwszRingBufferFilePath - WCHAR[%u]",
                            nLen + 1);

            hrRet = E_OUTOFMEMORY;
            __leave;
        }
        wcsncpy(m_pwszRingBufferFilePath, m_pwszRingBufferFileName, nLen);
        m_pwszRingBufferFilePath[nLen] = L'\0';

        // Create the file and map the section

        // First, open the memory mapped index file and validate if it's ours
        // (Note for self: No need to specify security attributes here since this opens an
        // existing file - delete this part of the comment.)
        hMMFile = ::CreateFileW(m_pwszRingBufferFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,          // security attributes
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, // file flags and attributes
                                NULL           // template file
                               );
        if (hMMFile == INVALID_HANDLE_VALUE)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Failed to open ring buffer file, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            hMMFile = NULL;
            __leave;
        }

        // Generate the name of the mapping object and the temp index file(s)
        BY_HANDLE_FILE_INFORMATION  sFileInf;
        WCHAR                       wszMapping[64];
        DWORD                       dwNumTimes = 0;

        do
        {
            if (::GetFileInformationByHandle(hMMFile, &sFileInf) == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "GetFileInformationByHandle on ring buffer file failed, last error = 0x%x",
                                dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
            //  check for too big
            if (sFileInf.nFileSizeHigh > 0 ||
                sFileInf.nFileSizeLow >= sizeof(CDVRFileCollection::CSharedData) + CDVRFileCollection::m_kMaxFilesLimit*sizeof(CDVRFileCollection::CSharedData::CFileInfo)) {

                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "file size is invalid (low = %u; high = %u), last error = 0x%x",
                                sFileInf.nFileSizeLow, sFileInf.nFileSizeHigh, ERROR_INVALID_DATA);
                __leave;
            }
            //  check for too small
            if (sFileInf.nFileSizeLow < sizeof(CSharedData))
            {
                // If file size is 0: Writer could have created the file, but not the memory map.
                // (The file is grown when the memory map is created.) This is an unlikely race
                // condition (reader opening file while writer is creating it and we could
                // force apps to handle this synchronization, but let's try to cope.

                // CreateMemoryMapping on a 0-sized file (where we specify 0 for the file
                // length would return ERROR_FILE_INVALID. We could loop there instead of here.

                // We must limit the number of iterations here, else we'll loop forever if we
                // are asked to open a zero-sized file
                if (++dwNumTimes == 5)
                {
                    hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    DvrIopDebugOut4(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "File size is %u < (sizeofCSharedData) = %u (after %d iterations), last error = 0x%x",
                                    sFileInf.nFileSizeLow, sizeof(CSharedData), dwNumTimes, ERROR_INVALID_DATA);
                    __leave;
                }
                ::Sleep(100);
            }
            else
            {
                break;
            }
        }
        while (1);

        // We start with a mapping counter of 1.
        wsprintf(wszMapping, L"Global\\MSDVRXMM_%u_%u_%u_%u",
                 sFileInf.dwVolumeSerialNumber,
                 sFileInf.nFileIndexHigh,
                 sFileInf.nFileIndexLow,
                 m_dwCurrentMemoryMapCounter);

        // Create the memory mapping. This will grow the disk file to
        // the size specified as arguments to the call.
        PACL                 pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwAclCreationStatus;
        SECURITY_ATTRIBUTES  sa;

        if (pClientInfo->dwNumSids > 0)
        {
            // We are a reader. If we create this map, the writer is done with it and
            // we (and no one else in our user context) needs SECTION_EXTEND_SIZE on
            // this memory map. If we open an existing map, the security attributes
            // we specify are ignored anyway. (At least, they should be. MSDN says
            // nothing about this.)
            dwAclCreationStatus = ::CreateACL(pClientInfo->dwNumSids, pClientInfo->ppSids,
                                            SET_ACCESS, SECTION_ALL_ACCESS & ~(SECTION_EXTEND_SIZE|SECTION_MAP_EXECUTE),
                                            SET_ACCESS, SECTION_QUERY|SECTION_MAP_WRITE|SECTION_MAP_READ,
                                            pACL,
                                            pSD
                                            );

            if (dwAclCreationStatus != ERROR_SUCCESS)
            {
                hrRet = HRESULT_FROM_WIN32(dwAclCreationStatus);
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "::CreateAcl failed, returning hr = 0x%x",
                                hrRet);
                __leave;
            }

            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
        }

        HANDLE hFileMapping = ::CreateFileMappingW(hMMFile,
                                                   pClientInfo->dwNumSids > 0? &sa : NULL,
                                                   PAGE_READWRITE,
                                                   0,        // high order size
                                                   0,        // low order of file size. Here we map the entire file
                                                   wszMapping);
        dwLastError = ::GetLastError();
        if (pClientInfo->dwNumSids > 0)
        {
            ::FreeSecurityDescriptors(pACL, pSD);
        }
        if (hFileMapping == NULL)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "CreateFileMappingW on ring buffer file failed, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        BOOL bMapAlreadyExists = dwLastError == ERROR_ALREADY_EXISTS;

        // Map the view
        CSharedData* pShared = (CSharedData*) MapViewOfFile(hFileMapping,
                                                            FILE_MAP_READ | FILE_MAP_WRITE,
                                                            0, 0, // file offset for start of map, high and low
                                                            0     // entire file mapping
                                                           );
        if (pShared == NULL)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "MapViewOfFile on ring buffer file failed, last error = 0x%x",
                            dwLastError);
            ::CloseHandle(hFileMapping);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        ::CloseHandle(hFileMapping);
        hFileMapping = NULL;         // Don't use this any more

        // If this file is not ours and is changing, we don't really know how large
        // the mapping is. We are going to access various members of CSharedData.
        // At last check we had at least sizeof(CSharedData) bytes in the file.
        // But we don't know if we mapped that many bytes. What we do know, however
        // is that we can access at least 1 page without faulting.

        if (IsBadWritePtr(pShared, sizeof(CSharedData)))
        {
            // Our memory map is not as large as the file. It should be
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Memory Map addresses bad even for CSharedData (=%u) bytes IsbadWritePtr returned 1, last error = 0x%x",
                            sizeof(CSharedData), ERROR_INVALID_DATA);
            __leave;
        }

        m_pShared = pShared;
        SetFlags(Mapped);
        m_pListBase = (CSharedData::CFileInfo*) (m_pShared + 1);

        if (bMapAlreadyExists)
        {
            dwNumTimes = 0;

            while (m_pShared->m_dwSharedMemoryMapCounter == 0)
            {
                if (++dwNumTimes == 5)
                {
                    m_dwCurrentMemoryMapCounter = 0 ;

                    hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "m_pShared->m_dwSharedMemoryMapCounter is 0 (after %d iterations), memory map exists, last error = 0x%x",
                                    dwNumTimes, ERROR_INVALID_DATA);
                    __leave;
                }
                ::Sleep(100);
            }
        }
        else
        {
            if (m_pShared->m_dwSharedMemoryMapCounter == 0)
            {
                m_dwCurrentMemoryMapCounter = 0 ;

                // The writer always sets this to a non zero value very early on.
                // This cannot be our file.
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "m_pShared->m_dwSharedMemoryMapCounter = 0, we created memory map, last error = 0x%x",
                                ERROR_INVALID_DATA);
                __leave;
            }
        }

        //  validate that this is ours
        if (memcmp(&m_pShared->m_guidVersion, &m_guidV5, sizeof(GUID)) != 0)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "guid is not v4 guid, last error = 0x%x",
                            ERROR_INVALID_DATA);
            __leave;
        }

        // Acquire ownership of the shared mutex if there is one.
        DWORD dwMutexSuffix = m_pShared->m_dwMutexSuffix;

        if (dwMutexSuffix == 0)
        {
            // No mutex required; we don't need to lock before accessing the shared data.
        }
        else
        {
            // m_dwMutexSuffix != 0 implies one or the other of the following:
            // - We are creating a multi-file recording and the writer has not finished.
            // - We have a file collection that has temp files and there is >= 1 client before us.
            //   In this case, the writer may or may not have finished.

            // Either way, the mutex must exist. (Every file collection is created with a non-zero
            // mutex suffix and the mutex is held when m_dwMutexSuffix is set to 0 - using a Interlocked fn)
            WCHAR wszMutex[MAX_MUTEX_NAME_LEN];
            wsprintf(wszMutex, L"%ls%d", CDVRFileCollection::m_kwszSharedMutexPrefix, dwMutexSuffix);

            m_hSharedMutex = ::OpenMutexW(SYNCHRONIZE, FALSE /* Inheritable */, wszMutex);

            // if # temp files = 0 go on, writer may have been killed. We
            // want to be allow partial recoveries when multi-file recordings
            // were aborted.
            if (m_hSharedMutex == NULL)
            {
                dwLastError = ::GetLastError();

                if (dwLastError == ERROR_FILE_NOT_FOUND &&
                    m_pShared->m_dwMinTempFiles == 0    &&
                    m_pShared->m_dwMaxTempFiles == 0
                   )
                {
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "OpenMutex failed, last error = 0x%x, continuing since there are no temp files",
                                    dwLastError);

                    // Don't change anything in the shared memory section
                    // However, we shouldn't use m_dwWriterPid any more.
                    SetFlags(SideStepReaderRegistration);
                }
                else
                {
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "OpenMutex failed for mutex suffix %u, last error = 0x%x",
                                    dwMutexSuffix, dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    __leave;
                }
            }
        }

        // We don't really need to lock if m_hSharedMutex == NULL, but it does not hurt.
        // By calling it, we check m_pShared->m_nDataInconsistent uniformly.

        bLocked = 1;
        // The following call will automatically remap m_pShared if m_pShared->m_dwSharedMemoryMapCounter
        // != m_dwCurrentMemoryMapCounter.
        hr = Lock(pClientInfo, bReleaseSharedMemoryLock);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // We have the lock now. Nothing in m_pShared should change till we give it up

        //  Verify the guid once more. If it's our file, this won't have changed
        if (memcmp(&m_pShared->m_guidVersion, &m_guidV5, sizeof(GUID)) != 0)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "guid is not v4 guid, last error = 0x%x",
                            ERROR_INVALID_DATA);
            __leave;
        }

        if (dwMutexSuffix == 0)
        {
            // No mutex required; we don't need to lock before accessing the shared data.

            // m_dwMutexSuffix == 0 implies that there are no temp files and that
            // the writer is done.
            if (m_pShared->m_dwWriterPid != 0 ||
                m_pShared->m_nWriterHasBeenClosed == 0 || // Writer must set this to 0 before releasing the file collection object
                m_pShared->m_dwMinTempFiles > 0 ||
                m_pShared->m_dwMaxTempFiles > 0 ||
                m_pShared->m_dwMutexSuffix != 0  // It changed from 0 - this is not our file
               )
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                DvrIopDebugOut6(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "m_dwMutexSuffix == 0, Writer Pid = %u, WriterClosed = %u, Min Temp Files = %u, Max Temp Files = %u, mutex suffix = %u, last error = 0x%x",
                                m_pShared->m_dwWriterPid, m_pShared->m_nWriterHasBeenClosed,
                                m_pShared->m_dwMinTempFiles, m_pShared->m_dwMaxTempFiles,
                                m_pShared->m_dwMutexSuffix,
                                ERROR_INVALID_DATA);
                __leave;
            }

        }
        else
        {
            // m_pShared->m_dwMutexSuffix could have become 0.

            // m_dwMutexSuffix != 0 implies one or the other of the following:
            // - we are creating a multi-file recording and the writer has not finished.
            // - we have a file collection that has temp files and there is >= 1 client before us.
            //   In this case, the writer may or may not have finished.

            if (m_pShared->m_dwMinTempFiles == 0 &&
                m_pShared->m_dwMaxTempFiles == 0)
            {
                // We want to be tolerant here. The writer could have died
                // while creating the recording. We want to salvage as much of
                // the recording as possible. Do not bail
            }
            else
            {
                if (m_pShared->m_dwNumClients == 0)
                {
                    // We have opened the mapping and opened the mutex handle.
                    // But the collection has been shut down.
                    // All the temp files have been removed and deleted

                    // Note: The last reader may have closed the mutex handle for
                    // this collection and the m_dwMutexSuffix it was using could
                    // be being used by another file collection. It doesn't matter
                    // because of this check.

                    hrRet = E_FAIL;
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "File collection has temp files and has been shut donw; returning E_FAIL");
                    __leave;
                }
            }
        }

        // We have the lock now. The file size is locked till we release the lock.
        // So get the file size once again now and use this size to determine the
        // number of file nodes
        if (::GetFileInformationByHandle(hMMFile, &sFileInf) == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "GetFileInformationByHandle on ring buffer file failed, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        if (sFileInf.nFileSizeHigh > 0)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "nFileSizeHigh is not zero (= %u), last error = 0x%x",
                            sFileInf.nFileSizeHigh, ERROR_INVALID_DATA);
            __leave;
        }
        if (sFileInf.nFileSizeLow < sizeof(CSharedData))
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "File size is %u < (sizeofCSharedData) = %u (after locking), last error = 0x%x",
                            sFileInf.nFileSizeLow, sizeof(CSharedData), ERROR_INVALID_DATA);
            __leave;
        }

        DWORD dwSharedMemoryBytes = sFileInf.nFileSizeLow;

        // Note that IsBadWritePtr has not been called if we did not call ReopenMemoryMap in Lock()
        if (IsBadWritePtr(m_pShared, dwSharedMemoryBytes))
        {
            // Our memory map is not as large as the file. It should be
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "File size is %u IsbadWritePtr returned 1, last error = 0x%x",
                            sFileInf.nFileSizeLow, ERROR_INVALID_DATA);
            __leave;
        }
        else
        {
            // At least we know that m_pShared and all file nodes in m_pListBase have valid addresses
        }


        // We have verified that the numerator will not underflow
        DWORD dwMaxFiles = (dwSharedMemoryBytes - sizeof(CSharedData)) / sizeof(CSharedData::CFileInfo);

        if (dwSharedMemoryBytes <= sizeof(CSharedData) ||
            (dwSharedMemoryBytes - sizeof(CSharedData)) % sizeof(CSharedData::CFileInfo) != 0 ||
            dwMaxFiles > CDVRFileCollection::m_kMaxFilesLimit)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "nFileSizeLow (= %u) tells us this is not our file, last error = 0x%x",
                            sFileInf.nFileSizeLow, ERROR_INVALID_DATA);
            __leave;
        }

        m_dwMaxFiles = dwMaxFiles; // Not reliable - based on file size. beware!!

        ::CloseHandle(hMMFile);
        hMMFile = NULL;         // Don't use this any more

        // Thorough sanity check of the data

        hr = ValidateSharedMemory(m_pShared, m_pListBase, dwMaxFiles);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // One last time:
        if ((dwMutexSuffix == 0 && m_pShared->m_dwMutexSuffix != 0) || m_pShared->m_nDataInconsistent)
        {
            // This could not have changed. This is not our file
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "m_dwMutexSuffix was 0 is now %u, m_nDataInconsistent was 0 is no %u, last error = 0x%x",
                            m_pShared->m_dwMutexSuffix, m_pShared->m_nDataInconsistent,
                            ERROR_INVALID_DATA);
            __leave;
        }

        // Verify the guid once more. If it's our file, this won't have changed
        if (memcmp(&m_pShared->m_guidVersion, &m_guidV5, sizeof(GUID)) != 0)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "guid is not v4 guid, last error = 0x%x",
                            ERROR_INVALID_DATA);
            __leave;
        }

        // Now, we are satisfied that this file is our's!
        SetFlags (ShareValid) ;

        SetFlags(FirstMappingOpened);
        hrRet = S_OK;
    }
    __finally
    {
        if (bLocked)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock);
        }
        if (hMMFile)
        {
            ::CloseHandle(hMMFile);
        }
        if (SUCCEEDED(hrRet))
        {
            DVR_ASSERT(!IsFlagSet(Delete) && !IsFlagSet(NoSharedMutex), "");
            DVR_ASSERT(!IsFlagSet(Delete) && IsFlagSet(Mapped), "");
            if (pmsIndexGranularity)
            {
                *pmsIndexGranularity = m_pShared->m_msIndexGranularity;
            }
        }
        else
        {
            // To ensure that the ASSERT in Release() succeeds:
            if (m_pShared && !IsFlagSet(Mapped))
            {
                // We will never get here since teh shared section is always mapped for this
                // constructor.
                m_pShared->m_nWriterHasBeenClosed = 1;
            }
        }
        if (phr)
        {
            *phr = hrRet;
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRFileCollection::CDVRFileCollection

CDVRFileCollection::~CDVRFileCollection()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::~CDVRFileCollection"

    DVRIO_TRACE_ENTER();

    BOOL    bReleaseSharedMemoryLock;
    BOOL    bLocked = 0;

    __try
    {
        // TODO: @@@@ This ought to be moved to Release and done if bWriter is
        // set. That will make sure that no reader can open
        // stub files (that are not multi-file recordings) after the writer
        // is done (because the m_hRingBufferFile handle is opened with DELETE_ON_CLOSE).
        // If it's done in the destructor, all readers in the writer's
        // process must release the ring buffer: until they do, readers in other
        // processes (and the writer's process) will be able to open the ring buffer
        // after the writer closes it.
        //
        if (m_hRingBufferFile != INVALID_HANDLE_VALUE) {
            ::CloseHandle (m_hRingBufferFile) ;
        }

        if (m_pShared && IsFlagSet (ShareValid))
        {
            bLocked = 1;

            DVR_ASSERT(m_pClientInfo, "");

            HRESULT hr = Lock(m_pClientInfo, bReleaseSharedMemoryLock);


            if (hr != HRESULT_FROM_WIN32(ERROR_INVALID_DATA))
            {
                // We have a valid handle to the mutex, so this should not happen:
                DVR_ASSERT(hr != HRESULT_FROM_WIN32(WAIT_FAILED), "");

                // ReopenMemoryMap must have failed (assuming the previous assert
                // did not fire)
                DVR_ASSERT(m_pShared->m_dwSharedMemoryMapCounter >= m_dwCurrentMemoryMapCounter, "");

                // See the comment in Lock() where we handle failure of ReopenMemoryMap
            }

            for (int i = 0; i < MAX_READERS; i++)
            {
                if (m_apNotificationContext[i])
                {
                    // This should not happen. We should have unregistered all the
                    // readers befoore destroying this object (each reader holds a
                    // ref count on the object).
                    DVR_ASSERT(0, "Reader was not unregistered?");
                }
            }


            if (IsFlagSet(ReopenMemoryMapFailed))
            {
                DVR_ASSERT(m_pShared->m_dwNumClients > 0, "");
            }

            if (m_pShared->m_dwNumClients == 0 &&
                m_pShared->m_dwMaxTempFiles > 0 // Has temp files - is not a multi file recording
                                                // We don't want to zap the stub file (specifically, m_leFileList)
                                                // for multi-file recordings
               )
            {
                CSharedData::CFileInfo*   pFileInfo;

                SHARED_LIST_ENTRY*  pCurrent = &m_pShared->m_leFileList;

                while (NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
                {
                    pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
                    pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

                    DVR_ASSERT(pFileInfo->bmOpenByReader == 0,
                               "Reader ref count is not zero.");

                    // This will remove the node from the list when
                    // DeleteUnusedInvalidFileNodes is called. If !bPermanentFile,
                    // it will also cause the disk file to be deleted.
                    pFileInfo->bWithinExtent = CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER;
                }

                DWORD* pdwNumInvalidUndeletedTempFiles = NULL;

#if defined(DEBUG)
                DWORD dwNumInvalidUndeletedTempFiles;

                pdwNumInvalidUndeletedTempFiles = &dwNumInvalidUndeletedTempFiles;
#endif

                DeleteUnusedInvalidFileNodes(TRUE, pdwNumInvalidUndeletedTempFiles);

#if defined(DEBUG)
                if (dwNumInvalidUndeletedTempFiles > 0)
                {
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "Failed to delete %u temporary file%hs.",
                                    dwNumInvalidUndeletedTempFiles,
                                    dwNumInvalidUndeletedTempFiles == 1? "" : "s");
                }
#endif
            }
        }

    }
    __finally
    {
        delete [] m_pwszTempFilePath;

        delete [] m_pwszRingBufferFileName;

        delete [] m_pwszRingBufferFilePath;

        if (bLocked)
        {
            DVR_ASSERT(m_pClientInfo, "");
            Unlock(m_pClientInfo, bReleaseSharedMemoryLock);
        }
        if (IsFlagSet(Delete))
        {
            DVR_ASSERT(m_pShared, "");

            DVR_ASSERT(!IsFlagSet(Mapped), "");

            BYTE* pbShared = (BYTE*) m_pShared;
            delete [] pbShared;
            m_pShared = NULL;
            m_pListBase = NULL;
        }
        else if (IsFlagSet(Mapped))
        {
            DVR_ASSERT(m_pShared, "");

            ::UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
            m_pListBase = NULL;
        }
        else if (m_pShared)
        {
            DVR_ASSERT(0, "Neither the Mapped nor the Delete flag is set?");
        }
        if (m_hSharedMutex)
        {
            ::CloseHandle(m_hSharedMutex);
        }
        ::DeleteCriticalSection(&m_csLock);
    }

    DVRIO_TRACE_LEAVE0();

} // CDVRFileCollection::~CDVRFileCollection()


// ====== Refcounting

ULONG CDVRFileCollection::AddRef(const CClientInfo* pClientInfo)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::AddRef"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0,
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRFileCollection::AddRef


ULONG CDVRFileCollection::Release(const CClientInfo* pClientInfo)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::Release"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0,
              "m_nRefCount < 0 after InterlockedDecrement");

    // If m_pShared == NULL; the constructor failed and we
    // are cleaning up partially initalized stuff
    if (m_pShared && pClientInfo->bAmWriter)
    {
        BOOL    bReleaseSharedMemoryLock;

        // Go on even if Lock fails. Either we got back
        // WAIT_FAILED (assert that we don't) or the
        // data is inconsistent. In the latter, case,
        // we still have to clean up.
        HRESULT hr = Lock(pClientInfo, bReleaseSharedMemoryLock);

        // We have a valid handle to the mutex, so this should not happen:
        DVR_ASSERT(hr != HRESULT_FROM_WIN32(WAIT_FAILED), "");

        if (FAILED(hr))
        {
            // We should not fail for any otehr reason. Specifically, the
            // the writer never calls ReopenMemoryMap and doesn't have to
            // deal with failures in that function
            DVR_ASSERT(hr == HRESULT_FROM_WIN32(ERROR_INVALID_DATA), "");
        }

        FreeTerminatedReaderSlots(pClientInfo, 0 /* Already locked */ , 1 /* Close all handles */ );
        DVR_ASSERT(m_pShared->m_nWriterHasBeenClosed != 0, "Writer should have set this before releasing the object.");
        ::InterlockedExchange((PLONG) &m_pShared->m_dwWriterPid, 0);
        if (m_pShared->m_dwMaxTempFiles == 0)
        {
            DVR_ASSERT(m_pShared->m_dwMinTempFiles == 0, "");
            ::InterlockedExchange((PLONG) &m_pShared->m_dwMutexSuffix, 0);
        }
        ::InterlockedDecrement((PLONG) &m_pShared->m_dwNumClients);
        // The following assert is really to ensure that m_dwNumClients has not underflowed
        // and become MAXDWORD
        DVR_ASSERT(m_pShared->m_dwNumClients <= MAX_READERS + 1   /* 1 for the writer */, "");

        Unlock(pClientInfo, bReleaseSharedMemoryLock);
    }

    if (nNewRef == 0)
    {
        // Must call DebugOut before the delete because the
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        m_pClientInfo = (CClientInfo*) pClientInfo;
                     // hack - this is needed in the destructor to lock and unlock the object
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }


    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRFileCollection::Release


// ====== Helper methods

// This function is called by the writer to open a reader's event
HRESULT CDVRFileCollection::OpenEvent(IN DWORD i /* index of reader whose event should be opened */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::OpenEvent"

    DVRIO_TRACE_ENTER();
    HRESULT hrRet = S_OK;

    WCHAR wszEvent[MAX_EVENT_NAME_LEN];

    wsprintf(wszEvent, L"%s%u",
             CDVRFileCollection::m_kwszSharedEventPrefix,
             m_pShared->Readers[i].dwEventSuffix);

    m_pShared->Readers[i].hReaderEvent = ::OpenEventW(EVENT_MODIFY_STATE, FALSE /* inheritable */, wszEvent);
    if (m_pShared->Readers[i].hReaderEvent == NULL )
    {
        // The open can fail because the reader terminated.
        DWORD dwLastError = ::GetLastError();
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "OpenEventW failed for reader index %u, last error = 0x%x; reader will not be notified of events",
                        i, dwLastError);
        hrRet = HRESULT_FROM_WIN32(dwLastError);
        m_pShared->Readers[i].dwFlags |= CSharedData::CReaderInfo::DVRIO_READER_FLAG_EVENT_OPEN_FAILED;
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // CDVRFileCollection::OpenEvent

// We must hold the shared memory mutex when calling this function
// It is expected that only the writer calls this function. (Is there
// a way of asserting that?)
//
HRESULT CDVRFileCollection::CreateMemoryMap(IN const CClientInfo* pClientInfo,
                                            IN      DWORD           dwSharedMemoryBytes, // for the existing mapping
                                            IN      BYTE*           pbShared,            // existing mapping
                                            IN      DWORD           dwNewSharedMemoryBytes,
                                            IN OUT  DWORD&          dwCurrentMemoryMapCounter,
                                            IN      DWORD           dwCreationDisposition,
                                            IN      DWORD           dwFlagsAndAttributes,
                                            OUT     CSharedData*&   pSharedParam,
                                            OUT     HANDLE *        phFile OPTIONAL
                                            )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::CreateMemoryMap"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    DVR_ASSERT(!pbShared || !DvrIopIsBadReadPtr(pbShared, dwSharedMemoryBytes),
               "pbShared is a bad read pointer");

    DVR_ASSERT(dwCreationDisposition == CREATE_NEW || dwCreationDisposition == OPEN_EXISTING,
               "Bad creation disposition");

    // The following assert checks that we only grow the memory mapping
    DVR_ASSERT(dwNewSharedMemoryBytes > dwSharedMemoryBytes, "");

    if (dwCreationDisposition == CREATE_NEW)
    {
        DVR_ASSERT(dwSharedMemoryBytes == 0, "");
    }
    else
    {
        DVR_ASSERT(dwSharedMemoryBytes > 0, "");
    }

    HRESULT     hrRet;
    HANDLE      hMMFile = NULL;
    HANDLE      hFileMapping = NULL;
    CSharedData* pShared = NULL;
    BOOL        bFileCreated = FALSE ;

    pSharedParam = NULL;

    //  init if this param was passed in
    if (phFile) {
        (* phFile) = INVALID_HANDLE_VALUE ;
    }

    __try
    {
        DWORD dwLastError;

        // Create the file and map the section
        DVR_ASSERT(m_pwszRingBufferFileName, "");

        // Open the memory map file. We need the handle to create the memory
        // map; also the memory map name is derived from the file's information.
        // TODO: @@@@ DACL the file if dwCreationDisposition == CREATE_NEW.
        hMMFile = ::CreateFileW(m_pwszRingBufferFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,          // security attributes
                                dwCreationDisposition,
                                dwFlagsAndAttributes,
                                NULL           // template file
                               );
        if (hMMFile == INVALID_HANDLE_VALUE)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Failed to open ring buffer file, creation disposition = %u, last error = 0x%x",
                            dwCreationDisposition, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            hMMFile = NULL;
            __leave;
        }

        //  file was created; we delete if there's any subsequent failure
        bFileCreated = TRUE ;

        // Generate the name of the mapping object
        BY_HANDLE_FILE_INFORMATION  sFileInf;
        WCHAR                       wszMapping[64];

        if (::GetFileInformationByHandle(hMMFile, &sFileInf) == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "GetFileInformationByHandle on ring buffer file failed, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        // No one else other than the writer changes the file size. Fail this call if
        // the file is not the expected size.
        if (sFileInf.nFileSizeHigh > 0 || sFileInf.nFileSizeLow != dwSharedMemoryBytes)
        {
            hrRet = E_FAIL;
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "GetFileInformationByHandle returns file size hi =%u, lo = %u, we expect size = %u, returning hr = 0x%x",
                            sFileInf.nFileSizeHigh, sFileInf.nFileSizeLow, dwSharedMemoryBytes, hrRet);
            __leave;
        }

        // Create the memory mapping. This will grow the disk file to
        // the size specified as arguments to .CreateFileMappingW
        DWORD  i = 0;

        PACL                 pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwAclCreationStatus;
        SECURITY_ATTRIBUTES  sa;

        if (pClientInfo->dwNumSids > 0)
        {
            dwAclCreationStatus = ::CreateACL(pClientInfo->dwNumSids, pClientInfo->ppSids,
                                            SET_ACCESS, SECTION_ALL_ACCESS & (~SECTION_MAP_EXECUTE),
                                            SET_ACCESS, SECTION_QUERY|SECTION_MAP_WRITE|SECTION_MAP_READ,
                                            pACL,
                                            pSD
                                            );

            if (dwAclCreationStatus != ERROR_SUCCESS)
            {
                hrRet = HRESULT_FROM_WIN32(dwAclCreationStatus);
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "::CreateAcl failed, returning hr = 0x%x",
                                hrRet);
                __leave;
            }

            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
        }

        do
        {
            //  PREFIX note: PREFIX is on drugs; we check if the call succeeds
            //      to retrieve file information; if it fails, we never make it
            //      this far; the only other possibility it's whining about is
            //      that there are types of file systems that won't return
            //      the volume serial number, but we're based on NTFS, soo..
            //      that should not be a problem

            dwCurrentMemoryMapCounter++;

            wsprintf(wszMapping, L"Global\\MSDVRXMM_%u_%u_%u_%u",
                     sFileInf.dwVolumeSerialNumber ,
                     sFileInf.nFileIndexHigh,
                     sFileInf.nFileIndexLow,
                     dwCurrentMemoryMapCounter);

            // This extends the file to the new size
            hFileMapping = ::CreateFileMappingW(hMMFile,
                                                pClientInfo->dwNumSids > 0? &sa : NULL,
                                                PAGE_READWRITE,
                                                0,        /// high order size
                                                dwNewSharedMemoryBytes,
                                                wszMapping);
            dwLastError = ::GetLastError();

            if (hFileMapping == NULL || dwLastError == ERROR_ALREADY_EXISTS)
            {
                // Note that if the last error is ERROR_ALREADY_EXISTS.
                // the size of the mapping returned is the size of the mapping
                // when it was created, not the newly specified size. So the
                // disk file would not have been grown. This is how we'd like it
                // to be.

                // Any memory map that already exists is an indication that some
                // other app is poaching on our mapping name. Readers never try
                // to craete a mapping larger than the writer's dwCurrentMemoryMapCounter.
                // (The exception is that a reader could be racing with a writer to
                // create a memory mapping for a file that the writer is just creating,
                // but in that case, the file size is 0 and the reader's CreateFileMapping
                // will fail - because mappings can't be created for 0 size files. We handle
                // this race condition in the constructor.)

                // Note also that the very first time a reader creates the mapping, it
                // uses 0 for dwCurrentMemoryMapCounter

                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "CreateFileMappingW on ring buffer file failed, dwCurrentMemoryMapCounter = %u, last error = 0x%x",
                                dwCurrentMemoryMapCounter, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
            }
            else
            {
                // Success
                break;
            }
            if (++i == 20)
            {
                // 20 arbitrary

                // Use the hrRet set for the last failed CreateFileMappingW call
                // hrRet = E_FAIL;

                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Too many CreateFileMappingW failed, returning hr = 0x%x",
                                dwSharedMemoryBytes, hrRet);
                if (pClientInfo->dwNumSids > 0)
                {
                    ::FreeSecurityDescriptors(pACL, pSD);
                }
                __leave;
            }
        }
        while (1);
        if (pClientInfo->dwNumSids > 0)
        {
            ::FreeSecurityDescriptors(pACL, pSD);
        }

        if (phFile) {
            //  send it back out if desired and we've succeeded
            (* phFile) = hMMFile ;
        }
        else {
            //  close it out and don't send it back out
            ::CloseHandle(hMMFile);
        }

        hMMFile = NULL ;

        // Map the view
        pShared = (CSharedData*) MapViewOfFile(hFileMapping,
                                               FILE_MAP_ALL_ACCESS,
                                               0, 0, // file offset for start of map, high and low
                                               dwNewSharedMemoryBytes);
        if (pShared == NULL)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "MapViewOfFile on ring buffer file failed, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        if (dwSharedMemoryBytes > 0 &&
            memcmp(pbShared, pShared, dwSharedMemoryBytes) != 0)
        {
            // We expect the file to be in sync with the our last update to
            // the previous memory map.

            hrRet = E_FAIL;
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "memcmp of old and new memory map up %u bytes fails, returning hr = 0x%x",
                            dwSharedMemoryBytes, hrRet);
            __leave;
        }
        else if (dwSharedMemoryBytes == 0)
        {
            // Readers that are racing with the writer, poll this value, waiting for it
            // to be non-zero. Until this point, we rely on NT's zero'ing of memory pages
            // to set this value to 0. Note that if we write this value to the disk file
            // before creating the map, we have a different race condition: the reader's
            // CreateMemoryMapping will not fail if it creates the mapping while the file
            // is being created - that solution assumes that the file creation is synchronous.

            LONG nPrev = ::InterlockedExchange((PLONG) &pShared->m_dwSharedMemoryMapCounter, 0);

            DVR_ASSERT(nPrev == 0, "");
        }

        pSharedParam = pShared;
        pShared = NULL;
        hrRet = S_OK;
    }
    __finally
    {
        if (pShared)
        {
            ::UnmapViewOfFile(pShared);
        }
        if (hFileMapping)
        {
            ::CloseHandle(hFileMapping);
        }
        if (hMMFile)
        {
            ::CloseHandle(hMMFile);
        }

        //  cleanup in case of failure
        if (FAILED (hrRet)) {
            if (phFile && (* phFile) != INVALID_HANDLE_VALUE) {
                //  close it out so we don't send a valid handle out on failure
                ::CloseHandle (* phFile) ;
                (* phFile) = INVALID_HANDLE_VALUE ;
            }

            //  if the file was to be created new, and it was created, delete it
            if (dwCreationDisposition == CREATE_NEW && bFileCreated) {
                ::DeleteFileW(m_pwszRingBufferFileName);
            }
        }

        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::CreateMemoryMap


// We must hold the shared memory mutex when calling this function
// The writer will (should) never call this function.
HRESULT CDVRFileCollection::ReopenMemoryMap(IN const CClientInfo* pClientInfo)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::ReopenMemoryMap"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(!pClientInfo->bAmWriter, "");

    HRESULT     hrRet;
    HANDLE      hMMFile = NULL;
    HANDLE      hFileMapping = NULL;
    CSharedData* pShared = NULL;

    __try
    {
        DWORD dwLastError;

        // Create the file and map the section
        DVR_ASSERT(m_pwszRingBufferFileName, "");

        // Open the memory map file. We need the handle to create the memory
        // map; also the memory map name is derived from the file's information.
        // (Note for self: No need to specify security attributes here since this opens an
        // existing file - delete this part of the comment.)
        hMMFile = ::CreateFileW(m_pwszRingBufferFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,          // security attributes
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, // file flags and attributes
                                NULL           // template file
                               );
        if (hMMFile == INVALID_HANDLE_VALUE)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Failed to open ring buffer file, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            hMMFile = NULL;
            __leave;
        }

        // Generate the name of the mapping object
        BY_HANDLE_FILE_INFORMATION  sFileInf;
        WCHAR                       wszMapping[64];
        DWORD                       dwSharedMemoryBytes;

        if (::GetFileInformationByHandle(hMMFile, &sFileInf) == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "GetFileInformationByHandle on ring buffer file failed, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }


        // We do not expect the file to have got smaller. Be tolerant if the file size has not
        // changed
        if (sFileInf.nFileSizeHigh > 0 ||
            sFileInf.nFileSizeLow < sizeof(CSharedData) + m_dwMaxFiles*sizeof(CSharedData::CFileInfo))
        {
            hrRet = E_FAIL;
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "GetFileInformationByHandle returns file size hi =%u, lo = %u, we expect size >= %u, returning hr = 0x%x",
                            sFileInf.nFileSizeHigh, sFileInf.nFileSizeLow,
                            sizeof(CSharedData) + m_dwMaxFiles*sizeof(CSharedData::CFileInfo), hrRet);
            __leave;
        }

        dwSharedMemoryBytes = sFileInf.nFileSizeLow;

        DWORD dwMaxFiles = (dwSharedMemoryBytes - sizeof(CSharedData)) / sizeof(CSharedData::CFileInfo);

        if (dwSharedMemoryBytes <= sizeof(CSharedData) ||
            (dwSharedMemoryBytes - sizeof(CSharedData)) % sizeof(CSharedData::CFileInfo) != 0 ||
            dwMaxFiles > CDVRFileCollection::m_kMaxFilesLimit)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "nFileSizeLow (= %u) tells us this is not our file, last error = 0x%x",
                            sFileInf.nFileSizeLow, ERROR_INVALID_DATA);
            __leave;
        }

        //  PREFIX note: PREFIX is on drugs; we check if the call succeeds
        //      to retrieve file information; if it fails, we never make it
        //      this far; the only other possibility it's whining about is
        //      that there are types of file systems that won't return
        //      the volume serial number, but we're based on NTFS, soo..
        //      that should not be a problem

        // Create the memory mapping. This will grow the disk file to
        // the size specified as arguments to .CreateFileMappingW
        wsprintf(wszMapping, L"Global\\MSDVRXMM_%u_%u_%u_%u",
                 sFileInf.dwVolumeSerialNumber ,
                 sFileInf.nFileIndexHigh,
                 sFileInf.nFileIndexLow,
                 m_pShared->m_dwSharedMemoryMapCounter);

        PACL                 pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwAclCreationStatus;
        SECURITY_ATTRIBUTES  sa;

        if (pClientInfo->dwNumSids > 0)
        {
            // We are a reader. If we create this map, the writer is done with it and
            // we (and no one else in our user context) needs SECTION_EXTEND_SIZE on
            // this memory map. If we open an existing map, the security attributes
            // we specify are ignored anyway. (At least, they should be. MSDN says
            // nothing about this.)
            //
            // Note: Although we are a reader, we could be creating a new map. This can
            // happen if the writer expanded the memory mapping and then terminated
            // (causing the memory mapping to be deleted) before any reader opened that
            // memory mapping.
            dwAclCreationStatus = ::CreateACL(pClientInfo->dwNumSids, pClientInfo->ppSids,
                                            SET_ACCESS, SECTION_ALL_ACCESS & ~(SECTION_EXTEND_SIZE|SECTION_MAP_EXECUTE),
                                            SET_ACCESS, SECTION_QUERY|SECTION_MAP_WRITE|SECTION_MAP_READ,
                                            pACL,
                                            pSD
                                            );

            if (dwAclCreationStatus != ERROR_SUCCESS)
            {
                hrRet = HRESULT_FROM_WIN32(dwAclCreationStatus);
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "::CreateAcl failed, returning hr = 0x%x",
                                hrRet);
                __leave;
            }

            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
        }

        hFileMapping = ::CreateFileMappingW(hMMFile,
                                            pClientInfo->dwNumSids > 0? &sa : NULL,
                                            PAGE_READWRITE,
                                            0,        // high order size
                                            0,        // low order size 0 = entire file
                                            wszMapping);

        dwLastError = ::GetLastError();
        if (pClientInfo->dwNumSids > 0)
        {
            ::FreeSecurityDescriptors(pACL, pSD);
        }

        ::CloseHandle(hMMFile);
        hMMFile = NULL;         // Don't use this any more

        if (hFileMapping == NULL)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "CreateFileMappingW on ring buffer file failed, m_pShared->m_dwSharedMemoryMapCounter = %u, last error = 0x%x",
                            m_pShared->m_dwSharedMemoryMapCounter, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        // Map the view
        pShared = (CSharedData*) MapViewOfFile(hFileMapping,
                                               FILE_MAP_READ | FILE_MAP_WRITE,
                                               0, 0, // file offset for start of map, high and low
                                               0     // the entire file
                                              );
        if (pShared == NULL)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "MapViewOfFile on ring buffer file failed, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        ::CloseHandle(hFileMapping);
        hFileMapping = NULL;         // Don't use this any more


        if (IsBadWritePtr(pShared, dwSharedMemoryBytes))
        {
            // Our memory map is not as large as the file. It should be
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "File size is %u, but fewer bytes are mapped; IsBadWritePtr returned 1, last error = 0x%x",
                            sFileInf.nFileSizeLow, ERROR_INVALID_DATA);
            __leave;
        }
        else
        {
            // At least we know that pShared and all file nodes in its list have valid addresses
        }

        // If the flag is not set, the shared memory will be validated in the constructor
        // The constructor has to validate the shared memory since there is no guarantee
        // this function was called when the constructor locked the shared memory,
        if (IsFlagSet(FirstMappingOpened))
        {
            CSharedData::CFileInfo* pListBase = (CSharedData::CFileInfo*) (pShared + 1);

            HRESULT hr = ValidateSharedMemory(pShared, pListBase, dwMaxFiles);

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
        }

        // Do not do this until we are successful. We have to clean up m_pShared otherwise.
        ::UnmapViewOfFile(m_pShared);
        m_pShared = pShared;
        pShared = NULL;
        m_pListBase = (CSharedData::CFileInfo*) (m_pShared + 1);

        if (IsFlagSet(FirstMappingOpened))
        {
            m_dwMaxFiles = dwMaxFiles;
        }

        m_dwCurrentMemoryMapCounter = m_pShared->m_dwSharedMemoryMapCounter;
        hrRet = S_OK;
    }
    __finally
    {
        if (pShared)
        {
            ::UnmapViewOfFile(pShared);
        }
        if (hFileMapping)
        {
            ::CloseHandle(hFileMapping);
        }
        if (hMMFile)
        {
            ::CloseHandle(hMMFile);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::ReopenMemoryMap


HRESULT CDVRFileCollection::ValidateSharedMemory(IN CSharedData*               pShared,
                                                 IN CSharedData::CFileInfo*    pListBase,
                                                 IN DWORD                      dwMaxFiles)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::ValidateSharedMemory"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    __try
    {
        DWORD dwLastError;

        if (pShared->m_dwMaxTempFiles < pShared->m_dwMinTempFiles ||
            dwMaxFiles < pShared->m_dwMaxTempFiles ||
            pShared->m_cnsStartTime > pShared->m_cnsEndTime ||
            pShared->m_dwNumClients > MAX_READERS + 1   /* 1 for the writer */ ||
            pShared->m_nFlags > CSharedData::StartTimeFixedAtZero
        )
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); //ASSERT (0) ;
            DvrIopDebugOut8(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Start time == %I64u, End Time = %I64u, NumClients = %u, Max clients = %u, Min Temp Files = %u, Max Temp Files = %u, Max Files = %u, pShared->m_nFlags=%u",
                            pShared->m_cnsStartTime, pShared->m_cnsEndTime, pShared->m_dwNumClients, MAX_READERS+1,
                            pShared->m_dwMinTempFiles, pShared->m_dwMaxTempFiles, dwMaxFiles,
                            pShared->m_nFlags);
            __leave;
        }

        for (DWORD i = 0; i < MAX_READERS; i++)
        {
            if (pShared->Readers[i].dwEventSuffix && (pShared->Readers[i].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE) == 0)
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Reader[%0d].dwFlags = %u (CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE not set), but dwEventSuffix is not zero; it is %u",
                                i, pShared->Readers[i].dwFlags, pShared->Readers[i].dwEventSuffix);
                __leave;
            }
            if (pShared->Readers[i].dwEventSuffix == 0 && pShared->Readers[i].hReaderEvent)
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Reader[%0d].dwEventSuffix is zero'd, but hReaderEvent = 0x%p",
                                i, pShared->Readers[i].hReaderEvent);
                __leave;
            }
            if (pShared->Readers[i].dwFlags > (CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE | CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP | CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE | CSharedData::CReaderInfo::DVRIO_READER_FLAG_EVENT_OPEN_FAILED))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Reader[%0d].dwFlags = %u > (CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE | CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP | CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE) = %u ",
                                i, pShared->Readers[i].dwFlags, (CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE | CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP | CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE));
                __leave;
            }
            if (pShared->Readers[i].dwMsg > (CSharedData::CReaderInfo::DVRIO_READER_REQUEST_DONE | CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP | CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Reader[%0d].dwMsg = %u > (CSharedData::CReaderInfo::DVRIO_READER_REQUEST_DONE | CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP | CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE) = %u ",
                                i, pShared->Readers[i].dwMsg, (CSharedData::CReaderInfo::DVRIO_READER_REQUEST_DONE | CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP | CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE));
                __leave;
            }
        }

        if (pShared->m_leFileList.Index != SHARED_LIST_NULL_POINTER ||
            (pShared->m_leFileList.Flink >= dwMaxFiles && pShared->m_leFileList.Flink != SHARED_LIST_NULL_POINTER) ||
            (pShared->m_leFileList.Blink >= dwMaxFiles && pShared->m_leFileList.Blink != SHARED_LIST_NULL_POINTER))
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "m_leFileList: Index = %u, Blink = %u, Flink = %u",
                            i, pShared->m_leFileList.Index,
                            pShared->m_leFileList.Blink, pShared->m_leFileList.Flink);
            __leave;
        }

        if (pShared->m_leFreeList.Index != SHARED_LIST_NULL_POINTER ||
            (pShared->m_leFreeList.Flink >= dwMaxFiles && pShared->m_leFreeList.Flink != SHARED_LIST_NULL_POINTER) ||
            (pShared->m_leFreeList.Blink >= dwMaxFiles && pShared->m_leFreeList.Blink != SHARED_LIST_NULL_POINTER))
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "m_leFreeList: Index = %u, Blink = %u, Flink = %u",
                            i, pShared->m_leFreeList.Index,
                            pShared->m_leFreeList.Blink, pShared->m_leFreeList.Flink);
            __leave;
        }

        for (i = 0; i < dwMaxFiles; i++)
        {
            if (pListBase[i].leListEntry.Index != i ||
                (pListBase[i].leListEntry.Flink >= dwMaxFiles && pListBase[i].leListEntry.Flink != SHARED_LIST_NULL_POINTER) ||
                (pListBase[i].leListEntry.Blink >= dwMaxFiles && pListBase[i].leListEntry.Blink != SHARED_LIST_NULL_POINTER))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pListBase[%0d].leListEntry: Index = %u, Blink = %u, Flink = %u",
                                i, pListBase[i].leListEntry.Index,
                                pListBase[i].leListEntry.Blink, pListBase[i].leListEntry.Flink);
                __leave;
            }
        }

        // Now go through the file list and make sure nodes in it are good.

        // The file list could have stale file nodes in the front of the
        // list (e.g., files open by paused readers). So, we cannot assert
        // that cnsStartTime of the first node in the list is >=
        // pShared->m_cnsStartTime.

        // TODO: We have to check that at least open file node that is in the
        // ring buffer extent has a start time >= pShared->m_cnsStartTime

        // TODO: validate that the attributes file string is null-terminated

        CSharedData::CFileInfo*   pFileInfo;
        SHARED_LIST_ENTRY*  pCurrent = &pShared->m_leFileList;

        QWORD        cnsLastStartTime ;
        int          nTempFiles ;

        nTempFiles = (int) pShared->m_dwMaxTempFiles;

        cnsLastStartTime = 0;
        i = 0;
        while (NEXT_SHARED_LIST_NODE(&pShared->m_leFileList, pListBase, pCurrent) != &pShared->m_leFileList)
        {
            i++;
            if (i > dwMaxFiles)
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "More than dwMaxFiles nodes in the file list");
                __leave;
            }

            pCurrent = NEXT_SHARED_LIST_NODE(&pShared->m_leFileList, pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            if ((DWORD) pFileInfo->bWithinExtent > CSharedData::CFileInfo::DVRIO_EXTENT_LAST)
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File list node %u: extent = %u > max legal extent = %u",
                                i, pFileInfo->bWithinExtent, CSharedData::CFileInfo::DVRIO_EXTENT_LAST);
                __leave;
            }

            if ((DWORD) pFileInfo->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER)
            {
                // Do nothing
            }
            else
            {
                if (pFileInfo->cnsStartTime < cnsLastStartTime)
                {
                    hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                    DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "File list node %u: start time = %I64u < last start time = %I64u",
                                    i, pFileInfo->cnsStartTime, cnsLastStartTime);
                    __leave;
                }
                cnsLastStartTime = pFileInfo->cnsStartTime;
            }

            if (pFileInfo->cnsStartTime > pFileInfo->cnsEndTime)
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File list node %u: start time = %I64u > end time = %I64u",
                                i, pFileInfo->cnsStartTime, pFileInfo->cnsEndTime);
                __leave;
            }
            if (pFileInfo->bPermanentFile == 0 && pFileInfo->bWithinExtent != CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER)
            {
                nTempFiles--;
                if (nTempFiles < 0)
                {
                    hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "File list node %u: More than %u temp files",
                                    i, pShared->m_dwMaxTempFiles);
                    __leave;
                }
            }
            if (pFileInfo->wFileFlags > (CSharedData::CFileInfo::OpenFromFileCollectionDirectory |
                                         CSharedData::CFileInfo::FileDeleted                     |
                                         CSharedData::CFileInfo::DoNotDeleteFile
                                        )
               )
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File list node %u: file flags = %u > max file flags = %u",
                                i, pFileInfo->wFileFlags,
                                (CSharedData::CFileInfo::OpenFromFileCollectionDirectory |
                                 CSharedData::CFileInfo::FileDeleted                     |
                                 CSharedData::CFileInfo::DoNotDeleteFile
                                )
                               );
                __leave;
            }
            if (pFileInfo->IsFlagSet(CSharedData::CFileInfo::FileDeleted) &&
                (pFileInfo->bWithinExtent != CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER ||
                 pFileInfo->IsFlagSet(CSharedData::CFileInfo::DoNotDeleteFile) ||
                 pFileInfo->bPermanentFile != 0))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut5(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File list node %u: file flags = %u (FileDeleted=%u set), but file is not temp, or DoNotDeleteFile flag (=%u) is also set, or is within extent, extent = %u",
                                i, pFileInfo->wFileFlags,
                                CSharedData::CFileInfo::FileDeleted,
                                CSharedData::CFileInfo::DoNotDeleteFile,
                                pFileInfo->bWithinExtent
                               );
                __leave;
            }
            if (pFileInfo->IsFlagSet(CSharedData::CFileInfo::DoNotDeleteFile) && pFileInfo->bPermanentFile != 0)
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File list node %u: file flags = %u (DoNotDeleteFile=%u set), but file is not temp file",
                                i, pFileInfo->wFileFlags,
                                CSharedData::CFileInfo::DoNotDeleteFile
                               );
                __leave;
            }
            for (int j = 0; j < sizeof(pFileInfo->wszFileName)/sizeof(WCHAR); j++)
            {
                if (pFileInfo->wszFileName[j] == L'\0')
                {
                    break;
                }
            }
            if (j == sizeof(pFileInfo->wszFileName)/sizeof(WCHAR))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File list node %u: file name not NULL terminated",
                                i);
                __leave;
            }

            // We haven't checked that all file id's are unique. Also that the
            // bWithinExtent members are "ordered".
        }

        // Now the free list

        DWORD nFileListNodes = i; // for debugging only

        // Don't reset i
        pCurrent = &pShared->m_leFreeList;
        while (NEXT_SHARED_LIST_NODE(&pShared->m_leFreeList, pListBase, pCurrent) != &pShared->m_leFreeList)
        {
            i++;
            if (i > dwMaxFiles)
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);//ASSERT (0) ;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "More than dwMaxFiles nodes in the file + free list");
                __leave;
            }

            pCurrent = NEXT_SHARED_LIST_NODE(&pShared->m_leFreeList, pListBase, pCurrent);
            // pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);
        }
        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::ValidateSharedMemory

void CDVRFileCollection::DeleteUnusedInvalidFileNodes(
    BOOL   bRemoveAllNodes,
    DWORD* pdwNumInvalidUndeletedTempFiles OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::DeleteUnusedInvalidFileNodes"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(!pdwNumInvalidUndeletedTempFiles ||
               !DvrIopIsBadWritePtr(pdwNumInvalidUndeletedTempFiles, 0),
               "pdwNumInvalidUndeletedTempFiles is a bad write pointer");

    DWORD dwNumUndeletedFiles = 0;
    CSharedData::CFileInfo*   pFileInfo;

    DVR_ASSERT(m_pShared, "");

    SHARED_LIST_ENTRY*  pCurrent = &m_pShared->m_leFileList;

    while (NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
    {
        BOOL bDecrement = 0;

        pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
        pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);
        if (!pFileInfo->bPermanentFile && !pFileInfo->bWithinExtent
            // Delete it anyway: it has fallen out of the buffer. We can do this because
            // files are opened with FILE_SHARE_DELETE. We cannot release the file node
            // however, since the reader that has the file open expects to find this node
            // when it closes the file.
            // && pFileInfo->bmOpenByReader == 0
           )
        {
            DVR_ASSERT(pFileInfo->wszFileName,
                       "File name is NULL?!");

            ::InterlockedIncrement(&m_pShared->m_nDataInconsistent);
            bDecrement = 1;
            if (pFileInfo->IsFlagSet(CSharedData::CFileInfo::FileDeleted | CSharedData::CFileInfo::DoNotDeleteFile))
            {
                // If either flags is set, do nothing
            }
            else if (!::DeleteFileW(pFileInfo->wszFileName))
            {
                DWORD dwLastError = ::GetLastError();

                if (dwLastError != ERROR_FILE_NOT_FOUND)
                {
                    // This should not happen since temp files are open with FILE_SHARE_DELETE

                    dwNumUndeletedFiles++;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "Could not delete file although reader ref count = 0, last error = 0x%x",
                                    dwLastError);
                    if (!bRemoveAllNodes)
                    {
                        // We leave the node as is; we will try the delete  again
                        // in subsequent calls to this function
                        ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);
                        continue;
                    }
                }
                else
                {
                    // else file already deleted (not by this function) - some one is meddling with the files
                }

                pFileInfo->SetFlags(CSharedData::CFileInfo::FileDeleted);
            }
            else
            {
                // file has just been deleted
                pFileInfo->SetFlags(CSharedData::CFileInfo::FileDeleted);
            }

            if (pFileInfo->bmOpenByReader != 0)
            {
                // Some reader has the file open. Hold on to the node

                // If we are removing all nodes, we should have verified
                // that there are no clients of the share; so no reader
                // should have this file open
                DVR_ASSERT(!bRemoveAllNodes, "");

                ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);
                continue;
            }
        }
        else if (!pFileInfo->bWithinExtent && pFileInfo->bmOpenByReader == 0)
        {
            // Permanent file not within extent and has no reader; remove the node
            DVR_ASSERT(pFileInfo->bPermanentFile,"");
        }
        else if (!bRemoveAllNodes)
        {
            DVR_ASSERT(pFileInfo->bWithinExtent || pFileInfo->bmOpenByReader != 0, "");
            continue;
        }
        else
        {
            // bRemoveAllNodes is true, so this is a call from the destructor.
            // The destructor sets pFileInfo->bWithinExtent to CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER.
            // So pFileInfo->bmOpenByReader != 0. Assert this.

            DVR_ASSERT(pFileInfo->bmOpenByReader != 0, "");

            // Note that pFileInfo->bmOpenByReader != 0 is an
            // error, but the destructor has already asserted
            // pFileInfo->bmOpenByReader == 0 to warn anyone
            // debugging this.
        }

        // Remove the node.

        SHARED_LIST_ENTRY* pTemp = PREVIOUS_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);

        ::InterlockedIncrement(&m_pShared->m_nDataInconsistent);
        RemoveEntrySharedList(&m_pShared->m_leFileList, m_pListBase, pCurrent);
        InsertTailSharedList(&m_pShared->m_leFreeList, m_pListBase, &m_pShared->m_leFreeList, pCurrent);
        ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);
        if (bDecrement)
        {
            ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);
        }

        pFileInfo->Cleanup();
        pCurrent = pTemp;
    }

    if (pdwNumInvalidUndeletedTempFiles)
    {
        *pdwNumInvalidUndeletedTempFiles = dwNumUndeletedFiles;
    }

    DVRIO_TRACE_LEAVE0();

    return;

} // CDVRFileCollection::DeleteUnusedInvalidFileNodes


HRESULT CDVRFileCollection::UpdateTimeExtent(BOOL bNotifyReaders)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::UpdateTimeExtent"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(m_pShared, "");

    HRESULT      hrRet;
    DWORD        dwNumMinTempFiles = m_pShared->m_dwMinTempFiles;
    DWORD        dwNumMaxTempFiles = m_pShared->m_dwMaxTempFiles;
    CSharedData::CFileInfo*   pFileInfo;
    BOOL         bInExtent = TRUE;
    SHARED_LIST_ENTRY*  pCurrent = &m_pShared->m_leFileList;
    CSharedData::CFileInfo*   pEnd = NULL;    // pointer to node that has the end time

    CSharedData::CFileInfo*   pStartMin = NULL;  // pointer to node that has the start time if the ring buffer has only m_dwMinTempFiles files
    CSharedData::CFileInfo*   pStartMax = NULL;  // pointer to node that has the start time if the ring buffer has > m_dwMinTempFiles files

    BOOL bRevise = 0; // If 1, update bWithinExtent of nodes from pStartMax through pStartMin
    BOOL bPermAdd = 0;

    SHARED_LIST_ENTRY*   pleStartMin = NULL; // Corresponding to pStartMin
    SHARED_LIST_ENTRY*   pleStartMax = NULL; // Corresponding to pStartMax
    SHARED_LIST_ENTRY*   pleEnd = NULL;      // Corresponding to the last node in the list

    READER_BITMASK       bmFileGone = 0;
    READER_BITMASK       bmFallingOutOfRingBuffer = 0;

    // Only clients in the writer process can notify readers; this is because the
    // event handles in the shared data section are valid only in the writer's process.
    DVR_ASSERT(!bNotifyReaders || ::GetCurrentProcessId() == m_pShared->m_dwWriterPid, "");

    ::InterlockedIncrement(&m_pShared->m_nDataInconsistent);

    while (PREVIOUS_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
    {
        pCurrent = PREVIOUS_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
        pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

        if (pFileInfo->cnsStartTime == pFileInfo->cnsEndTime &&
            pFileInfo->cnsStartTime != MAXQWORD)
        {
            // Regardless of bInExtent, this node is not in the
            // ring buffer's extent
            pFileInfo->bWithinExtent = CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER;
            continue;
        }

        if (!bInExtent)
        {
             DVR_ASSERT(dwNumMinTempFiles == 0, "");

            if (dwNumMaxTempFiles)
            {
                if (!pFileInfo->bPermanentFile)
                {
                    dwNumMaxTempFiles--;
                }
                if (pFileInfo->bmOpenByReader != 0  &&
                    pFileInfo->bWithinExtent != CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER)
                {
                    // A reader holds this file open. It doesn't matter
                    // if this file is temp or permanent; there are no more
                    // than m_dwNumMaxTempFiles from here on to the end of
                    // the list.

                    // Update the bWithinExtent field of all nodes
                    // from here through pleStartMin or pleEnd.
                    bRevise = 1;
                    pStartMax = pFileInfo;
                    pleStartMax = pCurrent;
                    bPermAdd = 1; // Add on any files just before this that are permanent
                }
                else if (bPermAdd)
                {
                    DVR_ASSERT(pStartMax, "");

                    // bPermAdd remains on iff the current file is permanent
                    bPermAdd = pFileInfo->bPermanentFile;
                    if (bPermAdd) // i.e., current file is permanent
                    {
                        // Extend the ring buffer with the permanent file
                        pStartMax = pFileInfo;
                        pleStartMax = pCurrent;
                    }
                }
            }
            else if (bPermAdd)
            {
                DVR_ASSERT(pStartMax, "");

                // bPermAdd remains on iff the current file is permanent
                bPermAdd = pFileInfo->bPermanentFile;
                if (bPermAdd) // i.e., current file is permanent
                {
                    // Extend the ring buffer with the permanent file
                    pStartMax = pFileInfo;
                    pleStartMax = pCurrent;
                }
            }

            // We may have to revise this after this loop
            pFileInfo->bWithinExtent = CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER;

            continue;
        }
        if (!pEnd)
        {
            pEnd = pFileInfo;

            // It is possible that pStartMin can remain NULL even though pStartMax != NULL.
            // This can happen in the case that m_dwNumMinTempFiles == 0 and m_dwNumMaxTempFiles > 0
            pleEnd = pCurrent;
        }
        if (dwNumMinTempFiles || pFileInfo->bPermanentFile)
        {
            pStartMin = pFileInfo;
            pleStartMin = pCurrent;
            DVR_ASSERT(bPermAdd == 0, "");

        }
        if (!pFileInfo->bPermanentFile)
        {
            if (dwNumMinTempFiles)
            {
                dwNumMinTempFiles--;
                DVR_ASSERT(dwNumMaxTempFiles > 0, "");
                dwNumMaxTempFiles--;
            }
            else
            {
                // We have found one more temp file than
                // m_dwMinTempFiles. The next valid node in the list
                // has been marked as pStartMin

#if defined(DEBUG)

                CSharedData::CFileInfo*   pFileInfoTemp = NULL;
                SHARED_LIST_ENTRY*        pleTemp = pCurrent;

                pleTemp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pleTemp);
                while (pleTemp != &m_pShared->m_leFileList)
                {
                    pFileInfoTemp = CONTAINING_RECORD(pleTemp, CSharedData::CFileInfo, leListEntry);

                    if (pFileInfoTemp->cnsStartTime == pFileInfoTemp->cnsEndTime &&
                        pFileInfoTemp->cnsStartTime != MAXQWORD)
                    {
                        pleTemp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pleTemp);
                        continue;
                    }
                    DVR_ASSERT(pleTemp == pleStartMin, "");
                    break;
                }
                DVR_ASSERT(pleTemp != &m_pShared->m_leFileList, "");

#endif // if defined(DEBUG)

                bInExtent = FALSE;

                // Go through rest of nodes in the list and
                // set their bWithinExtent to FALSE.
                // We will revise this if we find a reader has
                // a file open before dwNumMaxTempFiles falls to 0

                // But before that, is pCurrent open by a reader? AND has
                // it been marked as being out of the extent before? (If it
                // has, do not pull it back into the extent, otherwise files
                // that are opened by stall readers will bounce into and out
                // of the extent.)
                if (dwNumMaxTempFiles)
                {
                    dwNumMaxTempFiles--;
                    DVR_ASSERT(bPermAdd == 0, "");
                    if (pFileInfo->bmOpenByReader != 0 &&
                        pFileInfo->bWithinExtent != CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER)
                    {
                        // Update the bWithinExtent field of all nodes
                        // from here through pStartMin
                        bRevise = 1;
                        pStartMax = pFileInfo;
                        pleStartMax = pCurrent;
                        bPermAdd = 1; // Add on any previous files just before this that are permanent
                    }
                }
            }
        }
        else
        {
            // Permanent files extend the extent of the ring buffer extent
            // Nothing to do except to update the bWithinExtent member
        }
        pFileInfo->bWithinExtent = bInExtent? CSharedData::CFileInfo::DVRIO_EXTENT_IN_RING_BUFFER : CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER;
    }
    if (pEnd == NULL || (pStartMin == NULL && pStartMax == NULL))
    {
        // Shouldn't happen that pEnd is NULL and one of the other two is not NULL
        // (that'd be an error in this function).
        DVR_ASSERT(pEnd != NULL || (pStartMin == NULL && pStartMax == NULL), "");

        // If pEnd is not NULL and both the other two are NULL, that means:
        // - we found nodes in the list (pEnd != NULL)
        // - m_dwNumMinTempFiles == 0 and the last node in the list is a temp node (pStartMin == NULL)
        // - the sublist containing the last m_dwNumMaxTempFiles temp nodes in the list and as many permanent nodes
        //   as possible are not held open by any readers
        // This is not an error and should not be asserted. It makes sense to assert this only if we restrict
        // m_dwNumMaxTempFiles == 0 when m_dwNumMinTempFiles == 0 - in that case the list has temp nodes when it
        // should not have any temp nodes.

        m_pShared->m_cnsStartTime = m_pShared->m_cnsEndTime = 0;

        hrRet = S_FALSE;
    }
    else
    {
        m_pShared->m_cnsStartTime = pStartMax? pStartMax->cnsStartTime : pStartMin->cnsStartTime;
        m_pShared->m_cnsEndTime = pEnd->cnsEndTime;
        DVR_ASSERT((m_pShared->m_cnsStartTime < m_pShared->m_cnsEndTime) ||
                   (m_pShared->m_cnsStartTime == m_pShared->m_cnsEndTime && m_pShared->m_cnsStartTime == MAXQWORD),
                   "");

        if (bRevise)
        {
            // Note: pStartMin can be NULL; see an earlier comment in this function.

            // Revise all nodes from pleStartMax up to and excluding pleStartMin or
            // up to and including pleEnd. Stop when either pleEnd or pleStartMin is hit.

            DVR_ASSERT(pStartMax, "");
            DVR_ASSERT(pStartMin != pStartMax, ""); // Either pStartMin is NULL or it is a node following pStartMax
            DVR_ASSERT(pleStartMin != pleStartMax, ""); // Either pleStartMin is NULL or it is a node following pleStartMax
            DVR_ASSERT(pleStartMax, "");

            // Actually pleEnd will be non-NULL since pEnd != NULL, so this assert is
            // not very useful:
            DVR_ASSERT(pleStartMin || pleEnd, "");

            pCurrent = pleStartMax;
            do
            {
                DVR_ASSERT(pCurrent != &m_pShared->m_leFileList, "");
                pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

                DVR_ASSERT(pFileInfo->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER, "");

                if (pFileInfo->cnsStartTime == pFileInfo->cnsEndTime &&
                    pFileInfo->cnsStartTime != MAXQWORD)
                {
                    // do nothing, it remains outside the ring buffer
                }
                else
                {
                    pFileInfo->bWithinExtent = CSharedData::CFileInfo::DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER;

                    if (bNotifyReaders)
                    {
                        READER_BITMASK bm = pFileInfo->bmOpenByReader;
                        int i = 0;

                        for (; bm; bm >>= 1, i++)
                        {
                            if ((bm & 1) == 0)
                            {
                                continue;
                            }

                            bmFallingOutOfRingBuffer |= (1 << i);

                            // DVR_ASSERT(m_pShared->Readers[i].hReaderEvent, "");
                            DVR_ASSERT(m_pShared->Readers[i].dwEventSuffix, "");

                            if (m_pShared->Readers[i].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP)
                            {
                                m_pShared->Readers[i].dwFlags &= ~CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP;
                                m_pShared->Readers[i].dwMsg |= CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP;
                                if (!m_pShared->Readers[i].hReaderEvent &&
                                    (m_pShared->Readers[i].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_EVENT_OPEN_FAILED) == 0)
                                {
                                    // Open the event and ignore the returned status
                                    OpenEvent(i);
                                }

                                if (m_pShared->Readers[i].hReaderEvent)
                                {
                                    ::SetEvent(m_pShared->Readers[i].hReaderEvent);
                                }
                            }
                        }
                    }
                }

                if (pCurrent == pleEnd)
                {
                    break;
                }
                pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            }
            while (pCurrent != pleStartMin);
        }
        else
        {
            DVR_ASSERT(pStartMax == NULL, "");
            DVR_ASSERT(pleStartMax == NULL, "");
        }
        hrRet = S_OK;
    }
    ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);

    // Now warn readers about CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE. If a reader has this warning as well
    // as CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP issued to it in this function call, it will see both messages
    // together because it has to get the shared data mutex before looking for the message and we hold
    // that mutex.
    if (bNotifyReaders)
    {
        CSharedData::CFileInfo*   pFileInfoTmp;

        DVR_ASSERT(m_pShared, "");

        SHARED_LIST_ENTRY*  pCurrentTmp = &m_pShared->m_leFileList;
        BOOL bCaughtUp = 1;

        pCurrentTmp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrentTmp);
        while (pCurrentTmp != &m_pShared->m_leFileList)
        {
            pFileInfoTmp = CONTAINING_RECORD(pCurrentTmp, CSharedData::CFileInfo, leListEntry);
            if (pFileInfoTmp->bWithinExtent != CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER)
            {
                // All done
                break;
            }

            READER_BITMASK bm = pFileInfoTmp->bmOpenByReader;
            int i = 0;

            for (; bm; bm >>= 1, i++)
            {
                if ((bm & 1) == 0)
                {
                    continue;
                }

                // DVR_ASSERT(m_pShared->Readers[i].hReaderEvent, "");
                DVR_ASSERT(m_pShared->Readers[i].dwEventSuffix, "");

                bmFileGone |= (1 << i);

                if (m_pShared->Readers[i].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE)
                {
                    m_pShared->Readers[i].dwFlags &= ~CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE;
                    m_pShared->Readers[i].dwMsg |= CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE;
                    if (!m_pShared->Readers[i].hReaderEvent &&
                        (m_pShared->Readers[i].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_EVENT_OPEN_FAILED) == 0)
                    {
                        // Open the event and ignore the returned status
                        OpenEvent(i);
                    }

                    if (m_pShared->Readers[i].hReaderEvent)
                    {
                        ::SetEvent(m_pShared->Readers[i].hReaderEvent);
                    }
                }
            }

            pCurrentTmp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrentTmp);
        }

        // In some cases, e.g., when this function is called by SetNumTempFiles
        // or SetFileTimes, the ring buffer extent could have changed so that
        // some readers have actually caught up.

        for (int i = 0; i < MAX_READERS; i++)
        {
            READER_BITMASK  bmI = 1 << i;

            if (!(bmFallingOutOfRingBuffer & bmI))
            {
                // This reader is not falling out of the ring buffer any more
                m_pShared->Readers[i].dwFlags |= CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP;
                m_pShared->Readers[i].dwMsg &= ~CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP;
            }

            if (!(bmFileGone & bmI))
            {
                // This reader does not have open a file that has fallen out of the ring buffer
                m_pShared->Readers[i].dwFlags |= CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE;
                m_pShared->Readers[i].dwMsg &= ~CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE;
            }

            // We could reset the event if both messages have been cleared, but
            // there's not much point in that - the notification thread may
            // already have queued the notification
        }
    }

    DVRIO_TRACE_LEAVE0();

    return hrRet;

} // CDVRFileCollection::UpdateTimeExtent

HRESULT CDVRFileCollection::NotificationRoutine(IN NotificationContext* p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::NotificationRoutine"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!p || DvrIopIsBadWritePtr(p, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    DVR_ASSERT(p->m_pFileCollection == this, "");

    DWORD dwReaderIndex = p->m_FileCollectionInfo.dwReaderIndex;

    DVR_ASSERT(dwReaderIndex < MAX_READERS, "");

    BOOL    bReleaseSharedMemoryLock;
    BOOL    bUnlocked = 0;

    hrRet = E_FAIL;

    __try
    {
        // NOTE: Currently, the sids are NOT set in p->m_FileCollectionInfo
        // See the constructor of NotificationContext
        HRESULT hr = Lock(&p->m_FileCollectionInfo, bReleaseSharedMemoryLock);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        if (p != m_apNotificationContext[dwReaderIndex])
        {
            if (m_apNotificationContext[dwReaderIndex] == NULL)
            {
                // Reader has completed and is waiting for callbacks to complete
                hrRet = S_OK;
                __leave;
            }
            DVR_ASSERT(p == m_apNotificationContext[dwReaderIndex], "");
            hrRet = E_UNEXPECTED;
            __leave;
        }

        if ((m_pShared->Readers[dwReaderIndex].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE) == 0)
        {
            hrRet = E_UNEXPECTED;
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "dwFlags for reader index %u is not is use, flag = %u, returning hr = 0x%x",
                            dwReaderIndex, m_pShared->Readers[dwReaderIndex].dwFlags, hrRet);
            __leave;
        }

        DWORD dwMsg = m_pShared->Readers[dwReaderIndex].dwMsg & (CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP | CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE);

        m_pShared->Readers[dwReaderIndex].dwMsg &= ~(CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP | CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE);

        DVR_ASSERT(p->m_hReaderEvent, "");

        // Auto reset now: ::ResetEvent(p->m_hReaderEvent);

        // Release the lock
        Unlock(&p->m_FileCollectionInfo, bReleaseSharedMemoryLock);
        bUnlocked = 1;

        if (dwMsg > 0 && p->m_pfnCallback)
        {
            DWORD dwReason = DVRIO_NOTIFICATION_REASON_NONE;

            if (dwMsg & CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP)
            {
                dwReason |= DVRIO_NOTIFICATION_REASON_CATCH_UP;
            }
            if (dwMsg & CSharedData::CReaderInfo::DVRIO_READER_WARNING_FILE_GONE)
            {
                dwReason |= DVRIO_NOTIFICATION_REASON_FILE_GONE;
            }
            p->m_pfnCallback(p->m_pvContext, dwReason);
        }

        hrRet = S_OK;
    }
    __finally
    {
        if (!bUnlocked)
        {
            Unlock(&p->m_FileCollectionInfo, bReleaseSharedMemoryLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::NotificationRoutine

//static
VOID CALLBACK CDVRFileCollection::RegisterWaitCallback(PVOID lpvParam, BOOLEAN bTimerOut)
{
    __try
    {
        NotificationContext* p = (NotificationContext*) lpvParam;

        // Note that p->m_pFileCollection has been addref'd when we
        // called RegisterWaitForSingleObject. Also, p (the context)
        // we passed to RegisterWFSO) is not deleted by Unregisterreader
        // until all callbacks have completed

        p->m_pFileCollection->NotificationRoutine(p);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

} // CDVRFileCollection::RegisterWaitCallback

// ====== Public methods intended for the writer
// Note that CDVRReader could behave as a writer when it creates a ring buffer
// (opens a recorded ASF file) and it uses the writer functions such as Lock, Unlock,
// SetFileTimes and AddFile. In this case, it uses both the reader and the writer
// functions.

HRESULT CDVRFileCollection::Lock(IN const CClientInfo* pClientInfo,
                                 OUT BOOL& bReleaseSharedMemoryLock,
                                 IN  BOOL  bIncrementInconsistentDataCounter /* = 0 */
                                )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::Lock"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    // The reason for maintaining our own lock count is that we
    // do not want to return ERROR_INVALID_DATA in the following case:
    //
    // Function A calls Lock(bReleaseSharedMemoryLock, bIncrementInconsistentDataCounter = 1)
    // and then calls Function B.
    //
    // Function B calls Lock(bReleaseSharedMemoryLock, bIncrementInconsistentDataCounter = 1).

    if (m_dwNumTimesOwned &&
        ::GetCurrentThreadId() == m_dwLockOwner)
    {
        ::InterlockedIncrement((PLONG) &m_dwNumTimesOwned);
        if (bIncrementInconsistentDataCounter)
        {
            DVR_ASSERT(m_pShared, "");
            ::InterlockedIncrement(&m_pShared->m_nDataInconsistent);
        }
        bReleaseSharedMemoryLock = 0;

        return S_OK;
    }

    ::EnterCriticalSection(&m_csLock);

    DVR_ASSERT(m_dwNumTimesOwned == 0, "");

    // Note that m_dwLockOwner, etc are for the
    // critical section, not the shared mutex. Also,
    // the m_dwNumTimesOwned flag must be set/cleared after/before
    // m_dwLockOwner is set (because m_dwLockOwner is valid only when
    // m_dwNumTimesOwned >= 1).

    ::InterlockedExchange((PLONG) &m_dwLockOwner, ::GetCurrentThreadId());
    ::InterlockedExchange((PLONG) &m_dwNumTimesOwned, 1);

    HRESULT hr;

    bReleaseSharedMemoryLock = 0;
    if (!m_hSharedMutex)
    {
        hr = S_OK;
    }
    else if (IsFlagSet(ReopenMemoryMapFailed))
    {
        hr = E_FAIL;
    }
    else
    {
        DVR_ASSERT(m_pShared, "");
        DVR_ASSERT(IsFlagSet(Mapped), "");

        DWORD dwRet = ::WaitForSingleObject(m_hSharedMutex, INFINITE);
        if (dwRet == WAIT_FAILED)
        {
            DWORD dwLastError = ::GetLastError();
            hr = HRESULT_FROM_WIN32(dwLastError);
            DVR_ASSERT(0, "Waiting for shared memory lock returned WAIT_FAILED");
        }
        else
        {
            // WAIT_ABANDONED is ok, we track data inconsistency using
            // m_pShared->m_nDataInconsistent
            bReleaseSharedMemoryLock = 1;
            hr = S_OK;

            // Check if we have to remap the shared data section
            if (m_pShared->m_dwSharedMemoryMapCounter != m_dwCurrentMemoryMapCounter)
            {
                DVR_ASSERT(m_pShared->m_dwSharedMemoryMapCounter >= m_dwCurrentMemoryMapCounter, "");
                                                                // Remap whether or not the assertion failed

                // The writer will never get here - for the writer m_dwCurrentMemoryMapCounter
                // would be updated to m_pShared->m_dwSharedMemoryMapCounter when the mapping
                // succeeded.

                DVR_ASSERT(!pClientInfo->bAmWriter, "");

                HRESULT hrTmp = ReopenMemoryMap(pClientInfo);
                if (FAILED(hrTmp))
                {
                    // This is serious. m_pShared still is the old mapping, so if we
                    // write to shared memory, we are writing to the old mapping. There
                    // is no guarantee that the old and new mappings are coherent.
                    // Further, if we are the last ones to write, our writes could get
                    // flushed to disk.

                    // The writer never gets into this situation.

                    // In general, we won't write to shared memory if we don;t have the
                    // lock. The exception is in the destructor, UnregisterReader and
                    // Release (in which only the writer currently writes at all).

                    // Currently we prevent writes in the above 3 functions if getting
                    // the lock fails. The effect is equivalent to terminating the reader
                    // process ungracefully.

                    hr = hrTmp;
                    SetFlags(ReopenMemoryMapFailed);
                }
                else
                {
                    DVR_ASSERT(m_pShared->m_dwSharedMemoryMapCounter == m_dwCurrentMemoryMapCounter, "");
                }
            }
        }
    }
    if (SUCCEEDED(hr) && m_pShared && m_pShared->m_nDataInconsistent)
    {
        // Trouble, mutex owner died while modifying the shared data.
        // We can't guarantee consistency of the shared data section.
        // Just bail out.
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        if (!IsFlagSet(WarnedAboutInconsistentData))
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Waiting for shared mem lock succeeded but data is inconsistent (= %u), returning HRESULT_FROM_WIN32(ERROR_INVALID_DATA) = 0x%x",
                            m_pShared->m_nDataInconsistent,
                            HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
            SetFlags(WarnedAboutInconsistentData);
        }
    }

    if (SUCCEEDED(hr) && bIncrementInconsistentDataCounter)
    {
        DVR_ASSERT(m_pShared, "");
        ::InterlockedIncrement(&m_pShared->m_nDataInconsistent);
    }

    DVRIO_TRACE_LEAVE1_HR(hr);

    return hr;

} // CDVRFileCollection::Lock

HRESULT CDVRFileCollection::Unlock(IN const CClientInfo* pClientInfo,
                                   IN BOOL bReleaseSharedMemoryLock,
                                   IN BOOL bDecrementInconsistentDataCounter /* = 0 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::Unlock"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    if (bDecrementInconsistentDataCounter)
    {
        DVR_ASSERT(m_pShared, "");
        ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);
    }

    DVR_ASSERT(m_dwNumTimesOwned, "");
    DVR_ASSERT(::GetCurrentThreadId() == m_dwLockOwner, "");

    if (m_dwNumTimesOwned > 1)
    {
        ::InterlockedDecrement((PLONG) &m_dwNumTimesOwned);

        // We returned bReleaseSharedMemoryLock = 0 in Lock().
        DVR_ASSERT(bReleaseSharedMemoryLock == 0, "");

        DVRIO_TRACE_LEAVE1_HR(S_OK);
        return S_OK;
    }
    if (bReleaseSharedMemoryLock)
    {
        DVR_ASSERT(m_hSharedMutex, "");

        ::ReleaseMutex(m_hSharedMutex);
    }

    DVR_ASSERT(m_dwNumTimesOwned == 1, "");

    ::InterlockedExchange((PLONG) &m_dwNumTimesOwned, 0);
    ::InterlockedExchange((PLONG) &m_dwLockOwner, 0);

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1_HR(S_OK);

    return S_OK;

} // CDVRFileCollection::Unlock

HRESULT
CDVRFileCollection::SetAttributeFile (
    IN  const CClientInfo* pClientInfo,
    IN  LPWSTR  pszAttributeFile    //  NULL to explicitely clear
    )
{
    BOOL    fLocked ;
    HRESULT hr ;
    DWORD   dwLen ;

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    hr = Lock (pClientInfo, fLocked, 1) ;
    if (FAILED (hr)) {
        return hr ;
    }

    if (pszAttributeFile) {
        dwLen = wcslen (pszAttributeFile) ;
        if (dwLen < MAX_PATH) {
            CopyMemory (
                m_pShared -> m_szAttributeFile,
                pszAttributeFile,
                (dwLen + 1) * sizeof WCHAR               //  include NULL
                ) ;

            m_pShared -> m_dwAttributeFilenameLength = dwLen ;

            //  success
            hr = S_OK ;
        }
        else {
            hr = E_INVALIDARG ;
        }
    }
    else {
        //  explicitely being cleared
        m_pShared -> m_dwAttributeFilenameLength = 0 ;
        hr = S_OK ;
    }

    Unlock (pClientInfo, fLocked, 1) ;

    return hr ;
}   //  SetAttributeFile

HRESULT
CDVRFileCollection::GetAttributeFile (
    IN  const CClientInfo* pClientInfo,
    OUT LPWSTR *    ppszAttributeFile   //  NULL if there is none
    )
{
    BOOL    fLocked ;
    HRESULT hr ;
    int     iLen ;

    DVR_ASSERT(pClientInfo, "");
    hr = Lock (pClientInfo, fLocked) ;
    if (FAILED (hr)) {
        return hr ;
    }

    if (m_pShared -> m_dwAttributeFilenameLength > 0) {

        (* ppszAttributeFile) = new WCHAR [m_pShared -> m_dwAttributeFilenameLength + 1] ;
        if (* ppszAttributeFile) {
            CopyMemory (
                (* ppszAttributeFile),
                m_pShared -> m_szAttributeFile,
                (m_pShared -> m_dwAttributeFilenameLength + 1) * sizeof WCHAR
                ) ;

            hr = S_OK ;
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  no attribute filename
        (* ppszAttributeFile) = NULL ;
        hr = S_OK ;
    }

    Unlock (pClientInfo, fLocked) ;

    return hr ;
}

HRESULT CDVRFileCollection::AddFile(IN  const CClientInfo* pClientInfo,
                                    IN OUT LPWSTR*      ppwszFileName OPTIONAL,
                                    IN BOOL             bOpenFromFileCollectionDirectory,
                                    IN QWORD            cnsStartTime,
                                    IN QWORD            cnsEndTime,
                                    IN BOOL             bPermanentFile,
                                    IN BOOL             bDeleteTemporaryFile,
                                    IN LONGLONG         cnsFirstSampleTimeOffsetFromStartOfFile,
                                    OUT DVRIOP_FILE_ID* pnFileId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::AddFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    DvrIopDebugOut5(1, "TRACE ONLY: cnsStartTime = %I64u, cnsEndTime = %I64u, bPermanentFile = %u, cnsFirstSampleTimeOffsetFromStartOfFile = %I64d (%016I64x)", cnsStartTime, cnsEndTime, bPermanentFile, cnsFirstSampleTimeOffsetFromStartOfFile, cnsFirstSampleTimeOffsetFromStartOfFile);

    if (!ppwszFileName || !pnFileId || DvrIopIsBadWritePtr(pnFileId, 0) ||
        (*ppwszFileName && DvrIopIsBadStringPtr(*ppwszFileName)) ||
        cnsStartTime > cnsEndTime ||
        (cnsStartTime == cnsEndTime && cnsStartTime != MAXQWORD)
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    DWORD dwLastError = 0;
    WCHAR pwszFileName[MAX_PATH];
    WCHAR* pwszFileNameOnly = NULL;
    BOOL bDeleteFile = 0;   // If non-zero, we must delete pwszFileName on error return
    BOOL bFree = 0; // If non-zero, delete *ppwzsFileName and reset it to NULL on error return

    if (*ppwszFileName)
    {
        // We have been supplied a file name

        DWORD nLen;
        BOOL bRet = 0; // Return after the __finally block

        __try
        {
            // Get fully qualified name of file.

            nLen = ::GetFullPathNameW(*ppwszFileName, sizeof(pwszFileName)/sizeof(WCHAR), pwszFileName, &pwszFileNameOnly);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Second GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                                nLen+1, dwLastError);
                __leave;
            }
            if (nLen >= sizeof(pwszFileName)/sizeof(WCHAR)) // >= because nLen does not account for the NULL
            {
                DVR_ASSERT(0, "");
                hrRet = E_OUTOFMEMORY;

                // Note: nLen does not account for the NULL terminator
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Our max size for file name in CSharedData::CFileInfo is MAX_PATH (=%u), GetFullPathNameW returns nLen=%u",
                                MAX_PATH, nLen);
                __leave;
            }

            // Verify file is on an NTFS partition @@@@@ any need to do this??
            // @@@@ todo
        }
        __finally
        {
            if (hrRet != S_OK || dwLastError != 0)
            {
                if (dwLastError != 0)
                {
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
                DVRIO_TRACE_LEAVE1_HR(hrRet);
                bRet = 1;
            }
        }
        if (bRet)
        {
            return hrRet;
        }
    }
    else
    {
        // We have to generate a temp file name

        DWORD nRet;
        BOOL bRet = 0; // Return after the __finally block

        __try
        {
            // If this call succeeds, it creates the file. We need this feature so that
            // the generated file name is not reused till the ASF BeginWriting call is
            // issued.
            //
            // The file sink (and the DVR file sink) just overwrites the file it exists. This
            // is ideal. Else, client will have to delete file, opening a window
            // for this function to generate a file name that has already been assigned.

            DVR_ASSERT(m_pwszTempFilePath, "Temp file being created but m_pwszTempFilePath was not initialized?!");

            nRet = ::GetTempFileNameW(m_pwszTempFilePath, L"SBE", 0, pwszFileName);
            if (nRet == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "GetTempFileNameW failed, last error = 0x%x",
                                dwLastError);
                __leave;
            }
            bDeleteFile = 1;

            ::SetFileAttributesW(pwszFileName, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);


            // Copy file name to output param; we will undo this if
            // the function fails (but not if it returns S_FALSE)

            WCHAR* pwszName = new WCHAR[wcslen(pwszFileName) + 1];
            if (pwszName)
            {
                wcscpy(pwszName, pwszFileName);
                *ppwszFileName = pwszName;
                bFree = 1;
            }
            else
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", wcslen(pwszFileName)+1);
                __leave;
            }

            if (bOpenFromFileCollectionDirectory)
            {
                DWORD nLen = ::GetFullPathNameW(pwszName, sizeof(pwszFileName)/sizeof(WCHAR), pwszFileName, &pwszFileNameOnly);
                if (nLen == 0)
                {
                    dwLastError = ::GetLastError();
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "GetFullPathNameW failed, bOpenFromFileCollectionDirectory=1, nLen = %u, last error = 0x%x",
                                    nLen, dwLastError);
                    __leave;
                }
            }
        }
        __finally
        {
            if (hrRet != S_OK || dwLastError != 0)
            {
                if (dwLastError != 0)
                {
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
                DVRIO_TRACE_LEAVE1_HR(hrRet);

                if (bFree)
                {
                    delete [] (*ppwszFileName);
                    *ppwszFileName = NULL;
                }
                if (bDeleteFile)
                {
                    ::DeleteFileW(pwszFileName);
                }
                bRet = 1;
            }
        }
        if (bRet)
        {
            return hrRet;
        }
    }

    DVR_ASSERT(dwLastError == 0, "");

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = Lock(pClientInfo, bReleaseSharedMemoryLock);

    CSharedData::CFileInfo*          pFileInfo;
    CSharedData::CFileInfo*          pNewNode = NULL;
    SHARED_LIST_ENTRY*  pleNewNode = NULL;
    SHARED_LIST_ENTRY*  pCurrent;
    BOOL                bDecrement = 0;

    hrRet = E_FAIL;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        if (IsFlagSet(OpenedAsAFile))
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "This file collection object does not support calls to this fn");
            hrRet = E_INVALIDARG;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        // Verify that start, end times do not overlap start/end times
        // of other nodes in the list and find the insertion point

        BOOL bFound = 0;

        pCurrent = &m_pShared->m_leFileList;

        while (NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
        {
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);
            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored
                continue;
            }
            if (cnsEndTime <= pFileInfo->cnsStartTime)
            {
                // All ok; we should insert before pCurrent
                bFound = 1;
                break;
            }
            if (cnsStartTime >= pFileInfo->cnsEndTime)
            {
                // Keep going on
                continue;
            }
            // Trouble
            DVR_ASSERT(cnsStartTime < pFileInfo->cnsEndTime && cnsEndTime > pFileInfo->cnsStartTime,
                       "Overlapped insert assertion failure?!");
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Overlapped insert! Input params: start time: %I64u, end time: %I64u\n"
                            "overlap node values: start time: %I64u, end time: %I64u",
                            cnsStartTime, cnsEndTime, pFileInfo->cnsStartTime, pFileInfo->cnsEndTime);
            __leave;
        }

        // We are ready to insert. We set bWithinTimeExtent to CSharedData::CFileInfo::DVRIO_EXTENT_IN_RING_BUFFER in the constructor,
        // we'll revise this after we insert if needed. Note that we might insert
        // the file and then immediately delete the node (and the file if it is a temp file).
        // This will happen:
        // - if the file is a permanent file, it is not extending the ring buffer's time extent,
        //   i.e., there is a temp invalid file between the inserted file and the first valid
        //   file in the ring buffer
        // - if the file is a temp file, as for the permanent file condition above, OR if the
        //   ring buffer has max files already and the inserted file's time extent falls
        //   below the ring buffer's time extent
        // Inserting and then deleting is wasted work, but the code
        // is simpler this way and we won't hit this case because files added by the writer
        // will usually be added beyond the current write time. We return S_FALSE
        // if we insert and delete right away..

        if (IsSharedListEmpty(&m_pShared->m_leFreeList))
        {
            if (m_dwGrowBy == 0 || m_dwMaxFiles == m_kMaxFilesLimit)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "m_leFreeList is empty, can't add file");
                __leave;
            }

            DVR_ASSERT(m_dwMaxFiles < m_kMaxFilesLimit, "");

            DWORD dwGrowBy = m_dwGrowBy;
            if (m_dwMaxFiles + dwGrowBy > m_kMaxFilesLimit)
            {
                dwGrowBy = m_kMaxFilesLimit - m_dwMaxFiles;
            }
            DVR_ASSERT(dwGrowBy > 0, "");

            DWORD dwSharedMemoryBytes = sizeof(CSharedData) + m_dwMaxFiles*sizeof(CSharedData::CFileInfo);

            DWORD dwNewFileListSize = dwGrowBy*sizeof(CSharedData::CFileInfo);

            if (IsFlagSet(Mapped))
            {
                HRESULT         hr;
                CSharedData*    pShared;
                DWORD           dwSharedMemoryMapCounter = m_pShared->m_dwSharedMemoryMapCounter;

                // To ensure that the new map we create is coherent with the old one:
                if (::FlushViewOfFile(m_pShared, 0) == 0)
                {
                    dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "FlushViewOfFile failed, last error = 0x%x",
                                    dwLastError);
                    __leave;
                }
                hr = CreateMemoryMap(pClientInfo,
                                     dwSharedMemoryBytes,
                                     (BYTE*) m_pShared,
                                     dwSharedMemoryBytes + dwNewFileListSize,
                                     dwSharedMemoryMapCounter,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     pShared,
                                     NULL);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }

                DVR_ASSERT(pShared, "");

                CSharedData::CFileInfo* pListBase = (CSharedData::CFileInfo*) (pShared + 1);

                for (DWORD i = 0; i < dwGrowBy; i++)
                {
                    pListBase[i + m_dwMaxFiles].leListEntry.Index = (SharedListPointer) (i + m_dwMaxFiles);
                    InsertTailSharedList(&pShared->m_leFreeList, pListBase, &pShared->m_leFreeList, &pListBase[i + m_dwMaxFiles].leListEntry);
                }
                ::InterlockedExchange((PLONG) &pShared->m_dwSharedMemoryMapCounter, dwSharedMemoryMapCounter);

                // Write the counter to both the old and the new mapping. I don't know if coherence is
                // guaranteed across different mappings. (Should be, but MSDN does not say anything about this)
                ::InterlockedExchange((PLONG) &m_pShared->m_dwSharedMemoryMapCounter, dwSharedMemoryMapCounter);

                UINT_PTR dwOffset = (BYTE*) pCurrent - (BYTE*) m_pShared;

                ::UnmapViewOfFile(m_pShared);
                m_pShared = pShared;
                m_pListBase = (CSharedData::CFileInfo*) (m_pShared + 1);
                pCurrent = (SHARED_LIST_ENTRY*) ((BYTE*) m_pShared + dwOffset);
                m_dwMaxFiles += dwGrowBy;
                m_dwCurrentMemoryMapCounter = m_pShared->m_dwSharedMemoryMapCounter;
            }
            else
            {
                DVR_ASSERT(IsFlagSet(Delete), "");

                BYTE* pbShared = new BYTE[dwSharedMemoryBytes + dwNewFileListSize];
                if (!pbShared)
                {
                    hrRet = E_OUTOFMEMORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "alloc via new failed - pbShared - BYTE[%u]",
                                    dwSharedMemoryBytes);
                    __leave;
                }
                ::CopyMemory(pbShared, m_pShared, dwSharedMemoryBytes);

                UINT_PTR dwOffset = (BYTE*) pCurrent - (BYTE*) m_pShared;

                BYTE* pbSharedOld = (BYTE*) m_pShared;
                delete [] pbSharedOld;

                m_pShared = (CSharedData *) pbShared;
                pbShared = NULL;  // Do not use any more
                m_pListBase = (CSharedData::CFileInfo*) (m_pShared + 1);
                pCurrent = (SHARED_LIST_ENTRY*) ((BYTE*) m_pShared + dwOffset);
                for (DWORD i = 0; i < dwGrowBy; i++)
                {
                    m_pListBase[i + m_dwMaxFiles].leListEntry.Index = (SharedListPointer) (i + m_dwMaxFiles);
                    InsertTailSharedList(&m_pShared->m_leFreeList, m_pListBase, &m_pShared->m_leFreeList, &m_pListBase[i + m_dwMaxFiles].leListEntry);
                }
                m_dwMaxFiles += dwGrowBy;
            }
        }

        ::InterlockedIncrement(&m_pShared->m_nDataInconsistent);
        bDecrement = 1;
        pleNewNode = RemoveHeadSharedList(&m_pShared->m_leFreeList, m_pListBase, &m_pShared->m_leFreeList);

        DVR_ASSERT(pleNewNode, "");

        pNewNode = CONTAINING_RECORD(pleNewNode, CSharedData::CFileInfo, leListEntry);

        HRESULT hrTmp;

        hrTmp = pNewNode->Initialize(bOpenFromFileCollectionDirectory? pwszFileNameOnly: pwszFileName,
                             bOpenFromFileCollectionDirectory,
                             cnsStartTime,
                             cnsEndTime,
                             cnsFirstSampleTimeOffsetFromStartOfFile,
                             bPermanentFile,
                             bPermanentFile? 0 : bDeleteTemporaryFile,
                             m_nNextFileId,
                             CSharedData::CFileInfo::DVRIO_EXTENT_IN_RING_BUFFER);

        m_nNextFileId++;

        if (FAILED(hrTmp))
        {
            // This is an internal error
            DVR_ASSERT(0, "CSharedData::CFileInfo::Initialize() failed");
            hrRet = E_FAIL;

            // Leave bDecrement as 1. Data in the shared section is not inconsistent -
            // we will even add pNewNode back to m_leFreeList
            __leave;
        }

        if (!bFound)
        {
            // We insert at tail
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            DVR_ASSERT(pCurrent == &m_pShared->m_leFileList, "");
        }
        InsertTailSharedList(&m_pShared->m_leFileList, m_pListBase, pCurrent, pleNewNode);

        // Update the ring buffer's extent
        UpdateTimeExtent(TRUE);

        ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);
        bDecrement = 0;

        if (pNewNode->bWithinExtent)
        {
            hrRet = S_OK;
        }
        else
        {
            // The file we added is not within the time extent of the ring buffer
            hrRet = S_FALSE;
            // Unsafe to use pNewNode after the call to DeleteUnusedInvalidFileNodes
            pNewNode = NULL;
            pleNewNode = NULL;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                "Added file is not in ring buffer extent and has been deleted from ring buffer.");
        }

        //  Delete files if necessary
        DeleteUnusedInvalidFileNodes(FALSE, NULL);
    }
    __finally
    {
        // Note: we can return S_FALSE as described above.

        if (FAILED(hrRet) || dwLastError != 0)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock);
            if (bDeleteFile)
            {
                ::DeleteFileW(pwszFileName);
            }
            if (bFree)
            {
                delete [] (*ppwszFileName);
                *ppwszFileName = NULL;
            }

            if (pleNewNode)
            {
                // Got to insert node into the free list again
                DVR_ASSERT(pNewNode, "");
                DVR_ASSERT(bDecrement, "");

                if (!IsSharedListEmpty(pleNewNode))
                {
                    // pNewNode was added to m_leFileList
                    RemoveEntrySharedList(&m_pShared->m_leFileList, m_pListBase, pleNewNode);
                }
                InsertTailSharedList(&m_pShared->m_leFreeList, m_pListBase, &m_pShared->m_leFreeList, pleNewNode);

                pNewNode->Cleanup();

                // Don't use these any more
                pNewNode = NULL;
                pleNewNode = NULL;
            }

            if (bDecrement)
            {
                ::InterlockedDecrement(&m_pShared->m_nDataInconsistent);
            }
            if (dwLastError != 0)
            {
                hrRet = HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else if (hrRet != S_FALSE)
        {
            // No sense doing this if we deleted the just inserted node.

            *pnFileId = pNewNode->nFileId;

            // We hold the lock till here since we don't want the
            // node deleted by some other caller.

            Unlock(pClientInfo, bReleaseSharedMemoryLock);
        }
        else
        {
            // hrRet == S_FALSE
            Unlock(pClientInfo, bReleaseSharedMemoryLock);

            if (bFree)
            {
                delete [] (*ppwszFileName);
                *ppwszFileName = NULL;
            }
            // Disk file would have been deleted in the call to DeleteUnusedInvalidFileNodes
            // (unless bPermanent was specified, in which case we don't create it.)
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::AddFile

HRESULT CDVRFileCollection::SetFileTimes(IN  const CClientInfo* pClientInfo,
                                         IN DWORD dwNumElements,
                                         IN PDVRIOP_FILE_TIME pFileTimesParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::SetFileTimes"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;
    DWORD  i;
    PDVRIOP_FILE_TIME pFileTimes;

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    DvrIopDebugOut4(1, "TRACE ONLY CDVRFileCollection::SetFileTimes: dwNumElements = %u, pFileTimesParam->nFileId = %u, pFileTimesParam->cnsStartTime = %I64u, pFileTimesParam->cnsEndTime = %I64u",dwNumElements, pFileTimesParam->nFileId, pFileTimesParam->cnsStartTime, pFileTimesParam->cnsEndTime) ;

    if (!dwNumElements || !pFileTimesParam ||
        DvrIopIsBadReadPtr(pFileTimesParam, dwNumElements*sizeof(DVRIOP_FILE_TIME))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    for (i = 0; i < dwNumElements; i++)
    {
        if (pFileTimesParam[i].cnsStartTime > pFileTimesParam[i].cnsEndTime)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "bad input argument: start time exceeds end time at index %u", i);
            DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
            return E_INVALIDARG;
        }
    }

    pFileTimes = new DVRIOP_FILE_TIME[dwNumElements];
    if (pFileTimes == NULL)
    {
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                        "alloc via new failed - %u bytes",
                        dwNumElements*sizeof(DVRIOP_FILE_TIME));

        return E_OUTOFMEMORY; // out of stack space
    }

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = Lock(pClientInfo, bReleaseSharedMemoryLock, 1);

    CSharedData::CFileInfo*          pFileInfo;
    SHARED_LIST_ENTRY*  pCurrent;

    hrRet = E_FAIL;
    i = 0;
    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");
        pCurrent = &m_pShared->m_leFileList;

        // Verify that start, end times do not overlap start/end times
        // of other nodes in the list and find the insertion point

        QWORD cnsPrevEndTime = 0;

        // It's easy for the writer (the client of this function) to create the input
        // argument so that the file ids in the argument are in the same order as
        // file ids in the file collection. This simplifies the code in this function,
        // so we fail the call if this assumption is violated.

        while (i < dwNumElements && NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
        {
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);
            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored

                // Note that if a file id refers to this node, the call
                // will fail. This is what we want.
                continue;
            }
            if (pFileInfo->nFileId == pFileTimesParam[i].nFileId)
            {
                // Save away the original values in case we have to undo
                pFileTimes[i].nFileId = pFileInfo->nFileId;
                pFileTimes[i].cnsStartTime = pFileInfo->cnsStartTime;
                pFileTimes[i].cnsEndTime = pFileInfo->cnsEndTime;

                pFileInfo->cnsStartTime = pFileTimesParam[i].cnsStartTime;
                pFileInfo->cnsEndTime = pFileTimesParam[i].cnsEndTime;
                i++;
            }
            // The list must remain sorted by file time,

            if (pFileInfo->cnsStartTime == pFileInfo->cnsEndTime)
            {
                // This will happen if pFileTimes[i-1].cnsStartTime
                // == pFileTimes[i-1].cnsEndTime. If we don't add this
                // check here. the caller has a workaround; however this
                // makes it easier for him.

                // This node is going to be marked invalid anyway,
                // Don't consider it and don't update cnsPrevEndTime
                continue;

            }
            else if (pFileInfo->cnsStartTime < cnsPrevEndTime)
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Order of nodes in file collection changes.");
                hrRet = E_INVALIDARG;
                break;
            }

            cnsPrevEndTime = pFileInfo->cnsEndTime;
        }
        // Note: Do NOT change i after this. It is used in the
        // __finally section

        if (hrRet == E_INVALIDARG)
        {
            __leave;
        }
        else if (i == dwNumElements)
        {
            // We haven't advanced pCurrent to the next node
            // Note that we have ensured that dwNumElements > 0, so i > 0
            // so we must have entered the while loop.
            DVR_ASSERT(pCurrent != &m_pShared->m_leFileList, "");

            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);

            // Verify that the last node whose time we changed has
            // times less than the node following it.
            if (pCurrent != &m_pShared->m_leFileList)
            {
                pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);
                if (pFileInfo->cnsStartTime < cnsPrevEndTime)
                {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "Order of nodes in file collection changes.");
                    hrRet = E_INVALIDARG;
                    __leave;
                }
            }
        }
        else // (hrRet != E_INVALIDARG && i < dwNumElements)
        {
            // We ran out of nodes in the file collection before
            // we processed all the inputs. Either some file id in the
            // input is not in the collection or the order of file ids
            // in the input and the collection are different.

            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, &m_pShared->m_leFileList);
            while (pCurrent != &m_pShared->m_leFileList)
            {
                pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);
                if (pFileInfo->nFileId == pFileTimesParam[i].nFileId)
                {
                    break;
                }
                pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            }
            if (pCurrent != &m_pShared->m_leFileList)
            {
                // File id in input is not in the collection
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "file id %u specified in input param list is not in file collection.",
                                pFileTimesParam[i].nFileId);
                hrRet = E_INVALIDARG;
            }
            else
            {
                // Order of file ids different

                DVR_ASSERT(0,
                    "Input file list param does not have file ids in same order as file collection.");
                hrRet = E_FAIL;
            }
            __leave;
        }

        // Success! Update the file collection's extent.
        // UpdateTimeExtent() returns either S_OK or S_FALSE
        // and that's what we want to return
        hrRet = UpdateTimeExtent(TRUE);

        // Delete files if necessary. Files are not likely to be deleted
        // unless start time == end time was specified for some file in
        // the input
        DeleteUnusedInvalidFileNodes(FALSE, NULL);
    }
    __finally
    {
        // Note: we can return S_FALSE

        if (FAILED(hrRet))
        {
            // Undo any changes we made

            DWORD j = 0;

            pCurrent = &m_pShared->m_leFileList;
            while (j < i && NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
            {
                pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
                pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);
                if (pFileInfo->nFileId == pFileTimes[j].nFileId)
                {
                    // Restore the original values
                    pFileInfo->cnsStartTime = pFileTimes[j].cnsStartTime;
                    pFileInfo->cnsEndTime = pFileTimes[j].cnsEndTime;
                    j++;
                }
            }
            DVR_ASSERT(j == i, "Irrecoverable failure! Could not restore");
            if (j != i)
            {
                hrRet = E_FAIL;
            }
        }

        // Note that since we restore the original state, we can
        // decrement m_nDataInconsistent always
        Unlock(pClientInfo, bReleaseSharedMemoryLock, SUCCEEDED(hrLocked)? 1 : 0);

        delete [] pFileTimes;

        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::SetFileTimes

HRESULT CDVRFileCollection::SetNumTempFiles(IN  const CClientInfo* pClientInfo,
                                            IN DWORD dwMinNumberOfFilesParam,
                                            IN DWORD dwMaxNumberOfFilesParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::SetNumTempFiles"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = Lock(pClientInfo, bReleaseSharedMemoryLock, 1);

    hrRet = E_FAIL;


    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }
        if (IsFlagSet(OpenedAsAFile))
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "This file collection object does not support calls to this fn");
            hrRet = E_INVALIDARG;
            __leave;
        }

        if (dwMaxNumberOfFilesParam < dwMinNumberOfFilesParam ||
            dwMaxNumberOfFilesParam > m_dwMaxFiles ||
            (dwMaxNumberOfFilesParam > 0 && m_pwszTempFilePath == NULL))
        {
            // Note that if m_pwszTempFilePath is NULL, we were not provided a
            // temp directory in the constructor. We won't allow temp files to
            //  be created now.
            hrRet = E_INVALIDARG;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        m_pShared->m_dwMinTempFiles = dwMinNumberOfFilesParam;
        m_pShared->m_dwMaxTempFiles = dwMaxNumberOfFilesParam;

        UpdateTimeExtent(TRUE);
        DeleteUnusedInvalidFileNodes(FALSE, NULL);
        hrRet = S_OK;
    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock, SUCCEEDED(hrLocked)? 1 : 0);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::SetNumTempFiles

HRESULT CDVRFileCollection::FreeTerminatedReaderSlots(IN  const CClientInfo* pClientInfo,
                                                      IN BOOL bLock /* = 1 */,
                                                      IN BOOL bCloseAllHandles /* = 0 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::FreeTerminatedReaderSlots"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");

    HRESULT hrRet;

    // This function must be called only by the writer (or something in the
    // writer process) since the event handles being closed here are valid
    // only in the writer process.
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = bLock? Lock(pClientInfo, bReleaseSharedMemoryLock, 1) : S_OK;

    hrRet = E_FAIL;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");
        DVR_ASSERT(m_pShared->m_dwNumClients, "");

        if (m_pShared->m_dwNumClients == 1)
        {
            // No readers; the writer is the only client
            hrRet = S_OK;
            __leave;
        }

        for (int i = 0; i < MAX_READERS; i++)
        {
            if ((m_pShared->Readers[i].dwMsg & CSharedData::CReaderInfo::DVRIO_READER_REQUEST_DONE) != 0)
            {
                DVR_ASSERT(m_pShared->Readers[i].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE, "");
                // DVR_ASSERT(m_pShared->Readers[i].hReaderEvent != NULL, "");
                DVR_ASSERT(m_pShared->Readers[i].dwEventSuffix, "");

                // The following assert is valid, but not comprehensive since the reader
                // could be in another process
                DVR_ASSERT(m_apNotificationContext[i] == NULL, "");

                if (m_pShared->Readers[i].hReaderEvent)
                {
                    ::CloseHandle(m_pShared->Readers[i].hReaderEvent);
                    m_pShared->Readers[i].hReaderEvent = NULL;
                }
                else
                {
                    // The writer never opened this event
                }
                m_pShared->Readers[i].dwEventSuffix = 0;
                m_pShared->Readers[i].dwFlags = 0;
                m_pShared->Readers[i].dwMsg = CSharedData::CReaderInfo::DVRIO_READER_MSG_NONE;
            }
            else if (bCloseAllHandles)
            {
                if (m_pShared->Readers[i].hReaderEvent)
                {
                    ::CloseHandle(m_pShared->Readers[i].hReaderEvent);
                    m_pShared->Readers[i].hReaderEvent = NULL;
                }
                else
                {
                    // The writer never opened this event
                }
                m_pShared->Readers[i].dwEventSuffix = 0;
            }
        }

        hrRet = S_OK;
    }
    __finally
    {
        if (bLock)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock, SUCCEEDED(hrLocked)? 1 : 0);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::FreeTerminatedReaderSlots

HRESULT CDVRFileCollection::SetLastStreamTime(IN  const CClientInfo* pClientInfo,
                                              IN QWORD    cnsLastStreamTime,
                                              IN BOOL     bLock /* = 1 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::SetLastStreamTime"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    BOOL    bReleaseSharedMemoryLock;

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    HRESULT hrLocked = bLock? Lock(pClientInfo, bReleaseSharedMemoryLock, 1) : S_OK;

    hrRet = E_FAIL;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");
        DVR_ASSERT(m_pShared->m_dwNumClients, "");

        m_pShared->m_cnsLastStreamTime = cnsLastStreamTime;

        hrRet = S_OK;
    }
    __finally
    {
        if (bLock)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock, SUCCEEDED(hrLocked)? 1 : 0);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::SetLastStreamTime

HRESULT CDVRFileCollection::SetWriterHasBeenClosed(IN  const CClientInfo* pClientInfo,
                                                   IN BOOL bLock /* = 1 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::SetWriterHasBeenClosed"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = bLock? Lock(pClientInfo, bReleaseSharedMemoryLock) : S_OK;

    hrRet = E_FAIL;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        if (m_pShared)
        {
            DVR_ASSERT(m_pShared->m_dwNumClients, "");
            ::InterlockedExchange(&m_pShared->m_nWriterHasBeenClosed, 1);
        }

        hrRet = S_OK;
    }
    __finally
    {
        if (bLock)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::SetWriterHasBeenClosed

HRESULT CDVRFileCollection::SetFirstSampleTimeOffsetForFile(IN  const CClientInfo* pClientInfo,
                                                            IN DVRIOP_FILE_ID nFileId,
                                                            IN LONGLONG       cnsFirstSampleOffset,
                                                            IN BOOL           bLock /* = 1 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::SetFirstSampleTimeOffsetForFile"

    DVRIO_TRACE_ENTER();

    //  PREFIX fix
    HRESULT hrRet=E_FAIL ;

    DVR_ASSERT(pClientInfo, "");
    DVR_ASSERT(pClientInfo->bAmWriter, "");

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = bLock? Lock(pClientInfo, bReleaseSharedMemoryLock, 1) : S_OK;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");
        DVR_ASSERT(m_pShared->m_dwNumClients, "");

        CSharedData::CFileInfo*          pFileInfo;
        SHARED_LIST_ENTRY*  pCurrent;

        DVR_ASSERT(m_pShared, "");

        pCurrent = &m_pShared->m_leFileList;

        while (NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
        {
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            if (pFileInfo->nFileId == nFileId)
            {
                pFileInfo->cnsFirstSampleTimeOffsetFromStartOfFile = cnsFirstSampleOffset;
                hrRet = S_OK;
                break;
            }
        }
        if (FAILED(hrRet))
        {
             // nFileId is bad
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument: nFileId = %u", nFileId);
        }
    }
    __finally
    {
        if (bLock)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock, SUCCEEDED(hrLocked)? 1 : 0);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::SetFirstSampleTimeOffsetForFile

// ====== Public methods intended for the reader

HRESULT CDVRFileCollection::GetFileAtTime(IN  const CClientInfo* pClientInfo,
                                          IN QWORD              cnsStreamTime,
                                          OUT LPWSTR*           ppwszFileName OPTIONAL,
                                          OUT LONGLONG*         pcnsFirstSampleTimeOffsetFromStartOfFile OPTIONAL,
                                          OUT DVRIOP_FILE_ID*   pnFileId OPTIONAL,
                                          IN BOOL               bFileWillBeOpened)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetFileAtTime"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");
    DWORD dwReaderIndex = pClientInfo->bAmWriter?  m_dwInvalidReaderIndex : pClientInfo->dwReaderIndex;

    HRESULT hrRet;

    if ((pnFileId && DvrIopIsBadWritePtr(pnFileId, 0)) ||
        (pcnsFirstSampleTimeOffsetFromStartOfFile && DvrIopIsBadWritePtr(pcnsFirstSampleTimeOffsetFromStartOfFile, 0)) ||
        (ppwszFileName && DvrIopIsBadWritePtr(ppwszFileName, 0)) ||
        (bFileWillBeOpened && dwReaderIndex > MAX_READERS)
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    hrRet = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = Lock(pClientInfo, bReleaseSharedMemoryLock);

    CSharedData::CFileInfo*          pFileInfo;
    SHARED_LIST_ENTRY*  pCurrent;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        pCurrent = &m_pShared->m_leFileList;

        while (NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
        {
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            // Following test will ignore nodes whose start time == end time
            // (a) because bWithinExtent == FALSE and (b) by the way the test
            // for times is coded in the if condition below.
            if (pFileInfo->bWithinExtent &&
                cnsStreamTime >= pFileInfo->cnsStartTime &&
                (cnsStreamTime < pFileInfo->cnsEndTime ||
                 (cnsStreamTime == MAXQWORD && pFileInfo->cnsEndTime == MAXQWORD)
                )
               )
            {
                if (ppwszFileName)
                {

                    WCHAR* pwszName;
                    DWORD  nLen = wcslen(pFileInfo->wszFileName) + 1;
                    BOOL   bTwoCopies = 0;

                    if (pFileInfo->IsFlagSet(CSharedData::CFileInfo::OpenFromFileCollectionDirectory) && m_pwszRingBufferFilePath)
                    {
                        DWORD n = wcslen(m_pwszRingBufferFilePath);

                        if (n)
                        {
                            nLen += n; // Note that m_pwszRingBufferFilePath has a trailing \ or /.
                            bTwoCopies = 1;
                        }
                    }
                    pwszName = new WCHAR[nLen];
                    if (pwszName)
                    {
                        if (bTwoCopies)
                        {
                            wcscpy(pwszName, m_pwszRingBufferFilePath);
                            nLen = wcslen(pwszName);
                        }
                        else
                        {
                            nLen = 0;
                        }
                        wcscpy(pwszName + nLen, pFileInfo->wszFileName);
                        *ppwszFileName = pwszName;
                    }
                    else
                    {
                        hrRet = E_OUTOFMEMORY;
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "alloc via new failed - WCHAR[%u]",
                                        nLen);
                        __leave;
                    }
                }
                if (pnFileId)
                {
                    *pnFileId = pFileInfo->nFileId;
                }
                if (pcnsFirstSampleTimeOffsetFromStartOfFile)
                {
                    *pcnsFirstSampleTimeOffsetFromStartOfFile = pFileInfo->cnsFirstSampleTimeOffsetFromStartOfFile;
                }
                if (bFileWillBeOpened && dwReaderIndex < MAX_READERS)
                {
                    // Failure of following assertion is an error in CDVRReader - we maintain a bit mask
                    // per reader, not a ref count, so we don't expect a reader to call this function
                    // with bFileWillBeOpened if it already has the file open
                    DVR_ASSERT((pFileInfo->bmOpenByReader & (1 << dwReaderIndex)) == 0, "");

                    // m_nDataInconsistent is not incremented/decremented around this stmt
                    // That's ok as this is a local change - no other members have to be
                    // updated with this member.
                    pFileInfo->bmOpenByReader |= 1 << dwReaderIndex;

                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                                    "Reader %u has opened file id %u.",
                                    dwReaderIndex, pFileInfo->nFileId);

                    if (pFileInfo->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER)
                    {
                        DVR_ASSERT(m_apNotificationContext[dwReaderIndex] &&
                                   m_apNotificationContext[dwReaderIndex]->m_hReaderEvent, "");

                        if (m_pShared->Readers[dwReaderIndex].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP)
                        {
                            m_pShared->Readers[dwReaderIndex].dwFlags &= ~CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP;
                            m_pShared->Readers[dwReaderIndex].dwMsg |= CSharedData::CReaderInfo::DVRIO_READER_WARNING_CATCH_UP;

                            // Somewhat premature since the file has not been opened yet. But
                            // this is the best we can do short of waiting for UpdateTimeExtent()
                            // to be next called.
                            ::SetEvent(m_apNotificationContext[dwReaderIndex]->m_hReaderEvent);
                        }
                    }
                    else
                    {
                        DVR_ASSERT(pFileInfo->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_IN_RING_BUFFER, "");
                    }
                }
                hrRet = S_OK;
                break;
            }
        }
        if (FAILED(hrRet))
        {
            // No file for this time
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "No valid file corresponding to time %I64u found in file collection.",
                            cnsStreamTime);
        }
    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetFileAtTime

HRESULT CDVRFileCollection::CloseReaderFile(IN  const CClientInfo* pClientInfo,
                                            IN DVRIOP_FILE_ID   nFileId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::CloseReaderFile"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");
    DWORD dwReaderIndex = pClientInfo->bAmWriter?  m_dwInvalidReaderIndex : pClientInfo->dwReaderIndex;

    // This function may not be called by a writer
    if (dwReaderIndex > MAX_READERS)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT hrRet;

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = Lock(pClientInfo, bReleaseSharedMemoryLock);

    hrRet = E_FAIL;

    CSharedData::CFileInfo*          pFileInfo;
    SHARED_LIST_ENTRY*  pCurrent;
    BOOL                bUpdateExtent = 0;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, &m_pShared->m_leFileList);
        while (pCurrent != &m_pShared->m_leFileList)
        {
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            if (pFileInfo->nFileId == nFileId)
            {
                if (dwReaderIndex >= MAX_READERS)
                {
                    hrRet = S_OK;
                }
                else if ((pFileInfo->bmOpenByReader & (1 << dwReaderIndex)) == 0)
                {
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "Reader ref count for file id %u is already 0.",
                                    pFileInfo->nFileId);
                    hrRet = E_FAIL;
                }
                else
                {
                    // m_nDataInconsistent is not incremented/decremented around this stmt
                    // That's ok as this is a local change - no other members have to be
                    // updated with this member. If closing this file causes the extent to
                    // be updated, it'd be nice to keep the extent in sync with the change to
                    // this member, but that doesn't cause the shared data to be inconsistent
                    // in a harmful way (i.e., it is not corrupted and unusable by other clients).
                    pFileInfo->bmOpenByReader &= ~(1 << dwReaderIndex);
                    if (pFileInfo->bmOpenByReader == 0 &&
                        pFileInfo->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER &&
                        !pFileInfo->bPermanentFile)
                    {
                        bUpdateExtent = 1;
                    }

                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                                    "Reader %u has closed file id %u.",
                                    dwReaderIndex, pFileInfo->nFileId);

                    if (pFileInfo->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER)
                    {
                        DVR_ASSERT((m_pShared->Readers[dwReaderIndex].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP) == 0, "");

                        // Determine if reader has caught up
                        CSharedData::CFileInfo*   pFileInfoTmp;
                        SHARED_LIST_ENTRY*  pCurrentTmp = &m_pShared->m_leFileList;
                        BOOL bCaughtUp = 1;

                        pCurrentTmp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrentTmp);
                        while (pCurrentTmp != &m_pShared->m_leFileList)
                        {
                            pFileInfoTmp = CONTAINING_RECORD(pCurrentTmp, CSharedData::CFileInfo, leListEntry);
                            if (pFileInfoTmp->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_IN_RING_BUFFER)
                            {
                                // All done
                                break;
                            }

                            if (pFileInfoTmp->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER)
                            {
                                if (pFileInfoTmp->bmOpenByReader & (1 << dwReaderIndex))
                                {
                                    bCaughtUp = 0;
                                    break;
                                }
                            }
                            pCurrentTmp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrentTmp);
                        }
                        if (bCaughtUp)
                        {
                            m_pShared->Readers[dwReaderIndex].dwFlags |= CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP;
                        }
                    }
                    if (pFileInfo->bWithinExtent == CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER)
                    {
                        // If pFileInfo->cnsStartTime == pFileInfo->cnsEndTime, we may not have warned this
                        // node. We would have if all nodes before this one are also not in the collection's
                        // extent. But if the file was a priming file and has been removed from the collection,
                        // the reader would not have been warned. So the assert has two clauses
                        //
                        // In either case, it's safe to execute the code that turns the NONE_GONE flag on

                        DVR_ASSERT((m_pShared->Readers[dwReaderIndex].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE) == 0 ||
                                   pFileInfo->cnsStartTime == pFileInfo->cnsEndTime,
                                   "");

                        // Determine if reader has caught up
                        CSharedData::CFileInfo*   pFileInfoTmp;
                        SHARED_LIST_ENTRY*  pCurrentTmp = &m_pShared->m_leFileList;
                        BOOL bNoneGone = 1;

                        pCurrentTmp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrentTmp);
                        while (pCurrentTmp != &m_pShared->m_leFileList)
                        {
                            pFileInfoTmp = CONTAINING_RECORD(pCurrentTmp, CSharedData::CFileInfo, leListEntry);
                            if (pFileInfoTmp->bWithinExtent != CSharedData::CFileInfo::DVRIO_EXTENT_NOT_IN_RING_BUFFER)
                            {
                                // All done
                                break;
                            }

                            if (pFileInfoTmp->bmOpenByReader & (1 << dwReaderIndex))
                            {
                                bNoneGone = 0;
                                break;
                            }
                            pCurrentTmp = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrentTmp);
                        }
                        if (bNoneGone)
                        {
                            m_pShared->Readers[dwReaderIndex].dwFlags |= CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE;
                        }
                    }

                    hrRet = S_OK;
                }
                break;
            }
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
        }
        if (pCurrent == &m_pShared->m_leFileList)
        {
            // File id not in file collection
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "File id %u not found in file collection.",
                            nFileId);
            hrRet = E_FAIL;
        }
        if (SUCCEEDED(hrRet))
        {
            if (bUpdateExtent)
            {
                UpdateTimeExtent(FALSE);
            }

            // Call this even if the new ref count is not 0;
            // just use this op to clean up
            DeleteUnusedInvalidFileNodes(FALSE, NULL);
        }
    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::CloseReaderFile

HRESULT CDVRFileCollection::GetTimeExtentForFile(
    IN  const CClientInfo* pClientInfo,
    IN DVRIOP_FILE_ID nFileId,
    OUT QWORD*        pcnsStartStreamTime OPTIONAL,
    OUT QWORD*        pcnsEndStreamTime OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetTimeExtentForFile"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    HRESULT hrRet;

    if ((pcnsStartStreamTime && DvrIopIsBadWritePtr(pcnsStartStreamTime, 0)) ||
        (pcnsEndStreamTime && DvrIopIsBadWritePtr(pcnsEndStreamTime, 0))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = Lock(pClientInfo, bReleaseSharedMemoryLock);

    hrRet = E_FAIL;

    CSharedData::CFileInfo*          pFileInfo;
    SHARED_LIST_ENTRY*  pCurrent;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, &m_pShared->m_leFileList);
        while (pCurrent != &m_pShared->m_leFileList)
        {
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            if (pFileInfo->nFileId == nFileId)
            {
                if (pcnsStartStreamTime)
                {
                    *pcnsStartStreamTime = pFileInfo->cnsStartTime;
                }
                if (pcnsEndStreamTime)
                {
                    *pcnsEndStreamTime = pFileInfo->cnsEndTime;
                }
                hrRet = pFileInfo->bWithinExtent? S_OK : S_FALSE;
                break;
            }
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
        }
        if (pCurrent == &m_pShared->m_leFileList)
        {
            // File id not in file collection
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "File id %u not found in file collection.",
                            nFileId);
            hrRet = E_FAIL;
        }
    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetTimeExtentForFile

HRESULT CDVRFileCollection::GetTimeExtent(
    IN  const CClientInfo* pClientInfo,
    OUT QWORD*        pcnsStartStreamTime OPTIONAL,
    OUT QWORD*        pcnsEndStreamTime OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetTimeExtent"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    HRESULT hrRet;

    if ((pcnsStartStreamTime && DvrIopIsBadWritePtr(pcnsStartStreamTime, 0)) ||
        (pcnsEndStreamTime && DvrIopIsBadWritePtr(pcnsEndStreamTime, 0))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    BOOL    bReleaseSharedMemoryLock;

    __try
    {
        hrRet = Lock(pClientInfo, bReleaseSharedMemoryLock);
        if (FAILED(hrRet))
        {
            __leave;
        }

        DVR_ASSERT(m_pShared, "");
        if (pcnsStartStreamTime)
        {
            *pcnsStartStreamTime = m_pShared->m_cnsStartTime;
        }
        if (pcnsEndStreamTime)
        {
            *pcnsEndStreamTime = m_pShared->m_cnsLastStreamTime;
        }

        hrRet = S_OK;
    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetTimeExtent


// We return E_FAIL if cnsStreamTime = MAXQWORD (and
// m_pShared->m_cnsEndTime)
HRESULT CDVRFileCollection::GetFirstValidTimeAfter(IN  const CClientInfo* pClientInfo,
                                                   IN  QWORD    cnsStreamTime,
                                                   OUT QWORD*   pcnsNextValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetFirstValidTimeAfter"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    HRESULT hrRet;

    if (!pcnsNextValidStreamTime || DvrIopIsBadWritePtr(pcnsNextValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    BOOL                bReleaseSharedMemoryLock;
    CSharedData::CFileInfo*          pFileInfo;
    SHARED_LIST_ENTRY*  pCurrent;

    hrRet = E_FAIL;

    __try
    {
        HRESULT hr = Lock(pClientInfo, bReleaseSharedMemoryLock);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        pCurrent = &m_pShared->m_leFileList;

        while (NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
        {
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored
                continue;
            }
            if (cnsStreamTime >= pFileInfo->cnsStartTime &&
                cnsStreamTime < pFileInfo->cnsEndTime - 1)
            {
                *pcnsNextValidStreamTime = cnsStreamTime + 1;
                hrRet = S_OK;
                break;
            }
            else if (cnsStreamTime < pFileInfo->cnsStartTime)
            {
                // Time hole

                *pcnsNextValidStreamTime = pFileInfo->cnsStartTime;
                hrRet = S_OK;
                break;
            }
        }

        // if hrRet == E_FAIL, we crossed the ring buffer's extent and
        // there is no file. Return E_FAIL and don't change
        // *pcnsNextValidStreamTime
    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetFirstValidTimeAfter


// We return E_FAIL for 0 (and m_pShared->m_cnsStartTime)
HRESULT CDVRFileCollection::GetLastValidTimeBefore(IN  const CClientInfo* pClientInfo,
                                                   IN  QWORD    cnsStreamTime,
                                                   OUT QWORD*   pcnsLastValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetLastValidTimeBefore"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    HRESULT hrRet;

    if (!pcnsLastValidStreamTime || DvrIopIsBadWritePtr(pcnsLastValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    BOOL                bReleaseSharedMemoryLock;
    CSharedData::CFileInfo*          pFileInfo;
    SHARED_LIST_ENTRY*  pCurrent;

    hrRet = E_FAIL;

    __try
    {
        HRESULT hr = Lock(pClientInfo, bReleaseSharedMemoryLock);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        pCurrent = &m_pShared->m_leFileList;
        while (PREVIOUS_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
        {
            pCurrent = PREVIOUS_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored
                continue;
            }
            if (cnsStreamTime > pFileInfo->cnsStartTime &&
                cnsStreamTime <= pFileInfo->cnsEndTime)
            {
                // If cnsStreamTime == MAXQWORD, this covers the case
                // where a node has (start, end) = (T, QWORD_IFINITE) where
                // T != MAXQWORD. The next else if clause skips over
                // files with start = end = MAXQWORD
                *pcnsLastValidStreamTime = cnsStreamTime - 1;
                hrRet = S_OK;
                break;
            }
            else if (cnsStreamTime >= pFileInfo->cnsEndTime &&
                     (cnsStreamTime != MAXQWORD ||
                      pFileInfo->cnsEndTime != MAXQWORD)
                    )
            {
                // Time hole

                *pcnsLastValidStreamTime = pFileInfo->cnsEndTime - 1;
                hrRet = S_OK;
                break;
            }
        }

        // if hrRet == E_FAIL, we crossed the ring buffer's extent and
        // there is no file. Return E_FAIL and don't change
        // *pcnsLastValidStreamTime
    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetLastValidTimeBefore


ULONG CDVRFileCollection::StartTimeAnchoredAtZero(IN  const CClientInfo* pClientInfo)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::StartTimeAnchoredAtZero"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    BOOL    bReleaseSharedMemoryLock;

    ULONG   nRet = ~0; // arbitrary. If this call fails, we failed to get the lock and
                       // all subsequent calls to this object will fail, so it doesn't
                       // matter much what we return.

    __try
    {
        HRESULT hr = Lock(pClientInfo, bReleaseSharedMemoryLock);
        if (FAILED(hr))
        {
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        // Returns 1 or 0 here
        nRet = m_pShared->IsFlagSet(CSharedData::StartTimeFixedAtZero);

    }
    __finally
    {
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1(nRet);
    }

    return nRet;

} // CDVRFileCollection::StartTimeAnchoredAtZero


HRESULT CDVRFileCollection::GetLastStreamTime(IN  const CClientInfo* pClientInfo,
                                              OUT QWORD*   pcnsLastStreamTime,
                                              IN BOOL      bLock /* = 1 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetLastStreamTime"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    if (!pcnsLastStreamTime || DvrIopIsBadWritePtr(pcnsLastStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT hrRet;

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = bLock? Lock(pClientInfo, bReleaseSharedMemoryLock) : S_OK;

    hrRet = E_FAIL;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        *pcnsLastStreamTime = m_pShared->m_cnsLastStreamTime;

        hrRet = S_OK;
    }
    __finally
    {
        if (bLock)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetLastStreamTime

HRESULT CDVRFileCollection::GetWriterHasBeenClosed(IN  const CClientInfo* pClientInfo,
                                                   OUT  LONG*   pnWriterCompleted,
                                                   IN   BOOL    bLock /* = 1 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetWriterHasBeenClosed"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    if (!pnWriterCompleted || DvrIopIsBadWritePtr(pnWriterCompleted, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT hrRet;

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = bLock? Lock(pClientInfo, bReleaseSharedMemoryLock) : S_OK;

    hrRet = E_FAIL;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        *pnWriterCompleted = m_pShared->m_nWriterHasBeenClosed;

        hrRet = S_OK;
    }
    __finally
    {
        if (bLock)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetWriterHasBeenClosed

HRESULT CDVRFileCollection::GetFirstSampleTimeOffsetForFile(IN  const CClientInfo* pClientInfo,
                                                            IN DVRIOP_FILE_ID nFileId,
                                                            OUT LONGLONG*     pcnsFirstSampleOffset,
                                                            IN BOOL           bLock /* = 1 */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetFirstSampleTimeOffsetForFile"

    DVRIO_TRACE_ENTER();
    DVR_ASSERT(pClientInfo, "");

    if (!pcnsFirstSampleOffset || DvrIopIsBadWritePtr(pcnsFirstSampleOffset, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    //  PREFIX fix
    HRESULT hrRet=E_FAIL ;

    BOOL    bReleaseSharedMemoryLock;

    HRESULT hrLocked = bLock? Lock(pClientInfo, bReleaseSharedMemoryLock) : S_OK;

    __try
    {
        if (FAILED(hrLocked))
        {
            hrRet = hrLocked;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        CSharedData::CFileInfo*          pFileInfo;
        SHARED_LIST_ENTRY*  pCurrent;

        DVR_ASSERT(m_pShared, "");

        pCurrent = &m_pShared->m_leFileList;

        while (NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent) != &m_pShared->m_leFileList)
        {
            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            if (pFileInfo->nFileId == nFileId)
            {
                *pcnsFirstSampleOffset = pFileInfo->cnsFirstSampleTimeOffsetFromStartOfFile;
                hrRet = S_OK;
                break;
            }
        }
        if (FAILED(hrRet))
        {
             // nFileId is bad
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument: nFileId = %u", nFileId);
        }
    }
    __finally
    {
        if (bLock)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::GetFirstSampleTimeOffsetForFile

HRESULT CDVRFileCollection::RegisterReader(CClientInfo* pClientInfo,
                                           IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                                           IN  LPVOID                       pvContext OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::RegisterReader"

    DVRIO_TRACE_ENTER();
    HRESULT hrRet;

    if (!pClientInfo || DvrIopIsBadWritePtr(pClientInfo, 0) ||
        (pfnCallback && DvrIopIsBadVoidPtr(pfnCallback)) ||
        (pvContext && DvrIopIsBadVoidPtr(pvContext))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    NotificationContext *pContext = NULL;
    BOOL    bReleaseSharedMemoryLock;
    DWORD   dwReaderIndex = m_dwInvalidReaderIndex;
    BOOL    bSet = 0;
    HANDLE  hEvent = NULL;
    BOOL    bDecrement = 0;


    hrRet = E_FAIL;

    __try
    {
        HRESULT hr = Lock(pClientInfo, bReleaseSharedMemoryLock);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(m_pShared, "");

        // First determine whether we need to register at all
        if (m_pShared->m_dwMutexSuffix == 0 || IsFlagSet(SideStepReaderRegistration))
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, "no need to register");
            dwReaderIndex = MAX_READERS;
            hrRet = S_OK;
            __leave;
        }

        // Determine if there is an open slot
        for (int i = 0; i < MAX_READERS; i++)
        {
            if ((m_pShared->Readers[i].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE) == 0)
            {
                DVR_ASSERT(m_pShared->Readers[i].hReaderEvent == NULL, "");
                DVR_ASSERT(m_pShared->Readers[i].dwEventSuffix == 0, "");

                // Force it to NULL anyway
                m_pShared->Readers[i].hReaderEvent = NULL;
                m_pShared->Readers[i].dwEventSuffix = 0;
                dwReaderIndex = i;
                break;
            }
        }
        if (i == MAX_READERS)
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, "Reader registration failed - too many readers");
            hrRet = E_OUTOFMEMORY;
            __leave;
        }
        DVR_ASSERT(dwReaderIndex < MAX_READERS, "");
        DVR_ASSERT(m_apNotificationContext[dwReaderIndex] == NULL, "");
        m_pShared->Readers[dwReaderIndex].dwMsg = CSharedData::CReaderInfo::DVRIO_READER_MSG_NONE;
        m_pShared->Readers[dwReaderIndex].dwFlags = CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE | CSharedData::CReaderInfo::DVRIO_READER_FLAG_NONE_GONE | CSharedData::CReaderInfo::DVRIO_READER_FLAG_CAUGHT_UP;
        ::InterlockedIncrement((PLONG) &m_pShared->m_dwNumClients);
        DVR_ASSERT(m_pShared->m_dwNumClients <= MAX_READERS + 1   /* 1 for the writer */, "");
        bDecrement = 1;

        PACL                 pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwAclCreationStatus;
        SECURITY_ATTRIBUTES  sa;

        if (pClientInfo->dwNumSids > 0)
        {
            // It suffices to give EVENT_MODIFY_STATE access to only the writer's
            // user context. We know the writer's pid, and there may be a
            // way of getting its SID from that.
            dwAclCreationStatus = ::CreateACL(pClientInfo->dwNumSids, pClientInfo->ppSids,
                                            SET_ACCESS, EVENT_ALL_ACCESS,
                                            SET_ACCESS, EVENT_MODIFY_STATE,
                                            pACL,
                                            pSD
                                            );

            if (dwAclCreationStatus != ERROR_SUCCESS)
            {
                hrRet = HRESULT_FROM_WIN32(dwAclCreationStatus);
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "::CreateAcl failed, returning hr = 0x%x",
                                hrRet);
                __leave;
            }


            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
        }

        WCHAR  wszEvent[MAX_EVENT_NAME_LEN];
        DWORD nLen;

        wcscpy(wszEvent, CDVRFileCollection::m_kwszSharedEventPrefix);
        nLen = wcslen(CDVRFileCollection::m_kwszSharedEventPrefix);

        for (DWORD dwEventSuffix = 1; dwEventSuffix != 0; dwEventSuffix++)
        {
            wsprintf(wszEvent + nLen, L"%u", dwEventSuffix);

            hEvent = ::CreateEventW(pClientInfo->dwNumSids > 0? &sa : NULL,
                                    FALSE,          // event is auto reset
                                    FALSE,          // not signaled
                                    wszEvent        // name
                                );
            DWORD dwLastError = ::GetLastError();

            if (hEvent == NULL)
            {
                // It's ok to fail for any reason. Ideally, we should
                // trap reasons that stem from insufficient resources and
                // bail out. Note that failure can be because this event
                // is owned by someone else (we don't have access) or this
                // name is being used by someone else as a semaphore, etc.
                // In that case, we do want to ignore this error.
            }
            else if (dwLastError == ERROR_ALREADY_EXISTS)
            {
                // We want a new one, not something else that has
                // been created by someone else.
                ::CloseHandle(hEvent);
                hEvent = NULL;
            }
            else
            {
                break;
            }
        }
        if (pClientInfo->dwNumSids > 0)
        {
            ::FreeSecurityDescriptors(pACL, pSD);
        }
        if (hEvent == NULL)
        {
            DVR_ASSERT(0, "Failed to create a unique notification event for the reader after several tries");
            hrRet = E_FAIL;
            __leave;
        }

        // Now determine if the writer process has been closed. If it has, no
        // notification context needs to be created.
        if (m_pShared->m_dwWriterPid == 0)
        {
            // We still create a notification context and an event because
            // the reader can signal the event when it opens files whose
            // extent is CSharedData::CFileInfo::DVRIO_EXTENT_FALLING_OUT_OF_RING_BUFFER.
            DVR_ASSERT(m_pShared->m_nWriterHasBeenClosed != 0, "");
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, "writer process has been closed, no need to dup event into writer");
        }
        else
        {
            m_pShared->Readers[dwReaderIndex].dwEventSuffix = dwEventSuffix;
        }

        pContext = new NotificationContext(this, hEvent, pfnCallback, pvContext, pClientInfo, dwReaderIndex, &hr);

        if (pContext == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - NotificationContext");
            __leave;
        }

        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "NotificationContext constructor failed - hr = 0x%x",
                            hrRet);
            __leave;
        }

        hEvent = NULL; // pContext holds on to hEvent and will close it

        HANDLE  hWaitObject;

        if (::RegisterWaitForSingleObject(&hWaitObject,
                                          pContext->m_hReaderEvent,
                                          RegisterWaitCallback,
                                          pContext,
                                          INFINITE,
                                          WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "RegisterWFSO failed, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        pContext->SetWaitObject(hWaitObject);

        m_apNotificationContext[dwReaderIndex] = pContext;
        bSet = 1;
        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // pClientInfo->SetReaderIndex(m_dwInvalidReaderIndex); -- not necessary to do this
            if (dwReaderIndex != m_dwInvalidReaderIndex)
            {
                DVR_ASSERT(dwReaderIndex < MAX_READERS, "");
                DVR_ASSERT(m_pShared->Readers[dwReaderIndex].hReaderEvent == NULL, "");
                DVR_ASSERT(m_pShared->Readers[dwReaderIndex].dwMsg == CSharedData::CReaderInfo::DVRIO_READER_MSG_NONE, "");
                m_pShared->Readers[dwReaderIndex].dwFlags = 0;
                m_pShared->Readers[dwReaderIndex].dwEventSuffix = 0;
            }
            if (hEvent)
            {
                ::CloseHandle(hEvent);
            }
            delete pContext;
            if (bSet)
            {
                m_apNotificationContext[dwReaderIndex] = NULL;
            }
            if (bDecrement)
            {
                ::InterlockedDecrement((PLONG) &m_pShared->m_dwNumClients);
                // The following assert is really to ensure that m_dwNumClients has not underflowed
                // and become MAXDWORD
                DVR_ASSERT(m_pShared->m_dwNumClients <= MAX_READERS + 1   /* 1 for the writer */, "");
            }
        }
        else
        {
            pClientInfo->SetReaderIndex(dwReaderIndex);
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, "Registered at index %u", dwReaderIndex);
        }
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::RegisterReader

HRESULT CDVRFileCollection::UnregisterReader(IN  const CClientInfo* pClientInfo)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::UnregisterReader"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pClientInfo, "");
    DWORD dwReaderIndex = pClientInfo->bAmWriter?  m_dwInvalidReaderIndex : pClientInfo->dwReaderIndex;

    HRESULT hrRet;

    if (dwReaderIndex > MAX_READERS)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (dwReaderIndex == MAX_READERS)
    {
        return S_OK;
    }

    NotificationContext *pContext = NULL;
    BOOL    bReleaseSharedMemoryLock;
    BOOL    bUnlocked = 0;

    hrRet = E_FAIL;

    __try
    {
        // go on even if the lock failed

        HRESULT hr = Lock(pClientInfo, bReleaseSharedMemoryLock);
        DVR_ASSERT(hr != HRESULT_FROM_WIN32(WAIT_FAILED), "");

        DVR_ASSERT(m_pShared, "");

        pContext = m_apNotificationContext[dwReaderIndex];
        if (pContext == NULL)
        {
            hrRet = E_UNEXPECTED;
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "No notification context for reader index %u, returning hr = 0x%x",
                            dwReaderIndex, hrRet);
            __leave;
        }
        if ((m_pShared->Readers[dwReaderIndex].dwFlags & CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE) == 0)
        {
            DVR_ASSERT(0, "");

            hrRet = E_UNEXPECTED;
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "dwFlags for reader index %u is not is use, flag = %u, returning hr = 0x%x",
                            dwReaderIndex, m_pShared->Readers[dwReaderIndex].dwFlags, hrRet);
            // go on
            // __leave;
        }
        // Prevent any callbacks that are issued after this executes from calling
        // the client's callback (i.e., pContext->m_pfnCallback). This restriction
        // is not really necessary and can be dropped, but will require changes to
        // here and in NotificationRoutine() - the messages will have to be saved in
        // a member of NotificationContext and NotificationRoutine() will have to use
        // that member if m_apNotificationContext[dwReaderIndex] has been cleared.
        // [It's probably best to leave the assignment below as is so that we
        // don't have to grab the shared lock again after calling UnregisterWaitEx
        // just to clear this member.]
        m_apNotificationContext[dwReaderIndex] = NULL;

        // Make sure that the open file bit for this reader index is turned off
        // on all the file nodes
        CSharedData::CFileInfo*   pFileInfo;

        SHARED_LIST_ENTRY*  pCurrent = &m_pShared->m_leFileList;

        pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
        while (pCurrent != &m_pShared->m_leFileList)
        {
            pFileInfo = CONTAINING_RECORD(pCurrent, CSharedData::CFileInfo, leListEntry);

            // Reader should have closed the file before unregistering
            DVR_ASSERT((pFileInfo->bmOpenByReader & (1 << dwReaderIndex)) == 0, "");

            if (!IsFlagSet(ReopenMemoryMapFailed))
            {
                // Caution: We expect that the reader has closed this file and this bit is
                // already clear. We do this only to protect the next reader that gets this
                // index. The reader must call CloseReaderFile because that function does
                // other stuff such as update the time extent (if needed).
                pFileInfo->bmOpenByReader &= ~(1 << dwReaderIndex);
            }

            pCurrent = NEXT_SHARED_LIST_NODE(&m_pShared->m_leFileList, m_pListBase, pCurrent);
        }

        if (!IsFlagSet(ReopenMemoryMapFailed))
        {
            ::InterlockedDecrement((PLONG) &m_pShared->m_dwNumClients);

            if (m_pShared->Readers[dwReaderIndex].hReaderEvent == NULL)
            {
                // Writer has completed or never opened the reader's event
                m_pShared->Readers[dwReaderIndex].dwMsg = CSharedData::CReaderInfo::DVRIO_READER_MSG_NONE;
                m_pShared->Readers[dwReaderIndex].dwFlags = 0;
                m_pShared->Readers[dwReaderIndex].dwEventSuffix = 0;
            }
            else
            {
                // Tell writer to close event and free this slot

                DVR_ASSERT(dwReaderIndex < MAX_READERS, "");

                m_pShared->Readers[dwReaderIndex].dwMsg = CSharedData::CReaderInfo::DVRIO_READER_REQUEST_DONE;
                m_pShared->Readers[dwReaderIndex].dwFlags = CSharedData::CReaderInfo::DVRIO_READER_FLAG_IN_USE; // clear the other flags
            }
        }

        // Release the lock
        Unlock(pClientInfo, bReleaseSharedMemoryLock);
        bUnlocked = 1;

        if (pContext->m_hWaitObject)
        {
            // Wait for callbacks that are in progress to complete
            // when unregistering. These callbacks will not call
            // our client's callback (i.e., pContext->m_pfnCallback)
            ::UnregisterWaitEx(pContext->m_hWaitObject, INVALID_HANDLE_VALUE);
        }
        delete pContext;
        hrRet = S_OK;
    }
    __finally
    {
        if (!bUnlocked)
        {
            Unlock(pClientInfo, bReleaseSharedMemoryLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRFileCollection::UnregisterReader
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvrioreader.cpp ===
//------------------------------------------------------------------------------
// File: dvrIOReader.cpp
//
// Description: Implements the class CDVRReader
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

HRESULT STDMETHODCALLTYPE  DVRCreateReader(IN  CPVRIOCounters *             pPVRIOCounters,
                                           IN  LPCWSTR                      pwszFileName,
                                           IN  BOOL                         fUnbufferedIo,
                                           IN  DWORD                        dwIoSize,
                                           IN  DWORD                        dwBufferCount,
                                           IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                                           IN  LPVOID                       pvContext OPTIONAL,
                                           IN  HKEY                         hRegistryRootKeyParam OPTIONAL,
                                           IN  DWORD                        dwNumSids,
                                           IN  PSID*                        ppSids OPTIONAL,
                                           OUT IDVRReader**                 ppDVRReader)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DVRCreateReader"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    if (!ppDVRReader || DvrIopIsBadWritePtr(ppDVRReader, 0) ||
        !pwszFileName || DvrIopIsBadStringPtr(pwszFileName) ||
        (pfnCallback && DvrIopIsBadVoidPtr(pfnCallback)) ||
        (pvContext && DvrIopIsBadVoidPtr(pvContext))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    if (dwNumSids == 0 && ppSids)
    {
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "dwNumSids = 0, but ppSids = 0x%x is non-NULL",
                        ppSids);

        return E_INVALIDARG;
    }
    if (dwNumSids > 0 && ppSids == NULL)
    {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "dwNumSids = %u, but ppSids NULL",
                            dwNumSids);

        return E_INVALIDARG;
    }


    HRESULT         hrRet;
    CDVRReader*     p = NULL;
    HKEY            hDvrIoKey = NULL;
    HKEY            hRegistryRootKey = NULL;
    BOOL            bCloseKeys = 1; // Close all keys that we opened (only if this fn fails)


    *ppDVRReader = NULL;

    __try
    {
        DWORD dwRegRet;

        if (!hRegistryRootKeyParam)
        {
            dwRegRet = ::RegCreateKeyExW(
                            g_hDefaultRegistryHive,
                            kwszRegDvrKey,       // subkey
                            0,                   // reserved
                            NULL,                // class string
                            REG_OPTION_NON_VOLATILE, // special options
                            KEY_ALL_ACCESS,      // desired security access
                            NULL,                // security attr
                            &hRegistryRootKey,   // key handle
                            NULL                 // disposition value buffer
                           );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "RegCreateKeyExW for DVR key failed, last error = 0x%x",
                                dwLastError);
               hrRet = HRESULT_FROM_WIN32(dwLastError);
               __leave;
            }
        }
        else
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), hRegistryRootKeyParam,
                                       ::GetCurrentProcess(), (LPHANDLE) &hRegistryRootKey,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "DuplicateHandle failed for DVR IO key, last error = 0x%x",
                                dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        dwRegRet = ::RegCreateKeyExW(
                        hRegistryRootKey,
                        kwszRegDvrIoReaderKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoKey,          // key handle
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "RegCreateKeyExW for DVR IO key failed, last error = 0x%x",
                            dwLastError);
           hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

#if defined(DEBUG)
        // Until this point, we have been using default values for the debug levels
        DvrIopDbgInit(hRegistryRootKey);
#endif // DEBUG

        p = new CDVRReader(pPVRIOCounters,
                           pwszFileName,
                           dwNumSids,
                           ppSids,
                           fUnbufferedIo,
                           dwIoSize,
                           dwBufferCount,
                           pfnCallback,
                           pvContext,
                           hRegistryRootKey,
                           hDvrIoKey,
                           &hrRet);

        if (p == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - CDVRReader");
            __leave;
        }

        bCloseKeys = 0; // ~CDVRReader will close the keys

        if (FAILED(hrRet))
        {
            __leave;
        }


        hrRet = p->QueryInterface(IID_IDVRReader, (void**) ppDVRReader);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRReader failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "CDVRReader::QueryInterface failed, hr = 0x%x",
                            hrRet);
            __leave;
        }
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete p;

            if (bCloseKeys)
            {
                DWORD dwRegRet;

                if (hDvrIoKey)
                {
                    dwRegRet = ::RegCloseKey(hDvrIoKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hDvrIoKey failed.");
                    }
                }
                if (hRegistryRootKey)
                {
                    dwRegRet = ::RegCloseKey(hRegistryRootKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hRegistryRootKey failed.");
                    }
                }
            }
        }
        else
        {
            DVR_ASSERT(bCloseKeys == 0, "");
        }
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // DVRCreateReader

// ====== Constructor, destructor

#if defined(DEBUG)
DWORD CDVRReader::m_dwNextClassInstanceId = 0;
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif

CDVRReader::CDVRReader(IN  CPVRIOCounters *             pPVRIOCounters,
                       IN  CDVRFileCollection*          pRingBuffer,
                       IN  DWORD                        dwNumSids,
                       IN  PSID*                        ppSids OPTIONAL,
                       IN  DWORD                        msIndexGranularity,
                       IN  CAsyncIo *                   pAsyncIo,               //  if this is NULL, no async io
                       IN  DWORD                        dwIoSize,
                       IN  DWORD                        dwBufferCount,
                       IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                       IN  LPVOID                       pvContext OPTIONAL,
                       IN  HKEY                         hRegistryRootKey,
                       IN  HKEY                         hDvrIoKey,
                       OUT HRESULT*                     phr)
    : m_dwConsecutiveReads(0)
    , m_cnsIndexGranularity((QWORD) msIndexGranularity * k_dwMilliSecondsToCNS)
    , m_hRegistryRootKey(hRegistryRootKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_pCurrentNode(NULL)
    , m_pProfileNode(NULL)
    , m_pLiveFileReaderNode(NULL)
    , m_pWMProfile(NULL)
    , m_dwOutstandingProfileCount(0)
    , m_pDVRFileCollection(pRingBuffer)
    , m_FileCollectionInfo(FALSE)
    , m_pFileCollectionInfoAsWriter(NULL)
    , m_bDVRProgramFileIsLive(0)
    , m_nRefCount(1)
    , m_bSourceIsAnASFFile(0)
    , m_bAmWriter(0)
    , m_pAsyncIo(pAsyncIo)
    , m_dwIoSize(dwIoSize)
    , m_dwBufferCount(dwBufferCount)
    , m_pPVRIOCounters(pPVRIOCounters)
    , m_pSBERecordingAttributes(NULL)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CDVRReader[using RingBuffer]"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // Parameters have been validated, so asserts suffice
    DVR_ASSERT(m_pDVRFileCollection != NULL && !DvrIopIsBadWritePtr(m_pDVRFileCollection, 0), "");
    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");
    DVR_ASSERT(m_pPVRIOCounters, "") ;

    m_pPVRIOCounters -> AddRef () ;

    m_pDVRFileCollection->AddRef(&m_FileCollectionInfo);

    ::InitializeCriticalSection(&m_csLock);
    InitializeListHead(&m_leReadersList);
    InitializeListHead(&m_leFreeList);

    if (m_pAsyncIo) {
        m_pAsyncIo -> AddRef () ;
    }

    m_dwMinConsecutiveReads = ::GetRegDWORD(m_hDvrIoKey,
                                            kwszRegCloseReaderFilesAfterConsecutiveReadsValue,
                                            kdwRegCloseReaderFilesAfterConsecutiveReadsDefault);

    if (m_dwMinConsecutiveReads == 0)
    {
        // Not really necessary to do this. We always read at least 1 value
        // from a file before it is closed; so it is clearer if we set this
        // member to 1.
        m_dwMinConsecutiveReads = 1;
    }

    __try
    {
        HRESULT hr;

        hr = m_FileCollectionInfo.SetSids(dwNumSids, ppSids, 1);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "SetSids() failed, returning hr = 0x%x",
                            hrRet);
            __leave;
        }

        // Created signaled because ASF SDK tries to read samples
        // when the file is opened and we don't want to block on that
        m_hCancel = ::CreateEventW(NULL,        // security attr
                                   TRUE,        // manual reset
                                   TRUE,        // signaled
                                   NULL         // name
                                  );

        if (m_hCancel == NULL)
        {
            DWORD dwLastError = ::GetLastError();
            DVR_ASSERT(0, "");
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        hr = m_pDVRFileCollection->RegisterReader(&m_FileCollectionInfo, pfnCallback, pvContext);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        // The reader index should not be CDVRFileCollection::MAX_READERS
        DVR_ASSERT(m_FileCollectionInfo.dwReaderIndex < CDVRFileCollection::MAX_READERS, "");

        hrRet = S_OK;
    }
    __finally
    {
        if (phr)
        {
            *phr = hrRet;
        }
        m_nRefCount--; // Do not call release, we don't want the object destroyed!
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRReader::CDVRReader

CDVRReader::CDVRReader(IN  CPVRIOCounters *             pPVRIOCounters,
                       IN  LPCWSTR                      pwszFileName,
                       IN  DWORD                        dwNumSids,
                       IN  PSID*                        ppSids OPTIONAL,
                       IN  BOOL                         fUnbufferedIo,
                       IN  DWORD                        dwIoSize,
                       IN  DWORD                        dwBufferCount,
                       IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                       IN  LPVOID                       pvContext OPTIONAL,
                       IN  HKEY                         hRegistryRootKey,
                       IN  HKEY                         hDvrIoKey,
                       OUT HRESULT*                     phr)
    : m_dwConsecutiveReads(0)
    , m_hRegistryRootKey(hRegistryRootKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_pCurrentNode(NULL)
    , m_pProfileNode(NULL)
    , m_pLiveFileReaderNode(NULL)
    , m_pWMProfile(NULL)
    , m_dwOutstandingProfileCount(0)
    , m_pDVRFileCollection(NULL)
    , m_FileCollectionInfo(FALSE)
    , m_pFileCollectionInfoAsWriter(NULL)
    , m_bDVRProgramFileIsLive(0)
    , m_nRefCount(1)
    , m_bSourceIsAnASFFile(1)               //  properly initialized below
    , m_bAmWriter(0)
    , m_pAsyncIo(NULL)
    , m_dwIoSize(dwIoSize)
    , m_dwBufferCount(dwBufferCount)
    , m_pPVRIOCounters(pPVRIOCounters)
    , m_pSBERecordingAttributes(NULL)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CDVRReader[using File]"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // Parameters have been validated, so asserts suffice
    DVR_ASSERT(pwszFileName != NULL && !DvrIopIsBadStringPtr(pwszFileName), "");
    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");
    DVR_ASSERT(m_pPVRIOCounters, "") ;

    ::InitializeCriticalSection(&m_csLock);
    InitializeListHead(&m_leReadersList);
    InitializeListHead(&m_leFreeList);

    m_pPVRIOCounters -> AddRef () ;

    __try
    {
        LIST_ENTRY* pReader;
        HRESULT hr;

#if defined(DVRIO_FABRICATE_SIDS)
        PSID    pFabricatedSid = NULL;
        DWORD   dwFabricateSids = ::GetRegDWORD(m_hDvrIoKey,
                                                kwszRegFabricateSidsValue,
                                                kdwRegFabricateSidsDefault);
        if (!ppSids && dwNumSids == 0 && dwFabricateSids)
        {
            SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

            // Create owner SID
            if (!::AllocateAndInitializeSid(&SIDAuthNT, 1,
                                            SECURITY_AUTHENTICATED_USER_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &pFabricatedSid))
            {
                DWORD dwLastError = GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "::AllocateAndInitializeSid of authenticated user SID failed; last error = 0x%x",
                                dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }

            dwNumSids = 1;
            ppSids = &pFabricatedSid;
        }
#endif // if defined(DVRIO_FABRICATE_SIDS)

        hr = m_FileCollectionInfo.SetSids(dwNumSids, ppSids, 1);

#if defined(DVRIO_FABRICATE_SIDS)
        if (pFabricatedSid)
        {
            ::FreeSid(pFabricatedSid);
        }
#endif // if defined(DVRIO_FABRICATE_SIDS)

        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "SetSids() failed, returning hr = 0x%x",
                            hrRet);
            __leave;
        }

        m_dwMinConsecutiveReads = ::GetRegDWORD(m_hDvrIoKey,
                                                kwszRegCloseReaderFilesAfterConsecutiveReadsValue,
                                                kdwRegCloseReaderFilesAfterConsecutiveReadsDefault);

        if (m_dwMinConsecutiveReads == 0)
        {
            // Not really necessary to do this. We always read at least 1 value
            // from a file before it is closed; so it is clearer if we set this
            // member to 1.
            m_dwMinConsecutiveReads = 1;
        }

        // Created signaled because ASF SDK tries to read samples
        // when the file is opened and we don't want to block on that
        m_hCancel = ::CreateEventW(NULL,        // security attr
                                   TRUE,        // manual reset
                                   TRUE,        // signaled
                                   NULL         // name
                                  );

        if (m_hCancel == NULL)
        {
            DWORD dwLastError = ::GetLastError();
            DVR_ASSERT(0, "");
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        //  setup for async io, if we're unbuffered
        if (fUnbufferedIo) {
            m_pAsyncIo = new CAsyncIo () ;
            if (!m_pAsyncIo) {
                (* phr) = E_OUTOFMEMORY ;
                __leave ;
            }

            //  ours
            m_pAsyncIo -> AddRef () ;
        }

        DWORD msIndexGranularity;

        m_pDVRFileCollection = new CDVRFileCollection(&m_FileCollectionInfo,
                                                      pwszFileName,
                                                      &msIndexGranularity,
                                                      &hr);


        if (!m_pDVRFileCollection)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - CDVRFileCollection::CClientInfo");
            __leave;
        }

        if (FAILED(hr))
        {
            //  tried to map the specified file and it wasn't one of our stub
            //    files; so the specified file must be a proper ASF file
            m_bSourceIsAnASFFile = TRUE ;

            m_pDVRFileCollection->Release(&m_FileCollectionInfo);

            // Check to see if the ASF reader can open this file

            // We get by with using &m_FileCollectionInfo (a reader context rather
            // than a writer) because the file colleciton we create is not mapped)
            // Note that if this is a true ASF file, we release the collection
            // with m_pFileCollectionInfoAsWriter in CDVRReader::Close
            m_pDVRFileCollection = new CDVRFileCollection(&m_FileCollectionInfo,
                                                          0,            // Min temp files
                                                          0,            // Max temp files
                                                          1,            // Max files
                                                          0,            // Grow by
                                                          TRUE,         // bStartTimeFixedAtZero
                                                          MAXDWORD,     // Index granularity - we don't use the
                                                                        // value that we set in the file collection.
                                                                        // (Note that the file collection is not shared.)
                                                          NULL,         // Temporary files directory
                                                          NULL,         // Ring buffer file name
                                                          FALSE,        // not a multi-file recording
                                                          &hr);
            if (!m_pDVRFileCollection)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - CDVRFileCollection");
                __leave;
            }

            // We are the writer of this file collection object.
            m_bAmWriter = 1;

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
        }
        else {
            //  successfully mapped the specified file, so we're not reading
            //    from an ASF file proper
            m_bSourceIsAnASFFile = FALSE ;
        }

        // Get a reader index
        hr = m_pDVRFileCollection->RegisterReader(&m_FileCollectionInfo, pfnCallback, pvContext);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        DVR_ASSERT(m_FileCollectionInfo.dwReaderIndex <= CDVRFileCollection::MAX_READERS, "");

        if (m_bAmWriter)
        {
            m_pFileCollectionInfoAsWriter = new CDVRFileCollection::CClientInfo(TRUE);
            if (!m_pFileCollectionInfoAsWriter)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - CDVRFileCollection");
                __leave;
            }

            // SIDs are unused in the collection we create because the
            // file collection is not shared (either within or outside
            // this process)
            hr = m_pFileCollectionInfoAsWriter->SetSids(0, NULL);
            if (FAILED(hr))
            {
                hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "SetSids() failed, returning hr = 0x%x",
                                hrRet);
                __leave;
            }

            // File was opened with the ASF reader

            hr = AddAPermanentFile(pwszFileName);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            // For now, we never need to try to open the next file
            // If we support ASX files, remove the "1 ||"
            if (1 || !m_bDVRProgramFileIsLive)
            {
                // No need to try to open the next reader file in GetNextSample.
                m_dwConsecutiveReads = INFINITE;
            }
        }
        else
        {
            m_cnsIndexGranularity = (QWORD) msIndexGranularity  * k_dwMilliSecondsToCNS;
        }

        hrRet = S_OK;
    }
    __finally
    {
        if (phr)
        {
            *phr = hrRet;
        }
        m_nRefCount--; // Do not call release, we don't want the object destroyed!
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRReader::CDVRReader

CDVRReader::~CDVRReader()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::~CDVRReader"

    DVRIO_TRACE_ENTER();

    // Each GetProfile call addref's this object. So this function
    // will be called only when all profiles have been released (by
    // calling ReleaseProfile)
    DVR_ASSERT(m_dwOutstandingProfileCount == 0, "");
    DVR_ASSERT(m_pProfileNode == NULL, "");
    DVR_ASSERT(m_pWMProfile == NULL, "");

    HRESULT hr;

    hr = Close();

    DVR_ASSERT(m_hRegistryRootKey, "");

    DWORD dwRegRet = ::RegCloseKey(m_hRegistryRootKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hRegistryRootKey failed.");
    }

    DVR_ASSERT(m_hDvrIoKey, "");

    dwRegRet = ::RegCloseKey(m_hDvrIoKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hDvrIoKey failed.");
    }

    delete m_pFileCollectionInfoAsWriter;

    // Close should have cleaned up all this:
    DVR_ASSERT(m_pCurrentNode == NULL, "");
    DVR_ASSERT(m_pDVRFileCollection == NULL, "");
    DVR_ASSERT(IsListEmpty(&m_leReadersList), "");
    DVR_ASSERT(IsListEmpty(&m_leFreeList), "");

    delete m_pSBERecordingAttributes ;

    if (m_pAsyncIo) {
        //  ours
        m_pAsyncIo -> Release () ;
    }

    m_pPVRIOCounters -> Release () ;

    if (m_hCancel)
    {
        ::CloseHandle(m_hCancel);
    }
    ::DeleteCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE0();

} // CDVRReader::~CDVRReader()


// ====== Helper methods

// static
DWORD WINAPI CDVRReader::ProcessOpenRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ProcessOpenRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be removed from m_leReadersList till hReadyToReadFrom is set
    // and Close() will not delete the node without removing it from the
    // writer's list (and waiting for the file to be closed)

    PASF_READER_NODE pReaderNode = (PASF_READER_NODE) p;

    DVR_ASSERT(pReaderNode, "");
    DVR_ASSERT(pReaderNode->pWMReader, "");
    DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");
    DVR_ASSERT(::WaitForSingleObject(pReaderNode->hReadyToReadFrom, 0) == WAIT_TIMEOUT, "");

    BOOL            bCloseFile = 0;
    BOOL            bCloseReader = 0;
    IStream*        pIStream = NULL;
    IWMProfile*     pWMProfile = NULL;

    __try
    {
        HRESULT hr;

        // Do NOT change pReaderNode->hrRet after this till ProcessCloseRequest.
        // ProcessCloseRequest relies on seeing the value returned by Open
        DVR_ASSERT(pReaderNode->pwszFileName != NULL &&
                   !DvrIopIsBadStringPtr(pReaderNode->pwszFileName), "");

#if 0
        // Note that this call may fail if the BeginWriting call has not yet been
        // issued by the writer. Since the writer does that asynchronously (see Note 1),
        // the reader may be able to find the file in the file buffer and issue the
        // Open and the BeginWriting may not have compeleted. The reader and writer
        // clients have to be in sync or the reader (the client of this object)
        // should be prepared to poll, e..g, if Seek() or GetProfile() fails..
        //
        // Note 1: Actually, CDVRRingBufferWriter::AddATemporaryFile calls the
        // file collection's AddFile method to get a file name before it calls
        // CDVRRingBufferWriter::PrepareAFreeWriterNode (which creates the file).
        // So the problem is not caused just because the call to BeginWriting is
        // made asynchronously.
        //
        // Note 2: This is not an issue if the reader only opens files for times <=
        // the last stream time (since the writer has already written to them
        // and it updates the last stream time only after writing) EXCEPT before
        // the first write. At that time, the last stream time is set to the
        // file's start time though a sample has not been written and the file may
        // not have been fully opened.
        hr = pReaderNode->hrRet = pReaderNode->pWMReader->Open(pReaderNode->pwszFileName);
        if (FAILED(hr))
        {
            hrRet = hr;

            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Open failed; hr = 0x%x for file id %u",
                            hrRet, pReaderNode->nFileId);
            __leave;
        }
#endif

        DVR_ASSERT(pReaderNode->pDVRFileSource, "");

        hr = pReaderNode->pDVRFileSource->Open(pReaderNode->pwszFileName,
                                               pReaderNode->hCancel,
                                               pReaderNode->msTimeOut);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pDVRFileSource->Open failed; hr = 0x%x for file id %u",
                            hrRet, pReaderNode->nFileId);
            __leave;
        }
        bCloseFile = 1;

        hr = pReaderNode->pDVRFileSource->QueryInterface(IID_IStream, (LPVOID*) &pIStream);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pDVRFileSource->QueryInterface for IID_IStream failed; hr = 0x%x for file id %u",
                            hrRet, pReaderNode->nFileId);
            __leave;
        }

        hr = pReaderNode->pWMReader->OpenStream(pIStream);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pWMReader->OpenStream failed; hr = 0x%x for file id %u",
                            hrRet, pReaderNode->nFileId);
            __leave;
        }
        bCloseReader = 1;

        // Get the file version guid

        hr = pReaderNode->pWMReader->QueryInterface(IID_IWMHeaderInfo, (void**) &pReaderNode->pIWMHeaderInfo);

        if (FAILED(hr))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "QI for IID_IWMHeaderInfo failed, hr = 0x%x",
                            hr);
            hrRet = hr;
            __leave;
        }

        WORD                wStreamNum;
        WMT_ATTR_DATATYPE   Type;
        WORD                wLength;
        GUID                fileVersion;

        wStreamNum = 0;
        wLength = sizeof(fileVersion);

        hr = pReaderNode->pIWMHeaderInfo->GetAttributeByName(&wStreamNum, g_kwszDVRFileVersion, &Type,
                                               (BYTE*) &fileVersion, &wLength);

        if (SUCCEEDED(hr) &&
            (Type != WMT_TYPE_BINARY  || wLength != sizeof(fileVersion) ||
             memcmp(&fileVersion, &CDVRFileCollection::m_guidV5, sizeof(fileVersion)) != 0)
           )
        {
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pIWMHeaderInfo->GetAttributeByName for file version succeeded, but Type = %d (expected %d) wrong, length = %d, wrong, or guid returned is wrong",
                            Type, WMT_TYPE_BINARY, wLength);
            hrRet = NS_E_INCOMPATIBLE_VERSION;
            __leave;
        }
        else if (FAILED(hr))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pIWMHeaderInfo->GetAttributeByName for file version failed, hr = 0x%x",
                            hr);
            hrRet = hr;
            __leave;
        }

        hr = pReaderNode->pWMReader->QueryInterface(IID_IWMProfile, (LPVOID*) &pWMProfile);
        if (FAILED(hr))
        {
            hrRet = hr;

            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pWMReader->QueryInterface for IID_IWMProfile failed; hr = 0x%x for file id %u",
                            hrRet, pReaderNode->nFileId);
            __leave;
        }

        DWORD dwNumStreams;

        hr = pWMProfile->GetStreamCount(&dwNumStreams);
        if (FAILED(hr))
        {
            hrRet = hr;

            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWMProfile->GetStreamCount failed; hr = 0x%x for file id %u",
                            hrRet, pReaderNode->nFileId);
            __leave;
        }

        DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                        "Num streams for file %u is = %u",
                        pReaderNode->nFileId, dwNumStreams);

        for (; dwNumStreams > 0; dwNumStreams--)
        {
            hr = pReaderNode->pWMReader->SetReadStreamSamples((WORD) dwNumStreams, TRUE);
            if (FAILED(hr))
            {
                hrRet = hr;

                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pReaderNode->pWMReader->SetReadCompressedSamples failed for stream %u; hr = 0x%x for file id %u",
                                dwNumStreams, hrRet, pReaderNode->nFileId);
                __leave;
            }
        }

        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                        "Open succeeded for file %u, hrRet = S_OK",
                        pReaderNode->nFileId);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            HRESULT hr;

            if (bCloseReader)
            {
                hr = pReaderNode->pWMReader->Close();
                DVR_ASSERT(SUCCEEDED(hr), "pReaderNode->pWMReader->Close failed");
            }
            if (bCloseFile)
            {
                hr = pReaderNode->pDVRFileSource->Close();
                DVR_ASSERT(SUCCEEDED(hr), "pReaderNode->pDVRFileSource->Close failed");
            }
        }
        if (pWMProfile)
        {
            pWMProfile->Release();
        }
        if (pIStream)
        {
            pIStream->Release();
        }
        pReaderNode->hrRet = hrRet;
        pReaderNode->hCancel = NULL;    // We don't need it and it should not be used
        ::SetEvent(pReaderNode->hReadyToReadFrom);
    }

    // It's unsafe to reference pReaderNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRReader::ProcessOpenRequest

CSBERecordingAttributes *
CDVRReader::RecordingAttributes (
    )
{
    HRESULT hr ;
    LPWSTR  pszAttrFilename ;

    if (m_pSBERecordingAttributes) {
        return m_pSBERecordingAttributes ;
    }

    hr              = S_OK ;
    pszAttrFilename = NULL ;

    __try {

        if (IsContentRecording () &&
            m_pCurrentNode) {

            DVR_ASSERT (m_pCurrentNode -> pIWMHeaderInfo, "") ;
            m_pSBERecordingAttributes = new CSBERecordingAttributesWM (m_pCurrentNode -> pIWMHeaderInfo) ;
            if (m_pSBERecordingAttributes) {
                hr = m_pSBERecordingAttributes -> Load () ;
            }
        }
        else if (IsReferenceRecording ()) {
            hr = m_pDVRFileCollection -> GetAttributeFile (&m_FileCollectionInfo, & pszAttrFilename) ;
            if (FAILED (hr)) {
                __leave ;
            }

            m_pSBERecordingAttributes = new CSBERecordingAttributesFile (
                                                pszAttrFilename,
                                                & hr
                                                ) ;
            if (!m_pSBERecordingAttributes) {
                hr = E_OUTOFMEMORY ;
                __leave ;
            }
            else if (FAILED (hr)) {
                __leave ;
            }

            DVR_ASSERT (pszAttrFilename, "") ;

            hr = m_pSBERecordingAttributes -> Load () ;
            if (FAILED (hr)) {
                __leave ;
            }
        }
    }
    __finally {

        //  reset this if anything failed
        if (FAILED (hr)) {
            delete m_pSBERecordingAttributes ;
            m_pSBERecordingAttributes = NULL ;
        }

        delete [] pszAttrFilename ;
    }

    return m_pSBERecordingAttributes ;
}

STDMETHODIMP
CDVRReader::SetDVRIORecordingAttribute (
    IN  LPCWSTR                     pszAttributeName,
    IN  WORD                        wStreamNumber,
    IN  STREAMBUFFER_ATTR_DATATYPE  DataType,
    IN  BYTE *                      pbAttribute,
    IN  WORD                        wAttributeLength
    )
{
    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::SetDVRIORecordingAttribute"

    DVRIO_TRACE_ENTER();

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> SetAttribute (
                    wStreamNumber,
                    pszAttributeName,
                    DataType,
                    pbAttribute,
                    wAttributeLength
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);
    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet ;
}

STDMETHODIMP
CDVRReader::GetDVRIORecordingAttributeCount (
    IN  WORD    wStreamNumber,
    OUT WORD *  pcAttributes
    )
{
    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetDVRIORecordingAttributeCount"

    DVRIO_TRACE_ENTER();

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> GetAttributeCount (
                    wStreamNumber,
                    pcAttributes
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);
    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet ;
}

STDMETHODIMP
CDVRReader::GetDVRIORecordingAttributeByName (
    IN      LPCWSTR                         pszAttributeName,
    IN OUT  WORD *                          pwStreamNumber,
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetDVRIORecordingAttributeByName"

    DVRIO_TRACE_ENTER();

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> GetAttributeByName (
                    pszAttributeName,
                    pwStreamNumber,
                    pDataType,
                    pbAttribute,
                    pcbLength
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);
    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet ;
}

STDMETHODIMP
CDVRReader::GetDVRIORecordingAttributeByIndex (
    IN      WORD                            wIndex,
    IN OUT  WORD *                          pwStreamNumber,
    OUT     WCHAR *                         pszAttributeName,
    IN OUT  WORD *                          pcchNameLength,
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    HRESULT                     hrRet;
    CSBERecordingAttributes *   pRecordingAttributes ;

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetDVRIORecordingAttributeByIndex"

    DVRIO_TRACE_ENTER();

    ::EnterCriticalSection(&m_csLock);

    pRecordingAttributes = RecordingAttributes () ;
    if (pRecordingAttributes) {
        hrRet = pRecordingAttributes -> GetAttributeByIndex (
                    wIndex,
                    pwStreamNumber,
                    pszAttributeName,
                    pcchNameLength,
                    pDataType,
                    pbAttribute,
                    pcbLength
                    ) ;
    }
    else {
        hrRet = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_csLock);
    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet ;
}

HRESULT CDVRReader::PrepareAFreeReaderNode(
    IN LPCWSTR                              pwszFileName,
    IN DWORD                                msTimeOut,
    IN CDVRFileCollection::DVRIOP_FILE_ID   nFileId,
    OUT LIST_ENTRY*&                        rpFreeNode)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::PrepareAFreeReaderNode"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;
    PASF_READER_NODE    pFreeNode;

    LIST_ENTRY*         pCurrent = &m_leFreeList;
    BOOL                bRestore = 0;

    __try
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        while (pCurrent != &m_leFreeList)
        {
            pFreeNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);
            DVR_ASSERT(pFreeNode->hFileClosed, "");
            if (::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0)
            {
                // Verify that the hReadyToReadFrom event is reset
                DWORD nRet = ::WaitForSingleObject(pFreeNode->hReadyToReadFrom, 0);
                if (nRet == WAIT_TIMEOUT)
                {
                    break;
                }

                DVR_ASSERT(nRet != WAIT_OBJECT_0, "Free list node's hReadyToReadFrom is set?");
                if (nRet == WAIT_OBJECT_0)
                {
                    // This shouldn't happen; ignore the node and go on.
                    // Debug version will assert each time it hits this
                    // node!
                }
                else
                {
                    // This shouldn't happen either. Ignore this node and
                    // move on.
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "WFSO(hReadyToReadFrom) failed; hReadyToReadFrom = 0x%p, last error = 0x%x",
                                    pFreeNode->hReadyToReadFrom, dwLastError);
                }
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }
        if (pCurrent == &m_leFreeList)
        {
            // Create a new node

            pFreeNode = new ASF_READER_NODE(&hrRet);

            if (pFreeNode == NULL)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - ASF_READER_NODE");
                pCurrent = NULL;
                __leave;
            }
            else if (FAILED(hrRet))
            {
                delete pFreeNode;
                pFreeNode = NULL;
                pCurrent = NULL;
                __leave;
            }
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0, "");
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hReadyToReadFrom, 0) == WAIT_TIMEOUT, "");

            InsertHeadList(&m_leFreeList, &pFreeNode->leListEntry);
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
            DVR_ASSERT(pCurrent == &pFreeNode->leListEntry, "");
        }

        DVR_ASSERT(pCurrent != &m_leFreeList, "");

        // Create an ASF writer object if needed
        if (!pFreeNode->pWMReader)
        {
            IWMSyncReader* pWMReader;

            hrRet = ::WMCreateSyncReader(NULL, 0, &pWMReader);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "WMCreateSyncReader failed; hr = 0x%x",
                                hrRet);
                __leave;
            }
            pFreeNode->pWMReader = pWMReader; // Released only in Close()
        }

        if (!pFreeNode->pDVRFileSource)
        {
            IDVRFileSource* pDVRFileSource;
            IDVRSourceAdviseSink* pDVRSourceAdviseSink = NULL;

            if (m_bSourceIsAnASFFile)
            {
                // When reading from a tuner source (i.e., if m_bSourceIsAnASFFile == 0)
                // the writer updates the stream extent in the file collection object
                // and we get the extent directly from the stream collection object.
                // When reading from a live file, the stream extent is known only
                // at the DVR Stream Source layer. UpdateTimeExtent() retrieves this
                // info and sets it in the file collection object used by the reader.
                //
                // UpdateTimeExtent is called on demand, e.g., when the client wants
                // the current time extent or when it seeks. However, if the reader
                // blocks in the DVR Stream Source, waiting for the writer to catch up,
                // we call UpdateTimeExtent just before it blocks. This is done by
                // providing an advise sink to the DVR Stream Source.
                //
                // We do not need to provide the sink if we are reading a non-live file
                // source, but it doesn't matter because we'll never be called back.

                hrRet = QueryInterface(IID_IDVRSourceAdviseSink, (void**) &pDVRSourceAdviseSink);
                if (FAILED(hrRet))
                {
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "QI for IID_IDVRSourceAdviseSink failed; hr = 0x%x",
                                    hrRet);
                    __leave;
                }
                DVR_ASSERT(pDVRSourceAdviseSink, "");

                // Release, otherwise, we'll have circular ref counts
                pDVRSourceAdviseSink->Release();

            }

            hrRet = ::DVRCreateDVRFileSource(m_hRegistryRootKey, m_hDvrIoKey,
                                             m_FileCollectionInfo.dwNumSids, m_FileCollectionInfo.ppSids,
                                             &pDVRFileSource, pDVRSourceAdviseSink);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "DVRCreateDVRFileSource failed; hr = 0x%x",
                                hrRet);
                __leave;
            }
            pFreeNode->pDVRFileSource = pDVRFileSource; // Released only in Close()

            //  if IO is going to unbuffered, set that up now
            if (m_pAsyncIo) {
                IDVRFileSource2 *       pIDVRFileSource2 ;
                CPVRAsyncReaderCOM *    pAsyncReaderCOM ;

                hrRet = pFreeNode->pDVRFileSource -> QueryInterface (
                            IID_IDVRFileSource2,
                            (void **) & pIDVRFileSource2
                            ) ;

                if (SUCCEEDED (hrRet)) {

                    // Note that the async reader object never creates the
                    // shared kernel objects. The async writer object creates
                    // them and the reader object merely opens them. (There
                    // are no race conditions.) So there is no need to send in
                    // the SIDs to the reader object.
                    pAsyncReaderCOM = new CPVRAsyncReaderCOM (
                                                m_dwIoSize,
                                                m_dwBufferCount,
                                                m_pAsyncIo,
                                                m_pPVRIOCounters
                                                // m_FileCollectionInfo.dwNumSids,
                                                // m_FileCollectionInfo.ppSids
                                                ) ;
                    if (!pAsyncReaderCOM) {

                        DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "failed to instantiate CPVRAsyncReaderCOM") ;

                        hrRet = E_OUTOFMEMORY ;

                        pIDVRFileSource2 -> Release () ;

                        __leave ;
                    }

                    pAsyncReaderCOM -> AddRef () ;

                    hrRet = pIDVRFileSource2 -> SetAsyncIOReader (pAsyncReaderCOM) ;

                    pAsyncReaderCOM -> Release () ;

                    pIDVRFileSource2 -> Release () ;

                    if (FAILED (hrRet)) {
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "failed to initialize IDVRFileSourc2 with the async reader (%08xh)",
                                        hrRet) ;
                        __leave ;
                    }
                }
                else {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "QI for IDVRFileSourc2 failed") ;
                    __leave;

                }
            }
        }

        pFreeNode->nFileId = nFileId;
        pFreeNode->msTimeOut = msTimeOut;
        pFreeNode->hrRet = S_OK;
        DVR_ASSERT(pwszFileName != NULL && !DvrIopIsBadStringPtr(pwszFileName), "");
        pFreeNode->SetFileName(pwszFileName);
        pFreeNode->hCancel = m_hCancel;
        ::ResetEvent(pFreeNode->hFileClosed);
        bRestore = 1;

        // Issue the call to Open
        if (::QueueUserWorkItem(ProcessOpenRequest, pFreeNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "QueueUserWorkItem failed; last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        // Note: If any step can fail after this, we have to be sure
        // to put this node back into the free list
        RemoveEntryList(pCurrent);
        NULL_LIST_NODE_POINTERS(pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            rpFreeNode = NULL;
            if (bRestore)
            {
                DVR_ASSERT(pFreeNode, "");
                pFreeNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
                pFreeNode->hCancel = NULL;
                pFreeNode->SetFileName(NULL);
                ::SetEvent(pFreeNode->hFileClosed);
            }
        }
        else
        {
            rpFreeNode = pCurrent;
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::PrepareAFreeReaderNode


HRESULT CDVRReader::AddToReadersList(IN LIST_ENTRY*   pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::AddToReadersList"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    __try
    {
        // Insert into m_leReadersList

        BOOL                bFound = 0;
        LIST_ENTRY*         pTmp = &m_leReadersList;
        PASF_READER_NODE    pReaderNode;
        CDVRFileCollection::DVRIOP_FILE_ID   nFileId;

        pReaderNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);
        nFileId = pReaderNode->nFileId;

        while (NEXT_LIST_NODE(pTmp) != &m_leReadersList)
        {
            pTmp = NEXT_LIST_NODE(pTmp);
            pReaderNode = CONTAINING_RECORD(pTmp, ASF_READER_NODE, leListEntry);
            if (nFileId < pReaderNode->nFileId)
            {
                // All ok; we should insert before pTmp
                bFound = 1;
                break;
            }
            if (nFileId == pReaderNode->nFileId)
            {
                // Trouble
                DVR_ASSERT(nFileId != pReaderNode->nFileId, "File id already present in readers list");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File id %u already in readers list, being reinserted.",
                                pReaderNode->nFileId);
                hrRet = E_FAIL;
                __leave;
            }
        }

        if (!bFound)
        {
            // We insert at tail
            pTmp = NEXT_LIST_NODE(pTmp);;
            DVR_ASSERT(pTmp == &m_leReadersList, "");
        }
        InsertTailList(pTmp, pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up necessary
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::AddToReadersList

HRESULT CDVRReader::AddAPermanentFile(IN LPCWSTR pwszFileNameParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::AddAPermanentFile"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(m_bAmWriter, "");
    DVR_ASSERT(m_pFileCollectionInfoAsWriter, "");

    HRESULT hrRet = E_FAIL;

    PASF_READER_NODE    pReaderNode = NULL;
    LPWSTR              pwszFileName = NULL;
    LIST_ENTRY*         pReader = NULL;
    BOOL                bAdded = 0;
    BOOL                bDecRefCount = 0;
    BOOL                bCloseFile = 0;
    BOOL                bRemoveRingBufferFile = 0;
    QWORD               cnsCurrentStreamTime;


    __try
    {
        HRESULT hr;

        pwszFileName = new WCHAR[wcslen(pwszFileNameParam)+1];

        if (!pwszFileName)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - WCHAR[%u]",
                            wcslen(pwszFileNameParam)+1);
            __leave;
        }
        wcscpy(pwszFileName, pwszFileNameParam);

        hr = PrepareAFreeReaderNode(pwszFileName,
                                    1000,                   // timeout in msec
                                    CDVRFileCollection::DVRIOP_INVALID_FILE_ID,
                                    pReader);

        // PrepareAFreeReaderNode will delete pwszFileName regardless of
        // whether it succeeds or fails.
        pwszFileName = NULL;

        if (FAILED(hr))
        {
            DVR_ASSERT(pReader == NULL,
                       "PrepareAFreeReaderNode returns failure but pReader is not NULL");
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(pReader, "PrepareAFreeReaderNode returns success but pReader is NULL");

        pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;

        DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");

        // Wait for the ASF file open to complete

        DWORD nRet = ::WaitForSingleObject(pReaderNode->hReadyToReadFrom, INFINITE);
        if (nRet == WAIT_FAILED)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "WFSO(hReadyToReadFrom) failed while waiting for file open to complete; "
                            "hReadyToReadFrom = 0x%p, last error = 0x%x",
                            pReaderNode->hReadyToReadFrom, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        if (pReaderNode->hrRet == HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            // SDK pre-reads when it opens a file. Ignore the result if
            // it could not read because it was reading ahead of the writer..
            pReaderNode->hrRet = S_OK;
        }
        if (FAILED(pReaderNode->hrRet))
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Open of permanent file failed in ProcessOpenRequest." // pReaderNode-nFileId will be the invalid id
                           );
            hrRet = pReaderNode->hrRet;
            __leave;
        }
        bCloseFile = 1;

        // Note that we will need a start and an end time if we support ASX files

        BOOL bShared;

        hr = pReaderNode->pDVRFileSource->IsFileLive(&m_bDVRProgramFileIsLive, &bShared);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pDVRFileSource->IsFileLive failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        if (bShared)
        {
            // Don't need the file collection lock to update this member here
            // since we know we are not sharing it with a writer

            hr = pReaderNode->pDVRFileSource->GetLastTimeStamp(&cnsCurrentStreamTime);
            if (FAILED(hr))
            {
                hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pReaderNode->pDVRFileSource->GetLastTimeStamp failed; hr = 0x%x",
                                hrRet);
                __leave;
            }
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                            "File is live, last time stamp is %I64u",
                            cnsCurrentStreamTime);

            hr = m_pDVRFileCollection->SetLastStreamTime(m_pFileCollectionInfoAsWriter, cnsCurrentStreamTime);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            m_pLiveFileReaderNode = pReaderNode;

            hr = pReaderNode->pWMReader->QueryInterface(IID_IWMHeaderInfo, (void**) &pReaderNode->pIWMHeaderInfo);

            if (FAILED(hr))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "QI for IID_IWMHeaderInfo failed, hr = 0x%x",
                                hr);
                hrRet = hr;
                __leave;
            }

            // Get the index granularity

            WORD                wStreamNum;
            WMT_ATTR_DATATYPE   Type;
            WORD                wLength;
            DWORD               msIndexGranularity;

            wStreamNum = 0;
            wLength = sizeof(msIndexGranularity);

            hr = pReaderNode->pIWMHeaderInfo->GetAttributeByName(&wStreamNum, g_kwszDVRIndexGranularity, &Type,
                                                   (BYTE*) &msIndexGranularity, &wLength);

            if (SUCCEEDED(hr) && (Type != WMT_TYPE_DWORD  || wLength != sizeof(msIndexGranularity) || msIndexGranularity == 0))
            {
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pReaderNode->pIWMHeaderInfo->GetAttributeByName for index granularity succeeded, but Type = %d (expected %d) wrong, length = %d, wrong, or granularity returned= 0",
                                Type, WMT_TYPE_DWORD, wLength);
                hrRet = NS_E_INVALID_DATA;
                __leave;
            }
            else if (FAILED(hr))
            {
                // default the value
                msIndexGranularity = g_kmsDVRDefaultIndexGranularity;
            }
            m_cnsIndexGranularity = (QWORD) msIndexGranularity  * k_dwMilliSecondsToCNS;
        }
        else
        {
            // We have to get the duration from the header. Note that this
            // is slightly more than the last time stamp (since it includes the
            // duration of the last sample), but it will have to do.

            hr = pReaderNode->pWMReader->QueryInterface(IID_IWMHeaderInfo, (void**) &pReaderNode->pIWMHeaderInfo);

            if (FAILED(hr))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "QI for IID_IWMHeaderInfo failed, hr = 0x%x",
                                hr);
                hrRet = hr;
                __leave;
            }

            WORD                wStreamNum = 0;
            WMT_ATTR_DATATYPE   Type;
            WORD                wLength = sizeof(cnsCurrentStreamTime);

            hr = pReaderNode->pIWMHeaderInfo->GetAttributeByName(&wStreamNum, g_wszWMDuration, &Type,
                                                   (BYTE*) &cnsCurrentStreamTime, &wLength);

            if (FAILED(hr) || Type != WMT_TYPE_QWORD  || wLength != sizeof(cnsCurrentStreamTime))
            {
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pReaderNode->pIWMHeaderInfo->GetAttributeByName for duration failed, hr = 0x%x, but Type = %d (expected %d), length = %d",
                                Type, WMT_TYPE_QWORD, wLength);
                hrRet = hr;
                __leave;
            }

            if (cnsCurrentStreamTime == 0)
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "Duration of non-live file is 0, failing open.");
                hrRet = NS_E_INVALID_DATA;
                __leave;
            }

            // Subtract 1 since the ring buffer extent always corresponds to the last written sample.
            cnsCurrentStreamTime--;

            hr = m_pDVRFileCollection->SetWriterHasBeenClosed(m_pFileCollectionInfoAsWriter);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                            "File is not live; extent is %I64u",
                            cnsCurrentStreamTime);

            hr = m_pDVRFileCollection->SetLastStreamTime(m_pFileCollectionInfoAsWriter, cnsCurrentStreamTime);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            // Get the index granularity
            DWORD   msIndexGranularity;

            wStreamNum = 0;
            wLength = sizeof(msIndexGranularity);

            hr = pReaderNode->pIWMHeaderInfo->GetAttributeByName(&wStreamNum, g_kwszDVRIndexGranularity, &Type,
                                                   (BYTE*) &msIndexGranularity, &wLength);

            if (SUCCEEDED(hr) && (Type != WMT_TYPE_DWORD  || wLength != sizeof(msIndexGranularity) || msIndexGranularity == 0))
            {
                DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pReaderNode->pIWMHeaderInfo->GetAttributeByName for index granularity succeeded, Type = %d (expected %d) wrong, length = %d, wrong, or granularity returned= 0",
                                hr, Type, WMT_TYPE_DWORD, wLength);
                hrRet = NS_E_INVALID_DATA;
                __leave;
            }
            else if (FAILED(hr))
            {
                // default the value
                msIndexGranularity = g_kmsDVRDefaultIndexGranularity;
            }
            m_cnsIndexGranularity = (QWORD) msIndexGranularity  * k_dwMilliSecondsToCNS;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->AddFile(m_pFileCollectionInfoAsWriter,
                                           (LPWSTR*) &pReaderNode->pwszFileName,
                                           0,                   // bOpenFromFileCollectionDirectory
                                           0,                   // start time pRecorderNode->cnsStartTime,
                                           cnsCurrentStreamTime + 1,
                                           TRUE,                // bPermanentFile,
                                           0,                   // bDeleteTemporaryFiles, ignored if bPermanentFile is set
                                           0,                   // cnsFirstSampleTimeOffsetFromStartOfFile,
                                           &pReaderNode->nFileId);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        bRemoveRingBufferFile = 1;

        // Bump up the reader ref count

        CDVRFileCollection::DVRIOP_FILE_ID nTmpFileId;

        hr = m_pDVRFileCollection->GetFileAtTime(&m_FileCollectionInfo,
                                                 0,    // Replace with start time of file if we support ASX files
                                                 NULL, // file name optional
                                                 NULL, // cnsFirstSampleTimeOffsetFromStartOfFile
                                                 &nTmpFileId,
                                                 TRUE  // bFileWillBeOpened
                                                );
        if (FAILED(hr) || nTmpFileId != pReaderNode->nFileId)
        {
            // This can't happen
            DVR_ASSERT(SUCCEEDED(hr), "GetFileAtTime failed");
            DVR_ASSERT(nTmpFileId == pReaderNode->nFileId, "Two files with same start time in file collection?");
            if (SUCCEEDED(hr))
            {

                DVR_EXECUTE_ASSERT(SUCCEEDED(m_pDVRFileCollection->CloseReaderFile(&m_FileCollectionInfo, nTmpFileId)), "");
                hrRet = E_FAIL;
            }
            __leave;
        }

        bDecRefCount = 1;

        // Insert into m_leReadersList

        hr = AddToReadersList(pReader);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        bAdded = 1;

        pReaderNode = NULL; // We don't have any reason to use it
        hrRet = S_OK;
    }
    __finally
    {
        // If we succeeeded pwszFileName should be NULL.
        DVR_ASSERT(!pwszFileName || FAILED(hrRet), "");

        delete [] pwszFileName;

        if (FAILED(hrRet))
        {
            CDVRFileCollection::DVRIOP_FILE_ID nTmpFileId;

            if (bRemoveRingBufferFile)
            {
                nTmpFileId = pReaderNode->nFileId;
            }
            if (bAdded)
            {
                RemoveEntryList(pReader);
                NULL_LIST_NODE_POINTERS(pReader);
            }
            if (!bDecRefCount &&
                pReaderNode)            //  PREFIX
            {
                // This prevents CloseReaderFile from decreasing the ref count.
                // Note that it's ok to decrease the reader refcount after
                // calling SetFileTime (which makes the file collection remove
                // the node for this file when the reader ref count drops to 0).
                pReaderNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
            }
            if (bRemoveRingBufferFile)
            {
                // Set the end time to the start time to invalidate the file
                // in the file collection
                CDVRFileCollection::DVRIOP_FILE_TIME ft = {nTmpFileId, cnsCurrentStreamTime+1, cnsCurrentStreamTime+1};
                HRESULT hr;

                hr = m_pDVRFileCollection->SetFileTimes(m_pFileCollectionInfoAsWriter, 1, &ft);

                // A returned value of S_FALSE is ok. If this fails,
                // just ignore the error
                DVR_ASSERT(SUCCEEDED(hr), "");
            }
            if (bCloseFile)
            {
                HRESULT hr;

                hr = CloseReaderFile(pReader);

                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
                else
                {
                    // Note: Close may not have complete yet - that's ok
                }
            }

        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::AddAPermanentFile

HRESULT CDVRReader::GetFileAtTime(IN  QWORD         cnsStreamTime,
                                  IN  BOOL          bWaitTillFileIsOpened,
                                  OUT LIST_ENTRY**  pleReaderParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetFileAtTime"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pleReaderParam && !DvrIopIsBadWritePtr(pleReaderParam, 0), "");

    HRESULT hrRet = E_FAIL;
    CDVRFileCollection::DVRIOP_FILE_ID nFileId;
    PASF_READER_NODE    pReaderNode = NULL;
    LPWSTR              pwszFileName = NULL;
    LIST_ENTRY*         pReader = NULL;
    BOOL                bDecRefCount = 0;
    BOOL                bCloseFile = 0;
    BOOL                bAdded = 0;

    // Note that we will need a start and an end time if we support ASX files
    QWORD               cnsEndTime;   // time extent of the file; start tiem is always 0

    __try
    {
        HRESULT hr;

        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->GetFileAtTime(&m_FileCollectionInfo,
                                                            // Reader index, unused if bFileWillBeOpened == 0
                                                 cnsStreamTime,
                                                 NULL,      // file name optional
                                                 NULL,      // cnsFirstSampleTimeOffsetFromStartOfFile
                                                 &nFileId,
                                                 FALSE      // bFileWillBeOpened
                                                );
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Check if we already have this file open

        LIST_ENTRY*         pTmp = &m_leReadersList;
        PASF_READER_NODE    pTmpNode = NULL;
        BOOL                bFoundInList = 0;

        while (NEXT_LIST_NODE(pTmp) != &m_leReadersList)
        {
            pTmp = NEXT_LIST_NODE(pTmp);
            pTmpNode = CONTAINING_RECORD(pTmp, ASF_READER_NODE, leListEntry);
            if (nFileId < pTmpNode->nFileId)
            {
                // Not found
                break;
            }
            if (nFileId == pTmpNode->nFileId)
            {
                // We have issued an open request for this file
                bFoundInList = 1;
                if (bWaitTillFileIsOpened)
                {
                    break;
                }
                hrRet = S_OK;
                *pleReaderParam = pTmp;
                __leave;
            }
        }

        if (bFoundInList)
        {
            DVR_ASSERT(bWaitTillFileIsOpened, "");
            DVR_ASSERT(pTmpNode && pTmp, "");
            pReaderNode = pTmpNode;
            pReader = pTmp;
        }
        else
        {
            hr = m_pDVRFileCollection->GetFileAtTime(&m_FileCollectionInfo,
                                                     cnsStreamTime,
                                                     &pwszFileName,
                                                     NULL,          // cnsFirstSampleTimeOffsetFromStartOfFile
                                                     &nFileId,
                                                     TRUE           // bFileWillBeOpened
                                                    );
            if (FAILED(hr))
            {
                // Presumably, file only just got bumped out of the ring buffer
                hrRet = hr;
                __leave;
            }

            bDecRefCount = 1;

            DVR_ASSERT(pwszFileName, "GetFileAtTime succeeded but file name is NULL");
            DVR_ASSERT(nFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID,
                       "GetFileAtTime succeeded but file id returned is DVRIOP_INVALID_FILE_ID");


            // Note that the client of the DVRReader can cancel this operation.
            // So a timeout of INFINITE is ok.
            hr = PrepareAFreeReaderNode(pwszFileName,
                                        2000,                  // timeout
                                        nFileId,
                                        pReader);

            // PrepareAFreeReaderNode will delete pwszFileName regardless of
            // whether it succeeds or fails.
            pwszFileName = NULL;

            if (FAILED(hr))
            {
                DVR_ASSERT(pReader == NULL,
                           "PrepareAFreeReaderNode returns failure but pReader is not NULL");
                hrRet = hr;
                __leave;
            }

            // Closing the file will decrease the ref count in CloseReaderFile, so we don't
            // have to decrease the reader ref count ourselves.
            bDecRefCount = 0;
            bCloseFile = 1;

            DVR_ASSERT(pReader, "PrepareAFreeReaderNode returns success but pReader is NULL");

            pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;
        }

        if (bWaitTillFileIsOpened)
        {
            DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");

            // Wait for the ASF file open to complete

            DWORD nRet = ::WaitForSingleObject(pReaderNode->hReadyToReadFrom, INFINITE);
            if (nRet == WAIT_FAILED)
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "WFSO(hReadyToReadFrom) failed while waiting for file open to complete; "
                                "hReadyToReadFrom = 0x%p, last error = 0x%x",
                                pReaderNode->hReadyToReadFrom, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
            if (pReaderNode->hrRet == HRESULT_FROM_WIN32(ERROR_CANCELLED))
            {
                // SDK pre-reads when it opens a file. Ignore the result if
                // it could not read because it was reading ahead of the writer..
                pReaderNode->hrRet = S_OK;
            }
            if (FAILED(pReaderNode->hrRet))
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Open of file failed in ProcessOpenRequest." // pReaderNode-nFileId will be the invalid id
                               );
                hrRet = pReaderNode->hrRet;
                __leave;
            }
        }

        if (!bFoundInList)
        {
            // Insert into m_leReadersList

            hr = AddToReadersList(pReader);

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            bAdded = 1;
        }

        pReaderNode = NULL; // We don't have any reason to use it
        *pleReaderParam = pReader;
        hrRet = S_OK;
    }
    __finally
    {
        // If we succeeeded pwszFileName should be NULL.
        DVR_ASSERT(!pwszFileName || FAILED(hrRet), "");

        delete [] pwszFileName;

        if (FAILED(hrRet))
        {
            HRESULT hr;

            *pleReaderParam = NULL;


            if (bAdded)
            {
                RemoveEntryList(pReader);
                NULL_LIST_NODE_POINTERS(pReader);
            }
            if (bDecRefCount)
            {
                DVR_ASSERT(!bCloseFile, "bCloseFile should be 0 if bDecRefCount is 1");
                DVR_ASSERT(pReader == NULL, "");
                DVR_ASSERT(pReaderNode == NULL, "");

                hr = m_pDVRFileCollection->CloseReaderFile(&m_FileCollectionInfo, nFileId);
                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
            }
            if (bCloseFile)
            {
                DVR_ASSERT(pReader, "");

                // The following will wait till the file is opened
                // before closing it.
                //
                // Note that this is a file we just opened, so it can't
                // be equal to m_pProfileNode
                hr = CloseReaderFile(pReader);

                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
                else
                {
                    // Note: Close may not have complete yet - that's ok
                }
            }

        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::GetFileAtTime

// static
DWORD WINAPI CDVRReader::ProcessCloseRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ProcessCloseRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif


    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be deleted till Close() is called and Close() waits for
    // hFileClosed to be set.

    PASF_READER_NODE pReaderNode = (PASF_READER_NODE) p;

    DVR_ASSERT(pReaderNode, "");
    DVR_ASSERT(pReaderNode->pWMReader, "");
    DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");
    DVR_ASSERT(::WaitForSingleObject(pReaderNode->hFileClosed, 0) == WAIT_TIMEOUT, "");

    if (FAILED(pReaderNode->hrRet))
    {
        // Open failed, don't close the file
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                        "Open failed on file id %u, hr = 0x%x; not closing it, "
                        "but moving it to free list",
                        pReaderNode->nFileId, pReaderNode->hrRet);
        hrRet = pReaderNode->hrRet;
    }
    else
    {
        if (pReaderNode->pIWMHeaderInfo) {
            pReaderNode->pIWMHeaderInfo->Release () ;
            pReaderNode->pIWMHeaderInfo = NULL ;
        }

        hrRet = pReaderNode->hrRet = pReaderNode->pWMReader->Close();
        if (FAILED(hrRet))
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Close failed; hr = 0x%x for file id %u",
                            hrRet, pReaderNode->nFileId);
        }

        // The DVR file source's Close does not fail to close the file.
        // Should not get failure return.
        hrRet = pReaderNode->pDVRFileSource->Close();
        DVR_ASSERT(SUCCEEDED(hrRet), "pReaderNode->pDVRFileSource->Close failed");

        DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                        "Close hr = 0x%x for file %u",
                        hrRet, pReaderNode->nFileId);
    }

    pReaderNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
    pReaderNode->SetFileName(NULL);

    ::SetEvent(pReaderNode->hFileClosed);

    // It's unsafe to reference pReaderNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRReader::ProcessCloseRequest

HRESULT CDVRReader::CloseReaderFile(LIST_ENTRY* pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CloseReaderFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_READER_NODE    pReaderNode;
    BOOL                bLeak = 0;   // Leak the writer node memory if we fail
    BOOL                bDelete = 0; // Delete the writer node if we fail
    BOOL                bWaitForClose = 0; // Wait for hFileClsoed before deleting
    BOOL                bDecd = 0;  // Called the file collection's CloseReaderFile to decrease its reader ref count

    pReaderNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);

    __try
    {
        DWORD nRet;
        HRESULT hr;

        // If this node is the profile node, this function should not be called.
        // File remains open till the caller releases the profile
        if (m_pProfileNode == pReaderNode)
        {
            DVR_ASSERT(m_pProfileNode != pReaderNode, "");
            hrRet = E_INVALIDARG;
            __leave;
        }

        // If this node is the current reader node, this function should not be called.
        // The calling function should call ResetReader() before calling this function.
        if (m_pCurrentNode == pReaderNode)
        {
            DVR_ASSERT(m_pCurrentNode != pReaderNode, "");
            hrRet = E_INVALIDARG;
            __leave;
        }

        if (m_pLiveFileReaderNode == pReaderNode)
        {
            m_pLiveFileReaderNode = NULL;
        }

        // We have to close the file; ensure the open has completed
        DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");
        if (::WaitForSingleObject(pReaderNode->hReadyToReadFrom, INFINITE) == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Reader node's WFSO(hReadyToReadFrom) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "WFSO(hReadyToReadFrom) failed; hReadyToReadFrom = 0x%p, last error = 0x%x",
                            pReaderNode->hReadyToReadFrom, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);

            // We don't know if the queued user work item has executed or not
            // Better to leak this memory than to potentially av.
            bLeak = 1;
           __leave;
        }
        bDelete = 1;

        // Verify that hFileClosed is reset
        DVR_ASSERT(pReaderNode->hFileClosed, "");
        nRet = ::WaitForSingleObject(pReaderNode->hFileClosed, 0);
        if (nRet != WAIT_TIMEOUT)
        {
            DVR_ASSERT(nRet != WAIT_OBJECT_0, "Reader node's hFileClosed is set?");
            if (nRet == WAIT_OBJECT_0)
            {
                // hope for the best! Consider treating this an error @@@@
                ::ResetEvent(pReaderNode->hFileClosed);
            }
            else
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "WFSO(hFileClosed) failed; hFileClosed = 0x%p, last error = 0x%x",
                                pReaderNode->hFileClosed, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        bDecd = 1;
        if (pReaderNode->nFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
        {
            hr = m_pDVRFileCollection->CloseReaderFile(&m_FileCollectionInfo, pReaderNode->nFileId);
            if (FAILED(hr))
            {
                DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->CloseReaderFile failed");
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "m_pDVRFileCollection->CloseReaderFile failed for file id %u; hr = 0x%x",
                                pReaderNode->nFileId, hr);

            }
            // Go on - close the file and add this node to the free list
            // The node's state is still "good"
        }

        // Issue the call to EndWriting
        if (::QueueUserWorkItem(ProcessCloseRequest, pReaderNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "QueueUserWorkItem failed; last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        bWaitForClose = 1; // We wait only if subsequent operations fail

        // We could do this after the WFSO(hReadyToReadFrom) succeeds
        // We delay it because we may change this function to not
        // not delete the node on failure and retry this function.
        // So it's better to leave the event set until we are
        // sure of success.
        ::ResetEvent(pReaderNode->hReadyToReadFrom);

        // Insert into m_leFreeList
        LIST_ENTRY*         pTmp = &m_leFreeList;
        PASF_READER_NODE    pFreeNode;

        while (PREVIOUS_LIST_NODE(pTmp) != &m_leFreeList)
        {
            pTmp = PREVIOUS_LIST_NODE(pTmp);
            pFreeNode = CONTAINING_RECORD(pTmp, ASF_READER_NODE, leListEntry);
            if (pFreeNode->pWMReader != NULL)
            {
                InsertHeadList(pTmp, pCurrent);
                bDelete = 0;
                break;
            }
        }
        if (pTmp == &m_leFreeList)
        {
            // Not inserted into free list yet - all nodes in the
            // free list have pWMWriter == NULL
            InsertHeadList(&m_leFreeList, pCurrent);
            bDelete = 0;
        }
        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // We either leak or delete the node on failure, but not both

            DVR_ASSERT(bLeak == 0 || bLeak == 1, "");
            DVR_ASSERT(bDelete == 0 || bDelete == 1, "");
            DVR_ASSERT(bLeak ^ bDelete, "");

            if (bWaitForClose)
            {
                // Currently won't happen since we have no failures
                // after queueing the work item. However, this is to
                // protect us from code changes

                DWORD nRet;

                nRet = ::WaitForSingleObject(pReaderNode->hFileClosed, INFINITE);
                if (nRet == WAIT_FAILED)
                {
                    DVR_ASSERT(nRet == WAIT_OBJECT_0, "Reader node WFSO(hFileClosed) failed");

                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "WFSO(hFileClosed) failed, deleting node anyway; hFileClosed = 0x%p, last error = 0x%x",
                                    pReaderNode->hFileClosed, dwLastError);

                    // Ignore this error
                    // hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
            }
            else
            {
                // Close the file any way

                HRESULT hr;

                if (!bDecd)
                {
                    hr = m_pDVRFileCollection->CloseReaderFile(&m_FileCollectionInfo, pReaderNode->nFileId);
                    if (FAILED(hr))
                    {
                        DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->CloseReaderFile failed");
                        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "m_pDVRFileCollection->CloseReaderFile failed for file id %u; hr = 0x%x",
                                        pReaderNode->nFileId, hr);

                    }
                    // Go on - close the file
                }
                ProcessCloseRequest(pReaderNode);
            }
            if (bDelete)
            {
                delete pReaderNode;
            }
        }
        else
        {
            DVR_ASSERT(bLeak == 0 && bDelete == 0, "");
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::CloseReaderFile


HRESULT CDVRReader::CloseAllReaderFilesBefore(QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CloseAllReaderFilesBefore"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_READER_NODE    pReaderNode;
    LIST_ENTRY*         pCurrent = &m_leReadersList;

    __try
    {
        HRESULT hr;

        while (NEXT_LIST_NODE(pCurrent) != &m_leReadersList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pReaderNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);

            QWORD cnsEndTime;

            DVR_ASSERT(m_pDVRFileCollection, "");

            hr = m_pDVRFileCollection->GetTimeExtentForFile(&m_FileCollectionInfo,
                                                            pReaderNode->nFileId,
                                                            NULL,                // pcnsStartStreamTime OPTIONAL,
                                                            &cnsEndTime);

            if (FAILED(hr))
            {
                // error already logged, just go on
                DVR_ASSERT(0, "GetTimeExtentForFile failed.");
                continue;
            }
            else if (hr != S_FALSE && cnsEndTime > cnsStreamTime)
            {
                // Note thatif hr == S_FALSE, the file is no longer
                // in the ring buffer extent. We should close it
                // regardless of time. Note that files beyond the
                // last write time can drop out of the ring buffer
                // because the writer called SetFileTimes and
                // set their start time equal to their stop time

                // go on
                continue;
            }
            else if (m_pProfileNode == pReaderNode)
            {
                // We have to leave this file open till the profile
                // is released.
                continue;
            }
            else if (m_pCurrentNode == pReaderNode)
            {
                // Reset, then close
                ResetReader();
            }


            LIST_ENTRY* pPrevious = PREVIOUS_LIST_NODE(pCurrent);

            RemoveEntryList(pCurrent);
            NULL_LIST_NODE_POINTERS(pCurrent);

            hr = CloseReaderFile(pCurrent);
            if (FAILED(hr))
            {
                // We ignore this and go on, the node has been deleted
            }

            pCurrent = pPrevious;
        }
        hrRet = S_OK; // even if there was a failure
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::CloseAllReaderFilesBefore

HRESULT CDVRReader::Close(void)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Close"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        // Just in case we are called from a function other than
        // the destructor
        if(m_dwOutstandingProfileCount != 0)
        {
            DVR_ASSERT(m_dwOutstandingProfileCount == 0, "");
            hrRet = E_UNEXPECTED;
            __leave;
        }
        DVR_ASSERT(m_pProfileNode == NULL, "m_dwOutstandingProfileCount is zero");
        DVR_ASSERT(m_pWMProfile == NULL, "m_dwOutstandingProfileCount is zero");

        hr = CloseAllReaderFilesBefore(MAXQWORD);
        hrRet = hr;

        // This list should be empty by now.
        DVR_ASSERT(IsListEmpty(&m_leReadersList), "");

        // The current reader should be NULL
        DVR_ASSERT(m_pCurrentNode == NULL, "");

        // Delete all the reader nodes.
        LIST_ENTRY* pCurrent;

        pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        while (pCurrent != &m_leFreeList)
        {
            PASF_READER_NODE pFreeNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);

            DVR_ASSERT(pFreeNode->hFileClosed, "");

            // Ignore the returned status
            ::WaitForSingleObject(pFreeNode->hFileClosed, INFINITE);
            RemoveEntryList(pCurrent);
            delete pFreeNode;
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        }

        if (m_pDVRFileCollection)
        {
            if (m_bAmWriter)
            {
                DVR_ASSERT(m_pFileCollectionInfoAsWriter, "");

                // Ignore returned status
                m_pDVRFileCollection->SetWriterHasBeenClosed(m_pFileCollectionInfoAsWriter);
            }

            // Ignore the returned status of the following call. The
            // RegisterReader() call could have failed (or never been
            // executed), in which case, m_FileCollectionInfo.dwReaderIndex is not valid
            // and the following call will fail.
            m_pDVRFileCollection->UnregisterReader(&m_FileCollectionInfo);

            m_pDVRFileCollection->Release(m_bAmWriter? m_pFileCollectionInfoAsWriter : &m_FileCollectionInfo);
            m_pDVRFileCollection = NULL;
        }

        hrRet = S_OK;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::Close

void CDVRReader::ResetReader(IN PASF_READER_NODE pReaderNode /* = NULL */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ResetReader"

    DVRIO_TRACE_ENTER();

    m_pCurrentNode = pReaderNode;
    if (m_dwConsecutiveReads != INFINITE)
    {
        m_dwConsecutiveReads = 0;
    }

    DVRIO_TRACE_LEAVE0();
    return;

} // CDVRReader::ResetReader

HRESULT CDVRReader::UpdateTimeExtent()
{

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::UpdateTimeExtent"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;


    // For ASX files, we may have to add permanent files to the file collection
    // object first

    __try
    {
        QWORD cnsTime;
        HRESULT hr;

        if (!m_bDVRProgramFileIsLive)
        {
            hrRet = S_FALSE;
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        DVR_ASSERT(m_bAmWriter, "");
        DVR_ASSERT(m_pFileCollectionInfoAsWriter, "");
        DVR_ASSERT(m_pLiveFileReaderNode, "");

        hr = m_pLiveFileReaderNode->pDVRFileSource->GetLastTimeStamp(&cnsTime);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "m_pLiveFileReaderNode->pDVRFileSource->GetLastTimeStamp failed; hr = 0x%x; ignoring error",
                            hrRet);
            __leave;
        }

        // Get the file collection lock to update this member since
        // the client can try to read it without getting CDVRReader::m_csLock
        // in GetStreamTimeExtent
        BOOL  bReleaseSharedMemoryLock;

        // Note: For many of these functions, it's ok to use
        // m_FileCollectionInfo instead of m_pFileCollectionInfoAsWriter.
        // m_pFileCollectionInfoAsWriter must be used for the writer functions
        hr = m_pDVRFileCollection->Lock(m_pFileCollectionInfoAsWriter, bReleaseSharedMemoryLock, 1);
        if (FAILED(hr))
        {
            hrRet = hr;
            // If we failed to lock, the inconsistency data counter was not incremented.
            m_pDVRFileCollection->Unlock(m_pFileCollectionInfoAsWriter, bReleaseSharedMemoryLock, 0);
            __leave;
        }

        QWORD cnsCurrentStreamTime;

        hr = m_pDVRFileCollection->GetLastStreamTime(m_pFileCollectionInfoAsWriter,
                                                     &cnsCurrentStreamTime, 0 /* don't lock - we have the lock */);

        if (FAILED(hr))
        {
            hrRet = hr;
            m_pDVRFileCollection->Unlock(m_pFileCollectionInfoAsWriter, bReleaseSharedMemoryLock, 1);
            __leave;
        }

        if (cnsCurrentStreamTime != cnsTime)
        {
            hr = m_pDVRFileCollection->SetLastStreamTime(m_pFileCollectionInfoAsWriter, cnsTime, 0 /* don't lock - we have the lock */);

            if (FAILED(hr))
            {
                hrRet = hr;
                m_pDVRFileCollection->Unlock(m_pFileCollectionInfoAsWriter, bReleaseSharedMemoryLock, 1);
                __leave;
            }

            // We have to update the time extent of the file on the file collection object
            // so that GetFileAtTime does not fail.
            CDVRFileCollection::DVRIOP_FILE_TIME ft = {m_pLiveFileReaderNode->nFileId, 0, cnsTime+1};

            hr = m_pDVRFileCollection->SetFileTimes(m_pFileCollectionInfoAsWriter, 1, &ft);

            // Note that since SetFileTimes restores the original state, we can
            // decrement m_nDataInconsistent always (regardless of success/failure of hr)
            HRESULT hrTmp = m_pDVRFileCollection->Unlock(m_pFileCollectionInfoAsWriter, bReleaseSharedMemoryLock, 1);

            DVR_ASSERT(hr == S_OK, "");
            if (hr == S_FALSE)
            {
                // This is unexpected
                hrRet = E_FAIL;
                __leave;
            }
            else if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            if (FAILED(hrTmp))
            {
                hrRet = hrTmp;
                __leave;
            }

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                            "File is live, last time stamp is %I64u",
                            cnsTime);
            hrRet = S_OK;
            __leave;
        }
        else
        {
            HRESULT hrTmp = m_pDVRFileCollection->Unlock(m_pFileCollectionInfoAsWriter, bReleaseSharedMemoryLock, 1);
            if (FAILED(hrTmp))
            {
                hrRet = hrTmp;
                __leave;
            }
        }

        // Verify if file is still live

        BOOL bShared;

        hr = m_pLiveFileReaderNode->pDVRFileSource->IsFileLive(&m_bDVRProgramFileIsLive, &bShared);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pReaderNode->pDVRFileSource->IsFileLive failed; hr = 0x%x",
                            hrRet);
            __leave;
        }
        DVR_ASSERT(bShared, "");

        if (!m_bDVRProgramFileIsLive)
        {
            hr = m_pDVRFileCollection->SetWriterHasBeenClosed(m_pFileCollectionInfoAsWriter);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
        }

        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                        "Timestamp unchanged; File is liveis now %d",
                        m_bDVRProgramFileIsLive);
        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::UpdateTimeExtent


// ====== Public methods to support the recorder


// ====== IUnknown

STDMETHODIMP CDVRReader::QueryInterface(IN  REFIID riid,
                                        OUT void   **ppv)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::QueryInterface"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!ppv || DvrIopIsBadWritePtr(ppv, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        hrRet = E_POINTER;
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown*) (IDVRReader*) this;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRReader)
    {
        *ppv = (IDVRReader*) this;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRSourceAdviseSink)
    {
        *ppv = (IDVRSourceAdviseSink*) this;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRIORecordingAttributes)
    {
        *ppv = (IDVRIORecordingAttributes*) this;
        hrRet = S_OK;
    }
    else
    {
        *ppv = NULL;
        hrRet = E_NOINTERFACE;
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "no such interface");
    }

    if (SUCCEEDED(hrRet))
    {
        ((IUnknown *) (*ppv))->AddRef();
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // CDVRReader::QueryInterface


STDMETHODIMP_(ULONG) CDVRReader::AddRef()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::AddRef"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0,
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRReader::AddRef


STDMETHODIMP_(ULONG) CDVRReader::Release()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Release"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0,
              "m_nRefCount < 0 after InterlockedDecrement");

    if (nNewRef == 0)
    {
        // Must call DebugOut before the delete because the
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRReader::Release


// ====== IDVRReader

STDMETHODIMP CDVRReader::GetProfile(OUT IWMProfile** ppWMProfile)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetProfile"

    DVRIO_TRACE_ENTER();

    if (!ppWMProfile || DvrIopIsBadWritePtr(ppWMProfile, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;
    LIST_ENTRY*         pReader = NULL;
    BOOL                bCloseFile = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        if (m_dwOutstandingProfileCount)
        {
            DVR_ASSERT(m_pProfileNode != NULL, "m_dwOutstandingProfileCount is non-zero");
            DVR_ASSERT(m_pWMProfile != NULL, "m_dwOutstandingProfileCount is non-zero");
            hrRet = S_OK;
            __leave;
        }

        DVR_ASSERT(m_pProfileNode == NULL, "m_dwOutstandingProfileCount is zero");
        DVR_ASSERT(m_pWMProfile == NULL, "m_dwOutstandingProfileCount is zero");

        // Use the "latest" file. Note that this file should have been created
        // by the writer even if the ring buffer writer not started writing.
        QWORD qwLastStreamTime;

        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &qwLastStreamTime);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        hr = GetFileAtTime(qwLastStreamTime, 1 /* bWait */, &pReader);

        if (FAILED(hr))
        {
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                DVR_ASSERT(pReader == NULL, "GetFileAtTime fails but pReader != NULL");

                // For multi file recordings, it helps to try one other file (in case
                // the last ASF file in the recording was deleted). Note that we could
                // extend the file colleciton API to return the tiem fo a file that
                // did exist. As things stand, we don't have a file id and so can't
                // get the extent of a file to get the previous valid time

                QWORD cnsStartStreamTime;

                hr = m_pDVRFileCollection->GetTimeExtent(&m_FileCollectionInfo,
                                                         &cnsStartStreamTime,
                                                         NULL);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }

                hr = GetFileAtTime(cnsStartStreamTime, 1 /* bWait */, &pReader);
            }
            if (FAILED(hr))
            {
                DVR_ASSERT(pReader == NULL, "GetFileAtTime fails but pReader != NULL");
                hrRet = hr;
                __leave;
            }
        }
        DVR_ASSERT(pReader != NULL, "GetFileAtTime succeeds but pReader == NULL");

        PASF_READER_NODE    pReaderNode;

        pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;

        bCloseFile = 1;

        DVR_ASSERT(pReaderNode->pWMReader, "");

        hr = pReaderNode->pWMReader->QueryInterface(IID_IWMProfile, (void**) &m_pWMProfile);

        if (FAILED(hr))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "QI for IID_IWMProfilefailed, hr = 0x%x",
                            hr);
            hrRet = hr;
            __leave;
        }

        m_pProfileNode = pReaderNode;
        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;

        if (SUCCEEDED(hrRet))
        {
            m_dwOutstandingProfileCount++;
            *ppWMProfile = m_pWMProfile; // First QI addref's this, we don't addref it again
            AddRef();
        }
        else if (bCloseFile)
        {
            DVR_ASSERT(pReader, "");
            DVR_ASSERT(m_dwOutstandingProfileCount == 0, "Why did we try to open a file?");
            DVR_ASSERT(m_pWMProfile == NULL, "Why did we try to open a file?");

            // CloseReaderFile will assert this
            DVR_ASSERT(m_pProfileNode == NULL, "Why did we try to open a file?");
            hr = CloseReaderFile(pReader);
            if (FAILED(hr))
            {
                // We ignore this and go on, the node has been deleted
            }
        }
        else
        {
            DVR_ASSERT(pReader == NULL, "bCloseFile == 0");
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::GetProfile

STDMETHODIMP CDVRReader::ReleaseProfile(IN IWMProfile* pWMProfile)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ReleaseProfile"

    DVRIO_TRACE_ENTER();

    if (!pWMProfile || DvrIopIsBadWritePtr(pWMProfile, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;
    LIST_ENTRY*         pReader = NULL;
    BOOL                bCloseFile = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        if (m_dwOutstandingProfileCount && pWMProfile == m_pWMProfile)
        {
            DVR_ASSERT(m_pProfileNode != NULL, "m_dwOutstandingProfileCount is non-zero");
            DVR_ASSERT(m_pWMProfile != NULL, "m_dwOutstandingProfileCount is non-zero");
            hrRet = S_OK;
            __leave;
        }
        if (m_dwOutstandingProfileCount)
        {
            // pWMProfile != m_pWMProfile

            DVR_ASSERT(m_pProfileNode != NULL, "m_dwOutstandingProfileCount is non-zero");
            DVR_ASSERT(m_pWMProfile != NULL, "m_dwOutstandingProfileCount is non-zero");

            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
            DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
            hrRet = E_INVALIDARG;
            __leave;
        }

        DVR_ASSERT(m_pProfileNode == NULL, "m_dwOutstandingProfileCount is zero");
        DVR_ASSERT(m_pWMProfile == NULL, "m_dwOutstandingProfileCount is zero");
        hrRet = E_UNEXPECTED;
    }
    __finally
    {
        HRESULT hr;

        if (SUCCEEDED(hrRet))
        {
            m_dwOutstandingProfileCount--;

            if (m_dwOutstandingProfileCount == 0)
            {
                m_pWMProfile->Release();
                m_pWMProfile = NULL;
                m_pProfileNode = NULL;

                // Note that we cannot call CloseReaderFile here since
                // the file could also be opened for reading and we do
                // not maintain a refcount/flag in PASF_READER_NODE that
                // distinguishes files opened for profile info from files
                // opened for reads
            }

            ::LeaveCriticalSection(&m_csLock);
            DVRIO_TRACE_LEAVE1_HR(hrRet);

            // This could delete the object; that's why we
            // call LeaveCriticalSection first.
            Release();

            // NOTE: Object may have been DESTROYED
        }
        else
        {
            ::LeaveCriticalSection(&m_csLock);
            DVRIO_TRACE_LEAVE1_HR(hrRet);
        }
    }

    return hrRet;

} // CDVRReader::ReleaseProfile

STDMETHODIMP CDVRReader::Seek(IN QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Seek"

    DVRIO_TRACE_ENTER();

    HRESULT             hrRet;
    LIST_ENTRY*         pReader = NULL;
    PASF_READER_NODE    pCurrentReaderNode = NULL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        hr = UpdateTimeExtent();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Note that we do not bother to validate cnsStreamTime with the start time of
        // the file collection (which is returned by m_pDVRFileCollection->GetTimeExtent).
        // If cnsStreamTime is outside the file collection's extent, GetFileAtTime would
        // fail.
        //
        // We check cnsStreamTime with the last stream time because GetFileAtTime would
        // succeed if there was a file created by the writer in advance for a future time.

        QWORD qwLastStreamTime;

        //  PREFIX
        if (!m_pDVRFileCollection) {
            hrRet = E_UNEXPECTED ;
            __leave ;
        }

        BOOL bReleaseSharedMemoryLock;

        hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
        if (FAILED(hr))
        {
            hrRet = hr;
            m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
            __leave;
        }

        hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &qwLastStreamTime);
        if (FAILED(hr))
        {
            m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);

            hrRet = hr;
            __leave;
        }

        if (cnsStreamTime > qwLastStreamTime)
        {
            m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);

            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Seek failed because seek time = %I64u > stream extent = %I64u",
                            cnsStreamTime, qwLastStreamTime);
            hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
            __leave;
        }

        hr = GetFileAtTime(cnsStreamTime, 1 /* bWait */, &pReader);

        if (FAILED(hr))
        {
            m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);

            DVR_ASSERT(pReader == NULL, "GetFileAtTime fails but pReader != NULL");
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
            }
            else
            {
                hrRet = hr;
            }
            __leave;
        }
        DVR_ASSERT(pReader != NULL, "GetFileAtTime succeeds but pReader == NULL");

        // If this file is live (or the reader is reading from a live ring buffer)
        // the writer has either (a) written beyond cnsStreamTime (we tested this
        // above) or (b) not written any samples at all - in this case cnsStreamTime
        // is equal to the ring buffer's start time. In either case, the writer
        // will (should) not change the file's starting time. So the following
        // call will return a result consistent with the previous call to GetFileAtTime,
        // i.e., we don't have to worry about the writer's calling SetFileTimes or
        // changing the starting time of the file between the two calls.

        PASF_READER_NODE    pReaderNode;
        QWORD               cnsStartTime;
        QWORD               cnsEndTime;

        pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;

        hr = m_pDVRFileCollection->GetTimeExtentForFile(&m_FileCollectionInfo,
                                                        pReaderNode->nFileId,
                                                        &cnsStartTime,
                                                        &cnsEndTime);

        DVR_ASSERT(SUCCEEDED(hr),
                   "GetTimeExtentForFile failed when file is open for reading");

        if (hr == S_FALSE)
        {
            m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);

            // File has got bumped out of the ring buffer?
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "File id %u has been bumped out of the ring buffer after it was opened",
                            pReaderNode->nFileId);
            hr = CloseAllReaderFilesBefore(cnsEndTime); // always returs success
            hrRet = HRESULT_FROM_WIN32(ERROR_SEEK); // Seek time is not in the ring buffer extent
            __leave;
        }

        // Finally, we ask the ASF reader to seek
        DVR_ASSERT(pReaderNode->pWMReader, "");
        DVR_ASSERT(cnsStreamTime >= cnsStartTime,
                   "cnsStreamTime is not in the time extent of file returned by GetFileAtTime");

        if (cnsEndTime < qwLastStreamTime)
        {
            qwLastStreamTime = cnsEndTime;
        }

        // Round seek time off to the nearest second. Otherwise, the SDK
        // seeks to the next second and reads packets backwards till it
        // finds a keyframe just smaller than the value we want to seek to

        QWORD cnsSeekTime = cnsStreamTime - cnsStartTime;
        LONGLONG cnsFirstSampleOffset;

        hr = m_pDVRFileCollection->GetFirstSampleTimeOffsetForFile(&m_FileCollectionInfo,
                                                                   pReaderNode->nFileId,
                                                                   &cnsFirstSampleOffset);
        if (FAILED(hr))
        {
            m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);

            hrRet = hr;
            __leave;
        }

        //  we're now done with the file collection
        hr = m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        qwLastStreamTime -= cnsStartTime; // qwLastStreamTime is now the file's extent

        if (cnsFirstSampleOffset == CDVRRingBufferWriter::kInvalidFirstSampleOffsetTime)
        {
            // It has not yet been initialized. This means that no
            // samples have been written to the file yet.
            cnsFirstSampleOffset = 0;

            if (cnsSeekTime != 0) {
                //  we've landed on a file that is in a timehole
                //  TODO: ASSERT that this is what's happening

                //  relative to the file this seek request falls into, set the
                //    the offset to 0; subsequent read will fail; higher layer
                //    will then seekahead, by discovering the next valid sample
                //    time
                cnsSeekTime = 0 ;
            }
        }

        BOOL bAdded = 0;

        if (cnsFirstSampleOffset > 0 && cnsSeekTime < (QWORD) cnsFirstSampleOffset)
        {
            cnsSeekTime = 0;

            // The file extent must be greater than
            // the first sample's offset. (Note that qwLastStreamTime is really bounded by the stream
            // extent if this is the file the writer is writing to; even so the assert should hold.)
            DVR_ASSERT(qwLastStreamTime >= (QWORD) cnsFirstSampleOffset, "");
        }
        else if (cnsFirstSampleOffset >= 0)
        {
            cnsSeekTime -= cnsFirstSampleOffset;

            // Either we have not written to this file yet (the real cnsFirstSampleOffset was
            // CDVRRingBufferWriter::kInvalidFirstSampleOffsetTime and we set it to 0 above) or
            // the file extent is greater than the first sample's offset. (Note that qwLastStreamTime
            // is really bounded by the stream extent if this is the file the writer is writing to;
            // even so the assert should hold.)
            DVR_ASSERT(qwLastStreamTime >= (QWORD) cnsFirstSampleOffset, "");

            qwLastStreamTime -= cnsFirstSampleOffset;
            bAdded = 1;
        }
        else
        {
            // cnsSeekTime -= cnsFirstSampleOffset
            ::SafeAdd(cnsSeekTime, cnsSeekTime, (0 - cnsFirstSampleOffset));
            //
            // The number of index entries that has been generated is
            // (qwLastStreamTime_of_writer - cnsFirstSampleOffset_of_writer)/m_cnsIndexGranularity
            // Since qwLastStreamTime_of_writer = qwLastStreamTime_of_reader + Start time of reader relative to file
            // and   cnsFirstSampleOffset_of_writer = cnsFirstSampleOffset_of_reader + Start time of reader relative to file
            // the number of index entries can also be computed as
            // (qwLastStreamTime_of_reader - cnsFirstSampleOffset_of_reader)/m_cnsIndexGranularity
            //
            ::SafeAdd(qwLastStreamTime, qwLastStreamTime, (0 - cnsFirstSampleOffset));
            bAdded = 1;
        }

        QWORD cnsRoundedSeekTime;

        if (cnsFirstSampleOffset >= 0)
        {
            // Round off in this case.

            // First round down
            cnsRoundedSeekTime = (cnsSeekTime/m_cnsIndexGranularity) * m_cnsIndexGranularity;

            if (cnsSeekTime - cnsRoundedSeekTime > m_cnsIndexGranularity/2)
            {
                // Round up

                ::SafeAdd(cnsRoundedSeekTime, cnsRoundedSeekTime, m_cnsIndexGranularity);
                if (cnsRoundedSeekTime  >
                                (qwLastStreamTime/m_cnsIndexGranularity) * m_cnsIndexGranularity)
                {
                    // We've gone beyond the last index time. Round back down
                    // else SetRange will fail
                    cnsRoundedSeekTime -= m_cnsIndexGranularity;
                }
            }
            DVR_ASSERT(cnsRoundedSeekTime <= (qwLastStreamTime/m_cnsIndexGranularity) * m_cnsIndexGranularity, "");
        }
        else
        {
            // The only time cnsFirstSampleOffset < 0 is when we are viewing a multi file recording
            // and this is the first ASF file in that recording. (If we support pause/resume recording
            // and create a new file node in the DVRFileCollection object each time we resume, this can
            // also happen for each of the "resume" file nodes.)

            // In this case, we do not want to round down. We round up and if that is beyond the stream
            // time, we just set cnsRoundedSeekTime to cnsSeekTime. The SDK will read data backwards in this
            // case till it finds a sample that is just smaller (or is it larger?) than cnsSeekTime.

            // Note that the index entries point to the previous key frame. So even if we succeed in rounding
            // up, the first sample that is returned could have a time stamp that is < abs(cnsFirstSampleOffset)

            cnsRoundedSeekTime = (cnsSeekTime/m_cnsIndexGranularity) * m_cnsIndexGranularity;

            if (cnsRoundedSeekTime < cnsSeekTime)
            {
                ::SafeAdd(cnsRoundedSeekTime, cnsRoundedSeekTime, m_cnsIndexGranularity);
                if (cnsRoundedSeekTime >
                                (qwLastStreamTime/m_cnsIndexGranularity) * m_cnsIndexGranularity)
                {
                    cnsRoundedSeekTime = cnsSeekTime;
                    if (cnsRoundedSeekTime >
                                    (qwLastStreamTime/m_cnsIndexGranularity) * m_cnsIndexGranularity)
                    {
                        // Ok, we have to round down
                        cnsRoundedSeekTime = (cnsSeekTime/m_cnsIndexGranularity) * m_cnsIndexGranularity;
                    }
                }
            }
            else
            {
                // The seek time we were given is already rounded.
                DVR_ASSERT(cnsRoundedSeekTime == cnsSeekTime, "");
            }
            DVR_ASSERT(cnsRoundedSeekTime <= (qwLastStreamTime/m_cnsIndexGranularity) * m_cnsIndexGranularity, "");
        }

        hr = pReaderNode->pWMReader->SetRange(cnsRoundedSeekTime,
                                              0      // Duration - 0 means duration is unlimited
                                             );

        if (FAILED(hr))
        {
            DvrIopDebugOut8(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "SetRange to time %I64u (stream seek time = %I64u, file start time = %I64u, first sample offset = %I64d) for file id %u failed; last seekable stream time for this ASF file = %I64u, Index granularity = %I64u, hr = 0x%x",
                            cnsRoundedSeekTime, cnsStreamTime, cnsStartTime, cnsFirstSampleOffset, pReaderNode->nFileId,
                            cnsStartTime + qwLastStreamTime + (bAdded? cnsFirstSampleOffset : 0),
                            m_cnsIndexGranularity, hr);

            if (hr != (HRESULT) NS_E_INVALID_REQUEST) {
                hrRet = hr;
            }
            else {
                //  returned NS_E_INVALID_REQUEST; what's been observed is that
                //    this can happen if we've set our seek pointer into a
                //    region at the end of file that does not have data i.e.
                //    the file has 15.95 minutes of content but cnsEndTime is
                //    for 16 minutes, and we've seeked into (15.95,16]; if this
                //    happens we return a well-known error code that is handled
                //    by the higher layers
                hrRet = HRESULT_FROM_WIN32 (ERROR_SEEK_ON_DEVICE) ;
            }

            // We could, but don't have to, close the file.
            __leave;
        }

        pCurrentReaderNode = pReaderNode;
        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;

        // Regardless of whether the seek was successful, reset the following.
        // The client has to re-seek before calling GetNextSample if the seek
        // failed.
        ResetReader(pCurrentReaderNode);

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }


    return hrRet;

} // CDVRReader::Seek

STDMETHODIMP CDVRReader::GetNextSample(OUT INSSBuffer**    ppSample,
                                       OUT QWORD*          pcnsStreamTimeOfSample,
                                       OUT QWORD*          pcnsSampleDuration,
                                       OUT DWORD*          pdwFlags,
                                       OUT WORD*           pwStreamNum)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetNextSample"

    DVRIO_TRACE_ENTER();

    // Arguments will be validated by the WM SDK; we don't use
    // them till the SDK has, so we don't validate them here.

    HRESULT hrRet = E_FAIL;
    BOOL    bCloseFiles = 1; // All files closed if this function hits an error
    BOOL    bReleaseBuffer = 0; // pWMReader->GetNextSample succeeded, but we return an error,
                                // We should release the buffer before we return.
    BOOL    bCancelled = 0;     // Read was cancelled


    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;
        BOOL    bEOF = 0;
        QWORD   cnsStartTime;
        QWORD   cnsEndTime;

        //  BUGBUG: remove
        // ASF_READER_NODE *   pNodeGetNextSample ;

        do
        {
            if (!m_pCurrentNode)
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "m_pCurrentNode is NULL, should call Seek first.");

                // Since m_pCurrentNode is NULL, it's unlikely that we have any files to close
                // Note that it won't hurt to remove this.
                bCloseFiles = 0;
                hrRet = HRESULT_FROM_WIN32(ERROR_SEEK); // Tell caller to seek first
                __leave;
            }

            DVR_ASSERT(m_pDVRFileCollection, "");

            // Is the file still within the ring buffer?
            hr = m_pDVRFileCollection->GetTimeExtentForFile(&m_FileCollectionInfo, m_pCurrentNode->nFileId, NULL, NULL);

            if (FAILED(hr) || hr == S_FALSE)
            {
                DVR_ASSERT(hr == S_FALSE,
                           "GetTimeExtentForFile failed while we have file open for reading?");

                if (hr == S_FALSE)
                {
                    DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "GetTimeExtentForFile for file id %u returns S_FALSE; file bumped out of the ring buffer",
                                    m_pCurrentNode->nFileId, hr, S_FALSE);
                    // Tell caller to seek first
                    hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
                }
                else
                {
                    DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "GetTimeExtentForFile for file id %u returns hr = 0x%x",
                                    m_pCurrentNode->nFileId, hr, S_FALSE);
                    // hr == E_FAIL; this is an internal error.
                    hrRet = hr;
                }
                __leave;
            }

            // Wait for the hReadyToReadFrom event

            DWORD nRet = ::WaitForSingleObject(m_pCurrentNode->hReadyToReadFrom, INFINITE);
            if (nRet == WAIT_FAILED)
            {
                DVR_ASSERT(0, "Reader node's WFSO(hReadyToReadFrom) failed");

                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "WFSO(hReadyToReadFrom) failed; hReadyToReadFrom = 0x%p, last error = 0x%x",
                                m_pCurrentNode->hReadyToReadFrom, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
               __leave;
            }

            if (m_pCurrentNode->pWMReader == NULL)
            {
                DVR_ASSERT(m_pCurrentNode->pWMReader != NULL, "");
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Reader node's pWMReader is NULL?!");
                hrRet = E_FAIL;
                __leave;
            }

            // Verify there was no error in opening the file, i.e., BeginWriting
            // succeeded
            if (FAILED(m_pCurrentNode->hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Reader node's hrRet indicates failure, hrRet = 0x%x",
                                m_pCurrentNode->hrRet);

                hrRet = m_pCurrentNode->hrRet;
                __leave;
            }


            //  BUGBUG remove
            // pNodeGetNextSample = m_pCurrentNode ;


            // We are ready to read.
            DWORD dwOutputNum;

            hr = m_pCurrentNode->pWMReader->GetNextSample(0,  // Get from any stream
                                                          ppSample,
                                                          pcnsStreamTimeOfSample,
                                                          pcnsSampleDuration,
                                                          pdwFlags,
                                                          &dwOutputNum,
                                                          pwStreamNum);

            // Note that for live files, we should not get EOF unless the
            // writer has actually closed the file and the reader has got to
            // the true end of file
            bEOF = (hr == (HRESULT) NS_E_NO_MORE_SAMPLES) ;

            if (!bEOF && FAILED(hr))
            {
                DWORD dwInternalError;

                if (hr ==  (HRESULT) NS_E_INVALID_REQUEST)
                {
                    // Internal error
                    DVR_ASSERT(SUCCEEDED(hr), "pWMReader->GetNextSample failed");
                    hrRet = E_FAIL;
                    dwInternalError = 1;
                }
                else
                {
                    if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
                    {
                        // Really the caller should be made to do this - if there are
                        // multiple threads making calls into us, resetting the event
                        // is not good. Also, caller has to do this anyway because
                        // ERROR_CANCELLED is returned only if the reader read ahead
                        // of the writer and blocked waiting, for the writer.

                        // ResetCancel();

                        bCancelled = 1;
                    }
                    else
                    {
                        // The following is only to trap an error that we hit once
                        // where the SDK returned ASF_E_BUFFERTOOSMALL when we were
                        // reading a live file and the writer was stopped before the
                        // file completed.

#if defined(DVR_UNOFFICIAL_BUILD)
                        WCHAR buf[256];
                        wsprintf(buf, L"Error 0x%x being returned from GetNextSample()", hr);
                        ::MessageBoxW(NULL, buf, L"DVR IO Reader", MB_OK);
                        DVR_ASSERT(0, "GNS returning an error");
#endif defined(DVR_UNOFFICIAL_BUILD)
                    }

                    hrRet = hr;

                    // No need to close all files if the client caused a temporary error
                    // In any case, should not do that if bCancelled == 1
                    bCloseFiles = 0;
                    dwInternalError = 0;
                }
                if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
                {
                    DvrIopDebugOut2(dwInternalError?
                                    DVRIO_DBG_LEVEL_INTERNAL_ERROR :
                                    DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "pWMReader->GetNextSample failed, hr = 0x%x, InternalError = %u",
                                    hr, dwInternalError);
                }
                __leave;
            }

            if (!bEOF)
            {
                bReleaseBuffer = 1;
            }

            // We have read a sample successfully or been returned EOF.
            //
            // Determine if the file is still in the ring buffer and its time extent.
            // If not EOF, making this call a second time is wasteful, but it's safer
            // since the start time of the file could have changed since the last call
            // (our writer will not do this - it does not change the start time of a file
            // that has already been written to)..File could have been bumped out of the
            // ring buffer during the read, so this call is not totally useless.

            hr = m_pDVRFileCollection->GetTimeExtentForFile(&m_FileCollectionInfo,
                                                            m_pCurrentNode->nFileId,
                                                            &cnsStartTime,
                                                            &cnsEndTime);

            if (FAILED(hr) || hr == S_FALSE)
            {
                DVR_ASSERT(hr == S_FALSE,
                           "GetTimeExtentForFile failed while we have file open for reading?");

                DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "GetTimeExtentForFile (after GetNextSample) for file id %u returns hr = 0x%x (S_FALSE = 0x%x)",
                                m_pCurrentNode->nFileId, hr, S_FALSE);

                if (hr == S_FALSE)
                {
                    // Note: Do this regardless of whether bEOF is set or not.
                    // This file got pulled out of the ring buffer. The writer
                    // has to have written a file after this and we should be
                    // able to seek to that file. Note that in teh special
                    // case that the writer Closes teh ring buffer after
                    // creating it, the first file remains in the file collection
                    // and GetTimeExtentForFile will not return S_FALSE.

                    // Tell caller to seek first
                    hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
                }
                else
                {
                    // hr == E_FAIL; this is an internal error.
                    hrRet = hr;
                }
                __leave;
            }

            if (bEOF)
            {
                // The file is still in the ring buffer, so the EOF we hit was a "good"
                // result. (Note that we may have called the ASF GetNextSample before the
                // writer wrote the first sample; in this case, the writer may have changed
                // the first sample time and bumped the file we were reading out of the
                // ring buffer. We know that has not happened if we get here; we'd have
                // bailed out when GetTimeExtentForFile returned S_FALSE.)

                DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE,
                                "Hit EOF; going to call Seek to start reading from the next file");

                // Note that the call to Seek has the side effect of seeking to the start of
                // the next ASF file. This is necessary if we had previously been reading that
                // file and seeked back (to a different file) and are now switching back to it.
                //
                // Note also that if the writer has not been closed (this is not the "real" EOF,
                // i.e., the EOF of the ring buffer), it has at least 1 file open. So
                // the sample time of the last sample written by the
                // writer would be >= cnsEndTime and the file collection object is aware that
                // there is a file after the one on which we hit EOF. We should be able to seek
                // to that file.

                //  ***********************************
                //  BUGBUG
                /*
                {
                    QWORD qwLastStreamTime1;
                    HRESULT hr1 = m_pDVRFileCollection->GetLastStreamTime(&qwLastStreamTime1);
                    DVR_ASSERT (SUCCEEDED (hr1), "") ;

                    //  don't seek further forward than live
                    cnsEndTime = (cnsEndTime > qwLastStreamTime1 ? qwLastStreamTime1 : cnsEndTime) ;
                    //  ***********************************
                }
                */



                hr = Seek(cnsEndTime);
                if (FAILED(hr))
                {
                    // The failure could be for several reasons. We could have failed to open
                    // the next file. The caller could have called Cancel (which the DVR file
                    // source could have detected while it was opening the file). We could have
                    // hit a time hole that spans the next ASF file's time extent. Or we
                    // could have hit the real EOF. The task here is to detect the last condition.
                    //
                    // On a real EOF, cnsEndTime would be > lsat sample time since samples
                    // written to a file are < cnsEndTime. So Seek should return HRESULT_FROM_WIN32(ERROR_SEEK).
                    // However, to be safe, check if cnsEndTime > last sample time here.

                    if (hr == HRESULT_FROM_WIN32(ERROR_SEEK))
                    {
                        QWORD qwLastStreamTime;

                        DVR_ASSERT(m_pDVRFileCollection, "");

                        HRESULT hrTmp = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &qwLastStreamTime);
                        if (FAILED(hrTmp))
                        {
                            hrRet = hrTmp;
                            __leave;
                        }

                        if (qwLastStreamTime < cnsEndTime)
                        {
                            // We've hit EOF. It's debatable whether this needs to be a success code
                            // rather than a failure; client will have to check for it specially
                            // anyway
                            hrRet = NS_E_NO_MORE_SAMPLES;

                            // Don't need to set bCloseFiles if we get a succeess code; else we do,
                            bCloseFiles = 0;
                        }
                        else
                        {
                            hrRet = hr;
                        }
                    }
                    else
                    {
                        hrRet = hr;
                    }

                    DVR_ASSERT(!bReleaseBuffer, "We should never have set this to 1 since we never read a sample");


                    if (hrRet != (HRESULT) NS_E_NO_MORE_SAMPLES)
                    {
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                                        "Seek to the next file failed after we hit EOF, returning hr = 0x%x",
                                        hrRet);
                    }
                    else
                    {
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                                        "Seek to the next file failed after we hit the \"real\" EOF, returning hr = 0x%x",
                                        hrRet);
                    }
                    __leave;
                }
            }
        }
        while (bEOF);

        // Change the sample time to the stream time
        ::SafeAdd(*pcnsStreamTimeOfSample, *pcnsStreamTimeOfSample, cnsStartTime);

        DVR_ASSERT(m_pDVRFileCollection, "");

        LONGLONG cnsFirstSampleTimeOffsetFromStartOfFile;
        QWORD    cnsLastStreamTime;

        for (int kkTryAgain = 0; kkTryAgain < 2; kkTryAgain++)
        {
            // This lock is needed only if we are sharing the file with
            // a live source; the writer could be updating the first
            // sample time on the node.  Also, we don't really
            // need to do the stuff in this loop in any other case
            // (i.e., if we are reading from a file, live or otherwise),
            // because the first sample's time is always based to 0 in that case.

            BOOL  bReleaseSharedMemoryLock;

            hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
            if (FAILED(hr))
            {
                hrRet = hr;
                m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
                __leave;
            }
            hr = m_pDVRFileCollection->GetFirstSampleTimeOffsetForFile(&m_FileCollectionInfo,
                                                                       m_pCurrentNode->nFileId,
                                                                       &cnsFirstSampleTimeOffsetFromStartOfFile,
                                                                       0 /* Do not lock - we already have the lock */);
            if (FAILED(hr))
            {
                // There's no reason this should fail (since we already have the lock)
                // Failure means we have an internal error

                DVR_ASSERT(SUCCEEDED(hr), "");
                hrRet = hr;
                m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
                __leave;
            }

            hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo,
                                                         &cnsLastStreamTime,
                                                         0 /* Do not lock - we already have the lock */);

            if (FAILED(hr))
            {
                // There's no reason this should fail (since we already have the lock)
                // Failure means we have an internal error

                DVR_ASSERT(SUCCEEDED(hr), "");
                hrRet = hr;
                m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
                __leave;
            }

            hr = m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            if (cnsFirstSampleTimeOffsetFromStartOfFile < CDVRRingBufferWriter::kInvalidFirstSampleOffsetTime)
            {
                break;
            }

            if (kkTryAgain == 0)
            {
                // Writer has not updated this member yet?
                // There is a small chance this can happen since the writer
                // updates this member after WriteSample completes (writer has
                // to verify it completed successfully before updating) and
                // the WriteSample could have caused the sample to be written
                // to the file and read back out before it returned. This is
                // very unlikely to happen.
                //
                // Also note that the test for MAXQWORD catches this only if
                // m_pCurrentNode->pcnsFirstSampleTimeOffsetFromStartOfFile has never been set. If
                // the writer revises this value downward (because sample times
                // do not increase monotonically), the client gets some
                // inaccurate info.
                ::Sleep(100);
            }
            else
            {
                // Something's wrong here
                DVR_ASSERT(cnsFirstSampleTimeOffsetFromStartOfFile != CDVRRingBufferWriter::kInvalidFirstSampleOffsetTime, "First sample time not updated");
            }
        }

        if (cnsFirstSampleTimeOffsetFromStartOfFile >= 0)
        {
            ::SafeAdd(*pcnsStreamTimeOfSample, *pcnsStreamTimeOfSample, cnsFirstSampleTimeOffsetFromStartOfFile);
        }
        else if (*pcnsStreamTimeOfSample < (QWORD) (0 - cnsFirstSampleTimeOffsetFromStartOfFile))
        {
            // We return 0. *pcnsStreamTimeOfSample += cnsFirstSampleTimeOffsetFromStartOfFile would
            // be negative but since pcnsStreamTimeOfSample is a QWORD*, it will be interpreted as a
            // large positive number.

            // The only time cnsFirstSampleOffset < 0 is when we are viewing a multi file recording
            // and this is the first ASF file in that recording. (If we support pause/resume recording
            // and create a new file node in the DVRFileCollection object each time we resume, this can
            // also happen for each of the "resume" file nodes.)

            // Note that, in Seek(), we try to handle this case by rounding up. But even if that succeeded,
            // the first sample that is returned could have a time stamp that is < abs(cnsFirstSampleOffset)
            // because the index entries point to the previous key frame.

            // Finally, note that the sample time we return is not really used by the client to render the
            // sample - the real media times are embedded in the samples. Setting the sample time to 0 should
            // not do much harm. (Although a better solution would be to send the real time back and have
            // the client drop the samples.) It could mess up the time reported by IMedaiSeeking::GetCurrentPosition
            // because the graph thinks it has seeked to 0 but actually we've seekd to a value before that.

            *pcnsStreamTimeOfSample = 0;
        }
        else
        {
            *pcnsStreamTimeOfSample += cnsFirstSampleTimeOffsetFromStartOfFile;
        }

        // Primarily for multi file recordings. Not that single file recordings
        // have to be excluded (hence, the test for m_bAmWriter) since the last stream time
        // is lazy updated for these file collections. EOF for single file recordings will
        // be detected above anyway.
        if (*pcnsStreamTimeOfSample > cnsLastStreamTime && !m_bAmWriter
            // && GetWriterHasBeenClosed and verify writer has been closed
            // -- it would be safer to do this but the file collection object
            // allows opening file collections (with no temp files) whose writer has dies prematurely
            // So, we may be reading a multi file recording that did not terminate gracefully. We don't
            // want to read the remainder of the file in that case.
            )
        {
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_TRACE,
                            "We hit the \"real\" EOF: *pcnsStreamTimeOfSample = %I64u > file colelction extent = %I64u, returning hr = 0x%x",
                            *pcnsStreamTimeOfSample, cnsLastStreamTime, hrRet);

            // We've hit EOF. It's debatable whether this needs to be a success code
            // rather than a failure; client will have to check for it specially
            // anyway
            hrRet = NS_E_NO_MORE_SAMPLES;

            // Don't need to set bCloseFiles if we get a succeess code; else we do,
            bCloseFiles = 0;
            __leave;
        }
        else
        {
            hrRet = S_OK; // not changed after this
        }

        // Open the next file if we can and if we haven't already done so.
        if (m_dwConsecutiveReads < m_dwMinConsecutiveReads)
        {
            m_dwConsecutiveReads++;
        }
        if (m_dwConsecutiveReads == m_dwMinConsecutiveReads)
        {
            // We haven't yet opened the next reader file. Try to do this

            QWORD cnsNextTime;

            // Note that we allow for "time holes" after this file here.
            // When we hit EOF (above), we don't seek beyond time holes.
            hr = m_pDVRFileCollection->GetFirstValidTimeAfter(&m_FileCollectionInfo,
                                                              cnsEndTime,
                                                              &cnsNextTime);
            if (SUCCEEDED(hr))
            {
                LIST_ENTRY* pNextReader;

                hr = GetFileAtTime(cnsNextTime, 0 /* bWait */, &pNextReader);

                if (FAILED(hr))
                {
                    // This should not happen - unless the file just got bumped out of the
                    // ring buffer (via a SetFileTime call)
                    DVR_ASSERT(pNextReader == NULL, "GetFileAtTime fails but pNextReader != NULL");
                }
                else
                {
                    DVR_ASSERT(pNextReader != NULL, "GetFileAtTime succeeds but pNextReader == NULL");

                    // Don't need to try to open a reader file any more (till we switch
                    // to reading some other file)
                    m_dwConsecutiveReads++;
                }
            }
            else
            {
                // There is no file after this one. Defer the next trial for another
                // m_dwMinConsecutiveReads reads
                m_dwConsecutiveReads = 0;
            }

            // Close all files before the current one
            hr = CloseAllReaderFilesBefore(cnsStartTime);
            if (FAILED(hr))
            {
                // Ignore this
            }
        }

    }
    __finally
    {
        HRESULT hr;

        if (FAILED(hrRet))
        {
            if (bCloseFiles)
            {
                // Close all files
                hr = CloseAllReaderFilesBefore(MAXQWORD);
                if (FAILED(hr))
                {
                    // Ignore this
                }

                // Following must be done; even though CloseAllReaderFilesBefore
                // calls ResetReader(), it does not call it if m_pCurrentNode was
                // equal to m_pProfileNode
                // Following can be skipped for EOF although it doesn't hurt to
                // do it - the failed Seek has already done this. (This comment is
                // irrelevant if we find a success error code to return for EOF such
                // as S_FALSE.)
                ResetReader();
            }

            if (bReleaseBuffer)
            {
                // pWMReader->GetNextSample succeeded, but we are
                // failing the call. This will happen on EOF on
                // multi file recordings - see comment above where hrRet is set
                // to NS_E_NO_MORE_SAMPLES for this case.
                if (ppSample && *ppSample)
                {
                    (*ppSample)->Release();
                    *ppSample = NULL;
                }
            }
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }


    return hrRet;

} // CDVRReader::GetNextSample

STDMETHODIMP CDVRReader::GetStreamTimeExtent(OUT QWORD*  pcnsStartStreamTime,
                                             OUT QWORD*  pcnsEndStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetStreamTimeExtent"

    DVRIO_TRACE_ENTER();

    if (!pcnsStartStreamTime || DvrIopIsBadWritePtr(pcnsStartStreamTime, 0) ||
        !pcnsEndStreamTime || DvrIopIsBadWritePtr(pcnsEndStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;
    BOOL                m_bUnlock = 0;

    __try
    {
        if (::TryEnterCriticalSection(&m_csLock))
        {
            // We need to get here only if we are reading from a
            // live file. UpdateTimeExtent doesn't do anything
            // in other cases.

            // If we are reading a live file and can't get in here,
            // no matter. We'll just return the previously cached
            // values. If the reader has read ahead of the writer
            // and is blocked, the cached values would have been
            // updated; in other cases, they could be stale.

            m_bUnlock = 1;
            hrRet = UpdateTimeExtent();
            if (FAILED(hrRet))
            {
                __leave;
            }

            // no harm holding on to the critical section lock.
        }

        // We don't need to have a lock on this  object for
        // the rest of this routine. We assume that the caller
        // has us properly addref'd and so we will nto be destroyed
        // while this function is executing.

        //  PREFIX
        if (m_pDVRFileCollection) {
            hrRet = m_pDVRFileCollection->GetTimeExtent(&m_FileCollectionInfo,
                                                        pcnsStartStreamTime,
                                                        pcnsEndStreamTime);
        }
        else {
            hrRet = E_UNEXPECTED ;
        }

    }
    __finally
    {
        if (m_bUnlock)
        {
            ::LeaveCriticalSection(&m_csLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }


    return hrRet;

} // CDVRReader::GetStreamTimeExtent

STDMETHODIMP CDVRReader::GetFirstValidTimeAfter(IN  QWORD    cnsStreamTime,
                                                OUT QWORD*   pcnsNextValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetFirstValidTimeAfter"

    DVRIO_TRACE_ENTER();

    if (!pcnsNextValidStreamTime || DvrIopIsBadWritePtr(pcnsNextValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        hrRet = UpdateTimeExtent();
        if (FAILED(hrRet))
        {
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        hrRet = m_pDVRFileCollection->GetFirstValidTimeAfter(&m_FileCollectionInfo,
                                                             cnsStreamTime,
                                                             pcnsNextValidStreamTime);
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }


    return hrRet;

} // CDVRReader::GetFirstValidTimeAfter

STDMETHODIMP CDVRReader::GetLastValidTimeBefore(IN  QWORD    cnsStreamTime,
                                                OUT QWORD*   pcnsLastValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetLastValidTimeBefore"

    DVRIO_TRACE_ENTER();

    if (!pcnsLastValidStreamTime || DvrIopIsBadWritePtr(pcnsLastValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        hrRet = UpdateTimeExtent();
        if (FAILED(hrRet))
        {
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        hrRet = m_pDVRFileCollection->GetLastValidTimeBefore(&m_FileCollectionInfo,
                                                             cnsStreamTime,
                                                             pcnsLastValidStreamTime);
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }


    return hrRet;

} // CDVRReader::GetLastValidTimeBefore

STDMETHODIMP CDVRReader::Cancel()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Cancel"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    // Caller should have addref'd the object. m_hCancel is
    // created in the constructor and destroyed in the destructor,
    // so there is no need to grab the critical section.
    DVR_ASSERT(m_hCancel, "");

    if (!::SetEvent(m_hCancel))
    {
        hrRet = HRESULT_FROM_WIN32(::GetLastError());
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // CDVRReader::Cancel

STDMETHODIMP CDVRReader::ResetCancel()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ResetCancel"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    // Caller should have addref'd the object. m_hCancel is
    // created in the constructor and destroyed in the destructor,
    // so there is no need to grab the critical section.
    DVR_ASSERT(m_hCancel, "");

    if (!::ResetEvent(m_hCancel))
    {
        hrRet = HRESULT_FROM_WIN32(::GetLastError());
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // CDVRReader::ResetCancel

STDMETHODIMP_(ULONG) CDVRReader::IsLive()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::IsLive"

    DVRIO_TRACE_ENTER();

    LONG nRet;

    // Caller should have addref'd the object. m_bSourceIsAnASFFile is
    // set in the constructor and unchanged thereafter,
    // so there is no need to grab the critical section yet.
    if (!m_bSourceIsAnASFFile)
    {
        DVR_ASSERT(m_pDVRFileCollection, "");

        LONG    nWriterCompleted;
        HRESULT hr = m_pDVRFileCollection->GetWriterHasBeenClosed(&m_FileCollectionInfo, &nWriterCompleted);
        if (SUCCEEDED(hr))
        {
            nRet = (!nWriterCompleted)? 1 : 0;
        }
        else
        {
            // We are going to hit an error each time we call this funciton.
            // So, effectively, the writer has completed.
            nRet = 1;
        }
     }
    else
    {
        ::EnterCriticalSection(&m_csLock);

        __try
        {
            if (m_bDVRProgramFileIsLive)
            {
                // Get current status

                HRESULT hr = UpdateTimeExtent();

                if (FAILED(hr))
                {
                    nRet = 1;
                }
                else
                {
                    nRet = m_bDVRProgramFileIsLive? 1 : 0;
                }
            }
            else
            {
                nRet = 0;
            }
        }
        __finally
        {
            ::LeaveCriticalSection(&m_csLock);
        }
    }

    DVRIO_TRACE_LEAVE1(nRet);

    return nRet;

} // CDVRReader::IsLive

STDMETHODIMP_(ULONG) CDVRReader::StartTimeAnchoredAtZero()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::StartTimeAnchoredAtZero"

    DVRIO_TRACE_ENTER();

    LONG nRet;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        DVR_ASSERT(m_pDVRFileCollection, "");

        nRet = m_pDVRFileCollection->StartTimeAnchoredAtZero(&m_FileCollectionInfo);
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
    }

    DVRIO_TRACE_LEAVE1(nRet);

    return nRet;

} // CDVRReader::StartTimeAnchoredAtZero

STDMETHODIMP CDVRReader::ReadIsGoingToPend()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ReadIsGoingToPend"

    DVRIO_TRACE_ENTER();

    HRESULT             hrRet;

    // We should NOT block in this funciton

    // We should have already acquired all the locks
    if (!::TryEnterCriticalSection(&m_csLock))
    {
        DVR_ASSERT(0, "Sync Reader using a different thread to read bytes than the one calling GetNextSample.");
        return E_FAIL;
    }

    __try
    {
        hrRet = UpdateTimeExtent();
        if (FAILED(hrRet))
        {
            __leave;
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::ReadIsGoingToPend
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\precomp.h ===
#ifndef _DVR_IO_PRECOMP_H_
#define _DVR_IO_PRECOMP_H_

#include "dvrall.h"

// winnt.h is not included by windows.h because nt.h is included
// earlier. As a result MAXDWORD is undefined.

#ifndef MAXDWORD
#define MAXDWORD 0xffffffff
#endif

#include <malloc.h>     // For _alloca
#include <accctrl.h>    // For security/ACL stuff
#include <aclapi.h>     // For security/ACL stuff



#include <nserror.h>

// Use _DVR_IOP_ to define exported functions.
#define _DVR_IOP_
#include <dvrw32.h>
#include <dvrIOidl.h>
#include <DVRFileSource.h>
#include <DVRFileSink.h>
#include <dvrasyncio.h>
#include <dvrIOp.h>

#endif // _DVR_IO_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvrreg.cpp ===
//------------------------------------------------------------------------------
// File: dvrReg.cpp
//
// Description: Implements registry related functions.
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop


#if defined(DEBUG)

#define DVRIO_DUMP_THIS_FORMAT_STR ""
#define DVRIO_DUMP_THIS_VALUE

void DvrIopDbgInitFromRegistry(
    IN  HKEY  hRegistryKey,
    IN  DWORD dwNumValues, 
    IN  const WCHAR* awszValueNames[],
    OUT DWORD* apdwVariables[]
    )
{
    // Note: Only DVR_ASSERT variants should be used in this function.
    // No trace, no DvrIopDebugOut except for errors

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopDbgInitFromRegistry"

    // Can't do this: not set up yet!
    // DVRIO_TRACE_ENTER();

    HKEY hDvrIoDebugKey = NULL;
    DWORD dwRegRet;

    __try
    {
        dwRegRet = ::RegCreateKeyExW(
                        hRegistryKey,
                        kwszRegDvrIoDebugKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoDebugKey,     // key handle 
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DVR_ASSERT(hDvrIoDebugKey,
                       "Creation/opening of registry key hDvrIoDebugKey failed.");
            __leave;
        }
        for (DWORD i = 0; i < dwNumValues; i++)
        {
            DWORD dwType;
            DWORD dwVal;
            DWORD dwValBufSize = sizeof(dwVal);
        
            dwRegRet = ::RegQueryValueExW(hDvrIoDebugKey,     // key
                                          awszValueNames[i],  // value name
                                          NULL,               // reserved
                                          &dwType,            // type of value
                                          (LPBYTE) &dwVal,    // Value
                                          &dwValBufSize       // sizeof dwVal
                                         );
            if (dwRegRet == ERROR_SUCCESS && dwType == REG_DWORD)
            {
                *(apdwVariables[i]) = dwVal;
            }
            else if (dwRegRet == ERROR_FILE_NOT_FOUND)
            {
                dwVal = *(apdwVariables[i]);

                dwRegRet = ::RegSetValueExW(hDvrIoDebugKey,     // key
                                            awszValueNames[i],  // value name
                                            NULL,               // reserved
                                            REG_DWORD,          // type of value
                                            (LPBYTE) &dwVal,    // Value
                                            sizeof(DWORD)       // sizeof dwVal
                                           );
                if (dwRegRet != ERROR_SUCCESS)
                {
                    DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                               "Setting value of debug registry key failed.");
                    // Ignore the error and move to the next value
                }
            }
            else
            {
                // Ignore the error and move on
            }
        }
    }
    __finally
    {
        if (hDvrIoDebugKey)
        {
            dwRegRet = ::RegCloseKey(hDvrIoDebugKey);
            if (dwRegRet != ERROR_SUCCESS)
            {
                DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                           "Closing registry key hDvrIoDebugKey failed.");
            }
        }
    }

    // DVRIO_TRACE_LEAVE();

    return;
} // void DvrIopDbgInitFromRegistry

#endif // DEBUG


DWORD GetRegDWORD(IN HKEY hKey, IN LPCWSTR pwszValueName, IN DWORD dwDefaultValue)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "GetRegDWORD"

    DVRIO_TRACE_ENTER();

    if (!hKey || !pwszValueName || DvrIopIsBadStringPtr(pwszValueName))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return dwDefaultValue;
    }

    DWORD dwRet = dwDefaultValue;
    DWORD dwRegRet;

    __try
    {
        DWORD dwType;
        DWORD dwSize;
        DWORD dwValue;

        dwSize = sizeof(DWORD);

        dwRegRet = ::RegQueryValueExW(
                        hKey,
                        pwszValueName,       // value's name
                        0,                   // reserved
                        &dwType,             // type
                        (LPBYTE) &dwValue,   // data
                        &dwSize              // size in bytes
                       );
        if (dwRegRet != ERROR_SUCCESS && dwRegRet != ERROR_FILE_NOT_FOUND)
        {            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "RegGetValueExW failed; error = 0x%x", 
                            dwRegRet);

            __leave;
        }
        if (dwRegRet == ERROR_FILE_NOT_FOUND)
        {
            dwRegRet = ::RegSetValueExW(hKey,               // key
                                        pwszValueName,      // value name
                                        NULL,               // reserved
                                        REG_DWORD,          // type of value
                                        (LPBYTE) &dwRet,    // Value
                                        sizeof(DWORD)       // sizeof dwVal
                                       );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                           "Setting value of debug registry key failed.");
            }
            __leave;
        }
        if (dwType != REG_DWORD)
        {
            DVR_ASSERT(dwType == REG_DWORD, "Type of value is not REG_DWORD");
            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Type of value is not REG_DWORD, it is = 0x%x", 
                            dwType);

            __leave;
        }

        dwRet = dwValue;
        __leave;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1(dwRet);
    }

    return dwRet;

} // GetRegDWORD

HRESULT GetRegString(IN HKEY hKey, 
                     IN LPCWSTR pwszValueName,
                     OUT LPWSTR pwszValue OPTIONAL,
                     IN OUT DWORD* pdwSize)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "GetRegString"

    DVRIO_TRACE_ENTER();

    if (!hKey || !pdwSize || DvrIopIsBadWritePtr(pdwSize, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (pwszValue && DvrIopIsBadWritePtr(pwszValue, *pdwSize))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT hrRet;
    DWORD dwRegRet;

    __try
    {
        DWORD dwType;

        dwRegRet = ::RegQueryValueExW(
                        hKey,
                        pwszValueName,       // value's name
                        0,                   // reserved
                        &dwType,             // type
                        (LPBYTE) pwszValue,   // data
                        pdwSize              // size in bytes
                       );
        if (dwRegRet == ERROR_FILE_NOT_FOUND)
        {
            WCHAR w[] = L"";
            dwRegRet = ::RegSetValueExW(hKey,               // key
                                        pwszValueName,      // value name
                                        NULL,               // reserved
                                        REG_SZ,             // type of value
                                        (LPBYTE) w,         // Value
                                        sizeof(w)           // sizeof dwVal
                                       );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                           "Setting value of debug registry key failed.");
            }
            hrRet = HRESULT_FROM_WIN32(dwRegRet);
            __leave;
        }
        else if (dwRegRet != ERROR_SUCCESS)
        {            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "RegGetValueExW failed; error = 0x%x", 
                            dwRegRet);

            hrRet = HRESULT_FROM_WIN32(dwRegRet);
            __leave;
        }
        else if (dwType != REG_SZ)
        {
            DVR_ASSERT(dwType == REG_SZ, "Type of value name is not REG_SZ");
            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Type of value name is not REG_SZ, it is = 0x%x", 
                            dwType);

            *pdwSize = 0;
            hrRet = E_FAIL;
            __leave;
        }

        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // GetRegString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\dvrio\dvrioringbufferwriter.cpp ===
//------------------------------------------------------------------------------
// File: dvrIORingBufferWriter.cpp
//
// Description: Implements the class CDVRRingBufferWriter
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop


HRESULT
STDMETHODCALLTYPE
DVRCreateRecorderWriter (
    IN  CPVRIOCounters *        pPVRIOCounters,
    IN  LPCWSTR                 pszRecordingName,
    IN  IWMProfile*             pProfile,
    IN  DWORD                   dwIndexStreamId,
    IN  DWORD                   msIndexGranularity,
    IN  BOOL                    fUnbufferedIo,
    IN  DWORD                   dwIoSize,
    IN  DWORD                   dwBufferCount,
    IN  DWORD                   dwAlignment,
    IN  DWORD                   dwFileGrowthQuantum,
    IN  HKEY                    hkeyRoot,
    OUT IDVRRecorderWriter **   ppIDVRRecorderWriter
    )
{
    CDVRRecorderWriter *    pCDVRRecorderWriter ;
    HRESULT                 hr ;

    ASSERT (ppIDVRRecorderWriter) ;
    (* ppIDVRRecorderWriter) = NULL ;

    pCDVRRecorderWriter = new CDVRRecorderWriter (
                                pPVRIOCounters,
                                pszRecordingName,
                                pProfile,
                                dwIndexStreamId,
                                msIndexGranularity,
                                fUnbufferedIo,
                                dwIoSize,
                                dwBufferCount,
                                dwAlignment,
                                dwFileGrowthQuantum,
                                hkeyRoot,
                                & hr
                                ) ;

    if (!pCDVRRecorderWriter) {
        hr = E_OUTOFMEMORY ;
        goto cleanup ;
    }
    else if (FAILED (hr)) {
        delete pCDVRRecorderWriter ;
        goto cleanup ;
    }

    //  ours
    pCDVRRecorderWriter -> AddRef () ;

    hr = pCDVRRecorderWriter -> QueryInterface (
            IID_IDVRRecorderWriter,
            (void **) ppIDVRRecorderWriter
            ) ;

    //  ours
    pCDVRRecorderWriter -> Release () ;

    if (FAILED (hr)) {
        goto cleanup ;
    }

    cleanup :

    return hr ;
}

//  ------------------------
//  ------------------------

CDVRRecorderWriter::CDVRRecorderWriter (
    IN  CPVRIOCounters *    pPVRIOCounters,
    IN  LPCWSTR             pszRecordingName,
    IN  IWMProfile *        pProfile,
    IN  DWORD               dwIndexStreamId,
    IN  DWORD               msIndexGranularity,
    IN  BOOL                fUnbufferedIo,
    IN  DWORD               dwIoSize,
    IN  DWORD               dwBufferCount,
    IN  DWORD               dwAlignment,
    IN  DWORD               dwFileGrowthQuantum,
    IN  HKEY                hkeyRoot,
    OUT HRESULT *           phr
    ) : m_cRef                  (0),
        m_pAsyncIo              (NULL),
        m_dwIoSize              (dwIoSize),
        m_dwBufferCount         (dwBufferCount),
        m_dwAlignment           (dwAlignment),
        m_dwFileGrowthQuantum   (dwFileGrowthQuantum),
        m_dwIndexStreamId       (dwIndexStreamId),
        m_msIndexGranularity    (msIndexGranularity),
        m_pIWMWriter            (NULL),
        m_pIWMWriterAdvanced    (NULL),
        m_pIWMHeaderInfo        (NULL),
        m_pIDVRFileSink         (NULL),
        m_pIWMWriterSink        (NULL),
        m_pIWMWriterFileSink    (NULL),
        m_fWritingState         (FALSE)
{
    DWORD   dw ;

    InitializeCriticalSection (& m_crt) ;

    //  make sure the file doesn't already exist; that will be cause for an
    //    outright failure;
    ASSERT (pszRecordingName) ;
    dw = ::GetFileAttributesW (pszRecordingName) ;
    if (dw == INVALID_FILE_ATTRIBUTES) {
        dw = ::GetLastError () ;
        if (dw != ERROR_FILE_NOT_FOUND) {
            //  some other failure - not what we wanted
            (* phr) = E_INVALIDARG ;
            goto cleanup ;
        }
    }
    else {
        //  file already exists
        (* phr) = E_INVALIDARG ;
        goto cleanup ;
    }

    (* phr) = InitUnbufferedIo_ (fUnbufferedIo) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = InitDVRSink_ (hkeyRoot, pPVRIOCounters) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = InitWM_ (pProfile) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ASSERT (m_pIWMWriter) ;
    ASSERT (m_pIWMWriterAdvanced) ;
    ASSERT (m_pIWMHeaderInfo) ;
    ASSERT (m_pIDVRFileSink) ;
    ASSERT (m_pIWMWriterSink) ;
    ASSERT (m_pIWMWriterFileSink) ;

    //  everything is setup; open the target file
    (* phr) = m_pIWMWriterFileSink -> Open (pszRecordingName) ;
    if (FAILED (* phr)) { goto cleanup ; }

    cleanup :

    return ;
}

CDVRRecorderWriter::~CDVRRecorderWriter (
    )
{
    ReleaseAll_ () ;

    DeleteCriticalSection (& m_crt) ;
}

HRESULT
CDVRRecorderWriter::InitUnbufferedIo_ (
    IN  BOOL    fUnbuffered
    )
{
    HRESULT hr ;

    if (fUnbuffered) {
        m_pAsyncIo = new CAsyncIo () ;
        if (!m_pAsyncIo) {
            hr = E_OUTOFMEMORY ;
            goto cleanup ;
        }

        m_pAsyncIo -> AddRef () ;
    }
    else {
        //  nothing to do
        hr = S_OK ;
    }

    cleanup :

    return hr ;
}

HRESULT
CDVRRecorderWriter::InitDVRSink_ (
    IN  HKEY                hkeyRoot,
    IN  CPVRIOCounters *    pPVRIOCounters
    )
{
    HKEY                    hkeyIoRoot ;
    HRESULT                 hr ;
    IDVRFileSink2 *         pIDVRFileSink2 ;
    CPVRAsyncWriterCOM *    pPVRAsyncWriterCOM ;
    DWORD                   dwRet ;
    IWMRegisterCallback *   pIWMRegisterCallback ;

    ASSERT (!m_pIDVRFileSink) ;
    ASSERT (!m_pIWMWriterFileSink) ;
    ASSERT (!m_pIWMWriterSink) ;

    hkeyIoRoot              = NULL ;
    pIDVRFileSink2          = NULL ;
    pIWMRegisterCallback    = NULL ;

    dwRet = ::RegCreateKeyExW(
                    hkeyRoot,
                    kwszRegDvrIoWriterKey,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    & hkeyIoRoot,
                    NULL
                    ) ;
    if (dwRet != ERROR_SUCCESS) {
        //  don't fail the whole call; dvrsink only uses this key in
        //  "unofficial" builds
        hkeyIoRoot = NULL ;
    }

    //  ------------------------------------------------------------------------
    //  instantiate the DVRSink

    hr = ::DVRCreateDVRFileSink (hkeyRoot, hkeyIoRoot, 0 /* numSids */ , NULL /* ppSids */ , & m_pIDVRFileSink) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (m_pIDVRFileSink) ;

    //  ------------------------------------------------------------------------
    //  setup unbuffered IO

    if (m_pAsyncIo) {

        hr = m_pIDVRFileSink -> QueryInterface (
                    IID_IDVRFileSink2,
                    (void **) & pIDVRFileSink2
                    ) ;
        if (FAILED (hr)) { goto cleanup ; }

        pPVRAsyncWriterCOM = new CPVRAsyncWriterCOM (
                                    m_dwIoSize,
                                    m_dwBufferCount,
                                    m_dwAlignment,
                                    m_dwFileGrowthQuantum,
                                    m_pAsyncIo,
                                    pPVRIOCounters,
                                    0,              // dwNumSids
                                    NULL,           // ppSids
                                    & dwRet
                                    ) ;

        if (!pPVRAsyncWriterCOM) {
            hr = E_OUTOFMEMORY ;
            goto cleanup ;
        }
        else if (dwRet != NOERROR) {
            hr = HRESULT_FROM_WIN32 (dwRet) ;
            delete pPVRAsyncWriterCOM ;
            goto cleanup ;
        }

        pPVRAsyncWriterCOM -> AddRef () ;

        hr = pIDVRFileSink2 -> SetAsyncIOWriter (pPVRAsyncWriterCOM) ;

        pPVRAsyncWriterCOM -> Release () ;

        if (FAILED (hr)) {
            goto cleanup ;
        }
    }

    //  ------------------------------------------------------------------------
    //  the error callback

    hr = m_pIDVRFileSink -> QueryInterface (
            IID_IWMRegisterCallback,
            (void **) & pIWMRegisterCallback
            ) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = pIWMRegisterCallback -> Advise (
            static_cast <IWMStatusCallback *> (this),
            0
            ) ;

    //  ------------------------------------------------------------------------
    //  get a couple of interfaces we'll need

    hr = m_pIDVRFileSink -> QueryInterface (
            IID_IWMWriterFileSink,
            (void **) & m_pIWMWriterFileSink
            ) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = m_pIDVRFileSink -> QueryInterface (
            IID_IWMWriterSink,
            (void **) & m_pIWMWriterSink
            ) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  configure the sink

    m_pIDVRFileSink -> MarkFileTemporary (FALSE) ;
    m_pIDVRFileSink -> SetIndexStreamId (m_dwIndexStreamId, m_msIndexGranularity) ;

    cleanup :

    if (hkeyIoRoot) {
        ::RegCloseKey (hkeyIoRoot) ;
    }

    RELEASE_AND_CLEAR (pIDVRFileSink2) ;
    RELEASE_AND_CLEAR (pIWMRegisterCallback) ;

    return hr ;
}

HRESULT
CDVRRecorderWriter::InitWM_ (
    IN  IWMProfile *    pIWMProfile
    )
{
    HRESULT hr ;
    DWORD   dwNumInputs ;

    ASSERT (pIWMProfile) ;
    ASSERT (!m_pIWMWriter) ;
    ASSERT (!m_pIWMHeaderInfo) ;
    ASSERT (!m_pIWMWriterAdvanced) ;
    ASSERT (m_pIDVRFileSink) ;
    ASSERT (m_pIWMWriterSink) ;

    //  ------------------------------------------------------------------------
    //  configure the WM-specific first

    hr = ::WMCreateWriter (NULL, & m_pIWMWriter) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (m_pIWMWriter) ;
    hr = m_pIWMWriter -> QueryInterface (IID_IWMWriterAdvanced3, (void **) & m_pIWMWriterAdvanced) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (m_pIWMWriterAdvanced) ;

    (hr) = m_pIWMWriter -> QueryInterface (IID_IWMHeaderInfo, (void **) & m_pIWMHeaderInfo) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (m_pIWMHeaderInfo) ;

    m_pSBERecordingAttributes = new CSBERecordingAttributesWM (m_pIWMHeaderInfo) ;
    if (!m_pSBERecordingAttributes) { hr = E_OUTOFMEMORY ; goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  now plug in the DVRSink

    hr = m_pIWMWriterAdvanced -> AddSink (m_pIWMWriterSink) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  final configuration

    hr = m_pIWMWriter -> SetProfile (pIWMProfile) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = m_pIWMWriter -> GetInputCount (& dwNumInputs) ;
    if (FAILED (hr)) { goto cleanup ; }

    for (;dwNumInputs > 0;) {
        dwNumInputs-- ;
        hr = m_pIWMWriter -> SetInputProps (dwNumInputs, NULL) ;
    }

    hr = m_pIWMWriterAdvanced -> SetNonBlocking () ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = m_pIWMWriterAdvanced -> SetSyncTolerance (0) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = m_pIWMHeaderInfo -> SetAttribute (0, g_kwszDVRIndexGranularity, WMT_TYPE_DWORD,
                                           (BYTE *) & m_msIndexGranularity, sizeof m_msIndexGranularity) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = m_pIWMHeaderInfo -> SetAttribute (0, g_kwszDVRFileVersion, WMT_TYPE_BINARY,
                                           (BYTE *) & CDVRFileCollection::m_guidV5, sizeof CDVRFileCollection::m_guidV5) ;
    if (FAILED (hr)) { goto cleanup ; }

    cleanup :

    return hr ;
}

STDMETHODIMP
CDVRRecorderWriter::QueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (!ppv) {
        return E_POINTER ;
    }

    if (riid == IID_IDVRRecorderWriter) {
        (* ppv) = static_cast <IDVRRecorderWriter *> (this) ;
    }
    else if (riid == IID_IDVRIORecordingAttributes) {
        (* ppv) = static_cast <IDVRIORecordingAttributes *> (this) ;
    }
    else if (riid == IID_IUnknown) {
        (* ppv) = static_cast <IDVRRecorderWriter *> (this) ;
    }
    else {
        return E_NOINTERFACE ;
    }

    ASSERT (ppv) ;

    //  outgoing
    reinterpret_cast <IUnknown *> (* ppv) -> AddRef () ;

    return S_OK ;
}

STDMETHODIMP_(ULONG)
CDVRRecorderWriter::AddRef(
    )
{
    return ::InterlockedIncrement (& m_cRef) ;
}

STDMETHODIMP_(ULONG)
CDVRRecorderWriter::Release(
    )
{
    if (::InterlockedDecrement (& m_cRef) == 0) {
        delete this ;
        return 0 ;
    }

    return 1 ;
}

HRESULT
CDVRRecorderWriter::ReleaseAll_ (
    )
{
    HRESULT                 hr ;
    IWMRegisterCallback *   pIWMRegisterCallback ;

    hr = S_OK ;

    pIWMRegisterCallback    = NULL ;

    //  ------------------------------------------------------------------------
    //  null off the callbacks

    if (m_pIDVRFileSink) {

        hr = m_pIDVRFileSink -> QueryInterface (
                IID_IWMRegisterCallback,
                (void **) & pIWMRegisterCallback
                ) ;
        if (FAILED (hr)) { goto cleanup ; }

        hr = pIWMRegisterCallback -> Unadvise (
                static_cast <IWMStatusCallback *> (this),
                0
                ) ;
    }

    //  ------------------------------------------------------------------------
    //  remove the file writer sink

    if (m_pIWMWriterSink &&
        m_pIWMWriterAdvanced) {

        hr = m_pIWMWriterAdvanced -> RemoveSink (m_pIWMWriterSink) ;
        if (FAILED (hr)) { goto cleanup ; }
    }

    //  ------------------------------------------------------------------------
    //  cast off all interfaces & reset

    RELEASE_AND_CLEAR   (m_pAsyncIo) ;
    RELEASE_AND_CLEAR   (m_pIWMWriter) ;
    RELEASE_AND_CLEAR   (m_pIWMWriterAdvanced) ;
    RELEASE_AND_CLEAR   (m_pIWMHeaderInfo) ;
    RELEASE_AND_CLEAR   (m_pIDVRFileSink) ;
    RELEASE_AND_CLEAR   (m_pIWMWriterSink) ;
    DELETE_RESET        (m_pSBERecordingAttributes) ;

    cleanup :

    RELEASE_AND_CLEAR (pIWMRegisterCallback) ;

    return hr ;
}

STDMETHODIMP
CDVRRecorderWriter::WriteSample (
    IN  WORD            wStreamNum,
    IN  QWORD           cnsStreamTime,
    IN  DWORD           dwFlags,
    IN  INSSBuffer *    pSample
    )
{
    HRESULT hr ;

    ASSERT (m_pIWMWriterAdvanced) ;
    ASSERT (m_pIWMWriter) ;

    Lock_ () ;

    if (!m_fWritingState) {
        hr = m_pIWMWriter -> BeginWriting () ;
        if (FAILED (hr)) { goto cleanup ; }

        m_fWritingState = TRUE ;
    }

    hr = m_pIWMWriterAdvanced -> WriteStreamSample (
                wStreamNum,
                cnsStreamTime,
                0,
                0,
                dwFlags,
                pSample
                ) ;

    cleanup :

    Unlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRRecorderWriter::Close (
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (m_pIWMWriter) {
        hr = m_pIWMWriter -> EndWriting () ;
    }

    hr = S_OK ;

    ReleaseAll_ () ;

    Unlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRRecorderWriter::OnStatus (
    IN  WMT_STATUS          Status,
    IN  HRESULT             hr,
    IN  WMT_ATTR_DATATYPE   dwType,
    IN  BYTE *              pbValue,
    IN  void *              pvContext
    )
{
    return S_OK ;
}

STDMETHODIMP
CDVRRecorderWriter::SetDVRIORecordingAttribute (
    IN  LPCWSTR                     pszAttributeName,
    IN  WORD                        wStreamNumber,
    IN  STREAMBUFFER_ATTR_DATATYPE  DataType,
    IN  BYTE *                      pbAttribute,
    IN  WORD                        wAttributeLength
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (m_pSBERecordingAttributes) {
        hr = m_pSBERecordingAttributes -> SetAttribute (
                    wStreamNumber,
                    pszAttributeName,
                    DataType,
                    pbAttribute,
                    wAttributeLength
                    ) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRRecorderWriter::GetDVRIORecordingAttributeCount (
    IN  WORD    wStreamNumber,
    OUT WORD *  pcAttributes
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (m_pSBERecordingAttributes) {
        hr = m_pSBERecordingAttributes -> GetAttributeCount (
                    wStreamNumber,
                    pcAttributes
                    ) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRRecorderWriter::GetDVRIORecordingAttributeByName (
    IN      LPCWSTR                         pszAttributeName,
    IN OUT  WORD *                          pwStreamNumber,
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (m_pSBERecordingAttributes) {
        hr = m_pSBERecordingAttributes -> GetAttributeByName (
                    pszAttributeName,
                    pwStreamNumber,
                    pDataType,
                    pbAttribute,
                    pcbLength
                    ) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;

}

STDMETHODIMP
CDVRRecorderWriter::GetDVRIORecordingAttributeByIndex (
    IN      WORD                            wIndex,
    IN OUT  WORD *                          pwStreamNumber,
    OUT     WCHAR *                         pszAttributeName,
    IN OUT  WORD *                          pcchNameLength,
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pDataType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (m_pSBERecordingAttributes) {
        hr = m_pSBERecordingAttributes -> GetAttributeByIndex (
                    wIndex,
                    pwStreamNumber,
                    pszAttributeName,
                    pcchNameLength,
                    pDataType,
                    pbAttribute,
                    pcbLength
                    ) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

HRESULT STDMETHODCALLTYPE DVRCreateRingBufferWriter(IN  CPVRIOCounters *            pPVRIOCounters,
                                                    IN  DWORD                       dwMinNumberOfTempFiles,
                                                    IN  DWORD                       dwMaxNumberOfTempFiles,
                                                    IN  DWORD                       dwMaxNumberOfFiles,
                                                    IN  DWORD                       dwGrowBy,
                                                    IN  QWORD                       cnsTimeExtentOfEachFile,
                                                    IN  IWMProfile*                 pProfile,
                                                    IN  DWORD                       dwIndexStreamId,
                                                    IN  DWORD                       msIndexGranularity,
                                                    IN  BOOL                        fUnbufferedIo,
                                                    IN  DWORD                       dwIoSize,
                                                    IN  DWORD                       dwBufferCount,
                                                    IN  DWORD                       dwAlignment,
                                                    IN  DWORD                       dwFileGrowthQuantum,
                                                    IN  DVRIO_NOTIFICATION_CALLBACK pfnCallback OPTIONAL,
                                                    IN  LPVOID                      pvContext,
                                                    IN  HKEY                        hRegistryRootKeyParam OPTIONAL,
                                                    IN  LPCWSTR                     pwszDVRDirectory OPTIONAL,
                                                    IN  LPCWSTR                     pwszRingBufferFileName OPTIONAL,
                                                    IN  DWORD                       dwNumSids,
                                                    IN  PSID*                       ppSids OPTIONAL,
                                                    OUT IDVRRingBufferWriter**      ppDVRRingBufferWriter)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DVRCreateRingBufferWriter"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    if (!ppDVRRingBufferWriter || DvrIopIsBadWritePtr(ppDVRRingBufferWriter, 0) ||
        (pwszDVRDirectory && DvrIopIsBadStringPtr(pwszDVRDirectory))            ||
        (pwszRingBufferFileName && DvrIopIsBadStringPtr(pwszRingBufferFileName))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    if (dwMinNumberOfTempFiles <= 3 || dwMinNumberOfTempFiles > dwMaxNumberOfTempFiles ||
        dwMaxNumberOfFiles < dwMaxNumberOfTempFiles ||
        dwMaxNumberOfFiles > CDVRFileCollection::m_kMaxFilesLimit)
    {
        DvrIopDebugOut4(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "bad input argument: min temp files = %u, max temp files = %u, max files = %u, hard max on files = %u",
                        dwMinNumberOfTempFiles, dwMaxNumberOfTempFiles,
                        dwMaxNumberOfFiles, CDVRFileCollection::m_kMaxFilesLimit);

        return E_INVALIDARG;
    }
    if (dwIndexStreamId != MAXDWORD && msIndexGranularity == 0)
    {
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "Index stream id = %u, but index granularity is 0",
                        dwIndexStreamId);

        return E_INVALIDARG;
    }
    if (dwNumSids == 0 && ppSids)
    {
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "dwNumSids = 0, but ppSids = 0x%x is non-NULL",
                        ppSids);

        return E_INVALIDARG;
    }
    if (dwNumSids > 0 && ppSids == NULL)
    {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "dwNumSids = %u, but ppSids NULL",
                            dwNumSids);

        return E_INVALIDARG;
    }

    HRESULT                 hrRet;
    CDVRRingBufferWriter*   p = NULL;
    HKEY                    hDvrIoKey = NULL;
    HKEY                    hRegistryRootKey = NULL;
    BOOL                    bCloseKeys = 1; // Close all keys that we opened (only if this fn fails)

    *ppDVRRingBufferWriter = NULL;

    __try
    {
        DWORD dwRegRet;

        if (!hRegistryRootKeyParam)
        {
            dwRegRet = ::RegCreateKeyExW(
                            g_hDefaultRegistryHive,
                            kwszRegDvrKey,       // subkey
                            0,                   // reserved
                            NULL,                // class string
                            REG_OPTION_NON_VOLATILE, // special options
                            KEY_ALL_ACCESS,      // desired security access
                            NULL,                // security attr
                            &hRegistryRootKey,   // key handle
                            NULL                 // disposition value buffer
                           );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "RegCreateKeyExW for DVR key failed, last error = 0x%x",
                                dwLastError);
               hrRet = HRESULT_FROM_WIN32(dwLastError);
               __leave;
            }
        }
        else
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), hRegistryRootKeyParam,
                                       ::GetCurrentProcess(), (LPHANDLE) &hRegistryRootKey,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "DuplicateHandle failed for DVR IO key, last error = 0x%x",
                                dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        dwRegRet = ::RegCreateKeyExW(
                        hRegistryRootKey,
                        kwszRegDvrIoWriterKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoKey,          // key handle
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "RegCreateKeyExW for DVR IO key failed, last error = 0x%x",
                            dwLastError);
           hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }


#if defined(DEBUG)
        // Until this point, we have been using default values for the debug levels
        DvrIopDbgInit(hRegistryRootKey);
#endif // DEBUG

        p = new CDVRRingBufferWriter(pPVRIOCounters,
                                     dwMinNumberOfTempFiles,
                                     dwMaxNumberOfTempFiles,
                                     dwMaxNumberOfFiles,
                                     dwGrowBy,
                                     cnsTimeExtentOfEachFile,
                                     pProfile,
                                     dwIndexStreamId,
                                     msIndexGranularity,
                                     fUnbufferedIo,
                                     dwIoSize,
                                     dwBufferCount,
                                     dwAlignment,
                                     dwFileGrowthQuantum,
                                     pfnCallback,
                                     pvContext,
                                     hRegistryRootKey,
                                     hDvrIoKey,
                                     pwszDVRDirectory,
                                     pwszRingBufferFileName,
                                     dwNumSids,
                                     ppSids,
                                     &hrRet);

        if (p == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - CDVRRingBufferWriter");
            __leave;
        }

        bCloseKeys = 0; // ~CDVRRingBufferWriter will close the keys

        if (FAILED(hrRet))
        {
            __leave;
        }


        hrRet = p->QueryInterface(IID_IDVRRingBufferWriter, (void**) ppDVRRingBufferWriter);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRRingBufferWriter failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "CDVRRingBufferWriter::QueryInterface failed, hr = 0x%x",
                            hrRet);
            __leave;
        }
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete p;

            if (bCloseKeys)
            {
                DWORD dwRegRet;

                if (hDvrIoKey)
                {
                    dwRegRet = ::RegCloseKey(hDvrIoKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hDvrIoKey failed.");
                    }
                }
                if (hRegistryRootKey)
                {
                    DVR_ASSERT(hRegistryRootKey, "");
                    dwRegRet = ::RegCloseKey(hRegistryRootKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hRegistryRootKey failed.");
                    }
                }
            }
        }
        else
        {
            DVR_ASSERT(bCloseKeys == 0, "");
        }
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // DVRCreateRingBufferWriter

// ====== Constructor, destructor

#if defined(DEBUG)
DWORD CDVRRingBufferWriter::m_dwNextClassInstanceId = 0;
#endif

LONGLONG    CDVRRingBufferWriter::kInvalidFirstSampleOffsetTime = MAXLONGLONG;

//  we allow ourselves for an extra 10 seconds' worth of indexing entries for
//    padding; internally we allocate a number of pages to hold our index
//    entries, but if the close time is not right on, it is possible to jitter
//    just a bit and wrap the entries without flushing (if we're a TEMP file)
QWORD       CDVRRingBufferWriter::kcnsIndexEntriesPadding = 10 * 1000 ; // in milliseconds

#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif

CDVRRingBufferWriter::CDVRRingBufferWriter(IN  CPVRIOCounters *             pPVRIOCounters,
                                           IN  DWORD                        dwMinNumberOfTempFiles,
                                           IN  DWORD                        dwMaxNumberOfTempFiles,
                                           IN  DWORD                        dwMaxNumberOfFiles,
                                           IN  DWORD                        dwGrowBy,
                                           IN  QWORD                        cnsTimeExtentOfEachFile,
                                           IN  IWMProfile*                  pProfile,
                                           IN  DWORD                        dwIndexStreamId,
                                           IN  DWORD                        msIndexGranularity,
                                           IN  BOOL                         fUnbufferedIo,
                                           IN  DWORD                        dwIoSize,
                                           IN  DWORD                        dwBufferCount,
                                           IN  DWORD                        dwAlignment,
                                           IN  DWORD                        dwFileGrowthQuantum,
                                           IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                                           IN  LPVOID                       pvContext,
                                           IN  HKEY                         hRegistryRootKey,
                                           IN  HKEY                         hDvrIoKey,
                                           IN  LPCWSTR                      pwszDVRDirectoryParam OPTIONAL,
                                           IN  LPCWSTR                      pwszRingBufferFileName OPTIONAL,
                                           IN  DWORD                        dwNumSids,
                                           IN  PSID*                        ppSids OPTIONAL,
                                           OUT HRESULT*                     phr)
    : m_dwMinNumberOfTempFiles(dwMinNumberOfTempFiles)
    , m_dwMaxNumberOfTempFiles(dwMaxNumberOfTempFiles)
    , m_dwMaxNumberOfFiles(dwMaxNumberOfFiles)
    , m_cnsTimeExtentOfEachFile(cnsTimeExtentOfEachFile)
    , m_pProfile(pProfile)
    , m_dwIndexStreamId(dwIndexStreamId)
    , m_msIndexGranularity(msIndexGranularity)
    , m_hRegistryRootKey(hRegistryRootKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_pwszDVRDirectory(NULL)
    , m_pwszRingBufferFileName(NULL)
    , m_cnsMaxStreamDelta(0)
    , m_nFlags(0)
    , m_cnsFirstSampleTime(0)
    , m_nNotOkToWrite(-2)
    , m_pDVRFileCollection(NULL)
    , m_FileCollectionInfo(TRUE)
    , m_nRefCount(0)
    , m_pAsyncIo(NULL)
    , m_dwIoSize (dwIoSize)
    , m_dwBufferCount (dwBufferCount)
    , m_dwAlignment (dwAlignment)
    , m_dwFileGrowthQuantum (dwFileGrowthQuantum)
    , m_pPVRIOCounters(pPVRIOCounters)
    , m_pfnCallback(pfnCallback)
    , m_pvCallbackContext(pvContext)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CDVRRingBufferWriter"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");
    DVR_ASSERT(m_pPVRIOCounters,"") ;

    m_pPVRIOCounters -> AddRef () ;

    ::InitializeCriticalSection(&m_csLock);
    m_pProfile->AddRef();
    InitializeListHead(&m_leWritersList);
    InitializeListHead(&m_leFreeList);
    InitializeListHead(&m_leRecordersList);
    InitializeListHead(&m_leActiveMultiFileRecordersList);

    __try
    {
        HRESULT hr;

        if (pwszDVRDirectoryParam && DvrIopIsBadStringPtr(pwszDVRDirectoryParam))
        {
            hrRet = E_INVALIDARG;
            __leave;
        }
        if (pwszRingBufferFileName && DvrIopIsBadStringPtr(pwszRingBufferFileName))
        {
            hrRet = E_INVALIDARG;
            __leave;
        }

#if defined(DVRIO_FABRICATE_SIDS)
        PSID    pFabricatedSid = NULL;
        DWORD   dwFabricateSids = ::GetRegDWORD(m_hDvrIoKey,
                                                kwszRegFabricateSidsValue,
                                                kdwRegFabricateSidsDefault);
        if (!ppSids && dwNumSids == 0 && dwFabricateSids)
        {
            SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

            // Create owner SID
            if (!::AllocateAndInitializeSid(&SIDAuthNT, 1,
                                            SECURITY_AUTHENTICATED_USER_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &pFabricatedSid))
            {
                DWORD dwLastError = GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "::AllocateAndInitializeSid of authenticated user SID failed; last error = 0x%x",
                                dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }

            dwNumSids = 1;
            ppSids = &pFabricatedSid;
        }
#endif // if defined(DVRIO_FABRICATE_SIDS)

        hr = m_FileCollectionInfo.SetSids(dwNumSids, ppSids, 1);

#if defined(DVRIO_FABRICATE_SIDS)
        if (pFabricatedSid)
        {
            ::FreeSid(pFabricatedSid);
        }
#endif // if defined(DVRIO_FABRICATE_SIDS)

        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "SetSids() failed, returning hr = 0x%x",
                            hrRet);
            __leave;
        }

        if (pwszDVRDirectoryParam)
        {
            // Convert the supplied argument to a fully qualified path

            WCHAR   wTempChar;
            DWORD   dwLastError;
            DWORD   nLen;
            DWORD   nLen2;

            nLen = ::GetFullPathNameW(pwszDVRDirectoryParam, 0, &wTempChar, NULL);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "First GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }

            m_pwszDVRDirectory = new WCHAR[nLen+1];
            if (m_pwszDVRDirectory == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - m_pwszDVRDirectory - WCHAR[%u]",
                                nLen+1);

                hrRet = E_OUTOFMEMORY;
                __leave;
            }

            nLen2 = ::GetFullPathNameW(pwszDVRDirectoryParam, nLen+1, m_pwszDVRDirectory, NULL);
            if (nLen2 == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Second GetFullPathNameW failed, first call returned nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
            else if (nLen2 > nLen)
            {
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Second GetFullPathNameW returned nLen = %u > first call, which returned %u",
                                nLen2, nLen);
                hrRet = E_FAIL;
                __leave;
            }
        }
        if (!m_pwszDVRDirectory)
        {
            // Directory not supplied to fn. Get it from the registry

            DWORD  dwSize;

            hr = GetRegString(m_hDvrIoKey, kwszRegDataDirectoryValue, NULL, &dwSize);

            if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                hrRet = hr;
                __leave;
            }

            if (SUCCEEDED(hr) && dwSize > sizeof(WCHAR))
            {
                // + 1 just in case dwSize is not a multiple of sizeof(WCHAR)
                m_pwszDVRDirectory = new WCHAR[dwSize/sizeof(WCHAR) + 1];

                if (!m_pwszDVRDirectory)
                {
                    hrRet = E_OUTOFMEMORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", dwSize/sizeof(WCHAR)+1);
                    __leave;
                }

                hr = GetRegString(m_hDvrIoKey, kwszRegDataDirectoryValue, m_pwszDVRDirectory, &dwSize);
                if (FAILED(hr))
                {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "GetRegString failed to get value of kwszRegDataDirectoryValue (second call).");
                    hrRet = hr;
                    __leave;
                }
            }
        }
        if (!m_pwszDVRDirectory)
        {
            // Directory not supplied to fn and not set in the registry.
            // Use the temp path

            DWORD dwRet;
            WCHAR w;

            dwRet = ::GetTempPathW(0, &w);

            if (dwRet == 0)
            {
                // GetTempPathW failed
                DVR_ASSERT(0,
                           "Temporary directory for DVR files not set in registry "
                           "and GetTempPath() failed.");

                DWORD dwLastError = ::GetLastError(); // for debugging only

                hrRet = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                __leave;
            }

            // MSDN is confusing: is the value returned by GetTempPathW in bytes or WCHAR?
            // Does it include space for NULL char at end?
            m_pwszDVRDirectory = new WCHAR[dwRet + 1];

            if (m_pwszDVRDirectory == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", dwRet + 1);

                hrRet = E_OUTOFMEMORY; // out of stack space
                __leave;
            }

            dwRet = ::GetTempPathW(dwRet + 1, m_pwszDVRDirectory);

            if (dwRet == 0)
            {
                // GetTempPathW failed
                DVR_ASSERT(0,
                           "Temporary directory for DVR files not set in registry "
                           "and GetTempPath() [second call] failed.");

                DWORD dwLastError = ::GetLastError(); // for debugging only

                hrRet = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                __leave;
            }

            // Note that m_pwszDVRDirectory includes a trailing \.
            // And we should get a fully qualified path name
            DVR_ASSERT(dwRet > 1, "");

            // Zap the trailing \.
            if (m_pwszDVRDirectory[dwRet-1] == L'\\')
            {
                m_pwszDVRDirectory[dwRet-1] = L'\0';
            }
        }

        BOOL bAllocdRingBufferFileName = 0;

        if (!pwszRingBufferFileName)
        {
            DWORD dwSize;

            hr = GetRegString(m_hDvrIoKey, kwszRegRingBufferFileNameValue, NULL, &dwSize);

            if (SUCCEEDED(hr) && dwSize > sizeof(WCHAR))
            {
                // + 1 just in case dwSize is not a multiple of sizeof(WCHAR)
                pwszRingBufferFileName = new WCHAR[dwSize/sizeof(WCHAR) + 1];

                if (!pwszRingBufferFileName)
                {
                    hrRet = E_OUTOFMEMORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", dwSize/sizeof(WCHAR)+1);
                    __leave;
                }

                hr = GetRegString(m_hDvrIoKey, kwszRegRingBufferFileNameValue, (LPWSTR) pwszRingBufferFileName, &dwSize);
                if (FAILED(hr))
                {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "GetRegString failed to get value of kwszRingBufferFileNameValue (second call).");
                    // Ignore the registry key
                    delete [] pwszRingBufferFileName;
                    pwszRingBufferFileName = NULL;
                }
                bAllocdRingBufferFileName = 1;
            }
        }

        if (pwszRingBufferFileName)
        {
            // Convert the supplied argument to a fully qualified path

            WCHAR   wTempChar;
            DWORD   dwLastError;
            DWORD   nLen;
            DWORD   nLen2;

            nLen = ::GetFullPathNameW(pwszRingBufferFileName, 0, &wTempChar, NULL);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "First GetFullPathNameW (for pwszRingBufferFileName) failed, nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }

            m_pwszRingBufferFileName = new WCHAR[nLen+1];
            if (m_pwszRingBufferFileName == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - m_pwszRingBufferFileName - WCHAR[%u]",
                                nLen+1);

                hrRet = E_OUTOFMEMORY;
                __leave;
            }

            nLen2 = ::GetFullPathNameW(pwszRingBufferFileName, nLen+1, m_pwszRingBufferFileName, NULL);
            if (nLen2 == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Second GetFullPathNameW (for pwszRingBufferFileName) failed, first call returned nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
            else if (nLen2 > nLen)
            {
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Second GetFullPathNameW (for pwszRingBufferFileName) returned nLen = %u > first call, which returned %u",
                                nLen2, nLen);
                hrRet = E_FAIL;
                __leave;
            }
        }

        if (bAllocdRingBufferFileName)
        {
            delete [] pwszRingBufferFileName;
            pwszRingBufferFileName = NULL;
            ::DeleteFileW(m_pwszRingBufferFileName);
        }

        // We add 1 to the number of temporary files provided to us since
        // we create a priming file, which is empty.
        m_pDVRFileCollection = new CDVRFileCollection(&m_FileCollectionInfo,
                                                      m_dwMinNumberOfTempFiles + 1,
                                                      m_dwMaxNumberOfTempFiles + 1,
                                                      m_dwMaxNumberOfFiles + 1,
                                                      dwGrowBy,
                                                      FALSE,                    // bStartTimeFixedAtZero
                                                      m_msIndexGranularity,
                                                      m_pwszDVRDirectory,
                                                      m_pwszRingBufferFileName,
                                                      FALSE,                    // not a multi-file recording
                                                      &hr);
        if (!m_pDVRFileCollection)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - CDVRFileCollection");
            __leave;
        }

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (fUnbufferedIo) {
            m_pAsyncIo = new CAsyncIo () ;
            if (!m_pAsyncIo) {
                hrRet = E_OUTOFMEMORY ;
                __leave ;
            }

            //  our ref
            m_pAsyncIo -> AddRef () ;
        }

        // Get 1 file ready for writing. Since we don't know the
        // starting time yet, set the time extent of the file to
        // (0, m_cnsTimeExtentOfEachFile)
        hr = AddATemporaryFile(0, m_cnsTimeExtentOfEachFile);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DWORD dwIncreasingTimeStamps = 1;

#if defined(DVR_UNOFFICIAL_BUILD)

        dwIncreasingTimeStamps = ::GetRegDWORD(m_hDvrIoKey,
                                               kwszRegEnforceIncreasingTimestampsValue,
                                               kdwRegEnforceIncreasingTimestampsDefault);

#endif // defined(DVR_UNOFFICIAL_BUILD)

        if (dwIncreasingTimeStamps)
        {
            SetFlags(EnforceIncreasingTimeStamps);
        }

        // Ensure that the open succeeded. No point deferring this to the first
    // WriteSample

        LIST_ENTRY* pCurrent = NEXT_LIST_NODE(&m_leWritersList);
        DVR_ASSERT(pCurrent != &m_leWritersList, "");

        PASF_WRITER_NODE pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

        DWORD nRet = ::WaitForSingleObject(pWriterNode->hReadyToWriteTo, INFINITE);
        if (nRet == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x",
                            pWriterNode->hReadyToWriteTo, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
           __leave;
        }

        if (pWriterNode->pWMWriter == NULL)
        {
            DVR_ASSERT(pWriterNode->pWMWriter != NULL, "");
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Writer node's pWMWriter is NULL?!");
            hrRet = E_FAIL;
            __leave;
        }

        // Verify there was no error in opening the file, i.e., BeginWriting
        // succeeded
        if (FAILED(pWriterNode->hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Writer node's hrRet indicates failure, hrRet = 0x%x",
                            pWriterNode->hrRet);
            hrRet = pWriterNode->hrRet;
            __leave;
        }

        //  success
        hrRet = S_OK ;
    }
    __finally
    {
        if (phr)
        {
            *phr = hrRet;
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRRingBufferWriter::CDVRRingBufferWriter

CDVRRingBufferWriter::~CDVRRingBufferWriter()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::~CDVRRingBufferWriter"

    DVRIO_TRACE_ENTER();

    // Since each recorder holds a ref count on this object, this
    // will be called only when all recorders have been destroyed.

    if (!IsFlagSet(WriterClosed))
    {
        HRESULT hr;

        hr = Close();

        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "Object had not been closed; Close() returned hr = 0x%x",
                        hr);
    }

    if (m_pAsyncIo) {
        //  our ref
        m_pAsyncIo -> Release () ;
    }

    // All multi file recordings have been closed before this. The recordings hold
    // a ref count on this object, so this object cannot be destroyed if a
    // multi file object hasn't been released. When the multi file recording
    // is destroyed, it stops/cancels/deletes the recording

    if (m_pDVRFileCollection)
    {
        m_pDVRFileCollection->Release(&m_FileCollectionInfo);
        m_pDVRFileCollection = NULL;

        // Note that files (recordings or temp files) could have been added
        // to the file collection object beyond the last stream time.
        // They have all been closed and so are 0 length. This is a good
        // thing for recordings (permanent files). The reader will not be
        // able to seek to these files (since the lsat stream time
        // < the file's start time)

    }

    // Delete writer nodes corresponding to recordings that
    // were never started. See the comment in Close().
    LIST_ENTRY* pCurrent = NEXT_LIST_NODE(&m_leFreeList);
    while (pCurrent != &m_leFreeList)
    {
        PASF_WRITER_NODE pFreeNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

        DVR_ASSERT(pFreeNode->hFileClosed, "");

        // Ignore the returned status
        ::WaitForSingleObject(pFreeNode->hFileClosed, INFINITE);
        DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");
        RemoveEntryList(pCurrent);
        delete pFreeNode;
        pCurrent = NEXT_LIST_NODE(&m_leFreeList);
    }

    delete [] m_pwszDVRDirectory;
    delete [] m_pwszRingBufferFileName;

    DVR_ASSERT(m_hRegistryRootKey, "");

    DWORD dwRegRet = ::RegCloseKey(m_hRegistryRootKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hRegistryRootKey failed.");
    }

    DVR_ASSERT(m_hDvrIoKey, "");

    dwRegRet = ::RegCloseKey(m_hDvrIoKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hDvrIoKey failed.");
    }

    m_pPVRIOCounters -> Release () ;

    // Close should have cleaned up all this:
    DVR_ASSERT(m_pProfile == NULL, "");

    // Note: Close should not release the file collection
    // if we support post-recording. We should do that
    // here.
    DVR_ASSERT(m_pDVRFileCollection == NULL, "");
    DVR_ASSERT(IsListEmpty(&m_leRecordersList), "");
    DVR_ASSERT(IsListEmpty(&m_leActiveMultiFileRecordersList), "");
    DVR_ASSERT(IsListEmpty(&m_leWritersList), "");
    DVR_ASSERT(IsListEmpty(&m_leFreeList), "");

    ::DeleteCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE0();

} // CDVRRingBufferWriter::~CDVRRingBufferWriter()


// ====== Helper methods

// static
DWORD WINAPI CDVRRingBufferWriter::ProcessOpenRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::ProcessOpenRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be removed from m_leWritersList till hReadyToWriteTo is set
    // and Close() will not delete the node without removing it from the
    // writer's list (and waiting for the file to be closed)

    PASF_WRITER_NODE pWriterNode = (PASF_WRITER_NODE) p;

    DVR_ASSERT(pWriterNode, "");
    DVR_ASSERT(pWriterNode->pWMWriter, "");
    DVR_ASSERT(pWriterNode->hReadyToWriteTo, "");
    DVR_ASSERT(::WaitForSingleObject(pWriterNode->hReadyToWriteTo, 0) == WAIT_TIMEOUT, "");

    IWMWriterFileSink*      pWMWriterFileSink = NULL;

    __try
    {
        hrRet = pWriterNode->pDVRFileSink->QueryInterface(IID_IWMWriterFileSink, (LPVOID*) &pWMWriterFileSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWriterNode->pDVRFileSink->QueryInterface for IID_IWMWriterFileSink failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        LPCWSTR pwszFileName = pWriterNode->pwszFileName;

        if (pwszFileName == NULL)
        {
            DVR_ASSERT(pWriterNode->pRecorderNode, "");
            pwszFileName = pWriterNode->pRecorderNode->pwszFileName;
        }

        DVR_ASSERT(pwszFileName, "");

        hrRet = pWMWriterFileSink->Open(pwszFileName);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWriterNode->pDVRFileSink->Open failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

#if defined(DVR_UNOFFICIAL_BUILD)

        DVR_ASSERT(pWriterNode->cnsLastStreamTime == 0, "");

        DVR_ASSERT(pWriterNode->hVal == NULL, "");

        DWORD dwCreateValidationFiles = ::GetRegDWORD(pWriterNode->hDvrIoKey,
                                                      kwszRegCreateValidationFilesValue,
                                                      kdwRegCreateValidationFilesDefault);

        if (dwCreateValidationFiles)
        {
            WCHAR* pwszBuf = NULL;
            __try
            {
                pwszBuf = new WCHAR[wcslen(pwszFileName) + 5];
                if (pwszBuf == NULL)
                {
                    DVR_ASSERT(pwszBuf != NULL, "New() failed");
                    __leave;
                }
                wcscpy(pwszBuf, pwszFileName);

                wcscat(pwszBuf, L".val");

                pWriterNode->hVal = ::CreateFileW(pwszBuf,
                                                  GENERIC_WRITE, FILE_SHARE_READ,
                                                  NULL, CREATE_ALWAYS,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  NULL);
                if (pWriterNode->hVal == INVALID_HANDLE_VALUE)
                {
                    DWORD dwLastError = ::GetLastError();   // for debugging only

                    DVR_ASSERT(0, "CreateFile of the validation file failed");

                    pWriterNode->hVal = NULL;
                    __leave;
                }
            }
            __finally
            {
                delete [] pwszBuf;
            }
        }

#endif // if defined(DVR_UNOFFICIAL_BUILD)

        //  only call BeginWriting if we're not a content recording
        if (!pWriterNode -> IsFlagSet (ASF_WRITER_NODE::WriterNodeContentRecording)) {
            hrRet = pWriterNode->pWMWriter->BeginWriting();
            if (FAILED(hrRet))
            {
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "BeginWriting failed; hr = 0x%x for file id %u",
                                hrRet, pWriterNode->nFileId);
                __leave;
            }

            DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                            "BeginWriting hr = 0x%x for file %u",
                            hrRet, pWriterNode->nFileId);
        }
        else {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                            "BeginWriting not called in ::ProcessOpenRequest for content recording %s",
                            pwszFileName);
        }
    }
    __finally
    {
        // Do NOT change pWriterNode->hrRet after this till ProcessCloseRequest.
        // ProcessCloseRequest relies on seeing the value returned by BeginWriting
        // The exception is for content recordings. For content recordings,
        // BeginWriting is called in StartRecording and pWriterNode->hrRet
        // and pWriterNode->pRecorderNode->hrRet are both set there,
        pWriterNode->hrRet = hrRet;
        if (pWriterNode->pRecorderNode)
        {
            // Set the status on the associated recorder node
            pWriterNode->pRecorderNode->hrRet = hrRet;
        }

        delete [] pWriterNode->pwszFileName;
        pWriterNode->pwszFileName = NULL;

        if (pWMWriterFileSink)
        {
            pWMWriterFileSink->Release();
        }

        ::SetEvent(pWriterNode->hReadyToWriteTo);
    }

    // It's unsafe to reference pWriterNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRRingBufferWriter::ProcessOpenRequest

// Note that we pass in the SIDs to this function rather than use
// the values in m_FileCollectionInfo within the function. This
// function is used by multi-file recordings and the "live" (TV tuner)
// ring buffer. The SIDs could potentially be differnt. Similarly, we
// may want to be able to specify xdifferent SIDs for single file
// recordings in the future.
HRESULT CDVRRingBufferWriter::PrepareAFreeWriterNode(
    IN LPCWSTR                              pwszFileName, // delete[]'d if supplied. Set to NULL if pRecorderNode->pwszFileName is the file to be used
    IN DWORD                                dwNumSids,
    IN PSID*                                ppSids,
    IN DWORD                                dwDeleteTemporaryFiles,
    IN QWORD                                cnsStartTime,
    IN QWORD                                cnsEndTime,
    IN CDVRFileCollection::DVRIOP_FILE_ID   nFileId,
    IN PASF_RECORDER_NODE                   pRecorderNode,
    OUT LIST_ENTRY*&                        rpFreeNode)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::PrepareAFreeWriterNode"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    LIST_ENTRY*             pCurrent = &m_leFreeList;
    BOOL                    bRestore = 0;
    BOOL                    bRemoveSink = 0;
    BOOL                    bQueued = 0;
    PASF_WRITER_NODE        pFreeNode;
    IWMWriterSink*          pWMWriterSink = NULL;
    DWORD                   dwMaxIndexEntries ;
    DWORD                   dwNumPages ;
    IWMRegisterCallback *   pIWMRegisterCallback = NULL ;

    __try
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        while (pCurrent != &m_leFreeList)
        {
            pFreeNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);
            DVR_ASSERT(pFreeNode->hFileClosed, "");
            if (::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0)
            {
                if (pFreeNode->pRecorderNode != NULL)
                {
                    // This should not happen. Ignore this node and go on
                    DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");
                }
                else
                {
                    // Verify that the hReadyToWriteTo event is reset
                    DWORD nRet = ::WaitForSingleObject(pFreeNode->hReadyToWriteTo, 0);
                    if (nRet == WAIT_TIMEOUT)
                    {
                        break;
                    }

                    DVR_ASSERT(nRet != WAIT_OBJECT_0, "Free list node's hReadyToWriteTo is set?");
                    if (nRet == WAIT_OBJECT_0)
                    {
                        // This shouldn't happen; ignore the node and go on.
                        // Debug version will assert each time it hits this
                        // node!
                    }
                    else
                    {
                        // This shouldn't happen either. Ignore this node and
                        // move on.
                        DWORD dwLastError = ::GetLastError();
                        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                        "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x",
                                        pFreeNode->hReadyToWriteTo, dwLastError);
                    }
                }
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }
        if (pCurrent == &m_leFreeList)
        {
            // Create a new node

            pFreeNode = new ASF_WRITER_NODE(&hrRet);

            if (pFreeNode == NULL)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - ASF_WRITER_NODE");
                pCurrent = NULL;
                __leave;
            }
            else if (FAILED(hrRet))
            {
                delete pFreeNode;
                pFreeNode = NULL;
                pCurrent = NULL;
                __leave;
            }
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0, "");
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hReadyToWriteTo, 0) == WAIT_TIMEOUT, "");

            InsertHeadList(&m_leFreeList, &pFreeNode->leListEntry);
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
            DVR_ASSERT(pCurrent == &pFreeNode->leListEntry, "");

#if defined(DVR_UNOFFICIAL_BUILD)
            pFreeNode->hDvrIoKey = m_hDvrIoKey;
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        }
        DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");

        DVR_ASSERT(pCurrent != &m_leFreeList, "");

        // Create an ASF writer object if needed
        if (!pFreeNode->pWMWriter)
        {
            IWMWriter* pWMWriter;

            hrRet = ::WMCreateWriter(NULL, &pWMWriter);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "WMCreateWriter failed; hr = 0x%x",
                                hrRet);
                __leave;
            }
            pFreeNode->pWMWriter = pWMWriter; // Released only in Close()
        }

        if (!pFreeNode->pWMWriterAdvanced)
        {
            IWMWriterAdvanced3*  pWMWriterAdvanced;

            hrRet = pFreeNode->pWMWriter->QueryInterface(IID_IWMWriterAdvanced3, (LPVOID*) &pWMWriterAdvanced);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pFreeNode->pWMWriter->QueryInterface for IID_IWMWriterAdvanced failed; hr = 0x%x",
                                hrRet);
                __leave;
            }
            pFreeNode->pWMWriterAdvanced = pWMWriterAdvanced; // Released only in Close()

            // Enough to do this once even if the writer object is reused
            // (at least as currently implemented in the SDK). There is no
            // way to undo this.
            //
            // Ignore errors (currently does not fail)
            pFreeNode->pWMWriterAdvanced->SetNonBlocking();
        }

        if (!pFreeNode->pIWMHeaderInfo)
        {
            IWMHeaderInfo * pIWMHeaderInfo ;

            DVR_ASSERT(pFreeNode->pWMWriter, "") ;
            hrRet = pFreeNode->pWMWriter->QueryInterface(IID_IWMHeaderInfo, (LPVOID*) &pIWMHeaderInfo);

            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pFreeNode->pWMWriter->QueryInterface for IID_IWMHeaderInfo failed; hr = 0x%x",
                                hrRet);
                __leave;
            }

            pFreeNode->pIWMHeaderInfo = pIWMHeaderInfo ;
        }

        //  if we're a recording, set the content/reference flag correctly
        if (pRecorderNode) {
            //  set the flag on the ASF_WRITER_NODE if we're a content recording
            if (!pRecorderNode -> pMultiFileRecorder) {
                pFreeNode -> SetFlags (ASF_WRITER_NODE::WriterNodeContentRecording) ;
            }
            else {
                pFreeNode -> ClearFlags (ASF_WRITER_NODE::WriterNodeContentRecording) ;
            }
        }
        else {
            //  not a recording; clear it explicitely in case we've been recycled
            pFreeNode -> ClearFlags (ASF_WRITER_NODE::WriterNodeContentRecording) ;
        }

        // Create and initialize the DVR file sink

        DVR_ASSERT(pFreeNode->pDVRFileSink == NULL, "");

        hrRet = DVRCreateDVRFileSink(m_hRegistryRootKey, m_hDvrIoKey, dwNumSids, ppSids, &pFreeNode->pDVRFileSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "DVRCreateDVRFileSink failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        //  if our IO is asynchronous set it up now
        if (m_pAsyncIo) {

            IDVRFileSink2 * pIDVRFileSink2 ;

            hrRet = pFreeNode -> pDVRFileSink -> QueryInterface (IID_IDVRFileSink2, (void **) & pIDVRFileSink2) ;

            if (SUCCEEDED (hrRet)) {

                CPVRAsyncWriterCOM *    pPVRAsyncWriterCOM ;
                DWORD                   dwRet ;

                ASSERT (m_pAsyncIo) ;

                pPVRAsyncWriterCOM = new CPVRAsyncWriterCOM (
                                            m_dwIoSize,
                                            m_dwBufferCount,
                                            m_dwAlignment,
                                            m_dwFileGrowthQuantum,
                                            m_pAsyncIo,
                                            m_pPVRIOCounters,
                                            dwNumSids,
                                            ppSids,
                                            & dwRet
                                            ) ;

                if (!pPVRAsyncWriterCOM) {
                    pIDVRFileSink2 -> Release () ;
                    hrRet = E_OUTOFMEMORY ;
                    __leave ;
                }
                else if (dwRet != NOERROR) {
                    pIDVRFileSink2 -> Release () ;
                    hrRet = HRESULT_FROM_WIN32 (dwRet) ;
                    delete pPVRAsyncWriterCOM ;
                    __leave ;
                }

                pPVRAsyncWriterCOM -> AddRef () ;

                hrRet = pIDVRFileSink2 -> SetAsyncIOWriter (pPVRAsyncWriterCOM) ;

                pPVRAsyncWriterCOM -> Release () ;
                pIDVRFileSink2 -> Release () ;

                if (FAILED (hrRet)) {
                    __leave ;
                }
            }
            else {
                DVR_ASSERT(0, "failed to QI for IDVRFileSink2");
                __leave ;
            }
        }

        //  register for callback notifications

        hrRet = pFreeNode -> pDVRFileSink -> QueryInterface (
                        IID_IWMRegisterCallback,
                        (void **) & pIWMRegisterCallback
                        ) ;
        if (FAILED (hrRet)) {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pFreeNode -> pDVRFileSink -> QueryInterface for IID_IWMRegisterCallback failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        //  register for advise notifications
        hrRet = pIWMRegisterCallback -> Advise (
                    static_cast <IWMStatusCallback *> (this),
                    0
                    ) ;
        if (FAILED (hrRet)) {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "failed to register for error notification failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        // Note that if pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording)
        // we do not use dwDeleteTemporaryFiles. This is as it should be; we want to
        // ignore dwDeleteTemporaryFiles if the flag is set.
        if (pRecorderNode == NULL && dwDeleteTemporaryFiles == 0)
        {
            DWORD dwLastError;
            DWORD dwAttr = ::GetFileAttributesW(pwszFileName);

            if (dwAttr == (DWORD) -1)
            {
                dwLastError = ::GetLastError();

                if (dwLastError == ERROR_FILE_NOT_FOUND)
                {
                    // Go on; the file will be created
                }
                else
                {
                    DVR_ASSERT(0, "GetFileAttributes failed; temp file will be deleted when it is closed");

                    // Change dwDeleteTemporaryFiles back to 1 and go on.
                    // If it is not changed to 1, opening the file will fail

                    dwDeleteTemporaryFiles = 1;
                }
            }
            else
            {
                dwAttr &= ~(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);

                DWORD dwRet = ::SetFileAttributesW(pwszFileName, dwAttr);
                if (dwRet == 0)
                {
                    dwLastError = ::GetLastError(); // for debugging only

                    DVR_ASSERT(0, "SetFileAttributes failed; temp file will be deleted when it is closed");

                    // Change dwDeleteTemporaryFiles back to 1 and go on.
                    // If it is not changed to 1, opening the file will fail

                    dwDeleteTemporaryFiles = 1;
                }

            }
        }

        BOOL bMarkFileTemporary;

        if (pRecorderNode && pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
        {
            // Ignore dwDeleteTemporaryFiles in this case
            bMarkFileTemporary = 1;
        }
        else if (pRecorderNode == NULL && dwDeleteTemporaryFiles)
        {
            bMarkFileTemporary = 1;
        }
        else
        {
            bMarkFileTemporary = 0;
        }

        hrRet = pFreeNode->pDVRFileSink->MarkFileTemporary(bMarkFileTemporary);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pFreeNode->pDVRFileSink->MarkFileTemporary failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        if (m_dwIndexStreamId != MAXDWORD)
        {
            hrRet = pFreeNode->pDVRFileSink->SetIndexStreamId(m_dwIndexStreamId, m_msIndexGranularity);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "pFreeNode->pDVRFileSink->SetIndexStreamId failed; hr = 0x%x",
                                hrRet);
                __leave;
            }

            if (bMarkFileTemporary)
            {
                //  compute the max entries for each file; we're ok on the corner
                //    case here because the last index entry references the
                //    remainder of the file i.e. there isn't an index entry to
                //    mark the end of the file -- the last index entry is used
                //    for the last of the file
                dwMaxIndexEntries = (DWORD) ((m_cnsTimeExtentOfEachFile / 10000) + kcnsIndexEntriesPadding) / m_msIndexGranularity ;
                DVR_ASSERT(dwMaxIndexEntries > 0, "dwMaxIndexEntries has 0 entries");

                //  retrieve the number of pages required
                hrRet = pFreeNode->pDVRFileSink->GetNumPages (dwMaxIndexEntries, & dwNumPages) ;
                if (FAILED(hrRet))
                {
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "pFreeNode->pDVRFileSink->GetNumPages failed; hr = 0x%x",
                                    hrRet);
                    __leave;
                }

                //  set the number pages required
                hrRet = pFreeNode->pDVRFileSink->SetNumSharedDataPages(dwNumPages) ;
                if (FAILED(hrRet))
                {
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "pFreeNode->pDVRFileSink->SetNumSharedDataPages failed; hr = 0x%x",
                                    hrRet);
                    __leave;
                }
            }
        }

        // Add the DVR file sink to the WM writer

        hrRet = pFreeNode->pDVRFileSink->QueryInterface(IID_IWMWriterSink, (LPVOID*) &pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pFreeNode->pDVRFileSink->QueryInterface for IID_IWMWriterSink failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        DVR_ASSERT(pFreeNode->pWMWriterAdvanced, "");

        hrRet = pFreeNode->pWMWriterAdvanced->AddSink(pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pFreeNode->pWMWriterAdvanced->AddSink failed; hr = 0x%x",
                            hrRet);
            __leave;
        }
        bRemoveSink = 1;

        // Set the profile on the writer. This destroys the
        // existing ASF mux and creates a new one.
        //
        // On failure, this action does not have to be undone.
        // Clean up will be done when SetProfile is next called
        // or when EndWriting is called.
        //
        // Sending NULL in the argument to undo this action
        // immediately is rejected with an E_POINTER return
        hrRet = pFreeNode->pWMWriter->SetProfile(m_pProfile);

        if (FAILED(hrRet))
        {
            DVR_ASSERT(SUCCEEDED(hrRet), "SetProfile failed");
            __leave;
        }

        // Tell the writer that we are providing compressed streams.
        // It's enough to set the input props to NULL for this.
        DWORD dwNumInputs;

        hrRet = pFreeNode->pWMWriter->GetInputCount(&dwNumInputs);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(SUCCEEDED(hrRet), "GetInputCount failed");
            __leave;
        }

        for (; dwNumInputs > 0;)
        {
            dwNumInputs--;
            hrRet = pFreeNode->pWMWriter->SetInputProps(dwNumInputs, NULL);
            if (FAILED(hrRet))
            {
                DVR_ASSERT(SUCCEEDED(hrRet), "SetInputProps failed");
                __leave;
            }
        }

        DWORD dwSyncTolerance = ::GetRegDWORD(m_hRegistryRootKey,
                                              kwszRegSyncToleranceValue,
                                              kdwRegSyncToleranceDefault);

        hrRet = pFreeNode->pWMWriterAdvanced->SetSyncTolerance(dwSyncTolerance);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pFreeNode->pWMWriterAdvanced->SetSyncTolerance failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        // Set the index granularity attribute

        DWORD msIndexGranularity = m_msIndexGranularity;

        DVR_ASSERT(pFreeNode->pIWMHeaderInfo, "") ;

        hrRet = pFreeNode->pIWMHeaderInfo->SetAttribute(0 /* wStreamNum */, g_kwszDVRIndexGranularity, WMT_TYPE_DWORD,
                                            (BYTE*) &msIndexGranularity, sizeof(msIndexGranularity));

        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWMHeaderInfo->SetAttribute on index granularity failed, hr = 0x%x",
                            hrRet);
            __leave;
        }

        hrRet = pFreeNode->pIWMHeaderInfo->SetAttribute(0 /* wStreamNum */, g_kwszDVRFileVersion, WMT_TYPE_BINARY,
                                            (BYTE*) &CDVRFileCollection::m_guidV5,
                                            sizeof(CDVRFileCollection::m_guidV5));

        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWMHeaderInfo->SetAttribute on file version failed, hr = 0x%x",
                            hrRet);
            __leave;
        }

        if (pRecorderNode &&
            !pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording)
           )
        {
            //  transfer attributes to the ASF file proper
        }

        pFreeNode->cnsStartTime = cnsStartTime;
        pFreeNode->cnsEndTime = cnsEndTime;
        pFreeNode->nFileId = nFileId;
        pFreeNode->hrRet = S_OK;

        DVR_ASSERT(pFreeNode->pwszFileName == NULL, "");

        if (pRecorderNode == NULL ||
            pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording)
           )
        {
            pFreeNode->pwszFileName = pwszFileName;
        }
        else
        {
            // pRecorderNode->pwszFileName is used
        }
        pwszFileName = NULL; // Not used after this; make sure we don't delete it

        pFreeNode->SetRecorderNode(pRecorderNode);
        ::ResetEvent(pFreeNode->hFileClosed);
        bRestore = 1;

        // Issue the call to BeginWriting
        if (::QueueUserWorkItem(ProcessOpenRequest, pFreeNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "QueueUserWorkItem failed; last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        // Note: If any step can fail after this, we have to be sure
        // to put this node back into the free list, close the file, etc
        // The finally clause does not handle failure after this.
        bQueued = 1;
        RemoveEntryList(pCurrent);
        NULL_LIST_NODE_POINTERS(pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            DVR_ASSERT(!bQueued, "Update finally clause to clean up if bQueued = 1");

            rpFreeNode = NULL;
            if (bRestore && !bQueued)
            {
                pFreeNode->cnsStartTime = 0;
                pFreeNode->cnsEndTime = 0;
                pFreeNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
                pFreeNode->SetRecorderNode(NULL);
                delete [] pFreeNode->pwszFileName;
                pFreeNode->pwszFileName = NULL;
                ::SetEvent(pFreeNode->hFileClosed);
            }

            if (bRemoveSink && !bQueued)
            {
                HRESULT hr;

                DVR_ASSERT(pFreeNode->pWMWriterAdvanced, "");
                DVR_ASSERT(pWMWriterSink, "");
                hr = pFreeNode->pWMWriterAdvanced->RemoveSink(pWMWriterSink);
                DVR_ASSERT(SUCCEEDED(hr), "pFreeNode->pWMWriterAdvanced->RemoveSink failed");
            }
            if (!bQueued && pFreeNode && pFreeNode->pDVRFileSink)
            {
                pFreeNode->pDVRFileSink->Release();
                pFreeNode->pDVRFileSink = NULL;
            }

            delete [] pwszFileName;

            // SetProfile cannot be undone; see comment above.
        }
        else
        {
            rpFreeNode = pCurrent;
        }
        if (pWMWriterSink)
        {
            pWMWriterSink->Release();
        }

        if (pIWMRegisterCallback) {
            pIWMRegisterCallback -> Release () ;
        }

        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::PrepareAFreeWriterNode


HRESULT CDVRRingBufferWriter::AddToWritersList(IN LIST_ENTRY*   pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddToWritersList"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    __try
    {
        // Insert into m_leWritersList

        BOOL                bFound = 0;
        LIST_ENTRY*         pTmp = &m_leWritersList;
        PASF_WRITER_NODE    pWriterNode;
        QWORD               cnsStartTime;
        QWORD               cnsEndTime;

        pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

        cnsStartTime = pWriterNode->cnsStartTime;
        cnsEndTime = pWriterNode->cnsEndTime;

        while (NEXT_LIST_NODE(pTmp) != &m_leWritersList)
        {
            pTmp = NEXT_LIST_NODE(pTmp);
            pWriterNode = CONTAINING_RECORD(pTmp, ASF_WRITER_NODE, leListEntry);
            if (cnsEndTime <= pWriterNode->cnsStartTime)
            {
                // All ok; we should insert before pTmp
                bFound = 1;
                break;
            }
            if (cnsStartTime >= pWriterNode->cnsEndTime)
            {
                // Keep going on
                continue;
            }
            // Trouble
            DVR_ASSERT(cnsStartTime < pWriterNode->cnsEndTime && cnsEndTime > pWriterNode->cnsStartTime,
                       "Overlapped insert assertion failure?!");
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Overlapped insert! Input params: start time: %I64u, end time: %I64u\n"
                            "overlap node values: start time: %I64u, end time: %I64u",
                            cnsStartTime, cnsEndTime, pWriterNode->cnsStartTime, pWriterNode->cnsEndTime);
            hrRet = E_FAIL;
            __leave;
        }

        if (!bFound)
        {
            // We insert at tail
            pTmp = NEXT_LIST_NODE(pTmp);;
            DVR_ASSERT(pTmp == &m_leWritersList, "");
        }
        InsertTailList(pTmp, pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up necessary
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::AddToWritersList

HRESULT CDVRRingBufferWriter::AddATemporaryFile(IN QWORD   cnsStartTime,
                                                IN QWORD   cnsEndTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddATemporaryFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    BOOL                bRemoveRingBufferFile = 0;
    BOOL                bCloseFile = 0;
    LIST_ENTRY*         pCurrent;
    CDVRFileCollection::DVRIOP_FILE_ID nFileId;
    BOOL                bAdded = 0;

    __try
    {
        HRESULT hr;

        // Call the ring buffer to add a file
        LPWSTR  pwszFile = NULL;

        if (!IsFlagSet(FirstTempFileCreated))
        {
            DWORD       dwSize = 0;

            hr = GetRegString(m_hDvrIoKey, kwszRegFirstTemporaryBackingFileNameValue, NULL, &dwSize);

            SetFlags(FirstTempFileCreated);

            if (SUCCEEDED(hr) && dwSize > sizeof(WCHAR))
            {
                // + 1 just in case dwSize is not a multiple of sizeof(WCHAR)
                pwszFile = new WCHAR[dwSize/sizeof(WCHAR) + 1];

                if (!pwszFile)
                {
                    hrRet = E_OUTOFMEMORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", dwSize/sizeof(WCHAR)+1);
                    __leave;
                }

                hr = GetRegString(m_hDvrIoKey, kwszRegFirstTemporaryBackingFileNameValue, pwszFile, &dwSize);
                if (FAILED(hr))
                {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "GetRegString failed to get value of kwszFirstTemporaryBackingFileNameValue (second call).");
                    // Ignore the registry key
                    delete [] pwszFile;
                    pwszFile = NULL;
                }
            }
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        DWORD dwDeleteTemporaryFiles = ::GetRegDWORD(m_hDvrIoKey,
                                                     kwszRegDeleteRingBufferFilesValue,
                                                     kdwRegDeleteRingBufferFilesDefault);

        hr = m_pDVRFileCollection->AddFile(&m_FileCollectionInfo,
                                           &pwszFile,
                                           0,                   // bOpenFromFileCollectionDirectory
                                           cnsStartTime,
                                           cnsEndTime,
                                           FALSE,                // bPermanentFile,
                                           dwDeleteTemporaryFiles,
                                           kInvalidFirstSampleOffsetTime,
                                           &nFileId);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(hr != S_FALSE, "Temp file added is not in ring buffer extent?!");
        DVR_ASSERT(nFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");

        bRemoveRingBufferFile = 1;

        hr = PrepareAFreeWriterNode(pwszFile, m_FileCollectionInfo.dwNumSids, m_FileCollectionInfo.ppSids,
                                    dwDeleteTemporaryFiles, cnsStartTime, cnsEndTime, nFileId, NULL, pCurrent);

        // We don't need this any more. AddFile allocated it. It has been saved away in pCurrent
        // which will delete it. If PrepareAFreeWriterNode() failed, this may already have been
        // deleted.
        pwszFile = NULL;

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(pCurrent != NULL, "");

        // If any step after this fails, we have to call CloseWriterFile
        bCloseFile = 1;

        // Insert into m_leWritersList

        hr = AddToWritersList(pCurrent);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        bAdded = 1;
    hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            if (bAdded)
            {
                RemoveEntryList(pCurrent);
                NULL_LIST_NODE_POINTERS(pCurrent);
            }
            if (bCloseFile)
            {
                HRESULT hr;

                hr = CloseWriterFile(pCurrent);

                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
            }

            if (bRemoveRingBufferFile)
            {
                // Set the end time to the start time to invalidate the file
                // in the file collection
                CDVRFileCollection::DVRIOP_FILE_TIME ft = {nFileId, cnsStartTime, cnsStartTime};
                HRESULT hr;

                hr = m_pDVRFileCollection->SetFileTimes(&m_FileCollectionInfo, 1, &ft);

                // A returned value of S_FALSE is ok. If this fails,
                // just ignore the error
                DVR_ASSERT(SUCCEEDED(hr), "");
            }
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::AddATemporaryFile

// static
DWORD WINAPI CDVRRingBufferWriter::ProcessCloseRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::ProcessCloseRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be deleted till Close() is called and Close() waits for
    // hFileClosed to be set.

    PASF_WRITER_NODE pWriterNode = (PASF_WRITER_NODE) p;

    DVR_ASSERT(pWriterNode, "");
    DVR_ASSERT(pWriterNode->pWMWriter, "");
    DVR_ASSERT(pWriterNode->hReadyToWriteTo, "");
    DVR_ASSERT(::WaitForSingleObject(pWriterNode->hFileClosed, 0) == WAIT_TIMEOUT, "");

    if (FAILED(pWriterNode->hrRet))
    {
        // BeginWriting failed, don't close the file
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                        "BeginWriting() failed on file id %u, hr = 0x%x; not closing it, "
                        "but moving it to free list",
                        pWriterNode->nFileId, pWriterNode->hrRet);
        hrRet = pWriterNode->hrRet;
    }
    else
    {
        if (pWriterNode->pIWMHeaderInfo) {
            pWriterNode->pIWMHeaderInfo->Release () ;
            pWriterNode->pIWMHeaderInfo = NULL ;
        }

        hrRet = pWriterNode->hrRet = pWriterNode->pWMWriter->EndWriting();
        if (FAILED(hrRet))
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "EndWriting failed; hr = 0x%x for file id %u",
                            hrRet, pWriterNode->nFileId);
        }

        DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                        "EndWriting hr = 0x%x for file %u",
                        hrRet, pWriterNode->nFileId);
    }

    // The sink's Open call does not have to be explicitly undone. Calling
    // EndWriting as well as the last call to the sink's Release close the
    // sink.

    // Remove the DVR file sink and release it

    DVR_ASSERT(pWriterNode->pDVRFileSink, "");

    IWMWriterSink*          pWMWriterSink = NULL;

    __try
    {
        hrRet = pWriterNode->pDVRFileSink->QueryInterface(IID_IWMWriterSink, (LPVOID*) &pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWriterNode->pDVRFileSink->QueryInterface for IID_IWMWriterSink failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        hrRet = pWriterNode->pWMWriterAdvanced->RemoveSink(pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWriterNode->pWMWriterAdvanced->RemoveSink failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

#if defined(DVR_UNOFFICIAL_BUILD)

        if (pWriterNode->hVal)
        {
            ::CloseHandle(pWriterNode->hVal);
            pWriterNode->hVal = NULL;
        }
        pWriterNode->cnsLastStreamTime = 0;

#endif // if defined(DVR_UNOFFICIAL_BUILD)


    }
    __finally
    {
        if (pWMWriterSink)
        {
            pWMWriterSink->Release();
        }

        // The next release should destroy the DVR file sink
        pWriterNode->pDVRFileSink->Release();
        pWriterNode->pDVRFileSink = NULL;

        if (FAILED(hrRet))
        {
            // Don't reuse the pWMWriter
            pWriterNode->pWMWriter->Release();
            pWriterNode->pWMWriter = NULL;
            pWriterNode->pWMWriterAdvanced->Release();
            pWriterNode->pWMWriterAdvanced = NULL;
        }
    }

    DVR_ASSERT(pWriterNode->pwszFileName == NULL, "");
    pWriterNode->cnsStartTime = 0;
    pWriterNode->cnsEndTime = 0;
    pWriterNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
    pWriterNode->m_nFlags = 0;

    if (pWriterNode->pRecorderNode)
    {
        // This writer node is no longer associated with the recorder node.
        PASF_RECORDER_NODE pRecorderNode = pWriterNode->pRecorderNode;

        // Set the status on the associated recorder node; this could be the
        // BeginWriting status if BeginWriting failed
        if (SUCCEEDED (pRecorderNode->hrRet))
        {
            pRecorderNode->hrRet = hrRet;
        }

        pRecorderNode->SetWriterNode(NULL);
        pWriterNode->SetRecorderNode(NULL);

        pRecorderNode->SetFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::RecorderNodeDeleted))
        {
            delete pRecorderNode;
        }
        else if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::PersistentRecording))
        {
            pRecorderNode->ClearFlags(ASF_RECORDER_NODE::PersistentRecording);
            pRecorderNode->pRecorderInstance->Release();
            // At this point, pRecorderNode could have been deleted by DeleteRecorder()
        }
    }

    ::SetEvent(pWriterNode->hFileClosed);

    // It's unsafe to reference pWriterNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRRingBufferWriter::ProcessCloseRequest

HRESULT CDVRRingBufferWriter::CloseWriterFile(LIST_ENTRY* pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CloseWriterFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_WRITER_NODE        pWriterNode;
    BOOL                    bLeak = 0;   // Leak the writer node memory if we fail
    BOOL                    bDelete = 0; // Delete the writer node if we fail
    BOOL                    bWaitForClose = 0; // Wait for hFileClsoed before deleting
    IWMRegisterCallback *   pIWMRegisterCallback = NULL ;

    pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

    __try
    {
        DWORD nRet;

        // We have to close the file; ensure the open has completed
        DVR_ASSERT(pWriterNode->hReadyToWriteTo, "");
        if (::WaitForSingleObject(pWriterNode->hReadyToWriteTo, INFINITE) == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x",
                            pWriterNode->hReadyToWriteTo, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);

            // We don't know if the queued user work item has executed or not
            // Better to leak this memory than to potentially av.
            bLeak = 1;
           __leave;
        }
        bDelete = 1;

        // Verify that hFileClosed is reset
        DVR_ASSERT(pWriterNode->hFileClosed, "");
        nRet = ::WaitForSingleObject(pWriterNode->hFileClosed, 0);
        if (nRet != WAIT_TIMEOUT)
        {
            DVR_ASSERT(nRet != WAIT_OBJECT_0, "Writer node's hFileClosed is set?");
            if (nRet == WAIT_OBJECT_0)
            {
                // hope for the best! Consider treating this an error @@@@
                ::ResetEvent(pWriterNode->hFileClosed);
            }
            else
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "WFSO(hFileClosed) failed; hFileClosed = 0x%p, last error = 0x%x",
                                pWriterNode->hFileClosed, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        if (pWriterNode->pRecorderNode)
        {
            PASF_RECORDER_NODE pRecorderNode = pWriterNode->pRecorderNode;

            // Recording completed and file is being closed. Pull node out
            // of m_leRecordersList. This must be done while holding
            // m_csLock (and all calls to this fn do hold the lock)
            if (!LIST_NODE_POINTERS_NULL(&pRecorderNode->leListEntry))
            {
                RemoveEntryList(&pRecorderNode->leListEntry);
                NULL_LIST_NODE_POINTERS(&pRecorderNode->leListEntry);
            }
        }

        //  unregister from notifications
        hrRet = pWriterNode -> pDVRFileSink -> QueryInterface (
                        IID_IWMRegisterCallback,
                        (void **) & pIWMRegisterCallback
                        ) ;
        if (FAILED (hrRet)) {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWriterNode->pDVRFileSink->QueryInterface for IID_IWMRegisterCallback failed; hr = 0x%x",
                            hrRet);
            __leave;
        }

        //  unregister from advise notifications
        pIWMRegisterCallback -> Unadvise (
            static_cast <IWMStatusCallback *> (this),
            NULL
            ) ;

        // Issue the call to EndWriting
        if (::QueueUserWorkItem(ProcessCloseRequest, pWriterNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "QueueUserWorkItem failed; last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        bWaitForClose = 1; // We wait only if subsequent operations fail

        // We could do this after the WFSO(hReadyToWriteTo) succeeds
        // We delay it because we may change this function to not
        // not delete the node on failure and retry this function.
        // So it's better to leave the event set until we are
        // sure of success.
        ::ResetEvent(pWriterNode->hReadyToWriteTo);

        // Insert into m_leFreeList
        LIST_ENTRY*         pTmp = &m_leFreeList;
        PASF_WRITER_NODE    pFreeNode;

        while (PREVIOUS_LIST_NODE(pTmp) != &m_leFreeList)
        {
            pTmp = PREVIOUS_LIST_NODE(pTmp);
            pFreeNode = CONTAINING_RECORD(pTmp, ASF_WRITER_NODE, leListEntry);
            if (pFreeNode->pWMWriter != NULL)
            {
                InsertHeadList(pTmp, pCurrent);
                bDelete = 0;
                break;
            }
        }
        if (pTmp == &m_leFreeList)
        {
            // Not inserted into free list yet - all nodes in the
            // free list have pWMWriter == NULL
            InsertHeadList(&m_leFreeList, pCurrent);
            bDelete = 0;
        }
        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // We either leak or delete the node on failure, but not both

            DVR_ASSERT(bLeak == 0 || bLeak == 1, "");
            DVR_ASSERT(bDelete == 0 || bDelete == 1, "");
            DVR_ASSERT(bLeak ^ bDelete, "");

            if (bWaitForClose)
            {
                // Currently won't happen since we have no failures
                // after queueing the work item. However, this is to
                // protect us from code changes

                DWORD nRet;

                nRet = ::WaitForSingleObject(pWriterNode->hFileClosed, INFINITE);
                if (nRet == WAIT_FAILED)
                {
                    DVR_ASSERT(nRet == WAIT_OBJECT_0, "Writer node WFSO(hFileClosed) failed");

                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "WFSO(hFileClosed) failed, deleting node anyway; hFileClosed = 0x%p, last error = 0x%x",
                                    pWriterNode->hFileClosed, dwLastError);

                    // Ignore this error
                    // hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
            }
            else
            {
                // If SUCCEEDED(hrRet) || bWaitForClose == 1, this has already
                // been done in ProcessCloseRequest
                if (pWriterNode->pRecorderNode)
                {
                    // This writer node is no longer associated with the recorder node.
                    PASF_RECORDER_NODE pRecorderNode = pWriterNode->pRecorderNode;

                    // Set the status on the associated recorder node; this will be the
                    // BeginWriting status if BeginWriting failed
                    if (SUCCEEDED(pRecorderNode->hrRet))
                    {
                        // We haven't called EndWriting
                        pRecorderNode->hrRet = E_FAIL;
                    }
                    pRecorderNode->SetWriterNode(NULL);
                    pWriterNode->SetRecorderNode(NULL);
                    // Recording completed and file has been closed. Pull node out
                    // of m_leRecordersList
                    if (!LIST_NODE_POINTERS_NULL(&pRecorderNode->leListEntry))
                    {
                        RemoveEntryList(&pRecorderNode->leListEntry);
                        NULL_LIST_NODE_POINTERS(&pRecorderNode->leListEntry);
                    }
                    pRecorderNode->SetFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
                    if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::RecorderNodeDeleted))
                    {
                        delete pRecorderNode;
                    }
                    else if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::PersistentRecording))
                    {
                        pRecorderNode->ClearFlags(ASF_RECORDER_NODE::PersistentRecording);
                        pRecorderNode->pRecorderInstance->Release();
                        // At this point, pRecorderNode could have been deleted by DeleteRecorder()
                    }
                }
            }
            if (bDelete)
            {
                delete pWriterNode;
            }
        }
        else
        {
            DVR_ASSERT(bLeak == 0 && bDelete == 0, "");
        }

        if (pIWMRegisterCallback) {
            pIWMRegisterCallback -> Release () ;
        }

        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::CloseWriterFile


HRESULT CDVRRingBufferWriter::CloseAllWriterFilesBefore(QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CloseAllWriterFilesBefore"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_WRITER_NODE    pWriterNode;
    LIST_ENTRY*         pCurrent = &m_leWritersList;

    __try
    {
        HRESULT hr;

        while (NEXT_LIST_NODE(pCurrent) != &m_leWritersList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);
            if (pWriterNode->cnsEndTime > cnsStreamTime)
            {
                // All done
                hrRet = S_OK;
                break;
            }

            RemoveEntryList(pCurrent);
            NULL_LIST_NODE_POINTERS(pCurrent);

            hr = CloseWriterFile(pCurrent);
            if (FAILED(hr))
            {
                // We ignore this and go on, the node has been deleted
            }

            // Reset pCurrent to the start of the Writer list
            pCurrent = &m_leWritersList;
        }
        hrRet = S_OK; // even if there was a failure
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::CloseAllWriterFilesBefore


HRESULT CDVRRingBufferWriter::AddToRecordersList(IN LIST_ENTRY*   pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddToRecordersList"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    __try
    {

        PASF_RECORDER_NODE  pRecorderNode;
        LIST_ENTRY*         pTmp = &m_leRecordersList;

        pRecorderNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);

        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
        {
            // Multi file recording. Insert at tail
            DVR_ASSERT(pTmp == &m_leRecordersList, "");
        }
        else
        {
            BOOL                bFound = 0;
            QWORD               cnsStartTime;
            QWORD               cnsEndTime;

            cnsStartTime = pRecorderNode->cnsStartTime;
            cnsEndTime = pRecorderNode->cnsEndTime;

            while (NEXT_LIST_NODE(pTmp) != &m_leRecordersList)
            {
                pTmp = NEXT_LIST_NODE(pTmp);
                pRecorderNode = CONTAINING_RECORD(pTmp, ASF_RECORDER_NODE, leListEntry);

                if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
                {
                    // Al multi file recordings are always at the end of the list
                    bFound = 1;
                    break;
                }

                if (cnsEndTime <= pRecorderNode->cnsStartTime)
                {
                    // All ok; we should insert before pTmp
                    bFound = 1;
                    break;
                }
                if (cnsStartTime >= pRecorderNode->cnsEndTime)
                {
                    // Keep going on
                    continue;
                }
                // Trouble
                DVR_ASSERT(cnsStartTime < pRecorderNode->cnsEndTime && cnsEndTime > pRecorderNode->cnsStartTime,
                           "Overlapped insert assertion failure?!");
                DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Overlapped insert! Input params: start time: %I64u, end time: %I64u\n"
                                "overlap node values: start time: %I64u, end time: %I64u",
                                cnsStartTime, cnsEndTime, pRecorderNode->cnsStartTime, pRecorderNode->cnsEndTime);
                hrRet = E_FAIL;
                __leave;
            }

            if (!bFound)
            {
                // We insert at tail
                pTmp = NEXT_LIST_NODE(pTmp);;
                DVR_ASSERT(pTmp == &m_leRecordersList, "");
            }
        }
        InsertTailList(pTmp, pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up necessary
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::AddToRecordersList

// ====== Helper methods to support multi file recordings

HRESULT
CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::CreateAttributeFilename (
    OUT LPWSTR *    ppszFilename    //  use delete [] to free
    )
{
    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::CreateAttributeFilename"

    HRESULT hrRet;

    LPWSTR  pwszFileName = NULL;
    BOOL    bFreeFilename = 1;
    BOOL    fLocked = 0;

    DVR_ASSERT(pFileCollection, "");

    __try
    {
        HRESULT hr;

        hr = pFileCollection->Lock(&FileCollectionInfo, fLocked);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Generate the file name

        DVR_ASSERT(pRecorderNode->pwszFileName, "");

        WCHAR   wTempChar;
        WCHAR*  pDir;
        DWORD   dwLastError;
        DWORD   nLen;
        DWORD   nLen2;

        nLen = ::GetFullPathNameW(pRecorderNode->pwszFileName, 0, &wTempChar, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "First GetFullPathNameW (for pRecorderNode->pwszFileName) failed, nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        pwszFileName = new WCHAR[nLen+1+9]; // "_attr.sbe"
        if (pwszFileName == NULL)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - pwszFileName - WCHAR[%u]",
                            nLen+1+15);

            hrRet = E_OUTOFMEMORY;
            __leave;
        }

        nLen2 = ::GetFullPathNameW(pRecorderNode->pwszFileName, nLen+1, pwszFileName, &pDir);
        if (nLen2 == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Second GetFullPathNameW (for pRecorderNode->pwszFileName) failed, first call returned nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        else if (nLen2 > nLen)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Second GetFullPathNameW (for pRecorderNode->pwszFileName) returned nLen = %u > first call, which returned %u",
                            nLen2, nLen);
            hrRet = E_FAIL;
            __leave;
        }
        DVR_ASSERT(pDir, "");

        WCHAR* cp = wcsrchr(pwszFileName, L'.');

        if (cp == NULL || cp < pDir)
        {
            cp = pwszFileName + wcslen(pwszFileName);
        }

        //  create the filename
        wsprintf(cp, L"_attr.sbe");

        //  set outgoing
        (* ppszFilename) = pwszFileName ;

        bFreeFilename = FALSE ;

        hrRet = S_OK;
    }
    __finally
    {
        if (bFreeFilename)
        {
            delete [] pwszFileName;
        }

        hrRet = pFileCollection->Unlock (&FileCollectionInfo, fLocked) ;
    }

    return hrRet;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::CreateAttributeFilename

HRESULT
CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::SetAttributeFile (
    IN  LPWSTR  pszAttributeFile
    )
{
    HRESULT hrRet;

    //  locking is handled by the file collection object
    hrRet = pFileCollection->SetAttributeFile (&FileCollectionInfo, pszAttributeFile) ;

    return hrRet ;
}

HRESULT
CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::GetExistingAttributeFilename (
    OUT LPWSTR *    ppszFilename    //  use delete [] to free
    )
{
    HRESULT hrRet;

    //  locking is handled by the file collection object
    hrRet = pFileCollection->GetAttributeFile (&FileCollectionInfo, ppszFilename) ;

    return hrRet ;
}

HRESULT CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::AddFile(
    IN LPCWSTR  pwszWriterFileName, // of the file in the writer's file collection. This file is hard linked
    IN CDVRFileCollection::DVRIOP_FILE_ID nWriterFileId,
    IN QWORD    cnsFileStartTime,
    IN QWORD    cnsFileEndTime,
    IN LONGLONG cnsFirstSampleTimeOffsetFromStartOfFile)
{
    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::AddFile"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    CDVRFileCollection::DVRIOP_FILE_ID nFileId; // file id of the file we add to the recording
    LPWSTR                             pwszFileName = NULL;
    BOOL                               bDeleteFile = 0;
    BOOL                               bReleaseSharedMemoryLock = 0;
    BOOL                               bLockedMultiFileRecorder = 0;
    BOOL                               bDecrementInconsistencyDataCounter = 0;

    DVR_ASSERT(pFileCollection, "");

    __try
    {
        HRESULT hr;

        hr = pFileCollection->Lock(&FileCollectionInfo, bReleaseSharedMemoryLock, 1);
        bLockedMultiFileRecorder = 1;
        if (FAILED(hr))
        {
            hrRet = hr;
            bDecrementInconsistencyDataCounter = 0;
            __leave;
        }
        bDecrementInconsistencyDataCounter = 1;

        // Generate the file name

        DVR_ASSERT(pRecorderNode->pwszFileName, "");

        WCHAR   wTempChar;
        WCHAR*  pDir;
        DWORD   dwLastError;
        DWORD   nLen;
        DWORD   nLen2;

        nLen = ::GetFullPathNameW(pRecorderNode->pwszFileName, 0, &wTempChar, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "First GetFullPathNameW (for pRecorderNode->pwszFileName) failed, nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);

            //  PREFIX tweak just to make sure that we do in fact fail
            if (SUCCEEDED (hrRet)) {
                hrRet = E_FAIL ;
            }
            __leave;
        }

        pwszFileName = new WCHAR[nLen+1+15]; // '_' + 10 char for nNextFileSuffix + ".sbe"
        if (pwszFileName == NULL)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - pwszFileName - WCHAR[%u]",
                            nLen+1+15);

            hrRet = E_OUTOFMEMORY;
            __leave;
        }

        nLen2 = ::GetFullPathNameW(pRecorderNode->pwszFileName, nLen+1, pwszFileName, &pDir);
        if (nLen2 == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Second GetFullPathNameW (for pRecorderNode->pwszFileName) failed, first call returned nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        else if (nLen2 > nLen)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Second GetFullPathNameW (for pRecorderNode->pwszFileName) returned nLen = %u > first call, which returned %u",
                            nLen2, nLen);
            hrRet = E_FAIL;
            __leave;
        }
        DVR_ASSERT(pDir, "");

        WCHAR* cp = wcsrchr(pwszFileName, L'.');

        if (cp == NULL || cp < pDir)
        {
            cp = pwszFileName + wcslen(pwszFileName);
        }

        while (1)
        {
            if (nNextFileSuffix == 0)
            {
                hrRet = E_FAIL;
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Exhausted suffixes for file name, pMultiFileRecorderNode = 0x%x, returning hr = 0x%x",
                                this, hrRet);
                __leave;
            }

            wsprintf(cp, L"_%d.sbe", nNextFileSuffix);
            nNextFileSuffix++;

            if (::CreateHardLinkW(pwszFileName, pwszWriterFileName, NULL))
            {
                // Success
                bDeleteFile = 1;
                break;
            }

            dwLastError = ::GetLastError();

            if (dwLastError != ERROR_ALREADY_EXISTS)
            {
                // Note that if the volume does not support hard links, we should get here -
                // sooner or later!
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "CreateHardLinkW failed, pMultiFileRecorderNode = 0x%x, last error = 0x%x",
                                this, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        hr = pFileCollection->AddFile(&FileCollectionInfo,
                                      (LPWSTR*) &pwszFileName,
                                      1,                   // bOpenFromFileCollectionDirectory
                                      cnsFileStartTime,
                                      cnsFileEndTime,
                                      TRUE,                // bPermanentFile,
                                      0,                   // bDeleteTemporaryFiles, ignored if bPermanentFile is set
                                      cnsFirstSampleTimeOffsetFromStartOfFile,
                                      &nFileId);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        bDeleteFile = 0;
        hrRet = S_OK;
    }
    __finally
    {
        if (SUCCEEDED(hrRet))
        {
            nLastWriterFileId = nWriterFileId;
            nLastFileId = nFileId;
            cnsLastFileStartTime = cnsFileStartTime;
        }
        if (bDeleteFile)
        {
            DVR_ASSERT(FAILED(hrRet), "");
            ::DeleteFileW(pwszFileName);
            nNextFileSuffix--;
        }
        delete [] pwszFileName;

        if (bLockedMultiFileRecorder)
        {
            HRESULT hr = pFileCollection->Unlock(&FileCollectionInfo,
                                                 bReleaseSharedMemoryLock,
                                                 bDecrementInconsistencyDataCounter);
            DVR_ASSERT(SUCCEEDED(hr), "pFileCollection->Unlock failed");
        }

        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRRingBufferWriter::ASF_MULTI_FILE_RECORDER_NODE::AddFile

HRESULT
CDVRRingBufferWriter::CreateAttributeFilename (
    IN  LPVOID      pRecorderId,
    OUT LPWSTR *    pszAttrFilename
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CreateAttributeFilename"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    ::EnterCriticalSection(&m_csLock);
    __try
    {
        HRESULT     hr;
        LIST_ENTRY* pCurrent;
        LIST_ENTRY* pStart = (LIST_ENTRY*) pRecorderId;

        // Verify if the node is in the recorder's list.

        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            if (pCurrent == pStart)
            {
                break;
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        if (pCurrent == &m_leFreeList)
        {
            // Didn't find the node

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Did not find recorder node id 0x%x in the recorders list",
                            pStart);
            hrRet = E_FAIL;
            __leave;
        }

        PASF_RECORDER_NODE  pRecorderNode;

        pRecorderNode = CONTAINING_RECORD(pStart, ASF_RECORDER_NODE, leListEntry);

        DVR_ASSERT (pRecorderNode -> pMultiFileRecorder, "") ;
        hrRet = pRecorderNode -> pMultiFileRecorder -> CreateAttributeFilename (pszAttrFilename) ;
    }
    __finally {
        ::LeaveCriticalSection(&m_csLock);
    }

    return hrRet ;
}

HRESULT
CDVRRingBufferWriter::GetExistingAttributeFile (
    IN  LPVOID      pRecorderId,
    OUT LPWSTR *    ppszAttrFilename
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetExistingAttributeFile"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    ::EnterCriticalSection(&m_csLock);
    __try
    {
        HRESULT     hr;
        LIST_ENTRY* pCurrent;
        LIST_ENTRY* pStart = (LIST_ENTRY*) pRecorderId;

        // Verify if the node is in the recorder's list.

        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            if (pCurrent == pStart)
            {
                break;
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        if (pCurrent == &m_leFreeList)
        {
            // Didn't find the node

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Did not find recorder node id 0x%x in the recorders list",
                            pStart);
            hrRet = E_FAIL;
            __leave;
        }

        PASF_RECORDER_NODE  pRecorderNode;

        pRecorderNode = CONTAINING_RECORD(pStart, ASF_RECORDER_NODE, leListEntry);

        DVR_ASSERT (pRecorderNode -> pMultiFileRecorder, "") ;
        hrRet = pRecorderNode -> pMultiFileRecorder -> GetExistingAttributeFilename (ppszAttrFilename) ;
    }
    __finally {
        ::LeaveCriticalSection(&m_csLock);
    }

    return hrRet ;
}

HRESULT
CDVRRingBufferWriter::SetAttributeFile (
    IN  LPVOID  pRecorderId,
    IN  LPWSTR  pszAttrFilename
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::SetAttributeFile"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    ::EnterCriticalSection(&m_csLock);
    __try
    {
        HRESULT     hr;
        LIST_ENTRY* pCurrent;
        LIST_ENTRY* pStart = (LIST_ENTRY*) pRecorderId;

        // Verify if the node is in the recorder's list.

        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            if (pCurrent == pStart)
            {
                break;
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        if (pCurrent == &m_leFreeList)
        {
            // Didn't find the node

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Did not find recorder node id 0x%x in the recorders list",
                            pStart);
            hrRet = E_FAIL;
            __leave;
        }

        PASF_RECORDER_NODE  pRecorderNode;

        pRecorderNode = CONTAINING_RECORD(pStart, ASF_RECORDER_NODE, leListEntry);

        DVR_ASSERT (pRecorderNode -> pMultiFileRecorder, "") ;
        hrRet = pRecorderNode -> pMultiFileRecorder -> SetAttributeFile (pszAttrFilename) ;
    }
    __finally {
        ::LeaveCriticalSection(&m_csLock);
    }

    return hrRet ;
}

HRESULT CDVRRingBufferWriter::ExtendMultiFileRecording(IN  PASF_RECORDER_NODE pRecorderNode,
                                                       OUT BOOL&              bRecordingCompleted)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::ExtendMultiFileRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    DVR_ASSERT(pRecorderNode, "");

    PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode = pRecorderNode->pMultiFileRecorder;

    DVR_ASSERT(pMultiFileRecorderNode, "");

    CDVRFileCollection* pFileCollection = pMultiFileRecorderNode->pFileCollection;
    CDVRFileCollection::CClientInfo* pFileCollectionInfo = &(pMultiFileRecorderNode->FileCollectionInfo);

    DVR_ASSERT(pFileCollection, "");

    BOOL bLockedSharedMemory = 0;
    BOOL bReleaseSharedMemoryLock = 0;
    BOOL bReleaseSharedMemoryLockMultiFileRecorder = 0;
    BOOL bLockedMultiFileRecorder = 0;
    BOOL bDecrementInconsistencyDataCounterMultiFileRecorder = 0;

    bRecordingCompleted = 0;
    __try
    {
        HRESULT                             hr;
        CDVRFileCollection::DVRIOP_FILE_ID  nFileId;
        LPWSTR                              pwszFileName = NULL;
        LONGLONG                            cnsFirstSampleTimeOffsetFromStartOfFile;
        QWORD                               cnsFileStartTime;
        QWORD                               cnsFileEndTime;
        QWORD                               cnsCurrentStreamTime;

        if (FAILED(pRecorderNode->hrRet))
        {
            hrRet = pRecorderNode->hrRet;
            __leave;
        }

        hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
        bLockedSharedMemory = 1;
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &cnsCurrentStreamTime, 0 /* do not lock, we have the lock already */);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (pRecorderNode->cnsStartTime > cnsCurrentStreamTime)
        {
            // Not time to write to this recording as yet
            hrRet = S_OK;
            __leave;
        }

        if (!IsFlagSet(SampleWritten) &&
            pRecorderNode->cnsStartTime == cnsCurrentStreamTime)
        {
            // Not time to write to this recording as yet
            hrRet = S_OK;
            __leave;
        }

        hr = pFileCollection->Lock(pFileCollectionInfo, bReleaseSharedMemoryLockMultiFileRecorder, 1);
        bLockedMultiFileRecorder = 1;
        if (FAILED(hr))
        {
            hrRet = hr;
            bDecrementInconsistencyDataCounterMultiFileRecorder = 0;
            __leave;
        }
        bDecrementInconsistencyDataCounterMultiFileRecorder = 1;

        if (pRecorderNode->pWriterNode != NULL)
        {
            // We haven't "written" to this recording yet and this is the
            // first write

            hr = CloseTempFileOfMultiFileRecording(pRecorderNode);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            // Add the file(s) from the recording start time to the
            // current stream time to the multi file recording


            BOOL  bMoreFiles;               // More files to add after the current file?
            BOOL  bFirstIteration = 1;

            cnsFileEndTime = pRecorderNode->cnsStartTime;

            do
            {
                // Skip over time holes

                // Treat time cnsFileEndTime = 0 specially since cnsFileEndTime - 1 would underflow
                if (cnsFileEndTime == 0)
                {
                    hr = pFileCollection->GetLastValidTimeBefore(pFileCollectionInfo, 1, &cnsFileEndTime);

                    if (FAILED(hr))
                    {
                        // 0 is an invalid time
                        cnsFileEndTime = 1;
                            // So that we get the first valid time after 0 in the call to
                            // GetFirstValidTimeAfter below
                    }
                    else
                    {
                        // cnsFileEndTime must be 0.
                        // 0 is a valid time, no need to get the first valid time after it
                        DVR_ASSERT(cnsFileEndTime == 0, "");
                    }
                }
                else
                {
                    // To force the call to GetFirstValidTimeAfter
                    hr = E_FAIL;
                }


                if (FAILED(hr))
                {
                    hr = m_pDVRFileCollection->GetFirstValidTimeAfter(&m_FileCollectionInfo,
                                                                      cnsFileEndTime - 1,
                                                                      &cnsFileEndTime);
                }

                if (FAILED(hr))
                {
                    // This should not happen. We know that
                    //   pRecorderNode->cnsStartTime > cnsCurrentStreamTime (for the first iteration of this loop)
                    // and that
                    //   cnsFileEndTime > cnsCurrentStreamTime (for subsequent iterations)
                    // and that we have written a sample at cnsCurrentStreamTime
                    //
                    // Also, GetFirstValidTimeAfter should not have failed to
                    // get the lock since we already have the lock

                    DVR_ASSERT(0, "Unexpected: GetFirstValidTimeAfter failed");
                    hrRet = hr;
                    __leave;
                }

                DVR_ASSERT(cnsFileEndTime <= cnsCurrentStreamTime, "");

                if (pRecorderNode->cnsEndTime <= cnsFileEndTime)
                {
                    // Note that it's possible that we haven't yet added a file to the
                    // multi file recording. This can happen, for example, if the caller
                    // set start time = N, stop time = N+1 and the samples written had
                    // times = N-1 and N+1 (no sample had time = N). [Caller has to have
                    // set the start and stop times before the sample with time N+1 was
                    // written, otherwise pRecorderNode->cnsEndTime would be MAXQWORD.]

                    if (bFirstIteration)
                    {
                        // Force *pFileCollection->pcnsCurrentStreamTime to 0
                        // cnsFileEndTime = pRecorderNode->cnsStartTime + 1;
                    }
                    else
                    {
                        // cnsFileEndTime = pRecorderNode->cnsEndTime;
                    }
                    bMoreFiles = 0; // usused
                    bRecordingCompleted = 1;
                    // Do not change this. Otherwise, the streams end extent will be a value that is
                    // not backed by a file. This is also consistent with what we do in
                    // DeleteFilesFromMultiFileRecording() in the case that the end time of the
                    // recording falls in a time hole.
                    // *pMultiFileRecorderNode->pcnsCurrentStreamTime = cnsFileEndTime - pRecorderNode->cnsStartTime - 1;
                    break;
                }

                hr = m_pDVRFileCollection->GetFileAtTime(&m_FileCollectionInfo,
                                                                        // Reader index, unused if bFileWillBeOpened == 0
                                                         cnsFileEndTime,
                                                         &pwszFileName,
                                                         &cnsFirstSampleTimeOffsetFromStartOfFile,
                                                         &nFileId,
                                                         0              // bFileWillBeOpened
                                                        );
                if (FAILED(hr))
                {
                    // We know we have a file
                    DVR_ASSERT(0, "Unexpected: GetFileAtTime failed");
                    hrRet = hr;
                    __leave;
                }

                QWORD cnsStreamExtent;

                hr = m_pDVRFileCollection->GetTimeExtentForFile(&m_FileCollectionInfo,
                                                                nFileId,
                                                                &cnsFileStartTime,
                                                                &cnsFileEndTime);
                if (FAILED(hr))
                {
                    DVR_ASSERT(0, "Unexpected: GetTimeExtentForFile failed");
                    hrRet = hr;
                    delete [] pwszFileName;
                    __leave;
                }

                cnsStreamExtent = cnsFileEndTime - 1;

                if (cnsFileEndTime > cnsCurrentStreamTime)
                {
                    // Not any more - see comment near AddFile below.
                    // // The extent of the last file in the multi file recording never
                    // // exceeds the extent of the file collection of the multi file
                    // // recording (by design)
                    // cnsFileEndTime = cnsCurrentStreamTime + 1;
                    cnsStreamExtent = cnsCurrentStreamTime;
                    bMoreFiles = 0;
                }
                else
                {
                    bMoreFiles = 1;
                }
                // if cnsFileEndTime == MAXQWORD, it means that the current file is
                // single file recording on which the stop time has not been set.
                if (cnsFileEndTime != MAXQWORD && pRecorderNode->cnsEndTime <= cnsFileEndTime)
                {
                    cnsFileEndTime = pRecorderNode->cnsEndTime;
                    cnsStreamExtent = pRecorderNode->cnsEndTime - 1;
                    bMoreFiles = 0;
                    bRecordingCompleted = 1;
                }
                DVR_ASSERT(cnsFileEndTime > cnsFileStartTime, "");

                if (pMultiFileRecorderNode->nLastWriterFileId == CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
                {
                    // For the first file added to the multi file collection:

                    // Convert to a stream time
                    cnsFirstSampleTimeOffsetFromStartOfFile += cnsFileStartTime;

                    // In the multi file collection, the first sample's offset is relative to first sample
                    // offset in the writer's ring buffer. This is because, pRecorderNode->cnsStartTime maps to
                    // a time of 0 in the multi file recording.
                    cnsFirstSampleTimeOffsetFromStartOfFile -= pRecorderNode->cnsStartTime;

                    cnsFileStartTime = pRecorderNode->cnsStartTime;
                }

                // Note that the extent of this file matches the extent of the writer's file at this
                // time. The extnet is revised again when we add the next file to the multi file recording.
                // It is likely that the writer can change the extent of the current file between now and
                // then (if a single file recording is created after this). This does not matter much since
                // the file extent is not very useful as long as it is more than
                // *pMultiFileRecorderNode->pcnsCurrentStreamTime. Doing ti this way saves us from having
                // to call SetFileTimes every time *pMultiFileRecorderNode->pcnsCurrentStreamTime is updated.

                // When the recording is closed, the extent of the last file is changed to match
                // *pMultiFileRecorderNode->pcnsCurrentStreamTime
                hr = pMultiFileRecorderNode->AddFile(pwszFileName,
                                                     nFileId,
                                                     cnsFileStartTime - pRecorderNode->cnsStartTime,
                                                     cnsFileEndTime - pRecorderNode->cnsStartTime,
                                                     cnsFirstSampleTimeOffsetFromStartOfFile);

                delete [] pwszFileName;
                pwszFileName = NULL;

                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }
                // Do this on each iteration - if next iteration failed, the recording is at least good
                // up till here.
                DVR_ASSERT(pMultiFileRecorderNode->nLastWriterFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");
                DVR_ASSERT(pMultiFileRecorderNode->nLastFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");

                hr = pFileCollection->SetLastStreamTime(pFileCollectionInfo, cnsStreamExtent - pRecorderNode->cnsStartTime, 0 /* already locked, do not lock */);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }
                bFirstIteration = 0;
            }
            while (bMoreFiles);

            hrRet = S_OK;
            __leave;
        }

        // We have written to this multi file recording previously

        QWORD cnsStreamExtent;

        DVR_ASSERT(pMultiFileRecorderNode->nLastWriterFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");
        DVR_ASSERT(pMultiFileRecorderNode->nLastFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");

        if (cnsCurrentStreamTime >= pRecorderNode->cnsEndTime)
        {
            // *pFileCollection->pcnsCurrentStreamTime has been set in a previous call
            // to this function. We do not update it.

            // Update the file extent of the last file in the multi file recording. This
            // is not really necessary, but keeps things consistent with other sections
            // of code.

            DWORD               dwNumNodesToUpdate = 0;
            CDVRFileCollection::DVRIOP_FILE_TIME    ft[1];

            QWORD   cnsLastStreamTimeRecorder;

            hr = pFileCollection->GetLastStreamTime(pFileCollectionInfo, &cnsLastStreamTimeRecorder, 0 /* do not lock, already locked */);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            ft[dwNumNodesToUpdate].nFileId = pMultiFileRecorderNode->nLastFileId;
            ft[dwNumNodesToUpdate].cnsStartTime = pMultiFileRecorderNode->cnsLastFileStartTime;
            ft[dwNumNodesToUpdate].cnsEndTime = cnsLastStreamTimeRecorder + 1;
            dwNumNodesToUpdate++;

            DVR_ASSERT(cnsLastStreamTimeRecorder >= pMultiFileRecorderNode->cnsLastFileStartTime, "");

            hr = pFileCollection->SetFileTimes(pFileCollectionInfo, dwNumNodesToUpdate, &ft[0]);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            DVR_ASSERT(hr == S_OK, "S_FALSE unexpected - multi file recording should have files");

            bRecordingCompleted = 1;
            hrRet = S_OK;
            __leave;
        }

        // Extend the multi file recording, adding a file if needed
        cnsStreamExtent = cnsCurrentStreamTime;

        hr = m_pDVRFileCollection->GetFileAtTime(&m_FileCollectionInfo,
                                                                // Reader index, unused if bFileWillBeOpened == 0
                                                 cnsStreamExtent,
                                                 NULL,          // pwszFileName,
                                                 NULL,          // cnsFirstSampleTimeOffsetFromStartOfFile,
                                                 &nFileId,
                                                 0              // bFileWillBeOpened
                                                );
        if (FAILED(hr))
        {
            // We know we have a file
            DVR_ASSERT(0, "Unexpected: GetFileAtTime failed while extending recording");
            hrRet = hr;
            __leave;
        }
        if (nFileId == pMultiFileRecorderNode->nLastWriterFileId)
        {
            cnsStreamExtent -= pRecorderNode->cnsStartTime;

            // Don't need to call SetFileTimes here - see comment in the AddFile call above.
            // DWORD               dwNumNodesToUpdate = 0;
            // CDVRFileCollection::DVRIOP_FILE_TIME    ft[1];

            // ft[dwNumNodesToUpdate].nFileId = pMultiFileRecorderNode->nLastFileId;
            // ft[dwNumNodesToUpdate].cnsStartTime = pMultiFileRecorderNode->cnsLastFileStartTime;
            // ft[dwNumNodesToUpdate].cnsEndTime = cnsStreamExtent + 1;
            // dwNumNodesToUpdate++;

            DVR_ASSERT(cnsStreamExtent >= pMultiFileRecorderNode->cnsLastFileStartTime, "");

            // hr = pFileCollection->SetFileTimes(dwNumNodesToUpdate, &ft[0]);
            // if (FAILED(hr))
            // {
            //     hrRet = hr;
            //     __leave;
            // }
            // DVR_ASSERT(hr == S_OK, "S_FALSE unexpected - multi file recording should have files");

            hr = pFileCollection->SetLastStreamTime(pFileCollectionInfo, cnsStreamExtent, 0 /* already locked, do not lock */);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            hrRet = S_OK;
            __leave;
        }

        // Before adding the next file, extend the extent of the current file in the
        // multi file recording to match the extent of the file in the writer's ring
        // buffer. This will ensure that we don't introduce small time holes

        QWORD cnsPrevFileEnd;

        hr = m_pDVRFileCollection->GetTimeExtentForFile(&m_FileCollectionInfo,
                                                        pMultiFileRecorderNode->nLastWriterFileId,
                                                        NULL,
                                                        &cnsPrevFileEnd);
        if (FAILED(hr))
        {
            DVR_ASSERT(0, "Unexpected: GetTimeExtentForFile for previous writer failed - about to add file");
            hrRet = hr;
            __leave;
        }
        cnsPrevFileEnd -= pRecorderNode->cnsStartTime;

        DWORD               dwNumNodesToUpdate = 0;
        CDVRFileCollection::DVRIOP_FILE_TIME    ft[1];

        ft[dwNumNodesToUpdate].nFileId = pMultiFileRecorderNode->nLastFileId;
        ft[dwNumNodesToUpdate].cnsStartTime = pMultiFileRecorderNode->cnsLastFileStartTime;
        ft[dwNumNodesToUpdate].cnsEndTime = cnsPrevFileEnd;
        dwNumNodesToUpdate++;

        DVR_ASSERT(cnsPrevFileEnd >= pMultiFileRecorderNode->cnsLastFileStartTime, "");

        hr = pFileCollection->SetFileTimes(pFileCollectionInfo, dwNumNodesToUpdate, &ft[0]);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        DVR_ASSERT(hr == S_OK, "S_FALSE unexpected - multi file recording should have files");

        // The current stream time has not changed - we only advance the last file's extent
        // *pMultiFileRecorderNode->pcnsCurrentStreamTime = cnsPrevFileEnd - 1;

        // Now, add next file. Call GetFileAtTime again to get the file name and the first sample offset
        hr = m_pDVRFileCollection->GetFileAtTime(&m_FileCollectionInfo,
                                                                // Reader index, unused if bFileWillBeOpened == 0
                                                 cnsStreamExtent,
                                                 &pwszFileName,
                                                 &cnsFirstSampleTimeOffsetFromStartOfFile,
                                                 &nFileId,
                                                 0              // bFileWillBeOpened
                                                );
        if (FAILED(hr))
        {
            // We know we have a file
            DVR_ASSERT(0, "Unexpected: GetFileAtTime failed - about to add file");
            hrRet = hr;
            __leave;
        }

        hr = m_pDVRFileCollection->GetTimeExtentForFile(&m_FileCollectionInfo,
                                                        nFileId,
                                                        &cnsFileStartTime,
                                                        &cnsFileEndTime);
        if (FAILED(hr))
        {
            DVR_ASSERT(0, "Unexpected: GetTimeExtentForFile failed - about to add file");
            hrRet = hr;
            delete [] pwszFileName;
            __leave;
        }


        DVR_ASSERT(cnsFileEndTime >= cnsFileStartTime, "");
        hr = pMultiFileRecorderNode->AddFile(pwszFileName,
                                             nFileId,
                                             cnsFileStartTime - pRecorderNode->cnsStartTime,
                                             cnsFileEndTime - pRecorderNode->cnsStartTime,
                                             cnsFirstSampleTimeOffsetFromStartOfFile);

        delete [] pwszFileName;

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(pMultiFileRecorderNode->nLastWriterFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");
        DVR_ASSERT(pMultiFileRecorderNode->nLastFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");

        hr = pFileCollection->SetLastStreamTime(pFileCollectionInfo, cnsStreamExtent - pRecorderNode->cnsStartTime, 0 /* already locked, do not lock */);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        hrRet = S_OK;

    }
    __finally
    {
        if (bRecordingCompleted)
        {
            // Note: It is possible that we get here and the recording has no
            // files in it. See comment in try section for how this could
            // happen. In this case, the start and end extent of the multi file
            // recording should both be 0.

            DVR_ASSERT(SUCCEEDED(pRecorderNode->hrRet) && SUCCEEDED(hrRet), "");

            // Set the status on the associated recorder node
            pRecorderNode->hrRet = S_OK;

            // Don't do anything else here
        }

        if (SUCCEEDED(pRecorderNode->hrRet) && FAILED(hrRet))
        {
            pRecorderNode->hrRet = hrRet;
            HRESULT hr = pFileCollection->SetWriterHasBeenClosed(pFileCollectionInfo); // hr is for debugging only
            if (pRecorderNode->cnsEndTime != MAXQWORD)
            {
                // Recording has already been stopped. We have to close the recording
                // here; we never will otherwise.
                bRecordingCompleted = 1;
            }
        }

        if (bRecordingCompleted)
        {
            HRESULT hr;

            if (bLockedMultiFileRecorder)
            {
                hr = pFileCollection->Unlock(pFileCollectionInfo,
                                             bReleaseSharedMemoryLockMultiFileRecorder,
                                             bDecrementInconsistencyDataCounterMultiFileRecorder);
                DVR_ASSERT(SUCCEEDED(hr), "pFileCollection->Unlock failed");
            }

            // Ignore return status; this function will
            // record failures in pRecorderNode->hrRet
            // if necessary
            hr = CloseMultiFileRecording(pRecorderNode);

            // pRecorderNode may have been deleted. Do not reference it.

            DVR_ASSERT(SUCCEEDED(hr), "");

        }
        else if (bLockedMultiFileRecorder)
        {
            HRESULT hr = pFileCollection->Unlock(pFileCollectionInfo,
                                                 bReleaseSharedMemoryLockMultiFileRecorder,
                                                 bDecrementInconsistencyDataCounterMultiFileRecorder);
            DVR_ASSERT(SUCCEEDED(hr), "pFileCollection->Unlock failed");
        }


        if (bLockedSharedMemory)
        {
            HRESULT hr = m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
            DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->Unlock failed");
        }

        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::ExtendMultiFileRecording

HRESULT CDVRRingBufferWriter::CloseTempFileOfMultiFileRecording(IN PASF_RECORDER_NODE pRecorderNode)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CloseTempFileOfMultiFileRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;
    BOOL        bReleaseSharedMemoryLock = 0;
    BOOL        bLockedMultiFileRecorder = 0;
    BOOL        bDecrementInconsistencyDataCounter = 0;

    DVR_ASSERT(pRecorderNode, "");

    PASF_WRITER_NODE pWriterNode = pRecorderNode->pWriterNode;

    PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode = pRecorderNode->pMultiFileRecorder;

    DVR_ASSERT(pMultiFileRecorderNode, "");

    CDVRFileCollection* pFileCollection = pMultiFileRecorderNode->pFileCollection;
    CDVRFileCollection::CClientInfo* pFileCollectionInfo = &(pMultiFileRecorderNode->FileCollectionInfo);

    DVR_ASSERT(pFileCollection, "");

    __try
    {
        if (!pWriterNode)
        {
            // We are done
            hrRet = S_FALSE;
            __leave;
        }

        HRESULT hr;

        hr = pFileCollection->Lock(pFileCollectionInfo, bReleaseSharedMemoryLock, 1);
        bLockedMultiFileRecorder = 1;
        if (FAILED(hr))
        {
            hrRet = hr;
            bDecrementInconsistencyDataCounter = 0;
            __leave;
        }
        bDecrementInconsistencyDataCounter = 1;

        // If we still have the temp file, we should not have written to this recording yet. So, we expect:
        DVR_ASSERT(pMultiFileRecorderNode->nLastWriterFileId == CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");
        DVR_ASSERT(pMultiFileRecorderNode->nLastFileId == CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");

        // Remove the temporary file from the multi file recording and close it.
        // Note that we have the multi file recording lock, so readers will
        // wait till we are all done (have added permanent files to the collection

        DWORD               dwNumNodesToUpdate = 0;
        CDVRFileCollection::DVRIOP_FILE_TIME    ft[1];

        ft[dwNumNodesToUpdate].nFileId = pWriterNode->nFileId;
        ft[dwNumNodesToUpdate].cnsStartTime = pWriterNode->cnsStartTime;
        ft[dwNumNodesToUpdate].cnsEndTime = pWriterNode->cnsStartTime;
        dwNumNodesToUpdate++;

        hr = pFileCollection->SetFileTimes(pFileCollectionInfo, dwNumNodesToUpdate, &ft[0]);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        DVR_ASSERT(hr == S_FALSE, "S_OK unexpected - multi file recording should have no files");

        // The following call will delete the temp file (on disk)
        hr = pFileCollection->SetNumTempFiles(pFileCollectionInfo, 0, 0);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        hrRet = S_OK;
    }
    __finally
    {
        if (pWriterNode)
        {
            // Close the temp file whether or not the try block succeeded

            HRESULT hr;

            DVR_ASSERT(LIST_NODE_POINTERS_BOTH_NULL(&pWriterNode->leListEntry), "");

            // This is not a single file recording, so we don't want the
            // node marked for deletion etc. Note that we ignore the hrRet of
            // closing the file (it is set on pWriterNode only). But we don't
            // care much  if the temp file was clsoe properly or not.
            pWriterNode->SetRecorderNode(NULL);
            pRecorderNode->SetWriterNode(NULL);

            // Ignore failed return status - the writer node has been deleted.
            hr = CloseWriterFile(&pWriterNode->leListEntry);
        }

        if (bLockedMultiFileRecorder)
        {
            HRESULT hr = pFileCollection->Unlock(pFileCollectionInfo,
                                                 bReleaseSharedMemoryLock,
                                                 bDecrementInconsistencyDataCounter);
            DVR_ASSERT(SUCCEEDED(hr), "pFileCollection->Unlock failed");
        }
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // CDVRRingBufferWriter::CloseTempFileOfMultiFileRecording

HRESULT CDVRRingBufferWriter::CloseMultiFileRecording(IN PASF_RECORDER_NODE pRecorderNode)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CloseMultiFileRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;
    HRESULT     hr;

    DVR_ASSERT(pRecorderNode, "");

    PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode = pRecorderNode->pMultiFileRecorder;

    DVR_ASSERT(pMultiFileRecorderNode, "");

    // =================
    // NOTE: If this function fails, it may be necessary to record the
    // failure in pRecorderNode->hrRet
    // =================

    // Ignore returned status, just go on. No need to record this
    // failure in pRecorderNode->hrRet because if there was a temp
    // file to be closed, no samples were written to the multi file recording
    hr = CloseTempFileOfMultiFileRecording(pRecorderNode);

    // Recording completed and file is being closed. Pull node out
    // of m_leRecordersList. This must be done while holding
    // m_csLock (and all calls to this fn do hold the lock)
    if (!LIST_NODE_POINTERS_NULL(&pRecorderNode->leListEntry))
    {
        RemoveEntryList(&pRecorderNode->leListEntry);
        NULL_LIST_NODE_POINTERS(&pRecorderNode->leListEntry);
    }

    if (!LIST_NODE_POINTERS_NULL(&pMultiFileRecorderNode->leListEntry))
    {
        RemoveEntryList(&pMultiFileRecorderNode->leListEntry);
        NULL_LIST_NODE_POINTERS(&pMultiFileRecorderNode->leListEntry);
    }

    if (pMultiFileRecorderNode->pFileCollection)
    {
        // @@@@ Unresolved issue: If the writer doesn't write the next sample and
        // leaves the current ASF file open for a long time, a reader of the
        // live multi file recording will wait after reading all the samples
        // in the recording (until the writer writes the next sample or closes
        // the file) even though the recording has been fully rendered. The "right"
        // thing to do seems to be to register an event for each file collection
        // (for an end of writing notification) with the DVR IStream Source and
        // signal it here. However, this is not worth doing, particularly since
        // the writer is not expected to pause writing.

        // hr is for debugging only
        hr = pMultiFileRecorderNode->pFileCollection->SetWriterHasBeenClosed(&pMultiFileRecorderNode->FileCollectionInfo);
    }

    pRecorderNode->SetFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
    if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::RecorderNodeDeleted))
    {
        delete pRecorderNode;
    }
    else if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::PersistentRecording))
    {
        pRecorderNode->ClearFlags(ASF_RECORDER_NODE::PersistentRecording);
        pRecorderNode->pRecorderInstance->Release();
        // At this point, pRecorderNode could have been deleted by DeleteRecorder()
    }


    hrRet = S_OK;

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // CDVRRingBufferWriter::CloseMultiFileRecording


// Note: It is expected that the recording will be closed after this method completes
// (without writing any more samples to it). The nLastFileId in pMultiFileRecorderNode
// is NOT changed in this method, but that file could have been deleted and removed from the
// file collection.
HRESULT CDVRRingBufferWriter::DeleteFilesFromMultiFileRecording(IN PASF_RECORDER_NODE pRecorderNode)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::DeleteFilesFromMultiFileRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;
    BOOL        bReleaseSharedMemoryLock = 0;
    BOOL        bLockedMultiFileRecorder = 0;
    BOOL        bDecrementInconsistencyDataCounter = 0;
    CDVRFileCollection::PDVRIOP_FILE_TIME   pFileTimes = NULL;

    DVR_ASSERT(pRecorderNode, "");

    PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode = pRecorderNode->pMultiFileRecorder;

    DVR_ASSERT(pMultiFileRecorderNode, "");

    CDVRFileCollection* pFileCollection = pMultiFileRecorderNode->pFileCollection;
    CDVRFileCollection::CClientInfo* pFileCollectionInfo = &(pMultiFileRecorderNode->FileCollectionInfo);

    DVR_ASSERT(pFileCollection, "");


    __try
    {

        HRESULT hr;

        if (FAILED(pRecorderNode->hrRet))
        {
            hrRet = pRecorderNode->hrRet;
            __leave;
        }

        hr = pFileCollection->Lock(pFileCollectionInfo, bReleaseSharedMemoryLock, 1);
        bLockedMultiFileRecorder = 1;
        if (FAILED(hr))
        {
            hrRet = hr;
            bDecrementInconsistencyDataCounter = 0;
            __leave;
        }
        bDecrementInconsistencyDataCounter = 1;

        QWORD cnsFileEndTime = pRecorderNode->cnsEndTime - pRecorderNode->cnsStartTime;

        hr = pFileCollection->GetLastValidTimeBefore(pFileCollectionInfo, cnsFileEndTime, &cnsFileEndTime);

        if (FAILED(hr))
        {
            DVR_ASSERT(hr != E_FAIL, "Unexpected: GetFirstValidTimeBefore failed, should have found file for start recording time = 0");
            hrRet = hr;
            __leave;
        }

        QWORD   cnsLastStreamTimeRecorder;

        hr = pFileCollection->GetLastStreamTime(pFileCollectionInfo, &cnsLastStreamTimeRecorder, 0 /* do not lock, already locked */);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Set the extent on the file collection first. Readers will not try to read beyond this
        // time. If any of the subsequent steps fail, we don't have to worry about consistency
        // (e.g we may have deleted some files but not called SetFileTimes to remove the extra
        // file nodes from the file collection). [Aside: Note that there is no guarantee that
        // there are samples between the start time and cnsFileEndTime. The guarantee is that
        // there are one or more file spanning this time (shouldn't be > 1 file if there are no
        // samples).]


        if (FAILED(pRecorderNode->hrRet) && cnsLastStreamTimeRecorder >= cnsFileEndTime)
        {
            // Evidently the failure occurred after the recording's end time
            pRecorderNode->hrRet = S_OK;
        }

        hr = pFileCollection->SetLastStreamTime(pFileCollectionInfo, cnsFileEndTime, 0 /* do not lock, already locked */);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        cnsLastStreamTimeRecorder = cnsFileEndTime;

        QWORD                               cnsFileStartTime;
        LPWSTR                              pwszFileName;
        CDVRFileCollection::DVRIOP_FILE_ID  nFileId;
        DWORD                               dwNumNodesToUpdate = 0;

        hr = pFileCollection->GetFileAtTime(pFileCollectionInfo,
                                                           // Reader index, unused if bFileWillBeOpened == 0
                                            cnsFileEndTime,
                                            NULL,          // pwszFileName,
                                            NULL,          // cnsFirstSampleTimeOffsetFromStartOfFile,
                                            &nFileId,
                                            0              // bFileWillBeOpened
                                           );
        if (FAILED(hr))
        {
            // We know we have a file
            DVR_ASSERT(0, "Unexpected: GetFileAtTime failed for file at pRecorderNode->cnsEndTime");
            hrRet = hr;
            __leave;
        }

        hr = pFileCollection->GetTimeExtentForFile(pFileCollectionInfo,
                                                   nFileId,
                                                   &cnsFileStartTime,
                                                   &cnsFileEndTime);
        if (FAILED(hr))
        {
            DVR_ASSERT(0, "Unexpected: GetTimeExtentForFile failed for file at pRecorderNode->cnsEndTime");
            hrRet = hr;
            __leave;
        }

        CDVRFileCollection::DVRIOP_FILE_TIME    ft[1];

        ft[dwNumNodesToUpdate].nFileId = nFileId;
        ft[dwNumNodesToUpdate].cnsStartTime = cnsFileStartTime;
        ft[dwNumNodesToUpdate].cnsEndTime = cnsLastStreamTimeRecorder + 1;
        dwNumNodesToUpdate++;

        DVR_ASSERT(cnsLastStreamTimeRecorder >= cnsFileStartTime, "");

        hr = pFileCollection->SetFileTimes(pFileCollectionInfo, dwNumNodesToUpdate, &ft[0]);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        DVR_ASSERT(hr == S_OK, "S_FALSE unexpected - multi file recording should have files");

        // Skip over time holes
        DVR_ASSERT(cnsFileEndTime >= 1, "");
        hr = pFileCollection->GetFirstValidTimeAfter(pFileCollectionInfo, cnsFileEndTime - 1, &cnsFileEndTime);

        if (FAILED(hr) && hr != E_FAIL)
        {
            hrRet = hr;
            __leave;
        }

        QWORD cnsFirstFileToDeleteStartTime = cnsFileEndTime;

        dwNumNodesToUpdate = 0;
        while (SUCCEEDED(hr))
        {
            dwNumNodesToUpdate++;

            hr = pFileCollection->GetFileAtTime(pFileCollectionInfo,
                                                               // Reader index, unused if bFileWillBeOpened == 0
                                                cnsFileEndTime,
                                                &pwszFileName,
                                                NULL,          // cnsFirstSampleTimeOffsetFromStartOfFile,
                                                &nFileId,
                                                0              // bFileWillBeOpened
                                               );
            if (FAILED(hr))
            {
                // We know we have a file
                DVR_ASSERT(0, "Unexpected: GetFileAtTime failed but GetFirstValidTimeAfter had succeeded");
                hrRet = hr;
                __leave;
            }

            // We can delete the file (this is actually our hard link to the data file)
            // Note that all our readers specify FILE_SHARE_DELETE so the delete will
            // succeed even if readers have the file open.

            // We ignore the returned status - there is not much we can do if the delete
            // failed
            ::DeleteFileW(pwszFileName);
            delete [] pwszFileName;
            pwszFileName = NULL;

            hr = pFileCollection->GetTimeExtentForFile(pFileCollectionInfo,
                                                       nFileId,
                                                       NULL,
                                                       &cnsFileEndTime);
            if (FAILED(hr))
            {
                DVR_ASSERT(0, "Unexpected: GetTimeExtentForFile failed");
                hrRet = hr;
                __leave;
            }

            // Skip over time holes
            DVR_ASSERT(cnsFileEndTime >= 1, "");
            hr = pFileCollection->GetFirstValidTimeAfter(pFileCollectionInfo, cnsFileEndTime - 1, &cnsFileEndTime);

            if (FAILED(hr) && hr != E_FAIL)
            {
                hrRet = hr;
                __leave;
            }
        }

        // Remove the file nodes for files beyond the recording's time extent.

        if (dwNumNodesToUpdate > 0)
        {
            pFileTimes = new CDVRFileCollection::DVRIOP_FILE_TIME[dwNumNodesToUpdate];
            if (pFileTimes == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - %u bytes",
                                dwNumNodesToUpdate*sizeof(CDVRFileCollection::DVRIOP_FILE_TIME));

                hrRet = E_OUTOFMEMORY; // out of stack space
                __leave;
            }

            hr = S_OK;
            cnsFileEndTime = cnsFirstFileToDeleteStartTime;

            DWORD i = 0;

            while (SUCCEEDED(hr))
            {
                DVR_ASSERT(i < dwNumNodesToUpdate, "");

                hr = pFileCollection->GetFileAtTime(pFileCollectionInfo,
                                                                   // Reader index, unused if bFileWillBeOpened == 0
                                                    cnsFileEndTime,
                                                    NULL,          // pwszFileName,
                                                    NULL,          // cnsFirstSampleTimeOffsetFromStartOfFile,
                                                    &nFileId,
                                                    0              // bFileWillBeOpened
                                                   );
                if (FAILED(hr))
                {
                    // We know we have a file
                    DVR_ASSERT(0, "Unexpected: GetFileAtTime failed - had succeeded before");
                    hrRet = hr;
                    __leave;
                }


                hr = pFileCollection->GetTimeExtentForFile(pFileCollectionInfo,
                                                           nFileId,
                                                           &cnsFileStartTime,
                                                           &cnsFileEndTime);
                if (FAILED(hr))
                {
                    DVR_ASSERT(0, "Unexpected: GetTimeExtentForFile failed - had succeeded before");
                    hrRet = hr;
                    __leave;
                }

                pFileTimes[i].nFileId = nFileId;
                pFileTimes[i].cnsStartTime = cnsFileStartTime;
                pFileTimes[i].cnsEndTime = cnsFileStartTime;

                // Skip over time holes
                DVR_ASSERT(cnsFileEndTime >= 1, "");
                hr = pFileCollection->GetFirstValidTimeAfter(pFileCollectionInfo, cnsFileEndTime - 1, &cnsFileEndTime);

                if (FAILED(hr) && hr != E_FAIL)
                {
                    DVR_ASSERT(0, "Unexpected: GetFirstValidTimeAfter failed - had succeeded before");
                    hrRet = hr;
                    __leave;
                }
                i++;
            }
            DVR_ASSERT(i == dwNumNodesToUpdate, "");

            hr = pFileCollection->SetFileTimes(pFileCollectionInfo, dwNumNodesToUpdate, pFileTimes);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            if (hr == S_FALSE)
            {
                DVR_ASSERT(hr == S_OK, "S_FALSE unexpected - multi file recording should have files");
                hrRet = E_FAIL;
                __leave;
            }
        }

        hrRet = S_OK;
    }
    __finally
    {
        if (SUCCEEDED(pRecorderNode->hrRet) && FAILED(hrRet))
        {
            pRecorderNode->hrRet = hrRet;
            HRESULT hr = pFileCollection->SetWriterHasBeenClosed(pFileCollectionInfo); // hr is for debugging only
        }

        if (bLockedMultiFileRecorder)
        {
            HRESULT hr = pFileCollection->Unlock(pFileCollectionInfo,
                                                 bReleaseSharedMemoryLock,
                                                 bDecrementInconsistencyDataCounter);
            DVR_ASSERT(SUCCEEDED(hr), "pFileCollection->Unlock failed");
        }

        delete [] pFileTimes;
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // CDVRRingBufferWriter::DeleteFilesFromMultiFileRecording

// ====== Public methods to support the recorder

HRESULT CDVRRingBufferWriter::StartRecording(IN     LPVOID  pRecorderId,
                                             IN OUT QWORD * pcnsStartTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::StartRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    ASSERT (pcnsStartTime) ;

    if ((* pcnsStartTime) == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "Start time of MAXQWORD is invalid.");
        hrRet = E_INVALIDARG;
        DVRIO_TRACE_LEAVE1_HR(hrRet);
        return hrRet;
    }

    LIST_ENTRY* pInsert = NULL;
    BOOL        bIrrecoverableError = 0;
    LIST_ENTRY  leCloseFilesList;
    BOOL        bReleaseSharedMemoryLock = 0;
    BOOL        bLockedSharedMemory = 0;
    CDVRFileCollection::PDVRIOP_FILE_TIME   pFileTimes = NULL;

    InitializeListHead(&leCloseFilesList);

    ::EnterCriticalSection(&m_csLock);
    __try
    {
        HRESULT     hr;
        LIST_ENTRY* pCurrent;
        LIST_ENTRY* pStart = (LIST_ENTRY*) pRecorderId;

        // Verify if the node is in the recorder's list.

        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            if (pCurrent == pStart)
            {
                break;
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        if (pCurrent == &m_leFreeList)
        {
            // Didn't find the node

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Did not find recorder node id 0x%x in the recorders list",
                            pStart);
            hrRet = E_FAIL;
            __leave;
        }

        PASF_RECORDER_NODE  pRecorderNode;
        PASF_WRITER_NODE    pWriterNode;

        pRecorderNode = CONTAINING_RECORD(pStart, ASF_RECORDER_NODE, leListEntry);
        pWriterNode = pRecorderNode->pWriterNode;

        if (pRecorderNode->cnsStartTime != MAXQWORD)
        {
            // Recording already started?!
            DVR_ASSERT(pRecorderNode->cnsStartTime == MAXQWORD, "Recording already started");
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Recording already started on the recorder node id=0x%x at time %I64u",
                            pStart, pRecorderNode->cnsStartTime);
            hrRet = E_FAIL;
            __leave;
        }
        if (pRecorderNode->cnsEndTime != MAXQWORD)
        {
            // Recording already stopped without having been started?!
            DVR_ASSERT(pRecorderNode->cnsEndTime == MAXQWORD,
                       "Recording already stopped, but wasn't started?!");
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Recording already stopped on the recorder node id=0x%x at time %I64u, start time is MAXQWORD",
                            pStart, pRecorderNode->cnsEndTime);
            hrRet = E_FAIL;
            __leave;
        }
        if (!pWriterNode)
        {
            DVR_ASSERT(pRecorderNode->pWriterNode, "");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWriterNode of the recorder node id=0x%x is NULL",
                            pStart);
            hrRet = E_FAIL;
            __leave;
        }

        //  if we're a content recording, call BeginWriting now
        if (pWriterNode -> IsFlagSet (ASF_WRITER_NODE::WriterNodeContentRecording)) {
            DVR_ASSERT (pWriterNode->pWMWriter, "") ;
            hrRet = pWriterNode->pWMWriter->BeginWriting();
            if (FAILED (hrRet)) {
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "Content recording %s failed to start; BeginWriting call failed: %08xh",
                                pWriterNode -> pwszFileName, hrRet);

                pWriterNode->hrRet = hrRet;
                pRecorderNode->hrRet = hrRet;
                __leave ;
            }
        }

        // Branch off here
        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
        {
            if (!IsFlagSet(SampleWritten))
            {
                pRecorderNode->cnsStartTime = (* pcnsStartTime);
                hrRet = S_OK;
            }
            else
            {
                // We are going to hold on to the writer's file collection lock
                // for the duration of the call to ExtendMultiFileRecording().
                // If we release the lock here and a reader got it, it could
                // remove a temp file from the file collection and that may be
                // the file that we want to add to the multi file recording.

                QWORD   cnsStartStreamTime;
                BOOL    bRecordingCompleted;

                hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
                bLockedSharedMemory = 1;
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }

                hr = m_pDVRFileCollection->GetTimeExtent(&m_FileCollectionInfo, &cnsStartStreamTime, NULL);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }

                (* pcnsStartTime) = Max <QWORD> (cnsStartStreamTime, (* pcnsStartTime)) ;

                pRecorderNode->cnsStartTime = (* pcnsStartTime);
                hr = ExtendMultiFileRecording(pRecorderNode, bRecordingCompleted);

                // The recording could not have completed since we don't know the
                // end recording time.
                DVR_ASSERT(bRecordingCompleted == 0, "");

                if (FAILED(hr))
                {
                    // If ExtendMultiFileRecording() fails,. the recording itself has
                    // failed, i.e., we won't try to write any more samples to the
                    // recording. For failures until here, only StartRecording fails;
                    // subsequent calls to StartRecording could succeed.

                    // Note that pRecorderNode->hrRet would also have a failure status
                    DVR_ASSERT(FAILED(pRecorderNode->hrRet), "");
                    hrRet = hr;
                    __leave;
                }
                hrRet = S_OK;
            }

            DVR_ASSERT(SUCCEEDED(hrRet), "Should not get here");
            pRecorderNode->ClearFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
            InsertTailList(&m_leActiveMultiFileRecordersList, &pRecorderNode->pMultiFileRecorder->leListEntry);

            __leave;
        }

        // The following checks are valid only for single file recordings

        QWORD cnsCurrentStreamTime;
        hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &cnsCurrentStreamTime);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (IsFlagSet(WriterClosed))
        {
            // The recorders list will not be empty if a recording had been
            // created but had not been started before the writer was closed.
            // We should not allow the recording to be started now.
            hrRet = E_UNEXPECTED;
            __leave;
        }
        if (IsFlagSet(SampleWritten) && (* pcnsStartTime) <= cnsCurrentStreamTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Start time (%I64u) is <= current stream time (%I64u)",
                            (* pcnsStartTime), cnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }
        if (!IsFlagSet(SampleWritten) && (* pcnsStartTime) < m_cnsFirstSampleTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Start time (%I64u) is < first sample time (%I64u)",
                            (* pcnsStartTime), m_cnsFirstSampleTime);
            hrRet = E_INVALIDARG;
            __leave;
        }

        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }

        // Remove the node from the recorder's list
        RemoveEntryList(pStart);
        NULL_LIST_NODE_POINTERS(pStart);
        pInsert = pStart;

        // Verify that (* pcnsStartTime) follows the start time of all
        // other recordings.
        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            PASF_RECORDER_NODE pTmpNode;

            pTmpNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);
            if (!pTmpNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
            {
                if (pTmpNode->cnsStartTime != MAXQWORD)
                {
                    // If pTmpNode->cnsEndTime == MAXQWORD, StopRecording
                    // has not been called on pTmpNode; we cannot allow
                    // StartRecording to be called on this node.
                    if (pTmpNode->cnsEndTime > (* pcnsStartTime))
                    {
                        DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                        "Recorder node id=0x%x end time (%I64u) >= (* pcnsStartTime) (%I64u)",
                                        pCurrent, pTmpNode->cnsEndTime, (* pcnsStartTime));
                        hrRet = E_INVALIDARG;
                        __leave;
                    }
                    // All ok
                    break;
                }
                else
                {
                    DVR_ASSERT(pTmpNode->cnsEndTime == MAXQWORD, "");
                }
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        // Determine where in the writer's list to add this node and
        // whether to change the file times of other writer nodes

        DWORD dwNumNodesToUpdate = 0;
        pCurrent = NEXT_LIST_NODE(&m_leWritersList);
        while (pCurrent != &m_leWritersList)
        {
            PASF_WRITER_NODE pTmpNode;

            pTmpNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

            if (pTmpNode->cnsStartTime == MAXQWORD)
            {
                break;
            }
            if (// Redundant: pTmpNode->cnsStartTime >= (* pcnsStartTime) ||
                pTmpNode->cnsEndTime > (* pcnsStartTime))
            {
                // We have verified that the end times of all recorders is
                // < (* pcnsStartTime). So this is a temporary node
                DVR_ASSERT(pTmpNode->pRecorderNode == NULL,
                           "Node must be a temporary node");

                dwNumNodesToUpdate++;
            }
            else if (pTmpNode->cnsEndTime == (* pcnsStartTime))
            {
                // Nothing to do. Note that start time of this
                // node may be equal to the end time because
                // we made a previous call to SetFileTimes and
                // did not close the writer node (this should
                // not happen the way the code is currently structured).
                // This is ok, when calling SetFileTimes, we skip
                // over such nodes
                DVR_ASSERT(pTmpNode->cnsStartTime < (* pcnsStartTime),
                           "Node should have been removed from the writers list.");
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }

        if (dwNumNodesToUpdate > 0)
        {
            pFileTimes = new CDVRFileCollection::DVRIOP_FILE_TIME[dwNumNodesToUpdate];
            if (pFileTimes == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - %u bytes",
                                dwNumNodesToUpdate*sizeof(CDVRFileCollection::DVRIOP_FILE_TIME));

                hrRet = E_OUTOFMEMORY; // out of stack space
                __leave;
            }

            DWORD i = 0;
            LIST_ENTRY* pRemove = NULL;

            pCurrent = NEXT_LIST_NODE(&m_leWritersList);
            while (pCurrent != &m_leWritersList)
            {
                PASF_WRITER_NODE pTmpNode;

                pTmpNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

                if (pTmpNode->cnsStartTime == MAXQWORD)
                {
                    break;
                }
                if (// Redundant: pTmpNode->cnsStartTime >= (* pcnsStartTime) ||
                    pTmpNode->cnsEndTime > (* pcnsStartTime))
                {
                    // We have asserted in the previous loop that
                    // these nodes are all temporary nodes

                    pFileTimes[i].nFileId = pTmpNode->nFileId;
                    if (pTmpNode->cnsStartTime < (* pcnsStartTime))
                    {
                        // New start time is the same as the old one
                        // End time changed to recorder's start time
                        pFileTimes[i].cnsStartTime = pTmpNode->cnsStartTime;
                        pTmpNode->cnsEndTime = pFileTimes[i].cnsEndTime  = (* pcnsStartTime);
                    }
                    else if (pTmpNode->cnsStartTime == (* pcnsStartTime))
                    {
                        // we are going to tell the file collection object
                        // to delete this temporary node by setting its
                        // start time = end time
                        pTmpNode->cnsStartTime = pFileTimes[i].cnsStartTime = (* pcnsStartTime);
                        pTmpNode->cnsEndTime = pFileTimes[i].cnsEndTime  = (* pcnsStartTime);
                        DVR_ASSERT(pRemove == NULL,
                                   "a) There are 2 nodes in the writers list with the same start time AND with end time > start time OR b) the writers list is not sorted by start,end time");
                        pRemove = pCurrent;
                    }
                    else
                    {
                        // we are going to tell the file collection object
                        // to delete this temporary node by setting its
                        // start time = end time. Note that the recording
                        // file is going to have a stop time of MAXQWORD

                        // NOTE: Because of this there CAN NEVER BE temporary
                        // nodes following a permanent node in m_leWritersList
                        // and in the file collection object UNLESS the
                        // recording node is being written to.

                        if (!pRemove)
                        {
                            pRemove = pCurrent;
                        }
                        pFileTimes[i].cnsStartTime = pTmpNode->cnsStartTime;
                        pTmpNode->cnsEndTime = pFileTimes[i].cnsEndTime  = pTmpNode->cnsStartTime;
                    }
                    i++;
                }
                else if (pTmpNode->cnsEndTime == (* pcnsStartTime))
                {
                    // Nothing to do. Note that start time of this
                    // node may be equal to the end time because
                    // we made a previous call to SetFileTimes and
                    // did not close the writer node (this should
                    // not happen the way the code is currently structured).
                    // This is ok, when calling SetFileTimes, we skip
                    // over such nodes
                }
                pCurrent = NEXT_LIST_NODE(pCurrent);
            }
            DVR_ASSERT(i == dwNumNodesToUpdate, "");

            // We can be smart and restore state of the writers list
            // (restore the start, end times on writer nodes, insert pRemove)
            // but this is not worth it. We should not have any errors
            // after this - any error ought to be a bug and should be
            // fixed.
            bIrrecoverableError = 1;

            if (pRemove)
            {
                // Remove all nodes after this one in m_leWritersList
                // (including pRemove)
                // Note that all these nodes are temporary files; this has been
                // asserted in the while loop above.

                BOOL bStop = 0;

                pCurrent = PREVIOUS_LIST_NODE(&m_leWritersList);
                while (!bStop)
                {
                    bStop = (pCurrent == pRemove);

#if defined(DEBUG)
                    PASF_WRITER_NODE pTmpNode;

                    pTmpNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

                    DVR_ASSERT(pTmpNode->pRecorderNode == NULL, "Node should be a temp one.");
#endif

                    RemoveEntryList(pCurrent);

                    // As explained in StopRecording and SetFirstSampleTime, we close these files
                    // after setting the file times on the file collection object and priming a
                    // writer file. This delays sending the EOF notification to the reader until the
                    // file collection object has been cleaned up. Note that, as in StopRecording,
                    // we need to do this only if
                    // !IsFlagSet(SampleWritten) && (* pcnsStartTime) == cnsCurrentStreamTime.
                    // However, we just do it always. An alternative to delaying the closing of these
                    // files is to grab the file collection lock and unlock it only after we have
                    // completed updating the file collection - we use that approach in SetFirstSampleTime.
                    //
                    // WAS:
                    // NULL_LIST_NODE_POINTERS(pCurrent);
                    // Ignore failed return status - the writer node has been deleted.
                    // hr = CloseWriterFile(pCurrent);
                    InsertHeadList(&leCloseFilesList, pCurrent);

                    pCurrent = PREVIOUS_LIST_NODE(&m_leWritersList);
                }
            }
            hr = m_pDVRFileCollection->SetFileTimes(&m_FileCollectionInfo, dwNumNodesToUpdate, pFileTimes);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else
            {
                // S_FALSE is ok; the list could have got empty if (* pcnsStartTime) = 0
                // and we have not yet written a sample
            }
        }

        // Add the file to the file collection object
        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->AddFile(&m_FileCollectionInfo,
                                           (LPWSTR*) &pRecorderNode->pwszFileName,
                                           0,                   // bOpenFromFileCollectionDirectory
                                           (* pcnsStartTime),
                                           pRecorderNode->cnsEndTime,
                                           TRUE,                // bPermanentFile,
                                           0,                   // bDeleteTemporaryFiles, ignored if bPermanentFile is set
                                           kInvalidFirstSampleOffsetTime,
                                           &pWriterNode->nFileId);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Add the writer node to the writer's list
        bIrrecoverableError = 1;
        pRecorderNode->cnsStartTime = pWriterNode->cnsStartTime = (* pcnsStartTime);
        pRecorderNode->cnsEndTime = pWriterNode->cnsEndTime = MAXQWORD;
        hr = AddToWritersList(&pWriterNode->leListEntry);
        if (FAILED(hr))
        {
            // ??!! This should never happen
            DVR_ASSERT(0, "Insertion of recorder into writers list failed");
            hrRet = hr;
            __leave;
        }

        pInsert = NULL;

        // Re-insert the recorder node in the recorder's list
        hr = AddToRecordersList(pStart);
        if (FAILED(hr))
        {
            // ??!! This should never happen
            DVR_ASSERT(0, "Insertion of recorder into writers list failed");
            hrRet = hr;
            __leave;
        }

        pRecorderNode->ClearFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
            // If StartRecording did not succeed, we don't clear the DeleteRecorderNode flag.
            // We let DeleteRecorder delete the node (whenever it is called) if we exit
            // with failure. This is not an issue - if bIrrecoverableError
            // is non-zero, we disallow operations such as WriteSample,
            // StartRecording and StopRecording. If bIrrecoverableError is 0,
            // pRecorderNode->cnsStartTime  is still MAXQWORD and the
            // client will either have to call StartRecording on this node
            // once again or delete it.


        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;

        if (pInsert)
        {
            // Ignore the returned status; AddToRecordersList
            // has already logged  the error
            hr = AddToRecordersList(pInsert);
        }

        LIST_ENTRY* pCurrent;

        pCurrent = PREVIOUS_LIST_NODE(&leCloseFilesList);
        while (pCurrent != &leCloseFilesList)
        {
            RemoveEntryList(pCurrent);

            NULL_LIST_NODE_POINTERS(pCurrent);

            // Ignore failed return status - the writer node has been deleted.
            hr = CloseWriterFile(pCurrent);

            pCurrent = PREVIOUS_LIST_NODE(&leCloseFilesList);
        }

        if (FAILED(hrRet) && bIrrecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
        }

        if (bLockedSharedMemory)
        {
            hr = m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock);
            DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->Unlock failed");
        }

        ::LeaveCriticalSection(&m_csLock);

        delete [] pFileTimes;

        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::StartRecording


HRESULT CDVRRingBufferWriter::StopRecording(IN LPVOID pRecorderId,
                                            IN QWORD  cnsStopTime,
                                            IN BOOL   bNow,
                                            IN BOOL   bCancelIfNotStarted)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::StopRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    if (cnsStopTime == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                        "Stop time of MAXQWORD is invalid.");
        hrRet = E_INVALIDARG;
        DVRIO_TRACE_LEAVE1_HR(hrRet);
        return hrRet;
    }

    BOOL        bIrrecoverableError = 0;
    LIST_ENTRY* pWriterNodeToBeClosed = NULL;

    ::EnterCriticalSection(&m_csLock);
    __try
    {
        HRESULT     hr;
        LIST_ENTRY* pCurrent;
        LIST_ENTRY* pStop = (LIST_ENTRY*) pRecorderId;

        // Verify the node is in the recorder's list.

        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            if (pCurrent == pStop)
            {
                // Since cnsEndTime is MAXQWORD on this recorder
                // node, it's position in m_leRecordersList will not
                // change, i.e., setting the stop time will leave the
                // list sorted.
                // RemoveEntryList(pCurrent);
                break;
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        if (pCurrent == &m_leFreeList)
        {
            // Didn't find the node

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Did not find recorder node id 0x%x in the recorders list",
                            pStop);
            hrRet = E_FAIL;
            __leave;
        }

        PASF_RECORDER_NODE  pRecorderNode;

        pRecorderNode = CONTAINING_RECORD(pStop, ASF_RECORDER_NODE, leListEntry);

        QWORD cnsCurrentStreamTime;
        hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &cnsCurrentStreamTime);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (bNow)
        {
            cnsStopTime = cnsCurrentStreamTime+1;
        }

        if (bCancelIfNotStarted)
        {
            if (pRecorderNode->cnsStartTime > cnsCurrentStreamTime)
            {
                // Cancel it
                cnsStopTime = pRecorderNode->cnsStartTime;
            }
            else if (!IsFlagSet(SampleWritten) &&
                     pRecorderNode->cnsStartTime == cnsCurrentStreamTime)
            {
                // Cancel it
                cnsStopTime = pRecorderNode->cnsStartTime;
            }
        }

        if (pRecorderNode->cnsEndTime != MAXQWORD &&
            pRecorderNode->cnsStartTime != cnsStopTime // Recording is not being cancelled
           )
        {
            // Recording already stopped and caller is not cancelling the recording
            DVR_ASSERT(pRecorderNode->cnsEndTime == MAXQWORD, "Recording already stopped");
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Recording already stopped on the recorder node id=0x%x at time %I64u",
                            pStop, pRecorderNode->cnsEndTime);
            hrRet = E_FAIL;
            __leave;
        }
        if (pRecorderNode->cnsStartTime == MAXQWORD)
        {
            // Recording not started
            DVR_ASSERT(pRecorderNode->cnsStartTime != MAXQWORD,
                       "Recording not yet started?!");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Recording not started on the recorder node id=0x%x, start time is MAXQWORD",
                            pStop);
            hrRet = E_FAIL;
            __leave;
        }
        if (cnsStopTime < pRecorderNode->cnsStartTime)
        {
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Recorder node id=0x%x, start time (%I64u) > stopTime (%I64u)",
                            pStop, pRecorderNode->cnsStartTime, cnsStopTime);
            hrRet = E_INVALIDARG;
            __leave;
        }
        if (pRecorderNode->cnsStartTime == cnsStopTime &&
            IsFlagSet(SampleWritten) &&
            cnsCurrentStreamTime >= pRecorderNode->cnsStartTime)
        {
            // We could allow cancelling multi file recordings even if we have written to
            // them, but it's just as easy for the caller to stop the recording and delete
            // it. Disallowing this makes things uniform.

            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Recorder node id=0x%x, start time (%I64u) < current stream time (%I64u)",
                            pStop, pRecorderNode->cnsStartTime, cnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }

        // Branch off here
        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
        {
            if (pRecorderNode->cnsStartTime == cnsStopTime)
            {
                // Recording is being cancelled

                // We have not written a sample to this recording as yet -
                // the tests above and the way ExtendMultiFileRecording is
                // structured ensure that. Note that the multi file recording
                // will have NO files in it after CloseTempFileOfMultiFileRecording
                // is done and its start and end time extents will both be 0.
                // This is similar to the case described in ExtendMultiFileRecording
                // where the start/stop time interval specified does not contain
                // any samples.
                DVR_ASSERT(pRecorderNode->pWriterNode, "");

                pRecorderNode->cnsEndTime = cnsStopTime;

                // Ignore return status
                hr = CloseMultiFileRecording(pRecorderNode);

                // pRecorderNode may have been deleted; do not refer to it
                pRecorderNode = NULL;
                hrRet = S_OK;
                __leave;
            }

            // Stopping the recording

            if (cnsStopTime > cnsCurrentStreamTime + 1)
            {
                // Just record the stop time
                pRecorderNode->cnsEndTime = cnsStopTime;
                hrRet = S_OK;
                __leave;
            }

            if (cnsStopTime == cnsCurrentStreamTime + 1)
            {
                // We've hit things just right
                pRecorderNode->cnsEndTime = cnsStopTime;

                if (SUCCEEDED(pRecorderNode->hrRet))
                {
                    pRecorderNode->hrRet = S_OK;
                }

                // Ignore return status; this function will
                // record failures in pRecorderNode->hrRet
                // if necessary
                hr = CloseMultiFileRecording(pRecorderNode);

                // pRecorderNode may have been deleted; do not refer to it
                pRecorderNode = NULL;

                hrRet = S_OK;
                __leave;
            }

            // The stop recording time is in the past. We may have
            // to remove files from the multi file recording and
            // down adjust the extent. This will confuse live readers
            // that have read past the stop time, but note that the
            // next call to GetNextSample will return EOF.

            // Note also that if the start/stop interval does not
            // contain any media samples, the multi file recording
            // will still have at least 1 file in this case.

            pRecorderNode->cnsEndTime = cnsStopTime;
            hr = DeleteFilesFromMultiFileRecording(pRecorderNode);

            if (SUCCEEDED(pRecorderNode->hrRet))
            {
                if (FAILED(hr))
                {
                    pRecorderNode->hrRet = hr;
                }
                else
                {
                    pRecorderNode->hrRet = S_OK;
                }
            }

            // if FAILED(hr), go ahead and close the recording anyway.

            // Ignore return status; this function will
            // record failures in pRecorderNode->hrRet
            // if necessary
            hr = CloseMultiFileRecording(pRecorderNode);

            // pRecorderNode may have been deleted; do not refer to it
            pRecorderNode = NULL;

            hrRet = S_OK;
            __leave;
        }

        // The following checks are valid only for single file recordings

        if (IsFlagSet(WriterClosed))
        {
            // The recorders list will not be empty if a recording had been
            // created but had not been started before the writer was closed.
            // We should not allow the recording to be started now.

            // This operation will fail below anyway because we'll discover
            // that the recording had not been started. .

            hrRet = E_UNEXPECTED;
            __leave;
        }
        if (IsFlagSet(SampleWritten) && cnsStopTime <= cnsCurrentStreamTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Stop time (%I64u) is <= current stream time (%I64u); WriteSample has been called",
                            cnsStopTime, cnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }

        // Note: Even if the first sample has not been written, the first recording's
        // start time can not be < cnsCurrentStreamTime; StartRecording and
        // SetFirstSampleTime enforce that. Setting cnsStopTime == cnsCurrentStreamTime
        // allows client to cancel the recording.
        if (!IsFlagSet(SampleWritten) && cnsStopTime < cnsCurrentStreamTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Stop time (%I64u) is < current stream time (%I64u); WriteSample has NOT been called",
                            cnsStopTime, cnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }


        PASF_WRITER_NODE    pWriterNode;
        pWriterNode = pRecorderNode->pWriterNode;
        if (!pWriterNode)
        {
            DVR_ASSERT(pRecorderNode->pWriterNode, "");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWriterNode of the recorder node id=0x%x is NULL",
                            pStop);
            hrRet = E_FAIL;
            __leave;
        }

        DVR_ASSERT(pRecorderNode->cnsStartTime == pWriterNode->cnsStartTime, "");

        // Set the times

        // Note that we set the time on the recorder node so the client cannot
        // stop recording again or cancel it if this function fails after this.
        // We also set bIrrecoverableError, so StartRecording, StopRecording
        // and WriteSample will fail anyway.
        pRecorderNode->cnsEndTime = pWriterNode->cnsEndTime = cnsStopTime;
        bIrrecoverableError = 1;

        if (cnsStopTime > pRecorderNode->cnsStartTime)
        {
            // Stop time is being set

            // There are 2 cases to consider here.
            // (a) We have started writing to the recorder file. In this case,
            //     the previous file's time (in m_leWritersList) cannot be changed
            //     and there can be a temporary node after this one
            // (b) We have not written to the recorder file yet. In this case,
            //     there CANNOT be a temp node after this one (or a permanent
            //     one for that matter since we are setting the stop time).
            //     A note in StartRecording explains why there cannot be a temp
            //     file after this node.
            // In either case, we have to adjust the times of at most 2 files, the
            // previous file in the writers list is not affected by setting the
            // stop recording time (since the recording is not being cancelled).

            DWORD               dwNumNodesToUpdate = 0;
            CDVRFileCollection::DVRIOP_FILE_TIME    ft[2];
            LIST_ENTRY*         pWriter = &(pWriterNode->leListEntry);
            LIST_ENTRY*         pNext = NEXT_LIST_NODE(pWriter);
            PASF_WRITER_NODE    pNextWriter = (pNext == &m_leWritersList)? NULL : CONTAINING_RECORD(pNext, ASF_WRITER_NODE, leListEntry);

            // Both cases
            ft[dwNumNodesToUpdate].nFileId = pWriterNode->nFileId;
            ft[dwNumNodesToUpdate].cnsStartTime = pRecorderNode->cnsStartTime;
            ft[dwNumNodesToUpdate].cnsEndTime = cnsStopTime;
            dwNumNodesToUpdate++;

            if (IsFlagSet(SampleWritten) &&
                pRecorderNode->cnsStartTime <= cnsCurrentStreamTime)
            {
                // Case a
                if (!pNextWriter)
                {
                    // Next temp node has not been primed yet. Leave it as is
                }
                else
                {
                    // Assert it is a temporary node
                    DVR_ASSERT(pNextWriter->pRecorderNode == NULL,
                               "Setting end time on recorder node, next node in writers list is a recorder node?!");
                    DVR_ASSERT(pNextWriter->cnsStartTime == MAXQWORD, "");
                    DVR_ASSERT(pNextWriter->cnsEndTime == MAXQWORD, "");
                    ft[dwNumNodesToUpdate].nFileId = pNextWriter->nFileId;
                    ft[dwNumNodesToUpdate].cnsStartTime = pNextWriter->cnsStartTime = cnsStopTime;
                    ::SafeAdd(ft[dwNumNodesToUpdate].cnsEndTime, cnsStopTime, m_cnsTimeExtentOfEachFile);
                    pNextWriter->cnsEndTime = ft[dwNumNodesToUpdate].cnsEndTime;
                    dwNumNodesToUpdate++;

                    DVR_ASSERT(NEXT_LIST_NODE(pNext) == &m_leWritersList,
                               "More than 1 node following recorder node in writer list - we are setting its stop time?!");
                }
            }
            else
            {
                // Case b
                DVR_ASSERT(pNextWriter == NULL,
                           "Not written to this recorder node and it has a node following it in m_leWritersList");
            }

            hr = m_pDVRFileCollection->SetFileTimes(&m_FileCollectionInfo, dwNumNodesToUpdate, &ft[0]);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else if (hr != S_OK)
            {
                // S_FALSE is NOT ok; we have a recorder node in the list, file collection
                // cannot have got empty.
                // We have at least one node in the list.
                DVR_ASSERT(hr == S_OK, "hr = S_FALSE unexpected");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "SetFileTimes returns hr = 0x%x - unexpected.",
                                hr);
                hrRet = E_FAIL;
                __leave;
            }
        }
        else
        {
            // cnsStopTime == pRecorderNode->cnsStartTime, i.e., recording
            // is being cancelled. Stop time may or may not have been set earlier.

            // Note: There are no temporary nodes following this recording node.
            // See the note in start recording which explains why this is so -
            // note that no samples have been written to the recorder file as yet
            // (which is why we allow cancelling the recording). However if the
            // node before this is a temporary one, we may have to adjust its
            // end time.

            // We have to remove the node from the writers list, close the
            // writers file and remove the file from the file collection.
            // Then we have to determine whether to prime a new node (a
            // temporary file) to replace the one we removed.

            LIST_ENTRY*         pWriter = &(pWriterNode->leListEntry);
            LIST_ENTRY*         pPrev = PREVIOUS_LIST_NODE(pWriter);
            LIST_ENTRY*         pNext = NEXT_LIST_NODE(pWriter);
            PASF_WRITER_NODE    pPrevWriter = (pPrev == &m_leWritersList)? NULL : CONTAINING_RECORD(pPrev, ASF_WRITER_NODE, leListEntry);
            PASF_WRITER_NODE    pNextWriter = (pNext == &m_leWritersList)? NULL : CONTAINING_RECORD(pNext, ASF_WRITER_NODE, leListEntry);
            CDVRFileCollection::DVRIOP_FILE_TIME    ft[2];
            DWORD               dwNumNodesToUpdate = 0;

            if (pNextWriter)
            {
                DVR_ASSERT(pNextWriter->pRecorderNode == NULL,
                           "Node following recorder in writers list is a temp node.");
            }
            if (pPrevWriter && pPrevWriter->pRecorderNode == NULL)
            {
                QWORD   cnsTemp;

                ::SafeAdd(cnsTemp, pPrevWriter->cnsStartTime, m_cnsTimeExtentOfEachFile);

                DVR_ASSERT(pPrevWriter->cnsEndTime <= cnsTemp,
                           "A temporary node in the writers list has extent > m_cnsTimeExtentOfEachFile");

                if (pPrevWriter->cnsEndTime < cnsTemp)
                {
                    // We have asserted that the next writer is a permanent node above
                    if (pNextWriter && cnsTemp > pNextWriter->cnsStartTime)
                    {
                        cnsTemp = pNextWriter->cnsStartTime;
                    }
                    if (pPrevWriter->cnsEndTime != cnsTemp) // this test is redundant, will always succeed
                    {
                        // Adjust it
                        ft[dwNumNodesToUpdate].nFileId = pPrevWriter->nFileId;
                        ft[dwNumNodesToUpdate].cnsStartTime = pPrevWriter->cnsStartTime;
                        pPrevWriter->cnsEndTime = ft[dwNumNodesToUpdate].cnsEndTime = cnsTemp;
                        dwNumNodesToUpdate++;
                    }
                }
            }
            // Set start time = end time for the recorder's writer node.
            // Note that these may be less than cnsTemp. SetFileTimes should be
            // able to handle this since start time == end time
            ft[dwNumNodesToUpdate].nFileId = pWriterNode->nFileId;
            ft[dwNumNodesToUpdate].cnsStartTime = ft[dwNumNodesToUpdate].cnsEndTime = cnsStopTime;
            dwNumNodesToUpdate++;

            RemoveEntryList(pWriter);
            NULL_LIST_NODE_POINTERS(pWriter);

            // We defer closing the file till after the next node has been primed.
            // We do not want to leave the writer in a state in which all files have
            // been closed as that could confuse a reader of the ring buffer to believe
            // that it has hit EOF. (It is necessary to do this only if the reader could
            // be reading this file, which is possible only if
            // !IsFlagSet(SampleWritten) && cnsStopTime == cnsCurrentStreamTime.
            // However, it doesn't hurt to always do this.)
            //
            // WAS:
            // Ignore the returned status; the node is deleted if there was an error
            // hr = CloseWriterFile(pWriter);
            pWriterNodeToBeClosed = pWriter;

            hr = m_pDVRFileCollection->SetFileTimes(&m_FileCollectionInfo, dwNumNodesToUpdate, &ft[0]);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else
            {
                // S_FALSE is ok; the list could have become empty if cnsStopTime = m_cnsFirstSampleTime
                // and we have not yet written a sample; i.e., a recording was set
                // up starting at time t= m_cnsFirstSampleTime and is now being cancelled.
            }

            // Determine if we have to prime the writer's list
            BOOL bPrime = 0;
            // The start, end times passed to AddATemporaryFile
            QWORD               cnsTempStartTimeAddFile;
            QWORD               cnsTempEndTimeAddFile;

            if (pPrevWriter)
            {
                if (IsFlagSet(SampleWritten) &&
                    cnsCurrentStreamTime >= pPrevWriter->cnsStartTime &&
                    cnsCurrentStreamTime <= pPrevWriter->cnsEndTime &&
                    (!pNextWriter || pPrevWriter->cnsEndTime < pNextWriter->cnsStartTime)
                   )
                {
                    // Current writes are going to the previous node and the
                    // time extent of the previous node and the node we deleted
                    // are contiguous. The node that we deleted can be considered
                    // to have been the priming node.
                    //
                    // There is no need to prime here since WriteSample does that
                    // but we may as well

                    // If no sample has been written, we have a previous writer node
                    // which should cover the first write (by code design)

                    bPrime = 1;
                    cnsTempStartTimeAddFile = pPrevWriter->cnsEndTime;
                }
            }
            else
            {
                // If IsFlagSet(SampleWritten):
                // We know that cnsStopTime > cnsCurrentStreamTime. The node
                // corresponding to cnsCurrentStreamTime must be in the writers list
                // and it cannot have been closed by calling CloseAllWriterFilesBefore in
                // WriteSample (even in the case that m_cnsMaxStreamDelta = 0) because
                // WriteSamples closes files only if the file's end time is <=
                // cnsCurrentStreamTime - m_cnsMaxStreamDelta, i.e., all samples
                // in the file have times < (not <=) cnsCurrentStreamTime -
                // m_cnsMaxStreamDelta. So pPrevWriter cannot be NULL.

                // Conclusion: WriteSample has not been called at all,
                // i.e., !IsFlagSet(SampleWritten). Note that
                // SetFirstSampleTime may have been called and that
                // m_cnsFirstSampleTime may not be 0.

                if (IsFlagSet(SampleWritten))
                {
                    DVR_ASSERT(!IsFlagSet(SampleWritten), "");
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "No previous node in m_leWritersList for writer node corresponding to the stopped recorder node id=0x%x althugh a sample has been written",
                                    pStop);
                    hrRet = E_FAIL;
                    __leave;
                }
                bPrime = 1;
                cnsTempStartTimeAddFile = m_cnsFirstSampleTime;
            }
            if (bPrime)
            {
                ::SafeAdd(cnsTempEndTimeAddFile, cnsTempStartTimeAddFile, m_cnsTimeExtentOfEachFile);
                if (pNextWriter && cnsTempEndTimeAddFile > pNextWriter->cnsStartTime)
                {
                    cnsTempEndTimeAddFile = pNextWriter->cnsStartTime;
                }
                hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
                if (FAILED(hr))
                {
                    DVR_ASSERT(0, "AddATemporaryFile for priming failed.");
                    hrRet = hr;
                    DvrIopDebugOut7(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                    "Failed to prime a writer node after stopping recording for recorder id = 0x%x, SampleWritten = %d "
                                    "Previous writer exists: %hs, "
                                    "Start time supplied to AddATemporaryFile: %I64u, "
                                    "End time supplied to AddATemporaryFile: %I64u, "
                                    "Current stream time: %I64u, "
                                    "m_cnsFirstSampleTime: %I64u.",
                                    pStop,
                                    IsFlagSet(SampleWritten)? 1 : 0,
                                    pPrevWriter? "Yes" : "No",
                                    cnsTempStartTimeAddFile,
                                    cnsTempEndTimeAddFile,
                                    cnsCurrentStreamTime,
                                    m_cnsFirstSampleTime
                                    );
                }
            }
        } // if (cnsStopTime == pRecorderNode->cnsStartTime)
        hrRet = S_OK;
    }
    __finally
    {
        // Note: pRecorderNode may have been deleted by the time we get here

        if (pWriterNodeToBeClosed)
        {
            // Ignore the returned status; the node is deleted if there was an error
            CloseWriterFile(pWriterNodeToBeClosed);
        }
        if (FAILED(hrRet) && bIrrecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::StopRecording

HRESULT CDVRRingBufferWriter::DeleteRecorder(IN LPVOID pRecorderId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::DeleteRecorder"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        LIST_ENTRY*         pCurrent;
        PASF_RECORDER_NODE  pRecorderNode;
        LIST_ENTRY*         pDelete = (LIST_ENTRY*) pRecorderId;

        pRecorderNode = CONTAINING_RECORD(pDelete, ASF_RECORDER_NODE, leListEntry);

        pRecorderNode->SetFlags(ASF_RECORDER_NODE::RecorderNodeDeleted);

        // The DeleteRecorderNode is set by CloseWriterFile/ProcessCloseRequest
        // after the recorder's file has been closed. It is also set in
        // the ASF_RECORDER_NODE constructor and cleared only when
        // the start recording time is set. Note that recorder nodes that
        // have not been started (StartRecording not called) cannot be
        // cancelled (StopRecording won't take MAXQWORD as an argument)
        // but they can be deleted.
        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::DeleteRecorderNode))
        {
            // If pWriterNode is not NULL, CreateRecorder failed or the
            // client deleted the recorder before starting it
            if (pRecorderNode->pWriterNode)
            {
                // Note that this could be a multi-file recording
                // Ignore the returned status; if this fails, the
                // writer node is just deleted

                if (!LIST_NODE_POINTERS_NULL(&pRecorderNode->pWriterNode->leListEntry))
                {
                    RemoveEntryList(&pRecorderNode->pWriterNode->leListEntry);
                    NULL_LIST_NODE_POINTERS(&pRecorderNode->pWriterNode->leListEntry);
                }

                HRESULT hr;

                hr = CloseWriterFile(&pRecorderNode->pWriterNode->leListEntry);

                // We don't have to wait for the file to be closed.
                // CloseWriterFile/ProcessCloseRequest will delete
                // pRecorderNode asynchronously.
                // Do NOT access pRecorderNode after this
                pRecorderNode = NULL;
            }
            else if (!LIST_NODE_POINTERS_NULL(pDelete))
            {
                RemoveEntryList(pDelete);
                NULL_LIST_NODE_POINTERS(pDelete);
                delete pRecorderNode;
                pRecorderNode = NULL;
            }
            else
            {
                delete pRecorderNode;
                pRecorderNode = NULL;
            }
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::DeleteRecorder

HRESULT CDVRRingBufferWriter::GetRecordingStatus(IN  LPVOID pRecorderId,
                                                 OUT HRESULT* phResult OPTIONAL,
                                                 OUT BOOL*  pbStarted OPTIONAL,
                                                 OUT BOOL*  pbStopped OPTIONAL,
                                                 OUT BOOL*  pbSet)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetRecordingStatus"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    if (!pbSet || DvrIopIsBadWritePtr(pbSet, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        return E_POINTER;
    }
    *pbSet = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        LIST_ENTRY*         pCurrent;
        PASF_RECORDER_NODE  pRecorderNode;
        LIST_ENTRY*         pRecorder = (LIST_ENTRY*) pRecorderId;

        pRecorderNode = CONTAINING_RECORD(pRecorder, ASF_RECORDER_NODE, leListEntry);

        if (phResult)
        {
            *phResult = pRecorderNode->hrRet;
        }

        if (pbStarted == NULL && pbStopped == NULL)
        {
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        QWORD cnsStreamTime;

        HRESULT hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &cnsStreamTime);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (pbStarted)
        {
            *pbStarted = cnsStreamTime >= pRecorderNode->cnsStartTime;
        }
        if (pbStopped)
        {
            *pbStopped = cnsStreamTime >= pRecorderNode->cnsEndTime;
        }
        *pbSet = 1;

    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::GetRecordingStatus

HRESULT CDVRRingBufferWriter::HasRecordingFileBeenClosed(IN LPVOID pRecorderId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::HasRecordingFileBeenClosed"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        LIST_ENTRY*         pCurrent;
        PASF_RECORDER_NODE  pRecorderNode;
        LIST_ENTRY*         pRecorder = (LIST_ENTRY*) pRecorderId;

        pRecorderNode = CONTAINING_RECORD(pRecorder, ASF_RECORDER_NODE, leListEntry);

        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
        {
            DVR_ASSERT(pRecorderNode->pMultiFileRecorder, "");
            DVR_ASSERT(pRecorderNode->pMultiFileRecorder->pFileCollection, "");

            LONG nWriterCompleted;

            hrRet = pRecorderNode->pMultiFileRecorder->pFileCollection->GetWriterHasBeenClosed(
                &(pRecorderNode->pMultiFileRecorder->FileCollectionInfo),
                &nWriterCompleted);

            if (SUCCEEDED(hrRet))
            {
                hrRet = nWriterCompleted? S_OK : S_FALSE;
            }
        }
        else
        {
            hrRet = pRecorderNode->pWriterNode == NULL? S_OK : S_FALSE;
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::HasRecordingFileBeenClosed

// ====== IUnknown

STDMETHODIMP CDVRRingBufferWriter::QueryInterface(IN  REFIID riid,
                                                  OUT void   **ppv)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::QueryInterface"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!ppv || DvrIopIsBadWritePtr(ppv, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        hrRet = E_POINTER;
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast <IDVRRingBufferWriter*> (this) ;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRRingBufferWriter)
    {
        *ppv = static_cast <IDVRRingBufferWriter*> (this);
        hrRet = S_OK;
    }
    else
    {
        *ppv = NULL;
        hrRet = E_NOINTERFACE;
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "no such interface");
    }

    if (SUCCEEDED(hrRet))
    {
        ((IUnknown *) (*ppv))->AddRef();
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // CDVRRingBufferWriter::QueryInterface


STDMETHODIMP_(ULONG) CDVRRingBufferWriter::AddRef()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddRef"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0,
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRingBufferWriter::AddRef


STDMETHODIMP_(ULONG) CDVRRingBufferWriter::Release()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::Release"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0,
              "m_nRefCount < 0 after InterlockedDecrement");

    if (nNewRef == 0)
    {
        // Must call DebugOut before the delete because the
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE,
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRingBufferWriter::Release


STDMETHODIMP
CDVRRingBufferWriter::OnStatus (
    IN  WMT_STATUS          Status,
    IN  HRESULT             hr,
    IN  WMT_ATTR_DATATYPE   dwType,
    IN  BYTE *              pbValue,
    IN  void *              pvContext
    )
{
    if (FAILED (hr) &&
        m_pfnCallback) {

        m_pfnCallback (m_pvCallbackContext, DVRIO_NOTIFICATION_REASON_WRITE_ERROR) ;
    }

    return S_OK ;
}

// ====== IDVRRingBufferWriter


STDMETHODIMP CDVRRingBufferWriter::SetFirstSampleTime(IN QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::SetFirstSampleTime"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;
    BOOL    bLocked = 0;    // We have locked m_pDVRFileCollection
    BOOL    bRecoverableError = 0;
    BOOL    bReleaseSharedMemoryLock = 0;
    BOOL    bDecrementInconsistencyDataCounter = 0;
    CDVRFileCollection::PDVRIOP_FILE_TIME   pFileTimes = NULL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        if (IsFlagSet(StartingStreamTimeKnown))
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "StartingStreamTimeKnown flag is set (expect it is not "
                            "set when this function is called).");

            hrRet = E_UNEXPECTED;
            bRecoverableError = 1;
            __leave;
        }
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }
        if (m_cnsFirstSampleTime != 0)
        {
            DVR_ASSERT(m_cnsFirstSampleTime == 0, "");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "m_cnsFirstSampleTime = %I64u, should be 0",
                            m_cnsFirstSampleTime);
            bRecoverableError = 1;
            hrRet = E_FAIL;
            __leave;
        }

        // This should have been set in our constructor.
        DVR_ASSERT(m_pDVRFileCollection, "");

        if (cnsStreamTime == m_cnsFirstSampleTime)
        {
            // Skip out of this routine
            hrRet = S_OK;
            __leave;
        }

        // We have to update the times of nodes in m_leWritersList

        LIST_ENTRY*         pWriter;
        PASF_WRITER_NODE    pWriterNode;
        DWORD               dwNumNodesToUpdate;
        HRESULT             hr;

        // There should be at least one node in the list; there could be more
        // if StartRecording has been called.

        if (IsListEmpty(&m_leWritersList))
        {
            DVR_ASSERT(!IsListEmpty(&m_leWritersList),
                       "Writers list is empty - should have been primed in the constructor "
                       "and in StopRecording.");
            hrRet = E_FAIL;
          __leave;
        }

        pWriter = NEXT_LIST_NODE(&m_leWritersList);
        pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

        // The first node should have a start time of 0 regardless of
        // whether it is a temporary node or a recorder node.
        if (pWriterNode->cnsStartTime != 0)
        {
            DVR_ASSERT(pWriterNode->cnsStartTime == 0,
                       "Temporary writer's node start time != 0 ");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Temporary writer's node start time != 0; it is %I64u",
                            pWriterNode->cnsStartTime);
            hrRet = E_FAIL;
            __leave;
        }

        // We consider two cases: cnsStreamTime is (a) before and (b) after the first
        // recording's start time

        QWORD cnsFirstRecordingTime = MAXQWORD;

        if (!IsListEmpty(&m_leRecordersList))
        {
            PASF_RECORDER_NODE  pRecorderNode;

            pRecorderNode = CONTAINING_RECORD(NEXT_LIST_NODE(&m_leRecordersList), ASF_RECORDER_NODE, leListEntry);

           if (!pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
           {
               // If StartRecording has not been called on the first recorder node
                // its start time would be MAXQWORD, which works for us here.
                cnsFirstRecordingTime = pRecorderNode->cnsStartTime;
           }
           else
           {
               // No single file recordings. For purposes of this funciton,
               // this is equivalent to an empty m_leRecordersList.
           }
        }

        if (cnsStreamTime < cnsFirstRecordingTime)
        {
            CDVRFileCollection::DVRIOP_FILE_TIME    ft;

            ft.nFileId = pWriterNode->nFileId;
            ft.cnsStartTime = cnsStreamTime;
            ::SafeAdd(ft.cnsEndTime, cnsStreamTime, m_cnsTimeExtentOfEachFile);
            if (ft.cnsEndTime > cnsFirstRecordingTime)
            {
                ft.cnsEndTime = cnsFirstRecordingTime;
            }
            dwNumNodesToUpdate = 1;

            // No need to call CloseAllWriterFilesBefore here.

            hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
            bLocked = 1;
            if (FAILED(hr))
            {
                hrRet = hr;
                bDecrementInconsistencyDataCounter = 0;
                bRecoverableError = 1;
                __leave;
            }
            bDecrementInconsistencyDataCounter = 1;

            // Update the times on the writer node
            pWriterNode->cnsStartTime = cnsStreamTime;
            pWriterNode->cnsEndTime = ft.cnsEndTime;


            hr = m_pDVRFileCollection->SetFileTimes(&m_FileCollectionInfo, dwNumNodesToUpdate, &ft);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else if (hr == S_FALSE)
            {
                // We have at least one node in the list.
                DVR_ASSERT(hr == S_OK, "hr = S_FALSE unexpected");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "SetFileTimes returns hr = 0x%x - unexpected.",
                                hr);
                hrRet = E_FAIL;
                __leave;
            }
        }
        else
        {
            // Find out which node cnsStreamTime corresponds to. Note that
            // there may not be any node because cnsStreamTime falls between
            // two recordings or after the last recording. Note that we do
            // NOT create a temporary node after every recording node just
            // so that this case would be covered. If we did, we'd have
            // the file collection object could have more than m_dwNumberOfFiles
            // temporary files in it even before we got the first sample and
            // we'd have to change its algorithm for computing the time extent
            // of the ring buffer (and possibly maintain writer ref counts).
            // Instead, we pay the penalty here - we wait till a file is
            // primed. Two notes: 1. we cannot re-use the temporary file node
            // as is because its order relative to the other files would change
            // (SetFileTimes would fail) and 2. This case will not happen
            // unless the client called StopRecording before writing started.

            LIST_ENTRY*         pWriterForThisSample = NULL;

            // The start, end time of the last node passed to SetFileTimes
            QWORD               cnsTempStartTime;
            QWORD               cnsTempEndTime;
#if defined(DEBUG)
            BOOL                bFirstIteration = 1;
#endif
            // The start, end times passed to AddATemporaryFile
            QWORD               cnsTempStartTimeAddFile; // always cnsStreamTime
            QWORD               cnsTempEndTimeAddFile;

            // If a file's end time is before this, it should be closed by
            // calling CloseAllWriterFilesBefore
            QWORD cnsCloseTime;

            dwNumNodesToUpdate = 0;
            pWriter = NEXT_LIST_NODE(&m_leWritersList);
            while (pWriter != &m_leWritersList)
            {
                pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

#if defined(DEBUG)
                if (!bFirstIteration)
                {
                    // Note that this mayu also be true for the first node in
                    // the writer's list, but it doesn't have to be.
                    DVR_ASSERT(pWriterNode->pRecorderNode != NULL, "");
                }
#endif
                if (pWriterNode->cnsStartTime > cnsStreamTime)
                {
                   // If this assertion fails, we never set cnsTempStartTime and cnsTempEndTime,
                    // but use them.
                    DVR_ASSERT(!bFirstIteration,
                              "cnsStreamTime should be < the first recording time; we should not be here!");

                    // We will have to call AddATemporaryFile to create a temporary file
                    // cnsStreamTime falls between two recordings
                    cnsTempStartTimeAddFile = cnsStreamTime;
                    ::SafeAdd(cnsTempEndTimeAddFile, cnsStreamTime, m_cnsTimeExtentOfEachFile);
                    if (cnsTempEndTimeAddFile > pWriterNode->cnsStartTime)
                    {
                        cnsTempEndTimeAddFile = pWriterNode->cnsStartTime;
                    }
                    break;
                }

                dwNumNodesToUpdate++;
                if (pWriterNode->cnsEndTime > cnsStreamTime)
                {
                    // cnsStreamTime falls within this recording

                    // Assert this writer node has an associated recorder
                    DVR_ASSERT(pWriterNode->pRecorderNode != NULL, "");

                    pWriterForThisSample = pWriter;
                    cnsTempEndTime = pWriterNode->cnsEndTime;
                    cnsTempStartTime = cnsStreamTime;
                    break;
                }
                cnsTempStartTime = cnsTempEndTime = pWriterNode->cnsStartTime;
                pWriter = NEXT_LIST_NODE(pWriter);
#if defined(DEBUG)
                bFirstIteration = 0;
#endif
            }
            if (pWriter == &m_leWritersList)
            {
                cnsTempStartTimeAddFile = cnsStreamTime;
                // We will have to call AddATemporaryFile to create a temporary file
                // cnsStreamTime is after the last recording
                ::SafeAdd(cnsTempEndTimeAddFile, cnsStreamTime, m_cnsTimeExtentOfEachFile);
            }

            pFileTimes = new CDVRFileCollection::DVRIOP_FILE_TIME[dwNumNodesToUpdate];
            if (pFileTimes == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - %u bytes",
                                dwNumNodesToUpdate*sizeof(CDVRFileCollection::DVRIOP_FILE_TIME));

                hrRet = E_OUTOFMEMORY; // out of stack space
                bRecoverableError = 1;
                __leave;
            }

            pWriter = &m_leWritersList;
            for (DWORD i = 0; i < dwNumNodesToUpdate; i++)
            {
                pWriter = NEXT_LIST_NODE(pWriter);
                pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);
                pFileTimes[i].nFileId = pWriterNode->nFileId;
                pFileTimes[i].cnsStartTime = pFileTimes[i].cnsEndTime = pWriterNode->cnsStartTime;
            }
            // Change start and end times for the last node passed to SetFileTimes
            // Also update this info on the writer node itself.
            pFileTimes[i].cnsStartTime = cnsTempStartTime;
            pFileTimes[i].cnsEndTime = cnsTempEndTime;

            // Update the times on the writer node. Note that this is safe even
            // if cnsStreamTime falls between two recordings or after the last
            // recording; in these cases cnsTempStartTime and cnsTempEndTime
            // were set from the start, end times of the same writer node.
            DVR_ASSERT(pWriterForThisSample ||
                       (pWriterNode->cnsStartTime == cnsTempStartTime &&
                        pWriterNode->cnsEndTime == cnsTempEndTime),
                       "");
            pWriterNode->cnsStartTime = cnsTempStartTime;
            pWriterNode->cnsEndTime = cnsTempEndTime;

            // We call close writer files here to delete nodes before cnsStreamTime
            // from m_leWritersList and close the ASF files. If we do this before calling
            // SetFileTimes, the chances of deleting temporary disk files in the
            // SetFileTimes call are greater. Other than that; there is no need
            // to make this call before SetFileTimes().
            //
            // Note that m_leWritersList is changed after the call
            //

            // NOTE: We do NOT update the start and end times on ASF_RECORDER_NODE
            // nodes. This is deliberate. CloseWriterFile/ProcessCloseRequest which
            // are called by CloseAllWriterFilesBefore pulls the recorder nodes out
            // of m_leRecordersList and leaves them "hanging" till the client
            // calls DeleteRecorder. At that time the nodes are deleted. Since the
            // nodes are not in the recorders list, the start/end times on the
            // nodes do not matter any more. Note that the client hass already set
            // start and stop times on these recordings, so any subsequent calls it
            // makes to Start/StopRecording would fail anyway. (After ProcessCloseRequest
            // completes, it will fail for another reason - the recording is no longer
            // in the m_leRecordersList.) Also note that if a recording is persistent,
            // ProcessCloseRequest releases the refcount on the recording, so it is
            // destroyed.
            //
            // The exception to this is the recorder node corresponding to
            // pWriterForThisSample. The first sample time falls within the
            // extent of this writer node, so the writer will not be closed.
            if (pWriterForThisSample)
            {
                PASF_WRITER_NODE pTmpNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

                // This has already been asserted in the while loop above
                DVR_ASSERT(pTmpNode->pRecorderNode != NULL, "");

                DVR_ASSERT(pTmpNode->pRecorderNode->cnsStartTime != MAXQWORD &&
                           pTmpNode->pRecorderNode->cnsEndTime != MAXQWORD &&
                           pTmpNode->pRecorderNode->cnsEndTime == cnsTempEndTime, "");

                pTmpNode->pRecorderNode->cnsStartTime = cnsTempStartTime;
            }

            // We lock the file collection before closign the writer files.
            // A reader that has one of the closed writer files open will get
            // an EOF when the file is closed. The reader would next try to
            // get info about the closed file from the file collection object.
            // We keep the object locked till all updates are done; this
            // will make the reader wait after it gets the EOF notification
            // till the file collection object is consistent with the writer's
            // call to SetFirstSampleTime. (Our reader will detect that the
            // file that it got the EOF notification for has fallen out of the
            // ring buffer and bail out of GetNextSample.)
            //
            // Note also that we want at least 1 file int he ring buffer to be open
            // until the writer calls Close. By grabbing this lock before closing
            // the file, we can afford to relax that constraint - we can add the
            // priming file after closing the file - because the reader can't
            // get any info out of the file collection till it gets the lock anyway.

            hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
            bLocked = 1;
            if (FAILED(hr))
            {
                hrRet = hr;
                bDecrementInconsistencyDataCounter = 0;
                __leave;
            }

            // Note that even if this fn fails, the file collection data remains
            // consistent. (It is internally consistent although it is not consistent
            // with this class.) This is because the file collection methods invoked
            // here and in AddATemporaryFile leave the collection consistent even if
            // they fail. So, we leave this flag set to 1 even if we fail.
            bDecrementInconsistencyDataCounter = 1;

            hr = CloseAllWriterFilesBefore(cnsStreamTime);

            // Errors after this are not recoverable since the writers list has changed
            // as a result of calling CloseAllWriterFilesBefore()

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }


            hr = m_pDVRFileCollection->SetFileTimes(&m_FileCollectionInfo, dwNumNodesToUpdate, pFileTimes);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else
            {
                // S_FALSE is ok; the list could have got empty if cnsStreamTime
                // is after the last recording
            }

            if (!pWriterForThisSample)
            {
                // Verify that:
                DVR_ASSERT(cnsTempStartTimeAddFile == cnsStreamTime, "");

                // Add a temporary file.

                hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }
            }
        }

        hrRet = S_OK;

    }
    __finally
    {
        HRESULT hr;

        if (SUCCEEDED(hrRet))
        {
            if (!bLocked)
            {
                // Just in case the reader is accessing this concurrently ...

                hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
                bLocked = 1;
                if (FAILED(hr))
                {
                    // Just go on
                    bDecrementInconsistencyDataCounter = 0;
                    hrRet = hr;
                }
                else
                {
                    bDecrementInconsistencyDataCounter = 1;
                }
            }
        }
        if (SUCCEEDED(hrRet))
        {
            // We update this even though we have not yet written the first sample.
            // This is ok, because a Seek (by the reader) to this time will succeed.
            // The ring buffer's time extent would be returned as (cnsStreamTime, cnsStreamTime).
            // Usually if the ring buffers time extent is returned as (T1, T2), there is
            // a sample time stamped T2, but this is an exception.
            //
            // If we don't set this here, GetTimeExtent on the reader (ring buffer)
            // would return a start time > end time (end time would be last stream time
            // which is 0.

            DVR_ASSERT(bLocked, "");
            hr = m_pDVRFileCollection->SetLastStreamTime(&m_FileCollectionInfo, cnsStreamTime, 0 /* we already have the lock, do not lock */);
            if (FAILED(hr))
            {
                hrRet = hr;
            }
        }

        if (SUCCEEDED(hrRet))
        {
            SetFlags(StartingStreamTimeKnown);

            m_cnsFirstSampleTime = cnsStreamTime;

            m_nNotOkToWrite++;

            // Close any multi file recordigns whose start and stop time have been
            // set and whose stop time < m_cnsFirstSampleTime == cnsCurrentStreamTime

            LIST_ENTRY* pMFR = NEXT_LIST_NODE(&m_leActiveMultiFileRecordersList);
            DWORD       dwCount = 0;
            DWORD       dwSkip = 0;

            while (pMFR != &m_leActiveMultiFileRecordersList)
            {
                if (dwCount >= dwSkip)
                {

                    PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode = CONTAINING_RECORD(pMFR, ASF_MULTI_FILE_RECORDER_NODE, leListEntry);

                    DVR_ASSERT(pMultiFileRecorderNode->pRecorderNode, "");
                    DVR_ASSERT(pMultiFileRecorderNode->pFileCollection, "");

                    BOOL    bRecordingCompleted;

                    // Ignore the returned status
                    hr = ExtendMultiFileRecording(pMultiFileRecorderNode->pRecorderNode, bRecordingCompleted);

                    if (bRecordingCompleted)
                    {
                        // pMultiFileRecorderNode would have been pulled out of
                        // m_leActiveMultiFileRecordersList, so reset:
                        dwCount = 0;
                        pMFR = NEXT_LIST_NODE(&m_leActiveMultiFileRecordersList);
                    }
                    else
                    {
                        dwSkip++;
                        pMFR = NEXT_LIST_NODE(pMFR);
                        dwCount++;
                    }
                }
                else
                {
                    pMFR = NEXT_LIST_NODE(pMFR);
                    dwCount++;
                }
            }
        }
        else if (!bRecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
        }

        if (bLocked)
        {
            hr = m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, bDecrementInconsistencyDataCounter);
            DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->Unlock failed");
        }

        delete [] pFileTimes;

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::SetFirstSampleTime

STDMETHODIMP CDVRRingBufferWriter::WriteSample(IN WORD  wStreamNum,
                                               IN OUT QWORD * pcnsStreamTimeInput,
                                               IN DWORD dwFlags,
                                               IN INSSBuffer *pSample)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::WriteSample"

    DVRIO_TRACE_ENTER();

    DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                    "wStreamNum is %u, (*pcnsStreamTimeInput) is %I64u",
                    (DWORD) wStreamNum, (* pcnsStreamTimeInput));


    HRESULT hrRet = E_FAIL;
    BOOL    bRecoverableError = 0;
    PASF_WRITER_NODE    pWriterNode = NULL;
    QWORD   cnsStreamTime;  // The actual time we supply to the SDK; different
                            // from (* pcnsStreamTimeInput) by at most a few msec.

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        // Not really necessary since _finally section does not use
        // cnsStreamTime if we leave with failure. We have to do this
        // if the EnforceIncreasingTimeStamps flag is not set
        cnsStreamTime = (* pcnsStreamTimeInput);

        if (m_nNotOkToWrite)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is %d (should be 0 to allow the write).",
                            m_nNotOkToWrite);

            // This clause will cover the case when we hit a recoverable error
            // earlier. It doesn't hurt to set bRecoverableError to 1 in that case.
            bRecoverableError  = 1;
            hrRet = E_UNEXPECTED;
            __leave;
        }

        // m_nNotOkToWrite == 0 implies:
        DVR_ASSERT(IsFlagSet(StartingStreamTimeKnown) && IsFlagSet(MaxStreamDeltaSet) &&
                   !IsFlagSet(WriterClosed), "m_nNotOkToWrite is 0?!");

        if ((* pcnsStreamTimeInput) < m_cnsFirstSampleTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "(* pcnsStreamTimeInput) (%I64u) <= m_cnsFirstSampleTime (%I64u)",
                            (* pcnsStreamTimeInput), m_cnsFirstSampleTime);
            bRecoverableError  = 1;
            hrRet = E_INVALIDARG;
            __leave;
        }

        QWORD cnsCurrentStreamTime;

        hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &cnsCurrentStreamTime);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Workaround an SDK bug. First, the precision that the SDK provides for
        // timestamps is 1 msec precision although its input is a cns - cns are
        // truncated down to msec and scaled back up in the mux. Secondly. the
        // mux reorders samples and fragments of samples that have the same time
        // stamp. This is not an issue for  samples in different streams. However,
        // if 2 samples in the same stream have the same timestamp and some of
        // these samples are fragmented across ASF packets, the sample fragments
        // can be interleaved. For example, sample 2 fragment 1 can be followed
        // by sample 1 (unfragmented), which is followed by sample 2 fragment 2.
        // Even if the reader can put this back together (currently there is a
        // bug in the reader that causes it to discard sample 2 altogether in
        // the case that samples 1 and 2 both have a timestamp of 0), this could
        // cause issues for seeking. The safe thing is to work around all this
        // and provide timestamps  that increase by at least 1 msec to the SDK.
        //
        if (IsFlagSet(EnforceIncreasingTimeStamps))
        {
            // Note that cnsCurrentStreamTime will usually be a multiple of
            // k_dwMilliSecondsToCNS. The exception is the value it is set to in
            // SetFirstSampleTime

            //  PREFIX claims there's a codepath here...
            if (k_dwMilliSecondsToCNS == 0) {
                hrRet = E_UNEXPECTED ;
                __leave ;
            }

            QWORD       msStreamTime     = (* pcnsStreamTimeInput)/k_dwMilliSecondsToCNS;
            QWORD       msLastStreamTime = cnsCurrentStreamTime/k_dwMilliSecondsToCNS;

            if (msStreamTime <= msLastStreamTime)
            {
                msStreamTime = msLastStreamTime + 1;
            }
            cnsStreamTime = msStreamTime * k_dwMilliSecondsToCNS;

            //  stream time actually used; send this back out since we're
            //    updating it now
            (* pcnsStreamTimeInput) = cnsStreamTime ;
        }

        // We have closed files through cnsCurrentStreamTime - m_cnsMaxStreamDelta
        // [that is files whose end time is cnsCurrentStreamTime - m_cnsMaxStreamDelta,
        // i.e., whose samples have times < (not <=) cnsCurrentStreamTime -
        // m_cnsMaxStreamDelta, i.e., 2 successive calls can supply a stream time
        // of cnsCurrentStreamTime - m_cnsMaxStreamDelta without error].
        //
        // If we get a sample earlier than that, fail the call.
        // Note that for the first sample that's written, we have actually closed
        // files through cnsCurrentStreamTime, which is equal to m_cnsFirstSampleTime,
        // but this test is harmless in that case.

        if (cnsCurrentStreamTime > m_cnsMaxStreamDelta &&
            cnsStreamTime < cnsCurrentStreamTime - m_cnsMaxStreamDelta)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "cnsStreamTime (%I64u) <= cnsCurrentStreamTime - m_cnsMaxStreamDelta (%I64u)",
                            cnsStreamTime, cnsCurrentStreamTime - m_cnsMaxStreamDelta);
            bRecoverableError  = 1;
            hrRet = E_INVALIDARG;
            __leave;
        }

        if (cnsStreamTime == MAXQWORD)
        {
            // Note that a file with end time = T means the file has samples
            // whose times are < T (not <= T)

            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "cnsStreamTime == QWORD_INIFITE is invalid.");
            bRecoverableError  = 1;
            hrRet = E_INVALIDARG;
            __leave;
        }

        // Find the node corresponding to cnsStreamTime

        LIST_ENTRY*         pWriter = NEXT_LIST_NODE(&m_leWritersList);
        BOOL                bFoundWriterForThisSample = 0;

        pWriter = NEXT_LIST_NODE(&m_leWritersList);
        while (pWriter != &m_leWritersList)
        {
            pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

            if (pWriterNode->cnsStartTime > cnsStreamTime)
            {
                // We will have to call AddATemporaryFile to create a file
                // Clearly, there is a time hole here.
                break;
            }

            if (pWriterNode->cnsEndTime > cnsStreamTime)
            {
                // cnsStreamTime corresponds to this node
                bFoundWriterForThisSample = 1;
                break;
            }
            pWriter = NEXT_LIST_NODE(pWriter);
        }

        if (!bFoundWriterForThisSample)
        {
            // We either have a time hole or we've hit the end ofthe list and
            // not found a primed file (or both - if the list was empty).

            // Verify that we are in sync w/ the file collection, i.e., that
            // the file collection also does not have a file for this time.

            hr = m_pDVRFileCollection->GetFileAtTime(&m_FileCollectionInfo,
                                                                    // Reader index, unused if bFileWillBeOpened == 0
                                                     cnsStreamTime,
                                                     NULL,          // ppwszFileName OPTIONAL,
                                                     NULL,          // cnsFirstSampleTimeOffsetFromStartOfFile
                                                     NULL,          // pnFileId OPTIONAL,
                                                     0              // bFileWillBeOpened
                                                    );
            if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                DVR_ASSERT(0,
                           "Writers list not in sync w/ file collection");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Writer's list not in sync w/ file collection for the stream time %I64u",
                                cnsStreamTime);
                hrRet = E_FAIL;
                __leave;
            }

            // The start, end times passed to AddATemporaryFile if we do not find a node
            QWORD               cnsTempStartTimeAddFile;
            QWORD               cnsTempEndTimeAddFile;

            hr = m_pDVRFileCollection->GetLastValidTimeBefore(&m_FileCollectionInfo,
                                                              cnsStreamTime,
                                                              &cnsTempStartTimeAddFile);
            if (FAILED(hr))
            {
                // The call should not fail. We have ensured that
                // (a) cnsStreamTime >= m_cnsFirstSampleTime. i.e., we are not writing before
                // the first sample time and
                // (b) cnsStreamTime > cnsCurrentStreamTime - m_cnsMaxStreamDelta.
                //
                // If the call fails, there are no temporary (or permanent) files before cnsStreamTime.
                // But we added 1 temporary file before writing started and the file collection and
                // the file collection always maintains m_dwNumberOfFiles temporary files in its
                // extent. It cannot be the case that all temporary files are after cnsStreamTime
                // because of (b) and the relation between m_cnsMaxStreamDelta and m_dwNumberOfFiles.
                // So there must have been some bad calls to SetFileTimes that zapped all temporary
                // (and permanent) files before cnsStreamTime.

                DVR_ASSERT(0,
                           "GetLastValidTimeBefore failed");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "GetLastValidTimeBefore for the stream time %I64u",
                                cnsStreamTime);
                hrRet = E_FAIL;
                __leave;
            }
            // Advance the start time to the first usable time after the last
            // valid one. So now, cnsTempStartTimeAddFile <= cnsStreamTime
            cnsTempStartTimeAddFile += 1;

            hr = m_pDVRFileCollection->GetFirstValidTimeAfter(&m_FileCollectionInfo,
                                                              cnsStreamTime,
                                                              &cnsTempEndTimeAddFile);
            if (FAILED(hr))
            {
                cnsTempEndTimeAddFile = MAXQWORD;
            }

            QWORD               cnsTempLast;
            QWORD               cnsTemp;

            if (cnsStreamTime - cnsTempStartTimeAddFile > 20 * m_cnsTimeExtentOfEachFile)
            {
                if (cnsTempEndTimeAddFile - cnsStreamTime < 10 * m_cnsTimeExtentOfEachFile)
                {
                    cnsTempLast = cnsTempEndTimeAddFile;

                    while (cnsTempLast > cnsStreamTime)
                    {
                        cnsTempLast -= m_cnsTimeExtentOfEachFile;
                    }
                }
                else
                {
                    // An eight of the extent before the current sample time is
                    // arbitrary.
                    cnsTempLast = cnsStreamTime - m_cnsTimeExtentOfEachFile/8;
                }
                ::SafeAdd(cnsTemp, cnsTempLast, m_cnsTimeExtentOfEachFile);
            }
            else
            {
                cnsTemp = cnsTempStartTimeAddFile;

                DVR_ASSERT(cnsTemp <= cnsStreamTime, "");

                while (cnsTemp <= cnsStreamTime)
                {
                    // We maintain cnsTempLast rather than subtract m_cnsTimeExtentOfEachFile
                    // from cnsTemp after the loop because SafeAdd may return MAXQWORD
                    cnsTempLast = cnsTemp;

                    ::SafeAdd(cnsTemp, cnsTemp, m_cnsTimeExtentOfEachFile);
                }
            }

            cnsTempStartTimeAddFile = cnsTempLast;

            // End time is the min of:
            // - cnsTempStartTimeAddFile + m_cnsTimeExtentOfEachFile
            // - MAXQWORD
            // - the start time of the next node in the writer's list
            if (cnsTemp < cnsTempEndTimeAddFile)
            {
                cnsTempEndTimeAddFile = cnsTemp;
            }

            hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
            if (FAILED(hr))
            {
                DVR_ASSERT(0, "AddATemporaryFile failed.");
                hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Failed to add a node for the stream time %I64u",
                                cnsStreamTime);
                __leave;
            }

            // Find the node we just added
            pWriter = NEXT_LIST_NODE(&m_leWritersList);
            while (pWriter != &m_leWritersList)
            {
                pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

                if (pWriterNode->cnsStartTime > cnsStreamTime)
                {
                    // bad, bad, bad
                    break;
                }

                if (pWriterNode->cnsEndTime > cnsStreamTime)
                {
                    // cnsStreamTime corresponds to this node
                    bFoundWriterForThisSample = 1;
                    break;
                }
                pWriter = NEXT_LIST_NODE(pWriter);
            }
        }

        // We MUST already have a node in the writer's list corresponding to
        // cnsStreamTime.

        if (!bFoundWriterForThisSample)
        {
            DVR_ASSERT(0,
                       "Writers list does not have a node for the given stream time");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Writer's list does not have a ndoe for the stream time %I64u",
                            cnsStreamTime);
            pWriterNode = NULL;
            hrRet = E_FAIL;
            __leave;
        }

        // Wait for the file to be opened

        DWORD nRet = ::WaitForSingleObject(pWriterNode->hReadyToWriteTo, INFINITE);
        if (nRet == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x",
                            pWriterNode->hReadyToWriteTo, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
           __leave;
        }

        if (pWriterNode->pWMWriter == NULL)
        {
            DVR_ASSERT(pWriterNode->pWMWriter != NULL, "");
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Writer node's pWMWriter is NULL?!");
            hrRet = E_FAIL;
            __leave;
        }

        // Verify there was no error in opening the file, i.e., BeginWriting
        // succeeded
        if (FAILED(pWriterNode->hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "Writer node's hrRet indicates failure, hrRet = 0x%x",
                            pWriterNode->hrRet);
            hrRet = pWriterNode->hrRet;
            __leave;
        }

        // We are ready to write.
        hr = pWriterNode->pWMWriterAdvanced->WriteStreamSample(
                                                 wStreamNum,
                                                 cnsStreamTime - pWriterNode->cnsStartTime, // sample time
                                                 0, // send time by SDK
                                                 0, // duration - unused by SDK
                                                 dwFlags,
                                                 pSample);

        if (FAILED(hr))
        {
            if (hr == (HRESULT) NS_E_INVALID_REQUEST)
            {
                // Internal error
                DVR_ASSERT(SUCCEEDED(hr), "pWMWriter->WriteSample failed");
                hrRet = E_FAIL;
            }
            else
            {
                hrRet = hr;
                bRecoverableError = 1;
            }
            DvrIopDebugOut1(bRecoverableError?
                            DVRIO_DBG_LEVEL_CLIENT_ERROR :
                            DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pWMWriter->WriterSample failed, hr = 0x%x",
                            hr);
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        BOOL bReleaseSharedMemoryLock;

        hr = m_pDVRFileCollection->Lock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
        if (FAILED(hr))
        {
            hrRet = hr;
            // We do not set bRecoverableError to 1 here. If this fn failed, the
            // data is inconsistent. That can happen because some reader terminated
            // while updating the shared memory data (readers also update the shared
            // memory).

            // If we failed to lock, the inconsistency data counter was not incremented.
            m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 0);
            __leave;
        }

        if (!IsFlagSet(EnforceIncreasingTimeStamps) || !pWriterNode->IsFlagSet(ASF_WRITER_NODE::FileStartOffsetSet))
        {
            // Note: The ASF file sink takes off this amount from the time stamp we supply when the
            // sample is written to the ASF file. This value is not added back to the sample when it
            // is read out. So we have to do that in the reader.

            if (cnsStreamTime - pWriterNode->cnsStartTime >= (QWORD) kInvalidFirstSampleOffsetTime)
            {
                // If !IsFlagSet(EnforceIncreasingTimeStamps) and we revise the first sample offset,
                // we have to change the first sample offset of any multifile recording that references
                // this file. Currently, this is not done. However, we expect EnforceIncreasingTimeStamps
                // to be set. (ASF requires this from us or it will re-order our samples). @@@@

                DVR_ASSERT(cnsStreamTime - pWriterNode->cnsStartTime < (QWORD) kInvalidFirstSampleOffsetTime,
                           "We do not handle offsets of >= kInvalidFirstSampleOffsetTime for the first sample in an ASF file");
                // leave cnsFirstSampleTimeOffsetFromStartOfFile for this file unchanged at kInvalidFirstSampleOffsetTime
            }
            else
            {
                LONGLONG cnsFirstSampleOffset;

                hr = m_pDVRFileCollection->GetFirstSampleTimeOffsetForFile(&m_FileCollectionInfo,
                                                                           pWriterNode->nFileId,
                                                                           &cnsFirstSampleOffset,
                                                                           0 /* Don't lock, we already have the lock */ );

                if (FAILED(hr))
                {
                    // There's no reason this should fail (since we already have the lock)
                    // Failure means we have an internal error

                    DVR_ASSERT(SUCCEEDED(hr), "");
                    hrRet = hr;
                    m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
                    __leave;
                }

                if (cnsFirstSampleOffset > (LONGLONG) (cnsStreamTime - pWriterNode->cnsStartTime))
                {
                    hr = m_pDVRFileCollection->SetFirstSampleTimeOffsetForFile(&m_FileCollectionInfo,
                                                                               pWriterNode->nFileId,
                                                                               (LONGLONG) (cnsStreamTime - pWriterNode->cnsStartTime),
                                                                               0 /* Don't lock, we already have the lock */ );
                    if (FAILED(hr))
                    {
                        // There's no reason this should fail (since we already have the lock)
                        // Failure means we have an internal error

                        DVR_ASSERT(SUCCEEDED(hr), "");
                        hrRet = hr;
                        m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
                        __leave;
                    }
                    pWriterNode->SetFlags(ASF_WRITER_NODE::FileStartOffsetSet);
                }
            }
        }

        if (cnsCurrentStreamTime < cnsStreamTime)
        {
            hr = m_pDVRFileCollection->SetLastStreamTime(&m_FileCollectionInfo, cnsStreamTime,
                                                         0 /* Don't lock, we already have the lock */ );
            if (FAILED(hr))
            {
                // There's no reason this should fail (since we already have the lock)
                // Failure means we have an internal error

                DVR_ASSERT(SUCCEEDED(hr), "");
                hrRet = hr;
                m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
                __leave;
            }
        }

        // Ignore returned status of the following call. Note that the following fn can be
        // called after releasing the lock - the advantage of that
        // would be that we'd have decremented the inconsistent data counter first.
        // (FreeTerminatedReaderSlots does not cause shared data to get inconsistent.)
        // However, acquiring the lock can be expensive, so just hold on to it and
        // call this fn.
        m_pDVRFileCollection->FreeTerminatedReaderSlots(&m_FileCollectionInfo, 0 /* Already hold the lock*/ );

        LIST_ENTRY* pMFR = NEXT_LIST_NODE(&m_leActiveMultiFileRecordersList);
        DWORD       dwCount = 0;
        DWORD       dwSkip = 0;

        while (pMFR != &m_leActiveMultiFileRecordersList)
        {
            if (dwCount >= dwSkip)
            {

                PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode = CONTAINING_RECORD(pMFR, ASF_MULTI_FILE_RECORDER_NODE, leListEntry);

                DVR_ASSERT(pMultiFileRecorderNode->pRecorderNode, "");
                DVR_ASSERT(pMultiFileRecorderNode->pFileCollection, "");

                BOOL    bRecordingCompleted;

                // Ignore the returned status
                hr = ExtendMultiFileRecording(pMultiFileRecorderNode->pRecorderNode, bRecordingCompleted);

                if (bRecordingCompleted)
                {
                    // pMultiFileRecorderNode would have been pulled out of
                    // m_leActiveMultiFileRecordersList, so reset:
                    dwCount = 0;
                    pMFR = NEXT_LIST_NODE(&m_leActiveMultiFileRecordersList);
                }
                else
                {
                    dwSkip++;
                    pMFR = NEXT_LIST_NODE(pMFR);
                    dwCount++;
                }
            }
            else
            {
                pMFR = NEXT_LIST_NODE(pMFR);
                dwCount++;
            }
        }


        hr = m_pDVRFileCollection->Unlock(&m_FileCollectionInfo, bReleaseSharedMemoryLock, 1);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }


        if (NEXT_LIST_NODE(&m_leWritersList) != pWriter &&
            cnsStreamTime > m_cnsMaxStreamDelta)
        {
            // Close writer files if we can

            // Note that this is done after we write the sample so that
            // we ensure that the ring buffer always has at least 1 open
            // file. If we don't do this, it is possible that a reader
            // could detect EOF prematurely (all files have been closed by
            // the writer and there is no file after the one it last read
            // from in the ring buffer).

            // Note that if we forced m_cnsMaxStreamDelta > 0 (instead of
            // letting it be >= 0), we could close open files at the start
            // of this function rather than here.

            // Note that CloseAllWriterFilesBefore will not close pWriter,
            // the file we just wrote to since cnsEndTime for the file we just
            // wrote to would be > cnsStreamTime.

            QWORD cnsCloseTime;

            cnsCloseTime = cnsStreamTime - m_cnsMaxStreamDelta;

            LIST_ENTRY*         pTmpWriter = NEXT_LIST_NODE(&m_leWritersList);
            PASF_WRITER_NODE    pTmpWriterNode = CONTAINING_RECORD(pTmpWriter, ASF_WRITER_NODE, leListEntry);

            if (pTmpWriterNode->cnsEndTime <= cnsCloseTime)
            {
                hr = CloseAllWriterFilesBefore(cnsCloseTime);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }
            }
        }

        // Prime the next file if need be

        BOOL                bPrime = 0;

        // The start, end times passed to AddATemporaryFile if we do not find a node
        QWORD               cnsTempStartTimeAddFile;
        QWORD               cnsTempEndTimeAddFile;

        if (NEXT_LIST_NODE(pWriter) == &m_leWritersList)
        {
            // Note that if pWriterNode->cnsEndTime == MAXQWORD,
            // go ahead and prime. Typically, we'll need to because we
            // this node corresponds to a recorder. If the sample's write
            // time has got to the neighbourhood of MAXQWORD,
            // that's ok - we'll prime the file but never write to it.

            bPrime = 1;
            cnsTempStartTimeAddFile = pWriterNode->cnsEndTime;
            ::SafeAdd(cnsTempEndTimeAddFile, cnsTempStartTimeAddFile, m_cnsTimeExtentOfEachFile);
        }
        else
        {
            PASF_WRITER_NODE pNextWriterNode = CONTAINING_RECORD(NEXT_LIST_NODE(pWriter), ASF_WRITER_NODE, leListEntry);
            // Note that there is no need to special case MAXQWORD
            if (pNextWriterNode->cnsStartTime != pWriterNode->cnsEndTime)
            {
                bPrime = 1;
                cnsTempStartTimeAddFile = pWriterNode->cnsEndTime;
                ::SafeAdd(cnsTempEndTimeAddFile, cnsTempStartTimeAddFile, m_cnsTimeExtentOfEachFile);

                if (cnsTempEndTimeAddFile > pNextWriterNode->cnsStartTime)
                {
                    cnsTempEndTimeAddFile = pNextWriterNode->cnsStartTime;
                }
            }
            else
            {
                // Already primed
            }
        }

        if (bPrime)
        {
            hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
            if (FAILED(hr))
            {
                DVR_ASSERT(0, "AddATemporaryFile for priming failed.");
                // We ignore this error - we can do this again later.
                // hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "Failed to prime a writer node for start stream time %I64u",
                                cnsTempStartTimeAddFile);
            }
        }

        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;

        if (SUCCEEDED(hrRet))
        {
            SetFlags(SampleWritten);

#if defined(DVR_UNOFFICIAL_BUILD)

            if (pWriterNode->hVal)
            {
                DWORD dwRet = 0;
                DWORD dwWritten;
                DWORD dwLastError;

                __try
                {
                    if (cnsStreamTime <= pWriterNode->cnsLastStreamTime && cnsStreamTime > 0)
                    {
                        // Our validate utility expects times to be monotonically increasing
                        // May as well close the validation file
                        DVR_ASSERT(0, "Stream time smaller than last write; validation file will be closed.");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal,
                                        (LPVOID) &wStreamNum, sizeof(wStreamNum),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(wStreamNum))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (wStreamNum)");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal,
                                        (LPVOID) &cnsStreamTime, sizeof(cnsStreamTime),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(cnsStreamTime))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (cnsStreamTime)");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal,
                                        (LPVOID) &dwFlags, sizeof(dwFlags),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(dwFlags))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (dwFlags)");
                        dwRet = 0;
                        __leave;
                    }

                    BYTE* pBuffer;
                    DWORD dwLength;

                    if (FAILED(pSample->GetBufferAndLength(&pBuffer, &dwLength)))
                    {
                        DVR_ASSERT(0, "GetBufferAndLength validation file failed");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal,
                                        (LPVOID) &dwLength, sizeof(dwLength),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(dwLength))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (dwLength)");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal,
                                        (LPVOID) pBuffer, dwLength,
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != dwLength)
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (pSample->pBuffer)");
                        dwRet = 0;
                        __leave;
                    }

                }
                __finally
                {
                    if (dwRet == 0)
                    {
                        ::CloseHandle(pWriterNode->hVal);
                        pWriterNode->hVal = NULL;
                    }
                }

            }

#endif // if defined(DVR_UNOFFICIAL_BUILD)
        }
        else if (!bRecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
            SetFlags(SampleWritten);
            if (pWriterNode && pWriterNode->pRecorderNode)
            {
                // Inform the recorder of the failure.
                // Multi file recordings are unaffected.
                // They will not grow, however.
                pWriterNode->pRecorderNode->hrRet = hrRet;
            }

            // Mark all multi file recordings that are active as having failed

            QWORD cnsCurrentStreamTime;

            hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &cnsCurrentStreamTime);
            if (SUCCEEDED(hr))
            {
                LIST_ENTRY* pMFR = NEXT_LIST_NODE(&m_leActiveMultiFileRecordersList);

                while (pMFR != &m_leActiveMultiFileRecordersList)
                {

                    PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode = CONTAINING_RECORD(pMFR, ASF_MULTI_FILE_RECORDER_NODE, leListEntry);

                    DVR_ASSERT(pMultiFileRecorderNode->pRecorderNode, "");

                    if (SUCCEEDED(pMultiFileRecorderNode->pRecorderNode->hrRet) &&
                        cnsCurrentStreamTime >= pMultiFileRecorderNode->pRecorderNode->cnsStartTime &&
                        cnsCurrentStreamTime <  pMultiFileRecorderNode->pRecorderNode->cnsEndTime
                       )
                    {
                        pMultiFileRecorderNode->pRecorderNode->hrRet = hrRet;
                    }

                    pMFR = NEXT_LIST_NODE(pMFR);
                }
            }
            else
            {
                DVR_ASSERT(0, "m_pDVRFileCollection->GetLastStreamTime failed");
            }
        }
    else
    {
        // Dummy stmt so we can set a break here
        hr = hrRet;
    }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }


    return hrRet;

} // CDVRRingBufferWriter::WriteSample

STDMETHODIMP CDVRRingBufferWriter::SetMaxStreamDelta(IN QWORD cnsMaxStreamDelta)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::SetMaxStreamDelta"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }
        if (cnsMaxStreamDelta >= (m_dwMinNumberOfTempFiles - 3) * m_cnsTimeExtentOfEachFile)
        {
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "cnsMaxStreamDelta = %164u >= (numMinFiles-3)*time_extent; numMinFiles = %u, time_extent = %I64u.",
                            cnsMaxStreamDelta, m_dwMinNumberOfTempFiles, m_cnsTimeExtentOfEachFile);

            hrRet = E_INVALIDARG;
            __leave;
        }
        if (!IsFlagSet(MaxStreamDeltaSet))
        {
            SetFlags(MaxStreamDeltaSet);
            m_nNotOkToWrite++;
        }

        m_cnsMaxStreamDelta = cnsMaxStreamDelta;

        hrRet = S_OK;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::SetMaxStreamDelta


STDMETHODIMP CDVRRingBufferWriter::GetNumTempFiles(OUT DWORD* pdwMinNumberOfTempFiles,
                                                   OUT DWORD* pdwMaxNumberOfTempFiles)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetNumTempFiles"

    DVRIO_TRACE_ENTER();

    if (!pdwMinNumberOfTempFiles || DvrIopIsBadWritePtr(pdwMinNumberOfTempFiles, 0) ||
        !pdwMaxNumberOfTempFiles || DvrIopIsBadWritePtr(pdwMaxNumberOfTempFiles, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        return E_POINTER;
    }

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }

        if (!IsFlagSet(WriterClosed))
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }

        *pdwMinNumberOfTempFiles = m_dwMinNumberOfTempFiles;
        *pdwMaxNumberOfTempFiles = m_dwMaxNumberOfTempFiles;

    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::GetNumTempFiles

STDMETHODIMP CDVRRingBufferWriter::SetNumTempFiles(IN DWORD dwMinNumberOfTempFilesParam,
                                                   IN DWORD dwMaxNumberOfTempFilesParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::SetNumTempFiles"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }

        DWORD dwMinNumberOfTempFiles = dwMinNumberOfTempFilesParam > 0? dwMinNumberOfTempFilesParam : m_dwMinNumberOfTempFiles;
        DWORD dwMaxNumberOfTempFiles = dwMaxNumberOfTempFilesParam > 0? dwMaxNumberOfTempFilesParam : m_dwMaxNumberOfTempFiles;

        if (dwMinNumberOfTempFiles <= 3 ||
            dwMinNumberOfTempFiles > dwMaxNumberOfTempFiles ||
            m_dwMaxNumberOfFiles < dwMaxNumberOfTempFiles ||
            (IsFlagSet(MaxStreamDeltaSet) && m_cnsMaxStreamDelta >= (dwMinNumberOfTempFiles - 3) * m_cnsTimeExtentOfEachFile)
           )
        {
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "bad input arguments: m_cnsMaxStreamDelta = %164u, numMinFiles = %u, numMaxFiles = %u, time_extent = %I64u.",
                            m_cnsMaxStreamDelta, dwMinNumberOfTempFilesParam, dwMaxNumberOfTempFilesParam, m_cnsTimeExtentOfEachFile);

            hrRet = E_INVALIDARG;
            __leave;
        }
        if (!IsFlagSet(WriterClosed))
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }

        if (m_dwMinNumberOfTempFiles == dwMinNumberOfTempFiles &&
            m_dwMaxNumberOfTempFiles == dwMaxNumberOfTempFiles)
        {
            hrRet = S_OK;
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        // + 1 because we create a priming file
        hrRet = m_pDVRFileCollection->SetNumTempFiles(&m_FileCollectionInfo, dwMinNumberOfTempFiles + 1, dwMaxNumberOfTempFiles + 1);

        if (FAILED(hrRet))
        {
            if (hrRet != E_INVALIDARG)
            {
                // Currently this will not happen

                // We have hit an irrecoverable error.
                m_nNotOkToWrite = MINLONG;
            }
            else
            {
                // Shouldn't hit this; we validated the arguments before calling the file collection
                DVR_ASSERT(0, "");
            }
            __leave;
        }

        m_dwMinNumberOfTempFiles = dwMinNumberOfTempFiles;
        m_dwMaxNumberOfTempFiles = dwMaxNumberOfTempFiles;

    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::SetNumTempFiles

STDMETHODIMP CDVRRingBufferWriter::Close(void)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::Close"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        if (IsFlagSet(WriterClosed))
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE,
                            "Writer already closed");

            hrRet = S_FALSE;
            __leave;
        }

        // Shut down any active recorder. Note that there
        // is at most one.
        // This step is not really necesssary, but it's
        // the clean way to do it.

        LIST_ENTRY* pCurrent;

        if (m_nNotOkToWrite != MINLONG)
        {
            pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
            while (pCurrent != &m_leRecordersList)
            {
                PASF_RECORDER_NODE pRecorderNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);

                if (!pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording))
                {
                    if (pRecorderNode->cnsEndTime == MAXQWORD &&
                        pRecorderNode->cnsStartTime < MAXQWORD)
                    {
                        // Note that we cancel this recordings (on behalf of
                        // the client) by stopping them with stop time = their start time
                        // if the writer has not written a sample with time >= start time
                        // of the recording as yet. If the client holds a pointer to this
                        // object andd tries to stop it, that will fail - that's ok. It would
                        // have failed whether or not we tried to cancel the recording. (If
                        // we don't cancel the recording, StopRecording will fail since the
                        // stop time < start time. See comment below when StopRecording fails.)
                        hr = StopRecording(pCurrent, 0, 1 /* = bNow */, TRUE /* bCancelIfNotStarted*/);
                        if (FAILED(hr))
                        {
                            // If StopRecording fails:
                            // Note that the file collection object will think that
                            // this file extends to QWORD_INFINITE, that's ok. We
                            // do not call SetFileTimes to remove this file from the
                            // file collection. Note that the writer node corresponding
                            // to this recorder will be closed below. That will cause
                            // the node to be removed from the recorder's list. If the
                            // client has not released the recording and calls
                            // StopRecording after this, the call will fail (because
                            // the recording will not be in m_leRecordersList) - that's ok too.

                            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                            "StopRecording on recorder id 0x%p failed",
                                            pCurrent);
                            // Go on
                            // hrRet = hr;
                            // break;
                        }
                        // There is at most 1 active recorder, so:
                        break;
                    }
                    else if (pRecorderNode->cnsEndTime < MAXQWORD)
                    {
                        // There is at most 1 active recorder. We've found
                        // none in this case (All recordings that have started
                        // have been stopped.)

                        // All multi file recorders have also been processed - they
                        // are at the end of the list.
                        break;
                    }
                    else
                    {
                        // Start = end = MAXQWORD
                        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::PersistentRecording))
                        {
                            pRecorderNode->ClearFlags(ASF_RECORDER_NODE::PersistentRecording);
                            pRecorderNode->pRecorderInstance->Release();
                            // At this point, pRecorderNode could have been deleted by DeleteRecorder()
                            // That will happen if the creator has released its refcount on this
                            // recorder without setting the start/stop times.
                            //
                            // If it has been deleted, it would have been removed from the list. So start
                            // all over again
                            pCurrent = &m_leRecordersList;
                        }
                    }
                }
                else
                {
                    // Multi file recordings can be started and stopped after the
                    // writer is closed.

                    // Note that if the client has released a persistent multi file recording that
                    // has not been started or that has been started but not stoped, the client
                    // MUST get a pointer to that object (using GetRecordings) and start and stop
                    // the recordings with start and stop times BEFORE the last sample's time.
                    // Otherwise, these recordings hold ref counts on the ring buffer writer object
                    // and the ring buffer writer will not be destroyed.

                    // If a multi file recording has been stopped, it's time to close it
                    // If it has been started, but not stopped (and even if the start time
                    // exceeds thr last sample's time), do not close it - this is for
                    // uniformity.
                    if (pRecorderNode->cnsEndTime < MAXQWORD)
                    {
                        // Ignore hr.
                        hr = CloseMultiFileRecording(pRecorderNode);

                        // pRecorderNode may have been deleted. Do not reference it.

                        DVR_ASSERT(SUCCEEDED(hr), "");

                        // The recording has been been removed from the list. So start
                        // all over again
                        pCurrent = &m_leRecordersList;
                    }
                }
                pCurrent = PREVIOUS_LIST_NODE(pCurrent);
            }
        }

        // Don't allow any more writes. start/stop recording calls
        // regardless of whether this operation is successful
        m_nNotOkToWrite = MINLONG;

        // Note that some files following a recording may
        // have start = end time = MAXQWORD, so that's
        // the only argument that we can send in here.
        //
        // The recorders list should be emptied by this call
        // once ProcessCloseRequest has completed for all the
        // recorder files.
        //
        // hr on return will always be S_OK since failures are
        // skipped over.
        hr = CloseAllWriterFilesBefore(MAXQWORD);
        hrRet = hr;

        // @@@@ Should we return from this function at this point
        // if FAILED(hrRet)????

        // These lists should be empty by now.
        // Note: recording list empty does NOT mean that
        // recorder nodes have been freed. Recorders that
        // have not called DeleteRecording have references
        // to these nodes and the nodes will be deleted
        // in DeleteRecording

        // Recording list may not be empty: if a recording was
        // created and never started, the recorder remains in
        // the list. Note that the corresponding CDVRRecorder object
        // holds a ref count in the writer.
        // DVR_ASSERT(IsListEmpty(&m_leRecordersList), "");

        DVR_ASSERT(IsListEmpty(&m_leWritersList), "");

        // Delete all the writer nodes. However, this will not
        // delete writer nodes corresponding to recorders that
        // were not started - since those recordings have not
        // been closed. Those writer nodes are deleted in the
        // destructor.
        pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        while (pCurrent != &m_leFreeList)
        {
            PASF_WRITER_NODE pFreeNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

            DVR_ASSERT(pFreeNode->hFileClosed, "");

            // Ignore the returned status
            ::WaitForSingleObject(pFreeNode->hFileClosed, INFINITE);
            DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");
            RemoveEntryList(pCurrent);
            delete pFreeNode;
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        }

        // Note that we cannot delete the file collection object
        // here if we allow post recordings. Recorders may want
        // to Start/StopRecordings after Close and we have to have
        // the file collection object around to know if the
        if (m_pDVRFileCollection)
        {
            hr = m_pDVRFileCollection->SetWriterHasBeenClosed(&m_FileCollectionInfo);
            if (SUCCEEDED(hrRet) && FAILED(hr))
            {
                hrRet = hr;
            }
        }

        // Release the profile
        if (m_pProfile)
        {
            m_pProfile->Release();
            m_pProfile = NULL;
        }

        SetFlags(WriterClosed);
        hrRet = S_OK;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::Close

STDMETHODIMP CDVRRingBufferWriter::CreateRecorder(
    IN  LPCWSTR             pwszDVRFileName,
    IN  DWORD               dwFlags,
    OUT IDVRRecorder**      ppDVRRecorder)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CreateRecorder"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;
    WCHAR*  pwszFileName = NULL;

    if (!pwszDVRFileName || DvrIopIsBadStringPtr(pwszDVRFileName) ||
        !ppDVRRecorder || DvrIopIsBadWritePtr(ppDVRRecorder, 0)   ||
        dwFlags > (DVR_RECORDING_FLAG_PERSISTENT_RECORDING | DVR_RECORDING_FLAG_MULTI_FILE_RECORDING)
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);

        if (ppDVRRecorder && !DvrIopIsBadWritePtr(ppDVRRecorder, 0))
        {
            *ppDVRRecorder = NULL;
        }

        return E_INVALIDARG;
    }

    *ppDVRRecorder = NULL;

    // Get fully qualified file name and verify that the file does not
    // exist

    DWORD dwLastError = 0;
    BOOL bRet = 0;

    __try
    {
        // Get fully qualified name of file.
        WCHAR wTempChar;
        DWORD nLen;
        DWORD nGot ;    //  for PREFIX

        nLen = ::GetFullPathNameW(pwszDVRFileName, 0, &wTempChar, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "First GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            __leave;
        }

        pwszFileName = new WCHAR[nLen+1];

        if (!pwszFileName)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", nLen+1);
            __leave;
        }

        nGot = ::GetFullPathNameW(pwszDVRFileName, nLen+1, pwszFileName, NULL);
        if (nGot == 0 ||
            nGot > nLen+1)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "Second GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            __leave;
        }

        nLen = nGot ;

        // Verify that the file does not exist

        WIN32_FIND_DATA FindFileData;
        HANDLE hFind;

        hFind = ::FindFirstFileW(pwszFileName, &FindFileData);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "File already exists");
            ::FindClose(hFind);
            dwLastError = ERROR_ALREADY_EXISTS;
            __leave;
        }
        else
        {
            dwLastError = ::GetLastError();
            if (dwLastError != ERROR_FILE_NOT_FOUND)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "FindFirstFile failed, last error = 0x%x",
                                dwLastError);
                __leave;
            }
            // File is not found; this is what we want
            dwLastError = 0;
        }
    }
    __finally
    {
        if (hrRet != S_OK || dwLastError != 0)
        {
            if (dwLastError != 0)
            {
                hrRet = HRESULT_FROM_WIN32(dwLastError);
            }
            DVRIO_TRACE_LEAVE1_HR(hrRet);
            delete [] pwszFileName;
            bRet = 1;
        }
    }
    if (bRet)
    {
        return hrRet;
    }

    DVR_ASSERT(hrRet == S_OK, "Should have returned on failure?!");

    PASF_RECORDER_NODE pRecorderNode = NULL;
    CDVRRecorder*      pRecorderInstance = NULL;

    hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }

        // Construct the class objects we need

        pRecorderNode = new ASF_RECORDER_NODE(pwszFileName, &hr);

        if (!pRecorderNode)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - ASF_RECORDER_NODE");
            __leave;
        }

        pwszFileName = NULL; // pRecorderNode's destuctor will delete it.

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        pRecorderInstance = new CDVRRecorder(this, &pRecorderNode->leListEntry, &hr);
        if (!pRecorderInstance)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - CDVRRecorder");
            __leave;
        }

        // This is not addref'd; otherwise it would create a circular refcount.
        // We do, however, addref it if DVRIO_PERSISTENT_RECORDING is specified (below).
        pRecorderNode->SetRecorderInstance(pRecorderInstance);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (dwFlags & DVR_RECORDING_FLAG_MULTI_FILE_RECORDING)
        {
            //  ================================================================
            //  reference recording

            // We do NOT verify that the ring buffer is being created on a
            // NTFS partition (or one that supports hard links). This is
            // deliberate. For all we know, the client may want to create
            // an overlapped recording of a single file recording which
            // has been created on an NTFS partition.

            PASF_MULTI_FILE_RECORDER_NODE pMultiFileRecorderNode;

            // Use the same sids for the recorder as we do for the writer - at least for now.
            pMultiFileRecorderNode = new ASF_MULTI_FILE_RECORDER_NODE(pRecorderNode,
                                                                      m_FileCollectionInfo.dwNumSids,
                                                                      m_FileCollectionInfo.ppSids,
                                                                      &hr);
            if (!pMultiFileRecorderNode)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - ASF_MULTI_FILE_RECORDER_NODE");
                __leave;
            }
            if (FAILED(hr))
            {
                hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "ASF_MULTI_FILE_RECORDER_NODE construcntor failed, hr = 0x%x",
                                hr);
                delete pMultiFileRecorderNode;
                __leave;
            }

            // pRecorderNode will delete pMultiFileRecorderNode when it is destroyed
            pRecorderNode->SetMultiFileRecorderNode(pMultiFileRecorderNode);

            if (FAILED(hr)) // constructor of ASF_MULTI_FILE_RECORDER_NODE failed
            {
                hrRet = hr;
                __leave;
            }

            CDVRFileCollection* pFileCollection;

            // Note: Setting the # of min and max temp files to 1 and creating
            // a temp file for the multi file recording is a hack. See the
            // comments before the definition of ASF_RECORDER_NODE in dvriop.h
            //
            // For the current sizes of CSharedData and CSharedData::CFileInfo,
            // 13 file nodes is the most we can fit in 8192 bytes (2 x86 pages and
            // (2 default-sized NTFS clusters) and each page can contain at most
            // 7 additional nodes (when we grow the struct)
            pFileCollection = new CDVRFileCollection(&(pMultiFileRecorderNode->FileCollectionInfo),
                                                     1,                           // dwMinNumberOfTempFiles
                                                     1,                           // dwMaxNumberOfTempFiles
                                                     13,                          // dwMaxNumberOfFiles
                                                     7,                           // dwGrowBy,
                                                     TRUE,                        // bStartTimeFixedAtZero
                                                     m_msIndexGranularity,
                                                     m_pwszDVRDirectory,          // Temporary files directory
                                                     pRecorderNode->pwszFileName, // Ring buffer file name
                                                     TRUE,                        // multifile recording
                                                     &hr);
            if (!pFileCollection)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "alloc via new failed - CDVRFileCollection");
                __leave;
            }

            pMultiFileRecorderNode->SetFileCollection(pFileCollection);


            if (FAILED(hr)) // constructor of CDVRFileCollection failed
            {
                hrRet = hr;
                __leave;
            }

            // Call the multi file recorder's file collection to add a temporary file
            LIST_ENTRY*        pWriter;
            LPWSTR             pwszFile = NULL;
            const QWORD        kcnsTempFileStartTime = 0;
            const QWORD        kcnsTempFileEndTime = 1;

            CDVRFileCollection::DVRIOP_FILE_ID nFileId;

            hr = pFileCollection->AddFile(&(pMultiFileRecorderNode->FileCollectionInfo),
                                          &pwszFile,
                                          0,                    // bOpenFromFileCollectionDirectory
                                          kcnsTempFileStartTime,
                                          kcnsTempFileEndTime,
                                          FALSE,                // bPermanentFile,
                                          1,                    // dwDeleteTemporaryFiles
                                          kInvalidFirstSampleOffsetTime,
                                          &nFileId);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            DVR_ASSERT(hr != S_FALSE, "Temp file added to multi file recording is not in ring buffer extent?!");
            DVR_ASSERT(nFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");

            hr = PrepareAFreeWriterNode(pwszFile,
                                        pMultiFileRecorderNode->FileCollectionInfo.dwNumSids,
                                        pMultiFileRecorderNode->FileCollectionInfo.ppSids,
                                        TRUE,                        // dwDeleteTemporaryFiles - Ignored because the MultiFileRecording flag is set
                                        kcnsTempFileStartTime,
                                        kcnsTempFileEndTime,
                                        nFileId,
                                        pRecorderNode,
                                        pWriter);

            // We don't need this any more. AddFile allocated it. It has been saved away in pWriter
            // which will delete it. If PrepareAFreeWriterNode() failed, this may already have been
            // deleted.
            pwszFile = NULL;

            if (FAILED(hr))
            {
                // The file added by AddFile will be deleted (DeleteFile will be called) when
                // the file collection is deleted since it is a temp file.
                // We don't need to clean up pFileCollection (by calling its SetFileTimes to
                // remove the file we added) since pFileCollection is going to be deleted anyway.
                hrRet = hr;
                __leave;
            }


            DVR_ASSERT(pWriter != NULL, "");

            pRecorderNode->SetWriterNode(CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry));
        }
        else
        {
            //  ================================================================
            //  content recording

            LIST_ENTRY*        pWriter;

            hr = PrepareAFreeWriterNode(NULL,                        // pRecorderNode->pwszFileName will be used
                                        m_FileCollectionInfo.dwNumSids,
                                        m_FileCollectionInfo.ppSids,
                                        0,                           // dwDeleteTemporaryFiles, ignored for recorder nodes
                                        pRecorderNode->cnsStartTime, // for consistency with info in pRecorderNode
                                        pRecorderNode->cnsEndTime,   // for consistency with info in pRecorderNode
                                        CDVRFileCollection::DVRIOP_INVALID_FILE_ID,
                                        pRecorderNode,
                                        pWriter);

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            DVR_ASSERT(pWriter != NULL, "");

            pRecorderNode->SetWriterNode(CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry));

            //  send the IWMHeaderInfo pointer back out the recording object
            if (pRecorderNode -> pWriterNode -> pIWMHeaderInfo) {
                pRecorderInstance -> SetIWMHeaderInfo (pRecorderNode -> pWriterNode -> pIWMHeaderInfo) ;
            }
        }

        // Insert into recorders list
        hr = AddToRecordersList(&pRecorderNode->leListEntry);

        if (FAILED(hr))
        {
            // This cannot happen since start = end time = MAXQWORD
            DVR_ASSERT(pRecorderNode->cnsStartTime == MAXQWORD, "");
            DVR_ASSERT(pRecorderNode->cnsEndTime == MAXQWORD, "");
            DVR_ASSERT(SUCCEEDED(hr), "AddToRecordersList failed?!");
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "AddToRecordersList failed");
            hrRet = hr;
            __leave;
        }

        // Wait for BeginWriting to finish - do this after releasing m_csLock
        // Note that if the client cannot delete this recorder since it does
        // not yet have an IDVRRecorder for this recorder. Also CDVRRecorder has
        // a refcount on the ring buffer writer, so the ring buffer writer cannot
        // be destroyed. Calling Close will not change the recorders list.


        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete [] pwszFileName;
            if (pRecorderInstance == NULL)
            {
                delete pRecorderNode;
            }
            else
            {
                // Deleting pRecorderInstance will call DeleteRecorder delete pRecorderNode.
                delete pRecorderInstance;
            }
            DVRIO_TRACE_LEAVE1_HR(hrRet);
            bRet = 1;
        }

        ::LeaveCriticalSection(&m_csLock);
    }
    if (bRet)
    {
        return hrRet;
    }

    DVR_ASSERT(hrRet == S_OK, "");

    // Wait for BeginWriting to finish after releasing m_csLock
    DVR_ASSERT(pRecorderNode, "");
    DVR_ASSERT(pRecorderNode->pWriterNode, "");
    DVR_ASSERT(pRecorderNode->pWriterNode->hReadyToWriteTo, "");
    if (::WaitForSingleObject(pRecorderNode->pWriterNode->hReadyToWriteTo, INFINITE) == WAIT_FAILED)
    {
        DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

        dwLastError = ::GetLastError();
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                        "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x",
                        pRecorderNode->pWriterNode->hReadyToWriteTo, dwLastError);
        hrRet = HRESULT_FROM_WIN32(dwLastError);
    }

    if (SUCCEEDED(hrRet))
    {
        // This value has been put there by ProcessOpenRequest

        hrRet = pRecorderNode->hrRet;
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "ProcessOpenRequest/BeginWriting failed, hr = 0x%x",
                            hrRet);
        }
    }

    if (SUCCEEDED(hrRet))
    {
        DVR_ASSERT(pRecorderInstance, "");
        hrRet = pRecorderInstance->QueryInterface(IID_IDVRRecorder, (void**) ppDVRRecorder);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRRecorder failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "pRecorderInstance->QueryInterface failed, hr = 0x%x",
                            hrRet);
        }
    }

    if (FAILED(hrRet))
    {
        // This will delete pRecorderNode as well

        pRecorderNode = NULL;
        delete pRecorderInstance;
        pRecorderInstance = NULL;
    }
    else if (dwFlags & DVR_RECORDING_FLAG_PERSISTENT_RECORDING)
    {
        // Do this as the last step when we know we are going to return success
        pRecorderInstance->AddRef();
        pRecorderNode->SetFlags(ASF_RECORDER_NODE::PersistentRecording);
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // CDVRRingBufferWriter::CreateRecorder

STDMETHODIMP CDVRRingBufferWriter::CreateReader(IN  DVRIO_NOTIFICATION_CALLBACK  pfnCallback OPTIONAL,
                                                IN  LPVOID                       pvContext OPTIONAL,
                                                OUT IDVRReader**                 ppDVRReader)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CreateReader"

    DVRIO_TRACE_ENTER();

    if (!ppDVRReader || DvrIopIsBadWritePtr(ppDVRReader, 0) ||
        (pfnCallback && DvrIopIsBadVoidPtr(pfnCallback)) ||
        (pvContext && DvrIopIsBadVoidPtr(pvContext))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    // No need to lock.

    // Note; If caller has this pointer, we should not be being destroyed
    // while this function runs. If we are, that's an error on the caller's
    // part (the pointer it has to this should be properly Addref'd). So the
    // lock is not held just to guarantee we won't be destroyed during the
    // call and the destructor does not grab the lock either.

    HRESULT                 hrRet;
    CDVRReader*             p = NULL;
    HKEY                    hDvrIoKey = NULL;
    HKEY                    hRegistryRootKey = NULL;
    BOOL                    bCloseKeys = 1; // Close all keys that we opened (only if this fn fails)


    *ppDVRReader = NULL;

    __try
    {
        DWORD dwRegRet;

        // Give the reader it's own handles so that they can be closed independently

        if (0 == ::DuplicateHandle(::GetCurrentProcess(), m_hRegistryRootKey,
                                   ::GetCurrentProcess(), (LPHANDLE) &hRegistryRootKey,
                                   0,       // desired access - ignored
                                   FALSE,   // bInherit
                                   DUPLICATE_SAME_ACCESS))
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "DuplicateHandle failed for DVR IO key, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        dwRegRet = ::RegCreateKeyExW(
                        hRegistryRootKey,
                        kwszRegDvrIoReaderKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoKey,          // key handle
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                            "RegCreateKeyExW for DVR IO key failed, last error = 0x%x",
                            dwLastError);
           hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        p = new CDVRReader(m_pPVRIOCounters,
                           m_pDVRFileCollection,
                           m_FileCollectionInfo.dwNumSids,
                           m_FileCollectionInfo.ppSids,
                           m_msIndexGranularity,
                           m_pAsyncIo,
                           m_dwIoSize,
                           m_dwBufferCount,
                           pfnCallback,
                           pvContext,
                           hRegistryRootKey,
                           hDvrIoKey,
                           &hrRet);

        if (p == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via new failed - CDVRReader");
            __leave;
        }

        bCloseKeys = 0; // ~CDVRReader will close the keys

        if (FAILED(hrRet))
        {
            __leave;
        }


        hrRet = p->QueryInterface(IID_IDVRReader, (void**) ppDVRReader);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRReader failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "CDVRReader::QueryInterface failed, hr = 0x%x",
                            hrRet);
            __leave;
        }
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete p;

            if (bCloseKeys)
            {
                DWORD dwRegRet;

                if (hDvrIoKey)
                {
                    dwRegRet = ::RegCloseKey(hDvrIoKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hDvrIoKey failed.");
                    }
                }
                if (hRegistryRootKey)
                {
                    DVR_ASSERT(hRegistryRootKey, "");
                    dwRegRet = ::RegCloseKey(hRegistryRootKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hRegistryRootKey failed.");
                    }
                }
            }
        }
        else
        {
            DVR_ASSERT(bCloseKeys == 0, "");
        }
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // CDVRRingBufferWriter::CreateReader

STDMETHODIMP CDVRRingBufferWriter::GetDVRDirectory(OUT LPWSTR* ppwszDirectoryName)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetDVRDirectory"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    // We don;t need the critical section for this function since
    // m_pwszDVRDirectory is set in the constructor and not changed
    // after that. The caller should have an addref'd interface pointer
    // when calling this fn.

    __try
    {
        if (!ppwszDirectoryName)
        {
            hrRet = E_POINTER;
            __leave;
        }

        if (!m_pwszDVRDirectory)
        {
            DVR_ASSERT(m_pwszDVRDirectory, "");

            hrRet = E_FAIL;
            __leave;
        }

        DWORD nLen = (wcslen(m_pwszDVRDirectory) + 1) * sizeof(WCHAR);

        *ppwszDirectoryName = (LPWSTR) ::CoTaskMemAlloc(nLen);
        if (!(*ppwszDirectoryName))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via CoTaskMemAlloc failed - %d bytes", nLen);
            hrRet = E_OUTOFMEMORY;
            __leave;
        }
        wcscpy(*ppwszDirectoryName, m_pwszDVRDirectory);

        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::GetDVRDirectory

STDMETHODIMP CDVRRingBufferWriter::GetRingBufferFileName(OUT LPWSTR* ppwszFileName)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetRingBufferFileName"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    // We don;t need the critical section for this function since
    // m_pwszRingBufferFileName is set in the constructor and not changed
    // after that. The caller should have an addref'd interface pointer
    // when calling this fn.

    __try
    {
        if (!ppwszFileName)
        {
            hrRet = E_POINTER;
            __leave;
        }

        if (!m_pwszRingBufferFileName)
        {
            *ppwszFileName = NULL;
            hrRet = S_FALSE;
            __leave;
        }

        DWORD nLen = (wcslen(m_pwszRingBufferFileName) + 1) * sizeof(WCHAR);

        *ppwszFileName = (LPWSTR) ::CoTaskMemAlloc(nLen);
        if (!(*ppwszFileName))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                            "alloc via CoTaskMemAlloc failed - %d bytes", nLen);
            hrRet = E_OUTOFMEMORY;
            __leave;
        }
        wcscpy(*ppwszFileName, m_pwszRingBufferFileName);

        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::GetRingBufferFileName

STDMETHODIMP CDVRRingBufferWriter::GetRecordings(OUT DWORD*   pdwCount,
                                                 OUT IDVRRecorder*** pppIDVRRecorder OPTIONAL,
                                                 OUT LPWSTR** pppwszFileName OPTIONAL,
                                                 OUT QWORD**  ppcnsStartTime OPTIONAL,
                                                 OUT QWORD**  ppcnsStopTime OPTIONAL,
                                                 OUT BOOL**   ppbStarted OPTIONAL,
                                                 OUT DWORD**  ppdwFlags OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetRecordings"

    DVRIO_TRACE_ENTER();

    if (!pdwCount || DvrIopIsBadWritePtr(pdwCount, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        return E_POINTER;
    }
    if ((pppIDVRRecorder && DvrIopIsBadWritePtr(pppIDVRRecorder, 0))    ||
        (pppwszFileName && DvrIopIsBadWritePtr(pppwszFileName, 0))      ||
        (ppcnsStartTime && DvrIopIsBadWritePtr(ppcnsStartTime, 0))      ||
        (ppcnsStopTime && DvrIopIsBadWritePtr(ppcnsStopTime, 0))        ||
        (ppbStarted && DvrIopIsBadWritePtr(ppbStarted, 0))              ||
        (ppdwFlags && DvrIopIsBadWritePtr(ppdwFlags, 0))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        return E_POINTER;
    }

    HRESULT hrRet = S_OK;

    IDVRRecorder** ppIDVRRecorder = NULL;
    LPWSTR*        ppwszFileName  = NULL;
    QWORD*         pcnsStartTime  = NULL;
    QWORD*         pcnsStopTime   = NULL;
    BOOL*          pbStarted      = NULL;
    DWORD*         pdwFlags       = NULL;
    DWORD          dwCount        = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        BOOL        bDone = 1;
        LIST_ENTRY* pCurrent;

        // Determine number of recorders and the max file name len

        pCurrent = NEXT_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            dwCount++;
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }

        if (dwCount == 0)
        {
            __leave;
        }

        // Allocate memory

        if (pppIDVRRecorder)
        {
            ppIDVRRecorder = (IDVRRecorder**) ::CoTaskMemAlloc(dwCount *
                                                               sizeof(IDVRRecorder *));
            if (!ppIDVRRecorder)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            ::ZeroMemory(ppIDVRRecorder, dwCount * sizeof(IDVRRecorder *));
            bDone = 0;
        }

        if (pppwszFileName)
        {
            ppwszFileName = (LPWSTR*) ::CoTaskMemAlloc(dwCount * sizeof(LPWSTR));
            if (!ppwszFileName)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            ::ZeroMemory(ppwszFileName, dwCount * sizeof(LPWSTR));
            bDone = 0;
        }

        if (ppcnsStartTime)
        {
            pcnsStartTime = (QWORD*) ::CoTaskMemAlloc(dwCount * sizeof(QWORD));
            if (!pcnsStartTime)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            bDone = 0;
        }

        if (ppcnsStopTime)
        {
            pcnsStopTime = (QWORD*) ::CoTaskMemAlloc(dwCount * sizeof(QWORD));
            if (!pcnsStopTime)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            bDone = 0;
        }

        if (ppbStarted)
        {
            pbStarted = (BOOL*) ::CoTaskMemAlloc(dwCount * sizeof(BOOL));
            if (!pbStarted)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            bDone = 0;
        }

        if (ppdwFlags)
        {
            pdwFlags = (DWORD*) ::CoTaskMemAlloc(dwCount * sizeof(DWORD));
            if (!pdwFlags)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            bDone = 0;
        }

        if (bDone)
        {
            __leave;
        }

        // Get the current stream time

        QWORD cnsStreamTime = MAXQWORD;

        if (pbStarted && !IsFlagSet(WriterClosed))
        {
            HRESULT hr = m_pDVRFileCollection->GetLastStreamTime(&m_FileCollectionInfo, &cnsStreamTime);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
        }

        // Copy over the info

        DWORD i = 0;

        pCurrent = NEXT_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            PASF_RECORDER_NODE pRecorderNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);

            if (ppIDVRRecorder)
            {
                if (pRecorderNode->pRecorderInstance)
                {
                    HRESULT hr;
                    hr = pRecorderNode->pRecorderInstance->QueryInterface(IID_IDVRRecorder,
                                                                          (void**) &ppIDVRRecorder[i]);
                    if (FAILED(hr))
                    {
                        hrRet = hr;
                        __leave;
                    }
                }
                else
                {
                    DVR_ASSERT(0, "");
                    hrRet = E_FAIL;
                    __leave;
                }
            }
            if (ppwszFileName)
            {
                DWORD nLen = pRecorderNode->pwszFileName? 1 + wcslen(pRecorderNode->pwszFileName) : 1;

                ppwszFileName[i] = (LPWSTR) ::CoTaskMemAlloc(nLen * sizeof(WCHAR));
                if (!ppwszFileName[i])
                {
                    hrRet = E_OUTOFMEMORY;
                    __leave;
                }

                if (pRecorderNode->pwszFileName)
                {
                    wcscpy(ppwszFileName[i], pRecorderNode->pwszFileName);
                }
                else
                {
                    // Should not happen
                    ppwszFileName[i][0] = L'\0';
                }
            }
            if (pcnsStartTime)
            {
                pcnsStartTime[i] = pRecorderNode->cnsStartTime;
            }
            if (pcnsStopTime)
            {
                pcnsStopTime[i] = pRecorderNode->cnsEndTime;
            }
            if (pbStarted)
            {
                if (IsFlagSet(WriterClosed) || pRecorderNode->cnsStartTime == MAXQWORD)
                {
                    // If the writer has been closed, the only nodes left in
                    // m_leRecordersList are the ones that have not been
                    // started (including those whose start times were never set).
                    // Any node that had been started would have been closed when
                    // the writer was closed.

                    // This will change if we support ASX files

                    pbStarted[i] = 0;
                }
                else
                {
                    pbStarted[i] = cnsStreamTime >= pRecorderNode->cnsStartTime;
                }
            }
            if (pdwFlags)
            {
                pdwFlags[i] = (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::PersistentRecording) ?  DVR_RECORDING_FLAG_PERSISTENT_RECORDING : 0) |
                              (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::MultiFileRecording) ?  DVR_RECORDING_FLAG_MULTI_FILE_RECORDING : 0);
            }
            i++;
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }

        DVR_ASSERT(i == dwCount, "");

        hrRet = S_OK;

    }
    __finally
    {
        if (FAILED(hrRet))
        {
            for (DWORD i = 0; i < dwCount; i++)
            {
                if (ppIDVRRecorder && ppIDVRRecorder[i])
                {
                    ppIDVRRecorder[i]->Release();
                }
                if (ppwszFileName && ppwszFileName[i])
                {
                    ::CoTaskMemFree(ppwszFileName[i]);
                }
            }
            if (ppIDVRRecorder)
            {
                ::CoTaskMemFree(ppIDVRRecorder);
                ppIDVRRecorder = NULL;
            }
            if (ppwszFileName)
            {
                ::CoTaskMemFree(ppwszFileName);
                ppwszFileName = NULL;
            }
            if (pcnsStartTime)
            {
                ::CoTaskMemFree(pcnsStartTime);
                pcnsStartTime = NULL;
            }
            if (pcnsStopTime)
            {
                ::CoTaskMemFree(pcnsStopTime);
                pcnsStopTime = NULL;
            }
            if (pbStarted)
            {
                ::CoTaskMemFree(pbStarted);
                pbStarted = NULL;
            }
            if (pdwFlags)
            {
                ::CoTaskMemFree(pdwFlags);
                pdwFlags = NULL;
            }
            dwCount = 0;
        }

        *pdwCount = dwCount;
        if (pppIDVRRecorder)
        {
            *pppIDVRRecorder = ppIDVRRecorder;
        }
        if (pppwszFileName)
        {
            *pppwszFileName = ppwszFileName;
        }
        if (ppcnsStartTime)
        {
            *ppcnsStartTime = pcnsStartTime;
        }
        if (ppcnsStopTime)
        {
            *ppcnsStopTime = pcnsStopTime;
        }
        if (ppbStarted)
        {
            *ppbStarted = pbStarted;
        }
        if (ppdwFlags)
        {
            *ppdwFlags = pdwFlags;
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::GetRecordings

STDMETHODIMP CDVRRingBufferWriter::GetStreamTimeExtent(OUT  QWORD*  pcnsStartStreamTime,
                                                       OUT  QWORD*  pcnsEndStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetStreamTimeExtent"

    DVRIO_TRACE_ENTER();

    if (!pcnsStartStreamTime || DvrIopIsBadWritePtr(pcnsStartStreamTime, 0) ||
        !pcnsEndStreamTime || DvrIopIsBadWritePtr(pcnsEndStreamTime, 0)
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        return E_POINTER;
    }

    HRESULT hrRet = S_OK;
    QWORD cnsStreamTime = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        // Get the current stream extent

        DVR_ASSERT(m_pDVRFileCollection, "");

        hrRet = m_pDVRFileCollection->GetTimeExtent(&m_FileCollectionInfo,
                                                    pcnsStartStreamTime,
                                                    pcnsEndStreamTime);
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRRingBufferWriter::GetStreamTimeExtent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrall.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrall.h

    Abstract:

        This module is the main header for all ts/dvr

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__dvrall_h
#define __tsdvr__dvrall_h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <tchar.h>
#include <limits.h>
#include <delayimp.h>

//  dshow
#include <streams.h>
#include <dvdmedia.h>       //  MPEG2VIDEOINFO

//  WMSDK
#include <wmsdk.h>

#include "dxmperf.h"

//  project
#include "dvrdef.h"
#include "dvrfor.h"
#include "dvrtrace.h"
#include "dvrmacros.h"
#include "dvranalysis.h"
#include "sbeattrib.h"
#include "sbe.h"
#include "dvrdspriv.h"
#include "dvrw32.h"
#include "dvrperf.h"
#include "dvrutil.h"
#include "dvrpolicy.h"
#include "dvrioidl.h"

//  prototype for analysis logic's class factory method to host logic into
//   DShow filter
HRESULT
CreateDVRAnalysisHostFilter (
    IN  IUnknown *  punkOuter,
    IN  IUnknown *  punkAnalysisLogic,
    IN  REFCLSID    rCLSID,
    OUT CUnknown ** punkAnalysisFilterHost
    ) ;

#endif  //  __tsdvr__dvrall_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrdef.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdef.h

    Abstract:

        This module all the #defines

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        04-Apr-2001     created

--*/

#ifndef __tsdvr__dvrdef_h
#define __tsdvr__dvrdef_h

//  ============================================================================
//  constants

//  universal undefined value
#define UNDEFINED   -1

//  max dshow REFERENCE_TIME
#define MAX_REFERENCE_TIME                  0x7FFFFFFFFFFFFFFF

//  mpeg-2
//  00 00 01
#define START_CODE_PREFIX_LENGTH            3

//  mpeg-2
//  00 00 01 xx
#define START_CODE_LENGTH                   (START_CODE_PREFIX_LENGTH + 1)

//  registry values
#define DVR_STATS_DISABLED                  0
#define DVR_STATS_ENABLED                   1

//  stream numbers in WMSDK profiles
#define WMSDK_MIN_VALID_STREAM_NUM          1
#define WMSDK_MAX_VALID_STREAM_NUM          63
#define WMSDK_PROFILE_MAX_STREAMS           (WMSDK_MAX_VALID_STREAM_NUM - WMSDK_MIN_VALID_STREAM_NUM)

#define MAX_PIN_BANK_SIZE                   WMSDK_PROFILE_MAX_STREAMS

//  for VBR, we compute the max bitrate as uncompressed frame size *
//   frames per second; some of the VIDEOINFOHEADER structs though, seem to
//   have the .AvgTimePerFrame member 0ed out, so this value is our guess
#define VBR_DEF_FPS                         30

//  1x default
#define _1X_PLAYBACK_RATE                   1

//  master clock vs. host clock; this value the slope of each's delta; if they
//    are the same, the slope will be 1.0
#define CLOCKS_SAME_SCALING_VALUE           1

//  this is the directory name that the DVRIO layer stores the ring buffer
//    in; this name is appended to either a registry value, or to the session's
//    TEMP dir; ** this is a copy of the name -- DVRIO code has a copy, so if
//    this is changed, it must be changed in both files (dvriofilecollection.cpp)
//    **
#define DVRIO_RINGBUFFER_TEMPDIRNAME        L"TempDVR"

//  slowest forward and backwards trick
#define TRICK_PLAY_LOWEST_RATE              (0.1)

//  ----------------------------------------------------------------------------
//  temp storage min/max values
#define DVR_MIN_HARD_STOP_MIN_BACKING_FILES             4
#define DVR_MAX_HARD_STOP_MIN_BACKING_FILES             100

#define DVR_MIN_HARD_STOP_MIN_MAX_DELTA                 2

#define DVR_MIN_HARD_STOP_MAX_BACKING_FILES             (DVR_MIN_HARD_STOP_MIN_BACKING_FILES + DVR_MIN_HARD_STOP_MIN_MAX_DELTA)
#define DVR_MAX_HARD_STOP_MAX_BACKING_FILES             (DVR_MAX_HARD_STOP_MIN_BACKING_FILES + DVR_MIN_HARD_STOP_MIN_MAX_DELTA)

//  seconds
#define DVR_MIN_HARD_STOP_BACKING_FILE_DURATION_SEC     15

//  ============================================================================
//  registry constants

//  -------------------------------
//  top level location
#define REG_DVR_TOP_LEVEL                       HKEY_CURRENT_USER
#define REG_DVR_2ND_LEVEL                       TEXT ("SOFTWARE\\Microsoft")
#define REG_DVR_ROOT                            TEXT ("DVR")

//  dupe of what's in the dvrio code layer i.e. if those are ever changed,
//    these'zvgotta be changed as well
#define REG_DVRIO_WRITER_LOCATION               TEXT ("IO\\Writer")
#define REG_DVRIO_WRITER_LOCATION_KEYNAME       TEXT ("DVRDirectory")

//  -------------------------------
//  analysis-related
#define REG_DVR_ANALYSIS_LOGIC_MPEG2_VIDEO      TEXT ("Analysis") TEXT ("\\") TEXT ("Mpeg-2 Video")
#define REG_DVR_ANALYSIS_LOGIC_HOSTING_FILTER   TEXT ("Analysis") TEXT ("\\") TEXT ("Filter")

#define REG_DVR_STATS_NAME                      TEXT ("Stats")
#define REG_CONST_DVR_STATS                     FALSE
#define REG_DEF_STATS                           DVR_STATS_DISABLED

#define REG_ANALYSIS_HOSTING_FILTER_STATS       TEXT ("Hosting Filter")
#define REG_DEF_ANALYSIS_HOSTING_FILTER_STATS   DVR_STATS_DISABLED

#define REG_DVR_ANALYSIS_ROOT                   TEXT ("DVRAnalysis")
#define REG_DVR_STREAM_SINK_ROOT                TEXT ("DVRStreamSink")
#define REG_DVR_PLAY_ROOT                       TEXT ("DVRPlay")

//  stale filters
#define REG_DVR_STREAM_THROUGH_ROOT             TEXT ("DVRStreamThrough")
#define REG_DVR_STREAM_SOURCE_ROOT              TEXT ("DVRStreamSource")

//  BUGBUG
//  temporary registry entries follow i.e. those that should eventually not
//   be used, but are currently useful for testing & integration purposes

//  WMSDK stream's buffer window
#define REG_WM_BUFFER_WINDOW_NAME               TEXT ("WMBufferWindowMillis")
#define REG_CONST_WM_BUFFER_WINDOW              TRUE
#define REG_DEF_WM_BUFFER_WINDOW                0

//  WMSDK packet size;
#define REG_WM_PACKET_SIZE_NAME                 TEXT ("WMPacketSizeBytes")
#define REG_CONST_WM_PACKET_SIZE                FALSE
#define REG_DEF_WM_PACKET_SIZE                  0xffff
#define REG_MIN_WM_PACKET_SIZE                  0x1000
#define REG_MAX_WM_PACKET_SIZE                  REG_DEF_WM_PACKET_SIZE

//
//  The WMSDK validates mediatypes.  There are currently bugs in the
//   validation code that prevent us from storing audio and video subtypes
//   that they don't explicitely know about.  For now, we hack around
//   this by introducing our own hacky mediatypes, one for video and one
//   for audio, so we are not blocked.  We translate to/from on the in/out
//   of the SDK.  This is hideous but effective.
//
//  global variable if we are to use generic streams or not - settable via
//   the registry
extern BOOL g_fRegGenericStreams_Video ;
#define REG_VID_USE_GENERIC_STREAMS_NAME        TEXT ("Video_UseGenericStreams")
#define REG_VID_USE_GENERIC_STREAMS_DEFAULT     FALSE
#define REG_CONST_VID_USE_GENERIC_STREAMS       TRUE

extern BOOL g_fRegGenericStreams_Audio ;
#define REG_AUD_USE_GENERIC_STREAMS_DEFAULT     TRUE
#define REG_AUD_USE_GENERIC_STREAMS_NAME        TEXT ("Audio_UseGenericStreams")
#define REG_CONST_AUD_USE_GENERIC_STREAMS       FALSE

#define REG_MIN_NUM_BACKING_FILES_NAME          TEXT ("BackingStoreMinNumBackingFiles")
#define REG_CONST_MIN_NUM_BACKING_FILES         FALSE
#define REG_DEF_MIN_NUM_BACKING_FILES           DVR_MIN_HARD_STOP_MIN_BACKING_FILES

#define REG_MAX_NUM_BACKING_FILES_NAME          TEXT ("BackingStoreMaxNumBackingFiles")
#define REG_CONST_MAX_NUM_BACKING_FILES         FALSE
#define REG_DEF_MAX_NUM_BACKING_FILES           DVR_MIN_HARD_STOP_MAX_BACKING_FILES

#define REG_MIN_MIN_NUM_BACKING_FILES           DVR_MIN_HARD_STOP_MIN_BACKING_FILES
#define REG_MAX_MIN_NUM_BACKING_FILES           0x100

#define REG_MIN_MAX_NUM_BACKING_FILES           DVR_MIN_HARD_STOP_MIN_BACKING_FILES
#define REG_MAX_MAX_NUM_BACKING_FILES           0x100

#define REG_RING_BUFFER_GROW_BY_NAME            TEXT ("BackingStoreGrowBy")
#define REG_CONST_RING_BUFFER_GROW_BY           FALSE
#define REG_DEF_RING_BUFFER_GROW_BY             DVR_MIN_HARD_STOP_MIN_BACKING_FILES

#define REG_BACKING_FILE_DURATION_SECONDS_NAME  TEXT ("BackingStoreEachFileDurationSeconds")
#define REG_CONST_BACKING_FILE_DURATION_SECONDS FALSE
#define REG_DEF_BACKING_FILE_DURATION_SECONDS   300
#define REG_MIN_BACKING_FILE_DURATION_SECONDS   DVR_MIN_HARD_STOP_BACKING_FILE_DURATION_SEC
#define REG_MAX_BACKING_FILE_DURATION_SECONDS   0xffffffff

#define REG_MAX_STREAM_DELTA_NAME               TEXT ("MaxStreamDeltaMillis")
#define REG_CONST_MAX_STREAM_DELTA              TRUE
#define REG_DEF_MAX_STREAM_DELTA                1

#define REG_SOURCE_ALLOCATOR_CBUFFERS_NAME      TEXT ("BufferPoolSize")
#define REG_CONST_SOURCE_ALLOCATOR_CBUFFERS     FALSE
#define REG_DEF_SOURCE_ALLOCATOR_CBUFFERS       0x100
#define REG_MIN_SOURCE_ALLOCATOR_CBUFFERS       REG_DEF_SOURCE_ALLOCATOR_CBUFFERS
#define REG_MAX_SOURCE_ALLOCATOR_CBUFFERS       0x200

//  based on the capture packet rate, we can compute how many buffers we should
//    have in our pool based on time
#define REG_BUFFERPOOL_MILLIS_NAME              TEXT ("BufferPoolTotalMillis")
#define REG_CONST_BUFFERPOOL_MILLIS             FALSE
#define REG_DEF_BUFFERPOOL_MILLIS               1500
#define REG_MIN_BUFFERPOOL_MILLIS               1000
#define REG_MAX_BUFFERPOOL_MILLIS               4000

//  we can dynamically grow the size of the buffer pool up to this max; the
//    buffer consists just of wrappers so they are relatively cheap; initial
//    value is defined above (BufferPoolSize), but we can grow it by
//    BufferPooGrowBy count up the max that is specified here
#define REG_BUFFERPOOL_MAX_NAME                 TEXT ("BufferPoolMaxPerStream")
#define REG_CONST_BUFFERPOOL_MAX                FALSE
#define REG_DEF_BUFFERPOOL_MAX                  (REG_DEF_SOURCE_ALLOCATOR_CBUFFERS + (REG_DEF_SOURCE_ALLOCATOR_CBUFFERS / 2))
#define REG_MIN_BUFFERPOOL_MAX                  REG_MIN_SOURCE_ALLOCATOR_CBUFFERS
#define REG_MAX_BUFFERPOOL_MAX                  (REG_MAX_SOURCE_ALLOCATOR_CBUFFERS * 2)

#define REG_SOURCE_ALLOCATOR_CBBUFFER_NAME      TEXT ("Allocator.cbBuffer")
#define REG_CONST_SOURCE_ALLOCATOR_CBBUFFER     TRUE
#define REG_DEF_SOURCE_ALLOCATOR_CBBUFFER       0x2000

#define REG_SOURCE_ALLOCATOR_ALIGN_VAL_NAME     TEXT ("Allocator.cbAlign")
#define REG_CONST_SOURCE_ALLOCATOR_ALIGN_VAL    TRUE
#define REG_DEF_SOURCE_ALLOCATOR_ALIGN_VAL      1

#define REG_SOURCE_ALLOCATOR_PREFIX_VAL_NAME    TEXT ("Allocator.cbPrefix")
#define REG_CONST_SOURCE_ALLOCATOR_PREFIX_VAL   TRUE
#define REG_DEF_SOURCE_ALLOCATOR_PREFIX_VAL     0

#define REG_INLINE_DSHOW_PROPS_NAME             TEXT ("InlineDShowProps")
#define REG_CONST_INLINE_DSHOW_PROPS            TRUE
#define REG_DEF_INLINE_DSHOW_PROPS              TRUE

#define REG_SUCCEED_QUERY_ACCEPT_NAME           TEXT ("SucceedQueryAccept")
#define REG_CONST_SUCCEED_QUERY_ACCEPT          FALSE
#define REG_DEF_SUCCEED_QUERY_ACCEPT            TRUE

//  this value toggles the use or lack thereof, of a continuity counter that
//   enables us to count samples written vs. those read out; this helps with
//   debugging, discontinuities, etc...
#define REG_USE_CONTINUITY_COUNTER_NAME         TEXT ("UseContinuityCounter")
#define REG_CONST_USE_CONTINUITY_COUNTER        TRUE
#define REG_DEF_USE_CONTINUITY_COUNTER          TRUE

//  this value toggles a state where we don't send anything downstream until the
//   the first seek is made; the reason for this is that apps may want to seek
//   to the most forward position when the graph goes active;
#define REG_ONACTIVE_WAIT_FIRST_SEEK_NAME       TEXT ("OnActiveWaitFirstSeek")
#define REG_CONST_ONACTIVE_WAIT_FIRST_SEEK      FALSE
#define REG_DEF_ONACTIVE_WAIT_FIRST_SEEK        FALSE

//  value toggles whether or not we implement IReferenceClock
#define REG_IMPLEMENT_IREFERENCECLOCK_NAME      TEXT ("ImplementIReferenceClock")
#define REG_CONST_IMPLEMENT_IREFERENCECLOCK     FALSE
#define REG_DEF_IMPLEMENT_IREFERENCECLOCK       TRUE

//  normally we implement IRefclock iff the above reg value is TRUE & the source
//    is live; alternatively we can implement it always, not just when the
//    source is live
#define REG_ALWAYS_IMPLEMENT_IREFCLOCK_NAME     TEXT ("AlwaysImplementIReferenceClock")
#define REG_CONST_ALWAYS_IMPLEMENT_IREFCLOCK    FALSE
#define REG_DEF_ALWAYS_IMPLEMENT_IREFCLOCK      FALSE

//  we either support IMediaSeeking on the filter or the pins; trick mode can
//    only be supported if we support it on the filter
#define REG_IMPL_IMEDIASEEKING_ON_FILTER_NAME   TEXT ("ImplementIMediaSeekingOnFilter")
#define REG_CONST_IMPL_IMEDIASEEKING_ON_FILTER  TRUE
#define REG_DEF_IMPL_IMEDIASEEKING_ON_FILTER    FALSE

//  true/false if we support IMediaSeeking on pin
#define REG_IMPL_IMEDIASEEKING_ON_PIN_NAME      TEXT ("ImplementIMediaSeekingOnFilter")
#define REG_CONST_IMPL_IMEDIASEEKING_ON_PIN     TRUE
#define REG_DEF_IMPL_IMEDIASEEKING_ON_PIN       FALSE

//  support trick mode or not; currently not 1 decoder vendor properly supports
//    the interfaces; Intervideo is close; Mediamatics ignores; etc... so we
//    disable until we have something that works
#define REG_SUPPORT_TRICK_MODE_NAME             TEXT ("SupportTrickMode")
#define REG_CONST_SUPPORT_TRICK_MODE            TRUE
#define REG_DEF_SUPPORT_TRICK_MODE              TRUE

//  can set the max forward (> 0x) trick mode rate
#define REG_MAX_FORWARD_TRICK_MODE_NAME         TEXT ("MaxForwardTrickModeRate")
#define REG_CONST_MAX_FORWARD_TRICK_MODE        FALSE
#define REG_DEF_MAX_FORWARD_TRICK_MODE          64

//  can set the max reverse (< 0x) trick mode rate
#define REG_MAX_REVERSE_TRICK_MODE_NAME         TEXT ("MaxReverseTrickModeRate")
#define REG_CONST_MAX_REVERSE_TRICK_MODE        FALSE
#define REG_DEF_MAX_REVERSE_TRICK_MODE          6

//  can set the maximum full-frame rate forward trick mode play; if rates
//    above this are specified, trick mode play is just on keyframes
#define REG_MAX_FULLFRAME_F_PLAY_RATE_NAME      TEXT ("MaxFullFrameForwardRate")
#define REG_CONST_MAX_FULLFRAME_F_PLAY_RATE     FALSE
#define REG_DEF_MAX_FULLFRAME_F_PLAY_RATE       4

//  max key-frame only forward play; if full-frame fails, then this value is
//    examined; if value is excessive to this one, call will fail
#define REG_MAX_KEYFRAME_FOR_TRICK_MODE_NAME    TEXT ("MaxKeyFrameForwardRate")
#define REG_CONST_MAX_KEYFRAME_FOR_TRICK_MODE   FALSE
#define REG_DEF_MAX_KEYFRAME_FOR_TRICK_MODE     16

//  can set the granularity of the index; this is the seeking granularity; the
//    the finer the granularity the more entries must be made, but the finer
//    the seeking control
#define REG_INDEX_GRANULARITY_MILLIS_NAME       TEXT ("IndexGranularityMillis")
#define REG_CONST_INDEX_GRANULARITY_MILLIS      FALSE
#define REG_DEF_INDEX_GRANULARITY_MILLIS        500
#define REG_MIN_INDEX_GRANULARITY_MILLIS        200
#define REG_MAX_INDEX_GRANULARITY_MILLIS        2000

//  for media types that we cannot interpret, we must have a bitrate that we
//    can estimate; this is a registry-settable value; default is 20 Mbps
#define REG_DEF_AVG_BITRATE_NAME                TEXT ("DefAvgBitRate")
#define REG_CONST_DEF_AVG_BITRATE               FALSE
#define REG_DEF_DEF_AVG_BITRATE                 20000000

//  can notify downstream decoders of true rates or always make them positive;
//    we monotonically increase rates regardless of forward or backward
//    playback; some of the mpeg-2 video decoders (and associated ac-3 & mpeg-2
//    audio decoders) can handle rates that are backwards, with the
//    understanding that timestamps will still increase monotononically
#define REG_ALL_NOTIFIED_RATES_POSITIVE_NAME    TEXT ("AllNotifiedRatesPositive")
#define REG_CONST_ALL_NOTIFIED_RATES_POSITIVE   FALSE
#define REG_DEF_ALL_NOTIFIED_RATES_POSITIVE     TRUE

//  limit the amount of time ahead of time an app can queue a recording start
//    or stop request
#define REG_MAX_SCHED_REC_RELATIVE_SEC_NAME     TEXT ("MaxScheduledRecRelativeSeconds")
#define REG_CONST_MAX_SCHED_REC_RELATIVE_SEC    FALSE
#define REG_DEF_MAX_SCHED_REC_RELATIVE_SEC      5

//  toggles if we query downstream filters on non-primary streams for rate
//    compatibility; if we don't non 1x rates are quenched by the timeshifting
//    engine; if we do and the downstream filter (typically a decoder) claims
//    compatibility we send everything down, even if the decoder chooses to
//    discard everything
#define REG_QUERY_ALL_FOR_RATE_COMPAT_NAME      TEXT ("QueryAllForRateCompatibility")
#define REG_CONST_QUERY_ALL_FOR_RATE_COMPAT     FALSE
#define REG_DEF_QUERY_ALL_FOR_RATE_COMPAT       TRUE

//  it's possible to seek into a small no-man's land between end of content and
//    end of file (logical); when this occurs, we'll get the seeking failure
//    back out; we try to handle this by probing forward across this small
//    stretch; we'll try up to this many milliseconds worth of content, aligned
//    on the index granularity
//  FORWARD registry val
#define REG_MAX_SEEKING_F_PROBES_NAME           TEXT ("MaxSeekingProbeMillis_Forward")
#define REG_CONST_MAX_SEEKING_F_PROBES          FALSE
#define REG_DEF_MAX_SEEKING_F_PROBES            5000
#define REG_MIN_MAX_SEEKING_F_PROBES            1000
#define REG_MAX_MAX_SEEKING_F_PROBES            10000

//  it's possible to seek into a small no-man's land between end of content and
//    end of file (logical); when this occurs, we'll get the seeking failure
//    back out; we try to handle this by probing forward across this small
//    stretch; we'll try up to this many milliseconds worth of content, aligned
//    on the index granularity
//  REVERSE registry val
#define REG_MAX_SEEKING_R_PROBES_NAME           TEXT ("MaxSeekingProbeMillis_Reverse")
#define REG_CONST_MAX_SEEKING_R_PROBES          FALSE
#define REG_DEF_MAX_SEEKING_R_PROBES            2000
#define REG_MIN_MAX_SEEKING_R_PROBES            1000
#define REG_MAX_MAX_SEEKING_R_PROBES            10000

//  we measure the host clock to master clock difference no closer than this
//    often
#define REG_CLOCKSLAVE_SAMPLING_BRACKET_MILLIS_NAME     TEXT ("ClockSlaveMinSamplingBracketMillis")
#define REG_CONST_CLOCKSLAVE_SAMPLING_BRACKET_MILLIS    FALSE
#define REG_DEF_CLOCKSLAVE_SAMPLING_BRACKET_MILLIS      2000

//  min we try to slave to is when host clock is observed to run at 95% rate
//    of master clock; note that it's dangerous to set this too small, especially
//    if it's smaller than the capture graph's sync; this can lead to AV sync
//    issues
#define REG_CLOCKSLAVE_MIN_SLAVABLE_NAME        TEXT ("ClockSlaveMinSlavable")
#define REG_CONST_CLOCKSLAVE_MIN_SLAVABLE       FALSE
#define REG_DEF_CLOCKSLAVE_MIN_SLAVABLE         95

//  max we try to slave to is when host clock is observed to run at 105% rate
//    of master clock; note that it's dangerous to set this too small, especially
//    if it's smaller than the capture graph's sync; this can lead to AV sync
//    issues
#define REG_CLOCKSLAVE_MAX_SLAVABLE_NAME        TEXT ("ClockSlaveMaxSlavable")
#define REG_CONST_CLOCKSLAVE_MAX_SLAVABLE       FALSE
#define REG_DEF_CLOCKSLAVE_MAX_SLAVABLE         105

//  during trick mode forward play, we can send content downstream in 1 of 3
//    ways: (1) full stream, (2) key frame only, (3) key frame only, with
//    intermediate seek aheads.  The following 2 settings allow some
//    customization of these parameters

//  this is the max rate during which we don't skip ahead i.e. read, send
//    key frame, seek ahead, read, send key frame, etc...
#define REG_MAX_NON_SKIPPING_PLAY_RATE_NAME     TEXT ("MaxNonSkippingPlayRate")
#define REG_CONST_MAX_NON_SKIPPING_PLAY_RATE    FALSE
#define REG_DEF_MAX_NON_SKIPPING_PLAY_RATE      6

//  while we wait for decoder vendors to support our trick mode interface, we
//    make it possible to work with betas by setting this in the registry to
//    TRUE, but default is to pay attention to what they claim
#define REG_CHECK_MPEG2_TRICK_INTERFACE_NAME    TEXT ("CheckMpeg2DecoderTrickModeInterface")
#define REG_CONST_CHECK_MPEG2_TRICK_INTERFACE   FALSE
#define REG_DEF_CHECK_MPEG2_TRICK_INTERFACE     TRUE

//  steady-state, as the reader reads content out, it examines successive
//    packets' timestamps; if this threshold is exceeded, an event is posted
//    that a timehole has been detected; the hosting application can then
//    seek ahead if desired
#define REG_TIMEHOLE_THRESHOLD_MILLIS_NAME      TEXT ("TimeholeThresholdMillis")
#define REG_CONST_TIMEHOLE_THRESHOLD_MILLIS     FALSE
#define REG_DEF_TIMEHOLE_THRESHOLD_MILLIS       5000

//  after a seek, we must rediscover the PTS we use to normalize all the streams'
//    PTS in order to maintain AV sync; we do this by reading in a number of
//    samples (queueing them as we go) and stop when we've read a max number, or
//    discovered each stream's PTS, or failed trying; this value is the max
//    number of reads we make
#define REG_MAX_NORMALIZER_PTS_DISC_READS_NAME  TEXT ("MaxNormalizerPTSDiscReads")
#define REG_CONST_MAX_NORMALIZER_PTS_DISC_READS FALSE
#define REG_DEF_MAX_NORMALIZER_PTS_DISC_READS   REG_DEF_SOURCE_ALLOCATOR_CBUFFERS

//  this is the closest that we can come to live; when we seek we look how
//    close we are to live; if we are closer than this number, we'll pad the
//    timestamps by this amount, so the first frame is shown and held, until we
//    are further back than this number from live, and then the content is
//    played
#define REG_MIN_NEARLIVE_MILLIS_NAME            TEXT ("MinNearLiveMillis")
#define REG_CONST_MIN_NEARLIVE_MILLIS           FALSE
#define REG_DEF_MIN_NEARLIVE_MILLIS             200

//  when we detect that our downstream buffering falls below MinNearLiveMillis,
//    we pad out the timestamps by the deficit + this value; we buffer it up
//    just a bit more than necessary so we make a slight over-correction, vs.
//    under-correcting and requiring another correction in the near future
#define REG_LOW_BUFFER_PADDING_MILLIS_NAME      TEXT ("LowBufferPaddingMillis")
#define REG_CONST_LOW_BUFFER_PADDING_MILLIS     FALSE
#define REG_DEF_LOW_BUFFER_PADDING_MILLIS       50
#define REG_MIN_LOW_BUFFER_PADDING_MILLIS       0
#define REG_MAX_LOW_BUFFER_PADDING_MILLIS       300

//  if we are within this threshold of live content i.e. current EOF, then
//    a forward seek is not performed
#define REG_SEEK_NOOP_NAME                      TEXT ("SeekNoopMillis")
#define REG_CONST_SEEK_NOOP                     FALSE
#define REG_DEF_SEEK_NOOP                       200
#define REG_MIN_SEEK_NOOP                       0
#define REG_MAX_SEEK_NOOP                       500

//  async IO writer; this is the length of the write buffers; when these become
//    full, they are written (asynchronously) to disk; note that everything will
//    be aligned on page boundaries; this number will be page-aligned regardless
//    of the setting in the registry
#define REG_ASYNC_IO_BUFFER_SIZE_NAME           TEXT ("AsyncIoBufferSizeBytes")
#define REG_CONST_ASYNC_IO_BUFFER_SIZE          FALSE
#define REG_DEF_ASYNC_IO_BUFFER_SIZE            0x40000
#define REG_MIN_DEF_ASYNC_IO_BUFFER_SIZE        0x1000
#define REG_MAX_DEF_ASYNC_IO_BUFFER_SIZE        (REG_DEF_ASYNC_IO_BUFFER_SIZE * 4)

//  async IO writer; the number of buffers in the writer's ringbuffer; when
//    a write is made, the buffer content is copied to a buffer; when that buffer
//    becomes full, a write will be pended; this registry setting is the number
//    of such buffers in our pool; note that the bigger the pool the further
//    behind the writer can be
#define REG_ASYNC_WRITER_BUFFER_POOL_NAME       TEXT ("AsyncIoWriterBufferPoolCount")
#define REG_CONST_ASYNC_WRITER_BUFFER_POOL      FALSE
#define REG_DEF_ASYNC_WRITER_BUFFER_POOL        10
#define REG_MIN_ASYNC_WRITER_BUFFER_POOL        1
#define REG_MAX_ASYNC_WRITER_BUFFER_POOL        50

//  async IO reader; this is the number of buffers that the reader will have
//    in its pool to pend read aheads, and maintain in its cache
#define REG_ASYNC_READER_BUFFER_POOL_NAME       TEXT ("AsyncIoReaderBufferPoolCount")
#define REG_CONST_ASYNC_READER_BUFFER_POOL      FALSE
#define REG_DEF_ASYNC_READER_BUFFER_POOL        30
#define REG_MIN_ASYNC_READER_BUFFER_POOL        1
#define REG_MAX_ASYNC_READER_BUFFER_POOL        120

//  async IO writer file growth quantum; rather than growing the files on a
//    per-write basis, files are grown per the set quantum; this number will
//    be aligned with the size of the IO (REG_ASYNC_WRITER_IO_SIZE_NAME)
#define REG_FILE_GROWTH_QUANTUM_NAME            TEXT ("FileGrowthQuantumBytes")
#define REG_CONST_FILE_GROWTH_QUANTUM           FALSE
#define REG_DEF_FILE_GROWTH_QUANTUM             100000000
#define REG_MIN_FILE_GROWTH_QUANTUM             10000000
#define REG_MAX_FILE_GROWTH_QUANTUM             300000000

//  TRUE/FALSE flag if the IO will be unbuffered (and thus asynchronous) or not
#define REG_UNBUFFERED_IO_FLAG_NAME             TEXT ("UnbufferedIo")
#define REG_DEF_UNBUFFERED_IO_FLAG              TRUE
#define REG_CONST_UNBUFFERED_IO_FLAG            FALSE

//  when a rate request is made, we check how close to the EOF we are (forward
//    and backwards); we fail the rate request if are within this threshold of
//    available content; this is for FF
#define REG_FF_REQ_NOOP_BUFFER_MILLIS_NAME      TEXT ("Rate_FFMinBufferMillis")
#define REG_CONST_FF_REQ_NOOP_BUFFER_MILLIS     FALSE
#define REG_DEF_FF_REQ_NOOP_BUFFER_MILLIS       1000
#define REG_MIN_FF_REQ_NOOP_BUFFER_MILLIS       0
#define REG_MAX_FF_REQ_NOOP_BUFFER_MILLIS       5000

//  when a rate request is made, we check how close to the EOF we are (forward
//    and backwards); we fail the rate request if are within this threshold of
//    available content; this is for rewind and slow motion
#define REG_RW_REQ_NOOP_BUFFER_MILLIS_NAME      TEXT ("Rate_RWMinBufferMillis")
#define REG_CONST_RW_REQ_NOOP_BUFFER_MILLIS     FALSE
#define REG_DEF_RW_REQ_NOOP_BUFFER_MILLIS       1000
#define REG_MIN_RW_REQ_NOOP_BUFFER_MILLIS       0
#define REG_MAX_RW_REQ_NOOP_BUFFER_MILLIS       5000

//  ============================================================================

//  filter names
#define STREAMBUFFER_SINK_FILTER_NAME       "StreamBufferSink"
#define STREAMBUFFER_PLAY_FILTER_NAME       "StreamBufferSource"

//  analysis COM server names
#define DVR_MPEG2_FRAME_ANALYSIS            "MPEG-2 Video Stream Analyzer"
#define DVR_MPEG2_FRAME_ANALYSIS_W          L"MPEG-2 Video Stream Analyzer"

//  other COM servers
#define DVR_CONFIGURATION                   "StreamRW Configuration"
#define DVR_CONFIGURATION_W                 L"StreamRW Configuration"

#define DVR_ATTRIBUTES                      "StreamRW Attributes"
#define DVR_ATTRIBYTES_W                    L"StreamRW Attributes"

#define COMP_REC_OBJ_NAME                   "Composite Recording"
#define COMP_REC_OBJ_NAME_W                 L"Composite Recording"

//  profile names & descriptions
#define DVR_STREAM_SINK_PROFILE_NAME        L"DVRStreamSink Profile"
#define DVR_STREAM_SINK_PROFILE_DESCRIPTION L"DVRStreamSink Configuration WM Profile"

//  WMSDK compatibility version
#define WMSDK_COMPATIBILITY_VERSION         WMT_VER_9_0

//  use these to set WM stream attributes
#define WM_MEDIA_VIDEO_TYPE_NAME            L"Video"
#define WM_MEDIA_AUDIO_TYPE_NAME            L"Audio"
#define WM_MEDIA_DATA_TYPE_NAME             L"Data"
#define WM_STREAM_CONNECTION_NAME           L"Connection"

#endif  //  __tsdvr__dvrdef_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrfor.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrfor.h

    Abstract:

        This module contains forward declarations for all C++ classes
        defined in ts/dvr

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__dvrfor_h
#define __tsdvr__dvrfor_h

class CDVRPin ;
//  filters\shared\dvrpins.h
//  common to DVR input and output pins

template <class T>
class CTDVRPinBank ;
//  filters\shared\dvrpins.h
//  generic DVR pin Bank

class CDVRSourcePinManager ;
//  filters\shared\dvrpins.h
//  source pin bank

class CDVRSinkPinManager ;
//  filters\shared\dvrpins.h
//  sink pin bank

class CDVRThroughSinkPinManager ;
//  filters\shared\dvrpins.h
//  inherits from CDVRSinkPinManager, but overrides the completeconnect to
//   callback on filter's

class CDVROutputPin ;
//  filters\shared\dvrpins.h
//  DVR-class filter input pin

class CDVRVideoOutputPin ;
//  filters\shared\dvrpins.h
//  video output pin

class CDVRMpeg2VideoOutputPin ;
//  filters\shared\dvrpins.h
//  mpeg-2 video pin; knows how rate change works

class CDVRMpeg2AudioOutputPin ;
//  filters\shared\dvrpins.h
//  mpeg-2 audio pin; knows how rate change works

class CDVRDolbyAC3AudioOutputPin ;
//  filters\shared\dvrpins.h
//  dolby ac-3 audio pin; knows how rate change works

class CDVRInputPin ;
//  filters\shared\dvrpins.h
//  DVR-class filter output pin

class CIDVRPinConnectionEvents ;
//  filters\shared\dvrpins.h
//  abstract callback interface for input pin events (connection, etc..)

class CIDVRDShowStream ;
//  filters\shared\dvrpins.h
//  abstract callback interface for input pin streaming events (delivery, etc..)

class CMpeg2VideoFrame ;
//  analysis\iframe\dvriframe.h
//  mpeg-2 I-frame detection code; analysis logic

class CDVRStreamSink ;
//  filters\dvrstreamsink\dvrstreamsink.h
//  DVR-class sink filter proper

class CDVRStreamSource ;
//  filters\dvrstreamsource\dvrstreamsource.h
//  DVR-class source filter proper

class CDVRStreamThrough ;
//  filters\dvrstreamthrough\dvrstreamthrough.h
//  DVR-class stream-through filter proper

class CWin32SharedMem ;
//  inc\dvrperf.h
//  generic win32 shared mem object

class CMpeg2VideoStreamStatsMem ;
//  inc\dvrperf.h
//  mpeg-2 video frame analysis shared mem

class CMpeg2VideoStreamStatsWriter ;
//  inc\dvrperf.h

class CMpeg2VideoStreamStatsReader ;
//  inc\dvrperf.h

class CDVRAnalysisMeg2VideoStream ;
//  inc\dvrperf.h
//  mpeg-2 video stream stats (received)

class CPVRIOCounters ;
//  inc\dvrperf.h
//  DVRIO, async IO reader and writer counters

class CDVRAnalysisBuffer ;
//  analysis\dvranalysis
//  media sample wrapper for analysis logic

class CDVRAnalysisBufferPool ;
//  analysis\dvranalysis
//  sample wrapper pool

class CDVRAnalysis ;
//  analysis\dvranalysis
//  analysis filter host

class CDVRAnalysisInput ;
//  analysis\dvranalysis
//  analysis input pin

class CDVRAnalysisOutput ;
//  analysis\dvranalysis
//  analysis output pin

template <class T, DWORD dwAllocationQuantum>
class TStructPool ;
//  inc\dvrutil.h
//  struct pool - for reuse rather than allocating every time

template <int iCacheSize>
class TSizedDataCache ;
//  inc\dvrutil.h
//  data cache

class CDataCache ;
//  inc\dvrutil.h
//  cache that allocates

template <class T>
class TCNonDenseVector ;
//  inc\dvrutil.h
//  non-dense vector template

template <class T>
class TCDenseVector ;
//  inc\dvrutil.h
//  dense vector template

template <class T>
class TCObjPool ;
//  inc\dvrutil.h
//  producer-consumer template

class CMediaSampleWrapperPool ;
//  inc\dvrutil.h
//  media sample wrapper pool

class CMediaSampleWrapper ;
//  inc\dvrutil.h
//  media sample wrapper i.e. wraps another media sample, but exposes own props

template <class T, class K>
class CTSortedList ;
//  inc\dvrutil.h
//  generic sorted list

template <class T, LONG lMax>
class CTSizedQueue ;
//  inc\dvrutil.h
//  generic queue of T items; max size is lMax

class CDVRSourceProp ;
//  dvrprop\dvrsource\dvrsourceprop.h
//  DVR Stream source property page

class CDVRWriteManager ;
//  dvrfilters\shared\dvrdswrite.h
//  manages all writing operations; accepts dshow IMediaSamples

class CDVRWriter ;
//  dvrfilters\shared\dvrdswrite.h
//  DVR writer object; writes INSSBuffers

class CDVRIOWriter ;
//  dvrfilters\shared\dvrdswrite.h
//  uses our DVR IO layer to write INSSBuffers; derives from CDVRWriter

class CSBERecordingWriter ;
//  dvrfilters\shared\dvrdswrite.h
//  pure recording writer; uses DVRSink, so it can be shared, but not DVRIO

class CWMINSSBuffer3Wrapper ;
//  inc\dvrutil.h
//  IUnknown wrapper that exposes the INSSBuffer3 interface

class CPooledWMINSSBuffer3Wrapper ;
//  inc\dvrutil.h
//  CWMINSSBuffer3Wrapper child that is part of a pool

class CWMINSSBuffer3WrapperPool ;
//  inc\dvrutil.h
//  CPooledWMINSSBuffer3Wrapper pool

class CWMPooledINSSBuffer3Holder ;
//  inc\dvrutil.h
//  thunks all the INSSBuffer, INSSBuffer2, INSSBuffer3 calls to core object

class CWMINSSBuffer3HolderPool ;
//  inc\dvrutil.h
//  finite size pool

class CDVRWMSDKToDShowTranslator ;
//  inc\dvrutil.h
//  wmsdk -> dshow attribute translator

class CSBERecordingAttributes ;
//  inc\dvrutil.h
//  in-memory recording attributes for reference recordings; collection

class CSBERecAttribute ;
//  inc\dvrutil.h
//  each attribute in an CSBERecordingAttributes object

class CDVRDShowToWMSDKTranslator ;
//  inc\dvrutil.h
//  dshow -> wmsdk translator

class CDVRWMSDKToDShowMpeg2Translator ;
//  inc\dvrutil.h
//  wmsdk -> dshow attribute translator for mpeg-2

class CDVRDShowToWMSDKMpeg2Translator ;
//  inc\dvrutil.h
//  dshow -> wmsdk translator for mpeg-2

template <class T>
class TCDynamicProdCons ;
//  inc\dvrutil.h
//  producer/consumer pool template; can be fixed size; grows to a max

class CTSDVRSettings ;
//  inc\dvrpolicy.h
//  used throughought to retrieve settings

class CDVRAnalysisFlags ;
//  inc\dvrutil.h
//  used to get/set analysis flags

class CDVRMpeg2VideoAnalysisFlags ;
//  inc\dvrutil.h
//  used to get/set mpeg-2 video analysis flags

class CDVRDShowReader ;
//  dvrfilters\shared
//  reads INNSBuffers

class CDVRDReaderThread ;
//  dvrfilters\shared\dvrdswrite
//  reader thread; hosted by the CDVRReadManager

class CDVRReadManager ;
//  dvrfilters\shared\dvrdsreader.h
//  abstract class; hosted by a sourcing filter

class CDVRRecordingReader ;
//  dvrfilters\shared\dvrdsreader.h
//  derived from CDVRReadManager; plays back recordings

class CDVRBroadcastStreamReader ;
//  dvrfilters\shared\dvrdsreader.h
//  derived from CDVRReadmanager; plays back broadcast stream content

class CDVRReaderProfile ;
//  dvrfilters\shared\dvrdsreader.h
//  wraps an IWMProfile pointer obtained from the IDVRReader; refcounted

template <
    class tKey,     //  <, >, == operators must work
    class tVal      //  = operator must work
    >
class CTSmallMap ;
//  inc\dvrutil.h
//  ok for very small maps

class CDVRDShowSeekingCore ;
//  dvrfilters\shared\dvrdsseek.h
//  core seeking functionality; manages & serializes all seeking operations

class CDVRIMediaSeeking ;
//  dvrfilters\shared\dvrdsseek.h
//  IMediaSeeking implementation

class CDVRPinIMediaSeeking ;
//  dvrfilters\shared\dvrdsseek.h
//  output pin - specific IMediaSeeking implementation

class CDVRFilterIMediaSeeking ;
//  dvrfilters\shared\dvrdsseek.h
//  filter - specific IMediaSeeking implementation

class CSimpleBitfield ;
//  inc\dvrutil.h
//  simple bitfield

class CRatchetBuffer ;
//  inc\dvrutil.h
//  buffer that ratchets its allocation up as needed

class CDVRAttribute ;
//  inc\dvrutil.h
//  attribute data; GUID identifies

class CDVRAttributeList ;
//  inc\dvrutil.h
//  list of CDVRAttribute

class CDVRRecording ;
//  dvrfilters\shared\dvrdsrec.h
//  recording object (IUnknown *); obtained via IDVRStreamSink

class CDVRRecordingAttributes ;
//  dvrfilters\shared\dvrdsrec.h
//  talks to the DVRIO layer; largely a pass-through

class CDVRContentRecording ;
//  dvrfilters\shared\dvrdsrec.h
//  content recording object

class CDVRReferenceRecording ;
//  dvrfilters\shared\dvrdsrec.h
//  reference recording object

class CDVRRecordingAttribEnum ;
//  dvrfilters\shared\dvrdsrec.h
//  enumerates recording attributes

class CSBECompositionRecording ;
//  dvrfiters\shared\dvrdsrec.h
//  composite recording i.e. concatenates recordings into 1

class CDVRThread ;
//  inc\dvrutil.h
//  copy/paste CAMThread but some of the members are now protected vs. private

class CDVRReceiveStatsMem ;
//  inc\dvrperf.h
//  received streams stats shared memory

class CDVRReceiveStatsWriter ;
//  inc\dvrperf.h
//  received streams stats writer object

class CDVRReceiveStatsReader ;
//  inc\dvrperf.h
//  received streams stats reader

class CDVRSendStatsMem ;
//  inc\dvrperf.h
//  send streams stats shared memory

class CDVRSendStatsWriter ;
//  inc\dvrperf.h
//  send streams stats writer object

class CDVRSendStatsReader ;
//  inc\dvrperf.h
//  send streams stats reader

template <class T>
class CTDynArray ;
//  inc\dvrutil.h
//  dynamically-allocated Array; both LIFO & FIFO behavior

template <class T>
class CTDynStack ;
//  inc\dvrutil.h
//  dynamically-allocated LIFO

template <class T>
class CTDynQueue ;
//  inc\dvrutil.h
//  dynamically-allocated FIFO

class CDVRClock ;
//  dvrfilters\shared\dvrclock.h
//  IReferenceClock implementation

class CDVRPolicy ;
//  inc\dvrpolicy.h
//  app-controllable/settable policies; accessed from everywhere

class CDVRReadController ;
//  dvrfilters\shared\dvrdsread.h
//  read controller; can be media-specific; controls 1x & trick mode playback

class CDVR_Forward_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  forward read controller; abstract

class CDVR_F_FullFrame_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  full-frame forward read controller

class CMediaSampleList ;
//  dvrfilters\shared\dvrdsread.h
//  list - either a queue or a stack

class CMediaSampleLIFO ;
//  dvrfilters\shared\dvrdsread.h
//  media sample stack

class CMediaSampleFIFO ;
//  dvrfilters\shared\dvrdsread.h
//  media sample queue

class CINSSBufferLIFO ;
//  dvrfilters\shared\dvrdsread.h
//  INSSBuffer stack

class CDVRReverseSender ;
//  dvrfilters\shared\dvrdsread.h
//  per-stream reverse mode sender

class CDVRMpeg2ReverseSender ;
//  dvrfilters\shared\dvrdsread.h
//  mpeg-2 specific per-stream sender; deals with GOPs, etc...

class CDVRMpeg2_GOP_ReverseSender ;
//  dvrfilters\shared\dvrdsread.h
//  GOP reverse sender

class CDVRMpeg2_IFrame_ReverseSender ;
//  dvrfilters\shared\dvrdsread.h
//  I-frames only reverse sender

class CDVR_Reverse_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  reverse read controller; abstract

class CDVR_R_KeyFrame_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  reverse read controller; keyframes only

class CDVRIMediaSample ;
//  inc\dvrutil.h
//  wraps an INSSBuffer3;

class CDVRIMediaSamplePool ;
//  inc\dvrutil.h
//  source of CDVRIMediaSample objects

class CDVDRateChange ;
//  dvrfilters\shared\dvrpins.h
//  DVD rate change interface

class CRunTimeline ;
//  dvrfilters\shared\dvrdsseeek.h
//  run time; based on wall time; collapses pauses

class CVarSpeedTimeline ;
//  dvrfilters\shared\dvrdsseeek.h
//  like a run timeline, but incorporates rates

class CSeekingTimeline ;
//  dvrfilters\shared\dvrdsseeek.h
//  incorporates stream time with run time; holds a ref clock

template <class T>
class CTRateSegment ;
//  inc\dvrutil.h
//  rate segment object (used for rate change)

template <class T>
class CTTimestampRate ;
//  inc\dvrutil.h
//  maintains list of CRateSegment objects

class DVRAttributeHelpers ;
//  inc\dvrutil.h
//  DVR attribute helpers (INSSBuffer3 & IMediaSample)

class CDVREventSink ;
//  inc\dvrpolicy.h
//  event sink object

template <class T>
class CTIGetTime ;
//  dvrfilters\shared\dvrclock.h
//  abstract interface used to sample the host system clock

template <
    class HostClock,
    class MasterClock
    >
class CTCClockSlave ;
//  dvrfilters\shared\dvrclock.h
//  clock slaving object; computes a slaving ratio of HostClock to MasterClock

class CScalingValHistory ;
//  dvrfilters\shared\dvrclock.h
//  moving average of a scaling value over a *time* window

template <
    class HostClock,
    class MasterClock
    >
class CTClockSlaveSamplingWindow ;
//  dvrfilters\shared\dvrclock.h
//  slope (scale) of HostClock delta vs. MasterClock delta

class CW32SID ;
//  inc\dvrw32.h
//  holds an array of SIDs; refcounted

template <class T>
class CTSmoothingFilter ;
//  inc\dvrw32.h
//  given target value, smooths the transition from "current" (default 0) to
//    the target per its configuration

#endif  //  __tsdvr__dvrfor_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrperf.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        dvrperf.h

    Abstract:

        This module contains all declarations related to statistical
        information.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

    Notes:

--*/

#ifndef __tsdvr_dvrperf_h
#define __tsdvr_dvrperf_h

//  ============================================================================
//  initializes DMDPerf-related instrumentation

//  GUID is included after initguid.h in tsdvr.cpp
// {3512CF51-0C7D-4e73-AD15-70C6DA52090D}
DEFINE_GUID(__GUID_TIMESHIFT_PERF,
0x3512cf51, 0xc7d, 0x4e73, 0xad, 0x15, 0x70, 0xc6, 0xda, 0x52, 0x9, 0xd);

#define __DXMPERF_TIMESHIFT       0x00000004

void
DVRPerfInit (
    ) ;

void
DVRPerfUninit (
    ) ;

typedef struct __PERFINFO_DSHOW_TS_SEND {
    ULONGLONG   cycleCounter;
    ULONGLONG   dshowClock;
    ULONGLONG   buffering ;
    ULONGLONG   sampleTime;
} __PERFINFO_DSHOW_TS_SEND, *__PPERFINFO_DSHOW_TS_SEND;

typedef struct __PERFINFO_WMI_TSREND {
    EVENT_TRACE_HEADER      header;
    __PERFINFO_DSHOW_TS_SEND  data;
} __PERFINFO_WMI_TSREND, *__PPERFINFO_WMI_TSREND;

__inline
void
DVRPerfSampleOut (
    IN  IMediaSample *      pIMediaSample,
    IN  REFERENCE_TIME *    prtNow,
    IN  REFERENCE_TIME *    prtBuffering
    )
{
    if (PerflogEnableFlags & __DXMPERF_TIMESHIFT) {

        __PERFINFO_WMI_TSREND   perfData ;
        REFERENCE_TIME          rtStart ;
        REFERENCE_TIME          rtStop ;
        HRESULT                 hr ;

        hr = pIMediaSample -> GetTime (& rtStart, & rtStop) ;

        if (SUCCEEDED (hr)) {

            ZeroMemory (& perfData, sizeof perfData) ;

            perfData.header.Size        = sizeof perfData ;
            perfData.header.Flags       = WNODE_FLAG_TRACED_GUID ;
            perfData.header.Guid        = __GUID_TIMESHIFT_PERF ;

            perfData.data.cycleCounter  = _RDTSC() ;
            perfData.data.dshowClock    = (* prtNow) ;
            perfData.data.buffering     = (* prtBuffering) ;
            perfData.data.sampleTime    = rtStart ;

            PerflogTraceEvent ((PEVENT_TRACE_HEADER) & perfData) ;
        }
    }
}

//  ============================================================================
//  ============================================================================
//      mpeg-2 rame analysis stats

//  analysis framework reports to this
#define DVRANALYSIS_MPEG2_VIDEO_ANALYZED_SHAREDMEM_NAME TEXT ("TSDVR_ANALYSIS_MPEG2_VIDEO_ANALYZED_STATS")

//  passive - observed; not necessarily tagged
struct MPEG2_VIDEO_STATS_OBSERVED {
    ULONGLONG   ullSequenceHeaderCount ;    //  sequence_headers
    ULONGLONG   ullGOPHeaderCount ;         //  GOP-header
    ULONGLONG   ullIFrameCount ;            //  I-frame count
    ULONGLONG   ullPFrameCount ;            //  P-frame count
    ULONGLONG   ullBFrameCount ;            //  B-frame count
} ;

//  counter of analysis-tagged
struct MPEG2_VIDEO_STATS_FLAGGED {
    ULONGLONG   ullGOPBoundaries ;          //  GOP boundary (I-frame or GOP header)
    ULONGLONG   ullPFrameCount ;            //  P-frame count
    ULONGLONG   ullBFrameCount ;            //  B-frame count
} ;

struct DVRANALYSIS_MPEG2_VIDEO_STATS_ANALYZED {
    MPEG2_VIDEO_STATS_OBSERVED  Observed ;
    MPEG2_VIDEO_STATS_FLAGGED   Flagged ;
    double                      dFrameRate ;
} ;

/*++
    writer

    used purely internally
--*/
class CMpeg2VideoStreamStatsMem
{
    CWin32SharedMem *   m_pSharedMem ;

    protected :

        DVRANALYSIS_MPEG2_VIDEO_STATS_ANALYZED * m_pMpeg2VideoStreamStats ;

        CMpeg2VideoStreamStatsMem (
            ) : m_pMpeg2VideoStreamStats    (NULL),
                m_pSharedMem                (NULL) {}

        virtual
        ~CMpeg2VideoStreamStatsMem (
            )
        {
            delete m_pSharedMem ;
        }

        HRESULT
        Initialize (
            IN  BOOL    fEnable,
            IN  TCHAR * szSharedMemName = DVRANALYSIS_MPEG2_VIDEO_ANALYZED_SHAREDMEM_NAME
            )
        //  not serialized !!
        {
            HRESULT hr ;

            if (fEnable &&
                !m_pSharedMem) {

                //  turn it on and we're not yet on

                m_pSharedMem = new CWin32SharedMem (
                                        szSharedMemName,
                                        sizeof DVRANALYSIS_MPEG2_VIDEO_STATS_ANALYZED,
                                        & hr
                                        ) ;

                if (m_pSharedMem &&
                    SUCCEEDED (hr)) {

                    m_pMpeg2VideoStreamStats = reinterpret_cast <DVRANALYSIS_MPEG2_VIDEO_STATS_ANALYZED *> (m_pSharedMem -> GetSharedMem ()) ;
                }
                else {
                    hr = (m_pSharedMem ? hr : E_OUTOFMEMORY) ;
                    DELETE_RESET (m_pSharedMem) ;
                }
            }
            else if (!fEnable) {
                //  turn stats off

                DELETE_RESET (m_pSharedMem) ;
                m_pMpeg2VideoStreamStats = NULL ;

                hr = S_OK ;
            }

            return hr ;
        }

        HRESULT
        Clear (
            )
        //  not serialized !!
        {
            if (m_pSharedMem) {

                //  frame this in a __try/__except because it's possible for
                //   another process to create the shared mem, but make it
                //   smaller; we'll AV when we exceed the original (smaller)
                //   size

                __try {

                    ZeroMemory (
                        m_pSharedMem -> GetSharedMem (),
                        m_pSharedMem -> GetSharedMemSize ()
                        ) ;

                }
                __except (GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    //  return an error code
                    return HRESULT_FROM_WIN32 (STATUS_ACCESS_VIOLATION) ;
                }
            }

            return S_OK ;
        }
} ;

class CMpeg2VideoStreamStatsWriter :
    private CMpeg2VideoStreamStatsMem
{
    public :

        CMpeg2VideoStreamStatsWriter (
            ) {}

        HRESULT
        Initialize (
            IN  BOOL    f
            )
        {
            HRESULT hr ;

            hr = CMpeg2VideoStreamStatsMem::Initialize (f) ;
            if (SUCCEEDED (hr)) {
                hr = Clear () ;
                if (FAILED (hr)) {
                    Initialize (FALSE) ;
                }
            }

            return hr ;
        }

        void
        FrameRate (
            IN  BYTE    bFrameRate        //  h.262, table 6-4
            )
        {
            if (!m_pMpeg2VideoStreamStats) {
                return ;
            }

            switch (bFrameRate) {
                case DVR_ANALYSIS_MP2_FRAME_RATE_NOT_PRESENT :
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_23_976 :
                     m_pMpeg2VideoStreamStats -> dFrameRate = 23.976 ;
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_24 :
                    m_pMpeg2VideoStreamStats -> dFrameRate = 24 ;
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_25 :
                    m_pMpeg2VideoStreamStats -> dFrameRate = 25 ;
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_29_97 :
                    m_pMpeg2VideoStreamStats -> dFrameRate = 29.97 ;
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_30 :
                    m_pMpeg2VideoStreamStats -> dFrameRate = 30 ;
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_50 :
                    m_pMpeg2VideoStreamStats -> dFrameRate = 50 ;
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_59_94 :
                    m_pMpeg2VideoStreamStats -> dFrameRate = 59.94 ;
                    break ;

                case DVR_ANALYSIS_MP2_FRAME_RATE_60 :
                    m_pMpeg2VideoStreamStats -> dFrameRate = 60 ;
                    break ;
            } ;
        }

        __inline void GOPHeader_Observed ()         { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Observed.ullGOPHeaderCount++ ; }}
        __inline void I_Frame_Observed ()           { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Observed.ullIFrameCount++ ; }}
        __inline void B_Frame_Observed ()           { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Observed.ullBFrameCount++ ; }}
        __inline void P_Frame_Observed ()           { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Observed.ullPFrameCount++ ; }}
        __inline void SequenceHeader_Observed ()    { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Observed.ullSequenceHeaderCount++ ; }}

        __inline void GOPBoundary_Flagged ()    { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Flagged.ullGOPBoundaries++ ; }}
        __inline void B_Frame_Flagged ()        { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Flagged.ullBFrameCount++ ; }}
        __inline void P_Frame_Flagged ()        { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> Flagged.ullPFrameCount++ ; }}
} ;

//  COM-based host for the stream specific COM interfaces
class CMpeg2VideoStreamStatsReader :
    public  CUnknown,
    public  IDVRMpeg2VideoStreamStats,
    private CMpeg2VideoStreamStatsMem
{
    CDVRPolicy *    m_pPolicy ;

    public :

        CMpeg2VideoStreamStatsReader (
            IN  IUnknown *  pIUnknown,
            OUT HRESULT *   phr
            ) ;

        ~CMpeg2VideoStreamStatsReader (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  class factory
        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        //  stats interface
        DECLARE_IDVRMPEG2VIDEOSTREAMSTATS() ;
} ;

//  ============================================================================
//  ============================================================================

#define TSDVR_RECEIVE_STATS_SHAREDMEM_NAME      TEXT ("TSDVR_RECEIVE_STATS")

//  per pin
struct TSDVR_RECEIVE_STREAM_STATS {
    ULONGLONG       ullMediaSamplesIn ;
    ULONGLONG       ullTotalBytes ;
    ULONGLONG       ullDiscontinuities ;
    ULONGLONG       ullSyncPoints ;
    REFERENCE_TIME  rtLast ;
    ULONGLONG       ullWriteFailures ;
} ;

struct TSDVR_RECEIVE_ANALYSIS_MPEG2_VIDEO_STATS {
    //  boundaries
    ULONGLONG       ullTagged_GOPBoundaries ;       //  GOP headers & I-frames
    ULONGLONG       ullTagged_PFrames ;             //  P-frames
    ULONGLONG       ullTagged_BFrames ;             //  B-frames

    //  total bytes
    ULONGLONG       ullTotal_I_FrameBytes ;         //  GOP header + I-Frame bytes
    ULONGLONG       ullTotal_P_FrameBytes ;         //  P-frames
    ULONGLONG       ullTotal_B_FrameBytes ;         //  B-frames

    double          dFrameRate ;                    //  latset frame rate
} ;

struct TSDVR_RECEIVE_ANALYSIS_STATS {
    TSDVR_RECEIVE_ANALYSIS_MPEG2_VIDEO_STATS    Mpeg2VideoStats ;
} ;

#define TSDVR_RECEIVE_MAX_STREAM_STATS      5

struct TSDVR_RECEIVE_STATS {
    TSDVR_RECEIVE_STREAM_STATS      StreamStats [TSDVR_RECEIVE_MAX_STREAM_STATS] ;
    TSDVR_RECEIVE_ANALYSIS_STATS    AnalysisStats ;
} ;

class CDVRReceiveStatsMem
{
    CWin32SharedMem *   m_pSharedMem ;

    protected :

        TSDVR_RECEIVE_STATS *   m_pDVRReceiveStats ;

        CDVRReceiveStatsMem (
            ) : m_pDVRReceiveStats   (NULL),
                m_pSharedMem            (NULL) {}

        virtual
        ~CDVRReceiveStatsMem (
            )
        {
            delete m_pSharedMem ;
        }

        HRESULT
        Initialize (
            IN  BOOL    fEnable,
            IN  TCHAR * szSharedMemName = TSDVR_RECEIVE_STATS_SHAREDMEM_NAME
            )
        //  not serialized !!
        {
            HRESULT hr ;

            //  PREFIX
            hr = S_OK ;

            if (fEnable &&
                !m_pSharedMem) {

                //  turn it on and we're not yet on

                m_pSharedMem = new CWin32SharedMem (
                                        szSharedMemName,
                                        sizeof TSDVR_RECEIVE_STATS,
                                        & hr
                                        ) ;

                if (m_pSharedMem &&
                    SUCCEEDED (hr)) {

                    m_pDVRReceiveStats = reinterpret_cast <TSDVR_RECEIVE_STATS *> (m_pSharedMem -> GetSharedMem ()) ;
                }
                else {
                    hr = (m_pSharedMem ? hr : E_OUTOFMEMORY) ;
                    DELETE_RESET (m_pSharedMem) ;
                }
            }
            else if (!fEnable) {
                //  turn stats off

                DELETE_RESET (m_pSharedMem) ;
                m_pDVRReceiveStats = NULL ;

                hr = S_OK ;
            }

            return hr ;
        }

        HRESULT
        Clear (
            )
        //  not serialized !!
        {
            if (m_pSharedMem) {

                //  frame this in a __try/__except because it's possible for
                //   another process to create the shared mem, but make it
                //   smaller; we'll AV when we exceed the original (smaller)
                //   size

                __try {

                    ZeroMemory (
                        m_pSharedMem -> GetSharedMem (),
                        m_pSharedMem -> GetSharedMemSize ()
                        ) ;

                }
                __except (GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    //  return an error code
                    return HRESULT_FROM_WIN32 (STATUS_ACCESS_VIOLATION) ;
                }
            }

            return S_OK ;
        }
} ;

//  mpeg-2 video stream stats
class CDVRAnalysisMeg2VideoStream
{
    enum MPEG2_FRAME_TYPE {
        I_FRAME,
        P_FRAME,
        B_FRAME,
        NO_FRAME_BOUNDARY
    } ;

    MPEG2_FRAME_TYPE    m_Mpeg2FrameState ;

    static
    MPEG2_FRAME_TYPE
    Mpeg2FrameAnalysisData_ (
        IN  DWORD   dwMpeg2FrameAnalysis
        )
    {
        MPEG2_FRAME_TYPE    Mpeg2FrameType ;

        dwMpeg2FrameAnalysis &= 0x00000003 ;

        switch (dwMpeg2FrameAnalysis) {
            //  I-frame; value same a GOP boundary
            case DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_I_FRAME :
                Mpeg2FrameType = I_FRAME ;
                break ;

            //  p-frame
            case DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_P_FRAME :
                Mpeg2FrameType = P_FRAME ;
                break ;

            //  b-frame
            case DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_B_FRAME :
                Mpeg2FrameType = B_FRAME ;
                break ;

            default :
                Mpeg2FrameType = NO_FRAME_BOUNDARY ;
        } ;

        return Mpeg2FrameType ;
    }

    void
    UpdateFrameStats_ (
        IN  IMediaSample *                              pIMS,
        IN  TSDVR_RECEIVE_ANALYSIS_MPEG2_VIDEO_STATS *  pDVRMpeg2Analyis,
        IN  MPEG2_FRAME_TYPE                            Mpeg2FrameType,
        IN  BOOL                                        fFrameBoundary
        )
    {
        //  update the bytes for the frame boundary we're looking at
        switch (Mpeg2FrameType) {
            case I_FRAME :
                if (fFrameBoundary) {
                    pDVRMpeg2Analyis -> ullTagged_GOPBoundaries++ ;
                }
                pDVRMpeg2Analyis -> ullTotal_I_FrameBytes += pIMS -> GetActualDataLength () ;
                break ;

            case P_FRAME :
                if (fFrameBoundary) {
                    pDVRMpeg2Analyis -> ullTagged_PFrames++ ;
                }
                pDVRMpeg2Analyis -> ullTotal_P_FrameBytes += pIMS -> GetActualDataLength () ;
                break ;

            case B_FRAME :
                if (fFrameBoundary) {
                    pDVRMpeg2Analyis -> ullTagged_BFrames++ ;
                }
                pDVRMpeg2Analyis -> ullTotal_B_FrameBytes += pIMS -> GetActualDataLength () ;
                break ;
        } ;
    }

    void
    UpdateFrameRate_ (
        IN  DWORD                                       dwFrameRate,        //  h.262, table 6-4
        IN  TSDVR_RECEIVE_ANALYSIS_MPEG2_VIDEO_STATS *  pDVRMpeg2Analyis
        )
    {
        switch (dwFrameRate) {
            case DVR_ANALYSIS_MP2_FRAME_RATE_NOT_PRESENT :
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_23_976 :
                pDVRMpeg2Analyis -> dFrameRate = 23.976 ;
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_24 :
                pDVRMpeg2Analyis -> dFrameRate = 24 ;
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_25 :
                pDVRMpeg2Analyis -> dFrameRate = 25 ;
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_29_97 :
                pDVRMpeg2Analyis -> dFrameRate = 29.97 ;
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_30 :
                pDVRMpeg2Analyis -> dFrameRate = 30 ;
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_50 :
                pDVRMpeg2Analyis -> dFrameRate = 50 ;
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_59_94 :
                pDVRMpeg2Analyis -> dFrameRate = 59.94 ;
                break ;

            case DVR_ANALYSIS_MP2_FRAME_RATE_60 :
                pDVRMpeg2Analyis -> dFrameRate = 60 ;
                break ;
        } ;
    }

    public :

        CDVRAnalysisMeg2VideoStream (
            ) : m_Mpeg2FrameState (NO_FRAME_BOUNDARY) {}

        void
        DVRAnalysis_Mpeg2_NoAnalysis (
            IN  IMediaSample *                              pIMS,
            IN  TSDVR_RECEIVE_ANALYSIS_MPEG2_VIDEO_STATS *  pDVRMpeg2Analyis
            )
        {
            //  update with last frame we detected i.e. we're still in that frame
            UpdateFrameStats_ (pIMS, pDVRMpeg2Analyis, m_Mpeg2FrameState, FALSE) ;
        }

        void
        DVRAnalysis_Mpeg2_WithAnalysis (
            IN  IMediaSample *                              pIMS,
            IN  TSDVR_RECEIVE_ANALYSIS_MPEG2_VIDEO_STATS *  pDVRMpeg2Analyis,
            IN  DWORD                                       dwFrameAttrib
            )
        {
            MPEG2_FRAME_TYPE    Mpeg2FrameType ;

            //  determine the type of frame we're in
            Mpeg2FrameType = Mpeg2FrameAnalysisData_ (dwFrameAttrib) ;

            //  don't update member state on a non-frame boundary
            if (Mpeg2FrameType != NO_FRAME_BOUNDARY) {
                m_Mpeg2FrameState = Mpeg2FrameType ;
            }

            //  update stats with the new type of frame
            UpdateFrameStats_ (pIMS, pDVRMpeg2Analyis, m_Mpeg2FrameState, (Mpeg2FrameType != NO_FRAME_BOUNDARY ? TRUE : FALSE)) ;

            //  update frame-rate stats
            UpdateFrameRate_ (DVR_ANALYSIS_MP2_GET_FRAME_RATE (dwFrameAttrib), pDVRMpeg2Analyis) ;
        }
} ;

class CDVRReceiveStatsWriter :
    private CDVRReceiveStatsMem
{
    CDVRAnalysisMeg2VideoStream     m_Mpeg2VideoStreamAnalysis ;

    public :

        CDVRReceiveStatsWriter (
            ) {}

        HRESULT
        Initialize (
            IN  BOOL    f
            )
        {
            HRESULT hr ;

            hr = CDVRReceiveStatsMem::Initialize (f) ;
            if (SUCCEEDED (hr)) {
                hr = Clear () ;
                if (FAILED (hr)) {
                    Initialize (FALSE) ;
                }
            }

            return hr ;
        }

        __inline void SampleIn (int iFlow, IMediaSample * pIMS)
        {
            REFERENCE_TIME  rtStart ;
            REFERENCE_TIME  rtStop ;

            if (m_pDVRReceiveStats &&
                iFlow < TSDVR_RECEIVE_MAX_STREAM_STATS) {

                m_pDVRReceiveStats -> StreamStats [iFlow].ullMediaSamplesIn++ ;

                m_pDVRReceiveStats -> StreamStats [iFlow].ullTotalBytes         += pIMS -> GetActualDataLength () ;
                m_pDVRReceiveStats -> StreamStats [iFlow].ullDiscontinuities    += (pIMS -> IsDiscontinuity () == S_OK ? 1 : 0) ;
                m_pDVRReceiveStats -> StreamStats [iFlow].ullSyncPoints         += (pIMS -> IsSyncPoint () == S_OK ? 1 : 0) ;

                if (pIMS -> GetTime (& rtStart, & rtStop) != VFW_E_SAMPLE_TIME_NOT_SET) {
                    m_pDVRReceiveStats -> StreamStats [iFlow].rtLast = rtStart ;
                }
            }
        }

        __inline void SampleWritten (int iFlow, HRESULT hrWriteCall)
        {
            if (m_pDVRReceiveStats &&
                iFlow < TSDVR_RECEIVE_MAX_STREAM_STATS) {

                m_pDVRReceiveStats -> StreamStats [iFlow].ullWriteFailures      += (FAILED (hrWriteCall) ? 1 : 0) ;
            }
        }

        //  --------------------------------------------------------------------
        //  mpeg-2 specific

        __inline void Mpeg2SampleWithFrameAnalysis (IN IMediaSample * pIMS, IN DWORD dwFrameAttrib)
        {
            if (m_pDVRReceiveStats) {
                m_Mpeg2VideoStreamAnalysis.DVRAnalysis_Mpeg2_WithAnalysis (pIMS, & m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats, dwFrameAttrib) ;
            }
        }

        __inline void Mpeg2SampleWithNoFrameAnalysis (IN IMediaSample * pIMS)
        {
            if (m_pDVRReceiveStats) {
                m_Mpeg2VideoStreamAnalysis.DVRAnalysis_Mpeg2_NoAnalysis (pIMS, & m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats) ;
            }
        }
} ;

class CDVRReceiveStatsReader :
    public  CUnknown,
    public  IDVRReceiverStats,
    public  IDVRAnalysisMpeg2RecvStats,
    private CDVRReceiveStatsMem
{
    CDVRPolicy *    m_pPolicy ;

    public :

        CDVRReceiveStatsReader (
            IN  IUnknown *  pIUnknown,
            OUT HRESULT *   phr
            ) ;

        ~CDVRReceiveStatsReader (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  class factory
        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        //  stats interfaces
        DECLARE_IDVRRECEIVERSTATS() ;
        DECLARE_IDVRANALYSISMPEG2RECVSTATS () ;
} ;

//  ============================================================================
//  ============================================================================

#define TSDVR_SEND_STATS_SHAREDMEM_NAME      TEXT ("TSDVR_SEND_STATS")

//  per pin
struct TSDVR_SEND_STREAM_STATS {
    ULONGLONG       ullMediaSamplesIn ;
    ULONGLONG       ullTotalBytes ;
    ULONGLONG       ullDiscontinuities ;
    ULONGLONG       ullSyncPoints ;
    REFERENCE_TIME  rtLastNormalized ;
    REFERENCE_TIME  rtRefClockOnLastPTS ;
    REFERENCE_TIME  rtBufferingLastPTS ;
    ULONGLONG       ullUnderflows ;         //  # of stale PTS (wrt ref time)
    DWORD           dwReserved1 ;
    DWORD           dwReserved2 ;
} ;

struct TSDVR_CLOCK_SLAVING_STATS {
    ULONGLONG       ullInBoundsBrackets ;
    ULONGLONG       ullOutOfBoundsBrackets ;
    ULONGLONG       ullResets ;
    BOOL            fSlaving ;
    BOOL            fSettling ;
    ULONGLONG       ullReserved1 ;
    ULONGLONG       ullReserved2 ;
    double          dLastBracketScale ;
    double          dInUseScale ;
} ;

struct TSDVR_CLOCK_IREFCLOCK_STATS {
    ULONGLONG       ullQueuedAdvises ;
    ULONGLONG       ullSignaledAdvises ;
    ULONGLONG       ullStaleAdvises ;
} ;

struct TSDVR_CLOCK_STATS {
    TSDVR_CLOCK_SLAVING_STATS   Slaving ;
    TSDVR_CLOCK_IREFCLOCK_STATS IReferenceClock ;
} ;

#define TSDVR_SEND_MAX_STREAM_STATS      5

struct TSDVR_SEND_STATS {
    REFERENCE_TIME          rtNormalizer ;          //  this is the earliest stream's PTS
    REFERENCE_TIME          rtPTSBase ;             //  all streams shared this offset
    DWORD                   dwBufferPoolAvailable ; //  available buffers in the pool
    DWORD                   dwBufferPoolCur ;       //  current buffer pool size
    DWORD                   dwBufferPoolMax ;       //  max buffer pool
    REFERENCE_TIME          rtTotalPausedTime ;     //  total paused time; per run session
    ULONGLONG               ullReadFailures ;
    ULONGLONG               ullUnderflows ;         //  # of stale PTS (wrt ref time)
    TSDVR_SEND_STREAM_STATS StreamStats [TSDVR_SEND_MAX_STREAM_STATS] ;
    TSDVR_CLOCK_STATS       Clock ;
} ;

class CDVRSendStatsMem
{
    CWin32SharedMem *   m_pSharedMem ;

    protected :

        TSDVR_SEND_STATS *  m_pDVRSenderStats ;

        CDVRSendStatsMem (
            ) : m_pDVRSenderStats   (NULL),
                m_pSharedMem        (NULL) {}

        virtual
        ~CDVRSendStatsMem (
            )
        {
            delete m_pSharedMem ;
        }

        HRESULT
        Initialize (
            IN  BOOL    fEnable,
            IN  TCHAR * szSharedMemName = TSDVR_SEND_STATS_SHAREDMEM_NAME
            )
        //  not serialized !!
        {
            HRESULT hr ;

            //  PREFIX
            hr = S_OK ;

            if (fEnable &&
                !m_pSharedMem) {

                //  turn it on and we're not yet on

                m_pSharedMem = new CWin32SharedMem (
                                        szSharedMemName,
                                        sizeof TSDVR_SEND_STATS,
                                        & hr
                                        ) ;

                if (m_pSharedMem &&
                    SUCCEEDED (hr)) {

                    m_pDVRSenderStats = reinterpret_cast <TSDVR_SEND_STATS *> (m_pSharedMem -> GetSharedMem ()) ;
                }
                else {
                    hr = (m_pSharedMem ? hr : E_OUTOFMEMORY) ;
                    DELETE_RESET (m_pSharedMem) ;
                }
            }
            else if (!fEnable) {
                //  turn stats off

                DELETE_RESET (m_pSharedMem) ;
                m_pDVRSenderStats = NULL ;

                hr = S_OK ;
            }

            return hr ;
        }

        HRESULT
        Clear (
            )
        //  not serialized !!
        {
            if (m_pSharedMem) {

                //  frame this in a __try/__except because it's possible for
                //   another process to create the shared mem, but make it
                //   smaller; we'll AV when we exceed the original (smaller)
                //   size

                __try {

                    ZeroMemory (
                        m_pSharedMem -> GetSharedMem (),
                        m_pSharedMem -> GetSharedMemSize ()
                        ) ;

                }
                __except (GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    //  return an error code
                    return HRESULT_FROM_WIN32 (STATUS_ACCESS_VIOLATION) ;
                }
            }

            return S_OK ;
        }
} ;

class CDVRSendStatsWriter :
    private CDVRSendStatsMem
{
    public :

        CDVRSendStatsWriter (
            ) {}

        HRESULT
        Initialize (
            IN  BOOL    f
            )
        {
            HRESULT hr ;

            hr = CDVRSendStatsMem::Initialize (f) ;
            if (SUCCEEDED (hr)) {
                hr = Clear () ;
                if (FAILED (hr)) {
                    Initialize (FALSE) ;
                }
            }

            return hr ;
        }

        __inline void SetPausedTime (REFERENCE_TIME rtPausedTime)
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> rtTotalPausedTime  = rtPausedTime ;
            }
        }

        __inline void SetNormalizer (REFERENCE_TIME rtNormalizer, REFERENCE_TIME rtPTSBase)
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> rtNormalizer   = rtNormalizer ;
                m_pDVRSenderStats -> rtPTSBase      = rtPTSBase ;
            }
        }

        __inline void Underflow (int iFlow)
        {
            if (m_pDVRSenderStats &&
                iFlow < TSDVR_SEND_MAX_STREAM_STATS) {

                m_pDVRSenderStats -> StreamStats [iFlow].ullUnderflows++ ;  //  per stream
                m_pDVRSenderStats -> ullUnderflows++ ;                      //  global
            }
        }

        __inline void Buffering (int iFlow, REFERENCE_TIME * prtBuffering, DWORD dwBufferPoolAvailable, DWORD dwBufferPoolCur, DWORD dwBufferPoolMax)
        {
            if (m_pDVRSenderStats) {
                if (iFlow < TSDVR_SEND_MAX_STREAM_STATS) {
                    m_pDVRSenderStats -> StreamStats [iFlow].rtBufferingLastPTS = (* prtBuffering) ;
                }

                m_pDVRSenderStats -> dwBufferPoolAvailable  = dwBufferPoolAvailable ;
                m_pDVRSenderStats -> dwBufferPoolCur        = dwBufferPoolCur ;
                m_pDVRSenderStats -> dwBufferPoolMax        = dwBufferPoolMax ;
            }
        }

        __inline void SampleOut (HRESULT hr, int iFlow, IMediaSample * pIMS, REFERENCE_TIME * prtNow)
        {
            REFERENCE_TIME  rtStart ;
            REFERENCE_TIME  rtStop ;
            REFERENCE_TIME  rtBuffering ;

            if (m_pDVRSenderStats &&
                iFlow < TSDVR_SEND_MAX_STREAM_STATS &&
                SUCCEEDED (hr)) {

                m_pDVRSenderStats -> StreamStats [iFlow].ullMediaSamplesIn++ ;

                m_pDVRSenderStats -> StreamStats [iFlow].ullTotalBytes      += pIMS -> GetActualDataLength () ;
                m_pDVRSenderStats -> StreamStats [iFlow].ullDiscontinuities += (pIMS -> IsDiscontinuity () == S_OK ? 1 : 0) ;
                m_pDVRSenderStats -> StreamStats [iFlow].ullSyncPoints      += (pIMS -> IsSyncPoint () == S_OK ? 1 : 0) ;

                if (pIMS -> GetTime (& rtStart, & rtStop) != VFW_E_SAMPLE_TIME_NOT_SET) {
                    m_pDVRSenderStats -> StreamStats [iFlow].rtLastNormalized       = rtStart ;
                    m_pDVRSenderStats -> StreamStats [iFlow].rtRefClockOnLastPTS    = (* prtNow) ;
                }
            }

            rtBuffering = 0 ;

            ::DVRPerfSampleOut (
                pIMS,
                prtNow,
                & rtBuffering
                ) ;
        }

        __inline void INSSBufferRead (HRESULT hrReadCall)
        {
            if (m_pDVRSenderStats &&
                FAILED (hrReadCall)) {
                m_pDVRSenderStats -> ullReadFailures++ ;
            }
        }

        __inline void ClockStaleAdvise ()
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> Clock.IReferenceClock.ullStaleAdvises++ ;
            }
        }

        __inline void ClockQueuedAdvise ()
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> Clock.IReferenceClock.ullQueuedAdvises++ ;
            }
        }

        __inline void ClockSignaledAdvise ()
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> Clock.IReferenceClock.ullSignaledAdvises++ ;
            }
        }

        __inline void ClockReset (BOOL fSlaving)
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> Clock.Slaving.ullResets++ ;

                if (!fSlaving) {
                    m_pDVRSenderStats -> Clock.Slaving.fSlaving = FALSE ;
                    m_pDVRSenderStats -> Clock.Slaving.fSettling = FALSE ;
                }
                else {
                    m_pDVRSenderStats -> Clock.Slaving.fSlaving = FALSE ;
                    m_pDVRSenderStats -> Clock.Slaving.fSettling = TRUE ;
                }
            }
        }

        __inline void ClockSlaving ()
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> Clock.Slaving.fSlaving = TRUE ;
                m_pDVRSenderStats -> Clock.Slaving.fSettling = FALSE ;
            }
        }

        __inline void ClockSettling ()
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> Clock.Slaving.fSlaving = FALSE ;
                m_pDVRSenderStats -> Clock.Slaving.fSettling = TRUE ;
            }
        }

        __inline void BracketCompleted (IN double dBracketScale, IN BOOL fInBoundsBracket, IN double dInUseScale)
        {
            if (m_pDVRSenderStats) {

                if (fInBoundsBracket) {
                    m_pDVRSenderStats -> Clock.Slaving.ullInBoundsBrackets++ ;
                }
                else {
                    m_pDVRSenderStats -> Clock.Slaving.ullOutOfBoundsBrackets++ ;
                }

                m_pDVRSenderStats -> Clock.Slaving.dLastBracketScale    = dBracketScale ;
                m_pDVRSenderStats -> Clock.Slaving.dInUseScale          = dInUseScale ;
            }
        }
} ;

class CDVRSendStatsReader :
    public  CUnknown,
    public  IDVRSenderStats,
    private CDVRSendStatsMem
{
    CDVRPolicy *    m_pPolicy ;

    public :

        CDVRSendStatsReader (
            IN  IUnknown *  pIUnknown,
            OUT HRESULT *   phr
            ) ;

        ~CDVRSendStatsReader (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  class factory
        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        //  stats interfaces
        DECLARE_IDVRSENDERSTATS() ;
} ;

//  ============================================================================
//  ============================================================================

#define TSDVR_PVRIO_STATS_SHAREDMEM_NAME        TEXT ("TSDVR_PVRIO_STATS")

struct PVR_ASYNCREADER_WAIT_COUNTER {
    ULONGLONG   cQueued ;                   //  waits queued
    ULONGLONG   cSignaledSuccess ;          //  signaled success
    ULONGLONG   cSignaledFailure ;          //  signaled failures
    ULONGLONG   cBufferDequeued ;           //  buffers deqeueued
} ;

struct PVR_ASYNCREADER_COUNTER {
    ULONGLONG                       ullLastBufferReadout ;      //  last ::ReadBytes() stream offset
    ULONGLONG                       cReadoutWriteBufferHit ;    //  ::ReadBytes() write buffers hit
    ULONGLONG                       cReadoutCacheHit ;          //  ::ReadBytes() read cache hit
    ULONGLONG                       cReadoutCacheMiss ;         //  ::ReadBytes () read cache miss
    ULONGLONG                       cReadAheadReadCacheHit ;    //  read ahead cache hit
    ULONGLONG                       cReadAheadWriteBufferHit ;  //  read ahead write buffer hit
    ULONGLONG                       cReadAhead ;                //  read ahead counter (per read)
    ULONGLONG                       cPartiallyFilledBuffer ;    //  buffer in cache with < maxlength
    ULONGLONG                       cPartialReadAgain ;         //  partial buffer must be re-read to get more
    PVR_ASYNCREADER_WAIT_COUNTER    WaitAnyBuffer ;             //  wait for any buffer
    PVR_ASYNCREADER_WAIT_COUNTER    WaitReadCompletion ;        //  wait for specific buffer completion
    ULONGLONG                       ullLastDiskRead ;           //  last disk read
    ULONGLONG                       cIoPended ;                 //  # of IOs pended
    ULONGLONG                       cIoCompletedSuccess ;       //  pended IO return success
    ULONGLONG                       cIoCompletedError ;         //  pended IO return failure
    ULONGLONG                       cIoPendingError ;           //  pend returned neither ERROR_IO_PENDING or NOERROR
} ;

struct PVR_ASYNCWRITER_COUNTER {
    ULONGLONG   cFileExtensions ;       //  files are extended by quantums
    ULONGLONG   cBytesAppended ;        //  total bytes written
    ULONGLONG   cIoPended ;             //  an IO was successfully pended
    ULONGLONG   cIoPendingError ;       //  an error occured while pending an IO
    ULONGLONG   cWaitNextBuffer ;       //  writer had to wait for the next buffer to complete before proceeding
    ULONGLONG   cIoCompletedSuccess ;   //
    ULONGLONG   cIoCompletedError ;     //
} ;

struct PVR_IO_COUNTERS {
    PVR_ASYNCREADER_COUNTER PVRAsyncReaderCounters ;
    PVR_ASYNCWRITER_COUNTER PVRAsyncWriterCounters ;
} ;

class CPVRIOCountersMem
{
    protected :

        CWin32SharedMem *   m_pSharedMem ;
        PVR_IO_COUNTERS *   m_pPVRIOCounters ;

        CPVRIOCountersMem (
            ) : m_pPVRIOCounters    (NULL),
                m_pSharedMem        (NULL) {}

        virtual
        ~CPVRIOCountersMem (
            )
        {
            delete m_pSharedMem ;
        }

        HRESULT
        Initialize (
            IN  BOOL    fEnable,
            IN  TCHAR * szSharedMemName = TSDVR_PVRIO_STATS_SHAREDMEM_NAME
            )
        //  not serialized !!
        {
            HRESULT hr ;

            //  PREFIX
            hr = S_OK ;

            if (fEnable &&
                !m_pSharedMem) {

                //  turn it on and we're not yet on

                m_pSharedMem = new CWin32SharedMem (
                                        szSharedMemName,
                                        sizeof PVR_IO_COUNTERS,
                                        & hr
                                        ) ;

                if (m_pSharedMem &&
                    SUCCEEDED (hr)) {

                    m_pPVRIOCounters = reinterpret_cast <PVR_IO_COUNTERS *> (m_pSharedMem -> GetSharedMem ()) ;
                }
                else {
                    hr = (m_pSharedMem ? hr : E_OUTOFMEMORY) ;
                    DELETE_RESET (m_pSharedMem) ;
                }
            }
            else if (!fEnable) {
                //  turn stats off

                DELETE_RESET (m_pSharedMem) ;
                m_pPVRIOCounters = NULL ;

                hr = S_OK ;
            }

            return hr ;
        }

        HRESULT
        Clear (
            )
        //  not serialized !!
        {
            if (m_pSharedMem) {

                //  frame this in a __try/__except because it's possible for
                //   another process to create the shared mem, but make it
                //   smaller; we'll AV when we exceed the original (smaller)
                //   size

                __try {

                    ZeroMemory (
                        m_pSharedMem -> GetSharedMem (),
                        m_pSharedMem -> GetSharedMemSize ()
                        ) ;

                }
                __except (GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    //  return an error code
                    return HRESULT_FROM_WIN32 (STATUS_ACCESS_VIOLATION) ;
                }
            }

            return S_OK ;
        }
} ;

class CPVRIOCounters :
    protected CPVRIOCountersMem
{
    LONG    m_cRef ;

    public :

        CPVRIOCounters (
            ) : m_cRef              (0),
                CPVRIOCountersMem   ()    {}

        LONG AddRef ()  { return ::InterlockedIncrement (& m_cRef) ; }

        LONG Release ()
        {
            if (::InterlockedDecrement (& m_cRef) == 0) {
                delete this ;
                return 0 ;
            }

            return m_cRef ;
        }

        HRESULT
        Initialize (
            IN  BOOL    f
            )
        {
            HRESULT hr ;

            hr = CPVRIOCountersMem::Initialize (f) ;
            if (SUCCEEDED (hr)) {
                hr = Clear () ;
                if (FAILED (hr)) {
                    Initialize (FALSE) ;
                }
            }

            return hr ;
        }

        //  --------------------------------------------------------------------
        //  async reader counters

        __inline void AsyncReader_ReadoutWriteBufferHit ()              { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadoutWriteBufferHit++ ; }}
        __inline void AsyncReader_ReadoutCacheHit ()                    { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadoutCacheHit++ ; }}
        __inline void AsyncReader_ReadoutCacheMiss ()                   { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadoutCacheMiss++ ; }}
        __inline void AsyncReader_WaitReadCompletion_BufferDequeued ()  { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitReadCompletion.cBufferDequeued++ ; }}
        __inline void AsyncReader_PartiallyFilledBuffer ()              { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cPartiallyFilledBuffer++ ; }}
        __inline void AsyncReader_PartialReadAgain ()                   { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cPartialReadAgain++ ; }}
        __inline void AsyncReader_LastDiskRead (ULONGLONG ullStream)    { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.ullLastDiskRead = ullStream ; }}
        __inline void AsyncReader_LastReadout (ULONGLONG ullReadout)    { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.ullLastBufferReadout = ullReadout ; }}
        __inline void AsyncReader_WaitAnyBuffer_SignalSuccess ()        { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cSignaledSuccess++ ; }}
        __inline void AsyncReader_WaitAnyBuffer_SignalFailure ()        { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cSignaledFailure++ ; }}
        __inline void AsyncReader_WaitReadCompletion_SignalSuccess ()   { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitReadCompletion.cSignaledSuccess++ ; }}
        __inline void AsyncReader_WaitAnyBuffer_Queued ()               { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cQueued++ ; }}
        __inline void AsyncReader_WaitAnyBuffer_Dequeued ()             { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cBufferDequeued++ ; }}
        __inline void AsyncReader_ReadAhead ()                          { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadAhead++ ; }}
        __inline void AsyncReader_ReadAheadCacheHit ()                  { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadAheadReadCacheHit++ ; }}
        __inline void AsyncReader_ReadAheadWriteBufferHit ()            { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadAheadWriteBufferHit++ ; }}
        __inline void AsyncReader_IOPended ()                           { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoPended++ ; }}
        __inline void AsyncReader_IOPendedError ()                      { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoPendingError++ ; }}
        __inline void AsyncReader_IOCompletion (DWORD dwRet)            { if (m_pPVRIOCounters) { if (dwRet == NOERROR) {m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoCompletedSuccess++ ;} else { m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoCompletedError++ ;} }}

        //  --------------------------------------------------------------------
        //  async writer counters

        __inline void AsyncWriter_FileExtended ()                       { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncWriterCounters.cFileExtensions++ ; }}
        __inline void AsyncWriter_BytesAppended (DWORD dwBytes)         { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncWriterCounters.cBytesAppended += dwBytes ; }}
        __inline void AsyncWriter_IOPended ()                           { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoPended++ ; }}
        __inline void AsyncWriter_IOPendedError ()                      { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoPendingError++ ; }}
        __inline void AsyncWriter_WaitNextBuffer ()                     { if (m_pPVRIOCounters) { m_pPVRIOCounters -> PVRAsyncWriterCounters.cWaitNextBuffer++ ; }}
        __inline void AsyncWriter_IOCompletion (DWORD dwRet)            { if (m_pPVRIOCounters) { if (dwRet == NOERROR) { m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoCompletedSuccess++ ; } else {m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoCompletedError++ ; }}}
} ;

class CPVRIOCountersReader :
    public  CUnknown,
    public  IPVRIOCountersReader,
    protected CPVRIOCountersMem
{
    CDVRPolicy *    m_pPolicy ;

    public :

        CPVRIOCountersReader (
            IN  IUnknown *  pIUnknown,
            OUT HRESULT *   phr
            ) ;

        ~CPVRIOCountersReader (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  class factory
        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        //  counters interfaces
        DECLARE_IPVRIOCOUNTERSREADER() ;
} ;

#endif  //  __tsdvr_dvrperf_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrpolicy.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdef.h

    Abstract:

        This module all the #defines

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        24-May-2001     created

--*/

#ifndef __tsdvr__dvrpolicy_h
#define __tsdvr__dvrpolicy_h

//  ============================================================================
//  ============================================================================

class CTSDVRSettings
{
    //
    //  ..Val_ is for values
    //  ..Flag_ is for flags i.e. TRUE (non-zero) or FALSE (zero)
    //

    //
    //  ..Instance is specific to the instance (DVRPlay, DVRStreamSource, etc..)
    //  ..DVR is global to DVR i.e. applies to everything
    //

    template <class T>
    struct CTRegVal
    {
        BOOL    fValid ;
        T       Val ;
    } ;

    HKEY                m_hkeyStats ;           //  global; never per-app
    HKEY                m_hkeyDVRRoot ;
    HKEY                m_hkeyInstanceRoot ;
    CRITICAL_SECTION    m_crt ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    DWORD   GetValLocked_ (HKEY hkeyRoot, TCHAR * szValName, BOOL fConst, DWORD   dwDefVal, CTRegVal <DWORD> *) ;
    DWORD   GetValLocked_ (HKEY hkeyRoot, TCHAR * szValName, BOOL fConst, DWORD   dwDefVal, DWORD dwMin, DWORD dwMax, CTRegVal <DWORD> *) ;

    DWORD   InstanceGetVal_ (TCHAR * szValName, BOOL fConst, DWORD dwDefVal, CTRegVal <DWORD> * prv)                             { DWORD dw ; Lock_ () ; dw = GetValLocked_ (m_hkeyInstanceRoot, szValName, fConst, dwDefVal, prv) ; Unlock_ () ; return dw ; }
    DWORD   InstanceGetVal_ (TCHAR * szValName, BOOL fConst, DWORD dwDefVal, DWORD dwMin, DWORD dwMax, CTRegVal <DWORD> * prv)   { DWORD dw ; Lock_ () ; dw = GetValLocked_ (m_hkeyInstanceRoot, szValName, fConst, dwDefVal, dwMin, dwMax, prv) ; Unlock_ () ; return dw ; }

    DWORD   DVRGetVal_ (TCHAR * szValName, BOOL fConst, DWORD dwDefVal, CTRegVal <DWORD> * prv)                                  { DWORD dw ; Lock_ () ; dw = GetValLocked_ (m_hkeyDVRRoot, szValName, fConst, dwDefVal, prv) ;      Unlock_ () ; return dw ; }
    DWORD   DVRGetVal_ (TCHAR * szValName, BOOL fConst, DWORD dwDefVal, DWORD dwMin, DWORD dwMax, CTRegVal <DWORD> * prv)        { DWORD dw ; Lock_ () ; dw = GetValLocked_ (m_hkeyDVRRoot, szValName, fConst, dwDefVal, dwMin, dwMax, prv) ;      Unlock_ () ; return dw ; }

    void
    CloseRegKeys_ (
        ) ;

    //  ------------------------------------------------------------------------
    //  cached registry values

    enum {
        RINGBUFFER_MIN_NUM_BACKING_FILES,
        RINGBUFFER_MAX_NUM_BACKING_FILES,
        RINGBUFFER_BACKING_FILE_DURATION,
        RINGBUFFER_GROWBY,
        MAX_STREAM_DELTA,
        BUFFER_WINDOW_MILLIS,
        WM_PACKET_SIZE,
        INLINE_DSHOW_PROPS,
        SUCCEED_QUERY_ACCEPT,
        USE_CONTINUITY_COUNTER,
        ON_ACTIVATE_WAIT_FIRST_SEEK,
        CAN_IMPLEMENT_IREFERENCECLOCK,
        ALWAYS_IMPLEMENT_IREFERENCECLOCK,
        IMPLEMENT_IMEDIA_SEEKING_ON_FILTER,
        IMPLEMENT_IMEDIA_SEEKING_ON_PIN,
        SUPPORT_TRICK_MODE,
        MAX_KEY_FRAME_FORWARD_RATE,
        WM_INDEX_GRANULARITY_MILLIS,
        DEF_AVG_BITRATE,
        ALL_NOTIFIED_RATES_POSITIVE,
        MAX_SCHED_REC_RELATIVE_SEC,
        QUERY_ALL_FOR_RATE_COMPAT,
        ALLOCATOR_GETBUFFERSIZE,
        ALLOCATOR_GETBUFFERCOUNT,
        ALLOCATOR_GETALIGNVAL,
        ALLOCATOR_GETPREFIXVAL,
        CLOCKSLAVE_MIN_SAMPLING_BRACKET_MILLIS,
        CLOCKSLAVE_MIN_SLAVABLE,
        CLOCKSLAVE_MAX_SLAVABLE,
        MAX_FORWARD_TRICK_RATE,
        MAX_REVERSE_TRICK_RATE,
        MAX_FULLFRAME_RATE,
        MAX_NON_SKIPPING_RATE,
        CHECK_MPEG2_TRICK_MODE_INTERFACE,
        TIMEHOLE_THRESHOLD_MILLIS,
        MAX_NORMALIZER_PTS_DISC_READS,
        MIN_NEARLIVE_MILLIS,
        ASYNC_IO_BUFFER_SIZE,
        ASYNC_WRITER_IO_BUFFER_POOL,
        ASYNC_READER_IO_BUFFER_POOL,
        FILE_GROWTH_QUANTUM,
        UNBUFFERED_IO_FLAG,
        BUFFERPOOL_MAX,
        BUFFERPOOL_MILLIS,
        SEEK_NOOP,
        LOW_BUFFER_PADDING,
        RATE_FF_MINBUFFER_MILLIS,
        RATE_RW_MINBUFFER_MILLIS,
        MAX_SEEKING_F_PROBE_MILLIS,
        MAX_SEEKING_R_PROBE_MILLIS,

        //  --------------------------------------------------------------------
        //  always last
        REG_VALUE_COUNT
    } ;

    CTRegVal <DWORD>    m_RegVal [REG_VALUE_COUNT] ;    //  general purpose
    CTRegVal <DWORD>    m_Reg_StatsEnabled ;            //  special case

    void
    ResetCachedRegValuesLocked_ (
        ) ;

    BOOL
    ToFlagVal_ (
        IN  DWORD   dw
        )
    {
        return (dw ? TRUE : FALSE) ;
    }

    public :

        CTSDVRSettings (
            IN  HKEY    hkeyDefaultTopLevel,
            IN  TCHAR * psz2ndLevel,
            IN  TCHAR * pszInstanceRoot
            ) ;

        ~CTSDVRSettings (
            ) ;

        HKEY    GetDVRRegKey ()                     { return m_hkeyDVRRoot ; }
        HKEY    GetInstanceRegKey ()                { return m_hkeyInstanceRoot ; }

        HRESULT SetDVRRegKey (IN HKEY, IN  TCHAR * pszInstanceRoot) ;    //  key is duplicated

        //  min/max settings
        DWORD   RingBufferMinNumBackingFiles ()     { return DVRGetVal_     (REG_MIN_NUM_BACKING_FILES_NAME,            REG_CONST_MIN_NUM_BACKING_FILES,            REG_DEF_MIN_NUM_BACKING_FILES,          REG_MIN_MIN_NUM_BACKING_FILES,          REG_MAX_MIN_NUM_BACKING_FILES,          & m_RegVal [RINGBUFFER_MIN_NUM_BACKING_FILES]) ; }
        DWORD   RingBufferMaxNumBackingFiles ()     { return DVRGetVal_     (REG_MAX_NUM_BACKING_FILES_NAME,            REG_CONST_MAX_NUM_BACKING_FILES,            REG_DEF_MAX_NUM_BACKING_FILES,          REG_MIN_MAX_NUM_BACKING_FILES,          REG_MAX_MAX_NUM_BACKING_FILES,          & m_RegVal [RINGBUFFER_MAX_NUM_BACKING_FILES]) ; }
        DWORD   RingBufferBackingFileDurSecEach ()  { return DVRGetVal_     (REG_BACKING_FILE_DURATION_SECONDS_NAME,    REG_CONST_BACKING_FILE_DURATION_SECONDS,    REG_DEF_BACKING_FILE_DURATION_SECONDS,  REG_MIN_BACKING_FILE_DURATION_SECONDS,  REG_MAX_BACKING_FILE_DURATION_SECONDS,  & m_RegVal [RINGBUFFER_BACKING_FILE_DURATION]) ; }
        DWORD   WMPacketSize ()                     { return DVRGetVal_     (REG_WM_PACKET_SIZE_NAME,                   REG_CONST_WM_PACKET_SIZE,                   REG_DEF_WM_PACKET_SIZE,                 REG_MIN_WM_PACKET_SIZE,                 REG_MAX_WM_PACKET_SIZE,                 & m_RegVal [WM_PACKET_SIZE]) ; }
        DWORD   AsyncIoBufferLen ()                 { return DVRGetVal_     (REG_ASYNC_IO_BUFFER_SIZE_NAME,             REG_CONST_ASYNC_IO_BUFFER_SIZE,             REG_DEF_ASYNC_IO_BUFFER_SIZE,           REG_MIN_DEF_ASYNC_IO_BUFFER_SIZE,       REG_MAX_DEF_ASYNC_IO_BUFFER_SIZE,       & m_RegVal [ASYNC_IO_BUFFER_SIZE]) ; }
        DWORD   AsyncIoWriteBufferCount ()          { return DVRGetVal_     (REG_ASYNC_WRITER_BUFFER_POOL_NAME,         REG_CONST_ASYNC_WRITER_BUFFER_POOL,         REG_DEF_ASYNC_WRITER_BUFFER_POOL,       REG_MIN_ASYNC_WRITER_BUFFER_POOL,       REG_MAX_ASYNC_WRITER_BUFFER_POOL,       & m_RegVal [ASYNC_WRITER_IO_BUFFER_POOL]) ; }
        DWORD   AsyncIoReadBufferCount ()           { return DVRGetVal_     (REG_ASYNC_READER_BUFFER_POOL_NAME,         REG_CONST_ASYNC_READER_BUFFER_POOL,         REG_DEF_ASYNC_READER_BUFFER_POOL,       REG_MIN_ASYNC_READER_BUFFER_POOL,       REG_MAX_ASYNC_READER_BUFFER_POOL,       & m_RegVal [ASYNC_READER_IO_BUFFER_POOL]) ; }
        DWORD   FileGrowthQuantum ()                { return DVRGetVal_     (REG_FILE_GROWTH_QUANTUM_NAME,              REG_CONST_FILE_GROWTH_QUANTUM,              REG_DEF_FILE_GROWTH_QUANTUM,            REG_MIN_FILE_GROWTH_QUANTUM,            REG_MAX_FILE_GROWTH_QUANTUM,            & m_RegVal [FILE_GROWTH_QUANTUM]) ; }
        DWORD   AllocatorGetBufferCount ()          { return DVRGetVal_     (REG_SOURCE_ALLOCATOR_CBUFFERS_NAME,        REG_CONST_SOURCE_ALLOCATOR_CBUFFERS,        REG_DEF_SOURCE_ALLOCATOR_CBUFFERS,      REG_MIN_SOURCE_ALLOCATOR_CBUFFERS,      REG_MAX_SOURCE_ALLOCATOR_CBUFFERS,      & m_RegVal [ALLOCATOR_GETBUFFERCOUNT]) ; }
        DWORD   MaxBufferPoolPerStream ()           { return DVRGetVal_     (REG_BUFFERPOOL_MAX_NAME,                   REG_CONST_BUFFERPOOL_MAX,                   REG_DEF_BUFFERPOOL_MAX,                 REG_MIN_BUFFERPOOL_MAX,                 REG_MAX_BUFFERPOOL_MAX,                 & m_RegVal [BUFFERPOOL_MAX]) ; }
        DWORD   LowBufferPaddingMillis ()           { return DVRGetVal_     (REG_LOW_BUFFER_PADDING_MILLIS_NAME,        REG_CONST_LOW_BUFFER_PADDING_MILLIS,        REG_DEF_LOW_BUFFER_PADDING_MILLIS,      REG_MIN_LOW_BUFFER_PADDING_MILLIS,      REG_MAX_LOW_BUFFER_PADDING_MILLIS,      & m_RegVal [LOW_BUFFER_PADDING]) ; }
        DWORD   BufferPoolMillis ()                 { return DVRGetVal_     (REG_BUFFERPOOL_MILLIS_NAME,                REG_CONST_BUFFERPOOL_MILLIS,                REG_DEF_BUFFERPOOL_MILLIS,              REG_MIN_BUFFERPOOL_MILLIS,              REG_MAX_BUFFERPOOL_MILLIS,              & m_RegVal [BUFFERPOOL_MILLIS]) ; }
        DWORD   SeekNoopMillis ()                   { return DVRGetVal_     (REG_SEEK_NOOP_NAME,                        REG_CONST_SEEK_NOOP,                        REG_DEF_SEEK_NOOP,                      REG_MIN_SEEK_NOOP,                      REG_MAX_SEEK_NOOP,                      & m_RegVal [SEEK_NOOP]) ; }
        DWORD   FFRateMinBufferMillis ()            { return DVRGetVal_     (REG_FF_REQ_NOOP_BUFFER_MILLIS_NAME,        REG_CONST_FF_REQ_NOOP_BUFFER_MILLIS,        REG_DEF_FF_REQ_NOOP_BUFFER_MILLIS,      REG_MIN_FF_REQ_NOOP_BUFFER_MILLIS,      REG_MAX_FF_REQ_NOOP_BUFFER_MILLIS,      & m_RegVal [RATE_FF_MINBUFFER_MILLIS]) ; }
        DWORD   RWRateMinBufferMillis ()            { return DVRGetVal_     (REG_RW_REQ_NOOP_BUFFER_MILLIS_NAME,        REG_CONST_RW_REQ_NOOP_BUFFER_MILLIS,        REG_DEF_RW_REQ_NOOP_BUFFER_MILLIS,      REG_MIN_RW_REQ_NOOP_BUFFER_MILLIS,      REG_MAX_RW_REQ_NOOP_BUFFER_MILLIS,      & m_RegVal [RATE_RW_MINBUFFER_MILLIS]) ; }
        DWORD   F_MaxSeekingProbeMillis ()          { return DVRGetVal_     (REG_MAX_SEEKING_F_PROBES_NAME,             REG_CONST_MAX_SEEKING_F_PROBES,             REG_DEF_MAX_SEEKING_F_PROBES,           REG_MIN_MAX_SEEKING_F_PROBES,           REG_MAX_MAX_SEEKING_F_PROBES,           & m_RegVal [MAX_SEEKING_F_PROBE_MILLIS]) ; }
        DWORD   R_MaxSeekingProbeMillis ()          { return DVRGetVal_     (REG_MAX_SEEKING_R_PROBES_NAME,             REG_CONST_MAX_SEEKING_R_PROBES,             REG_DEF_MAX_SEEKING_R_PROBES,           REG_MIN_MAX_SEEKING_R_PROBES,           REG_MAX_MAX_SEEKING_R_PROBES,           & m_RegVal [MAX_SEEKING_R_PROBE_MILLIS]) ; }
        DWORD   IndexGranularityMillis ()           { return DVRGetVal_     (REG_INDEX_GRANULARITY_MILLIS_NAME,         REG_CONST_INDEX_GRANULARITY_MILLIS,         REG_DEF_INDEX_GRANULARITY_MILLIS,       REG_MIN_INDEX_GRANULARITY_MILLIS,       REG_MAX_INDEX_GRANULARITY_MILLIS,       & m_RegVal [WM_INDEX_GRANULARITY_MILLIS]) ; }

        //  no min/max settings
        DWORD   MaxStreamDeltaMillis ()             { return DVRGetVal_     (REG_MAX_STREAM_DELTA_NAME,                 REG_CONST_MAX_STREAM_DELTA,                 REG_DEF_MAX_STREAM_DELTA,               & m_RegVal [MAX_STREAM_DELTA]) ; }
        DWORD   MaxScheduledRecordRelativeSeconds (){ return DVRGetVal_     (REG_MAX_SCHED_REC_RELATIVE_SEC_NAME,       REG_CONST_MAX_SCHED_REC_RELATIVE_SEC,       REG_DEF_MAX_SCHED_REC_RELATIVE_SEC,     & m_RegVal [MAX_SCHED_REC_RELATIVE_SEC]) ; }
        DWORD   RingBufferGrowBy ()                 { return DVRGetVal_     (REG_RING_BUFFER_GROW_BY_NAME,              REG_CONST_RING_BUFFER_GROW_BY,              REG_DEF_RING_BUFFER_GROW_BY,            & m_RegVal [RINGBUFFER_GROWBY]) ; }
        DWORD   WMBufferWindowMillis ()             { return DVRGetVal_     (REG_WM_BUFFER_WINDOW_NAME,                 REG_CONST_WM_BUFFER_WINDOW,                 REG_DEF_WM_BUFFER_WINDOW,               & m_RegVal [BUFFER_WINDOW_MILLIS]) ; }
        DWORD   DefaultAverageBitRate ()            { return DVRGetVal_     (REG_DEF_AVG_BITRATE_NAME,                  REG_CONST_DEF_AVG_BITRATE,                  REG_DEF_DEF_AVG_BITRATE,                & m_RegVal [DEF_AVG_BITRATE]) ; }
        DWORD   ClockSlaveSampleBracketMillis ()    { return DVRGetVal_     (REG_CLOCKSLAVE_SAMPLING_BRACKET_MILLIS_NAME,REG_CONST_CLOCKSLAVE_SAMPLING_BRACKET_MILLIS,REG_DEF_CLOCKSLAVE_SAMPLING_BRACKET_MILLIS,& m_RegVal [CLOCKSLAVE_MIN_SAMPLING_BRACKET_MILLIS]) ; }
        DWORD   ClockSlaveMinSlavable ()            { return DVRGetVal_     (REG_CLOCKSLAVE_MIN_SLAVABLE_NAME,          REG_CONST_CLOCKSLAVE_MIN_SLAVABLE,          REG_DEF_CLOCKSLAVE_MIN_SLAVABLE,        & m_RegVal [CLOCKSLAVE_MIN_SLAVABLE]) ; }
        DWORD   ClockSlaveMaxSlavable ()            { return DVRGetVal_     (REG_CLOCKSLAVE_MAX_SLAVABLE_NAME,          REG_CONST_CLOCKSLAVE_MAX_SLAVABLE,          REG_DEF_CLOCKSLAVE_MAX_SLAVABLE,        & m_RegVal [CLOCKSLAVE_MAX_SLAVABLE]) ; }
        DWORD   TimeholeThresholdMillis ()          { return DVRGetVal_     (REG_TIMEHOLE_THRESHOLD_MILLIS_NAME,        REG_CONST_TIMEHOLE_THRESHOLD_MILLIS,        REG_DEF_TIMEHOLE_THRESHOLD_MILLIS,      & m_RegVal [TIMEHOLE_THRESHOLD_MILLIS]) ; }
        DWORD   MaxNormalizerPTSDiscReads ()        { return DVRGetVal_     (REG_MAX_NORMALIZER_PTS_DISC_READS_NAME,    REG_CONST_MAX_NORMALIZER_PTS_DISC_READS,    REG_DEF_MAX_NORMALIZER_PTS_DISC_READS,  & m_RegVal [MAX_NORMALIZER_PTS_DISC_READS]) ; }
        DWORD   MinNearLiveMillis ()                { return DVRGetVal_     (REG_MIN_NEARLIVE_MILLIS_NAME,              REG_CONST_MIN_NEARLIVE_MILLIS,              REG_DEF_MIN_NEARLIVE_MILLIS,            & m_RegVal [MIN_NEARLIVE_MILLIS]) ; }
        DWORD   MaxFullFrameRate ()                 { return DVRGetVal_     (REG_MAX_FULLFRAME_F_PLAY_RATE_NAME,        REG_CONST_MAX_FULLFRAME_F_PLAY_RATE,        REG_DEF_MAX_FULLFRAME_F_PLAY_RATE,      & m_RegVal [MAX_FULLFRAME_RATE]) ; }
        DWORD   MaxKeyFrameForwardRate ()           { return DVRGetVal_     (REG_MAX_KEYFRAME_FOR_TRICK_MODE_NAME,      REG_CONST_MAX_KEYFRAME_FOR_TRICK_MODE,      REG_DEF_MAX_KEYFRAME_FOR_TRICK_MODE,    & m_RegVal [MAX_KEY_FRAME_FORWARD_RATE]) ; }
        DWORD   MaxNonSkippingRate ()               { return DVRGetVal_     (REG_MAX_NON_SKIPPING_PLAY_RATE_NAME,       REG_CONST_MAX_NON_SKIPPING_PLAY_RATE,       REG_DEF_MAX_NON_SKIPPING_PLAY_RATE,     & m_RegVal [MAX_NON_SKIPPING_RATE]) ; }
        DWORD   MaxForwardRate ()                   { return DVRGetVal_     (REG_MAX_FORWARD_TRICK_MODE_NAME,           REG_CONST_MAX_FORWARD_TRICK_MODE,           REG_DEF_MAX_FORWARD_TRICK_MODE,         & m_RegVal [MAX_FORWARD_TRICK_RATE]) ; }
        DWORD   MaxReverseRate ()                   { return DVRGetVal_     (REG_MAX_REVERSE_TRICK_MODE_NAME,           REG_CONST_MAX_REVERSE_TRICK_MODE,           REG_DEF_MAX_REVERSE_TRICK_MODE,         & m_RegVal [MAX_REVERSE_TRICK_RATE]) ; }
        BOOL    UseUnbufferedIo ()                  { return DVRGetVal_     (REG_UNBUFFERED_IO_FLAG_NAME,               REG_CONST_UNBUFFERED_IO_FLAG,               REG_DEF_UNBUFFERED_IO_FLAG,             & m_RegVal [UNBUFFERED_IO_FLAG]) ; }
        BOOL    CheckTricMpeg2TrickModeInterface () { return DVRGetVal_     (REG_CHECK_MPEG2_TRICK_INTERFACE_NAME,      REG_CONST_CHECK_MPEG2_TRICK_INTERFACE,      REG_DEF_CHECK_MPEG2_TRICK_INTERFACE,    & m_RegVal [CHECK_MPEG2_TRICK_MODE_INTERFACE]) ; }

        BOOL    QueryAllForRateCompatibility ()     { return ToFlagVal_     (DVRGetVal_     (REG_QUERY_ALL_FOR_RATE_COMPAT_NAME,    REG_CONST_QUERY_ALL_FOR_RATE_COMPAT,    REG_DEF_QUERY_ALL_FOR_RATE_COMPAT,      & m_RegVal [QUERY_ALL_FOR_RATE_COMPAT])) ; }
        BOOL    UseContinuityCounter ()             { return ToFlagVal_     (DVRGetVal_     (REG_USE_CONTINUITY_COUNTER_NAME,       REG_CONST_USE_CONTINUITY_COUNTER,       REG_DEF_USE_CONTINUITY_COUNTER,         & m_RegVal [USE_CONTINUITY_COUNTER])) ; }
        BOOL    ImplementIMediaSeekingOnFilter ()   { return ToFlagVal_     (DVRGetVal_     (REG_IMPL_IMEDIASEEKING_ON_FILTER_NAME, REG_CONST_IMPL_IMEDIASEEKING_ON_FILTER, REG_DEF_IMPL_IMEDIASEEKING_ON_FILTER,   & m_RegVal [IMPLEMENT_IMEDIA_SEEKING_ON_FILTER])) ; }
        BOOL    ImplementIMediaSeekingOnPin ()      { return ToFlagVal_     (DVRGetVal_     (REG_IMPL_IMEDIASEEKING_ON_PIN_NAME,    REG_CONST_IMPL_IMEDIASEEKING_ON_PIN,    REG_DEF_IMPL_IMEDIASEEKING_ON_PIN,      & m_RegVal [IMPLEMENT_IMEDIA_SEEKING_ON_PIN])) ; }
        BOOL    SupportTrickMode ()                 { return ToFlagVal_     (DVRGetVal_     (REG_SUPPORT_TRICK_MODE_NAME,           REG_CONST_SUPPORT_TRICK_MODE,           REG_DEF_SUPPORT_TRICK_MODE,             & m_RegVal [SUPPORT_TRICK_MODE])) ; }
        BOOL    AllNotifiedRatesPositive ()         { return ToFlagVal_     (DVRGetVal_     (REG_ALL_NOTIFIED_RATES_POSITIVE_NAME,  REG_CONST_ALL_NOTIFIED_RATES_POSITIVE,  REG_DEF_ALL_NOTIFIED_RATES_POSITIVE,    & m_RegVal [ALL_NOTIFIED_RATES_POSITIVE])) ; }
        BOOL    OnActiveWaitFirstSeek ()            { return ToFlagVal_     (InstanceGetVal_ (REG_ONACTIVE_WAIT_FIRST_SEEK_NAME,    REG_CONST_ONACTIVE_WAIT_FIRST_SEEK,     REG_DEF_ONACTIVE_WAIT_FIRST_SEEK,       & m_RegVal [ON_ACTIVATE_WAIT_FIRST_SEEK])) ; }
        BOOL    CanImplementIReferenceClock ()      { return ToFlagVal_     (InstanceGetVal_ (REG_IMPLEMENT_IREFERENCECLOCK_NAME,   REG_CONST_IMPLEMENT_IREFERENCECLOCK,    REG_DEF_IMPLEMENT_IREFERENCECLOCK,      & m_RegVal [CAN_IMPLEMENT_IREFERENCECLOCK])) ; }
        BOOL    AlwaysImplementIReferenceClock ()   { return ToFlagVal_     (InstanceGetVal_ (REG_ALWAYS_IMPLEMENT_IREFCLOCK_NAME,  REG_CONST_ALWAYS_IMPLEMENT_IREFCLOCK,   REG_DEF_ALWAYS_IMPLEMENT_IREFCLOCK,     & m_RegVal [ALWAYS_IMPLEMENT_IREFERENCECLOCK])) ; }
        BOOL    InlineDShowProps ()                 { return ToFlagVal_     (InstanceGetVal_ (REG_INLINE_DSHOW_PROPS_NAME,          REG_CONST_INLINE_DSHOW_PROPS,           REG_DEF_INLINE_DSHOW_PROPS,             & m_RegVal [INLINE_DSHOW_PROPS])) ; }
        BOOL    SucceedQueryAccept ()               { return ToFlagVal_     (InstanceGetVal_ (REG_SUCCEED_QUERY_ACCEPT_NAME,        REG_CONST_SUCCEED_QUERY_ACCEPT,         REG_DEF_SUCCEED_QUERY_ACCEPT,           & m_RegVal [SUCCEED_QUERY_ACCEPT])) ; }

        DWORD   AllocatorGetBufferSize ()           { return InstanceGetVal_  (REG_SOURCE_ALLOCATOR_CBBUFFER_NAME,   REG_CONST_SOURCE_ALLOCATOR_CBBUFFER,   REG_DEF_SOURCE_ALLOCATOR_CBBUFFER,   & m_RegVal [ALLOCATOR_GETBUFFERSIZE]) ; }
        DWORD   AllocatorGetAlignVal ()             { return InstanceGetVal_  (REG_SOURCE_ALLOCATOR_ALIGN_VAL_NAME,  REG_CONST_SOURCE_ALLOCATOR_ALIGN_VAL,  REG_DEF_SOURCE_ALLOCATOR_ALIGN_VAL,  & m_RegVal [ALLOCATOR_GETALIGNVAL]) ; }
        DWORD   AllocatorGetPrefixVal ()            { return InstanceGetVal_  (REG_SOURCE_ALLOCATOR_PREFIX_VAL_NAME, REG_CONST_SOURCE_ALLOCATOR_PREFIX_VAL, REG_DEF_SOURCE_ALLOCATOR_PREFIX_VAL, & m_RegVal [ALLOCATOR_GETPREFIXVAL]) ; }

        BOOL    StatsEnabled ()                     { DWORD dw ; Lock_ () ; dw = GetValLocked_ (m_hkeyStats, REG_DVR_STATS_NAME, REG_CONST_DVR_STATS,   REG_DEF_STATS, & m_Reg_StatsEnabled) ; Unlock_ () ; return ToFlagVal_ (dw) ; }
        DWORD   EnableStats (BOOL f) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVREventSink
{
    CRITICAL_SECTION    m_crt ;
    IMediaEventSink *   m_pIMediaEventSink ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    public :

        CDVREventSink (
            ) ;

        ~CDVREventSink (
            ) ;

        HRESULT
        Initialize (
            IN  IFilterGraph *  pIFilterGraph
            ) ;

        HRESULT
        OnEvent (
            IN  long        lEventCode,
            IN  LONG_PTR    lptrEventParam1,
            IN  LONG_PTR    lptrEventParam2
            ) ;

        //  DVRIO-originated callbacks
        static
        void
        __stdcall
        DVRIOCallback (
            IN  LPVOID  pvContext,
            IN  DWORD   dwNotificationReasons
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRPolicy
{
    CDVREventSink       m_EventSink ;
    CTSDVRSettings      m_RegSettings ;
    LONG                m_lRef ;
    CRITICAL_SECTION    m_crt ;
    CW32SID *           m_pW32SID ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    public :

        CDVRPolicy (
            IN  TCHAR *     pszInstRegRoot,
            OUT HRESULT *   phr
            ) ;

        ~CDVRPolicy (
            ) ;

        HRESULT
        SetRootHKEY (
            IN  HKEY    hkeyRoot,
            IN  TCHAR * pszInstanceRoot
            )
        {
            return m_RegSettings.SetDVRRegKey (hkeyRoot, pszInstanceRoot) ;
        }

        HRESULT
        SetSIDs (
            IN  DWORD   cSIDs,
            IN  PSID *  ppSID
            ) ;

        //  fails if there is none
        HRESULT
        GetSIDs (
            OUT CW32SID **  ppW32SIDs
            ) ;

        CTSDVRSettings * Settings ()    { return & m_RegSettings ; }
        CDVREventSink *  EventSink ()   { return & m_EventSink ; }

        //  lifetime
        ULONG AddRef ()     { return InterlockedIncrement (& m_lRef) ; }
        ULONG Release () ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRConfigure :
    public CUnknown,
    public IStreamBufferConfigure,
    public IStreamBufferInitialize
{
    HKEY    m_hkeyDVRRoot ;             //  copy of init key; only used to tell if we're initialized

    BOOL IsInitialized_ ()  { return (m_hkeyDVRRoot != NULL ? TRUE : FALSE) ; }

    public :

        CDVRConfigure (
            IN  LPUNKNOWN   punkControlling
            ) ;

        ~CDVRConfigure (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT VOID ** ppv
            ) ;

        //  ====================================================================
        //  IStreamBufferConfigure

        STDMETHODIMP
        SetDirectory (
            IN  LPCWSTR pszDirectoryName
            ) ;

        STDMETHODIMP
        GetDirectory (
            OUT LPWSTR *    ppszDirectoryName
            ) ;

        STDMETHODIMP
        SetBackingFileCount (
            IN  DWORD   dwMin,
            IN  DWORD   dwMax
            ) ;

        STDMETHODIMP
        GetBackingFileCount (
            OUT DWORD * pdwMin,
            OUT DWORD * pdwMax
            ) ;

        STDMETHODIMP
        SetBackingFileDuration (
            IN  DWORD   dwSeconds
            ) ;

        STDMETHODIMP
        GetBackingFileDuration (
            OUT DWORD * pdwSeconds
            ) ;

        //  ====================================================================
        //  IStreamBufferInitialize

        STDMETHODIMP
        SetHKEY (
            IN  HKEY    hkeyRoot
            ) ;

        STDMETHODIMP
        SetSIDs (
            IN  DWORD   cSIDs,
            IN  PSID *  ppSID
            ) ;

        //  ====================================================================
        //  class-factory method

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  punkControlling,
            IN  HRESULT *   phr
            ) ;
} ;

#endif  //  __tsdvr__dvrpolicy_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrtrace.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrtrace.h

    Abstract:

        This module contains tracing wrappers for DirectShow's, with standard
            levels, etc..

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef _tsdvr__dvrtrace_h
#define _tsdvr__dvrtrace_h

//  standard levels
#define TRACE_ENTER_LEAVE_LEVEL             9
#define TRACE_ERROR_LEVEL                   3
#define CONSTRUCTOR_DESTRUCTOR_LEVEL        (TRACE_ENTER_LEAVE_LEVEL - 1)

//  ============================================================================
//  LOG_AREA_
//
//  These definitions broadly categorize related areas, so they can be turned
//   on with minimum/none frivolous, non-related tracing.

//  CONSTRUCTOR_DESTRUCTOR
//      falls into the memory management area
//
//      levels:
//          all 1: CONSTRUCTOR_DESTRUCTOR_LEVEL (defined above)
//          3
//          4
//          5
#define LOG_AREA_CONSTRUCTOR_DESTRUCTOR     LOG_MEMORY

//  WMSDK
//      used to trace operations that are specific to WMSDK such as profile
//      creation, manipulation, etc...
//
//      levels:
//          1   * ordinary runtime operations, such as profile creation,
//                  manipulation
//          2
//          3
//          4
//          5   * runtime dshow <-> wmsdk translation
#define LOG_AREA_WMSDK_DSHOW                LOG_CUSTOM1

//  IMediaSeeking & trick mode operation
//      used to trace operations that are specifically related to IMediaSeeking
//      calls; also used to trace segment notifications
//
//      levels:
//          1   * SetPosition call parameters & return values;
//              * IDVRReader adjustments;
//              * new segment notifications/pin
//              * rate change calls
//              * rate change actual i.e. when it happens (gop boundaries)
//              * failed rate changes
//              * reader thread start/stop
//              * back-to-live 1x transition when rate > 1x
//          2   * GOP boundary discovery
//          3
//          4   * duration (static & live file)
//          5
#define LOG_AREA_SEEKING_AND_TRICK          LOG_CUSTOM2

//  time-related tracing
//      used to trace out timestamp recovery & generation; a/v sync
//      adjustments; ref clock values
//
//      levels:
//          1   * timestamp normalization value discovery
//              * we're IReferenceClock (TRUE/FALSE)
//              * underflow PTS padding adjustments
//          2
//          3
//          4   * IReferenceClock thread activity
//              * receipt stream time trace
//          5   * all timestamps (in csv format)
#define LOG_AREA_TIME                       LOG_TIMING

//  DVR analysis related tracing
//      used to trace out DVR analysis, format-specific analysis, analysis
//      collection, analysis usage
//
//      levels:
//          1
//          2
//          3
//          4
//          5   * duplicate attribute removal
//          6   [format-specific] tracing
//              * mpeg-2 frame detection
//          7   * analysis recovery & outgoing media sample reconstruction
//          8   * all analyzed outgoing media samples
#define LOG_AREA_DVRANALYSIS                LOG_CUSTOM3

//  clock-slaving related tracing
//      used to trace out any clock slaving activity, such as states, windows,
//      degradations, etc...
//
//      levels:
//          1   * sampling window completion
//              * historic scaling val addition
//              * history trimming activities
//
#define LOG_AREA_CLOCK_SLAVE                LOG_CUSTOM4

//  DVR recording related tracing
//      used to trace recording activity (creation, starts, stops)
//
//      levels:
//          1   * creation
//              * start
//              * stop
//          6   * read/write IO pend
//              * read/write IO completions
//          7   * read ahead logic
//              * buffer pool
//              * READs
//              * WRITEs
//
#define LOG_AREA_RECORDING                  LOG_CUSTOM5
#define LOG_AREA_PVRIO                      LOG_CUSTOM5

//  general
//
//      levels:
//          1   * filtergraph state changes
//              * read controller init
//              * dynamic format changes
//              * rtBase, following a seek
//              * timestamp padding, if near live
//          2   * segment-related
//          3
//          4
//          5
//          6
//          7
//          8   * media sample traffic
//              * timestamps
#define LOG_AREA_DSHOW                      LOG_TRACE

#ifdef DEBUG

#define TRACE_0(ds,l,fmt)                    DbgLog((ds,l,fmt))
#define TRACE_1(ds,l,fmt,a)                  DbgLog((ds,l,fmt,a))
#define TRACE_2(ds,l,fmt,a,b)                DbgLog((ds,l,fmt,a,b))
#define TRACE_3(ds,l,fmt,a,b,c)              DbgLog((ds,l,fmt,a,b,c))
#define TRACE_4(ds,l,fmt,a,b,c,d)            DbgLog((ds,l,fmt,a,b,c,d))
#define TRACE_5(ds,l,fmt,a,b,c,d,e)          DbgLog((ds,l,fmt,a,b,c,d,e))
#define TRACE_6(ds,l,fmt,a,b,c,d,e,f)        DbgLog((ds,l,fmt,a,b,c,d,e,f))
#define TRACE_7(ds,l,fmt,a,b,c,d,e,f,g)      DbgLog((ds,l,fmt,a,b,c,d,e,f,g))
#define TRACE_8(ds,l,fmt,a,b,c,d,e,f,g,h)    DbgLog((ds,l,fmt,a,b,c,d,e,f,g,h))

#else

#define TRACE_0(ds,l,fmt)                    0
#define TRACE_1(ds,l,fmt,a)                  0
#define TRACE_2(ds,l,fmt,a,b)                0
#define TRACE_3(ds,l,fmt,a,b,c)              0
#define TRACE_4(ds,l,fmt,a,b,c,d)            0
#define TRACE_5(ds,l,fmt,a,b,c,d,e)          0
#define TRACE_6(ds,l,fmt,a,b,c,d,e,f)        0
#define TRACE_7(ds,l,fmt,a,b,c,d,e,f,g)      0
#define TRACE_8(ds,l,fmt,a,b,c,d,e,f,g,h)    0

#endif

//  ---------------------------------------------------------------------------
//  error
//  ---------------------------------------------------------------------------

#define TRACE_ERROR()                       TRACE_2(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u)"),TEXT(__FILE__), __LINE__)
#define TRACE_ERROR_0(fmt)                  TRACE_2(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__)
#define TRACE_ERROR_1(fmt,a)                TRACE_3(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a)
#define TRACE_ERROR_2(fmt,a,b)              TRACE_4(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b)
#define TRACE_ERROR_3(fmt,a,b,c)            TRACE_5(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c)
#define TRACE_ERROR_4(fmt,a,b,c,d)          TRACE_6(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c,d)
#define TRACE_ERROR_5(fmt,a,b,c,d,e)        TRACE_7(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c,d,e)
#define TRACE_ERROR_6(fmt,a,b,c,d,e,f)      TRACE_8(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c,d,e,f)

#define ERROR_SPEW(v,op,c)                  TRACE_ERROR_5(TEXT("(%s = 0x%08xh) %s (%s = 0x%08xh)"),TEXT(#v),v,TEXT(#op),TEXT(#c),c)
#define ERROR_SPEW_EX(v,op,c,m)             TRACE_ERROR_6(TEXT("(%s = 0x%08xh) %s (%s = 0x%08xh); %s"),TEXT(#v),v,TEXT(#op),TEXT(#c),c,m)
#define ERROR_RET(v,op,c)                   if ((v) op (c)) { ERROR_SPEW(v,op,c); return ; }
#define ERROR_RET_VAL(v,op,c,r)             if ((v) op (c)) { ERROR_SPEW(v,op,c); return (r) ; }
#define ERROR_RET_EX(v,op,c,m)              if ((v) op (c)) { ERROR_SPEW_EX(v,op,c,m); return ; }
#define ERROR_RET_VAL_EX(v,op,c,r,m)        if ((v) op (c)) { ERROR_SPEW_EX(v,op,c,m); return (r) ; }

//  ---------------------------------------------------------------------------
//  constructor / destructor
//  ---------------------------------------------------------------------------

#define TRACE_CONSTRUCTOR(fmt)              TRACE_1(LOG_AREA_CONSTRUCTOR_DESTRUCTOR,CONSTRUCTOR_DESTRUCTOR_LEVEL,TEXT("[%08xh] CONSTRUCTOR : ") fmt TEXT("::") fmt, this)
#define TRACE_DESTRUCTOR(fmt)               TRACE_1(LOG_AREA_CONSTRUCTOR_DESTRUCTOR,CONSTRUCTOR_DESTRUCTOR_LEVEL,TEXT("[%08xh] DESTRUCTOR  : ") fmt TEXT("::~") fmt, this)

//  ---------------------------------------------------------------------------
//  enter
//  ---------------------------------------------------------------------------
#define TRACE_ENTER_0(fmt)                  TRACE_0(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt)
#define TRACE_ENTER_1(fmt,a)                TRACE_1(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a)
#define TRACE_ENTER_2(fmt,a,b)              TRACE_2(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b)
#define TRACE_ENTER_3(fmt,a,b,c)            TRACE_3(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c)
#define TRACE_ENTER_4(fmt,a,b,c,d)          TRACE_4(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c,d)
#define TRACE_ENTER_5(fmt,a,b,c,d,e)        TRACE_5(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c,d,e)
#define TRACE_ENTER_6(fmt,a,b,c,d,e,f)      TRACE_6(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c,d,e,f)

//  ---------------------------------------------------------------------------
//  object enter
//  ---------------------------------------------------------------------------
#define O_TRACE_ENTER_0(fmt)                TRACE_ENTER_1(TEXT("[%08xh] ") fmt, this)
#define O_TRACE_ENTER_1(fmt,a)              TRACE_ENTER_2(TEXT("[%08xh] ") fmt, this,a)
#define O_TRACE_ENTER_2(fmt,a,b)            TRACE_ENTER_3(TEXT("[%08xh] ") fmt, this,a,b)
#define O_TRACE_ENTER_3(fmt,a,b,c)          TRACE_ENTER_4(TEXT("[%08xh] ") fmt, this,a,b,c)
#define O_TRACE_ENTER_4(fmt,a,b,c,d)        TRACE_ENTER_5(TEXT("[%08xh] ") fmt, this,a,b,c,d)
#define O_TRACE_ENTER_5(fmt,a,b,c,d,e)      TRACE_ENTER_6(TEXT("[%08xh] ") fmt, this,a,b,c,d,e)

//  ---------------------------------------------------------------------------
//  leave
//  ---------------------------------------------------------------------------
#define TRACE_LEAVE_0(fmt)                  TRACE_0(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt)
#define TRACE_LEAVE_1(fmt,a)                TRACE_1(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a)
#define TRACE_LEAVE_2(fmt,a,b)              TRACE_2(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b)
#define TRACE_LEAVE_3(fmt,a,b,c)            TRACE_3(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c)
#define TRACE_LEAVE_4(fmt,a,b,c,d)          TRACE_4(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c,d)
#define TRACE_LEAVE_5(fmt,a,b,c,d,e)        TRACE_5(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c,d,e)
#define TRACE_LEAVE_6(fmt,a,b,c,d,e,f)      TRACE_6(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c,d,e,f)

//  ---------------------------------------------------------------------------
//  object leave
//  ---------------------------------------------------------------------------
#define O_TRACE_LEAVE_0(fmt)                TRACE_LEAVE_1(TEXT("[%08xh] ") fmt, this)
#define O_TRACE_LEAVE_1(fmt,a)              TRACE_LEAVE_2(TEXT("[%08xh] ") fmt, this,a)
#define O_TRACE_LEAVE_2(fmt,a,b)            TRACE_LEAVE_3(TEXT("[%08xh] ") fmt, this,a,b)
#define O_TRACE_LEAVE_3(fmt,a,b,c)          TRACE_LEAVE_4(TEXT("[%08xh] ") fmt, this,a,b,c)
#define O_TRACE_LEAVE_4(fmt,a,b,c,d)        TRACE_LEAVE_5(TEXT("[%08xh] ") fmt, this,a,b,c,d)
#define O_TRACE_LEAVE_5(fmt,a,b,c,d,e)      TRACE_LEAVE_6(TEXT("[%08xh] ") fmt, this,a,b,c,d,e)

#endif  //  _tsdvr__dvrtrace_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrmacros.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrmacros.h

    Abstract:

        This module contains ts/dvr-wide macros

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__dvrmacros_h
#define __tsdvr__dvrmacros_h

//  macros
#define RELEASE_AND_CLEAR(punk)                 if (punk) { (punk)->Release(); (punk) = NULL; }
#define DELETE_RESET(p)                         { delete (p); (p) = NULL ; }
#define DELETE_RESET_ARRAY(a)                   { delete [] (a); (a) = NULL ; }
#define CLOSE_RESET_REG_KEY(r)                  if ((r) != NULL) { RegCloseKey (r); (r) = NULL ;}
#define LOCK_HELD(crt)                          ((crt) -> OwningThread == (HANDLE) GetCurrentThreadId ())
#define LE_UNATTACHED(ple)                      (IsListEmpty (ple))
#define LE_ATTACHED(ple)                        (!LE_UNATTACHED(ple))
#define SET_UNATTACHED(ple)                     InitializeListHead (ple)
#define DVR_CONTAINS_FIELD(type, field, offset) ((FIELD_OFFSET(type, field) + sizeof(((type *)0)->field)) <= offset)

#endif  //  __tsdvr__dvrmacros_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrutil.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrutil.h

    Abstract:

        This module contains ts/dvr-wide utility prototypes

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef _tsdvr__dvrutil_h
#define _tsdvr__dvrutil_h

HRESULT
KSPropertySet_ (
    IN  IUnknown *      punk,
    IN  const GUID *    pPSGUID,
    IN  DWORD           dwProperty,
    IN  BYTE *          pData,
    IN  DWORD           cbData
    ) ;

HRESULT
KSPropertyGet_ (
    IN  IUnknown *      punk,
    IN  const GUID *    pPSGUID,
    IN  DWORD           dwProperty,
    IN  BYTE *          pData,
    IN  DWORD           cbMax,
    OUT DWORD *         pcbGot
    ) ;

extern BOOL g_fUseRateChange11 ;

double
CompatibleRateValue (
    IN  double  dTargetRate
    ) ;

//  ============================================================================
//  timebase conversions

__inline
DWORD
QPCToMillis (
    IN  LONGLONG    llQPC,
    IN  DWORD       dwQPCFreq
    )
{
    return (DWORD) ((1000 * llQPC) / dwQPCFreq) ;
}

__inline
REFERENCE_TIME
QPCToDShow (
    IN  LONGLONG    llQPC,
    IN  LONGLONG    llQPCFreq
    )
{
    double dRetval ;

    dRetval = llQPC * (10000000.0 / ((double) llQPCFreq)) ;
    return (REFERENCE_TIME) dRetval ;
}

__inline
QWORD
MillisToWMSDKTime (
    IN  DWORD   dwMillis
    )
{
    return dwMillis * 10000I64 ;
}

__inline
REFERENCE_TIME
DShowTimeToMilliseconds (
    IN  REFERENCE_TIME  rt
    )
{
    return rt / 10000 ;
}

__inline
REFERENCE_TIME
DShowTimeToSeconds (
    IN  REFERENCE_TIME  rt
    )
{
    return DShowTimeToMilliseconds (rt) / 1000 ;
}

__inline
DWORD
WMSDKTimeToSeconds (
    IN  QWORD   qw
    )
{
    //  both are 10 MHz clocks
    return (DWORD) DShowTimeToSeconds (qw) ;
}

__inline
QWORD
WMSDKTimeToMilliseconds (
    IN  QWORD   qw
    )
{
    //  both are 10 MHz clocks
    return (QWORD) DShowTimeToMilliseconds (qw) ;
}

__inline
QWORD
SecondsToWMSDKTime (
    IN  DWORD   dwSeconds
    )
{
    return MillisToWMSDKTime (dwSeconds * 1000) ;
}

__inline
REFERENCE_TIME
SecondsToDShowTime (
    IN  DWORD   dwSeconds
    )
{
    //  both are 10 MHz clocks
    return SecondsToWMSDKTime (dwSeconds) ;
}

__inline
QWORD
MinutesToWMSDKTime (
    IN  DWORD   dwMinutes
    )
{
    return SecondsToWMSDKTime (dwMinutes * 60) ;
}

__inline
QWORD
DShowToWMSDKTime (
    IN  REFERENCE_TIME  rt
    )
{
    //  both are 10 MHz clocks; rt should never be < 0
    ASSERT (rt >= 0I64) ;
    return (QWORD) rt ;
}

__inline
REFERENCE_TIME
WMSDKToDShowTime (
    IN  QWORD   qw
    )
{
    REFERENCE_TIME  rtRet ;

    //  both are 10 MHz clocks, but WMSDK is unsigned
    rtRet = (REFERENCE_TIME) qw ;
    if (rtRet < 0I64) {
        rtRet = MAX_REFERENCE_TIME ;
    }

    return rtRet ;
}

BOOL
AMMediaIsTimestamped (
    IN  AM_MEDIA_TYPE * pmt
    ) ;

__inline
REFERENCE_TIME
MillisToDShowTime (
    IN  DWORD   dwMillis
    )
{
    return WMSDKToDShowTime (MillisToWMSDKTime (dwMillis)) ;
}

//  ============================================================================

__inline
BOOL
IsMaybeStartCodePrefix (
    IN  BYTE *  pbBuffer,
    IN  LONG    lBufferLength
    )
{
    ASSERT (lBufferLength < START_CODE_PREFIX_LENGTH) ;

    if (lBufferLength == 1) {
        return (pbBuffer [0] == 0x00 ? TRUE : FALSE) ;
    }
    else if (lBufferLength == 2) {
        return (pbBuffer [0] == 0x00 && pbBuffer [1] == 0x00 ? TRUE : FALSE) ;
    }
    else {
        return FALSE ;
    }
}

__inline
BYTE
StartCode (
    IN BYTE *   pbStartCode
    )
{
    return pbStartCode [3] ;
}

__inline
BOOL
IsStartCodePrefix (
    IN  BYTE *  pbBuffer
    )
{
    return (pbBuffer [0] == 0x00 &&
            pbBuffer [1] == 0x00 &&
            pbBuffer [2] == 0x01) ;
}

//  TRUE :  (* ppbBuffer) points to prefix i.e. = {00,00,01}
//  FALSE:  (* piBufferLength) == 2
__inline
BOOL
SeekToPrefix (
    IN OUT  BYTE ** ppbBuffer,
    IN OUT  LONG *  plBufferLength
    )
{
    while ((* plBufferLength) >= START_CODE_PREFIX_LENGTH) {
        if (IsStartCodePrefix (* ppbBuffer)) {
            return TRUE ;
        }

        //  advance to next byte and decrement number of bytes left
        (* plBufferLength)-- ;
        (* ppbBuffer)++ ;
    }

    return FALSE ;
}

HRESULT
IndexStreamId (
    IN  IWMProfile *    pIWMProfile,
    OUT WORD *          pwStreamId
    ) ;

HRESULT
CopyWMProfile (
    IN  CDVRPolicy *    pPolicy,
    IN  IWMProfile *    pIMasterProfile,
    OUT IWMProfile **   ppIWMCopiedProfile
    ) ;

HRESULT
DiscoverTimelineStream (
    IN  IWMProfile *    pIWMProfile,
    OUT WORD *          pwTimelineStream
    ) ;

BOOL
IsBlankMediaType (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsAMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsWMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsAMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsWMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsGenericVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsGenericAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsMpeg2Video (
    IN  AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsMpeg2Audio (
    IN  AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsDolbyAc3Audio (
    IN  AM_MEDIA_TYPE * pmt
    ) ;

void
EncryptedSubtypeHack_IN (
    IN OUT  AM_MEDIA_TYPE * pmt
    ) ;

void
EncryptedSubtypeHack_OUT (
    IN OUT  AM_MEDIA_TYPE * pmt
    ) ;

void
DumpINSSBuffer3Attributes (
    IN  INSSBuffer *    pINSSBuffer,
    IN  QWORD           cnsRead,
    IN  WORD            wStream,
    IN  DWORD           dwTraceLevel = 7
    ) ;

#ifdef SBE_PERF

void
OnCaptureInstrumentPerf_ (
    IN  IMediaSample *  pIMediaSample,
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  int             iStream
    ) ;

void
OnReadout_Perf_ (
    IN  INSSBuffer3 *   pINSSBuffer3
    ) ;

#endif  //  SBE_PERF

//  ============================================================================
//  ============================================================================

class DVRAttributeHelpers
{
    public :

        //  --------------------------------------------------------------------
        //  general

        static
        BOOL
        IsAnalysisPresent (
            IN  IMediaSample2 * pIMediaSample2
            ) ;

        static
        BOOL
        IsAnalysisPresent (
            IN  INSSBuffer *    pINSSBuffer
            ) ;

        static
        BOOL
        IsAnalysisPresent (
            IN  INSSBuffer3 *   pINSSBuffer3
            ) ;

        static
        HRESULT
        GetAttribute (
            IN      IMediaSample *  pIMediaSample,
            IN      GUID            guidAttribute,
            IN OUT  DWORD *         pdwSize,
            OUT     BYTE *          pbBuffer
            ) ;

        static
        HRESULT
        GetAttribute (
            IN      INSSBuffer *    pINSSBuffer,
            IN      GUID            guidAttribute,
            IN OUT  DWORD *         pdwSize,
            OUT     BYTE *          pbBuffer
            ) ;

        static
        HRESULT
        GetAttribute (
            IN      INSSBuffer3 *   pINSSBuffer3,
            IN      GUID            guidAttribute,
            IN OUT  DWORD *         pdwSize,
            OUT     BYTE *          pbBuffer
            ) ;

        static
        HRESULT
        SetAttribute (
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  GUID            guidAttribute,
            IN  DWORD           dwSize,
            IN  BYTE *          pbBuffer
            ) ;

        static
        HRESULT
        SetAttribute (
            IN  INSSBuffer *    pINSSBuffer,
            IN  GUID            guidAttribute,
            IN  DWORD           dwSize,
            IN  BYTE *          pbBuffer
            ) ;

        static
        HRESULT
        SetAttribute (
            IN  IMediaSample *  pIMS,
            IN  GUID            guidAttribute,
            IN  DWORD           dwSize,
            IN  BYTE *          pbBuffer
            ) ;

        static
        BOOL
        IsAttributePresent (
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  GUID            guidAttribute
            ) ;

        static
        BOOL
        IsAttributePresent (
            IN  IMediaSample *  pIMediaSample,
            IN  GUID            guidAttribute
            ) ;

        static
        BOOL
        IsAttributePresent (
            IN  INSSBuffer *    pINSSBuffer,
            IN  GUID            guidAttribute
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class DShowWMSDKHelpers
{
    //  validates and ensures that all values add up correctly
    static
    HRESULT
    FormatBlockSetValidForWMSDK_ (
        IN OUT  AM_MEDIA_TYPE * pmt
        ) ;

    public :

        //  validates and ensures that all values add up correctly
        static
        HRESULT
        MediaTypeSetValidForWMSDK (
            IN OUT  AM_MEDIA_TYPE * pmt
            ) ;

        //  call FreeMediaType ((AM_MEDIA_TYPE *) pWmt) to free
        static
        HRESULT
        TranslateDShowToWM (
            IN  AM_MEDIA_TYPE * pAmt,
            OUT WM_MEDIA_TYPE * pWmt
            ) ;

        static
        HRESULT
        TranslateWMToDShow (
            IN  WM_MEDIA_TYPE * pWmt,
            OUT AM_MEDIA_TYPE * pAmt
            ) ;

        static
        BOOL
        IsWMVideoStream (
            IN  REFGUID guidStreamType
            ) ;

        static
        BOOL
        IsWMAudioStream (
            IN  REFGUID guidStreamType
            ) ;

        static
        WORD
        PinIndexToWMStreamNumber (
            IN  LONG    lIndex
            ) ;

        static
        WORD
        PinIndexToWMInputStream (
            IN  LONG    lIndex
            ) ;

        static
        LONG
        WMStreamNumberToPinIndex (
            IN  WORD    wStreamNumber
            ) ;

        static
        CDVRWMSDKToDShowTranslator *
        GetWMSDKToDShowTranslator (
            IN  AM_MEDIA_TYPE *     pmtConnection,
            IN  CDVRPolicy *        pPolicy,
            IN  int                 iFlowId
            ) ;

        static
        CDVRDShowToWMSDKTranslator *
        GetDShowToWMSDKTranslator (
            IN  AM_MEDIA_TYPE * pmtConnection,
            IN  CDVRPolicy *    pPolicy,
            IN  int             iFlowIdm
            ) ;

        static
        HRESULT
        AddFormatSpecificExtensions (
            IN  IWMStreamConfig2 *  pIWMStreamConfig2,
            IN  AM_MEDIA_TYPE *     pmt
            ) ;

        static
        HRESULT
        AddDVRAnalysisExtensions (
            IN  IWMStreamConfig2 *  pIWMStreamConfig2,
            IN  AM_MEDIA_TYPE *     pmt
            ) ;

        static
        HRESULT
        RecoverSBEAttributes (
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  IMediaSample *  pIMS,
            IN  double          dCurRate,
            IN  OUT DWORD *     pdwContinuityCounterNext
            ) ;

        static
        HRESULT
        SetSBEAttributes (
            IN  DWORD           dwSamplesPerSec,
            IN  IMediaSample *  pIMS,
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  DWORD *         dwContinuityCounterNext
            ) ;

        static
        HRESULT
        RecoverNewMediaType (
            IN  INSSBuffer3 *       pINSSBuffer3,
            OUT AM_MEDIA_TYPE **    ppmtNew         //  DeleteMediaType on this to free
            ) ;

        static
        HRESULT
        InlineNewMediaType (
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  AM_MEDIA_TYPE * pmtNew              //  can free this after the call
            ) ;
} ;

//  ============================================================================
//      CDVRAttribute
//  ============================================================================

class CDVRAttribute
{
    GUID            m_guidAttribute ;
    CRatchetBuffer  m_AttributeData ;
    DWORD           m_dwAttributeSize ;

    public :

        CDVRAttribute *    m_pNext ;

        CDVRAttribute (
            ) ;

        HRESULT
        SetAttributeData (
            IN  GUID    guid,
            IN  LPVOID  pvData,
            IN  DWORD   dwSize
            ) ;

        BOOL
        IsEqual (
            IN  REFGUID rguid
            ) ;

        HRESULT
        GetAttribute (
            IN      GUID    guid,
            IN OUT  LPVOID  pvData,
            IN OUT  DWORD * pdwDataLen
            ) ;

        HRESULT
        GetAttributeData (
            OUT     GUID *  pguid,
            IN OUT  LPVOID  ppvData,
            IN OUT  DWORD * pdwDataLen
            ) ;
} ;

//  ============================================================================
//      CDVRAttributeList
//  ============================================================================

class CDVRAttributeList :
    private TCDynamicProdCons <CDVRAttribute>

{
    CDVRAttribute * m_pAttribListHead ;
    LONG            m_cAttributes ;

    CDVRAttribute *
    PopListHead_ (
        ) ;

    CDVRAttribute *
    FindInList_ (
        IN  GUID    guid
        ) ;

    CDVRAttribute *
    GetIndexed_ (
        IN  LONG    lIndex
        ) ;

    void
    InsertInList_ (
        IN  CDVRAttribute *
        ) ;

    virtual
    CDVRAttribute *
    NewObj_ (
        )
    {
        return new CDVRAttribute ;
    }

    public :

        CDVRAttributeList (
            ) ;

        ~CDVRAttributeList (
            ) ;

        HRESULT
        AddAttribute (
            IN  GUID    guid,
            IN  LPVOID  pvData,
            IN  DWORD   dwSize
            ) ;

        HRESULT
        GetAttribute (
            IN      GUID    guid,
            OUT     LPVOID  pvData,
            IN OUT  DWORD * pdwDataLen
            ) ;

        HRESULT
        GetAttributeIndexed (
            IN  LONG    lIndex,
            OUT GUID *  pguidAttribute,
            OUT LPVOID  pvData,
            IN OUT      DWORD * pdwDataLen
            ) ;

        LONG GetCount ()    { return m_cAttributes ; }

        void
        Reset (
            ) ;
} ;

//  ============================================================================
//  CMediaSampleWrapper
//  ============================================================================

//  shamelessly stolen from amfilter.h & amfilter.cpp
class CMediaSampleWrapper :
    public IMediaSample2,
    public IAttributeSet,
    public IAttributeGet
{

protected:

    friend class CPooledMediaSampleWrapper ;

    virtual void Recycle_ ()    { delete this ; }

    /*  Values for dwFlags - these are used for backward compatiblity
        only now - use AM_SAMPLE_xxx
    */
    enum { Sample_SyncPoint       = 0x01,   /* Is this a sync point */
           Sample_Preroll         = 0x02,   /* Is this a preroll sample */
           Sample_Discontinuity   = 0x04,   /* Set if start of new segment */
           Sample_TypeChanged     = 0x08,   /* Has the type changed */
           Sample_TimeValid       = 0x10,   /* Set if time is valid */
           Sample_MediaTimeValid  = 0x20,   /* Is the media time valid */
           Sample_TimeDiscontinuity = 0x40, /* Time discontinuity */
           Sample_StopValid       = 0x100,  /* Stop time valid */
           Sample_ValidFlags      = 0x1FF
         };

    /* Properties, the media sample class can be a container for a format
       change in which case we take a copy of a type through the SetMediaType
       interface function and then return it when GetMediaType is called. As
       we do no internal processing on it we leave it as a pointer */

    DWORD            m_dwFlags;         /* Flags for this sample */
                                        /* Type specific flags are packed
                                           into the top word
                                        */
    DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
    LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
    LONG             m_lActual;         /* Length of data in this sample */
    LONG             m_cbBuffer;        /* Size of the buffer */
    REFERENCE_TIME   m_Start;           /* Start sample time */
    REFERENCE_TIME   m_End;             /* End sample time */
    LONGLONG         m_MediaStart;      /* Real media start position */
    LONG             m_MediaEnd;        /* A difference to get the end */
    AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */
    DWORD            m_dwStreamId;      /* Stream id */
    CDVRAttributeList   m_DVRAttributeList ;

    IUnknown *      m_pIMSCore ;

public:
    LONG             m_cRef;            /* Reference count */


public:

    CMediaSampleWrapper();

    virtual ~CMediaSampleWrapper();

    /* Note the media sample does not delegate to its owner */

    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    DECLARE_IATTRIBUTESET () ;
    DECLARE_IATTRIBUTEGET () ;

    //  ========================================================================

    DWORD   GetTypeSpecificFlags ()                 { return m_dwTypeSpecificFlags ; }
    void    SetTypeSpecificFlags (IN DWORD dw)      { m_dwTypeSpecificFlags = dw ; }

    virtual void Reset_ () ;

    HRESULT
    Init (
        IN  IUnknown *  pIMS,
        IN  BYTE *      pbPayload,
        IN  LONG        lPayloadLength
        ) ;

    //  just wording .. makes it more clear that flags etc... are not all
    //   reset
    HRESULT
    Wrap (
        IN  IUnknown *  pIMS,
        IN  BYTE *      pbPayload,
        IN  LONG        lPayloadLength
        )
    {
        return Init (pIMS, pbPayload, lPayloadLength) ;
    }

    HRESULT
    Init (
        IN  BYTE *  pbPayload,
        IN  LONG    lPayloadLength
        ) ;

    //  ========================================================================

    // set the buffer pointer and length. Used by allocators that
    // want variable sized pointers or pointers into already-read data.
    // This is only available through a CMediaSampleWrapper* not an IMediaSample*
    // and so cannot be changed by clients.
    HRESULT SetPointer(BYTE * ptr, LONG cBytes);

    // Get me a read/write pointer to this buffer's memory.
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);

    STDMETHODIMP_(LONG) GetSize(void);

    // get the stream time at which this sample should start and finish.
    STDMETHODIMP GetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );

    // Set the stream time at which this sample should start and finish.
    STDMETHODIMP SetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);

    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);

    // these allow for limited format changes in band

    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);

    // returns S_OK if there is a discontinuity in the data (this same is
    // not a continuation of the previous stream of data
    // - there has been a seek).
    STDMETHODIMP IsDiscontinuity(void);
    // set the discontinuity property - TRUE if this sample is not a
    // continuation, but a new sample after a seek.
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);

    // get the media times for this sample
    STDMETHODIMP GetMediaTime(
        LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
    );

    // Set the media times for this sample
    STDMETHODIMP SetMediaTime(
        LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
    );

    // Set and get properties (IMediaSample2)
    STDMETHODIMP GetProperties(
        DWORD cbProperties,
        BYTE * pbProperties
    );

    STDMETHODIMP SetProperties(
        DWORD cbProperties,
        const BYTE * pbProperties
    );
};

class CScratchMediaSample :
    public CMediaSampleWrapper
{
    BYTE *  m_pbAllocBuffer ;

    public :

        CScratchMediaSample (
            IN  LONG                lBufferLen,
            IN  REFERENCE_TIME *    pStartTime,
            IN  REFERENCE_TIME *    pEndTime,
            IN  DWORD               dwFlags,
            OUT HRESULT *           phr
            ) : m_pbAllocBuffer     (NULL),
                CMediaSampleWrapper ()
        {
            m_pbAllocBuffer = new BYTE [lBufferLen] ;
            if (m_pbAllocBuffer) {
                (* phr) = Init (m_pbAllocBuffer, lBufferLen) ;
                if (SUCCEEDED (* phr)) {

                    m_dwFlags = dwFlags ;

                    if (pStartTime) {
                        m_Start = (* pStartTime) ;
                        if (pEndTime) {
                            m_End = (* pEndTime) ;
                        }
                    }
                }
            }
            else {
                (* phr) = E_OUTOFMEMORY ;
            }

            return ;
        }

        ~CScratchMediaSample (
            )
        {
            delete [] m_pbAllocBuffer ;
        }
} ;

class CDVRIMediaSample :
    public CMediaSampleWrapper
{
    CDVRIMediaSamplePool *  m_pOwningPool ;
    REFERENCE_TIME *        m_prtStartRecyled ;
    QWORD                   m_cnsStreamTime ;

    protected :

        virtual void Recycle_ () ;

    public :

        CDVRIMediaSample (
            CDVRIMediaSamplePool *   pOwningPool
            ) : m_pOwningPool       (pOwningPool),
                m_prtStartRecyled   (NULL),
                CMediaSampleWrapper () {}

        REFERENCE_TIME *    GetRecycledStartTime () { return m_prtStartRecyled ; }

        virtual
        void
        Reset_ (
            )
        {
            //  before clearing everything out, were we timestamped ?
            m_prtStartRecyled = ((m_dwFlags & Sample_TimeValid) ? & m_Start : NULL) ;
            CMediaSampleWrapper::Reset_ () ;
        }
} ;

class CPooledMediaSampleWrapper :
    public CMediaSampleWrapper
{
    CMediaSampleWrapperPool *   m_pOwningPool ;

    protected :

        virtual void Recycle_ () ;

    public :

        CPooledMediaSampleWrapper (
            CMediaSampleWrapperPool *   pOwningPool
            ) : m_pOwningPool       (pOwningPool),
                CMediaSampleWrapper ()
        {
            ASSERT (m_pOwningPool) ;
        }
} ;

class CDVRIMediaSamplePool :
    public TCDynamicProdCons <CDVRIMediaSample>
{
    CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;

    protected :

        virtual
        CDVRIMediaSample *
        NewObj_ (
            )
        {
            return new CDVRIMediaSample (this) ;
        }

    public :

        CDVRIMediaSamplePool (
            CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : TCDynamicProdCons <CDVRIMediaSample> (),
                m_pDVRSendStatsWriter   (pDVRSendStatsWriter)
        {
            ASSERT (m_pDVRSendStatsWriter) ;
        }

        //  blocking
        CDVRIMediaSample *
        Get () ;

        //  non-blocking
        CDVRIMediaSample *
        TryGet () ;

        virtual
        void
        Recycle (
            IN  CDVRIMediaSample * pDVRIMediaSample
            ) ;
} ;

class CMediaSampleWrapperPool :
    public TCDynamicProdCons <CPooledMediaSampleWrapper>
{
    protected :

        virtual
        CPooledMediaSampleWrapper *
        NewObj_ (
            )
        {
            return new CPooledMediaSampleWrapper (this) ;
        }

    public :

        CMediaSampleWrapperPool (
            ) : TCDynamicProdCons <CPooledMediaSampleWrapper> () {}

        //  blocking
        CPooledMediaSampleWrapper *
        Get (
            ) ;

        //  non-blocking
        CPooledMediaSampleWrapper *
        TryGet (
            ) ;
} ;

//  ============================================================================
//      CWMINSSBuffer3Wrapper
//  ============================================================================

class CWMINSSBuffer3Wrapper :
    public INSSBuffer3
{
    CDVRAttributeList   m_AttribList ;
    IUnknown *          m_punkCore ;
    LONG                m_cRef ;
    BYTE *              m_pbBuffer ;
    DWORD               m_dwBufferLength ;
    DWORD               m_dwMaxBufferLength ;

    protected :

        virtual void Recycle_ ()    { delete this ; }

    public :

        CWMINSSBuffer3Wrapper (
            ) ;

        virtual
        ~CWMINSSBuffer3Wrapper (
            ) ;

        // IUnknown
        STDMETHODIMP QueryInterface ( REFIID riid, void **ppvObject );
        STDMETHODIMP_(ULONG) Release();
        STDMETHODIMP_(ULONG) AddRef();

        // INSSBuffer
        STDMETHODIMP GetLength( DWORD *pdwLength );
        STDMETHODIMP SetLength( DWORD dwLength );
        STDMETHODIMP GetMaxLength( DWORD * pdwLength );
        STDMETHODIMP GetBufferAndLength( BYTE ** ppdwBuffer, DWORD * pdwLength );
        STDMETHODIMP GetBuffer( BYTE ** ppdwBuffer );

        //  INSSBuffer2
        STDMETHODIMP GetSampleProperties( DWORD cbProperties, BYTE *pbProperties) ;     //  stubbed
        STDMETHODIMP SetSampleProperties( DWORD cbProperties, BYTE * pbProperties) ;    //  stubbed

        //  INSSBuffer3
        STDMETHODIMP SetProperty( GUID guidProperty, void * pvBufferProperty, DWORD dwBufferPropertySize) ;
        STDMETHODIMP GetProperty( GUID guidProperty, void * pvBufferProperty, DWORD *pdwBufferPropertySize) ;

        //  ====================================================================
        //  class methods

        HRESULT Init (IUnknown *, BYTE * pbBuffer, DWORD dwLength) ;
        void Reset_ () ;
} ;

//  ============================================================================
//  CPooledWMINSSBuffer3Wrapper
//  ============================================================================

class CPooledWMINSSBuffer3Wrapper :
    public CWMINSSBuffer3Wrapper
{
    CWMINSSBuffer3WrapperPool *    m_pOwningPool ;

    protected :

        virtual void Recycle_ () ;

    public :

        CPooledWMINSSBuffer3Wrapper (
            IN  CWMINSSBuffer3WrapperPool *  pOwningPool
            ) : m_pOwningPool           (pOwningPool),
                CWMINSSBuffer3Wrapper   ()
        {
            ASSERT (m_pOwningPool) ;
        }
} ;

//  ============================================================================
//  CWMINSSBuffer3WrapperPool
//  ============================================================================

class CWMINSSBuffer3WrapperPool :
    public TCDynamicProdCons <CPooledWMINSSBuffer3Wrapper>
{
    protected :

        virtual
        CPooledWMINSSBuffer3Wrapper *
        NewObj_ (
            )
        {
            return new CPooledWMINSSBuffer3Wrapper (this) ;
        }

    public :

        CWMINSSBuffer3WrapperPool (
            ) : TCDynamicProdCons <CPooledWMINSSBuffer3Wrapper> () {}

        CPooledWMINSSBuffer3Wrapper *
        Get (
            )
        {
            CPooledWMINSSBuffer3Wrapper * pNSSWrapper ;

            pNSSWrapper = TCDynamicProdCons <CPooledWMINSSBuffer3Wrapper>::Get () ;
            if (pNSSWrapper) {
                pNSSWrapper -> AddRef () ;
            }

            return pNSSWrapper ;
        }
} ;

//  ============================================================================
//      CWMPooledINSSBuffer3Holder
//  ============================================================================

class CWMPooledINSSBuffer3Holder :
    public INSSBuffer3
{
    INSSBuffer3 *              m_pINSSBuffer3Core ;
    LONG                       m_cRef ;
    CWMINSSBuffer3HolderPool * m_pOwningPool ;

    protected :

        virtual void Recycle_ () ;

    public :

        CWMPooledINSSBuffer3Holder (
            IN  CWMINSSBuffer3HolderPool *  pOwningPool
        ) : m_pOwningPool           (pOwningPool),
            m_pINSSBuffer3Core      (NULL),
            m_cRef                  (0)
        {
            ASSERT (m_pOwningPool) ;
        }

        virtual
        ~CWMPooledINSSBuffer3Holder (
            )
        {
            Reset_ () ;
        }

        //  IUnknown
        STDMETHODIMP QueryInterface ( REFIID riid, void **ppvObject );
        STDMETHODIMP_(ULONG) Release();
        STDMETHODIMP_(ULONG) AddRef();

        //  INSSBuffer
        STDMETHODIMP GetLength( DWORD *pdwLength )                                  { return m_pINSSBuffer3Core -> GetLength (pdwLength) ; }
        STDMETHODIMP SetLength( DWORD dwLength )                                    { return m_pINSSBuffer3Core -> SetLength (dwLength) ; }
        STDMETHODIMP GetMaxLength( DWORD * pdwLength )                              { return m_pINSSBuffer3Core -> GetMaxLength (pdwLength) ; }
        STDMETHODIMP GetBufferAndLength( BYTE ** ppdwBuffer, DWORD * pdwLength )    { return m_pINSSBuffer3Core -> GetBufferAndLength (ppdwBuffer, pdwLength) ; }
        STDMETHODIMP GetBuffer( BYTE ** ppdwBuffer )                                { return m_pINSSBuffer3Core -> GetBuffer (ppdwBuffer) ; }

        //  INSSBuffer2
        STDMETHODIMP GetSampleProperties( DWORD cbProperties, BYTE *pbProperties)   { return m_pINSSBuffer3Core -> GetSampleProperties (cbProperties, pbProperties) ; }
        STDMETHODIMP SetSampleProperties( DWORD cbProperties, BYTE * pbProperties)  { return m_pINSSBuffer3Core -> SetSampleProperties (cbProperties, pbProperties) ; }

        //  INSSBuffer3
        STDMETHODIMP SetProperty( GUID guidProperty, void * pvBufferProperty, DWORD dwBufferPropertySize)   { return m_pINSSBuffer3Core -> SetProperty (guidProperty, pvBufferProperty, dwBufferPropertySize) ; }
        STDMETHODIMP GetProperty( GUID guidProperty, void * pvBufferProperty, DWORD *pdwBufferPropertySize) { return m_pINSSBuffer3Core -> GetProperty (guidProperty, pvBufferProperty, pdwBufferPropertySize) ; }

        //  ====================================================================
        //  class methods

        HRESULT Init (INSSBuffer *) ;
        void Reset_ () ;
} ;

//  ============================================================================
//  CWMINSSBuffer3HolderPool
//  ============================================================================

class CWMINSSBuffer3HolderPool :
    public TCDynamicProdCons <CWMPooledINSSBuffer3Holder>
{
    protected :

        virtual
        CWMPooledINSSBuffer3Holder *
        NewObj_ (
            )
        {
            return new CWMPooledINSSBuffer3Holder (this) ;
        }

    public :

        CWMINSSBuffer3HolderPool (
            ) : TCDynamicProdCons <CWMPooledINSSBuffer3Holder> () {}

        CWMPooledINSSBuffer3Holder *
        Get (
            )
        {
            CWMPooledINSSBuffer3Holder * pNSSHolder ;

            pNSSHolder = TCDynamicProdCons <CWMPooledINSSBuffer3Holder>::Get () ;
            if (pNSSHolder) {
                pNSSHolder -> AddRef () ;
            }

            return pNSSHolder ;
        }
} ;

//  ============================================================================
//  ============================================================================

//  BUGBUG: for now do this based on media type
CDVRAnalysisFlags *
GetAnalysisTagger (
    IN  const AM_MEDIA_TYPE *   pmt
    ) ;

//  or the type of analysis
CDVRAnalysisFlags *
GetAnalysisTagger (
    IN  REFGUID rguidAnalysis
    ) ;

void
RecycleAnalysisTagger (
    IN  CDVRAnalysisFlags *
    ) ;

//  ----------------------------------------------

class CDVRAnalysisFlags
{
    protected :

        HRESULT
        TransferCoreMSSettings_ (
            IN  IMediaSample *          pIMSReceived,
            IN  CMediaSampleWrapper *   pMSWrapper
            ) ;

        HRESULT
        TransferAttributes_ (
            IN  IMediaSample *          pIMSReceived,
            IN  CMediaSampleWrapper *   pMSWrapper
            ) ;

        HRESULT
        TransferSettingsAndAttributes_ (
            IN  IMediaSample *          pIMSReceived,
            IN  CMediaSampleWrapper *   pMSWrapper
            )
        {
            HRESULT hr ;

            hr = TransferCoreMSSettings_ (pIMSReceived, pMSWrapper) ;
            if (SUCCEEDED (hr)) {
                hr = TransferAttributes_ (pIMSReceived, pMSWrapper) ;
            }

            return hr ;
        }

        //  want media-specific only
        CDVRAnalysisFlags (
            ) {}

    public :

        virtual
        ~CDVRAnalysisFlags (
            ) {}

        //  called for the first wrapping media sample i.e. pIMSReceived
        //    offset 0
        virtual
        HRESULT
        Transfer (
            IN  IMediaSample *          pIMSReceived,
            IN  CMediaSampleWrapper *   pMSWrapper
            ) = 0;

        virtual
        HRESULT
        Mark (
            IN  CMediaSampleWrapper *   pMSWrapper,
            IN  GUID *                  pguidAttribute,
            IN  BYTE *                  pbAttributeData,
            IN  DWORD                   dwAttributeDataLen
            ) = 0 ;
} ;

class CDVRMpeg2VideoAnalysisFlags :
    public CDVRAnalysisFlags
{
    BOOL            m_fCachedStartValid ;
    REFERENCE_TIME  m_rtCachedStart ;
    BOOL            m_fCachedStopValid ;
    REFERENCE_TIME  m_rtCachedStop ;

    public :

        CDVRMpeg2VideoAnalysisFlags (
            ) : CDVRAnalysisFlags   (),
                m_fCachedStartValid (FALSE),
                m_fCachedStopValid  (FALSE) {}

        virtual
        HRESULT
        Transfer (
            IN  IMediaSample *          pIMSReceived,
            IN  CMediaSampleWrapper *   pMSWrapper
            ) ;

        virtual
        HRESULT
        Mark (
            IN  CMediaSampleWrapper *   pMSWrapper,
            IN  GUID *                  pguidAttribute,
            IN  BYTE *                  pbAttributeData,
            IN  DWORD                   dwAttributeDataLen
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRAttributeTranslator
{
    //  this is the pin ID
    int             m_iFlowId ;
    CDVRPolicy *    m_pPolicy ;

    protected :

        CRatchetBuffer  m_RatchetBuffer ;

        CDVRPolicy *    Policy_ ()  { return m_pPolicy ; }

        CDVRAttributeTranslator (
            IN  CDVRPolicy *    pPolicy,
            IN  int             iFlowId
            ) ;

        CDVRAttributeTranslator () ;

    public :

        ~CDVRAttributeTranslator (
            ) ;
} ;

//  ============================================================================
//  ============================================================================

//  dshow -> WMSDK
class CDVRDShowToWMSDKTranslator :
    public CDVRAttributeTranslator
{
    //  we have 1 attribute translator per stream (per pin), so we maintain 1
    //   continuity counter per stream; this allows us to discover
    //   discontinuities on a per-stream basis vs. global
    DWORD           m_dwContinuityCounterNext ;

    BOOL            m_fInlineDShowProps ;

    CRatchetBuffer  m_Scratch ;

    protected :

        DWORD   m_dwGlobalAnalysisFlags ;

        HRESULT
        InlineProperties_ (
            IN      DWORD,
            IN      IMediaSample *,
            IN OUT  INSSBuffer3 *
            ) ;

        HRESULT
        SetEncryptionAttribute_ (
            IN  IMediaSample *  pIMS,
            IN  INSSBuffer3 *   pINSSBuffer3
            ) ;

    public :

        CDVRDShowToWMSDKTranslator (
            IN  CDVRPolicy *    pPolicy,
            IN  int             iFlowId
            ) ;

        virtual
        HRESULT
        SetAttributesWMSDK (
            IN  CDVRReceiveStatsWriter *    pRecvStatsWriter,
            IN  DWORD                       dwSamplesPerSec,
            IN  IReferenceClock *           pRefClock,
            IN  IMediaSample *              pIMS,
            OUT INSSBuffer3 *               pINSSBuffer3,
            OUT DWORD *                     pdwWMSDKFlags
            ) ;

        void SetInlineProps (BOOL f)        { m_fInlineDShowProps = f ; }
        void SetAnalysisPresent (BOOL f)    { DVR_ANALYSIS_GLOBAL_PRESENT (m_dwGlobalAnalysisFlags, f) ; }

        virtual
        BOOL
        IsCleanPoint(
            IN IMediaSample * pIMS
            ) {
            return  pIMS->IsSyncPoint () == S_OK;
        }
} ;

//  ============================================================================
//  ============================================================================

//  WMSDK -> dshow
class CDVRWMSDKToDShowTranslator :
    public CDVRAttributeTranslator
{
    //  we have 1 attribute translator per stream (per pin), so we maintain 1
    //   continuity counter per stream; this allows us to discover
    //   discontinuities on a per-stream basis vs. global
    DWORD           m_dwContinuityCounterNext ;

    BOOL            m_fInlineDShowProps ;

    CRatchetBuffer  m_Scratch ;

    protected :

        HRESULT
        RecoverInlineProperties_ (
            IN      double,
            IN      INSSBuffer *,
            IN OUT  IMediaSample *,
            OUT     AM_MEDIA_TYPE **                    //  dyn format change
            ) ;

        void
        TransferEncryptionAttribute_ (
            IN      INSSBuffer3 *,
            IN OUT  IMediaSample *
            ) ;

    public :

        CDVRWMSDKToDShowTranslator (
            IN  CDVRPolicy *    pPolicy,
            IN  int             iFlowId
            ) ;

        ~CDVRWMSDKToDShowTranslator (
            ) ;

        virtual
        HRESULT
        SetAttributesDShow (
            IN      CDVRSendStatsWriter *   pSendStatsWriter,
            IN      INSSBuffer *            pINSSBuffer,
            IN      QWORD                   cnsStreamTimeOfSample,
            IN      QWORD                   cnsSampleDuration,
            IN      DWORD                   dwFlags,
            IN      double                  dCurRate,
            OUT     DWORD *                 pdwSamplesPerSec,
            IN OUT  IMediaSample *          pIMS,
            OUT     AM_MEDIA_TYPE **        ppmtNew                 //  dyn format change
            ) ;

} ;

//  ============================================================================
//  ============================================================================

class CDVRWMSDKToDShowMpeg2Translator :
    public CDVRWMSDKToDShowTranslator
{
    HRESULT
    FlagAnalysisPresent_ (
        IN      INSSBuffer3 *   pINSSBuffer3,
        IN      IAttributeSet * pDVRAttribSet,
        IN OUT  BOOL *          pfAnalysisPresent
        ) ;

    HRESULT
    FlagMpeg2VideoAnalysis_ (
        IN      INSSBuffer3 *   pINSSBuffer3,
        IN      IAttributeSet * pDVRAttribSet
        ) ;

    HRESULT
    RecoverInlineAnalysisData_ (
        IN      CDVRSendStatsWriter *   pSendStatsWriter,
        IN      INSSBuffer *            pINSSBuffer,
        IN OUT  IMediaSample *          pIMS
        ) ;

    public :

        CDVRWMSDKToDShowMpeg2Translator (
            IN  CDVRPolicy *    pPolicy,
            IN  int             iFlowId
            ) : CDVRWMSDKToDShowTranslator (pPolicy, iFlowId) {}

        virtual
        HRESULT
        SetAttributesDShow (
            IN      CDVRSendStatsWriter *   pSendStatsWriter,
            IN      INSSBuffer *            pINSSBuffer,
            IN      QWORD                   cnsStreamTimeOfSample,
            IN      QWORD                   cnsSampleDuration,
            IN      DWORD                   dwFlags,
            IN      double                  dCurRate,
            OUT     DWORD *                 pdwSamplesPerSec,
            IN OUT  IMediaSample *          pIMS,
            OUT     AM_MEDIA_TYPE **        ppmtNew                 //  dyn format change
            ) ;

} ;

//  ============================================================================
//  ============================================================================

class CDVRDShowToWMSDKMpeg2Translator :
    public CDVRDShowToWMSDKTranslator
{
    CDVRMpeg2VideoAnalysisFlags m_Mpeg2AnalysisReader ;

    HRESULT
    InlineAnalysisData_ (
        IN      CDVRReceiveStatsWriter *    pRecvStatsWriter,
        IN      IReferenceClock *           pRefClock,
        IN      IMediaSample *              pIMS,
        IN OUT  DWORD *                     pdwWMSDKFlags,
        OUT     INSSBuffer3 *               pINSSBuffer3
        ) ;

    HRESULT
    InlineMpeg2Attributes_ (
        IN  INSSBuffer3 *   pINSSBuffer3,
        IN  IMediaSample *  pIMS
        ) ;

    public :

        CDVRDShowToWMSDKMpeg2Translator (
            IN  CDVRPolicy *        pPolicy,
            IN  int                 iFlowId
            ) : CDVRDShowToWMSDKTranslator  (pPolicy, iFlowId)
        {
        }

        virtual
        HRESULT
        SetAttributesWMSDK (
            IN  CDVRReceiveStatsWriter *    pRecvStatsWriter,
            IN  DWORD                       dwSamplesPerSec,
            IN  IReferenceClock *           pRefClock,
            IN  IMediaSample *              pIMS,
            OUT INSSBuffer3 *               pINSSBuffer3,
            OUT DWORD *                     pdwWMSDKFlags
            ) ;

        virtual
        BOOL
        IsCleanPoint(
            IN IMediaSample * pIMS
            ) {
            return TRUE;  // Specical case for MPEG2
        }
} ;

//  ============================================================================
//  ============================================================================

template <class T>
class CTRateSegment
{
    //
    //  Given a starting PTS and a rate, this object will scale PTSs that
    //    are >= the starting PTS according to the rate.
    //
    //  The formula used to compute a scaled timestamp is the usual x-y
    //    graph with slope, where x is the input timestamp, and y is the
    //    output timestamp.  The formula is based on y(i) = m * (x(i) -
    //    x(i-1)).  In this case, m = 1/rate.  Also, since the slope does
    //    change in a segment, we compute x(i-1) once, when the rate is
    //    set.  Thus, the formula becomes
    //
    //      PTS(out) = (1/rate) * (PTS(in) - PTS(base))
    //
    //    where PTS(base) is computed as
    //
    //      PTS(base) = PTS(start) - (rate(new)/rate(last)) * (PTS(start) -
    //                      PTS(start_last)
    //
    //  Rates cannot be 0, and must fall in the <= -0.1 && >= 0.1; note that
    //      TRICK_PLAY_LOWEST_RATE = 0.1
    //

    LIST_ENTRY          m_ListEntry ;
    T                   m_tPTS_start ;      //  earliest PTS for this segment
    T                   m_tPTS_base ;       //  computed; base PTS for this segment
    double              m_dRate ;           //  0.5 = half speed; 2 = twice speed
    double              m_dSlope ;          //  computed; = 1/rate
    T                   m_tNextSegStart ;   //  use this value to determine if segment
                                    //    applies
    public :

        CTRateSegment (
            IN  T       tPTS_start,
            IN  double  dRate,
            IN  T       tPTS_start_last = 0,
            IN  double  dRate_last      = 1
            ) : m_tNextSegStart (0)
        {
            InitializeListHead (& m_ListEntry) ;
            Initialize (tPTS_start, dRate, tPTS_start_last, dRate_last) ;
        }

        T       Start ()        { return m_tPTS_start ; }
        T       Base ()         { return m_tPTS_base ; }
        double  Rate ()         { return m_dRate ; }
        T       NextSegStart () { return m_tNextSegStart ; }

        void SetNextSegStart (IN T tNextStart)  { m_tNextSegStart = tNextStart ; }

        void
        Initialize (
            IN  T       tPTS_start,
            IN  double  dRate,
            IN  T       tPTS_base_last  = 0,
            IN  double  dRate_last      = 1,
            IN  T       tNextSegStart   = 0
            )
        {
            ASSERT (::Abs <double> (dRate) >= TRICK_PLAY_LOWEST_RATE) ;

            m_dRate         = dRate ;
            m_tPTS_start    = tPTS_start ;

            SetNextSegStart (tNextSegStart) ;

            //  compute the base
            ASSERT (dRate_last != 0) ;
            m_tPTS_base = tPTS_start - (T) ((dRate / dRate_last) *
                                        (double) (tPTS_start - tPTS_base_last)) ;

            //  compute the slope
            ASSERT (dRate != 0) ;
            m_dSlope = 1 / dRate ;
        }

        void
        Scale (
            IN OUT  T * ptPTS
            )
        {
            ASSERT (ptPTS) ;
            ASSERT ((* ptPTS) >= m_tPTS_start) ;

            (* ptPTS) = (T) (m_dSlope * (double) ((* ptPTS) - m_tPTS_base)) ;
        }

        LIST_ENTRY *
        ListEntry (
            )
        {
            return (& m_ListEntry) ;
        }

        //  ================================================================

        static
        CTRateSegment *
        RecoverSegment (
            IN  LIST_ENTRY *    pListEntry
            )
        {
            CTRateSegment * pRateSegment ;

            pRateSegment = CONTAINING_RECORD (pListEntry, CTRateSegment, m_ListEntry) ;
            return pRateSegment ;
        }
} ;

//  ============================================================================
//  ============================================================================

template <class T>
class CTTimestampRate
{
    //
    //  This class hosts a list of CTRateSegments.  It does not police to make
    //    sure old segments are inserted after timestamps have been scaled out
    //    of following segments.
    //

    LIST_ENTRY          m_SegmentList ;     //  CTRateSegment list list head
    CTRateSegment <T> * m_pCurSegment ;     //  current segment; cache this
                                            //    because we'll hit this one 99%
                                            //    of the time
    T                   m_tPurgeThreshold ; //  PTS-current_seg threshold beyond
                                            //    which we purge stale segments
    int                 m_iCurSegments ;
    int                 m_iMaxSegments ;    //  we'll never queue more than this
                                            //    number; this prevents non-timestamped
                                            //    streams from having infinite
                                            //    segments that we'd never know
                                            //    to delete

    CRITICAL_SECTION    m_crt ;             //  we serialize the list, regardless

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    //  get a new segment; allocate for now
    CTRateSegment <T> *
    NewSegment_ (
        IN  T       tPTS_start,
        IN  double  dRate,
        IN  T       tPTS_start_last = 0,
        IN  double  dRate_last      = 1
        )
    {
        return new CTRateSegment <T> (tPTS_start, dRate, tPTS_start_last, dRate_last) ;
    }

    //  recycle; delete for now
    void
    Recycle_ (
        IN  CTRateSegment <T> * pRateSegment
        )
    {
        delete pRateSegment ;
    }

    //  purges the passed list of all CTRateSegment objects
    void
    Purge_ (
        IN  LIST_ENTRY *    pListEntryHead
        )
    {
        CTRateSegment <T> * pRateSegment ;

        while (!IsListEmpty (pListEntryHead)) {
            //  pop & recycle first in the list
            pRateSegment = CTRateSegment <T>::RecoverSegment (pListEntryHead -> Flink) ;
            Pop_ (pRateSegment -> ListEntry ()) ;
            Recycle_ (pRateSegment) ;
        }
    }

    //  pops & fixes up the next/prev pointers
    void
    Pop_ (
        IN  LIST_ENTRY *    pListEntry
        )
    {
        RemoveEntryList (pListEntry) ;
        InitializeListHead (pListEntry) ;

        ASSERT (m_iCurSegments > 0) ;
        m_iCurSegments-- ;
    }

    //  following a mid-list insertion, we must fixup following segments' base
    //    pts, at the very least
    void
    ReinitFollowingSegments_ (
        )
    {
        CTRateSegment <T> * pCurSegment ;
        CTRateSegment <T> * pPrevSegment ;

        ASSERT (m_pCurSegment) ;
        pPrevSegment = m_pCurSegment ;

        while (pPrevSegment -> ListEntry () -> Flink != & m_SegmentList) {
            pCurSegment = CTRateSegment <T>::RecoverSegment (pPrevSegment -> ListEntry () -> Flink) ;

            pCurSegment -> Initialize (
                pCurSegment -> Start (),
                pCurSegment -> Rate (),
                pPrevSegment -> Base (),
                pPrevSegment -> Rate ()
                ) ;

            pPrevSegment -> SetNextSegStart (pCurSegment -> Start ()) ;

            pPrevSegment = pCurSegment ;
        }
    }

    void
    TrimToMaxSegments_ (
        )
    {
        CTRateSegment <T> * pTailSegment ;
        LIST_ENTRY *        pTailListEntry ;

        ASSERT (m_iCurSegments >= 0) ;

        while (m_iCurSegments > m_iMaxSegments) {
            //  trim from the tail
            pTailListEntry = m_SegmentList.Blink ;
            pTailSegment = CTRateSegment <T>::RecoverSegment (pTailListEntry) ;

            Pop_ (pTailSegment -> ListEntry ()) ;
            ASSERT (m_iCurSegments == m_iMaxSegments) ;

            TRACE_1 (LOG_AREA_SEEKING_AND_TRICK, 1,
                TEXT ("CTTimestampRate::TrimToMaxSegments_ () : %08xh"),
                pTailSegment) ;

            Recycle_ (pTailSegment) ;
        }
    }

    //  new segment is inserted into list, sorted by start PTS
    DWORD
    InsertNewSegment_ (
        IN  T       tPTS_start,
        IN  double  dRate
        )
    {
        CTRateSegment <T> * pNewSegment ;
        CTRateSegment <T> * pPrevSegment ;
        LIST_ENTRY *        pPrevListEntry ;
        DWORD               dw ;
        T                   tBase_prev ;
        double              dRate_prev ;

        //  assume this one will go to the head of the active list; move
        //    all others to the tail

        pNewSegment = NewSegment_ (tPTS_start, dRate) ;
        if (pNewSegment) {

            tBase_prev = 0 ;
            dRate_prev = 1 ;

            //  back down the list, from the end
            for (pPrevListEntry = m_SegmentList.Blink ;
                 pPrevListEntry != & m_SegmentList ;
                 pPrevListEntry = pPrevListEntry -> Blink
                 ) {

                pPrevSegment = CTRateSegment <T>::RecoverSegment (pPrevListEntry) ;

                //  if we have a dup, remove it (we'll never have > 1 duplicate)
                if (pPrevSegment -> Start () == tPTS_start) {

                    pPrevListEntry = pPrevListEntry -> Flink ;  //  go forwards again
                    Pop_ (pPrevListEntry -> Blink) ;            //  remove previous
                    Recycle_ (pPrevSegment) ;                   //  recycle

                    //
                    //  next one should be it
                    //

                    continue ;
                }

                //  check for right position in ordering
                if (pPrevSegment -> Start () < tPTS_start) {
                    //  found it

                    tBase_prev = pPrevSegment -> Base () ;
                    dRate_prev = pPrevSegment -> Rate () ;

                    //  fixup previous' next start field
                    pPrevSegment -> SetNextSegStart (tPTS_start) ;

                    break ;
                }
            }

            //  initialize wrt to previous
            pNewSegment -> Initialize (
                tPTS_start,
                dRate,
                tBase_prev,
                dRate_prev
                ) ;

            //  insert
            InsertHeadList (
                pPrevListEntry,
                pNewSegment -> ListEntry ()
                ) ;

            //  one more segment inserted
            m_iCurSegments++ ;

            TRACE_4 (LOG_AREA_SEEKING_AND_TRICK, 1,
                TEXT ("CTTimestampRate::InsertNewSegment_ () : new segment queued; %I64d ms, %2.1f; segments = %d; %08xh"),
                ::DShowTimeToMilliseconds (tPTS_start), dRate, m_iCurSegments, pNewSegment) ;

            //  set the current segment (assume locality)
            m_pCurSegment = pNewSegment ;

            //
            //  fixup the remainder of the segments in the list
            //

            ReinitFollowingSegments_ () ;

            //  trim a segment if we must
            TrimToMaxSegments_ () ;

            dw = NOERROR ;
        }
        else {
            dw = ERROR_NOT_ENOUGH_MEMORY ;
        }

        return dw ;
    }

    BOOL
    IsInSegment_ (
        IN  T                   tPTS,
        IN  CTRateSegment <T> * pSegment
        )
    {
        BOOL    r ;

        if (pSegment -> Start () <= tPTS &&
            (pSegment -> NextSegStart () == 0 || pSegment -> NextSegStart () > tPTS)) {

            r = TRUE ;
        }
        else {
            r = FALSE ;
        }

        return r ;
    }

    void
    PurgeStaleSegments_ (
        IN  T                   tPTS,
        IN  CTRateSegment <T> * pEffectiveSegment
        )
    {
        CTRateSegment <T> * pCurSegment ;
        LIST_ENTRY *        pCurListEntry ;

        //  on the whole, we expect PTSs to monotonically increase; this means
        //    that they may drift just a bit frame-frame as in the case with
        //    mpeg-2 video, but overall they will increase; we therefore compare
        //    to our threshold and if we have segments that end earlier than
        //    the oldest PTS we expect to see, we purge it

        ASSERT (pEffectiveSegment) ;
        ASSERT (pEffectiveSegment -> Start () <= tPTS) ;

        //  if we have stale segments, and we're above the threshold into
        //    effective (current) segment, purge all stale segments
        if (pEffectiveSegment -> ListEntry () -> Blink != & m_SegmentList &&
            tPTS - pEffectiveSegment -> Start () >= m_tPurgeThreshold) {

            //  back down from the previous segment and purge the list
            for (pCurListEntry = pEffectiveSegment -> ListEntry () -> Blink;
                 pCurListEntry != & m_SegmentList ;
                 ) {

                //  recover the segment
                pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;

                //  back down to previous
                pCurListEntry = pCurListEntry -> Blink ;

                ASSERT (pCurListEntry -> Flink == pCurSegment -> ListEntry ()) ;

                TRACE_3 (LOG_AREA_SEEKING_AND_TRICK, 1,
                    TEXT ("CTTimestampRate::PurgeStaleSegments_ () : %08xh, PTS = %I64d ms, segstart = %I64d ms"),
                    pCurSegment, ::DShowTimeToMilliseconds (tPTS), ::DShowTimeToMilliseconds (pCurSegment -> Start ())) ;

                //  now pop and recycle
                Pop_ (pCurSegment -> ListEntry ()) ;
                Recycle_ (pCurSegment) ;
            }

            //  should have purged all segments that preceded the effective segmetn
            ASSERT (pEffectiveSegment -> ListEntry () -> Blink == & m_SegmentList) ;
        }

        return ;
    }

    //  returns the right segment for the PTS, if there is one; returns NULL
    //    if there is none; resets m_pCurSegment if it must (if current
    //    m_pCurSegment is stale)
    CTRateSegment <T> *
    GetSegment_ (
        IN  T   tPTS
        )
    {
        CTRateSegment <T> * pRetSegment ;
        CTRateSegment <T> * pCurSegment ;
        LIST_ENTRY *        pCurListEntry ;

        //  make sure it's within bounds
        ASSERT (m_pCurSegment) ;
        if (IsInSegment_ (tPTS, m_pCurSegment)) {
            //  99.9% code path
            pRetSegment = m_pCurSegment ;
        }
        else {
            //  need to hunt down the right segment

            //  init retval for failure
            pRetSegment = NULL ;

            //  hunt forward or backward from m_pCurSegment ?
            if (m_pCurSegment -> Start () < tPTS) {

                //  forward

                ASSERT (m_pCurSegment -> NextSegStart () != 0) ;
                ASSERT (m_pCurSegment -> NextSegStart () <= tPTS) ;

                for (pCurListEntry = m_pCurSegment -> ListEntry () -> Flink ;
                     pCurListEntry != & m_SegmentList ;
                     pCurListEntry = pCurListEntry -> Flink) {

                    pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;

                    if (IsInSegment_ (tPTS, pCurSegment)) {
                        //  found it; reset m_pCurSegment and return it
                        m_pCurSegment = pCurSegment ;
                        pRetSegment = m_pCurSegment ;

                        break ;
                    }
                }
            }
            else {
                //  backward
                ASSERT (m_pCurSegment -> Start () > tPTS) ;

                for (pCurListEntry = m_pCurSegment -> ListEntry () -> Blink ;
                     pCurListEntry != & m_SegmentList ;
                     pCurListEntry = pCurListEntry -> Blink) {

                    pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;

                    if (IsInSegment_ (tPTS, pCurSegment)) {
                        //  found it; reset m_pCurSegment and return it
                        m_pCurSegment = pCurSegment ;
                        pRetSegment = m_pCurSegment ;

                        break ;
                    }
                }
            }
        }

        if (pRetSegment) {
            PurgeStaleSegments_ (tPTS, pRetSegment) ;
        }

        return pRetSegment ;
    }

    public :

        CTTimestampRate (
            IN  T tPurgeThreshold,      //  purge stale segments when we get a PTS
                                        //    that is further into the current
                                        //    segment than this
            IN  int iMaxSegments = LONG_MAX
            ) : m_pCurSegment       (NULL),
                m_tPurgeThreshold   (tPurgeThreshold),
                m_iMaxSegments      (iMaxSegments),
                m_iCurSegments      (0)
        {
            InitializeCriticalSection (& m_crt) ;
            InitializeListHead (& m_SegmentList) ;
        }

        ~CTTimestampRate (
            )
        {
            Clear () ;
            DeleteCriticalSection (& m_crt) ;
        }

        void
        Clear (
            )
        {
            Lock_ () ;

            Purge_ (& m_SegmentList) ;
            ASSERT (IsListEmpty (& m_SegmentList)) ;

            m_pCurSegment = NULL ;

            Unlock_ () ;
        }

        DWORD
        NewSegment (
            IN  T       tPTS_start,
            IN  double  dRate
            )
        {
            DWORD   dw ;

            Lock_ () ;

            dw = InsertNewSegment_ (tPTS_start, dRate) ;

            Unlock_ () ;

            return dw ;
        }

        DWORD
        ScalePTS (
            IN  OUT T * ptPTS
            )
        {
            DWORD               dw ;
            CTRateSegment <T> * pSegment ;

            Lock_ () ;

            //  don't proceed if we've got nothing queued
            if (m_pCurSegment) {
                pSegment = GetSegment_ (* ptPTS) ;
                if (pSegment) {
                    ASSERT (IsInSegment_ ((* ptPTS), pSegment)) ;
                    pSegment -> Scale (ptPTS) ;
                    dw = NOERROR ;
                }
                else {
                    //  earlier than earliest segment
                    dw = ERROR_GEN_FAILURE ;
                }
            }
            else {
                //  leave intact; don't fail the call
                dw = NOERROR ;
            }

            Unlock_ () ;

            return dw ;
        }

#if 0
        void
        Dump (
            )
        {
            CTRateSegment <T> * pCurSegment ;
            LIST_ENTRY *        pCurListEntry ;

            Lock_ () ;

            printf ("==================================\n") ;
            for (pCurListEntry = m_SegmentList.Flink;
                 pCurListEntry != & m_SegmentList;
                 pCurListEntry = pCurListEntry -> Flink
                 ) {

                pCurSegment = CTRateSegment <T>::RecoverSegment (pCurListEntry) ;
                printf ("start = %-5d; rate = %-2.1f; base = %-5d; next = %-5d\n",
                    pCurSegment -> Start (),
                    pCurSegment -> Rate (),
                    pCurSegment -> Base (),
                    pCurSegment -> NextSegStart ()
                    ) ;
            }

            Unlock_ () ;
        }
#endif
} ;

class CTimelines
{
    REFERENCE_TIME  m_rtRuntime ;
    REFERENCE_TIME  m_rtPlaytime ;
    REFERENCE_TIME  m_rtStreamtime ;

    public :

        CTimelines (
            )
        {
            Reset () ;
        }

        void
        Reset (
            )
        {
            m_rtRuntime         = UNDEFINED ;
            m_rtPlaytime        = UNDEFINED ;
            m_rtStreamtime      = UNDEFINED ;
        }

        REFERENCE_TIME  get_Runtime ()                          { return m_rtRuntime ; }
        void            put_Runtime (IN REFERENCE_TIME rt)      { m_rtRuntime = rt ; }

        REFERENCE_TIME  get_Playtime ()                         { return m_rtPlaytime ; }
        void            put_Playtime (IN REFERENCE_TIME rt)     { m_rtPlaytime = rt ; }

        REFERENCE_TIME  get_RateStart_PTS () ;
        REFERENCE_TIME  get_RateStart_Runtime () ;

        REFERENCE_TIME  get_Streamtime ()                       { return m_rtStreamtime ; }
        void            put_Streamtime (IN REFERENCE_TIME rt)   { m_rtStreamtime = rt ; }
} ;

//  ============================================================================
//  ============================================================================

//  CAMThread has m_dwParam & m_dwReturnVal private, so derived classes cannot
//   access them, so we copy/paste CAMThread just so we can do this ..

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CDVRThread {

    // make copy constructor and assignment operator inaccessible

    CDVRThread(const CDVRThread &refThread);
    CDVRThread &operator=(const CDVRThread &refThread);

//  only diff from CAMThread is protected: was moved up just a bit
protected:

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CDVRThread();
    virtual ~CDVRThread();

    CCritSec m_AccessLock;  // locks access by client threads
    CCritSec m_WorkerLock;  // locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};

//  ============================================================================
//  ============================================================================

class CSBERecAttribute
{
    STREAMBUFFER_ATTR_DATATYPE  m_DataType ;
    BYTE *                      m_pbAttribute ;
    WORD                        m_cbAttribute ;
    LPWSTR                      m_pszName ;
    DWORD                       m_dwNameLengthBytes ;

    public :

        CSBERecAttribute (
            IN  LPCWSTR                     pszName,
            IN  STREAMBUFFER_ATTR_DATATYPE  DataType,
            IN  BYTE *                      pbAttribute,
            IN  WORD                        cbAttribute,
            OUT DWORD *                     pdwRet
            ) : m_pszName           (NULL),
                m_pbAttribute       (NULL),
                m_cbAttribute       (cbAttribute),
                m_DataType          (DataType),
                m_dwNameLengthBytes (0)
        {
            ASSERT (pszName) ;
            m_pszName = new WCHAR [wcslen (pszName) + 1] ;

            if (m_cbAttribute > 0) {
                m_pbAttribute = new BYTE [m_cbAttribute] ;
            }

            if (!m_pszName ||
                (cbAttribute > 0 && !m_pbAttribute)) {

                (* pdwRet) = ERROR_NOT_ENOUGH_MEMORY ;
                goto cleanup ;
            }

            m_dwNameLengthBytes = (::wcslen (pszName) + 1) * sizeof WCHAR ;

            ::CopyMemory (
                m_pszName,
                pszName,
                m_dwNameLengthBytes
                ) ;

            ::CopyMemory (
                m_pbAttribute,
                pbAttribute,
                m_cbAttribute
                ) ;

            //  success
            (* pdwRet) = NOERROR ;

            cleanup :

            return ;
        }

        ~CSBERecAttribute (
            )
        {
            delete [] m_pszName ;
            delete [] m_pbAttribute ;
        }

        LPWSTR                      Name ()         { return m_pszName ; }
        STREAMBUFFER_ATTR_DATATYPE  DataType ()     { return m_DataType ; }
        BYTE *                      Attribute ()    { return m_pbAttribute ; }
        WORD                        Length ()       { return m_cbAttribute ; }
        DWORD                       NameLenBytes () { return m_dwNameLengthBytes ; }    //  includes NULL-terminator
} ;

//  ============================================================================
//  ============================================================================

class CSBERecordingAttributes
{
    public :

        virtual
        ~CSBERecordingAttributes (
            ) {}

        virtual
        HRESULT
        Flush (
            ) { return S_OK ; }

        virtual
        void
        Lock (
            ) {}

        virtual
        HRESULT
        Load (
            ) { return S_OK ; }

        /*++
            SetAttribute ()

            1. sets an attribute on a recording object;
            2. fails if the IDVRRecordControl::Start has already been successfully
                called;
            3. if an attribute of the same name already exists, overwrites the old
        --*/
        virtual
        HRESULT
        SetAttribute (
            IN  WORD                        wReserved,              //  0
            IN  LPCWSTR                     pszAttributeName,       //  name
            IN  STREAMBUFFER_ATTR_DATATYPE  SBEAttributeType,       //  type
            IN  BYTE *                      pbAttribute,            //  blob
            IN  WORD                        cbAttributeLength       //  blob length
            ) = 0 ;

        virtual
        HRESULT
        GetAttributeCount (
            IN  WORD    wReserved,      //  0
            OUT WORD *  pcAttributes    //  count
            ) = 0 ;

        /*++
            GetAttributeByName ()

            1. given a name, returns the attribute data
            2. if the provided buffer is too small, returns VFW_E_BUFFER_OVERFLOW,
                and (* pcbLength) contains the minimum required length of the buffer
            3. to learn the length of the attribute, pass in non-NULL pcbLength,
                and NULL pbAttribute parameter; OUT value will be the length of
                the attribute
        --*/
        virtual
        HRESULT
        GetAttributeByName (
            IN      LPCWSTR                         pszAttributeName,   //  name
            IN      WORD *                          pwReserved,         //  0
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) = 0 ;

        /*++
            GetAttributeByIndex ()

            1. given an 0-based index, returns the attribute name and data
            2. if either buffer is too small, returns VFW_E_BUFFER_OVERFLOW, and
                (* pcbLength) and (* pcchNameLength) contain the minimum required
                length of each buffer
            3. the length returned by pcchNameLength includes the null-terminator
            4. to learn the length of the name & attribute, pass in non-NULL
                pcchNameLength & pcbLength, and NULL pszAttributeName & pbAttribute
                parameters; OUT value of the non-NULL parameters will be the
                lengths of the name and attribute
        --*/
        virtual
        HRESULT
        GetAttributeByIndex (
            IN      WORD                            wIndex,
            IN      WORD *                          pwReserved,
            OUT     WCHAR *                         pszAttributeName,
            IN OUT  WORD *                          pcchNameLength,         //  includes NULL-terminator; in BYTES
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) = 0 ;
} ;

class CSBERecordingAttributesWM :
    public CSBERecordingAttributes
{
    IWMHeaderInfo * m_pIWMHeaderInfo ;

    public :

        CSBERecordingAttributesWM (
            IN  IWMHeaderInfo * pIWMHeaderInfo
            ) : m_pIWMHeaderInfo    (pIWMHeaderInfo)
        {
            ASSERT (m_pIWMHeaderInfo) ;
            m_pIWMHeaderInfo -> AddRef () ;
        }

        virtual
        ~CSBERecordingAttributesWM (
            )
        {
            m_pIWMHeaderInfo -> Release () ;
        }

        virtual
        HRESULT
        SetAttribute (
            IN  WORD                        wReserved,              //  0
            IN  LPCWSTR                     pszAttributeName,       //  name
            IN  STREAMBUFFER_ATTR_DATATYPE  SBEAttributeType,       //  type
            IN  BYTE *                      pbAttribute,            //  blob
            IN  WORD                        cbAttributeLength       //  blob length
            )
        {
            return m_pIWMHeaderInfo -> SetAttribute (
                        wReserved,
                        pszAttributeName,
                        (WMT_ATTR_DATATYPE) SBEAttributeType,
                        pbAttribute,
                        cbAttributeLength
                        ) ;
        }

        virtual
        HRESULT
        GetAttributeCount (
            IN  WORD    wReserved,      //  0
            OUT WORD *  pcAttributes    //  count
            )
        {
            return m_pIWMHeaderInfo -> GetAttributeCount (
                        wReserved,
                        pcAttributes
                        ) ;
        }

        virtual
        HRESULT
        GetAttributeByName (
            IN      LPCWSTR                         pszAttributeName,   //  name
            IN      WORD *                          pwReserved,         //  0
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            )
        {
            return m_pIWMHeaderInfo -> GetAttributeByName (
                        pwReserved,
                        pszAttributeName,
                        (WMT_ATTR_DATATYPE *) pSBEAttributeType,
                        pbAttribute,
                        pcbLength
                        ) ;
        }

        virtual
        HRESULT
        GetAttributeByIndex (
            IN      WORD                            wIndex,
            IN      WORD *                          pwReserved,
            OUT     WCHAR *                         pszAttributeName,
            IN OUT  WORD *                          pcchNameLength,         //  includes NULL-terminator; in BYTES
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            )
        {
            return m_pIWMHeaderInfo -> GetAttributeByIndex (
                        wIndex,
                        pwReserved,
                        pszAttributeName,
                        pcchNameLength,
                        (WMT_ATTR_DATATYPE *) pSBEAttributeType,
                        pbAttribute,
                        pcbLength
                        ) ;
        }
} ;

class CSBERecordingAttributesFile :
    public CSBERecordingAttributes
{

#define PVR_ATTRIB_MAGIC_MARKER     0x01020304

    #pragma pack(push)
    #pragma pack(1)

    struct IN_FILE_PVR_ATTRIBUTE_HEADER {
        DWORD                       dwMagicMarker ;
        ULONG                       ulReserved ;
        DWORD                       dwTotalAttributeLen ;   //  header + name + data
        DWORD                       dwNameLengthBytes ;     //  includes null-terminator;
        STREAMBUFFER_ATTR_DATATYPE  DataType ;
        DWORD                       dwDataLength ;

        //  follow
        //  name
        //  attribute
    } ;

    #pragma pack(pop)

    BOOL                                m_fLocked ;
    TCDenseVector <CSBERecAttribute *>  m_Attributes ;
    CRITICAL_SECTION                    m_crt ;
    LPWSTR                              m_pszAttrFile ;


    void Lock_ ()           { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()         { ::LeaveCriticalSection (& m_crt) ; }

    void
    FreeAttributes_ (
        ) ;

    //  checks against reserved names, cross-typed well-known, etc...
    BOOL
    ValidAttribute_ (
        IN  LPCWSTR                     pszAttributeName,       //  name
        IN  STREAMBUFFER_ATTR_DATATYPE  SBEAttributeType,       //  type
        IN  BYTE *                      pbAttribute,            //  blob
        IN  WORD                        cbAttributeLength       //  blob length
        ) ;

    void
    FindLocked_ (
        IN  LPCWSTR             pszName,
        OUT CSBERecAttribute ** ppPVRAttribute,
        OUT DWORD *             pdwIndex
        ) ;

    public :

        CSBERecordingAttributesFile (
            IN  LPCWSTR     pszAttrFile,
            OUT HRESULT *   phr
            ) ;

        virtual
        ~CSBERecordingAttributesFile (
            ) ;

        //  overwrites an existing file if it exists
        HRESULT Flush   () ;
        HRESULT Load    () ;

        /*++
            SetAttribute ()

            1. sets an attribute on a recording object;
            2. fails if the IDVRRecordControl::Start has already been successfully
                called;
            3. if an attribute of the same name already exists, overwrites the old
        --*/
        virtual
        HRESULT
        SetAttribute (
            IN  WORD                        wReserved,              //  0
            IN  LPCWSTR                     pszAttributeName,       //  name
            IN  STREAMBUFFER_ATTR_DATATYPE  SBEAttributeType,       //  type
            IN  BYTE *                      pbAttribute,            //  blob
            IN  WORD                        cbAttributeLength       //  blob length
            ) ;

        HRESULT
        SetAttribute (
            IN  WORD                wReserved,              //  0
            IN  LPCWSTR             pszAttributeName,       //  name
            IN  WMT_ATTR_DATATYPE   WMAttributeType,        //  type (WM)
            IN  BYTE *              pbAttribute,            //  blob
            IN  WORD                cbAttributeLength       //  blob length
            ) ;

        virtual
        HRESULT
        GetAttributeCount (
            IN  WORD    wReserved,      //  0
            OUT WORD *  pcAttributes    //  count
            ) ;

        /*++
            GetAttributeByName ()

            1. given a name, returns the attribute data
            2. if the provided buffer is too small, returns VFW_E_BUFFER_OVERFLOW,
                and (* pcbLength) contains the minimum required length of the buffer
            3. to learn the length of the attribute, pass in non-NULL pcbLength,
                and NULL pbAttribute parameter; OUT value will be the length of
                the attribute
        --*/
        virtual
        HRESULT
        GetAttributeByName (
            IN      LPCWSTR                         pszAttributeName,   //  name
            IN      WORD *                          pwReserved,         //  0
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) ;

        HRESULT
        GetAttributeByName (
            IN      LPCWSTR             pszAttributeName,   //  name
            IN      WORD *              pwReserved,         //  0
            OUT     WMT_ATTR_DATATYPE * pWMAttributeType,
            OUT     BYTE *              pbAttribute,
            IN OUT  WORD *              pcbLength
            ) ;

        /*++
            GetAttributeByIndex ()

            1. given an 0-based index, returns the attribute name and data
            2. if either buffer is too small, returns VFW_E_BUFFER_OVERFLOW, and
                (* pcbLength) and (* pcchNameLength) contain the minimum required
                length of each buffer
            3. the length returned by pcchNameLength includes the null-terminator
            4. to learn the length of the name & attribute, pass in non-NULL
                pcchNameLength & pcbLength, and NULL pszAttributeName & pbAttribute
                parameters; OUT value of the non-NULL parameters will be the
                lengths of the name and attribute
        --*/
        virtual
        HRESULT
        GetAttributeByIndex (
            IN      WORD                            wIndex,
            IN      WORD *                          pwReserved,
            OUT     WCHAR *                         pszAttributeName,
            IN OUT  WORD *                          pcchNameLength,         //  includes NULL-terminator; in BYTES
            OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
            OUT     BYTE *                          pbAttribute,
            IN OUT  WORD *                          pcbLength
            ) ;

        HRESULT
        GetAttributeByIndex (
            IN      WORD                wIndex,
            IN      WORD *              pwReserved,
            OUT     WCHAR *             pszAttributeName,
            IN OUT  WORD *              pcchNameLength,         //  includes NULL-terminator; in BYTES
            OUT     WMT_ATTR_DATATYPE * pWMAttributeType,
            OUT     BYTE *              pbAttribute,
            IN OUT  WORD *              pcbLength
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CConcatRecTimeline
{
    struct STREAM_STATE {
        WORD    wStreamNumber ;
        DWORD   dwContinuityCounter ;
    } ;

    WORD                    m_wTimelineStream ;         //  1 stream in the profile; audio if it exists
    REFERENCE_TIME          m_rtAvgDelta ;              //  for the timeline stream
    DWORD                   m_cTimelineProcessed ;
    DWORD                   m_cRecPacketsProcessed ;
    DWORD                   m_cPreProcessed ;
    const DWORD             m_cMaxPreprocess ;

    REFERENCE_TIME          m_rtLastGoodTimelinePTSDelta ;
    REFERENCE_TIME          m_rtLastTimelinePTS ;           //  last one, regardless of discontinuities
    REFERENCE_TIME          m_rtLastContinuousPTS ;         //  reset whenever there's a discontinuity
    QWORD                   m_cnsLastStreamTime ;
    LONGLONG                m_llStreamtimeShift ;           //  per recording; use SIGNED value
    REFERENCE_TIME          m_PTSShift ;                     //  applies to all

    DWORD                   m_cStreams ;
    STREAM_STATE *          m_ppStreamState ;

    STREAM_STATE *
    GetStreamState_ (
        IN  WORD    wStreamNumber
        ) ;

    void
    RolloverContinuityCounters_ (
        ) ;

    HRESULT
    InitializeStreamStates_ (
        IN  IWMProfile *    pIWMProfile
        ) ;

    HRESULT
    GetSBEAttributes_ (
        IN  INSSBuffer *                    pINSSBuffer,
        OUT INSSBUFFER3PROP_SBE_ATTRIB *   pSBEAttrib
        ) ;

    HRESULT
    SetSBEAttributes_ (
        IN  INSSBuffer *                    pINSSBuffer,
        IN  INSSBUFFER3PROP_SBE_ATTRIB *   pSBEAttrib
        ) ;

    HRESULT
    ShiftDShowPTSs_ (
        IN      WORD            wStreamNumber,
        IN OUT  INSSBuffer *    pINSSBuffer,
        OUT     BOOL *          pfDropSample
        ) ;

    HRESULT
    ShiftWMSDKStreamTime_ (
        IN      WORD    wStreamNumber,
        IN OUT  QWORD * pcnsStreamTime,
        OUT     BOOL *  pfDropSample
        ) ;

    HRESULT
    UpdateContinuityCounter_ (
        IN  WORD            wStreamNumber,
        IN  INSSBuffer *    pINSSBuffer
        ) ;

    void
    ProcessTimelineStreamBuffer_ (
        IN  INSSBuffer *    pINSSBuffer,
        IN  DWORD           dwFlags
        ) ;

    public :

        CConcatRecTimeline (
            IN  DWORD           cMaxPreprocess,
            IN  IWMProfile *    pIWMProfile,
            OUT HRESULT *       phr
            ) ;

        ~CConcatRecTimeline (
            ) ;

        void
        InitForNextRec (
            ) ;

        HRESULT
        PreProcess (
            IN  DWORD           cRecSamples,    //  starts at 0 for each new recording & increments
            IN  WORD            wStreamNumber,
            IN  QWORD           cnsStreamTime,
            IN  INSSBuffer *    pINSSBuffer
            ) ;

        HRESULT
        Shift (
            IN      WORD            wStreamNumber,
            IN      DWORD           dwFlags,
            IN OUT  INSSBuffer *    pINSSBuffer,
            IN OUT  QWORD *         pcnsStreamTime,
            OUT     BOOL *          pfDropSample
            ) ;

        BOOL CanShift ()            { return ((m_PTSShift != UNDEFINED && m_llStreamtimeShift != UNDEFINED) ? TRUE : FALSE) ; }

        QWORD MaxStreamTime ()      { return (m_cnsLastStreamTime != UNDEFINED ? m_cnsLastStreamTime : 0) ; }
} ;

#endif  //  _tsdvr__dvrutil_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\util\dvrperf.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        dvrstats.cpp

    Abstract:

        This module contains the class implementation for stats.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

--*/

#include "dvrall.h"
#include "dvranalysis.h"
#include "dvrutil.h"
#include "dvrperf.h"

// Performance logging parameters.
struct {
    PERFLOG_LOGGING_PARAMS  Params ;
    TRACE_GUID_REGISTRATION TraceGuids[1] ;
} g_perflogParams;

void
DVRPerfInit (
    )
{
    //
    // Initialize WMI-related performance logging.
    //

    HKEY    PerfKey ;
    DWORD   PerfValue ;
    if (RegOpenKey (
        HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\DirectX"),
        &PerfKey) == ERROR_SUCCESS)
    {
        DWORD sizePerfValue=sizeof(DWORD);

        if (RegQueryValueEx (
            PerfKey, TEXT("TimeshiftInstrumentation"), NULL,NULL,(LPBYTE)&PerfValue,
            &sizePerfValue) == ERROR_SUCCESS)
        {
            if (PerfValue > 0)
            {
                g_perflogParams.Params.ControlGuid = GUID_DSHOW_CTL;
                g_perflogParams.Params.OnStateChanged = NULL;
                g_perflogParams.Params.NumberOfTraceGuids = 1;
                g_perflogParams.Params.TraceGuids[0].Guid = &__GUID_TIMESHIFT_PERF;

                PerflogInitialize (&g_perflogParams.Params);
            } //if perfvalue
        } //if regqueryvalue
        RegCloseKey(PerfKey);
    } //if regopen key
}

void
DVRPerfUninit (
    )
{
    PerflogShutdown();
}

//  ============================================================================
//  ============================================================================

CMpeg2VideoStreamStatsReader::CMpeg2VideoStreamStatsReader (
    IN  IUnknown *  pIUnknown,
    OUT HRESULT *   phr
    ) : CUnknown    (TEXT ("CMpeg2VideoStreamStatsReader"),
                     pIUnknown
                     ),
        m_pPolicy   (NULL)
{
    m_pPolicy = new CDVRPolicy (REG_DVR_ANALYSIS_LOGIC_MPEG2_VIDEO, phr) ;
    if (!m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
        RELEASE_AND_CLEAR (m_pPolicy) ;
        goto cleanup ;
    }

    (* phr) = Initialize (TRUE) ;
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    cleanup :

    return ;
}

CMpeg2VideoStreamStatsReader::~CMpeg2VideoStreamStatsReader (
    )
{
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRMpeg2VideoStreamStats) {

        ASSERT (m_pMpeg2VideoStreamStats) ;
        return GetInterface (
                    (IDVRMpeg2VideoStreamStats *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  class factory
CUnknown *
WINAPI
CMpeg2VideoStreamStatsReader::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   phr
    )
{
    CMpeg2VideoStreamStatsReader *  pMpeg2Video ;

    pMpeg2Video = new CMpeg2VideoStreamStatsReader (
                        pIUnknown,
                        phr
                        ) ;

    if (!pMpeg2Video ||
        FAILED (* phr)) {

        DELETE_RESET (pMpeg2Video) ;
    }

    return pMpeg2Video ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::GetFrameCounts (
    OUT ULONGLONG * pull_I_Frames_Observed,
    OUT ULONGLONG * pull_P_Frames_Observed,
    OUT ULONGLONG * pull_B_Frames_Observed,
    OUT ULONGLONG * pull_P_Frames_Flagged,
    OUT ULONGLONG * pull_B_Frames_Flagged
    )
{
    if (!pull_I_Frames_Observed ||
        !pull_P_Frames_Observed ||
        !pull_B_Frames_Observed ||
        !pull_P_Frames_Flagged  ||
        !pull_B_Frames_Flagged
        ) {

        return E_POINTER ;
    }

    ASSERT (m_pMpeg2VideoStreamStats) ;

    //  observed
    (* pull_I_Frames_Observed)  = m_pMpeg2VideoStreamStats -> Observed.ullIFrameCount ;
    (* pull_P_Frames_Observed)  = m_pMpeg2VideoStreamStats -> Observed.ullPFrameCount ;
    (* pull_B_Frames_Observed)  = m_pMpeg2VideoStreamStats -> Observed.ullBFrameCount ;

    //  flagged
    (* pull_P_Frames_Flagged)   = m_pMpeg2VideoStreamStats -> Flagged.ullPFrameCount ;
    (* pull_B_Frames_Flagged)   = m_pMpeg2VideoStreamStats -> Flagged.ullBFrameCount ;

    return S_OK ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::GetFrameRate (
    OUT ULONGLONG * pullSequenceHeaders,
    OUT double *    pdFrameRate
    )
{
    if (!pullSequenceHeaders ||
        !pdFrameRate) {

        return E_POINTER ;
    }

    (* pullSequenceHeaders) = m_pMpeg2VideoStreamStats -> Observed.ullSequenceHeaderCount ;
    (* pdFrameRate)         = m_pMpeg2VideoStreamStats -> dFrameRate ;

    return S_OK ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::GetObservedGOPHeaderCount (
    OUT ULONGLONG * pull_GOHeaders_Observed
    )
{
    if (!pull_GOHeaders_Observed) {
        return E_POINTER ;
    }

    ASSERT (m_pMpeg2VideoStreamStats) ;

    (* pull_GOHeaders_Observed) = m_pMpeg2VideoStreamStats -> Observed.ullGOPHeaderCount ;

    return S_OK ;
}

HRESULT
CMpeg2VideoStreamStatsReader::GetGOPBoundariesFlagged (
    OUT ULONGLONG * pull_GOPBoundariesFlagged
    )
{
    if (!pull_GOPBoundariesFlagged) {
        return E_POINTER ;
    }

    (* pull_GOPBoundariesFlagged) = m_pMpeg2VideoStreamStats -> Flagged.ullGOPBoundaries ;

    return S_OK ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::Enable (
    IN OUT  BOOL *  pfEnable
    )
{
    BOOL    fCurrent ;
    BOOL    r ;
    DWORD   dw ;

    if (!pfEnable) {
        return E_POINTER ;
    }

    ASSERT (m_pPolicy) ;

    fCurrent = m_pPolicy -> Settings () -> StatsEnabled () ;
    if (fCurrent != (* pfEnable)) {
        dw = m_pPolicy -> Settings () -> EnableStats (* pfEnable) ;
        r = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        r = TRUE ;
    }

    (* pfEnable) = fCurrent ;

    return (r ? S_OK : E_FAIL) ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::Reset (
    )
{
    return Clear () ;
}

//  ============================================================================
//  ============================================================================

CDVRReceiveStatsReader::CDVRReceiveStatsReader (
    IN  IUnknown *  pIUnknown,
    OUT HRESULT *   phr
    ) : CUnknown    (TEXT ("CDVRReceiveStatsReader"),
                     pIUnknown
                     ),
        m_pPolicy   (NULL)
{
    m_pPolicy = new CDVRPolicy (REG_DVR_STREAM_SINK_ROOT, phr) ;
    if (!m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
        RELEASE_AND_CLEAR (m_pPolicy) ;
        goto cleanup ;
    }

    (* phr) = Initialize (TRUE) ;
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    ASSERT (m_pDVRReceiveStats) ;

    cleanup :

    return ;
}

CDVRReceiveStatsReader::~CDVRReceiveStatsReader (
    )
{
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CDVRReceiveStatsReader::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRReceiverStats) {

        ASSERT (m_pDVRReceiveStats) ;
        return GetInterface (
                    (IDVRReceiverStats *) this,
                    ppv
                    ) ;
    }

    else if (riid == IID_IDVRAnalysisMpeg2RecvStats) {
        ASSERT (m_pDVRReceiveStats) ;
        return GetInterface (
                    (IDVRAnalysisMpeg2RecvStats *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  class factory
CUnknown *
WINAPI
CDVRReceiveStatsReader::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   phr
    )
{
    CDVRReceiveStatsReader *  pDVRReceiveStatsReader ;

    pDVRReceiveStatsReader = new CDVRReceiveStatsReader (
                        pIUnknown,
                        phr
                        ) ;

    if (!pDVRReceiveStatsReader ||
        FAILED (* phr)) {

        DELETE_RESET (pDVRReceiveStatsReader) ;
    }

    return pDVRReceiveStatsReader ;
}

HRESULT
CDVRReceiveStatsReader::GetStatsMaxStreams (
    OUT int *   piMaxStreams
    )
{
    if (!piMaxStreams) {
        return E_POINTER ;
    }

    (* piMaxStreams) = TSDVR_RECEIVE_MAX_STREAM_STATS ;
    return S_OK ;
}

HRESULT
CDVRReceiveStatsReader::GetStreamStats (
    IN  int                 iStreamIndex,   //  0-based
    OUT ULONGLONG *         pullMediaSamplesIn,
    OUT ULONGLONG *         pullTotalBytes,
    OUT ULONGLONG *         pullDiscontinuities,
    OUT ULONGLONG *         pullSyncPoints,
    OUT REFERENCE_TIME *    prtLast,
    OUT ULONGLONG *         pullWriteFailures
    )
{
    if (iStreamIndex < 0 &&
        iStreamIndex >= TSDVR_RECEIVE_MAX_STREAM_STATS) {

        return E_INVALIDARG ;
    }

    if (!pullMediaSamplesIn     ||
        !pullTotalBytes         ||
        !pullDiscontinuities    ||
        !pullSyncPoints         ||
        !prtLast                ||
        !pullWriteFailures) {

        return E_POINTER ;
    }

    ASSERT (m_pDVRReceiveStats) ;

    (* pullMediaSamplesIn)  = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullMediaSamplesIn ;
    (* pullTotalBytes)      = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullTotalBytes ;
    (* pullDiscontinuities) = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullDiscontinuities ;
    (* pullSyncPoints)      = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullSyncPoints ;
    (* prtLast)             = m_pDVRReceiveStats -> StreamStats [iStreamIndex].rtLast ;
    (* pullWriteFailures)   = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullWriteFailures ;

    return S_OK ;
}

HRESULT
CDVRReceiveStatsReader::GetMpeg2VideoFrameStats (
    OUT ULONGLONG * pull_GOP_Boundaries,
    OUT ULONGLONG * pull_P_Frames,
    OUT ULONGLONG * pull_B_Frames
    )
{
    if (!pull_GOP_Boundaries    ||
        !pull_P_Frames          ||
        !pull_B_Frames) {

        return E_POINTER ;
    }

    (* pull_GOP_Boundaries) = m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats.ullTagged_GOPBoundaries ;
    (* pull_P_Frames)       = m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats.ullTagged_PFrames ;
    (* pull_B_Frames)       = m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats.ullTagged_BFrames ;

    return S_OK ;
}

HRESULT
CDVRReceiveStatsReader::GetMpeg2VideoStreamByteStats (
    OUT ULONGLONG * pull_I_FrameBytesTotal,     //  GOP header + I-frame
    OUT ULONGLONG * pull_P_FrameBytesTotal,     //  P-frame
    OUT ULONGLONG * pull_B_FrameBytesTotal      //  B-frame
    )
{
    if (!pull_I_FrameBytesTotal ||
        !pull_P_FrameBytesTotal ||
        !pull_B_FrameBytesTotal) {

        return E_POINTER ;
    }

    (* pull_I_FrameBytesTotal)  = m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats.ullTotal_I_FrameBytes ;
    (* pull_P_FrameBytesTotal)  = m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats.ullTotal_P_FrameBytes ;
    (* pull_B_FrameBytesTotal)  = m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats.ullTotal_B_FrameBytes ;

    return S_OK ;
}

HRESULT
CDVRReceiveStatsReader::GetMpeg2VideoFrameRate (
    OUT double *    pdFrameRate
    )
{
    if (!pdFrameRate) {
        return E_POINTER ;
    }

    (* pdFrameRate) = m_pDVRReceiveStats -> AnalysisStats.Mpeg2VideoStats.dFrameRate ;

    return S_OK ;
}

STDMETHODIMP
CDVRReceiveStatsReader::Enable (
    IN OUT  BOOL *  pfEnable
    )
{
    BOOL    fCurrent ;
    BOOL    r ;
    DWORD   dw ;

    if (!pfEnable) {
        return E_POINTER ;
    }

    ASSERT (m_pPolicy) ;

    fCurrent = m_pPolicy -> Settings () -> StatsEnabled () ;
    if (fCurrent != (* pfEnable)) {
        dw = m_pPolicy -> Settings () -> EnableStats (* pfEnable) ;
        r = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        r = TRUE ;
    }

    (* pfEnable) = fCurrent ;

    return (r ? S_OK : E_FAIL) ;
}

STDMETHODIMP
CDVRReceiveStatsReader::Reset (
    )
{
    return Clear () ;
}

//  ============================================================================
//  ============================================================================

CDVRSendStatsReader::CDVRSendStatsReader (
    IN  IUnknown *  pIUnknown,
    OUT HRESULT *   phr
    ) : CUnknown    (TEXT ("CDVRSendStatsReader"),
                     pIUnknown
                     ),
        m_pPolicy   (NULL)
{
    m_pPolicy = new CDVRPolicy (REG_DVR_STREAM_SOURCE_ROOT, phr) ;
    if (!m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
        RELEASE_AND_CLEAR (m_pPolicy) ;
        goto cleanup ;
    }

    (* phr) = Initialize (TRUE) ;
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    ASSERT (m_pDVRSenderStats) ;

    cleanup :

    return ;
}

CDVRSendStatsReader::~CDVRSendStatsReader (
    )
{
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CDVRSendStatsReader::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRSenderStats) {

        ASSERT (m_pDVRSenderStats) ;
        return GetInterface (
                    (IDVRSenderStats *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  class factory
CUnknown *
WINAPI
CDVRSendStatsReader::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   phr
    )
{
    CDVRSendStatsReader *  pDVRSendStatsReader ;

    pDVRSendStatsReader = new CDVRSendStatsReader (
                        pIUnknown,
                        phr
                        ) ;

    if (!pDVRSendStatsReader ||
        FAILED (* phr)) {

        DELETE_RESET (pDVRSendStatsReader) ;
    }

    return pDVRSendStatsReader ;
}

HRESULT
CDVRSendStatsReader::GetStatsMaxStreams (
    OUT int *   piMaxStreams
    )
{
    if (!piMaxStreams) {
        return E_POINTER ;
    }

    (* piMaxStreams) = TSDVR_SEND_MAX_STREAM_STATS ;
    return S_OK ;
}

HRESULT
CDVRSendStatsReader::GetStreamStats (
    IN  int                 iStreamIndex,   //  0-based
    OUT ULONGLONG *         pullMediaSamplesIn,
    OUT ULONGLONG *         pullTotalBytes,
    OUT ULONGLONG *         pullDiscontinuities,
    OUT ULONGLONG *         pullSyncPoints,
    OUT REFERENCE_TIME *    prtLastNormalized,
    OUT REFERENCE_TIME *    prtRefClockOnLastPTS,
    OUT REFERENCE_TIME *    prtBufferingLastPTS,
    OUT ULONGLONG *         pullUnderflows,
    OUT LONG *              plMediaSamplesOutstanding,
    OUT LONG *              plMediaSamplePoolSize
    )
{
    if (iStreamIndex < 0 &&
        iStreamIndex >= TSDVR_SEND_MAX_STREAM_STATS) {

        return E_INVALIDARG ;
    }

    if (!pullMediaSamplesIn         ||
        !pullTotalBytes             ||
        !pullDiscontinuities        ||
        !pullSyncPoints             ||
        !prtLastNormalized          ||
        !prtRefClockOnLastPTS       ||
        !prtBufferingLastPTS        ||
        !pullUnderflows             ||
        !plMediaSamplesOutstanding  ||
        !plMediaSamplePoolSize) {

        return E_POINTER ;
    }

    ASSERT (m_pDVRSenderStats) ;

    (* pullMediaSamplesIn)          = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullMediaSamplesIn ;
    (* pullTotalBytes)              = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullTotalBytes ;
    (* pullDiscontinuities)         = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullDiscontinuities ;
    (* pullSyncPoints)              = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullSyncPoints ;
    (* prtLastNormalized)           = m_pDVRSenderStats -> StreamStats [iStreamIndex].rtLastNormalized ;
    (* prtRefClockOnLastPTS)        = m_pDVRSenderStats -> StreamStats [iStreamIndex].rtRefClockOnLastPTS ;
    (* prtBufferingLastPTS)         = m_pDVRSenderStats -> StreamStats [iStreamIndex].rtBufferingLastPTS ;
    (* pullUnderflows)              = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullUnderflows ;
    (* plMediaSamplesOutstanding)   = m_pDVRSenderStats -> StreamStats [iStreamIndex].dwReserved1 ;
    (* plMediaSamplePoolSize)       = m_pDVRSenderStats -> StreamStats [iStreamIndex].dwReserved2 ;

    return S_OK ;
}

HRESULT
CDVRSendStatsReader::GetGlobalStats (
    OUT REFERENCE_TIME *    prtNormalizer,
    OUT REFERENCE_TIME *    prtPTSBase,
    OUT DWORD *             pdwBufferPoolAvailable,
    OUT DWORD *             pdwBufferPoolCur,
    OUT DWORD *             pdwBufferPoolMax,
    OUT ULONGLONG *         pullReadFailures,
    OUT ULONGLONG *         pullUnderflows,
    OUT REFERENCE_TIME *    prtTotalPaused
    )
{
    if (!prtNormalizer          ||
        !prtPTSBase             ||
        !pdwBufferPoolAvailable ||
        !pdwBufferPoolCur       ||
        !pdwBufferPoolMax       ||
        !pullReadFailures       ||
        !pullUnderflows         ||
        !prtTotalPaused) {

        return E_POINTER ;
    }

    (* prtNormalizer)           = m_pDVRSenderStats -> rtNormalizer ;
    (* prtPTSBase)              = m_pDVRSenderStats -> rtPTSBase ;
    (* pdwBufferPoolAvailable)  = m_pDVRSenderStats -> dwBufferPoolAvailable ;
    (* pdwBufferPoolCur)        = m_pDVRSenderStats -> dwBufferPoolCur ;
    (* pdwBufferPoolMax)        = m_pDVRSenderStats -> dwBufferPoolMax ;
    (* pullReadFailures)        = m_pDVRSenderStats -> ullReadFailures ;
    (* pullUnderflows)          = m_pDVRSenderStats -> ullUnderflows ;
    (* prtTotalPaused)          = m_pDVRSenderStats -> rtTotalPausedTime ;

    return S_OK ;
}

STDMETHODIMP
CDVRSendStatsReader::GetClockSlaving (
    OUT ULONGLONG * pullInBoundsBrackets,
    OUT ULONGLONG * pullOutOfBoundsBrackets,
    OUT ULONGLONG * pullResets,
    OUT BOOL *      pfSlaving,
    OUT BOOL *      pfSettling,
    OUT double *    pdLastBracketScale,
    OUT double *    pdInUseScale
    )
{
    if (!pullInBoundsBrackets       ||
        !pullOutOfBoundsBrackets    ||
        !pullResets                 ||
        !pfSlaving                  ||
        !pfSettling                 ||
        !pdLastBracketScale         ||
        !pdInUseScale) {

        return E_POINTER ;
    }

    (* pullInBoundsBrackets)    = m_pDVRSenderStats -> Clock.Slaving.ullInBoundsBrackets ;
    (* pullOutOfBoundsBrackets) = m_pDVRSenderStats -> Clock.Slaving.ullOutOfBoundsBrackets ;
    (* pullResets)              = m_pDVRSenderStats -> Clock.Slaving.ullResets ;
    (* pfSlaving)               = m_pDVRSenderStats -> Clock.Slaving.fSlaving ;
    (* pfSettling)              = m_pDVRSenderStats -> Clock.Slaving.fSettling ;
    (* pdLastBracketScale)      = m_pDVRSenderStats -> Clock.Slaving.dLastBracketScale ;
    (* pdInUseScale)            = m_pDVRSenderStats -> Clock.Slaving.dInUseScale ;

    return S_OK ;
}

STDMETHODIMP
CDVRSendStatsReader::GetIRefClock (
    OUT ULONGLONG * pullQueuedAdvises,
    OUT ULONGLONG * pullSignaledAdvises,
    OUT ULONGLONG * pullStaleAdvises
    )
{
    if (!pullQueuedAdvises      ||
        !pullSignaledAdvises    ||
        !pullStaleAdvises) {

        return E_POINTER ;
    }

    (* pullQueuedAdvises)   = m_pDVRSenderStats -> Clock.IReferenceClock.ullQueuedAdvises ;
    (* pullSignaledAdvises) = m_pDVRSenderStats -> Clock.IReferenceClock.ullSignaledAdvises ;
    (* pullStaleAdvises)    = m_pDVRSenderStats -> Clock.IReferenceClock.ullStaleAdvises ;

    return S_OK ;
}

STDMETHODIMP
CDVRSendStatsReader::Enable (
    IN OUT  BOOL *  pfEnable
    )
{
    BOOL    fCurrent ;
    BOOL    r ;
    DWORD   dw ;

    if (!pfEnable) {
        return E_POINTER ;
    }

    ASSERT (m_pPolicy) ;

    fCurrent = m_pPolicy -> Settings () -> StatsEnabled () ;
    if (fCurrent != (* pfEnable)) {
        dw = m_pPolicy -> Settings () -> EnableStats (* pfEnable) ;
        r = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        r = TRUE ;
    }

    (* pfEnable) = fCurrent ;

    return (r ? S_OK : E_FAIL) ;
}

STDMETHODIMP
CDVRSendStatsReader::Reset (
    )
{
    return Clear () ;
}

//  ============================================================================
//  ============================================================================

CPVRIOCountersReader::CPVRIOCountersReader (
    IN  IUnknown *  pIUnknown,
    OUT HRESULT *   phr
    ) : CUnknown    (TEXT ("CPVRIOCountersReader"),
                     pIUnknown
                     ),
        m_pPolicy   (NULL)
{
    m_pPolicy = new CDVRPolicy (REG_DVR_STREAM_SOURCE_ROOT, phr) ;
    if (!m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
        RELEASE_AND_CLEAR (m_pPolicy) ;
        goto cleanup ;
    }

    (* phr) = Initialize (TRUE) ;
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    ASSERT (m_pPVRIOCounters) ;

    cleanup :

    return ;
}

CPVRIOCountersReader::~CPVRIOCountersReader (
    )
{
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CPVRIOCountersReader::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IPVRIOCountersReader) {

        ASSERT (m_pPVRIOCounters) ;
        return GetInterface (
                    (IPVRIOCountersReader *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  class factory
CUnknown *
WINAPI
CPVRIOCountersReader::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   phr
    )
{
    CPVRIOCountersReader *  pPVRIOCountersReader ;

    pPVRIOCountersReader = new CPVRIOCountersReader (
                        pIUnknown,
                        phr
                        ) ;

    if (!pPVRIOCountersReader ||
        FAILED (* phr)) {

        DELETE_RESET (pPVRIOCountersReader) ;
    }

    return pPVRIOCountersReader ;
}

STDMETHODIMP
CPVRIOCountersReader::GetAsyncReaderCounters (
    OUT ULONGLONG * pcWriteBufferHit,
    OUT ULONGLONG * pcReadCacheHit,
    OUT ULONGLONG * pcReadCacheMiss,
    OUT ULONGLONG * pcReadAhead,
    OUT ULONGLONG * pcReadAheadReadCacheHit,
    OUT ULONGLONG * pcReadAheadWriteBufferHit,
    OUT ULONGLONG * pcPartiallyFilledBuffer,
    OUT ULONGLONG * pcPartialReadAgain,
    OUT ULONGLONG * pcWaitForAny_Queued,
    OUT ULONGLONG * pcWaitForAny_SignaledSuccess,
    OUT ULONGLONG * pcWaitForAny_SignaledFailure,
    OUT ULONGLONG * pcWaitForAny_BufferDequeued,
    OUT ULONGLONG * pcWaitRead_Queued,
    OUT ULONGLONG * pcWaitRead_SignaledSuccess,
    OUT ULONGLONG * pcWaitRead_SignaledFailure,
    OUT ULONGLONG * pcWaitRead_BufferDequeued,
    OUT ULONGLONG * pullLastDiskRead,
    OUT ULONGLONG * pullLastBufferReadout,
    OUT ULONGLONG * pcIoPended,
    OUT ULONGLONG * pcIoCompletedSuccess,
    OUT ULONGLONG * pcIoCompletedError,
    OUT ULONGLONG * pcIoPendingError
    )
{
    if (!pcWriteBufferHit               ||
        !pcReadCacheHit                 ||
        !pcReadCacheMiss                ||
        !pcReadAhead                    ||
        !pcReadAheadReadCacheHit        ||
        !pcReadAheadWriteBufferHit      ||
        !pcPartiallyFilledBuffer        ||
        !pcPartialReadAgain             ||
        !pcWaitForAny_Queued            ||
        !pcWaitForAny_SignaledSuccess   ||
        !pcWaitForAny_SignaledFailure   ||
        !pcWaitForAny_BufferDequeued    ||
        !pcWaitRead_Queued              ||
        !pcWaitRead_SignaledSuccess     ||
        !pcWaitRead_SignaledFailure     ||
        !pcWaitRead_BufferDequeued      ||
        !pullLastDiskRead               ||
        !pullLastBufferReadout          ||
        !pcIoPended                     ||
        !pcIoCompletedSuccess           ||
        !pcIoCompletedError             ||
        !pcIoPendingError) {

        return E_POINTER ;
    }

    (* pcWriteBufferHit)                = m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadoutWriteBufferHit ;
    (* pcReadCacheHit)                  = m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadoutCacheHit ;
    (* pcReadCacheMiss)                 = m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadoutCacheMiss ;
    (* pullLastBufferReadout)           = m_pPVRIOCounters -> PVRAsyncReaderCounters.ullLastBufferReadout ;

    (* pcReadAhead)                     = m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadAhead ;
    (* pcReadAheadReadCacheHit)         = m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadAheadReadCacheHit ;
    (* pcReadAheadWriteBufferHit)       = m_pPVRIOCounters -> PVRAsyncReaderCounters.cReadAheadWriteBufferHit ;
    (* pcPartiallyFilledBuffer)         = m_pPVRIOCounters -> PVRAsyncReaderCounters.cPartiallyFilledBuffer ;
    (* pcPartialReadAgain)              = m_pPVRIOCounters -> PVRAsyncReaderCounters.cPartialReadAgain ;

    (* pcWaitForAny_Queued)             = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cQueued ;
    (* pcWaitForAny_SignaledSuccess)    = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cSignaledSuccess ;
    (* pcWaitForAny_SignaledFailure)    = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cSignaledFailure ;
    (* pcWaitForAny_BufferDequeued)     = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitAnyBuffer.cBufferDequeued ;

    (* pcWaitRead_Queued)               = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitReadCompletion.cQueued ;
    (* pcWaitRead_SignaledSuccess)      = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitReadCompletion.cSignaledSuccess ;
    (* pcWaitRead_SignaledFailure)      = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitReadCompletion.cSignaledFailure ;
    (* pcWaitRead_BufferDequeued)       = m_pPVRIOCounters -> PVRAsyncReaderCounters.WaitReadCompletion.cBufferDequeued ;

    (* pullLastDiskRead)                = m_pPVRIOCounters -> PVRAsyncReaderCounters.ullLastDiskRead ;

    (* pcIoPended)                      = m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoPended ;
    (* pcIoCompletedSuccess)            = m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoCompletedSuccess ;
    (* pcIoCompletedError)              = m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoCompletedError ;
    (* pcIoPendingError)                = m_pPVRIOCounters -> PVRAsyncReaderCounters.cIoPendingError ;

    return S_OK ;
}

STDMETHODIMP
CPVRIOCountersReader::GetAsyncWriterCounters (
    OUT ULONGLONG * pcFileExtensions,
    OUT ULONGLONG * pcBytesAppended,
    OUT ULONGLONG * pcIoPended,
    OUT ULONGLONG * pcIoPendingError,
    OUT ULONGLONG * pcWaitNextBuffer,
    OUT ULONGLONG * pcIoCompletedSuccess,
    OUT ULONGLONG * pcIoCompletedError
    )
{

    if (!pcFileExtensions       ||
        !pcBytesAppended        ||
        !pcIoPended             ||
        !pcIoPendingError       ||
        !pcWaitNextBuffer       ||
        !pcIoCompletedSuccess   ||
        !pcIoCompletedError) {

        return E_POINTER ;
    }

    (* pcFileExtensions)        = m_pPVRIOCounters -> PVRAsyncWriterCounters.cFileExtensions ;
    (* pcBytesAppended)         = m_pPVRIOCounters -> PVRAsyncWriterCounters.cBytesAppended ;
    (* pcIoPended)              = m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoPended ;
    (* pcIoPendingError)        = m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoPendingError ;
    (* pcWaitNextBuffer)        = m_pPVRIOCounters -> PVRAsyncWriterCounters.cWaitNextBuffer ;
    (* pcIoCompletedSuccess)    = m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoCompletedSuccess ;
    (* pcIoCompletedError)      = m_pPVRIOCounters -> PVRAsyncWriterCounters.cIoCompletedError ;

    return S_OK ;
}

STDMETHODIMP
CPVRIOCountersReader::Enable (
    IN OUT  BOOL *  pfEnable
    )
{
    BOOL    fCurrent ;
    BOOL    r ;
    DWORD   dw ;

    if (!pfEnable) {
        return E_POINTER ;
    }

    ASSERT (m_pPolicy) ;

    fCurrent = m_pPolicy -> Settings () -> StatsEnabled () ;
    if (fCurrent != (* pfEnable)) {
        dw = m_pPolicy -> Settings () -> EnableStats (* pfEnable) ;
        r = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        r = TRUE ;
    }

    (* pfEnable) = fCurrent ;

    return (r ? S_OK : E_FAIL) ;
}

STDMETHODIMP
CPVRIOCountersReader::Reset (
    )
{
    return Clear () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\inc\dvrw32.h ===
/*++

    Copyright (c) 2002 Microsoft Corporation

    Module Name:

        dvrw32.h

    Abstract:

        utilities that are pure win32

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef _tsdvr__dvrw32_h
#define _tsdvr__dvrw32_h

#ifndef UNDEFINED
#define UNDEFINED   -1
#endif  //  UNDEFINED

template <class T> T Min (T a, T b)                     { return (a < b ? a : b) ; }
template <class T> T Max (T a, T b)                     { return (a > b ? a : b) ; }
template <class T> T Abs (T t)                          { return (t >= 0 ? t : 0 - t) ; }
template <class T> BOOL InRange (T val, T min, T max)   { return (min <= val && val <= max) ; }

template <class T> T AlignDown (T a, T align)           { return (a / align) * align ; }
template <class T> T AlignUp (T a, T align)             { return (a % align ? ((a / align) + 1) * align : a) ; }

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    ) ;

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    ) ;

//  return TRUE if we're on XPe
BOOL
IsXPe (
    ) ;

BOOL
CheckOS (
    ) ;

//  returns TRUE if the required DLLs can be successfully loaded (via LoadLibrary)
BOOL
RequiredModulesPresent (
    ) ;

FARPROC
WINAPI
SBE_DelayLoadFailureHook (
    IN  UINT            unReason,
    IN  DelayLoadInfo * pDelayInfo
    ) ;

//  ============================================================================
//  registry

//  value exists:           retrieves it
//  value does not exist:   sets it
BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR szValName,
    OUT DWORD * pdw
    ) ;

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdw
    ) ;

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    ) ;

BOOL
GetRegStringValW (
    IN      HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN      LPCTSTR pszRegRoot,
    IN      LPCTSTR pszRegValName,
    IN OUT  DWORD * pdwLen,         //  out: string length + null, in bytes
    OUT     BYTE *  pbBuffer
    ) ;

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    ) ;

BOOL
GetRegStringValW (
    IN      HKEY    hkeyRoot,
    IN      LPCTSTR pszRegValName,
    IN OUT  DWORD * pdwLen,         //  out: string length + null, in bytes
    OUT     BYTE *  pbBuffer
    ) ;

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    ) ;

BOOL
SetRegStringValW (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCWSTR pszRegRoot,
    IN  LPCWSTR pszRegValName,
    IN  LPCWSTR pszStringVal
    ) ;

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    ) ;

BOOL
SetRegStringValW (
    IN  HKEY    hkeyRoot,
    IN  LPCWSTR pszRegValName,
    IN  LPCWSTR pszVal
    ) ;

//  ============================================================================
//  CMutexLock
//      manages nested calls in-proc
//  ============================================================================

class CMutexLock
{
    //
    //  uses the critical section to serialize in-proc i.e. if a thread owns
    //    the mutex, it also owns the critical section, so threads within
    //    the same process are blocked from even checking if the count is
    //    up; if the lock is held in another process, the critical section
    //    serializes the threads in the same process
    //

    LONG                m_cLock ;
    CRITICAL_SECTION    m_crt ;
    HANDLE              m_hMutex ;
    DWORD               m_dwOwningThreadId ;

    void LockInternal_ ()   { ::EnterCriticalSection (& m_crt) ; }
    void UnlockInternal_ () { ::LeaveCriticalSection (& m_crt) ; }

    public :

        CMutexLock (
            IN  HANDLE  hMutex,
            OUT DWORD * pdwRet
            ) : m_hMutex            (NULL),
                m_cLock             (0),
                m_dwOwningThreadId  (UNDEFINED)
        {
            BOOL    r ;

            ASSERT (hMutex) ;

            ::InitializeCriticalSection (& m_crt) ;

            r = ::DuplicateHandle (
                        ::GetCurrentProcess (),
                        hMutex,
                        ::GetCurrentProcess (),
                        & m_hMutex,
                        0,
                        FALSE,
                        DUPLICATE_SAME_ACCESS
                        ) ;
            if (r) {
                (* pdwRet) = NOERROR ;
            }
            else {
                (* pdwRet) = ::GetLastError () ;
                m_hMutex = NULL ;
            }

            return ;
        }

        ~CMutexLock (
            )
        {
            ASSERT (m_cLock == 0) ;
            ASSERT (m_dwOwningThreadId == UNDEFINED) ;

            if (m_hMutex) {
                ::CloseHandle (m_hMutex) ;
            }

            ::DeleteCriticalSection (& m_crt) ;
        }

        BOOL IsLockedByCallingThread ()
        {
            BOOL    r ;

            //  there are race conditions here, but if we own it, the
            //    owning thread id won't change until we release it
            if (m_cLock > 0 &&
                m_dwOwningThreadId == ::GetCurrentThreadId ()) {

                r = TRUE ;
            }
            else {
                r = FALSE ;
            }

            return r ;
        }

        BOOL Lock ()
        {
            BOOL    r ;
            DWORD   dwRet ;

            ASSERT (m_hMutex) ;

            LockInternal_ () ;

            //  if we're in, we either own the mutex, or are the first in our
            //    process to want to own it

            if (m_cLock == 0) {
                dwRet = ::WaitForSingleObject (m_hMutex, INFINITE) ;
            }
            else {
                //  calling thread already owns it
                dwRet = WAIT_OBJECT_0 ;
            }

            if (dwRet == WAIT_OBJECT_0) {

                if (m_cLock == 0) {
                    //  first call to own the critsec
                    ASSERT (m_dwOwningThreadId == UNDEFINED) ;
                    m_dwOwningThreadId = ::GetCurrentThreadId () ;
                }

                //  hold the critical section lock; it will be nested if this
                //    isn't the first time we make the call
                m_cLock++ ;

                r = TRUE ;
            }
            else {
                //  don't count this one i.e. release our ref on the critical section
                UnlockInternal_ () ;

                r = FALSE ;
            }

            return r ;
        }

        void Unlock ()
        {
            ASSERT (m_hMutex) ;

            if (m_dwOwningThreadId == ::GetCurrentThreadId ()) {

                ASSERT (m_cLock > 0) ;
                m_cLock-- ;

                if (m_cLock == 0) {
                    ::ReleaseMutex (m_hMutex) ;
                    m_dwOwningThreadId = UNDEFINED ;
                }

                //  release the critical section; if m_cLock went to 0, this
                //    should be our final release
                UnlockInternal_ () ;
            }
        }
} ;

//  ----------------------------------------------------------------------------
//      TCNonDenseVector
//  ----------------------------------------------------------------------------

/*++
--*/
template <class T>
class TCNonDenseVector
{
    T **    m_pptTable ;                //  table pointer
    T       m_tEmptyVal ;               //  denotes an empty value in a block
    int     m_iTableRowCountInUse ;     //  rows currently in use
    int     m_iTableRowCountAvail ;     //  available rows (allocated)
    int     m_iBlockSize ;              //  allocation unit size;
                                        //  NOTE: = init table size
    int     m_iMaxIndexInsert ;         //  the max value set so far

    int GetAllocatedSize_ ()    { return m_iTableRowCountInUse * m_iBlockSize ; }

    DWORD
    AppendBlock_ (
        IN  T * ptBlock
        )
    {
        int     iNewTableSize ;
        T **    pptNewTable ;

        //  if we don't have any place to store the new block, allocate it now
        if (!m_pptTable ||
            (m_iTableRowCountInUse == m_iTableRowCountAvail)) {

            //  compute new table size; initial table size is m_iBlockSize
            iNewTableSize = Max <int> (m_iBlockSize, m_iTableRowCountAvail * 2) ;

            //  allocate
            pptNewTable = AllocateTable_ (iNewTableSize) ;
            if (pptNewTable) {
                //  we have a new table

                //  zero the entries out
                ZeroMemory (pptNewTable, iNewTableSize * sizeof (T *)) ;

                //  if we have an old one
                if (m_pptTable) {
                    //  copy the contents over to the newly allocated table and
                    //   free the old
                    CopyMemory (pptNewTable, m_pptTable, m_iTableRowCountAvail * sizeof (T *)) ;
                    FreeTable_ (m_pptTable) ;
                }

                //  set the member variables
                m_pptTable              = pptNewTable ;
                m_iTableRowCountAvail   = iNewTableSize ;
            }
            else {
                //  failed to allocate memory - send the failure back out
                return ERROR_NOT_ENOUGH_MEMORY ;
            }
        }

        //  one more row in use - update and set
        m_iTableRowCountInUse++ ;
        m_pptTable [m_iTableRowCountInUse - 1] = ptBlock ;      //  0-based

        //  success
        return NOERROR ;
    }

    DWORD
    AddBlock_ (
        )
    {
        DWORD   dw ;
        int     i ;
        T *     ptNew ;

        //  allocate the new block
        ptNew = AllocateBlock_ () ;

        if (ptNew) {
            //  initialize to empty
            for (i = 0; i < m_iBlockSize; i++) { ptNew [i] = m_tEmptyVal ; }

            //  append the block to the table
            dw = AppendBlock_ (ptNew) ;

            //  if we failed to append, free the block
            if (dw != NOERROR) {
                FreeBlock_ (ptNew) ;
            }
        }
        else {
            //  failed to allocate memory
            dw = ERROR_NOT_ENOUGH_MEMORY ;
        }

        return dw ;
    }

    protected :

        T *
        AllocateBlock_ (
            )
        {
            return reinterpret_cast <T *> (malloc (m_iBlockSize * sizeof T)) ;
        }

        T **
        AllocateTable_ (
            IN  int iNumEntries
            )
        {
            return reinterpret_cast <T **> (malloc (iNumEntries * sizeof (T *))) ;
        }

        void
        FreeBlock_ (
            IN  T * pBlock
            )
        {
            free (pBlock) ;
        }

        void
        FreeTable_ (
            IN  T **    pptTable
            )
        {
            free (pptTable) ;
        }

    public :

        TCNonDenseVector (
            IN  T   tEmptyVal,
            IN  int iBlockSize
            ) : m_pptTable              (NULL),
                m_iTableRowCountInUse   (0),
                m_tEmptyVal             (tEmptyVal),
                m_iTableRowCountAvail   (0),
                m_iMaxIndexInsert       (-1),
                m_iBlockSize            (iBlockSize) {}

        ~TCNonDenseVector (
            )
        {
            int i ;

            if (m_pptTable) {
                for (i = 0; i < m_iTableRowCountInUse ; i++) {
                    ASSERT (m_pptTable [i]) ;
                    FreeBlock_ (m_pptTable [i]) ;
                }

                FreeTable_ (m_pptTable) ;
            }
        }

        DWORD
        SetVal (
            IN  T   tVal,
            IN  int iIndex
            )
        {
            DWORD   dw ;
            int     iTableRow ;
            int     iBlockIndex ;

            //  add blocks until we have the desired index
            while (GetAllocatedSize_ () < iIndex + 1) {

                dw = AddBlock_ () ;
                if (dw != NOERROR) {
                    return dw ;
                }
            }

            //  compute the table row and row index
            iTableRow   = iIndex / m_iBlockSize ;
            iBlockIndex = iIndex % m_iBlockSize ;

            ASSERT (iTableRow <= m_iTableRowCountAvail) ;
            ASSERT (m_pptTable [iTableRow]) ;

            //  set the value
            m_pptTable [iTableRow] [iBlockIndex] = tVal ;

            //  update max, maybe
            m_iMaxIndexInsert = Max <int> (m_iMaxIndexInsert, iIndex) ;

            return NOERROR ;
        }

        //  returns the number of distinct slot inserts
        int ValCount ()     { return (m_pptTable ? m_iMaxIndexInsert + 1 : 0) ; }

        //  index is chosen as entry following max inserted so far
        DWORD
        AppendVal (
            IN  T       tVal,
            OUT int *   piAppendIndex
            )
        {
            DWORD   dw ;
            int     iAppendIndex ;

            //  iAppendIndex is 0-based
            iAppendIndex = ValCount () ;

            //  set it
            dw = SetVal (
                    tVal,
                    iAppendIndex
                    ) ;

            if (dw == NOERROR &&
                piAppendIndex) {

                //  return the index, if the call was successfull and caller
                //   wants to know
                (* piAppendIndex) = iAppendIndex ;

                ASSERT (iAppendIndex + 1 == ValCount ()) ;
            }

            return dw ;
        }

        //  NOTE: may allocated just to clear .. desired behavior ?
        void ClearVal (IN int iIndex)   { SetVal (iIndex, m_tEmptyVal) ; }

        DWORD
        GetVal (
            IN  int iIndex,
            OUT T * ptRet
            )
        {
            DWORD   dw ;

            if (iIndex + 1 <= GetAllocatedSize_ ()) {
                ASSERT (iIndex / m_iBlockSize <= m_iTableRowCountAvail) ;
                ASSERT (m_pptTable [iIndex / m_iBlockSize]) ;

                (* ptRet) = m_pptTable [iIndex / m_iBlockSize] [iIndex % m_iBlockSize] ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTDynArray
//  ----------------------------------------------------------------------------

template <class T>
class CTDynArray
{
    //  FIFO: insert at "tail"; remove at "head"
    //  LIFO: insert at "top" remove at "top"

    enum {
        INIT_TABLE_SIZE = 5
    } ;

    T **    m_ppBlockTable ;
    LONG    m_lAllocatedTableSize ;
    LONG    m_lAllocatedBlocks ;
    LONG    m_lAllocQuantum ;
    LONG    m_lMaxArrayLen ;
    LONG    m_lCurArrayLen ;
    LONG    m_lLastInsertSlotIndex ;

    LONG AllocatedArrayLength_ ()           { return m_lAllocatedBlocks * m_lAllocQuantum ; }
    LONG TableIndex_ (IN LONG lArrayIndex)  { return lArrayIndex / m_lAllocQuantum ; }
    LONG BlockIndex_ (IN LONG lArrayIndex)  { return lArrayIndex % m_lAllocQuantum ; }

    LONG NextInsertSlotIndex_ ()
    {
        return (AllocatedArrayLength_ () > 0 ? (m_lLastInsertSlotIndex + m_lCurArrayLen) % AllocatedArrayLength_ () : 0) ;
    }

    LONG FIFO_HeadIndex_ ()
    {
        return m_lLastInsertSlotIndex ;
    }

    void FIFO_PopHead_ ()
    {
        ASSERT (m_lCurArrayLen > 0) ;
        m_lCurArrayLen-- ;
        m_lLastInsertSlotIndex = (m_lLastInsertSlotIndex + 1) % AllocatedArrayLength_ () ;
    }

    LONG LIFO_TopIndex_ ()
    {
        ASSERT (m_lCurArrayLen > 0) ;
        return (m_lLastInsertSlotIndex + m_lCurArrayLen - 1) % AllocatedArrayLength_ () ;
    }

    void LIFO_PopTop_ ()
    {
        ASSERT (m_lCurArrayLen > 0) ;
        m_lCurArrayLen-- ;
    }

    DWORD
    MaybeGrowTable_ (
        )
    {
        LONG    lNewSize ;
        T **    pptNew ;

        if (m_lAllocatedTableSize == m_lAllocatedBlocks) {
            //  need to allocate more table

            lNewSize = (m_lAllocatedTableSize > 0 ? m_lAllocatedTableSize * 2 : INIT_TABLE_SIZE) ;

            pptNew = AllocateTable_ (lNewSize) ;
            if (!pptNew) {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }

            ZeroMemory (pptNew, lNewSize * sizeof (T *)) ;

            if (m_ppBlockTable) {
                ASSERT (m_lAllocatedTableSize > 0) ;
                CopyMemory (
                    pptNew,
                    m_ppBlockTable,
                    m_lAllocatedTableSize * sizeof (T *)
                    ) ;

                FreeTable_ (m_ppBlockTable) ;
            }

            m_ppBlockTable = pptNew ;
            m_lAllocatedTableSize = lNewSize ;
        }

        return NOERROR ;
    }

    T *
    Entry_ (
        IN  LONG    lIndex
        )
    {
        //  should not be asking if it's beyond
        ASSERT (lIndex < AllocatedArrayLength_ ()) ;

        ASSERT (TableIndex_ (lIndex) < m_lAllocatedTableSize) ;
        ASSERT (m_ppBlockTable [TableIndex_ (lIndex)]) ;

        return & m_ppBlockTable [TableIndex_ (lIndex)] [BlockIndex_ (lIndex)] ;
    }

    T
    Val_ (IN LONG lIndex)
    {
        return (* Entry_ (lIndex)) ;
    }

    DWORD
    Append_ (T tVal)
    {
        T *     ptNewBlock ;
        LONG    lNewBlockTableIndex ;
        DWORD   dw ;

        ASSERT (!ArrayMaxed ()) ;

        if ((NextInsertSlotIndex_ () == m_lLastInsertSlotIndex && m_lCurArrayLen > 0) ||
            AllocatedArrayLength_ () == 0) {

            //  table is full; need to allocate

            //  might need to extend the table to hold more blocks
            dw = MaybeGrowTable_ () ;
            if (dw != NOERROR) {
                return dw ;
            }

            ASSERT (m_lAllocatedTableSize > m_lAllocatedBlocks) ;

            //  allocate our new block
            ptNewBlock = AllocateBlock_ () ;
            if (!ptNewBlock) {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }

            //  new block is inserted in table into OutSlotIndex's block; we'll
            //    then move out the OutSlotIndex
            lNewBlockTableIndex = TableIndex_ (m_lLastInsertSlotIndex) ;

            //  init the new block & make room for the new block (if there's
            //    something there now i.e. this is not our first time through)
            if (m_ppBlockTable [lNewBlockTableIndex]) {
                //  copy the contents of the block we're about to move out
                CopyMemory (
                    ptNewBlock,
                    m_ppBlockTable [lNewBlockTableIndex],
                    m_lAllocQuantum * sizeof T
                    ) ;

                //  shift the blocks that follow out
                MoveMemory (
                    & m_ppBlockTable [lNewBlockTableIndex + 1],
                    & m_ppBlockTable [lNewBlockTableIndex],
                    (m_lAllocatedBlocks - lNewBlockTableIndex) * sizeof (T *)
                    ) ;
            }

            //  insert into the table
            m_ppBlockTable [lNewBlockTableIndex] = ptNewBlock ;
            m_lAllocatedBlocks++ ;

            //  shift the OutSlot out, if this is not our first
            m_lLastInsertSlotIndex += (m_lAllocatedBlocks > 1 ? m_lAllocQuantum : 0) ;
        }

        //  append to tail
        (* Entry_ (NextInsertSlotIndex_ ())) = tVal ;
        m_lCurArrayLen++ ;

        return NOERROR ;
    }

    protected :

        T *
        AllocateBlock_ (
            )
        {
            return reinterpret_cast <T *> (malloc (m_lAllocQuantum * sizeof T)) ;
        }

        T **
        AllocateTable_ (
            IN  int iNumEntries
            )
        {
            return reinterpret_cast <T **> (malloc (iNumEntries * sizeof (T *))) ;
        }

        void
        FreeBlock_ (
            IN  T * pBlock
            )
        {
            free (pBlock) ;
        }

        void
        FreeTable_ (
            IN  T **    pptTable
            )
        {
            free (pptTable) ;
        }


        DWORD FIFOHeadVal_ (OUT T * pt)
        {
            DWORD   dw ;

            if (m_lCurArrayLen > 0) {
                (* pt) = Val_ (FIFO_HeadIndex_ ()) ;
                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD PopFIFO_ (OUT T * pt)
        {
            DWORD   dw ;

            dw = FIFOHeadVal_ (pt) ;
            if (dw == NOERROR) {
                FIFO_PopHead_ () ;
            }

            return dw ;
        }

        DWORD LIFOTopVal_ (OUT T * pt)
        {
            DWORD   dw ;

            if (m_lCurArrayLen > 0) {
                (* pt) = Val_ (LIFO_TopIndex_ ()) ;
                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD PopLIFO_ (OUT T * pt)
        {
            DWORD   dw ;

            dw = LIFOTopVal_ (pt) ;
            if (dw == NOERROR) {
                LIFO_PopTop_ () ;
            }

            return dw ;
        }

    public :

        CTDynArray (
            IN  LONG    lAllocQuantum,
            IN  LONG    lMaxArrayLen = LONG_MAX
            ) : m_lAllocQuantum         (lAllocQuantum),
                m_lAllocatedBlocks      (0),
                m_lAllocatedTableSize   (0),
                m_ppBlockTable          (NULL),
                m_lMaxArrayLen          (lMaxArrayLen),
                m_lCurArrayLen          (0),
                m_lLastInsertSlotIndex  (0) {}

        ~CTDynArray (
            )
        {
            LONG    l ;

            for (l = 0; l < m_lAllocatedBlocks; l++) {
                FreeBlock_ (m_ppBlockTable [l]) ;
            }

            FreeTable_ (m_ppBlockTable) ;
        }

        LONG Length ()      { return m_lCurArrayLen ; }
        BOOL ArrayMaxed ()  { return (m_lCurArrayLen < m_lMaxArrayLen ? FALSE : TRUE) ; }
        BOOL Empty ()       { return (Length () > 0 ? FALSE : TRUE) ; }
        void Reset ()       { m_lCurArrayLen = 0 ; }

        DWORD Push (IN T tVal)
        {
            DWORD   dw ;

            if (!ArrayMaxed ()) {
                dw = Append_ (tVal) ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        virtual
        DWORD
        Pop (
            OUT T * pt
            ) = 0 ;
} ;

//  ----------------------------------------------------------------------------
//  CTDynQueue
//  ----------------------------------------------------------------------------

template <class T>
class CTDynQueue :
    public CTDynArray <T>
{
    public :

        CTDynQueue (
            IN  LONG    lAllocQuantum,
            IN  LONG    lMaxQueueLen = LONG_MAX
            ) : CTDynArray <T> (lAllocQuantum,
                                lMaxQueueLen) {}

        virtual DWORD Pop (OUT T * pt)
        {
            return PopFIFO_ (pt) ;
        }

        DWORD Head (OUT T * pt)
        {
            return FIFOHeadVal_ (pt) ;
        }

        DWORD Tail (OUT T * pt)
        {
            return LIFOTopVal_ (pt) ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTDynStack
//  ----------------------------------------------------------------------------

template <class T>
class CTDynStack :
    public CTDynArray <T>
{
    public :

        CTDynStack (
            IN  LONG    lAllocQuantum,
            IN  LONG    lMaxQueueLen = LONG_MAX
            ) : CTDynArray <T> (lAllocQuantum,
                                lMaxQueueLen) {}

        virtual DWORD Pop (OUT T * pt)
        {
            return PopLIFO_ (pt) ;
        }

        DWORD Top (OUT T * pt)
        {
            return LIFOTopVal_ (pt) ;
        }
} ;

//  ----------------------------------------------------------------------------
//      CDataCache
//  ----------------------------------------------------------------------------

class CDataCache
{
    BYTE *  m_pbCache ;
    BYTE *  m_pbCurrent ;
    int     m_iCacheSize ;

    public :

        CDataCache (
            IN  BYTE *  pbCache,
            IN  int     iCacheSize
            ) : m_pbCache       (pbCache),
                m_iCacheSize    (iCacheSize),
                m_pbCurrent     (pbCache) {}

        int CurCacheSize ()     { return (int) (m_pbCurrent - m_pbCache) ; }
        int CacheRemaining ()   { return m_iCacheSize - CurCacheSize () ; }
        BYTE * Get ()           { return m_pbCache ; }
        void Reset ()           { m_pbCurrent = m_pbCache ; }
        BOOL IsEmpty ()         { return CurCacheSize () == 0 ; }

        BOOL
        Append (
            IN  BYTE *  pb,
            IN  int     iLength
            )
        {
            if (iLength <= CacheRemaining ()) {
                CopyMemory (
                    m_pbCurrent,
                    pb,
                    iLength
                    ) ;

                m_pbCurrent += iLength ;
                return TRUE ;
            }
            else {
                return FALSE ;
            }
        }
} ;

template <int iCacheSize>
class TSizedDataCache :
    public CDataCache
{
    BYTE    m_pbCache [iCacheSize] ;

    public :

        TSizedDataCache (
            ) : CDataCache (
                    m_pbCache,
                    iCacheSize
                    ) {}
} ;

//  ----------------------------------------------------------------------------
//      TStructPool
//  ----------------------------------------------------------------------------

template <class T, DWORD dwAllocationQuantum = 5>
class TStructPool
{
    template <class T>
    struct CONTAINER
    {
        LIST_ENTRY  ListEntry ;
        DWORD       dwIndex ;
        T           Object ;

        static
        CONTAINER <T> *
        RecoverContainer (
            IN  T * pObject
            )
        {
            CONTAINER <T> * pContainer ;
            pContainer = CONTAINING_RECORD (pObject, CONTAINER <T>, Object) ;
            return pContainer ;
        }
    } ;

    template <class T>
    struct ALLOCATION_UNIT {
        LIST_ENTRY      ListEntry ;
        DWORD           dwInUseCount ;
        CONTAINER <T>   Container [dwAllocationQuantum] ;
    } ;

    LIST_ENTRY          m_AllocationUnits ;
    LIST_ENTRY          m_FreeList ;
    LIST_ENTRY          m_InUseList ;
    DWORD               m_dwTotalFreeCount ;

    ALLOCATION_UNIT <T> *
    GetOwningAllocationUnit_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        ALLOCATION_UNIT <T> * pAllocationUnit ;

        pAllocationUnit = CONTAINING_RECORD (pContainer, ALLOCATION_UNIT <T>, Container [pContainer -> dwIndex]) ;
        return pAllocationUnit ;
    }

    void
    InitializeAllocationUnit_ (
        IN  ALLOCATION_UNIT <T> *   pNewAllocationUnit
        )
    {
        DWORD   i ;

        for (i = 0; i < dwAllocationQuantum; i++) {
            pNewAllocationUnit -> Container [i].dwIndex = i ;
            InsertHeadList (& m_FreeList, & (pNewAllocationUnit -> Container [i].ListEntry)) ;
            m_dwTotalFreeCount++ ;
        }

        InsertHeadList (& m_AllocationUnits, & (pNewAllocationUnit -> ListEntry)) ;

        pNewAllocationUnit -> dwInUseCount = 0 ;
    }

    void
    MaybeRecycleAllocationUnit_ (
        IN  ALLOCATION_UNIT <T> *   pAllocationUnit
        )
    {
        DWORD   i ;

        if (pAllocationUnit -> dwInUseCount == 0 &&
            m_dwTotalFreeCount > dwAllocationQuantum) {

            for (i = 0; i < dwAllocationQuantum; i++) {
                FreeListPop_ (& (pAllocationUnit -> Container [i])) ;
            }

            RemoveEntryList (& (pAllocationUnit -> ListEntry)) ;

            delete pAllocationUnit ;
        }
    }

    void
    FreeListPush_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        InsertHeadList (& m_FreeList, & (pContainer -> ListEntry)) ;
        m_dwTotalFreeCount++ ;
    }

    void
    FreeListPop_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        RemoveEntryList (& (pContainer -> ListEntry)) ;
        m_dwTotalFreeCount-- ;
    }

    CONTAINER <T> *
    FreeListPop_ (
        )
    {
        LIST_ENTRY *    pListEntry ;
        CONTAINER <T> * pContainer ;

        if (IsListEmpty (& m_FreeList) == FALSE) {
            pListEntry = RemoveHeadList (& m_FreeList) ;
            m_dwTotalFreeCount-- ;

            pContainer = CONTAINING_RECORD (pListEntry, CONTAINER <T>, ListEntry) ;
            return pContainer ;
        }
        else {
            return NULL ;
        }
    }

    void
    InUseListPop_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        RemoveEntryList (& pContainer -> ListEntry) ;
    }

    void
    InUseListPush_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        InsertHeadList (& m_InUseList, & (pContainer -> ListEntry)) ;
    }

    public :

        TStructPool (
            ) : m_dwTotalFreeCount (0)
        {
            InitializeListHead (& m_AllocationUnits) ;
            InitializeListHead (& m_FreeList) ;
            InitializeListHead (& m_InUseList) ;
        }

        ~TStructPool (
            )
        {
            ALLOCATION_UNIT <T> *   pAllocationUnit ;
            LIST_ENTRY *            pListEntry ;

            while (IsListEmpty (& m_AllocationUnits) == FALSE) {
                pListEntry = RemoveHeadList (& m_AllocationUnits) ;
                pAllocationUnit = CONTAINING_RECORD (pListEntry, ALLOCATION_UNIT <T>, ListEntry) ;
                delete pAllocationUnit ;
            }
        }

        T *
        Get (
            )
        {
            ALLOCATION_UNIT <T> *   pAllocationUnit ;
            CONTAINER <T> *         pContainer ;

            pContainer = FreeListPop_ () ;
            if (!pContainer) {

                pAllocationUnit = new ALLOCATION_UNIT <T> ;
                if (!pAllocationUnit) {
                    return NULL ;
                }

                InitializeAllocationUnit_ (pAllocationUnit) ;
                ASSERT (IsListEmpty (& m_FreeList) == FALSE) ;

                pContainer = FreeListPop_ () ;
            }

            ASSERT (pContainer) ;

            GetOwningAllocationUnit_ (pContainer) -> dwInUseCount++ ;
            InUseListPush_ (pContainer) ;

            return & (pContainer -> Object) ;
        }

        void
        Recycle (
            IN  T * pObject
            )
        {
            CONTAINER <T> *         pContainer ;
            ALLOCATION_UNIT <T> *   pAllocationUnit ;

            pContainer = CONTAINER <T>::RecoverContainer (pObject) ;

            InUseListPop_ (pContainer) ;
            FreeListPush_ (pContainer) ;

            pAllocationUnit = GetOwningAllocationUnit_ (pContainer) ;
            pAllocationUnit -> dwInUseCount-- ;

            MaybeRecycleAllocationUnit_ (pAllocationUnit) ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTSmallMap
//  ----------------------------------------------------------------------------

template <
    class tKey,     //  <, >, == operators must work
    class tVal      //  = operator must work
    >
class CTSmallMap
{
    struct MAP_REF {
        tKey        key ;
        tVal        val ;
        MAP_REF *   pNext ;
    } ;

    TStructPool <MAP_REF>   m_MapRefPool ;
    MAP_REF *               m_pHead ;

    void
    Insert_ (
        IN  MAP_REF *   pMapRefNew
        )
    {
        MAP_REF **  ppCur ;

        ppCur = & m_pHead ;

        for (;;) {
            if (* ppCur) {
                if (pMapRefNew -> val <= (* ppCur) -> val) {
                    break ;
                }

                ppCur = & (* ppCur) -> pNext ;
            }
            else {
                break ;
            }
        }

        pMapRefNew -> pNext = (* ppCur) ;
        (* ppCur)           = pMapRefNew ;
    }

    public :

        CTSmallMap (
            ) : m_pHead (NULL) {}

        ~CTSmallMap (
            )
        {
            MAP_REF *   pDel ;

            while (m_pHead) {
                //  remove the head
                pDel = m_pHead ;
                m_pHead = m_pHead -> pNext ;

                m_MapRefPool.Recycle (pDel) ;
            }
        }

        BOOL
        Find (
            IN  tKey    key,
            OUT tVal *  ptVal
            )
        {
            MAP_REF *   pCur ;
            BOOL        r ;

            pCur = m_pHead ;

            r = FALSE ;

            while (pCur) {
                if (pCur -> key == key) {
                    (* ptVal) = pCur -> val ;
                    r = TRUE ;
                    break ;
                }

                pCur = pCur -> pNext ;
            }

            return r ;
        }

        BOOL
        CreateMap (
            IN  tKey    key,
            IN  tVal    val
            )
        {
            MAP_REF *   pMapRef ;
            BOOL        r ;
            tVal        valTmp ;

            r = Find (key, & valTmp) ;
            if (!r) {
                pMapRef = m_MapRefPool.Get () ;
                if (pMapRef) {
                    pMapRef -> key = key ;
                    pMapRef -> val = val ;

                    Insert_ (pMapRef) ;

                    //  success
                    r = TRUE ;
                }
                else {
                    //  memory allocation error
                    r = FALSE ;
                }
            }
            else {
                //  no duplicates allowed !!
                r = FALSE ;
            }

            return r ;
        }
} ;

//  ----------------------------------------------------------------------------
//  TCProducerConsumer
//  ----------------------------------------------------------------------------

template <
    class T,
    T * Recover (IN LIST_ENTRY * ple)
    >
static
T *
ListHeadPop (
    IN  LIST_ENTRY *    pleHead
    )
{
    LIST_ENTRY *    pleItem ;
    T *             pt ;

    if (!IsListEmpty (pleHead)) {
        pleItem = pleHead -> Flink ;
        RemoveEntryList (pleItem) ;

        pt = Recover (pleItem) ;
    }
    else {
        pt = NULL ;
    }

    return pt ;
}

template <class T>
class TCProducerConsumer
{
    struct OBJ_CONTAINER {
        T           tObj ;
        LIST_ENTRY  ListEntry ;

        static OBJ_CONTAINER * Recover (IN LIST_ENTRY * ple)
        {
            OBJ_CONTAINER * pObj ;
            pObj = CONTAINING_RECORD (ple, OBJ_CONTAINER, ListEntry) ;
            return pObj ;
        }
    } ;

    struct OBJ_REQUEST {
        HANDLE          hEvent ;
        DWORD           dwRetVal ;
        T               tObj ;
        LIST_ENTRY      ListEntry ;

        static OBJ_REQUEST * Recover (IN LIST_ENTRY * ple)
        {
            OBJ_REQUEST *   pObj ;
            pObj = CONTAINING_RECORD (ple, OBJ_REQUEST, ListEntry) ;
            return pObj ;
        }
    } ;

    CRITICAL_SECTION    m_crt ;
    LIST_ENTRY          m_PoolContainer ;
    LIST_ENTRY          m_PoolRequest ;
    LIST_ENTRY          m_AvailObj ;
    LIST_ENTRY          m_RequestQueue ;
    BOOL                m_fStateBlocking ;

    //  all counters are serialized during increment/decrement calls
    int                 m_iRequestQueueLen ;
    int                 m_iAvailCount ;
    int                 m_iPoolMaxContainers ;
    int                 m_iPoolContainers ;
    int                 m_iPoolMaxRequests ;
    int                 m_iPoolRequests ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    void SatisfyRequest_ (IN OBJ_REQUEST * pObjRequest, IN T tItem)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest -> tObj     = tItem ;
        pObjRequest -> dwRetVal = NOERROR ;

        SetEvent (pObjRequest -> hEvent) ;
    }

    void FailRequest_ (IN OBJ_REQUEST * pObjRequest)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest -> tObj     = NULL ;
        pObjRequest -> dwRetVal = ERROR_GEN_FAILURE ;

        SetEvent (pObjRequest -> hEvent) ;
    }

    void RequestPoolPush_ (IN OBJ_REQUEST * pObjRequest)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        if (m_iPoolRequests < m_iPoolMaxRequests) {
            InsertHeadList (& m_PoolRequest, & pObjRequest -> ListEntry) ;
            m_iPoolRequests++ ;
        }
        else {
            delete pObjRequest ;
        }
    }

    OBJ_REQUEST * RequestPoolPop_ ()
    {
        OBJ_REQUEST *   pObjRequest ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest = ListHeadPop <OBJ_REQUEST, OBJ_REQUEST::Recover> (& m_PoolRequest) ;
        if (pObjRequest) {
            ASSERT (m_iPoolRequests > 0) ;
            m_iPoolRequests-- ;
        }

        return pObjRequest ;
    }

    void ContainerPoolPush_ (IN OBJ_CONTAINER * pObjContainer)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        if (m_iPoolContainers < m_iPoolMaxContainers) {
            m_iPoolContainers++ ;
            InsertHeadList (& m_PoolContainer, & pObjContainer -> ListEntry) ;
        }
        else {
            delete pObjContainer ;
        }
    }

    OBJ_CONTAINER * ContainerAvailPop_ ()
    {
        OBJ_CONTAINER * pObjContainer ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjContainer = ListHeadPop <OBJ_CONTAINER, OBJ_CONTAINER::Recover> (& m_AvailObj) ;
        if (pObjContainer) {
            ASSERT (m_iAvailCount > 0) ;
            m_iAvailCount-- ;
        }

        return pObjContainer ;
    }

    void ContainerAvailPush_ (OBJ_CONTAINER * pObjContainer)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        m_iAvailCount++ ;
        InsertHeadList (& m_AvailObj, & pObjContainer -> ListEntry) ;
    }

    OBJ_CONTAINER * ContainerPoolPop_ ()
    {
        OBJ_CONTAINER * pObjContainer ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjContainer = ListHeadPop <OBJ_CONTAINER, OBJ_CONTAINER::Recover> (& m_PoolContainer) ;
        if (pObjContainer) {
            ASSERT (m_iPoolContainers > 0) ;
            m_iPoolContainers-- ;
        }

        return pObjContainer ;
    }

    OBJ_REQUEST * GetRequestObj_ ()
    {
        OBJ_REQUEST *   pObjRequest ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest = RequestPoolPop_ () ;
        if (!pObjRequest) {
            pObjRequest = new OBJ_REQUEST ;
            if (pObjRequest) {
                pObjRequest -> hEvent = CreateEvent (NULL, TRUE, FALSE, NULL) ;
                if (pObjRequest -> hEvent == NULL) {
                    delete pObjRequest ;
                    pObjRequest = NULL ;
                }
            }
        }
        else {
            ResetEvent (pObjRequest -> hEvent) ;
        }

        return pObjRequest ;
    }

    OBJ_CONTAINER * GetContainerObj_ ()
    {
        OBJ_CONTAINER * pObjContainer ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjContainer = ContainerPoolPop_ () ;
        if (!pObjContainer) {
            pObjContainer = new OBJ_CONTAINER ;
        }

        return pObjContainer ;
    }

    void RequestQueuePush_ (IN OBJ_REQUEST * pObjRequest)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        InsertTailList (& m_RequestQueue, & pObjRequest -> ListEntry) ;
        m_iRequestQueueLen++ ;
    }

    OBJ_REQUEST * RequestQueuePop_ ()
    {
        OBJ_REQUEST *   pObjRequest ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest = ListHeadPop <OBJ_REQUEST, OBJ_REQUEST::Recover> (& m_RequestQueue) ;
        if (pObjRequest) {
            m_iRequestQueueLen-- ;
        }

        return pObjRequest ;
    }

    public :

        TCProducerConsumer (
            IN  int iPoolMaxContainers  = INT_MAX,
            IN  int iPoolMaxRequests    = INT_MAX
            ) : m_iAvailCount           (0),
                m_iRequestQueueLen      (0),
                m_iPoolMaxRequests      (iPoolMaxRequests),
                m_iPoolRequests         (0),
                m_iPoolMaxContainers    (iPoolMaxContainers),
                m_iPoolContainers       (0),
                m_fStateBlocking        (TRUE)
        {
            InitializeCriticalSection (& m_crt) ;

            InitializeListHead (& m_PoolContainer) ;
            InitializeListHead (& m_PoolRequest) ;
            InitializeListHead (& m_AvailObj) ;
            InitializeListHead (& m_RequestQueue) ;
        }

        ~TCProducerConsumer (
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            OBJ_REQUEST *   pObjRequest ;

            ASSERT (IsListEmpty (& m_RequestQueue)) ;
            ASSERT (IsListEmpty (& m_AvailObj)) ;

            Lock_ () ;

            pObjRequest = RequestPoolPop_ () ; ;
            while (pObjRequest) {
                CloseHandle (pObjRequest -> hEvent) ;
                delete pObjRequest ;

                pObjRequest = RequestPoolPop_ () ; ;
            }

            pObjContainer = ContainerPoolPop_ () ;
            while (pObjContainer) {
                delete pObjContainer ;
                pObjContainer = ContainerPoolPop_ () ;
            }

            Unlock_ () ;

            ASSERT (m_iPoolContainers == 0) ;
            ASSERT (m_iPoolRequests == 0) ;

            DeleteCriticalSection (& m_crt) ;
        }

        DWORD
        Pop (
            OUT T * ptItem
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            OBJ_REQUEST *   pObjRequest ;
            DWORD           dw ;
            DWORD           r ;

            (* ptItem) = NULL ;

            Lock_ () ;

            pObjContainer = ContainerAvailPop_ () ;
            if (!pObjContainer) {
                if (m_fStateBlocking) {
                    pObjRequest = GetRequestObj_ () ;

                    if (pObjRequest) {
                        RequestQueuePush_ (pObjRequest) ;
                        Unlock_ () ;

                        r = WaitForSingleObject (pObjRequest -> hEvent, INFINITE) ;

                        if (r == WAIT_OBJECT_0) {

                            Lock_ () ;

                            dw = pObjRequest -> dwRetVal ;
                            if (dw == NOERROR) {
                                (* ptItem) = pObjRequest -> tObj ;
                            }
                        }
                        else {
                            dw = ERROR_GEN_FAILURE ;

                            Lock_ () ;
                        }

                        RequestPoolPush_ (pObjRequest) ;
                    }
                    else {
                        dw = ERROR_GEN_FAILURE ;
                    }
                }
                else {
                    dw = ERROR_GEN_FAILURE ;
                }
            }
            else {
                (* ptItem) = pObjContainer -> tObj ;
                ContainerPoolPush_ (pObjContainer) ;

                dw = NOERROR ;
            }

            Unlock_ () ;

            return dw ;
        }

        DWORD
        TryPop (
            OUT T * ptItem
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            DWORD           dw ;

            Lock_ () ;

            pObjContainer = ContainerAvailPop_ () ;
            if (pObjContainer) {
                (* ptItem) = pObjContainer -> tObj ;
                ContainerPoolPush_ (pObjContainer) ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            Unlock_ () ;

            return dw ;
        }

        DWORD
        Push (
            IN  T   tItem
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            OBJ_REQUEST *   pObjRequest ;
            DWORD           dw ;

            Lock_ () ;

            pObjRequest = RequestQueuePop_ () ;
            if (pObjRequest) {
                SatisfyRequest_ (pObjRequest, tItem) ;

                dw = NOERROR ;
            }
            else {
                pObjContainer = GetContainerObj_ () ;
                if (pObjContainer) {
                    pObjContainer -> tObj = tItem ;
                    ContainerAvailPush_ (pObjContainer) ;

                    dw = NOERROR ;
                }
                else {
                    dw = ERROR_GEN_FAILURE ;
                }
            }

            Unlock_ () ;

            return dw ;
        }

        void
        SetStateBlocking (
            )
        {
            Lock_ () ;
            m_fStateBlocking = TRUE ;
            Unlock_ () ;
        }

        void
        SetStateNonBlocking (
            )
        {
            OBJ_REQUEST *   pObjRequest ;

            Lock_ () ;

            m_fStateBlocking = FALSE ;

            pObjRequest = RequestQueuePop_ () ;
            if (pObjRequest) {
                FailRequest_ (pObjRequest) ;
            }

            Unlock_ () ;
        }

        //  all non-blocking - instantaneous values
        int AvailCount ()           { return m_iAvailCount ; }
        int RequestQueueLength ()   { return m_iRequestQueueLen ; }
        int ContainerPool ()        { return m_iPoolContainers ; }
        int RequestPool ()          { return m_iPoolRequests ; }
} ;

//  ----------------------------------------------------------------------------
//      TCDenseVector
//  ----------------------------------------------------------------------------

template <class T>
class TCDenseVector
/*++
    simple dense vector template;
    allocates from a specified heap or the process heap (default);
    grows and shrinks (reallocates) as required, as values are added and
      deleted;
    does not sort in any manner;
    can add member randomly; appending is most efficient
    can remove members randomly; deleted from end is most efficient
--*/
{
    //  default values
    enum {
        DEF_INITIAL_SIZE        = 4,    //  initialize size
        DEF_RESIZE_MULTIPLIER   = 2     //  multiplier/divisor of size
    } ;

    T *                 m_pVector ;                 //  vector of objects
    DWORD               m_cElements ;               //  number of elements; <= m_dwMaxSize
    DWORD               m_dwResizeMultiplier ;      //  resize/shrink multiplier/divisor
    DWORD               m_dwInitialSize ;           //  first allocation
    HANDLE              m_hHeap ;                   //  heap handle (not duplicated !)
    DWORD               m_dwMaxSize ;               //  current max size of vector
    CRITICAL_SECTION    m_crt ;                     //  used in the Lock/Unlock methods

    void
    MaybeGrow_ (
        )
    /*++
    --*/
    {
        T *     pNewVector ;
        DWORD   dwNewSize ;

        ASSERT (m_hHeap) ;

        //  if we're maxed out, grow the vector
        if (m_cElements == m_dwMaxSize) {

            if (m_pVector) {
                //  we've been called before, time to realloc

                ASSERT (m_dwMaxSize > 0) ;
                dwNewSize = m_dwResizeMultiplier * m_dwMaxSize ;

                pNewVector = reinterpret_cast <T *> (HeapReAlloc (
                                                        m_hHeap,
                                                        HEAP_GENERATE_EXCEPTIONS,
                                                        m_pVector,
                                                        dwNewSize * sizeof T
                                                        )) ;
            }
            else {
                //  this is the first time we are allocating
                dwNewSize = m_dwInitialSize ;

                pNewVector = reinterpret_cast <T *> (HeapAlloc (
                                                        m_hHeap,
                                                        HEAP_GENERATE_EXCEPTIONS,
                                                        dwNewSize * sizeof T
                                                        )) ;
            }

            //  specifying HEAP_GENERATE_EXCEPTIONS in the above calls ensures
            //  that the system will have raised an exception if there's
            //  insufficient memory
            ASSERT (pNewVector) ;

            //  reset array pointer and set the max size
            m_pVector = pNewVector ;
            m_dwMaxSize = dwNewSize ;
        }

        return ;
    }

    void
    MaybeShrink_ (
        )
    {
        T *     pNewVector ;
        DWORD   dwNewSize ;

        ASSERT (m_pVector) ;
        ASSERT (m_dwMaxSize > 0) ;
        ASSERT (m_dwResizeMultiplier > 0) ;
        ASSERT (m_hHeap) ;

        //  if we fall below the threshold, but are bigger than smallest size,
        //  try to realloc
        if (m_cElements >= m_dwInitialSize &&
            m_cElements <= (m_dwMaxSize / m_dwResizeMultiplier)) {

            dwNewSize = m_dwMaxSize / m_dwResizeMultiplier ;

            pNewVector = reinterpret_cast <T *> (HeapReAlloc (
                                                    m_hHeap,
                                                    HEAP_GENERATE_EXCEPTIONS,
                                                    m_pVector,
                                                    dwNewSize * sizeof T
                                                    )) ;

            //  specifying HEAP_GENERATE_EXCEPTIONS in the above calls ensures
            //  that the system will have raised an exception if there's
            //  insufficient memory
            ASSERT (pNewVector) ;

            //  reset array pointer and set the max size
            m_dwMaxSize = dwNewSize ;
            m_pVector = pNewVector ;
        }

        return ;
    }

    public :

        TCDenseVector (
            IN  HANDLE      hHeap               = NULL,                     //  could specify the heap handle
            IN  DWORD       dwInitialSize       = DEF_INITIAL_SIZE,         //  initial entries allocation
            IN  DWORD       dwResizeMultiplier  = DEF_RESIZE_MULTIPLIER     //  resize multiplier/divisor
            ) : m_pVector               (NULL),
                m_dwResizeMultiplier    (dwResizeMultiplier),
                m_dwInitialSize         (dwInitialSize),
                m_dwMaxSize             (0),
                m_cElements             (0),
                m_hHeap                 (hHeap)
        {
            //  if no heap was specified, grab the process' heap handle
            if (!m_hHeap) {
                m_hHeap = GetProcessHeap () ;
            }

            InitializeCriticalSection (& m_crt) ;

            ASSERT (m_hHeap) ;
            ASSERT (dwResizeMultiplier > 0) ;
            ASSERT (dwInitialSize > 0) ;
        }

        ~TCDenseVector (
            )
        {
            //  there's nothing in the docs that says m_pVector can be NULL
            //  when calling HeapFree..
            if (m_pVector) {
                ASSERT (m_hHeap != NULL) ;
                HeapFree (
                    m_hHeap,
                    NULL,
                    m_pVector
                    ) ;
            }

            DeleteCriticalSection (& m_crt) ;
        }

        _inline
        const
        DWORD
        GetCount (
            )
        //  returns the number of elements currently in the vector
        {
            return m_cElements ;
        }

        __inline
        T *
        const
        GetVector (
            )
        //  returns the vector itself; caller then has direct access to the
        //  memory
        {
            return m_pVector ;
        }

        __inline
        void
        GetVector (
            OUT T **    ppT,
            OUT DWORD * pcElements
            )
        {
            ASSERT (ppT) ;
            ASSERT (pcElements) ;

            * ppT = m_pVector ;
            * pcElements = m_cElements ;
        }

        T
        operator [] (
            IN  DWORD   dwIndex
            )
        {
            T       t ;
            HRESULT hr ;

            hr = Get (dwIndex, & t) ;
            if (SUCCEEDED (hr)) {
                return t ;
            }
            else {
                return 0 ;
            }
        }

        __inline
        void
        Lock (
            )
        {
            EnterCriticalSection (& m_crt) ;
        }

        __inline
        void
        Unlock (
            )
        {
            LeaveCriticalSection (& m_crt) ;
        }

        __inline
        HRESULT
        const
        Get (
            IN  DWORD   dwIndex,
            OUT T *     pValue
            )
        //  returns the dwIndex'th element in the vector
        {
            ASSERT (pValue) ;

            if (dwIndex >= m_cElements) {
                return E_INVALIDARG ;
            }

            * pValue = m_pVector [dwIndex] ;

            return S_OK ;
        }

        HRESULT
        Append (
            IN  T       Value,
            OUT DWORD * pcTotalElements = NULL
            )
        /*++
            Purpose:

                Appends a new value to the end of the vector.  Optionally returns
                the number of elements in the vector.

            Parameters:

                Value               new item

                pcTotalElements     optional OUT parameter to return the number
                                      of elements in the vector AFTER the call;
                                      valid only if the call is successfull

            Return Values:

                S_OK                success
                E_OUTOFMEMORY       the vector is maxed and the memory reallocation
                                      failed

        --*/
        {
            return Insert (m_cElements,
                           Value,
                           pcTotalElements) ;
        }

        HRESULT
        Insert (
            IN  DWORD   dwIndex,
            IN  T       Value,
            OUT DWORD * pcTotalElements = NULL
            )
        /*++
            Purpose:

                Insert a new value at the specified Index

            Parameters:

                dwIndex             0-based index to the position where the
                                      new item should be inserted

                Value               new item

                pcTotalElements     optional OUT parameter to return the number
                                      of elements in the vector after the call;
                                      valid only if successfull

            Return Values:

                S_OK                success

                E_OUTOFMEMORY       the vector is maxed and the memory
                                      reallocation failed

                E_INVALIDARG        the specified index is out of range of the
                                      current contents of the vector; the min
                                      valid value is 0, and the max valid value
                                      is after the last elemtn

        --*/
        {
            //  make sure we're not going to insert off the end of the vector;
            //  m_cElements is the max valid index for a new element (in which
            //  case we are appending)
            if (dwIndex > m_cElements) {
                return E_INVALIDARG ;
            }

            //  if we didn't get this when we instantiated, we try again
            if (m_hHeap == NULL) {
                m_hHeap = GetProcessHeap () ;
                if (m_hHeap == NULL) {
                    return E_OUTOFMEMORY ;
                }
            }

            //  frame this in a try-except block to catch out-of-memory
            //  exceptions
            __try {
                MaybeGrow_ () ;
            }
            __except (GetExceptionCode () == STATUS_NO_MEMORY ||
                      GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                      EXCEPTION_EXECUTE_HANDLER :
                      EXCEPTION_CONTINUE_SEARCH) {

                return E_OUTOFMEMORY ;
            }

            //  the only failure to MaybeGrow_ is a win32 exception, so if we
            //  get to here, we've got the memory we need
            ASSERT (m_cElements < m_dwMaxSize) ;
            ASSERT (m_pVector) ;

            //  if there are elements to move, and we're not just appending, move
            //  the remaining elements out to make room
            if (m_cElements > 0 &&
                dwIndex < m_cElements) {

                //  expand
                MoveMemory (
                    & m_pVector [dwIndex + 1],
                    & m_pVector [dwIndex],
                    (m_cElements - dwIndex) * sizeof T
                    ) ;
            }

            //  insert the new item
            m_pVector [dwIndex] = Value ;
            m_cElements++ ;

            //  if the caller wants to know size, set that now
            if (pcTotalElements) {
                * pcTotalElements = m_cElements ;
            }

            return S_OK ;
        }

        HRESULT
        Remove (
            IN  DWORD   dwIndex,
            OUT T *     pValue = NULL
            )
        /*++
            Purpose:

                Removes an item at the specified 0-based index.  Optionally returns
                the value in the [out] parameter.

            Parameters:

                dwIndex     0-based index

                pValue      optional pointer to a value to obtain what was removed

            Return Values:

                S_OK            success

                E_INVALIDARG    an out-of-range index was specified

        --*/
        {
            ASSERT (m_hHeap != NULL) ;

            //  dwIndex is 0-based
            if (dwIndex >= m_cElements) {
                return E_INVALIDARG ;
            }

            //  if caller wants to get the Remove'd value, set it now
            if (pValue) {
                * pValue = m_pVector [dwIndex] ;
            }

            //  compact the remaining elements, unless we're removing the last element
            //  check above ensures that subtracting 1 does not wrap
            if (dwIndex < m_cElements - 1) {

                //  compact
                MoveMemory (
                        & m_pVector [dwIndex],
                        & m_pVector [dwIndex + 1],
                        (m_cElements - 1 - dwIndex) * sizeof T
                        ) ;
            }

            m_cElements-- ;

            __try {
                MaybeShrink_ () ;
            }
            __except (GetExceptionCode () == STATUS_NO_MEMORY ||
                      GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                      EXCEPTION_EXECUTE_HANDLER :
                      EXCEPTION_CONTINUE_SEARCH) {

                //  fail silently; we still have the memory we had before
            }

            return S_OK ;
        }
} ;

//  ----------------------------------------------------------------------------

//  ============================================================================
//  TCDynamicProdCons
//  ============================================================================

template <class T>
class TCDynamicProdCons
{
    TCProducerConsumer <T *>    m_Pool ;

    protected :

        LONG    m_lMaxAllocate ;
        LONG    m_lActualAllocated ;

        virtual T * NewObj_ () = 0 ;
        virtual void DeleteObj_ (T * pt) { delete pt ; }

    public :

        TCDynamicProdCons (
            IN  LONG    lMaxAllocate = LONG_MAX
            ) : m_lMaxAllocate      (lMaxAllocate),
                m_lActualAllocated  (0) {}

        virtual
        ~TCDynamicProdCons (
            )
        {
            T *     pObj ;
            DWORD   dw ;

            for (;;) {
                dw = m_Pool.TryPop (& pObj) ;
                if (dw == NOERROR) {
                    ASSERT (pObj) ;
                    ASSERT (m_lActualAllocated >= 0) ;

                    DeleteObj_ (pObj) ;
                    InterlockedDecrement (& m_lActualAllocated) ;
                }
                else {
                    break ;
                }
            }

            ASSERT (m_lActualAllocated == 0) ;
        }

        void SetMaxAllocate (IN LONG lMax)  { ::InterlockedExchange (& m_lMaxAllocate, lMax) ; }
        LONG GetCurMaxAllocate ()           { return m_lMaxAllocate ; }
        LONG GetAllocated ()                { return m_lActualAllocated ; }
        LONG GetAvailable ()                { return m_Pool.AvailCount () ; }
        void SetStateBlocking ()            { m_Pool.SetStateBlocking () ; }
        void SetStateNonBlocking ()         { m_Pool.SetStateNonBlocking () ; }

        T *
        TryGet (
            )
        {
            T *     pObj ;
            DWORD   dw ;

            dw = m_Pool.TryPop (& pObj) ;
            if (dw != NOERROR) {
                //  didn't get anything
                pObj = NULL ;

                //  may be able to allocate
                if (m_lActualAllocated < m_lMaxAllocate) {
                    pObj = NewObj_ () ;
                    if (pObj) {
                        ::InterlockedIncrement (& m_lActualAllocated) ;
                    }
                }
            }

            return pObj ;
        }

        T *
        Get (
            )
        {
            T *     pObj ;
            DWORD   dw ;

            pObj = TryGet () ;
            if (!pObj) {
                //  failed to get it non-blocking; blocking until we get 1
                dw = m_Pool.Pop (& pObj) ;
                if (dw != NOERROR) {
                    pObj = NULL ;
                }
            }

            return pObj ;
        }

        void
        Recycle (
            IN  T * pObj
            )
        {
            DWORD   dw ;

            ASSERT (m_lActualAllocated > 0) ;

            if (m_lActualAllocated <= m_lMaxAllocate) {
                dw = m_Pool.Push (pObj) ;
                if (dw != NOERROR) {
                    DeleteObj_ (pObj) ;
                    ::InterlockedDecrement (& m_lActualAllocated) ;
                }
            }
            else {
                DeleteObj_ (pObj) ;
                ::InterlockedDecrement (& m_lActualAllocated) ;
            }
        }
} ;

//  ============================================================================
//  CRatchetBuffer
//  ============================================================================

class CRatchetBuffer
{
    ULONGLONG   m_StaticBuffer ;
    BYTE *      m_pbBuffer ;
    DWORD       m_dwBufferLength ;

    void
    FreeBuffer_ (
        )
    {
        if (m_pbBuffer != (BYTE *) & m_StaticBuffer) {
            delete [] m_pbBuffer ;
        }

        m_pbBuffer = NULL ;
    }

    public :

        CRatchetBuffer (
            ) : m_pbBuffer          (NULL),
                m_dwBufferLength    (0) {}

        ~CRatchetBuffer (
            )
        {
            FreeBuffer_ () ;
        }

        DWORD
        SetMinLen (
            IN  DWORD   dwLen
            )
        {
            BYTE *  pbNewBuffer ;

            if (dwLen > m_dwBufferLength) {

                //  try to set it
                if (dwLen <= sizeof m_StaticBuffer) {
                    pbNewBuffer = (BYTE *) & m_StaticBuffer ;
                    dwLen = sizeof m_StaticBuffer ;
                }
                else {
                    pbNewBuffer = new BYTE [dwLen] ;
                }

                if (pbNewBuffer) {
                    FreeBuffer_ () ;

                    m_pbBuffer = pbNewBuffer ;
                    m_dwBufferLength = dwLen ;
                }
                else {
                    return ERROR_NOT_ENOUGH_MEMORY ;
                }
            }

            return NOERROR ;
        }

        DWORD
        Copy (
            IN  BYTE *  pb,
            IN  DWORD   dwLen
            )
        {
            DWORD   dw ;

            dw = SetMinLen (dwLen) ;
            if (dw == NOERROR) {
                CopyMemory (m_pbBuffer, pb, dwLen) ;
            }

            return dw ;
        }

        DWORD GetBufferLength ()    { return m_dwBufferLength ; }

        BYTE *
        Buffer (
            )
        {
            return m_pbBuffer ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTSortedList
//  ----------------------------------------------------------------------------

template <
    class T,        //  store this
    class K         //  use this as key (for sorting)
    >
class CTSortedList
{
    struct OBJ_CONTAINER {
        T               tPayload ;
        K               kVal ;
        OBJ_CONTAINER * pNext ;
    } ;

    OBJ_CONTAINER *     m_pContainerPool ;
    OBJ_CONTAINER *     m_pListHead ;
    OBJ_CONTAINER **    m_ppCur ;
    LONG                m_lListLen ;

    OBJ_CONTAINER *
    GetContainer_ (
        )
    {
        OBJ_CONTAINER * pContainer ;

        if (m_pContainerPool) {
            pContainer          = m_pContainerPool ;
            m_pContainerPool    = m_pContainerPool -> pNext ;
        }
        else {
            pContainer = new OBJ_CONTAINER ;
        }

        return pContainer ;
    }

    void
    RecycleContainer_ (
        IN  OBJ_CONTAINER * pContainer
        )
    {
        pContainer -> pNext = m_pContainerPool ;
        m_pContainerPool    = pContainer ;
    }

    DWORD
    GetCurContainer_ (
        OUT OBJ_CONTAINER **    ppContainer
        )
    {
        DWORD   dw ;

        if (m_ppCur &&
            (* m_ppCur)) {
            (* ppContainer) = (* m_ppCur) ;
            dw = NOERROR ;
        }
        else {
            dw = ERROR_GEN_FAILURE ;
        }

        return dw ;
    }

    protected :

        virtual void InsertNewContainer_ (
            IN  OBJ_CONTAINER * pNewContainer
            )
        {
            OBJ_CONTAINER **    ppCur ;

            ppCur = & m_pListHead ;

            for (;;) {
                if (* ppCur) {
                    if (pNewContainer -> kVal <= (* ppCur) -> kVal) {
                        break ;
                    }

                    ppCur = & (* ppCur) -> pNext ;
                }
                else {
                    break ;
                }
            }

            pNewContainer -> pNext  = (* ppCur) ;
            (* ppCur)               = pNewContainer ;

            m_lListLen++ ;
        }

    public :

        CTSortedList (
            ) : m_pListHead         (NULL),
                m_lListLen          (0),
                m_ppCur             (NULL),
                m_pContainerPool    (NULL)
        {
        }

        virtual
        ~CTSortedList (
            )
        {
            OBJ_CONTAINER * pContainer ;

            ASSERT (!m_pListHead) ;
            ASSERT (ListLen () == 0) ;

            while (m_pContainerPool) {
                pContainer = m_pContainerPool ;
                m_pContainerPool = m_pContainerPool -> pNext ;

                delete pContainer ;
            }
        }

        DWORD
        Insert (
            IN  T   tItem,
            IN  K   kVal
            )
        {
            OBJ_CONTAINER * pContainer ;
            DWORD           dw ;

            pContainer = GetContainer_ () ;
            if (pContainer) {

                pContainer -> tPayload  = tItem ;
                pContainer -> kVal      = kVal ;
                pContainer -> pNext     = pContainer ;

                InsertNewContainer_ (pContainer) ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_NOT_ENOUGH_MEMORY ;
            }

            return dw ;
        }

        DWORD
        SetPointer (
            IN  LONG    lIndex
            )
        {
            DWORD   dw ;
            LONG    i ;

            if (lIndex < m_lListLen) {
                m_ppCur = & m_pListHead ;
                for (i = 0; i < lIndex; i++) {
                    m_ppCur = & (* m_ppCur) -> pNext ;
                }

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD
        Advance (
            )
        {
            DWORD   dw ;

            if (m_ppCur &&
                (* m_ppCur) -> pNext) {

                m_ppCur = & (* m_ppCur) -> pNext ;

                dw = S_OK ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD
        GetCur (
            OUT T * ptVal
            )
        {
            OBJ_CONTAINER * pContainer ;
            DWORD           dw ;

            dw = GetCurContainer_ (& pContainer) ;
            if (dw == NOERROR) {
                (* ptVal) = pContainer -> tPayload ;
            }

            return dw ;
        }

        DWORD
        PopCur (
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            DWORD           dw ;

            if (m_ppCur) {
                pObjContainer = (* m_ppCur) ;
                (* m_ppCur) = pObjContainer -> pNext ;

                ASSERT (m_lListLen > 0) ;
                m_lListLen-- ;

                pObjContainer -> pNext = pObjContainer ;

                RecycleContainer_ (pObjContainer) ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        void
        ResetList (
            )
        {
            DWORD   dw ;

            dw = SetPointer (0) ;
            for (;dw == NOERROR && ListLen () > 0;) {
                dw = PopCur () ;
            }
        }

        LONG ListLen ()     { return m_lListLen ; }
} ;

//  ============================================================================
//  ============================================================================

class CSimpleBitfield
{
    int     m_cBits ;
    BYTE *  m_pBits ;
    int     m_ByteArrayLength ;
    int     m_cBitsSet ;

    size_t
    DivRoundUpMaybe_ (
        IN  int num,
        IN  int den
        )
    {
        return (num) / (den) + ((num) % (den) ? 1 : 0) ;
    }

    public :

        CSimpleBitfield (
            IN  int         cBits,
            OUT HRESULT *   phr
            ) : m_cBits     (cBits),
                m_pBits     (NULL),
                m_cBitsSet  (0)
        {
            m_ByteArrayLength = DivRoundUpMaybe_ (m_cBits, 8) ;

            m_pBits = new BYTE [m_ByteArrayLength] ;
            if (m_pBits == NULL) {
                (* phr) = E_OUTOFMEMORY ;
                goto cleanup ;
            }

            (* phr) = S_OK ;

            ClearAll () ;

            cleanup :

            return ;
        }

        ~CSimpleBitfield (
            )
        {
            delete [] m_pBits ;
        }

        int BitfieldSize () { return m_cBits ; }
        int BitsSet ()      { return m_cBitsSet ; }

        void
        ClearAll (
            )
        {
            ZeroMemory (m_pBits, m_ByteArrayLength) ;
            m_cBitsSet = 0 ;
        }

        void
        Set (int b)
        {
            int     iB ;
            int     ib ;
            BYTE    mask ;

            ASSERT (b <= m_cBits) ;

            if (!IsSet (b)) {
                m_cBitsSet++ ;
            }

            iB = b / 8 ;
            ib = b % 8 ;
            mask = 1 << ib ;
            m_pBits [iB] |= mask ;
        }

        void
        Unset (int b)
        {
            int     iB ;
            int     ib ;
            BYTE    mask ;

            ASSERT (b <= m_cBits) ;

            if (IsSet (b)) {
                ASSERT (m_cBitsSet > 0) ;
                m_cBitsSet-- ;
            }

            iB = b / 8 ;
            ib = b % 8 ;
            mask = ~(1 << ib) ;
            m_pBits [iB] &= mask ;
        }

        BOOL
        IsSet (int b)
        {
            int     iB ;
            int     ib ;
            BYTE    mask ;

            ASSERT (b <= m_cBits) ;

            iB = b / 8 ;
            ib = b % 8 ;
            mask = 1 << ib ;

            return m_pBits [iB] & mask ? TRUE : FALSE ;
        }
} ;

//  ============================================================================
//  shared memory object

class CWin32SharedMem
{
    BYTE *  m_pbShared ;
    DWORD   m_dwSize ;
    HANDLE  m_hMapping ;

    void
    Free_ (
        ) ;

    HRESULT
    Create_ (
        IN  TCHAR *     szName,
        IN  DWORD       dwSize,
        IN  PSECURITY_ATTRIBUTES       psa
        ) ;

    public :

        CWin32SharedMem (
            IN  TCHAR *     szName,
            IN  DWORD       dwSize,
            OUT HRESULT *   phr,
            IN  PSECURITY_ATTRIBUTES       psa = NULL
            ) ;

        virtual
        ~CWin32SharedMem (
            ) ;

        BYTE *  GetSharedMem ()     { return m_pbShared ; }
        DWORD   GetSharedMemSize () { return m_dwSize ; }
} ;

//  ============================================================================
//      TGenericMap
//  ============================================================================

template <
    class T,                            //  objects to store in this map
    class K,                            //  hash key type
    BOOL  fDuplicatesAllowed,           //  TRUE/FALSE if duplicates are allowed
    int   iAllocationUnitCount,         //  allocation quantum
    int   ulTableSize                   //  table size; must be prime
    >
class TGenericMap
/*++
    fixed size hash table; very simple
--*/
{
    /*++

      2      3      5      7     11     13     17     19     23     29
     31     37     41     43     47     53     59     61     67     71
     73     79     83     89     97    101    103    107    109    113
    127    131    137    139    149    151    157    163    167    173
    179    181    191    193    197    199    211    223    227    229
    233    239    241    251    257    263    269    271    277    281
    283    293    307    311    313    317    331    337    347    349
    353    359    367    373    379    383    389    397    401    409
    419    421    431    433    439    443    449    457    461    463
    467    479    487    491    499    503    509    521    523    541
    547    557    563    569    571    577    587    593    599    601
    607    613    617    619    631    641    643    647    653    659
    661    673    677    683    691    701    709    719    727    733
    739    743    751    757    761    769    773    787    797    809
    811    821    823    827    829    839    853    857    859    863
    877    881    883    887    907    911    919    929    937    941
    947    953    967    971    977    983    991    997   1009   1013

    --*/

    //  this structure references 1 entry
    struct TABLE_ENTRY {
        K           HashKey ;               //  hash key (hashed to get index)
        T           Object ;                //  object
        int         iAllocUnitIndex ;      //  index in the allocation unit
        LIST_ENTRY  ListEntry ;             //  listentry for in-use or free list
        LIST_ENTRY  HashList ;              //  list of TABLE_ENTRY with a common hash, or that are empty
    } ;

    //  this structure references a list of TABLE_ENTRYs, each of which
    //  hashes to the same value
    struct HASH_BUCKET {
        LIST_ENTRY  HashListHead ;
    } ;

    TStructPool <TABLE_ENTRY, iAllocationUnitCount> m_TableEntryPool ;

    HASH_BUCKET                     m_Table [ulTableSize] ;     //  table headers
    LIST_ENTRY                      m_EntryList ;               //  table entries in use
    CRITICAL_SECTION                m_crt ;                     //  crit sect for the lock

    void    Lock_ ()                { EnterCriticalSection (& m_crt) ; }
    void    Unlock_ ()              { LeaveCriticalSection (& m_crt) ; }
    BOOL    NoDuplicatesAllowed_ () { return fDuplicatesAllowed == FALSE ; }

    void
    HashListsPush_ (
        IN  ULONG           ulHashValue,
        IN  TABLE_ENTRY *   pTableEntry
        )
    {
        ASSERT (ulHashValue < ulTableSize) ;

        InsertHeadList (& (m_Table [ulHashValue].HashListHead), & (pTableEntry -> HashList)) ;
        InsertTailList (& m_EntryList, & (pTableEntry -> ListEntry)) ;
    }

    void
    HashListsPop_ (
        IN  TABLE_ENTRY *   pTableEntry
        )
    {
        RemoveEntryList (& (pTableEntry -> HashList)) ;
        RemoveEntryList (& (pTableEntry -> ListEntry)) ;
    }

    TABLE_ENTRY *
    FindInHashChain_ (
        IN  K               HashKey,                //  search for
        IN  LIST_ENTRY *    pListStartInclusive,    //  check this one
        IN  LIST_ENTRY *    pListStopExclusive      //  up to, but not including this one
        )
    //  if pListStartInclusive == pListStopExclusive, nothing is checked
    {
        TABLE_ENTRY *   pCurTableEntry ;
        TABLE_ENTRY *   pRetTableEntry ;
        LIST_ENTRY *    pListEntry ;

        pRetTableEntry = NULL ;

        for (pListEntry = pListStartInclusive ;
             pListEntry != pListStopExclusive ;
             pListEntry = pListEntry -> Flink) {

            pCurTableEntry = CONTAINING_RECORD (pListEntry, TABLE_ENTRY, HashList) ;
            if (pCurTableEntry -> HashKey == HashKey) {
                //  found a match
                pRetTableEntry = pCurTableEntry ;
                break ;
            }
        }

        return pRetTableEntry ;
    }

    TABLE_ENTRY *
    FindHashkey_ (
        IN  K       HashKey,
        IN  ULONG   ulHashValue
        )
    //  searches an entire list of the specified hashkey
    {
        return FindInHashChain_ (
                    HashKey,
                    m_Table [ulHashValue].HashListHead.Flink,   //  start
                    & (m_Table [ulHashValue].HashListHead)      //  end point
                    ) ;
    }

    TABLE_ENTRY *
    FindObject_ (
        IN  T       Object,
        IN  K       HashKey,
        IN  ULONG   ulHashValue
        )
    {
        TABLE_ENTRY *   pCurTableEntry ;
        LIST_ENTRY *    pTableHashListHead ;
        TABLE_ENTRY *   pRetTableEntry ;

        pRetTableEntry = NULL ;

        pTableHashListHead = & (m_Table [ulHashValue].HashListHead) ;

        pCurTableEntry = FindInHashChain_ (
                            HashKey,                        //  look for
                            pTableHashListHead -> Flink,    //  starting
                            pTableHashListHead              //  up to
                            ) ;

        while (pCurTableEntry) {

            ASSERT (pCurTableEntry -> HashKey == HashKey) ;

            if (pCurTableEntry -> Object == Object) {
                pRetTableEntry = pCurTableEntry ;
                break ;
            }

            //  find the next with same hashkey
            pCurTableEntry = FindInHashChain_ (
                                HashKey,                            //  look for
                                pCurTableEntry -> HashList.Flink,   //  starting with next
                                pTableHashListHead                  //  up to
                                ) ;
            }

        return pRetTableEntry ;
    }

    public :

        TGenericMap (
            )
        {
            ULONG   i ;

            InitializeCriticalSection (& m_crt) ;

            InitializeListHead (& m_EntryList) ;

            for (i = 0; i < ulTableSize; i++) {
                InitializeListHead (& (m_Table [i].HashListHead)) ;
            }
        }

        virtual
        ~TGenericMap (
            )
        {
            DeleteCriticalSection (& m_crt) ;
        }

        //  --------------------------------------------------------------------

        //  converts hashkey to a well-distributed ULONG value
        virtual ULONG   Value (IN K HashKey) = 0 ;

        //  --------------------------------------------------------------------

        ULONG
        Hash (
            IN  K HashKey
            )
        {
            return Value (HashKey) % ulTableSize ;
        }

        DWORD
        Store (
            IN  T   Object,
            IN  K   HashKey
            )
        {
            ULONG           ulHashValue ;
            TABLE_ENTRY *   pTableEntry ;
            DWORD           dwRet ;

            ulHashValue = Hash (HashKey) ;

            Lock_ () ;

            if (NoDuplicatesAllowed_ () &&
                FindHashkey_ (HashKey, ulHashValue) != NULL) {

                //  cannot have duplicates & one was found
                dwRet = ERROR_ALREADY_EXISTS ;
            }
            else {
                pTableEntry = m_TableEntryPool.Get () ;
                if (pTableEntry) {

                    pTableEntry -> Object   = Object ;
                    pTableEntry -> HashKey  = HashKey ;

                    HashListsPush_ (
                        ulHashValue,
                        pTableEntry
                        ) ;

                    //  success
                    dwRet = NOERROR ;
                }
                else {
                    //  failure
                    dwRet = ERROR_NOT_ENOUGH_MEMORY ;
                }
            }

            Unlock_ () ;

            return dwRet ;
        }

        DWORD
        Find (
            IN  K   HashKey,
            OUT T * pObject
            )
        {
            ULONG           ulHashValue ;
            TABLE_ENTRY *   pTableEntry ;
            DWORD           dwRet ;

            ASSERT (pObject) ;

            ulHashValue = Hash (HashKey) ;

            Lock_ () ;

            pTableEntry = FindHashkey_ (HashKey, ulHashValue) ;
            if (pTableEntry) {
                //  found
                * pObject = pTableEntry -> Object ;

                dwRet = NOERROR ;
            }
            else {
                //  not found
                dwRet = ERROR_SEEK ;
            }

            Unlock_ () ;

            return dwRet ;
        }

        DWORD
        FindSpecific (
            IN  T   Object,
            IN  K   HashKey
            )
        {
            ULONG           ulHashValue ;
            TABLE_ENTRY *   pTableEntry ;
            DWORD           dwRet ;

            ulHashValue = Hash (HashKey) ;

            Lock_ () ;

            pTableEntry = FindObject_ (Object, HashKey, ulHashValue) ;
            if (pTableEntry) {
                //  success
                dwRet = NOERROR ;
            }
            else {
                //  specific object was not found
                dwRet = ERROR_SEEK ;
            }

            Unlock_ () ;

            return dwRet ;
        }

        BOOL
        Exists (
            IN  K   HashKey
            )
        {
            DWORD   dwRet ;
            T       tTmp ;

            dwRet = Find (HashKey, & tTmp) ;

            return (dwRet == NOERROR) ;
        }

        DWORD
        Remove (
            IN  K   HashKey,
            OUT T * pObject = NULL
            )
        {
            ULONG           ulHashValue ;
            TABLE_ENTRY *   pTableEntry ;
            DWORD           dwRet ;

            ulHashValue = Hash (HashKey) ;

            Lock_ () ;

            pTableEntry = FindHashkey_ (HashKey, ulHashValue) ;
            if (pTableEntry) {
                if (pObject) {
                    (* pObject) = pTableEntry -> Object ;
                }

                HashListsPop_ (pTableEntry) ;
                m_TableEntryPool.Recycle (pTableEntry) ;

                //  success
                dwRet = NOERROR ;
            }
            else {
                //  nothing was found with the specified hashkey
                dwRet = ERROR_SEEK ;
            }

            Unlock_ () ;

            return dwRet ;
        }

        DWORD
        RemoveSpecific (
            IN  T   Object,
            IN  K   HashKey
            )
        {
            ULONG           ulHashValue ;
            TABLE_ENTRY *   pTableEntry ;
            DWORD           dwRet ;

            ulHashValue = Hash (HashKey) ;

            Lock_ () ;

            pTableEntry = FindObject_ (Object, HashKey, ulHashValue) ;
            if (pTableEntry) {
                HashListsPop_ (pTableEntry) ;
                m_TableEntryPool.Recycle (pTableEntry) ;

                //  success
                dwRet = NOERROR ;
            }
            else {
                //  not found
                dwRet = ERROR_SEEK ;
            }

            Unlock_ () ;

            return dwRet ;
        }

        void
        Clear (
            )
        {
            T   tTmp ;

            Lock_ () ;
            while (SUCCEEDED (RemoveFirst (& tTmp))) ;
            Unlock_ () ;
        }

        BOOL
        IsEmpty (
            )
        {
            return IsListEmpty (& m_EntryList) ;
        }

        DWORD
        RemoveFirst (
            OUT T *     pObject
            )
        {
            DWORD           dwRet ;
            TABLE_ENTRY *   pTableEntry ;
            LIST_ENTRY *    pListEntry ;

            Lock_ () ;

            if (IsListEmpty (& m_EntryList) == FALSE) {
                pListEntry = m_EntryList.Flink ;
                pTableEntry = CONTAINING_RECORD (pListEntry, TABLE_ENTRY, ListEntry) ;

                * pObject = pTableEntry -> Object ;

                HashListsPop_ (pTableEntry ) ;
                m_TableEntryPool.Recycle (pTableEntry) ;

                dwRet = NOERROR ;
            }
            else {
                dwRet = ERROR_SEEK ;
            }

            Unlock_ () ;

            return dwRet ;
        }
} ;

class CW32SID
{
    LONG    m_cRef ;
    PSID *  m_ppSID ;
    DWORD   m_cSID ;

    void
    DeleteSids_ (
        )
    {
        if (m_ppSID) {
            ASSERT (m_cSID) ;
            for (DWORD i = 0; i < m_cSID; i++) {
                delete [] (m_ppSID [i]) ;
            }

            delete [] m_ppSID ;
        }

        m_ppSID = NULL ;
        m_cSID  = 0 ;
    }

    DWORD
    CopySids_ (
        IN  PSID*   ppSidsParam,
        IN  DWORD   dwNumSidsParam
        )
    {
        DWORD   dwRet ;
        DWORD   iParam ;
        DWORD   jMember ;
        DWORD   dwSidLength ;

        if (dwNumSidsParam == 0 && ppSidsParam) {
            return ERROR_INVALID_PARAMETER ;
        }

        if (dwNumSidsParam > 0 && ppSidsParam == NULL) {
            return ERROR_INVALID_PARAMETER ;
        }

        ASSERT (!m_ppSID) ;
        ASSERT (!m_cSID) ;

        if (dwNumSidsParam == 0) {
            return NOERROR ;
        }

        m_ppSID = new PSID [dwNumSidsParam] ;
        if (!m_ppSID) {
            return ERROR_NOT_ENOUGH_MEMORY ;
        }

        m_cSID = dwNumSidsParam ;

        ::ZeroMemory (m_ppSID, m_cSID * sizeof PSID);

        for (iParam = 0, jMember = 0; iParam < dwNumSidsParam ; iParam++, jMember++) {

            //  validate
            if (!ppSidsParam [iParam] ||
                !::IsValidSid (ppSidsParam [iParam])
                )
            {
                dwRet = ::GetLastError();

                if (!ppSidsParam[iParam]) {
                    dwRet = ERROR_INVALID_PARAMETER ;
                }

                goto cleanup ;
            }

            dwSidLength = ::GetLengthSid (ppSidsParam [iParam]) ;

            m_ppSID[jMember] = new BYTE [dwSidLength] ;

            if (!m_ppSID [jMember]) {
                dwRet = ERROR_NOT_ENOUGH_MEMORY ;
                goto cleanup ;
            }

            if (!::CopySid (dwSidLength, m_ppSID [jMember], ppSidsParam [iParam])) {
                dwRet = ::GetLastError();
                goto cleanup ;
            }
        }

        dwRet = NOERROR ;

        cleanup :

        if (dwRet != NOERROR) {
            DeleteSids_ () ;
        }

        return dwRet ;
    }



    public :

        CW32SID (
            IN  PSID *  ppSID,
            IN  DWORD   cSID,
            OUT DWORD * pdw
            ) : m_cRef  (0),
                m_ppSID (NULL),
                m_cSID  (0)
        {
            ASSERT (pdw) ;
            (* pdw) = CopySids_ (ppSID, cSID) ;
        }

        ~CW32SID (
            )
        {
            DeleteSids_ () ;
        }

        LONG
        AddRef (
            )
        {
            return ::InterlockedIncrement (& m_cRef) ;
        }

        LONG
        Release (
            )
        {
            if (::InterlockedDecrement (& m_cRef) == 0) {
                delete this ;
                return 0 ;
            }

            return 1 ;
        }

        PSID *  ppSID ()    { return m_ppSID ; }
        DWORD   Count ()    { return m_cSID ; }
} ;

//  ============================================================================
//  CTimeBracket
//  ============================================================================

//  not serialized
class CTimeBracket
{
    DWORD       m_dwStartMillis ;
    const DWORD m_dwMaxAllowableElapsed ;

    public :

        CTimeBracket (
            IN  DWORD   dwMaxElapsed
            ) : m_dwStartMillis         (0),
                m_dwMaxAllowableElapsed (dwMaxElapsed) {}

        void    Restart ()          { m_dwStartMillis = ::timeGetTime () ; }
        DWORD   ElapsedMillis ()    { return Min <DWORD> (m_dwMaxAllowableElapsed, ::timeGetTime () - m_dwStartMillis) ; }
} ;

//  ============================================================================
//  CTSmoothingFilter
//  ============================================================================

/*++
    smooths from 0 (after reset) to the target value; as the target value is
    updated, will tend towards it, but within the constraints of a max step
    value (per sec) specified; when reset, starts again at 0; target value
    can be updated anytime, but should be 0-based
--*/
template <class T>
class CTSmoothingFilter
{
    enum {
        DEF_BUCKET_MILLIS = 10
    } ;

    T                   m_tTargetVal ;
    T                   m_tCurVal ;
    CRITICAL_SECTION    m_crt ;
    T                   m_tMaxStepPerMilli ;
    CTimeBracket        m_TimeBracket ;
    T                   m_tCurAllowableError ;
    double              m_dAllowableErrorDegradation ;

    void Lock_ ()       { ::EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { ::LeaveCriticalSection (& m_crt) ; }

    public :

        CTSmoothingFilter (
            IN  T       tMaxStepPerMilli,
            IN  double  dAllowableErrorDegradation,
            IN  DWORD   dwBucketMillis = DEF_BUCKET_MILLIS
            ) : m_tMaxStepPerMilli              (tMaxStepPerMilli),
                m_dAllowableErrorDegradation    (dAllowableErrorDegradation),
                m_TimeBracket                   (dwBucketMillis)
        {
            ::InitializeCriticalSection (& m_crt) ;
            Reset () ;

            ASSERT (tMaxStepPerMilli != 0) ;
        }

        ~CTSmoothingFilter (
            )
        {
            ::DeleteCriticalSection (& m_crt) ;
        }

        void
        Reset (
            IN  T   tStartVal = 0
            )
        {
            Lock_ () ;

            m_tTargetVal            = tStartVal ;
            m_tCurVal               = tStartVal ;
            m_tCurAllowableError    = 0 ;

            m_TimeBracket.Restart () ;

            Unlock_ () ;
        }

        T TargetVal ()  { return m_tTargetVal ; }
        T CurVal ()     { return m_tCurVal ; }

        T
        AdjustCurVal (
            )
        {
            T       tCurVal ;
            T       tCurDelta ;
            T       tStep ;
            DWORD   dwElapsedMillis ;

            Lock_ () ;

            if (m_tCurVal != m_tTargetVal) {

                if (m_tTargetVal > m_tCurVal + m_tCurAllowableError) {
                    //  ----------------------------------------------------------------
                    //  adjust up

                    dwElapsedMillis = m_TimeBracket.ElapsedMillis () ;
                    if (dwElapsedMillis > 0) {

                        //  delta
                        tCurDelta = Abs <T> (m_tTargetVal - m_tCurVal) ;

                        //  step
                        tStep = Min <T> (tCurDelta, m_tMaxStepPerMilli * dwElapsedMillis) ;

                        //  adjust
                        m_tCurVal += tStep ;

                        //TRACE_4 (LOG_TIMING, 1, TEXT ("UP (elapsed = %u) CurDelta = %I64d; Step = %I64d; curval = %I64d ms"), dwElapsedMillis, tCurDelta, tStep, m_tCurVal/10000) ;

                        //  set our bracket
                        m_tCurAllowableError = Min <T> (tCurDelta, m_tCurAllowableError) ;

                        //  start our timer again
                        m_TimeBracket.Restart () ;
                    }
                }
                else if (m_tTargetVal < m_tCurVal - m_tCurAllowableError) {
                    //  ----------------------------------------------------------------
                    //  adjust down

                    dwElapsedMillis = m_TimeBracket.ElapsedMillis () ;
                    if (dwElapsedMillis > 0) {
                        //  delta
                        tCurDelta = Abs <T> (m_tCurVal - m_tTargetVal) ;

                        //  step
                        tStep = Min <T> (tCurDelta, m_tMaxStepPerMilli * dwElapsedMillis) ;

                        //TRACE_4 (LOG_TIMING, 1, TEXT ("DOWN (elapsed = %u) CurDelta = %I64d; Step = %I64d; curval = %I64d ms"), dwElapsedMillis, tCurDelta, tStep, m_tCurVal/10000) ;

                        //  adjust
                        m_tCurVal -= tStep ;

                        //  set our bracket
                        m_tCurAllowableError = Min <T> (tCurDelta, m_tCurAllowableError) ;

                        //  start our timer again
                        m_TimeBracket.Restart () ;
                    }
                }
                else {
                    //  ----------------------------------------------------------------
                    //  degrade our allowable error bracket

                    m_tCurAllowableError = (T) (m_dAllowableErrorDegradation * (double) m_tCurAllowableError) ;
                    //TRACE_1 (LOG_TIMING, 1, TEXT ("DEGRADE m_tCurAllowableError = %I64d"), m_tCurAllowableError) ;
                }
            }

            tCurVal = m_tCurVal ;

            Unlock_ () ;

            return tCurVal ;
        }

        void
        SetTargetVal (
            IN  T   tVal
            )
        {
            Lock_ () ;
            m_tTargetVal = tVal ;
            Unlock_ () ;
        }
} ;

//  ============================================================================
//  CTSampleRate
//  ============================================================================

template <
    class   tMillis,
    DWORD   cMaxBrackets,
    tMillis BracketDurationMillis,
    DWORD   cMinUsableBrackets
    >
class CTSampleRate
{
    struct BRACKET_POINT {
        tMillis     Millis ;
        ULONGLONG   cSamples ;
    } ;

    BRACKET_POINT   m_Queue [cMaxBrackets] ;
    DWORD           m_dwSettlingVal ;
    DWORD           m_Head ;
    DWORD           m_Tail ;
    DWORD           m_cSamplesPerSec ;
    tMillis         m_cMaxQueueMillis ;
    ULONGLONG       m_cSamples ;

    DWORD Index_ (IN DWORD dwIndex)     { return dwIndex % cMaxBrackets ; }
    DWORD CurBracketCount_ ()           { return m_Tail - m_Head + 1 ; }
    BRACKET_POINT * Head_ ()            { return & m_Queue [Index_ (m_Head)] ; }
    BRACKET_POINT * Tail_ ()            { return & m_Queue [Index_ (m_Tail)] ; }

    void
    QueueBracket_ (
        IN  ULONGLONG   cSamples,
        IN  tMillis     Millis
        )
    {
        ASSERT (CurBracketCount_ () < cMaxBrackets) ;

        m_Tail++ ;

        Tail_ () -> cSamples    = cSamples ;
        Tail_ () -> Millis      = Millis ;
    }

    void
    TrimQueue_ (
        IN  tMillis Millis
        )
    {
        while (CurBracketCount_ () > 0) {
            if (Millis - Head_ () -> Millis >= m_cMaxQueueMillis) {
                m_Head++ ;
            }
            else {
                break ;
            }
        }
    }

    void
    ComputeSampleRate_ (
        )
    {
        double  dDelta_Millis ;
        double  dDelta_Samples ;

        ASSERT (CurBracketCount_ () <= cMaxBrackets) ;

        if (CurBracketCount_ () >= cMinUsableBrackets) {

            dDelta_Millis  = (double) (Tail_ () -> Millis - Head_ () -> Millis) ;
            dDelta_Samples = (double) (LONGLONG) (Tail_ () -> cSamples - Head_ () -> cSamples) ;

            if (dDelta_Millis > 0) {
                m_cSamplesPerSec = (DWORD) (dDelta_Samples / (dDelta_Millis / 1000.0)) ;
            }
        }
    }

    public :

        CTSampleRate (
            IN  DWORD   dwSettlingVal
            ) : m_Head              (1),
                m_Tail              (0),
                m_dwSettlingVal     (dwSettlingVal),
                m_cSamplesPerSec    (dwSettlingVal),
                m_cMaxQueueMillis   (cMaxBrackets * BracketDurationMillis),
                m_cSamples          (0)
        {
            Reset () ;
        }

        DWORD
        OnSample (
            IN  tMillis     Millis,
            IN  ULONGLONG   cSamples = 1
            )
        {
            m_cSamples += cSamples ;

            TrimQueue_ (Millis) ;

            if (CurBracketCount_ () == 0 ||
                (Millis - Tail_ () -> Millis) > BracketDurationMillis) {

                QueueBracket_ (m_cSamples, Millis) ;
                ComputeSampleRate_ () ;
            }

            return m_cSamplesPerSec ;
        }

        DWORD CurSampleRate ()  { return m_cSamplesPerSec ; }
        void  Reset ()          { m_Tail = 0 ; m_Head = 1 ; m_cSamplesPerSec = m_dwSettlingVal ; m_cSamples = 0 ; }
        DWORD Length ()         { return CurBracketCount_ () ; }
} ;

#endif  //  _tsdvr__dvrw32_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\inc\asferr.h ===
///////////////////////////////////////////////////////////////////////////
//
// ASFErr.h - definition of ASF HRESULT codes
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
// This file is generated by the MC tool from ASFErr.mc
//

#ifndef _ASFERR_H
#define _ASFERR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Errors (2000 - 2999)
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ASF_E_BUFFEROVERRUN
//
// MessageText:
//
//  An attempt was made to seek or position past the end of a buffer.%0
//
#define ASF_E_BUFFEROVERRUN              0xC00D07D0L

//
// MessageId: ASF_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The supplied input or output buffer was too small.%0
//
#define ASF_E_BUFFERTOOSMALL             0xC00D07D1L

//
// MessageId: ASF_E_BADLANGUAGEID
//
// MessageText:
//
//  The language ID was not found.%0
//
#define ASF_E_BADLANGUAGEID              0xC00D07D2L

//
// MessageId: ASF_E_NOPAYLOADLENGTH
//
// MessageText:
//
//  The multiple payload packet is missing the payload length.%0
//
#define ASF_E_NOPAYLOADLENGTH            0xC00D07DBL

//
// MessageId: ASF_E_TOOMANYPAYLOADS
//
// MessageText:
//
//  The packet contains too many payloads.%0
//
#define ASF_E_TOOMANYPAYLOADS            0xC00D07DCL

//
// MessageId: ASF_E_PACKETCONTENTTOOLARGE
//
// MessageText:
//
//  ASF_E_PACKETCONTENTTOOLARGE
//
#define ASF_E_PACKETCONTENTTOOLARGE      0xC00D07DEL

//
// MessageId: ASF_E_UNKNOWNPACKETSIZE
//
// MessageText:
//
//  Expecting a fixed packet size but min. and max. are not equal.%0
//
#define ASF_E_UNKNOWNPACKETSIZE          0xC00D07E0L

//
// MessageId: ASF_E_INVALIDHEADER
//
// MessageText:
//
//  ASF_E_INVALIDHEADER
//
#define ASF_E_INVALIDHEADER              0xC00D07E2L

//
// MessageId: ASF_E_NOCLOCKOBJECT
//
// MessageText:
//
//  The object does not have a valid clock object.%0
//
#define ASF_E_NOCLOCKOBJECT              0xC00D07E6L

//
// MessageId: ASF_E_UNKNOWNCLOCKTYPE
//
// MessageText:
//
//  ASF_E_UNKNOWNCLOCKTYPE
//
#define ASF_E_UNKNOWNCLOCKTYPE           0xC00D07EBL

//
// MessageId: ASF_E_OPAQUEPACKET
//
// MessageText:
//
//  An attempt was made to restore or access an opaque packet.%0
//
#define ASF_E_OPAQUEPACKET               0xC00D07EDL

//
// MessageId: ASF_E_WRONGVERSION
//
// MessageText:
//
//  ASF_E_WRONGVERSION
//
#define ASF_E_WRONGVERSION               0xC00D07EEL

//
// MessageId: ASF_E_OVERFLOW
//
// MessageText:
//
//  An attempt was made to store a value which was larger than then destination's maximum value.%0
//
#define ASF_E_OVERFLOW                   0xC00D07EFL

//
// MessageId: ASF_E_NOTFOUND
//
// MessageText:
//
//  The object was not found.%0
//
#define ASF_E_NOTFOUND                   0xC00D07F0L

//
// Someone else is using MessageIds 2033 & 2034, so we skip them
// 
// 2033 = NS_E_NOTHING_TO_DO
// 2034 = NS_E_NO_MULTICAST

//
// MessageId: ASF_E_OBJECTTOOBIG
//
// MessageText:
//
//  The object is too large to be processed in the requested manner.%0
//
#define ASF_E_OBJECTTOOBIG               0xC00D07F3L

//
// MessageId: ASF_E_UNEXPECTEDVALUE
//
// MessageText:
//
//  A value was not set as expected.%0
//
#define ASF_E_UNEXPECTEDVALUE            0xC00D07F4L

//
// MessageId: ASF_E_INVALIDSTATE
//
// MessageText:
//
//  The request is not valid in the object's current state.%0
//
#define ASF_E_INVALIDSTATE               0xC00D07F5L

//
// MessageId: ASF_E_NOLIBRARY
//
// MessageText:
//
//  This object does not have a valid library pointer; it was not properly created or it has been Shutdown().%0
//
#define ASF_E_NOLIBRARY                  0xC00D07F6L

//
// MessageId: ASF_E_ALREADYINITIALIZED
//
// MessageText:
//
//  This object has already been initialized; the setting cannot be changed.%0
//
#define ASF_E_ALREADYINITIALIZED         0xC00D07F7L

//
// MessageId: ASF_E_INVALIDINIT
//
// MessageText:
//
//  This object has not been initialized properly; that operation cannot be performed.%0
//
#define ASF_E_INVALIDINIT                0xC00D07F8L

//
// MessageId: ASF_E_NOHEADEROBJECT
//
// MessageText:
//
//  The ASF Header object could not be found.%0
//
#define ASF_E_NOHEADEROBJECT             0xC00D07F9L

//
// MessageId: ASF_E_NODATAOBJECT
//
// MessageText:
//
//  The ASF Data object could not be found.%0
//
#define ASF_E_NODATAOBJECT               0xC00D07FAL

//
// MessageId: ASF_E_NOINDEXOBJECT
//
// MessageText:
//
//  The ASF Index object could not be found.%0
//
#define ASF_E_NOINDEXOBJECT              0xC00D07FBL

//
// MessageId: ASF_E_NOSTREAMPROPS
//
// MessageText:
//
//  A Stream Properties object with the correct stream number could not be found.%0
//
#define ASF_E_NOSTREAMPROPS              0xC00D07FCL

//
// MessageId: ASF_E_NOFILEPROPS
//
// MessageText:
//
//  The File Properties object could not be found.%0
//
#define ASF_E_NOFILEPROPS                0xC00D07FDL

//
// MessageId: ASF_E_NOLANGUAGELIST
//
// MessageText:
//
//  The Language List object could not be found.%0
//
#define ASF_E_NOLANGUAGELIST             0xC00D07FEL

//
// MessageId: ASF_E_NOINDEXPARAMETERS
//
// MessageText:
//
//  The Index Parameters object could not be found.%0
//
#define ASF_E_NOINDEXPARAMETERS          0xC00D07FFL

//
// MessageId: ASF_E_UNSUPPORTEDERRORCONCEALMENT
//
// MessageText:
//
//  The requested error concealment strategy is not supported by this component.%0
//
#define ASF_E_UNSUPPORTEDERRORCONCEALMENT 0xC00D0800L

//
// MessageId: ASF_E_INVALIDFLAGS
//
// MessageText:
//
//  The flags for this object or set of objects are not properly set.%0
//
#define ASF_E_INVALIDFLAGS               0xC00D0801L

//
// MessageId: ASF_E_BADDATADESCRIPTOR
//
// MessageText:
//
//  One or more data descriptors is not properly set.%0
//
#define ASF_E_BADDATADESCRIPTOR          0xC00D0802L

//
// MessageId: ASF_E_BADINDEXINTERVAL
//
// MessageText:
//
//  The index has an invalid time interval (probably zero).%0
//
#define ASF_E_BADINDEXINTERVAL           0xC00D0803L

//
// MessageId: ASF_E_INVALIDTIME
//
// MessageText:
//
//  The given time value is not valid.%0
//
#define ASF_E_INVALIDTIME                0xC00D0804L

//
// MessageId: ASF_E_INVALIDINDEX
//
// MessageText:
//
//  The given index value is not valid.%0
//
#define ASF_E_INVALIDINDEX               0xC00D0805L

//
// MessageId: ASF_E_STREAMNUMBERINUSE
//
// MessageText:
//
//  The specified stream number is already in use.%0
//
#define ASF_E_STREAMNUMBERINUSE          0xC00D0806L

//
// MessageId: ASF_E_BADMEDIATYPE
//
// MessageText:
//
//  The specified media type does not work with this component.%0
//
#define ASF_E_BADMEDIATYPE               0xC00D0807L

//
// MessageId: ASF_E_WRITEFAILED
//
// MessageText:
//
//  The object could not be written as specified.%0
//
#define ASF_E_WRITEFAILED                0xC00D0808L

//
// MessageId: ASF_E_NOTENOUGHDESCRIPTORS
//
// MessageText:
//
//  The given data unit requires a larger number of descriptors to be fully parsed.%0
//
#define ASF_E_NOTENOUGHDESCRIPTORS       0xC00D0809L

//
// MessageId: ASF_E_INDEXBLOCKUNLOADED
//
// MessageText:
//
//  The index entries for the specified index block have been unloaded from memory and are not available.%0
//
#define ASF_E_INDEXBLOCKUNLOADED         0xC00D080AL

//
// MessageId: ASF_E_NOTENOUGHBANDWIDTH
//
// MessageText:
//
//  The specified bandwidth is not large enough.%0
//
#define ASF_E_NOTENOUGHBANDWIDTH         0xC00D080BL

//
// MessageId: ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE
//
// MessageText:
//
//  The object has exceeded its maximum size.%0
//
#define ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE  0xC00D080CL

//
// MessageId: ASF_E_BADDATAUNIT
//
// MessageText:
//
//  The given data unit is corrupted, badly formatted, or otherwise not valid.%0
//
#define ASF_E_BADDATAUNIT                0xC00D080DL

//
// MessageId: ASF_E_HEADERSIZE
//
// MessageText:
//
//  The ASF header has exceeded the specified maximum size.%0
//
#define ASF_E_HEADERSIZE                 0xC00D080EL


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Success Codes (2000 - 2999)
//

//
// MessageId: ASF_S_OPAQUEPACKET
//
// MessageText:
//
//  ASF_S_OPAQUEPACKET
//
#define ASF_S_OPAQUEPACKET               0x000D07F0L


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Warnings (2000 - 2999)
//


#endif // _ASFERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\util\dvrutil.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrutil.cpp

    Abstract:

        This module the ts/dvr-wide utility code; compiles into a .LIB

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

BOOL
IsBlankMediaType (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    BOOL    r ;

    r = (pmt -> majortype   == GUID_NULL &&
         pmt -> subtype     == GUID_NULL &&
         pmt -> formattype  == GUID_NULL ? TRUE : FALSE) ;

    return r ;
}

BOOL
IsAMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (pmt -> majortype == MEDIATYPE_Video ? TRUE : FALSE) ;
}

BOOL
IsWMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    //  GUIDs are the same
    return IsAMVideo (pmt) ;
}

BOOL
IsAMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (pmt -> majortype == MEDIATYPE_Audio ? TRUE : FALSE) ;
}

BOOL
IsWMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    //  GUIDs are the same
    return IsAMAudio (pmt) ;
}

BOOL
IsGenericVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (g_fRegGenericStreams_Video && pmt -> majortype == GENERIC_MEDIATYPE_Video) ;
}

BOOL
IsGenericAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (g_fRegGenericStreams_Audio && pmt -> majortype == GENERIC_MEDIATYPE_Audio) ;
}

BOOL
IsVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (IsAMVideo (pmt) || IsWMVideo (pmt) || IsGenericVideo (pmt)) ;
}

BOOL
IsAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (IsAMAudio (pmt) || IsWMAudio (pmt) || IsGenericAudio (pmt)) ;
}

BOOL
AMMediaIsTimestamped (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    BOOL    r ;

    r = (IsAMVideo (pmt) || IsAMAudio (pmt) ? TRUE : FALSE) ;

    return r ;
}

BOOL
IsMpeg2Video (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    BOOL    r ;
    GUID *  pguidTagged ;

    ASSERT (pmt) ;

    r = FALSE ;

    if (IsVideo (pmt)) {

        if (pmt -> subtype == MEDIASUBTYPE_MPEG2_VIDEO) {
            //  unencrypted media type
            r = TRUE ;
        }
        else if (pmt -> subtype == MEDIASUBTYPE_ETDTFilter_Tagged_SBE &&
                 pmt -> cbFormat >= 2 * sizeof GUID) {

            //  encrypted; check if it's mpeg-2

            pguidTagged = (GUID *) ((pmt -> pbFormat + pmt -> cbFormat) - (2 * sizeof GUID)) ;
            ASSERT ((BYTE *) pguidTagged >= pmt -> pbFormat) ;

            if (pguidTagged [0] == MEDIASUBTYPE_MPEG2_VIDEO) {
                r = TRUE ;
            }
        }
    }

    return r ;
}

BOOL
IsMpeg2Audio (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    BOOL    r ;
    GUID *  pguidTagged ;

    ASSERT (pmt) ;

    r = FALSE ;

    if (IsAudio (pmt)) {

        if (pmt -> subtype == MEDIASUBTYPE_MPEG2_AUDIO) {
            //  unencrypted media type
            r = TRUE ;
        }
        else if (pmt -> subtype == MEDIASUBTYPE_ETDTFilter_Tagged_SBE &&
                 pmt -> cbFormat >= 2 * sizeof GUID) {

            //  encrypted; check if it's mpeg-2

            pguidTagged = (GUID *) ((pmt -> pbFormat + pmt -> cbFormat) - (2 * sizeof GUID)) ;
            ASSERT ((BYTE *) pguidTagged >= pmt -> pbFormat) ;

            if (pguidTagged [0] == MEDIASUBTYPE_MPEG2_AUDIO) {
                r = TRUE ;
            }
        }
    }

    return r ;
}

BOOL
IsDolbyAc3Audio (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    BOOL    r ;
    GUID *  pguidTagged ;

    ASSERT (pmt) ;

    r = FALSE ;

    if (IsAudio (pmt)) {

        if (pmt -> subtype == MEDIASUBTYPE_DOLBY_AC3) {
            //  unencrypted media type
            r = TRUE ;
        }
        else if (pmt -> subtype == MEDIASUBTYPE_ETDTFilter_Tagged_SBE &&
                 pmt -> cbFormat >= 2 * sizeof GUID) {

            //  encrypted; check if it's ac-3

            pguidTagged = (GUID *) ((pmt -> pbFormat + pmt -> cbFormat) - (2 * sizeof GUID)) ;
            ASSERT ((BYTE *) pguidTagged >= pmt -> pbFormat) ;

            if (pguidTagged [0] == MEDIASUBTYPE_DOLBY_AC3) {
                r = TRUE ;
            }
        }
    }

    return r ;
}

void
EncryptedSubtypeHack_IN (
    IN OUT  AM_MEDIA_TYPE * pmt
    )
{
    GUID *  pguidTagged ;
    GUID    guidTaggedSubtype ;
    GUID    guidTaggedFormatype ;

    ASSERT (pmt) ;

    //  needs to be sync'd with ET filter

    //  only care about video; everything else is generic to the WMSDK because
    //    we morph the majortype
    if (IsVideo (pmt)) {

#ifdef DEBUG
        int     i1 ;
        WCHAR   szSubtype1 [HW_PROFILE_GUIDLEN] ;
        WCHAR   szFormattype1 [HW_PROFILE_GUIDLEN] ;

        i1 = ::StringFromGUID2 (pmt -> subtype, szSubtype1, sizeof szSubtype1 / sizeof WCHAR) ;
        if (i1) {

            szSubtype1 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;

            i1 = ::StringFromGUID2 (pmt -> formattype, szFormattype1, sizeof szFormattype1 / sizeof WCHAR) ;
            if (i1) {

                szFormattype1 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;

                TRACE_2 (LOG_AREA_DSHOW, 1,
                    TEXT ("(input) IN: majortype is video; subtype = %s; formattype = %s"),
                    szSubtype1, szFormattype1) ;
            }
        }
#endif  //  DEBUG

        if (pmt -> subtype == MEDIASUBTYPE_ETDTFilter_Tagged_SBE &&
            pmt -> formattype == FORMATTYPE_ETDTFilter_Tagged_SBE) {

            //  gotta swap them out
            if (pmt -> cbFormat >= 2 * sizeof GUID) {

                pguidTagged = (GUID *) ((pmt -> pbFormat + pmt -> cbFormat) - (2 * sizeof GUID)) ;
                ASSERT ((BYTE *) pguidTagged >= pmt -> pbFormat) ;

                guidTaggedSubtype   = pguidTagged [0] ;
                guidTaggedFormatype = pguidTagged [1] ;

                pguidTagged [0] = pmt -> subtype ;
                pguidTagged [1] = pmt -> formattype ;

                pmt -> subtype      = guidTaggedSubtype ;
                pmt -> formattype   = guidTaggedFormatype ;
            }
        }

#ifdef DEBUG
        int     i2 ;
        WCHAR   szSubtype2 [HW_PROFILE_GUIDLEN] ;
        WCHAR   szFormattype2 [HW_PROFILE_GUIDLEN] ;

        i2 = ::StringFromGUID2 (pmt -> subtype, szSubtype2, sizeof szSubtype2 / sizeof WCHAR) ;
        if (i2) {
            szSubtype2 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;
            i2 = ::StringFromGUID2 (pmt -> formattype, szFormattype2, sizeof szFormattype2 / sizeof WCHAR) ;
            if (i2) {
                szFormattype2 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;

                TRACE_2 (LOG_AREA_DSHOW, 1,
                    TEXT ("(input) OUT: majortype is video; subtype = %s; formattype = %s"),
                    szSubtype2, szFormattype2) ;
            }
        }
#endif  //  DEBUG
    }
}

void
EncryptedSubtypeHack_OUT (
    IN OUT  AM_MEDIA_TYPE * pmt
    )
{
    GUID *  pguidTagged ;
    GUID    guidTaggedSubtype ;
    GUID    guidTaggedFormatype ;

    ASSERT (pmt) ;

    //  needs to be sync'd with ET filter

    //  only care about video; everything else is generic to the WMSDK because
    //    we morph the majortype
    if (IsVideo (pmt)) {

#ifdef DEBUG
        int     i1 ;
        WCHAR   szSubtype1 [HW_PROFILE_GUIDLEN] ;
        WCHAR   szFormattype1 [HW_PROFILE_GUIDLEN] ;

        i1 = ::StringFromGUID2 (pmt -> subtype, szSubtype1, sizeof szSubtype1 / sizeof WCHAR) ;
        if (i1) {

            szSubtype1 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;

            i1 = ::StringFromGUID2 (pmt -> formattype, szFormattype1, sizeof szFormattype1 / sizeof WCHAR) ;
            if (i1) {

                szFormattype1 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;

                TRACE_2 (LOG_AREA_DSHOW, 1,
                    TEXT ("(output) IN: majortype is video; subtype = %s; formattype = %s"),
                    szSubtype1, szFormattype1) ;
            }
        }
#endif  //  DEBUG

        //  check if we've swapped the encrypted subtype and formattype out on
        //    the way in
        if (pmt -> cbFormat >= 2 * sizeof GUID) {

            pguidTagged = (GUID *) ((pmt -> pbFormat + pmt -> cbFormat) - (2 * sizeof GUID)) ;
            ASSERT ((BYTE *) pguidTagged >= pmt -> pbFormat) ;

            if (pguidTagged [0] == MEDIASUBTYPE_ETDTFilter_Tagged_SBE &&
                pguidTagged [1] == FORMATTYPE_ETDTFilter_Tagged_SBE) {

                //  encrypted media types are appended to the format block;
                //    swap them back out

                guidTaggedSubtype   = pguidTagged [0] ;
                guidTaggedFormatype = pguidTagged [1] ;

                pguidTagged [0] = pmt -> subtype ;
                pguidTagged [1] = pmt -> formattype ;

                pmt -> subtype      = guidTaggedSubtype ;
                pmt -> formattype   = guidTaggedFormatype ;
            }
        }

#ifdef DEBUG
        int     i2 ;
        WCHAR   szSubtype2 [HW_PROFILE_GUIDLEN] ;
        WCHAR   szFormattype2 [HW_PROFILE_GUIDLEN] ;

        i2 = ::StringFromGUID2 (pmt -> subtype, szSubtype2, sizeof szSubtype2 / sizeof WCHAR) ;
        if (i2) {
            szSubtype2 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;
            i2 = ::StringFromGUID2 (pmt -> formattype, szFormattype2, sizeof szFormattype2 / sizeof WCHAR) ;
            if (i2) {
                szFormattype2 [HW_PROFILE_GUIDLEN - 1] = L'\0' ;

                TRACE_2 (LOG_AREA_DSHOW, 1,
                    TEXT ("(output) OUT: majortype is video; subtype = %s; formattype = %s"),
                    szSubtype2, szFormattype2) ;
            }
        }
#endif  //  DEBUG
    }
}

//  ============================================================================
//  DVRAttributeHelpers
//  ============================================================================

HRESULT
DVRAttributeHelpers::GetAttribute (
    IN      IMediaSample *  pIMediaSample,
    IN      GUID            guidAttribute,
    IN OUT  DWORD *         pdwSize,
    OUT     BYTE *          pbBuffer
    )
{
    IAttributeGet * pIDVRAnalysisAttributeGet ;
    HRESULT         hr ;

    hr = pIMediaSample -> QueryInterface (
            IID_IAttributeGet,
            (void **) & pIDVRAnalysisAttributeGet
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIDVRAnalysisAttributeGet -> GetAttrib (
                guidAttribute,
                pbBuffer,
                pdwSize
                ) ;

        pIDVRAnalysisAttributeGet -> Release () ;
    }

    return hr ;
}

HRESULT
DVRAttributeHelpers::GetAttribute (
    IN      INSSBuffer *    pINSSBuffer,
    IN      GUID            guidAttribute,
    IN OUT  DWORD *         pdwSize,
    OUT     BYTE *          pbBuffer
    )
{
    INSSBuffer3 *   pINSSBuffer3 ;
    HRESULT         hr ;

    hr = pINSSBuffer -> QueryInterface (IID_INSSBuffer3, (void **) & pINSSBuffer3) ;
    if (SUCCEEDED (hr)) {
        hr = GetAttribute (
                pINSSBuffer3,
                guidAttribute,
                pdwSize,
                pbBuffer
                ) ;

        pINSSBuffer3 -> Release () ;
    }

    return hr ;
}

HRESULT
DVRAttributeHelpers::GetAttribute (
    IN      INSSBuffer3 *   pINSSBuffer3,
    IN      GUID            guidAttribute,
    IN OUT  DWORD *         pdwSize,
    OUT     BYTE *          pbBuffer
    )
{
    HRESULT hr ;

    hr = pINSSBuffer3 -> GetProperty (
            guidAttribute,
            pbBuffer,
            pdwSize
            ) ;

    return hr ;
}

HRESULT
DVRAttributeHelpers::SetAttribute (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  GUID            guidAttribute,
    IN  DWORD           dwSize,
    IN  BYTE *          pbBuffer
    )
{
    HRESULT hr ;

    hr = pINSSBuffer3 -> SetProperty (
            guidAttribute,
            pbBuffer,
            dwSize
            ) ;

    return hr ;
}

HRESULT
DVRAttributeHelpers::SetAttribute (
    IN  INSSBuffer *    pINSSBuffer,
    IN  GUID            guidAttribute,
    IN  DWORD           dwSize,
    IN  BYTE *          pbBuffer
    )
{
    INSSBuffer3 *   pINSSBuffer3 ;
    HRESULT         hr ;

    hr = pINSSBuffer -> QueryInterface (
            IID_INSSBuffer3,
            (void **) & pINSSBuffer3
            ) ;
    if (SUCCEEDED (hr)) {
        hr = DVRAttributeHelpers::SetAttribute (
                pINSSBuffer3,
                guidAttribute,
                dwSize,
                pbBuffer
                ) ;

        pINSSBuffer3 -> Release () ;
    }

    return hr ;
}

HRESULT
DVRAttributeHelpers::SetAttribute (
    IN  IMediaSample *  pIMS,
    IN  GUID            guidAttribute,
    IN  DWORD           dwSize,
    IN  BYTE *          pbBuffer
    )
{
    IAttributeSet * pIDVRAnalysisAttributeSet ;
    HRESULT         hr ;

    hr = pIMS -> QueryInterface (
            IID_IAttributeSet,
            (void **) & pIDVRAnalysisAttributeSet
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIDVRAnalysisAttributeSet -> SetAttrib (
                guidAttribute,
                pbBuffer,
                dwSize
                ) ;

        pIDVRAnalysisAttributeSet -> Release () ;
    }

    return hr ;
}

BOOL
DVRAttributeHelpers::IsAnalysisPresent (
    IN  IMediaSample2 * pIMediaSample2
    )
{
    IAttributeGet * pIDVRAnalysisAttributeGet ;
    DWORD           dwSize ;
    HRESULT         hr ;
    DWORD           dwGlobalAnalysisFlags ;
    BOOL            r ;

    dwGlobalAnalysisFlags = 0 ;
    dwSize = sizeof dwGlobalAnalysisFlags ;

    hr = GetAttribute (
            pIMediaSample2,
            DVRAnalysis_Global,
            & dwSize,
            (BYTE *) & dwGlobalAnalysisFlags
            ) ;
    if (SUCCEEDED (hr)) {
        r = DVR_ANALYSIS_GLOBAL_IS_PRESENT (dwGlobalAnalysisFlags) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
DVRAttributeHelpers::IsAnalysisPresent (
    IN  INSSBuffer *    pINSSBuffer
    )
{
    IAttributeGet * pIDVRAnalysisAttributeGet ;
    DWORD           dwSize ;
    HRESULT         hr ;
    DWORD           dwGlobalAnalysisFlags ;
    BOOL            r ;

    dwGlobalAnalysisFlags = 0 ;
    dwSize = sizeof dwGlobalAnalysisFlags ;

    hr = GetAttribute (
            pINSSBuffer,
            DVRAnalysis_Global,
            & dwSize,
            (BYTE *) & dwGlobalAnalysisFlags
            ) ;
    if (SUCCEEDED (hr)) {
        r = DVR_ANALYSIS_GLOBAL_IS_PRESENT (dwGlobalAnalysisFlags) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
DVRAttributeHelpers::IsAttributePresent (
    IN  IMediaSample *  pIMediaSample,
    IN  GUID            guidAttribute
    )
{
    HRESULT hr ;
    DWORD   dwLen ;
    BOOL    r ;

    hr = GetAttribute (
            pIMediaSample,
            guidAttribute,
            & dwLen,
            NULL
            ) ;
    if (SUCCEEDED (hr)) {
        r = (dwLen > 0 ? TRUE : FALSE) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
DVRAttributeHelpers::IsAttributePresent (
    IN  INSSBuffer *    pINSSBuffer,
    IN  GUID            guidAttribute
    )
{
    HRESULT hr ;
    DWORD   dwLen ;
    BOOL    r ;

    hr = GetAttribute (
            pINSSBuffer,
            guidAttribute,
            & dwLen,
            NULL
            ) ;
    if (SUCCEEDED (hr)) {
        r = (dwLen > 0 ? TRUE : FALSE) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
DVRAttributeHelpers::IsAttributePresent (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  GUID            guidAttribute
    )
{
    HRESULT hr ;
    DWORD   dwLen ;
    BOOL    r ;

    hr = GetAttribute (
            pINSSBuffer3,
            guidAttribute,
            & dwLen,
            NULL
            ) ;
    if (SUCCEEDED (hr)) {
        r = (dwLen > 0 ? TRUE : FALSE) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

//  ============================================================================
//  DShowWMSDKHelpers
//  ============================================================================

BOOL g_fUseRateChange11 ;

double
CompatibleRateValue (
    IN  double  dTargetRate
    )
{
    LONG    l ;

    if (g_fUseRateChange11) {
        //  whenever we use a rate, we first translate it to the same value that
        //    will be used by other modules; for ratechange 1.1, the rate is
        //    sent down as an effective PTS and a LONG of value 10000/Rate; if
        //    the values don't evenly divide
        l = (LONG) (10000.0 / dTargetRate) ;
        if (l != 0) {
            dTargetRate = 10000.0 / (double) l ;
        }
    }

    return dTargetRate ;
}

BOOL g_fRegGenericStreams_Video ;
BOOL g_fRegGenericStreams_Audio ;

HRESULT
KSPropertySet_ (
    IN  IUnknown *      punk,
    IN  const GUID *    pPSGUID,
    IN  DWORD           dwProperty,
    IN  BYTE *          pData,
    IN  DWORD           cbData
    )
{
    HRESULT             hr ;
    IKsPropertySet *    pIKsProp ;

    if (!punk) {
        return E_FAIL;
    }

    pIKsProp = NULL ;

    hr = punk -> QueryInterface (
            IID_IKsPropertySet,
            (void **) & pIKsProp
            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (pIKsProp) ;

        hr = pIKsProp -> Set (
                * pPSGUID,
                dwProperty,
                NULL,
                0,
                pData,
                cbData
                ) ;

        pIKsProp -> Release () ;
    }

    return hr ;
}

HRESULT
KSPropertyGet_ (
    IN  IUnknown *      punk,
    IN  const GUID *    pPSGUID,
    IN  DWORD           dwProperty,
    IN  BYTE *          pData,
    IN  DWORD           cbMax,
    OUT DWORD *         pcbGot
    )
{
    HRESULT             hr ;
    IKsPropertySet *    pIKsProp ;

    if (!punk) {
        return E_FAIL;
    }

    pIKsProp = NULL ;

    hr = punk -> QueryInterface (
            IID_IKsPropertySet,
            (void **) & pIKsProp
            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (pIKsProp) ;

        hr = pIKsProp -> Get (
                * pPSGUID,
                dwProperty,
                NULL,
                0,
                pData,
                cbMax,
                pcbGot
                ) ;

        pIKsProp -> Release () ;
    }

    return hr ;
}

//  call FreeMediaType ((AM_MEDIA_TYPE *) pWmt) to free
HRESULT
DShowWMSDKHelpers::TranslateDShowToWM (
    IN  AM_MEDIA_TYPE * pAmt,
    OUT WM_MEDIA_TYPE * pWmt
    )
{
    HRESULT hr ;

    ASSERT (pAmt) ;
    ASSERT (pWmt) ;

    hr = CopyMediaType ((AM_MEDIA_TYPE *) pWmt, pAmt) ;

    if (SUCCEEDED (hr)) {

        if (pWmt -> majortype == MEDIATYPE_Audio &&
            g_fRegGenericStreams_Audio) {
            pWmt -> majortype = GENERIC_MEDIATYPE_Audio ;
        }
        else if (pWmt -> majortype == MEDIATYPE_Video &&
                g_fRegGenericStreams_Video) {
            pWmt -> majortype = GENERIC_MEDIATYPE_Video ;
        }
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::TranslateWMToDShow (
    IN  WM_MEDIA_TYPE * pWmt,
    OUT AM_MEDIA_TYPE * pAmt
    )
{
    HRESULT hr ;

    ASSERT (pAmt) ;
    ASSERT (pWmt) ;

    hr = CopyMediaType (pAmt, (AM_MEDIA_TYPE *) pWmt) ;

    if (SUCCEEDED (hr)) {

        if (g_fRegGenericStreams_Audio &&
            pAmt -> majortype == GENERIC_MEDIATYPE_Audio) {

            pAmt -> majortype = MEDIATYPE_Audio ;
        }
        else if (g_fRegGenericStreams_Video &&
                 pAmt -> majortype == GENERIC_MEDIATYPE_Video) {

            pAmt -> majortype = MEDIATYPE_Video ;
        }
    }

    return hr ;
}

BOOL
DShowWMSDKHelpers::IsWMVideoStream (
    IN  REFGUID guidStreamType
    )
{
    BOOL    r ;

    if (g_fRegGenericStreams_Video) {
        r = (guidStreamType == GENERIC_MEDIATYPE_Video ? TRUE : FALSE) ;
    }
    else {
        r = (guidStreamType == MEDIATYPE_Video ? TRUE : FALSE) ;
    }

    return r ;
}

BOOL
DShowWMSDKHelpers::IsWMAudioStream (
    IN  REFGUID guidStreamType
    )
{
    BOOL    r ;

    if (g_fRegGenericStreams_Audio) {
        r = (guidStreamType == GENERIC_MEDIATYPE_Audio ? TRUE : FALSE) ;
    }
    else {
        r = (guidStreamType == MEDIATYPE_Audio ? TRUE : FALSE) ;
    }

    return r ;
}

HRESULT
DShowWMSDKHelpers::FormatBlockSetValidForWMSDK_ (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT             hr ;
    WAVEFORMATEX *      pWaveFormatEx ;
    WMVIDEOINFOHEADER * pWMVideoInfoHeader ;
    DWORD               dwBitsPerFrame ;
    DWORD               dwFramesPerSec ;

    //  default to PASS unless we can explicitely set it to FAIL
    hr = S_OK ;

    //  ========================================================================
    //  WAVEFORMATEX format block

    if (pmt -> formattype == FORMAT_WaveFormatEx) {
        //  WAVEFORMATEX struct; we know how to validate
        if (pmt -> pbFormat &&
            pmt -> cbFormat >= sizeof WAVEFORMATEX) {

            pWaveFormatEx = reinterpret_cast <WAVEFORMATEX *> (pmt -> pbFormat) ;

            //  bitrate = 0 error
            if (pWaveFormatEx -> nAvgBytesPerSec == 0) {
                //  probably for compressed data, so it's not known; but
                //   the WMSDK expects this value to compute wrt the other
                //   members
                pWaveFormatEx -> nAvgBytesPerSec = pWaveFormatEx -> nSamplesPerSec *
                                                   pWaveFormatEx -> nChannels *
                                                   pWaveFormatEx -> wBitsPerSample /
                                                   8 ;
            }

            hr = S_OK ;
        }
        else {
            //  invalid size
            hr = E_FAIL ;
        }
    }

    //  ========================================================================
    //  generic streams are checked by the WMSDK layer at runtime for correct
    //    size as specified with the .lSampleSize vs. .bFixedSizeSamples
    //    AM_MEDIA_TYPE members; if the .bFixedSizeSamples member is set, the
    //    runtime size of the INSSBuffer is checked against the size specified
    //    here in the .lSampleSize member; the INSSBuffer is failed if the size
    //    doesn't match; these checks are not performed if the .bFixedSizeSamples
    //    member is not set;
    //  our fixup is as follows
    //    1. if it's audio & we're going to map to a generic stream (per the
    //          g_fRegGenericStreams_Audio flag), we clear .bFixedSizeSamples
    //    2. if it's video & we're going to map to a generic stream (per the
    //          g_fRegGenericStreams_Video flag), we clear .bFixedSizeSamples
    //

    //  check is made for either generic or non-generic majortypes in case we
    //   are called after we whack them
    if ((g_fRegGenericStreams_Video && (pmt -> majortype == MEDIATYPE_Video || pmt -> majortype == GENERIC_MEDIATYPE_Video)) ||
        (g_fRegGenericStreams_Audio && (pmt -> majortype == MEDIATYPE_Audio || pmt -> majortype == GENERIC_MEDIATYPE_Audio))) {

        if (pmt -> lSampleSize == 0 && pmt -> bFixedSizeSamples) {
            //  this is the check I'd like to only make
            pmt -> bFixedSizeSamples = FALSE ;
        }
        else if (pmt -> bFixedSizeSamples) {
            //  but for now, we'll clear always
            pmt -> bFixedSizeSamples = FALSE ;
        }
    }

    //  ========================================================================
    //  mpeg-2 video is compressed, but the BITMAPINFOHEADER.biCompression is
    //    frequently set to 0, which has meaning BI_RGB (uncompressed); this is
    //    obviously bogus; there are other FOURCC codes for uncompressed content
    //    but we check for the value that is glaringly bad; if it's "bad" we
    //    set it to FOURCC MPEG, which is vague if it means mpeg1, mpeg2; it's
    //    closer than RGB

    //  ========================================================================
    //  mpeg-2 video
    if (pmt -> formattype == FORMAT_MPEG2Video  &&
        pmt -> pbFormat                         &&
        pmt -> cbFormat >= sizeof MPEG2VIDEOINFO) {

        if (reinterpret_cast <MPEG2VIDEOINFO *> (pmt -> pbFormat) -> hdr.bmiHeader.biCompression == 0) {
            reinterpret_cast <MPEG2VIDEOINFO *> (pmt -> pbFormat) -> hdr.bmiHeader.biCompression = MAKEFOURCC ('M','P','E','G') ;
        }
    }

    //  ========================================================================
    //  part of the validation process in the WMSDK involves making sure that
    //    these numbers all add up ok; we make sure here so the stream creation
    //    succeeds
    //  ========================================================================
    if (pmt -> subtype      == WMMEDIASUBTYPE_WMV1      &&
        pmt -> formattype   == WMFORMAT_VideoInfo       &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        //  bits per frame
        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        //  frames per sec
        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSec = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSec = VBR_DEF_FPS ;
        }

        //  bits per second
        pWMVideoInfoHeader -> dwBitRate = dwBitsPerFrame * dwFramesPerSec ;
    }

    //  ========================================================================
    //  part of the validation process in the WMSDK involves making sure that
    //    these numbers all add up ok; we make sure here so the stream creation
    //    succeeds
    //  ========================================================================
    if (pmt -> subtype      == WMMEDIASUBTYPE_WMV2      &&
        pmt -> formattype   == WMFORMAT_VideoInfo       &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        //  bits per frame
        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        //  frames per sec
        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSec = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSec = VBR_DEF_FPS ;
        }

        //  bits per second
        pWMVideoInfoHeader -> dwBitRate = dwBitsPerFrame * dwFramesPerSec ;
    }

    //  ========================================================================
    //  part of the validation process in the WMSDK involves making sure that
    //    these numbers all add up ok; we make sure here so the stream creation
    //    succeeds
    //  ========================================================================
    if ((pmt -> subtype == WMMEDIASUBTYPE_WMV3)  &&

        pmt -> formattype   == WMFORMAT_VideoInfo       &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        //  bits per frame
        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        //  frames per sec
        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSec = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSec = VBR_DEF_FPS ;
        }

        //  bits per second
        pWMVideoInfoHeader -> dwBitRate = dwBitsPerFrame * dwFramesPerSec ;
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::MediaTypeSetValidForWMSDK (
    IN OUT  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    //  make sure the AM_MEDIA_TYPE members all make sense wrt one another;
    //   we look for specific media types; if there's a media type we don't
    //   know about, we'll OK it i.e. we default to pass

    if (pmt -> subtype == MEDIASUBTYPE_MPEG2_VIDEO) {
        //  mpeg-2 video is compressed
        pmt -> bTemporalCompression = TRUE ;

        //  .bFixedSizeSamples may/may not be true; we cannot tell here,
        //    though if we're the ones upstream, it'll be FALSE, but .. we
        //    cannot be sure.
    }

    hr = FormatBlockSetValidForWMSDK_ (pmt) ;

    return hr ;
}

WORD
DShowWMSDKHelpers::PinIndexToWMStreamNumber (
    IN  LONG    lIndex
    )
{
    ASSERT (lIndex < MAX_PIN_BANK_SIZE) ;
    ASSERT (lIndex + 1 < WMSDK_MAX_VALID_STREAM_NUM) ;

    return (WORD) lIndex + 1 ;
}

WORD
DShowWMSDKHelpers::PinIndexToWMInputStream (
    IN  LONG    lIndex
    )
{
    //  pin indeces are 0-based; so are input streams
    return (WORD) lIndex ;
}


LONG
DShowWMSDKHelpers::WMStreamNumberToPinIndex (
    IN  WORD    wStreamNumber
    )
{
    //  pin indeces are 0-based
    //  WM stream numbers valid values are [1,WMSDK_MAX_VALID_STREAM_NUM], so we 1-base everything

    ASSERT (WMSDK_MIN_VALID_STREAM_NUM <= wStreamNumber) ;
    ASSERT (wStreamNumber <= WMSDK_MAX_VALID_STREAM_NUM) ;
    ASSERT (wStreamNumber - 1 < MAX_PIN_BANK_SIZE) ;

    return (wStreamNumber - 1) ;
}

CDVRWMSDKToDShowTranslator *
DShowWMSDKHelpers::GetWMSDKToDShowTranslator (
    IN  AM_MEDIA_TYPE *     pmtConnection,
    IN  CDVRPolicy *        pPolicy,
    IN  int                 iFlowId
    )
{
    CDVRWMSDKToDShowTranslator *   pRet ;

    if (IsMpeg2Video (pmtConnection)) {
        pRet = new CDVRWMSDKToDShowMpeg2Translator (pPolicy, iFlowId) ;
    }
    else {
        pRet = new CDVRWMSDKToDShowTranslator (pPolicy, iFlowId) ;
    }

    return pRet ;
}

CDVRDShowToWMSDKTranslator *
DShowWMSDKHelpers::GetDShowToWMSDKTranslator (
    IN  AM_MEDIA_TYPE *     pmtConnection,
    IN  CDVRPolicy *        pPolicy,
    IN  int                 iFlowId
    )
{
    CDVRDShowToWMSDKTranslator *   pRet ;

    if (IsMpeg2Video (pmtConnection)) {
        pRet = new CDVRDShowToWMSDKMpeg2Translator (pPolicy, iFlowId) ;
    }
    else {
        pRet = new CDVRDShowToWMSDKTranslator (pPolicy, iFlowId) ;
    }

    return pRet ;
}

HRESULT
DShowWMSDKHelpers::AddDVRAnalysisExtensions (
    IN  IWMStreamConfig2 *  pIWMStreamConfig2,
    IN  AM_MEDIA_TYPE *     pmt
    )
{
    HRESULT hr ;

    ASSERT (pIWMStreamConfig2) ;
    ASSERT (pmt) ;

    //  mpeg-2 analysis flags
    if (IsMpeg2Video (pmt)) {
        //  see idl\dvranalysis.idl for details
        hr = pIWMStreamConfig2 -> AddDataUnitExtension (DVRAnalysis_Mpeg2Video, sizeof DWORD, NULL, 0) ;

        //  analysis presence/absence i.e. we know analysis
        if (SUCCEEDED (hr)) {
            hr = pIWMStreamConfig2 -> AddDataUnitExtension (DVRAnalysis_Global, sizeof DWORD, NULL, 0) ;
        }
    }
    else {
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::AddFormatSpecificExtensions (
    IN  IWMStreamConfig2 *  pIWMStreamConfig2,
    IN  AM_MEDIA_TYPE *     pmt
    )
{
    HRESULT hr ;

    ASSERT (pIWMStreamConfig2) ;
    ASSERT (pmt) ;

    if (IsMpeg2Video (pmt)) {

        //  mpeg-2 has PTSs inlined
        hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_Mpeg2ElementaryStream, sizeof LONGLONG, NULL, 0) ;
    }
    else {
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::RecoverNewMediaType (
    IN  INSSBuffer3 *       pINSSBuffer3,
    OUT AM_MEDIA_TYPE **    ppmtNew         //  DeleteMediaType on this to free
    )
{
    HRESULT hr ;
    BYTE *  pbBuffer ;
    DWORD   dwLen ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (ppmtNew) ;
    ASSERT (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, INSSBuffer3Prop_DShowNewMediaType)) ;

    pbBuffer = NULL ;

    hr = pINSSBuffer3 -> GetProperty (
            INSSBuffer3Prop_DShowNewMediaType,
            NULL,
            & dwLen
            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (dwLen > 0) ;

        //  get the media type out
        pbBuffer = new BYTE [dwLen] ;
        if (pbBuffer) {
            //  recover
            hr = pINSSBuffer3 -> GetProperty (
                    INSSBuffer3Prop_DShowNewMediaType,
                    pbBuffer,
                    & dwLen
                    ) ;
            if (SUCCEEDED (hr)) {
                (* ppmtNew) = reinterpret_cast <AM_MEDIA_TYPE *> (CoTaskMemAlloc (sizeof AM_MEDIA_TYPE)) ;
                if (* ppmtNew) {
                    //  copy the media type itself
                    CopyMemory (
                        * ppmtNew,
                        pbBuffer,
                        sizeof AM_MEDIA_TYPE
                        ) ;

                    //  is there a format block
                    if ((* ppmtNew) -> cbFormat > 0) {
                        //  ignore the .pbFormat member - it's not valid
                        (* ppmtNew) -> pbFormat = reinterpret_cast <BYTE *> (CoTaskMemAlloc ((* ppmtNew) -> cbFormat)) ;
                        if ((* ppmtNew) -> pbFormat) {
                            //  copy the format block
                            CopyMemory (
                                (* ppmtNew) -> pbFormat,
                                pbBuffer + sizeof AM_MEDIA_TYPE,        //  format block follows contiguously when copied in..
                                (* ppmtNew) -> cbFormat
                                ) ;

                            //  success
                            hr = S_OK ;
                        }
                        else {
                            hr = E_OUTOFMEMORY ;

                            //  free what we've allocated
                            CoTaskMemFree (* ppmtNew) ;
                        }
                    }
                    else {
                        //  no format block
                        (* ppmtNew) -> pbFormat = NULL ;

                        //  success
                        hr = S_OK ;
                    }
                }
                else {
                    hr = E_OUTOFMEMORY ;
                }
            }

            //  done with the buffer regardless
            delete [] pbBuffer ;
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::InlineNewMediaType (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT hr ;
    BYTE *  pbBuffer ;
    DWORD   dwLen ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (pmtNew) ;

    hr          = S_OK ;
    pbBuffer    = NULL ;
    dwLen       = 0 ;

    if (pmtNew -> pbFormat == NULL) {
        if (pmtNew -> cbFormat == 0) {
            //  looks valid; set it
            pbBuffer = reinterpret_cast <BYTE *> (pmtNew) ;
            dwLen = sizeof AM_MEDIA_TYPE ;
        }
        else {
            hr = E_INVALIDARG ;
        }
    }
    else {
        //  need to form into contiguous buffer
        dwLen = sizeof AM_MEDIA_TYPE + pmtNew -> cbFormat ;
        pbBuffer = new BYTE [dwLen] ;
        if (pbBuffer) {
            //  copy the media type
            CopyMemory (
                pbBuffer,
                pmtNew,
                sizeof AM_MEDIA_TYPE
                ) ;

            //  set to follow; note this value will not make sense on the way
            //   back out
            reinterpret_cast <AM_MEDIA_TYPE *> (pbBuffer) -> pbFormat = pbBuffer + sizeof AM_MEDIA_TYPE ;

            //  and the format block
            CopyMemory (
                reinterpret_cast <AM_MEDIA_TYPE *> (pbBuffer) -> pbFormat,
                pmtNew -> pbFormat,
                pmtNew -> cbFormat
                ) ;
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }

    //  we're set
    if (SUCCEEDED (hr)) {
        ASSERT (pbBuffer) ;
        ASSERT (dwLen > 0) ;

        hr = pINSSBuffer3 -> SetProperty (
                INSSBuffer3Prop_DShowNewMediaType,
                reinterpret_cast <LPVOID> (pbBuffer),
                dwLen
                ) ;
    }

    //  done with pbBuffer
    if (pbBuffer != pmtNew -> pbFormat) {
        delete [] pbBuffer ;
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::SetSBEAttributes (
    IN  DWORD           dwSamplesPerSec,
    IN  IMediaSample *  pIMS,
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  DWORD *         dwContinuityCounterNext
    )
{
    AM_SAMPLE2_PROPERTIES       Sample2Properties ;
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttrib ;
    HRESULT                     hr ;
    IMediaSample2 *             pIMS2 ;

    hr = pIMS -> QueryInterface (IID_IMediaSample2, (void **) & pIMS2) ;
    if (SUCCEEDED (hr)) {
        hr = pIMS2 -> GetProperties (
                        sizeof Sample2Properties,
                        reinterpret_cast <BYTE *> (& Sample2Properties)
                        ) ;
        if (SUCCEEDED (hr)) {

            //  time members
            hr = pIMS -> GetTime (& SBEAttrib.rtStart, & SBEAttrib.rtStop) ;
            if (hr != VFW_E_SAMPLE_TIME_NOT_SET) {
                //  might need to clear the stop time
                SBEAttrib.rtStop = (hr == VFW_S_NO_STOP_TIME ? -1 : SBEAttrib.rtStop) ;
            }
            else {
                //  clear them both
                SBEAttrib.rtStart = -1 ;
                SBEAttrib.rtStop = -1 ;
            }

            //  time is taken care of
            hr = S_OK ;

            //  Set attribute value accordingly
            INIT_SBE_ATTRIB_VERSION(SBEAttrib.dwVersion) ;

            SBEAttrib.dwTypeSpecificFlags   = Sample2Properties.dwTypeSpecificFlags ;
            SBEAttrib.dwStreamId            = Sample2Properties.dwStreamId ;
            SBEAttrib.dwFlags               = 0 ;
            SBEAttrib.dwCounter             = *dwContinuityCounterNext ;
            SBEAttrib.dwReserved            = 0 ;
            SBEAttrib.dwMuxedStreamStats    = MUXED_STREAM_STATS_PACKET_RATE (SBEAttrib.dwMuxedStreamStats, dwSamplesPerSec) ;

            // bug# 629263 (DShow->WMSDK, write)
            // Since we set every media sample as a clean point, we need to preserve the
            // correct sync point info.  This is done by saving this in the dshow attribute.
            SET_SBE_SYNCPOINT(SBEAttrib.dwFlags, pIMS2->IsSyncPoint() == S_OK);
            SET_SBE_DISCONTINUITY(SBEAttrib.dwFlags, pIMS2->IsDiscontinuity() == S_OK);

            //  set it on the INSSBuffer3
            hr = pINSSBuffer3 -> SetProperty (
                                    INSSBuffer3Prop_SBE_Attributes,
                                    & SBEAttrib,
                                    sizeof SBEAttrib
                                    ) ;

            // Update current counter after the SetProperty()
            *dwContinuityCounterNext = NEXT_COUNTER_VAL (*dwContinuityCounterNext) ;

            TRACE_1 (LOG_AREA_WMSDK_DSHOW, 8,
                TEXT ("DShowWMSDKHelpers::SetSBEAttributes () : start = %I64d ms"),
                ::DShowTimeToMilliseconds (SBEAttrib.rtStart != -1 ? SBEAttrib.rtStart : 0)) ;
        }

        pIMS2 -> Release () ;
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::RecoverSBEAttributes (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  IMediaSample *  pIMS,
    IN  double          dCurRate,
    IN  OUT DWORD *     pdwContinuityCounterNext
    )
{
    AM_SAMPLE2_PROPERTIES       Sample2Properties ;
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttrib ;
    HRESULT                     hr ;
    IMediaSample2 *             pIMS2 ;
    DWORD                       dwSize ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (pIMS) ;
    ASSERT (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, INSSBuffer3Prop_SBE_Attributes)) ;

    dwSize = sizeof SBEAttrib ;
    hr = pINSSBuffer3 -> GetProperty (
            INSSBuffer3Prop_SBE_Attributes,
            & SBEAttrib,
            & dwSize
            ) ;
    if (SUCCEEDED (hr)) {
        //  set the various properties now
        if (SBEAttrib.rtStart != -1) {
            //  if there's a time associated, set it
            hr = pIMS -> SetTime (
                            & SBEAttrib.rtStart,
                            (SBEAttrib.rtStop != -1 ? & SBEAttrib.rtStop : NULL)
                            ) ;
        }

        // Bug# 629263 (WMSDK->DShow, read)
        // Do not rely on timestamp setting to set sync point; instead,
        // recover SyncPoint flag and set it to MediaSample accordingly.
        pIMS -> SetSyncPoint(IS_SBE_SYNCPOINT(SBEAttrib.dwFlags));

        // Recover DShow disconinuity flag
        pIMS -> SetDiscontinuity(IS_SBE_DISCONTINUITY(SBEAttrib.dwFlags) || (*pdwContinuityCounterNext != SBEAttrib.dwCounter));

#ifdef DEBUG
        if (pIMS -> IsDiscontinuity() == S_OK) {
            TRACE_3 (LOG_AREA_DSHOW, 1,
                TEXT ("DShowWMSDKHelpers::RecoverSBEAttributes (Discontinuity): dwFlag:0x%08x; 0x%08x ?= 0x%08x (expected)"),
                SBEAttrib.dwFlags, SBEAttrib.dwCounter, *pdwContinuityCounterNext) ;
        }
#endif
        // Adjust couunter
        if (dCurRate > 0)
            *pdwContinuityCounterNext = NEXT_COUNTER_VAL (SBEAttrib.dwCounter) ;
        else
            *pdwContinuityCounterNext = PREV_COUNTER_VAL (SBEAttrib.dwCounter) ;

        if (SUCCEEDED (hr)) {
            //  typespecific flags & stream id; gotta get the sample properties
            hr = pIMS -> QueryInterface (IID_IMediaSample2, (void **) & pIMS2) ;
            if (SUCCEEDED (hr)) {

                hr = pIMS2 -> GetProperties (
                        sizeof Sample2Properties,
                        reinterpret_cast <BYTE *> (& Sample2Properties)
                        ) ;
                if (SUCCEEDED (hr)) {
                    Sample2Properties.dwTypeSpecificFlags   = SBEAttrib.dwTypeSpecificFlags ;
                    Sample2Properties.dwStreamId            = SBEAttrib.dwStreamId ;

                    hr = pIMS2 -> SetProperties (
                                    sizeof Sample2Properties,
                                    reinterpret_cast <const BYTE *> (& Sample2Properties)
                                    ) ;
                }

                pIMS2 -> Release () ;
            }
        }
    } else {
        hr = NS_E_INVALID_DATA;
    }

    return hr ;
}

//  ----------------------------------------------------------------------------
//      CMediaSampleWrapper
//  ----------------------------------------------------------------------------

//  shamelessly stolen from amfilter.h & amfilter.cpp

CMediaSampleWrapper::CMediaSampleWrapper() :
    m_pBuffer(NULL),                // Initialise the buffer
    m_cbBuffer(0),                  // And it's length
    m_lActual(0),                   // By default, actual = length
    m_pMediaType(NULL),             // No media type change
    m_dwFlags(0),                   // Nothing set
    m_cRef(0),                      // 0 ref count
    m_dwTypeSpecificFlags(0),       // Type specific flags
    m_dwStreamId(AM_STREAM_MEDIA),  // Stream id
    m_pIMSCore (NULL)
{
//@@BEGIN_MSINTERNAL
#ifdef DXMPERF
    PERFLOG_CTOR( L"CMediaSampleWrapper", (IMediaSample *) this );
#endif // DXMPERF
//@@END_MSINTERNAL
}

/* Destructor deletes the media type memory */

CMediaSampleWrapper::~CMediaSampleWrapper()
{
//@@BEGIN_MSINTERNAL
#ifdef DXMPERF
    PERFLOG_DTOR( L"CMediaSampleWrapper", (IMediaSample *) this );
#endif // DXMPERF
//@@END_MSINTERNAL

    if (m_pMediaType) {
    DeleteMediaType(m_pMediaType);
    }
}

/* Override this to publicise our interfaces */

STDMETHODIMP
CMediaSampleWrapper::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IMediaSample ||
        riid == IID_IMediaSample2 ||
        riid == IID_IUnknown) {
        return GetInterface((IMediaSample *) this, ppv);
    }
    else if (riid == IID_IAttributeSet) {
        return GetInterface ((IAttributeSet *) this, ppv) ;
    }
    else if (riid == IID_IAttributeGet) {
        return GetInterface ((IAttributeGet *) this, ppv) ;
    }
    else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CMediaSampleWrapper::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// --  CMediaSampleWrapper lifetimes --
//
// On final release of this sample buffer it is not deleted but
// returned to the freelist of the owning memory allocator
//
// The allocator may be waiting for the last buffer to be placed on the free
// list in order to decommit all the memory, so the ReleaseBuffer() call may
// result in this sample being deleted. We also need to hold a refcount on
// the allocator to stop that going away until we have finished with this.
// However, we cannot release the allocator before the ReleaseBuffer, as the
// release may cause us to be deleted. Similarly we can't do it afterwards.
//
// Thus we must leave it to the allocator to hold an addref on our behalf.
// When he issues us in GetBuffer, he addref's himself. When ReleaseBuffer
// is called, he releases himself, possibly causing us and him to be deleted.

void
CMediaSampleWrapper::Reset_ (
    )
{
    if (m_dwFlags & Sample_TypeChanged) {
        SetMediaType(NULL);
    }

    ASSERT(m_pMediaType == NULL);
    m_dwFlags = 0;
    m_dwTypeSpecificFlags = 0;
    m_dwStreamId = AM_STREAM_MEDIA;

    m_DVRAttributeList.Reset () ;
    RELEASE_AND_CLEAR (m_pIMSCore) ;
}

STDMETHODIMP
CMediaSampleWrapper::SetAttrib (
    IN  GUID    guidAttribute,
    IN  BYTE *  pbAttribute,
    IN  DWORD   dwAttributeLength
    )
{
    return m_DVRAttributeList.AddAttribute (
            guidAttribute,
            pbAttribute,
            dwAttributeLength
            ) ;
}

STDMETHODIMP
CMediaSampleWrapper::GetCount (
    OUT LONG *  plCount
    )
{
    if (!plCount) {
        return E_POINTER ;
    }

    (* plCount) = m_DVRAttributeList.GetCount () ;
    return S_OK ;
}

STDMETHODIMP
CMediaSampleWrapper::GetAttribIndexed (
    IN  LONG    lIndex,             //  0-based
    OUT GUID *  pguidAttribute,
    OUT BYTE *  pbAttribute,
    OUT DWORD * pdwAttributeLength
    )
{
    return m_DVRAttributeList.GetAttributeIndexed (
            lIndex,
            pguidAttribute,
            pbAttribute,
            pdwAttributeLength
            ) ;
}

STDMETHODIMP
CMediaSampleWrapper::GetAttrib (
    IN  GUID    guidAttribute,
    OUT BYTE *  pbAttribute,
    OUT DWORD * pdwAttributeLength
    )
{
    return m_DVRAttributeList.GetAttribute (
            guidAttribute,
            pbAttribute,
            pdwAttributeLength
            ) ;
}

HRESULT
CMediaSampleWrapper::Init (
    IN  IUnknown *  pIMS,
    IN  BYTE *      pbPayload,
    IN  LONG        lPayloadLength
    )
{
    ASSERT (!m_pIMSCore) ;

    m_pIMSCore = pIMS ;
    m_pIMSCore -> AddRef () ;

    return Init (pbPayload, lPayloadLength) ;
}

HRESULT
CMediaSampleWrapper::Init (
    IN  BYTE *  pbPayload,
    IN  LONG    lPayloadLength
    )
{
    m_lActual = m_cbBuffer = lPayloadLength ;
    m_pBuffer = pbPayload ;

    return S_OK ;
}

STDMETHODIMP_(ULONG)
CMediaSampleWrapper::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
        this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        Reset_ () ;
        Recycle_ () ;
    }
    return (ULONG)lRef;
}


// set the buffer pointer and length. Used by allocators that
// want variable sized pointers or pointers into already-read data.
// This is only available through a CMediaSampleWrapper* not an IMediaSample*
// and so cannot be changed by clients.
HRESULT
CMediaSampleWrapper::SetPointer(BYTE * ptr, LONG cBytes)
{
    m_pBuffer = ptr;            // new buffer area (could be null)
    m_cbBuffer = cBytes;        // length of buffer
    m_lActual = cBytes;         // length of data in buffer (assume full)

    return S_OK;
}


// get me a read/write pointer to this buffer's memory. I will actually
// want to use sizeUsed bytes.
STDMETHODIMP
CMediaSampleWrapper::GetPointer(BYTE ** ppBuffer)
{
    ValidateReadWritePtr(ppBuffer,sizeof(BYTE *));

    // creator must have set pointer either during
    // constructor or by SetPointer
    ASSERT(m_pBuffer);

    *ppBuffer = m_pBuffer;
    return NOERROR;
}


// return the size in bytes of this buffer
STDMETHODIMP_(LONG)
CMediaSampleWrapper::GetSize(void)
{
    return m_cbBuffer;
}


// get the stream time at which this sample should start and finish.
STDMETHODIMP
CMediaSampleWrapper::GetTime(
    REFERENCE_TIME * pTimeStart,     // put time here
    REFERENCE_TIME * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(REFERENCE_TIME));
    ValidateReadWritePtr(pTimeEnd,sizeof(REFERENCE_TIME));

    if (!(m_dwFlags & Sample_StopValid)) {
        if (!(m_dwFlags & Sample_TimeValid)) {
            return VFW_E_SAMPLE_TIME_NOT_SET;
        } else {
            *pTimeStart = m_Start;

            //  Make sure old stuff works
            *pTimeEnd = m_Start + 1;
            return VFW_S_NO_STOP_TIME;
        }
    }

    *pTimeStart = m_Start;
    *pTimeEnd = m_End;
    return NOERROR;
}


// Set the stream time at which this sample should start and finish.
// NULL pointers means the time is reset
STDMETHODIMP
CMediaSampleWrapper::SetTime(
    REFERENCE_TIME * pTimeStart,
    REFERENCE_TIME * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~(Sample_TimeValid | Sample_StopValid);
    } else {
        if (pTimeEnd == NULL) {
            m_Start = *pTimeStart;
            m_dwFlags |= Sample_TimeValid;
            m_dwFlags &= ~Sample_StopValid;
        } else {
            ValidateReadPtr(pTimeStart,sizeof(REFERENCE_TIME));
            ValidateReadPtr(pTimeEnd,sizeof(REFERENCE_TIME));
            ASSERT(*pTimeEnd >= *pTimeStart);

            m_Start = *pTimeStart;
            m_End = *pTimeEnd;
            m_dwFlags |= Sample_TimeValid | Sample_StopValid;
        }
    }
    return NOERROR;
}


// get the media times (eg bytes) for this sample
STDMETHODIMP
CMediaSampleWrapper::GetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(LONGLONG));
    ValidateReadWritePtr(pTimeEnd,sizeof(LONGLONG));

    if (!(m_dwFlags & Sample_MediaTimeValid)) {
        return VFW_E_MEDIA_TIME_NOT_SET;
    }

    *pTimeStart = m_MediaStart;
    *pTimeEnd = (m_MediaStart + m_MediaEnd);
    return NOERROR;
}


// Set the media times for this sample
STDMETHODIMP
CMediaSampleWrapper::SetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~Sample_MediaTimeValid;
    } else {
        ValidateReadPtr(pTimeStart,sizeof(LONGLONG));
        ValidateReadPtr(pTimeEnd,sizeof(LONGLONG));
        ASSERT(*pTimeEnd >= *pTimeStart);

        m_MediaStart = *pTimeStart;
        m_MediaEnd = (LONG)(*pTimeEnd - *pTimeStart);
        m_dwFlags |= Sample_MediaTimeValid;
    }
    return NOERROR;
}


STDMETHODIMP
CMediaSampleWrapper::IsSyncPoint(void)
{
    if (m_dwFlags & Sample_SyncPoint) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}


STDMETHODIMP
CMediaSampleWrapper::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
        m_dwFlags |= Sample_SyncPoint;
    } else {
        m_dwFlags &= ~Sample_SyncPoint;
    }
    return NOERROR;
}

// returns S_OK if there is a discontinuity in the data (this same is
// not a continuation of the previous stream of data
// - there has been a seek).
STDMETHODIMP
CMediaSampleWrapper::IsDiscontinuity(void)
{
    if (m_dwFlags & Sample_Discontinuity) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

// set the discontinuity property - TRUE if this sample is not a
// continuation, but a new sample after a seek.
STDMETHODIMP
CMediaSampleWrapper::SetDiscontinuity(BOOL bDiscont)
{
    // should be TRUE or FALSE
    if (bDiscont) {
        m_dwFlags |= Sample_Discontinuity;
    } else {
        m_dwFlags &= ~Sample_Discontinuity;
    }
    return S_OK;
}

STDMETHODIMP
CMediaSampleWrapper::IsPreroll(void)
{
    if (m_dwFlags & Sample_Preroll) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}


STDMETHODIMP
CMediaSampleWrapper::SetPreroll(BOOL bIsPreroll)
{
    if (bIsPreroll) {
        m_dwFlags |= Sample_Preroll;
    } else {
        m_dwFlags &= ~Sample_Preroll;
    }
    return NOERROR;
}

STDMETHODIMP_(LONG)
CMediaSampleWrapper::GetActualDataLength(void)
{
    return m_lActual;
}


STDMETHODIMP
CMediaSampleWrapper::SetActualDataLength(LONG lActual)
{
    if (lActual > m_cbBuffer) {
        ASSERT(lActual <= GetSize());
        return VFW_E_BUFFER_OVERFLOW;
    }
    m_lActual = lActual;
    return NOERROR;
}


/* These allow for limited format changes in band */

STDMETHODIMP
CMediaSampleWrapper::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    ValidateReadWritePtr(ppMediaType,sizeof(AM_MEDIA_TYPE *));
    ASSERT(ppMediaType);

    /* Do we have a new media type for them */

    if (!(m_dwFlags & Sample_TypeChanged)) {
        ASSERT(m_pMediaType == NULL);
        *ppMediaType = NULL;
        return S_FALSE;
    }

    ASSERT(m_pMediaType);

    /* Create a copy of our media type */

    *ppMediaType = CreateMediaType(m_pMediaType);
    if (*ppMediaType == NULL) {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}


/* Mark this sample as having a different format type */

STDMETHODIMP
CMediaSampleWrapper::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    /* Delete the current media type */

    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
        m_pMediaType = NULL;
    }

    /* Mechanism for resetting the format type */

    if (pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
        return NOERROR;
    }

    ASSERT(pMediaType);
    ValidateReadPtr(pMediaType,sizeof(AM_MEDIA_TYPE));

    /* Take a copy of the media type */

    m_pMediaType = CreateMediaType(pMediaType);
    if (m_pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
        return E_OUTOFMEMORY;
    }

    m_dwFlags |= Sample_TypeChanged;
    return NOERROR;
}

// Set and get properties (IMediaSample2)
STDMETHODIMP CMediaSampleWrapper::GetProperties(
    DWORD cbProperties,
    BYTE * pbProperties
)
{
    if (0 != cbProperties) {
        CheckPointer(pbProperties, E_POINTER);
        //  Return generic stuff up to the length
        AM_SAMPLE2_PROPERTIES Props;
        Props.cbData     = min(cbProperties, sizeof(Props));
        Props.dwSampleFlags = m_dwFlags & ~Sample_MediaTimeValid;
        Props.dwTypeSpecificFlags = m_dwTypeSpecificFlags;
        Props.pbBuffer   = m_pBuffer;
        Props.cbBuffer   = m_cbBuffer;
        Props.lActual    = m_lActual;
        Props.tStart     = m_Start;
        Props.tStop      = m_End;
        Props.dwStreamId = m_dwStreamId;
        if (m_dwFlags & AM_SAMPLE_TYPECHANGED) {
            Props.pMediaType = m_pMediaType;
        } else {
            Props.pMediaType = NULL;
        }
        CopyMemory(pbProperties, &Props, Props.cbData);
    }
    return S_OK;
}

HRESULT CMediaSampleWrapper::SetProperties(
    DWORD cbProperties,
    const BYTE * pbProperties
)
{

    /*  Generic properties */
    AM_MEDIA_TYPE *pMediaType = NULL;

    if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbData, cbProperties)) {
        CheckPointer(pbProperties, E_POINTER);
        AM_SAMPLE2_PROPERTIES *pProps =
            (AM_SAMPLE2_PROPERTIES *)pbProperties;

        /*  Don't use more data than is actually there */
        if (pProps->cbData < cbProperties) {
            cbProperties = pProps->cbData;
        }
        /*  We only handle IMediaSample2 */
        if (cbProperties > sizeof(*pProps) ||
            pProps->cbData > sizeof(*pProps)) {
            return E_INVALIDARG;
        }
        /*  Do checks first, the assignments (for backout) */
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Check the flags */
            if (pProps->dwSampleFlags &
                    (~Sample_ValidFlags | Sample_MediaTimeValid)) {
                return E_INVALIDARG;
            }
            /*  Check a flag isn't being set for a property
                not being provided
            */
            if ((pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID) &&
                 !(m_dwFlags & AM_SAMPLE_TIMEVALID) &&
                 !DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {
                 return E_INVALIDARG;
            }
        }
        /*  NB - can't SET the pointer or size */
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pbBuffer, cbProperties)) {

            /*  Check pbBuffer */
            if (pProps->pbBuffer != 0 && pProps->pbBuffer != m_pBuffer) {
                return E_INVALIDARG;
            }
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties)) {

            /*  Check cbBuffer */
            if (pProps->cbBuffer != 0 && pProps->cbBuffer != m_cbBuffer) {
                return E_INVALIDARG;
            }
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties) &&
            DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {

            /*  Check lActual */
            if (pProps->cbBuffer < pProps->lActual) {
                return E_INVALIDARG;
            }
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {

            /*  Check pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                CheckPointer(pProps->pMediaType, E_POINTER);
                pMediaType = CreateMediaType(pProps->pMediaType);
                if (pMediaType == NULL) {
                    return E_OUTOFMEMORY;
                }
            }
        }

        /*  Now do the assignments */
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwStreamId, cbProperties)) {
            m_dwStreamId = pProps->dwStreamId;
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Set the flags */
            m_dwFlags = pProps->dwSampleFlags |
                                (m_dwFlags & Sample_MediaTimeValid);
            m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
        } else {
            if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwTypeSpecificFlags, cbProperties)) {
                m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
            }
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {
            /*  Set lActual */
            m_lActual = pProps->lActual;
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {

            /*  Set the times */
            m_End   = pProps->tStop;
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStart, cbProperties)) {

            /*  Set the times */
            m_Start = pProps->tStart;
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {
            /*  Set pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                if (m_pMediaType != NULL) {
                    DeleteMediaType(m_pMediaType);
                }
                m_pMediaType = pMediaType;
            }
        }

        /*  Fix up the type changed flag to correctly reflect the current state
            If, for instance the input contained no type change but the
            output does then if we don't do this we'd lose the
            output media type.
        */
        if (m_pMediaType) {
            m_dwFlags |= Sample_TypeChanged;
        } else {
            m_dwFlags &= ~Sample_TypeChanged;
        }
    }

    return S_OK;
}

//  ============================================================================
//  ============================================================================

void
CDVRIMediaSample::Recycle_ (
    )
{
    m_pOwningPool -> Recycle (this) ;
}

//  ============================================================================
//  ============================================================================

void
CPooledMediaSampleWrapper::Recycle_ (
    )
{
    m_pOwningPool -> Recycle (this) ;
}

//  ============================================================================
//  ============================================================================

CDVRIMediaSample *
CDVRIMediaSamplePool::Get (
    )
{
    CDVRIMediaSample * pDVRIMediaSample ;

    pDVRIMediaSample = TCDynamicProdCons <CDVRIMediaSample>::Get () ;
    if (pDVRIMediaSample) {
        pDVRIMediaSample -> AddRef () ;
    }

    return pDVRIMediaSample ;
}

CDVRIMediaSample *
CDVRIMediaSamplePool::TryGet (
    )
{
    CDVRIMediaSample * pDVRIMediaSample ;

    pDVRIMediaSample = TCDynamicProdCons <CDVRIMediaSample>::TryGet () ;
    if (pDVRIMediaSample) {
        pDVRIMediaSample -> AddRef () ;
    }

    return pDVRIMediaSample ;
}

void
CDVRIMediaSamplePool::Recycle (
    IN  CDVRIMediaSample * pDVRIMediaSample
    )
{
    TCDynamicProdCons <CDVRIMediaSample>::Recycle (pDVRIMediaSample) ;
}

//  ============================================================================
//  ============================================================================

CPooledMediaSampleWrapper *
CMediaSampleWrapperPool::Get (
    )
{
    CPooledMediaSampleWrapper * pMSWrapper ;

    pMSWrapper = TCDynamicProdCons <CPooledMediaSampleWrapper>::Get () ;
    if (pMSWrapper) {
        pMSWrapper -> AddRef () ;
    }

    return pMSWrapper ;
}

CPooledMediaSampleWrapper *
CMediaSampleWrapperPool::TryGet (
    )
{
    CPooledMediaSampleWrapper * pMSWrapper ;

    pMSWrapper = TCDynamicProdCons <CPooledMediaSampleWrapper>::TryGet () ;
    if (pMSWrapper) {
        pMSWrapper -> AddRef () ;
    }

    return pMSWrapper ;
}

//  ============================================================================
//  ============================================================================

CDVRAttribute::CDVRAttribute (
    ) : m_dwAttributeSize   (0)
{
}

HRESULT
CDVRAttribute::SetAttributeData (
    IN  GUID    guid,
    IN  LPVOID  pvData,
    IN  DWORD   dwSize
    )
{
    DWORD   dw ;
    HRESULT hr ;

    if (!pvData &&
        dwSize > 0) {

        return E_POINTER ;
    }

    dw = m_AttributeData.Copy (
            reinterpret_cast <BYTE *> (pvData),
            dwSize
            ) ;
    if (dw == NOERROR) {
        //  size always is set
        m_dwAttributeSize = dwSize ;

        //  GUID always gets set
        m_guidAttribute = guid ;

        //  success
        hr = S_OK ;
    }
    else {
        hr = HRESULT_FROM_WIN32 (dw) ;
    }

    return hr ;
}

BOOL
CDVRAttribute::IsEqual (
    IN  REFGUID rguid
    )
{
    return (rguid == m_guidAttribute ? TRUE : FALSE) ;
}

HRESULT
CDVRAttribute::GetAttribute (
    IN      GUID    guid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    HRESULT hr ;

    if (!pdwDataLen) {
        return E_POINTER ;
    }

    if (IsEqual (guid)) {

        ASSERT (m_AttributeData.GetBufferLength () >= m_dwAttributeSize) ;

        if (pvData) {
            //  caller wants the data
            (* pdwDataLen) = Min <DWORD> ((* pdwDataLen), m_dwAttributeSize) ;
            CopyMemory (pvData, m_AttributeData.Buffer (), (* pdwDataLen)) ;
        }
        else {
            //  caller just wants to know how big
            (* pdwDataLen) = m_dwAttributeSize ;
        }

        //  success
        hr = S_OK ;
    }
    else {
        //  not the right guid
        hr = NS_E_UNSUPPORTED_PROPERTY ;
    }

    return hr ;
}

HRESULT
CDVRAttribute::GetAttributeData (
    OUT     GUID *  pguid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    //  set the GUID
    ASSERT (pguid) ;
    (* pguid) = m_guidAttribute ;

    //  retrieve the attributes
    return GetAttribute (
                (* pguid),
                pvData,
                pdwDataLen
                ) ;
}

//  ============================================================================
//      CDVRAttributeList
//  ============================================================================

CDVRAttributeList::CDVRAttributeList (
    ) : m_pAttribListHead   (NULL),
        m_cAttributes       (0)
{
}

CDVRAttributeList::~CDVRAttributeList (
    )
{
    Reset () ;
}

CDVRAttribute *
CDVRAttributeList::PopListHead_ (
    )
{
    CDVRAttribute *    pCur ;

    pCur = m_pAttribListHead ;
    if (pCur) {
        m_pAttribListHead = m_pAttribListHead -> m_pNext ;
        pCur -> m_pNext = NULL ;

        ASSERT (m_cAttributes > 0) ;
        m_cAttributes-- ;
    }

    return pCur ;
}

CDVRAttribute *
CDVRAttributeList::GetIndexed_ (
    IN  LONG    lIndex
    )
{
    LONG            lCur ;
    CDVRAttribute * pCur ;

    ASSERT (lIndex < GetCount ()) ;
    ASSERT (lIndex >= 0) ;

    for (lCur = 0, pCur = m_pAttribListHead;
         lCur < lIndex;
         lCur++, pCur = pCur -> m_pNext) ;

    return pCur ;
}

CDVRAttribute *
CDVRAttributeList::FindInList_ (
    IN  GUID    guid
    )
{
    CDVRAttribute *    pCur ;

    for (pCur = m_pAttribListHead;
         pCur && !pCur -> IsEqual (guid);
         pCur = pCur -> m_pNext) ;

    return pCur ;
}

    CDVRAttribute *
    GetIndexed_ (
        IN  LONG    lIndex
        ) ;

void
CDVRAttributeList::InsertInList_ (
    IN  CDVRAttribute *    pNew
    )
{
    pNew -> m_pNext = m_pAttribListHead ;
    m_pAttribListHead = pNew ;

    m_cAttributes++ ;
}

HRESULT
CDVRAttributeList::AddAttribute (
    IN  GUID    guid,
    IN  LPVOID  pvData,
    IN  DWORD   dwSize
    )
{
    HRESULT         hr ;
    CDVRAttribute * pNew ;

    pNew = FindInList_ (guid) ;
    if (!pNew) {
        pNew = Get () ;
        if (pNew) {
            hr = pNew -> SetAttributeData (
                    guid,
                    pvData,
                    dwSize
                    ) ;

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle (pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  duplicates don't make sense; closest error found in winerror.h
        hr = HRESULT_FROM_WIN32 (ERROR_DUPLICATE_TAG) ;
    }

    return hr ;
}

HRESULT
CDVRAttributeList::GetAttribute (
    IN      GUID    guid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    HRESULT         hr ;
    CDVRAttribute * pAttrib ;

    pAttrib = FindInList_ (guid) ;
    if (pAttrib) {
        hr = pAttrib -> GetAttribute (
                guid,
                pvData,
                pdwDataLen
                ) ;
    }
    else {
        hr = NS_E_UNSUPPORTED_PROPERTY ;
    }

    return hr ;
}

HRESULT
CDVRAttributeList::GetAttributeIndexed (
    IN      LONG    lIndex,
    OUT     GUID *  pguidAttribute,
    OUT     LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    CDVRAttribute * pAttrib ;

    if (lIndex < 0 ||
        lIndex >= GetCount ()) {
        return E_INVALIDARG ;
    }

    pAttrib = GetIndexed_ (lIndex) ;
    ASSERT (pAttrib) ;

    return pAttrib -> GetAttributeData (
            pguidAttribute,
            pvData,
            pdwDataLen
            ) ;
}

void
CDVRAttributeList::Reset (
    )
{
    CDVRAttribute *    pCur ;

    for (;;) {
        pCur = PopListHead_ () ;
        if (pCur) {
                Recycle (pCur) ;
        }
        else {
            break ;
        }
    }
}

//  ============================================================================
//      CWMINSSBuffer3Wrapper
//  ============================================================================

CWMINSSBuffer3Wrapper::CWMINSSBuffer3Wrapper (
    ) : m_punkCore              (NULL),
        m_cRef                  (0)
{
}

CWMINSSBuffer3Wrapper::~CWMINSSBuffer3Wrapper (
    )
{
    Reset_ () ;
}

HRESULT
CWMINSSBuffer3Wrapper::Init (
    IN  IUnknown *  punkCore,
    IN  BYTE *      pbBuffer,
    IN  DWORD       dwLength
    )
{
    ASSERT (punkCore) ;
    ASSERT (pbBuffer) ;

    m_punkCore = punkCore ;
    m_punkCore -> AddRef () ;

    m_dwBufferLength = m_dwMaxBufferLength = dwLength ;

    m_pbBuffer = pbBuffer ;

    return S_OK ;
}

void
CWMINSSBuffer3Wrapper::Reset_ (
    )
{
    m_AttribList.Reset () ;
    RELEASE_AND_CLEAR (m_punkCore) ;
}

// IUnknown
STDMETHODIMP
CWMINSSBuffer3Wrapper::QueryInterface (
    REFIID riid,
    void **ppv
    )
{
    if (riid == IID_INSSBuffer) {
        return GetInterface((INSSBuffer *) this, ppv);
    }
    else if (riid == IID_INSSBuffer2) {
        return GetInterface((INSSBuffer2 *) this, ppv);
    }
    else if (riid == IID_INSSBuffer3) {
        return GetInterface((INSSBuffer3 *) this, ppv);
    }
    else if (riid == IID_IUnknown) {
        //  ambiguous, so we pick the first interface we inherit from
        return GetInterface ((INSSBuffer3 *) this, ppv) ;
    }
    else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CWMINSSBuffer3Wrapper::Release()
{
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    if (lRef == 0) {
        Reset_ () ;
        Recycle_ () ;
    }

    return (ULONG)lRef;
}

STDMETHODIMP_(ULONG)
CWMINSSBuffer3Wrapper::AddRef()
{
    return InterlockedIncrement (& m_cRef) ;
}

// INSSBuffer
STDMETHODIMP
CWMINSSBuffer3Wrapper::GetLength (
    OUT DWORD * pdwLength
    )
{
    if (!pdwLength) {
        return E_POINTER ;
    }

    (* pdwLength) = m_dwBufferLength ;
    return S_OK ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::SetLength (
    IN  DWORD dwLength
    )
{
    HRESULT hr ;

    if (dwLength <= m_dwMaxBufferLength) {
        m_dwBufferLength = dwLength ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_BUFFER_OVERFLOW ;
    }

    return hr ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetMaxLength (
    OUT DWORD * pdwLength
    )
{
    if (!pdwLength) {
        return E_POINTER ;
    }

    (* pdwLength) = m_dwMaxBufferLength ;
    return S_OK ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetBufferAndLength (
    OUT BYTE ** ppdwBuffer,
    OUT DWORD * pdwLength
    )
{
    if (!ppdwBuffer ||
        !pdwLength) {
        return E_POINTER ;
    }

    (* ppdwBuffer)  = m_pbBuffer ;
    (* pdwLength)   = m_dwBufferLength ;

    return S_OK ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetBuffer (
    IN  BYTE ** ppdwBuffer
    )
{
    if (!ppdwBuffer) {
        return E_POINTER ;
    }

    (* ppdwBuffer)  = m_pbBuffer ;

    return S_OK ;
}

//  INSSBuffer2
STDMETHODIMP
CWMINSSBuffer3Wrapper::GetSampleProperties (
    IN  DWORD   cbProperties,
    OUT BYTE *  pbProperties
    )
{
    return E_NOTIMPL ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::SetSampleProperties (
    IN  DWORD cbProperties,
    IN  BYTE * pbProperties
    )
{
    return E_NOTIMPL ;
}

//  INSSBuffer3Wrapper
STDMETHODIMP
CWMINSSBuffer3Wrapper::SetProperty (
    IN  GUID    guidProperty,
    IN  void *  pvProperty,
    IN  DWORD   dwPropertySize
    )
{
    return m_AttribList.AddAttribute (
                guidProperty,
                pvProperty,
                dwPropertySize
                ) ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetProperty (
    IN      GUID    guidProperty,
    OUT     void *  pvProperty,
    IN OUT  DWORD * pdwPropertySize
    )
{
    return m_AttribList.GetAttribute (
                guidProperty,
                pvProperty,
                pdwPropertySize
                ) ;
}

//  ============================================================================

void
CPooledWMINSSBuffer3Wrapper::Recycle_ (
    )
{
    m_pOwningPool -> Recycle (this) ;
}


//  ============================================================================
//      CWMPooledINSSBuffer3Holder
//  ============================================================================

//  IUnknown
STDMETHODIMP
CWMPooledINSSBuffer3Holder::QueryInterface ( REFIID riid, void **ppv )
{
    if (riid == IID_INSSBuffer) {
        return GetInterface((INSSBuffer *) this, ppv);
    }
    else if (riid == IID_INSSBuffer2) {
        return GetInterface((INSSBuffer2 *) this, ppv);
    }
    else if (riid == IID_INSSBuffer3) {
        return GetInterface((INSSBuffer3 *) this, ppv);
    }
    else if (riid == IID_IUnknown) {
        //  ambiguous, so we pick the first interface we inherit from
        return GetInterface ((INSSBuffer3 *) this, ppv) ;
    }
    else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CWMPooledINSSBuffer3Holder::Release(
    )
{
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    if (lRef == 0) {
        Reset_ () ;
        Recycle_ () ;
    }

    return (ULONG)lRef;
}

STDMETHODIMP_(ULONG)
CWMPooledINSSBuffer3Holder::AddRef()
{
    return InterlockedIncrement (& m_cRef) ;
}

HRESULT
CWMPooledINSSBuffer3Holder::Init (
    IN  INSSBuffer * pINSSBuffer
    )
{
    ASSERT (!m_pINSSBuffer3Core) ;
    return pINSSBuffer -> QueryInterface (
                IID_INSSBuffer3,
                (void **) & m_pINSSBuffer3Core
                ) ;
}

void
CWMPooledINSSBuffer3Holder::Reset_ (
    )
{
    RELEASE_AND_CLEAR (m_pINSSBuffer3Core) ;
}

void
CWMPooledINSSBuffer3Holder::Recycle_ (
    )
{
    m_pOwningPool -> Recycle (this) ;
}

//  ============================================================================
//  ============================================================================

CDVRAttributeTranslator::CDVRAttributeTranslator (
    IN  CDVRPolicy *        pPolicy,
    IN  int                 iFlowId
    ) : m_iFlowId   (iFlowId),
        m_pPolicy   (pPolicy)
{
    ASSERT (m_pPolicy) ;
    m_pPolicy -> AddRef () ;
}

CDVRAttributeTranslator::~CDVRAttributeTranslator (
    )
{
    m_pPolicy -> Release () ;
}

//  ============================================================================
//  ============================================================================

CDVRDShowToWMSDKTranslator::CDVRDShowToWMSDKTranslator (
    IN  CDVRPolicy *        pPolicy,
    IN  int                 iFlowId
    ) : CDVRAttributeTranslator     (pPolicy, iFlowId),
        m_dwContinuityCounterNext   (0),
        m_dwGlobalAnalysisFlags     (0)
{
    //  one-time setting; this does change over time
    m_fInlineDShowProps     = Policy_ () -> Settings () -> InlineDShowProps () ;
    //  default to no analysis; we'll get set otherwise later
    SetAnalysisPresent (FALSE) ;
}

HRESULT
CDVRDShowToWMSDKTranslator::InlineProperties_ (
    IN      DWORD           dwSamplesPerSec,
    IN      IMediaSample *  pIMS,
    IN OUT  INSSBuffer3 *   pINSSBuffer3
    )
{
    AM_MEDIA_TYPE * pmt ;
    HRESULT         hr ;

    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer3) ;

    //  ========================================================================
    //  dshow attributes
    if (m_fInlineDShowProps) {
        hr = DShowWMSDKHelpers::SetSBEAttributes (
                dwSamplesPerSec,
                pIMS,
                pINSSBuffer3,
                & m_dwContinuityCounterNext
                ) ;
    }
    else {
        hr = E_NOTIMPL ;
    }

    //  ========================================================================
    //  dynamic format change
    if (SUCCEEDED (hr) &&
        pIMS -> GetMediaType (& pmt) == S_OK) {

        ASSERT (pmt) ;
        hr = DShowWMSDKHelpers::InlineNewMediaType (pINSSBuffer3, pmt) ;
        FreeMediaType (* pmt) ;
    }

    //  ========================================================================
    //  encryption attribute
    hr = SetEncryptionAttribute_ (pIMS, pINSSBuffer3) ;

    return hr ;
}


HRESULT
CDVRDShowToWMSDKTranslator::SetEncryptionAttribute_ (
    IN  IMediaSample *  pIMS,
    IN  INSSBuffer3 *   pINSSBuffer3
    )
{
    HRESULT hr ;
    DWORD   dwLen ;
    DWORD   dwRet ;
    BOOL    r ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (pIMS) ;

    hr = S_OK ;

    r = DVRAttributeHelpers::IsAttributePresent (pIMS, ATTRID_ENCDEC_BLOCK_SBE) ;
    if (r) {

        hr = DVRAttributeHelpers::GetAttribute (
                pIMS,
                ATTRID_ENCDEC_BLOCK_SBE,
                & dwLen,
                NULL
                ) ;

        if (SUCCEEDED (hr)) {

            dwRet = m_Scratch.SetMinLen (dwLen) ;

            if (dwRet == NOERROR) {

                hr = DVRAttributeHelpers::GetAttribute (
                        pIMS,
                        ATTRID_ENCDEC_BLOCK_SBE,
                        & dwLen,
                        m_Scratch.Buffer ()
                        ) ;

                if (SUCCEEDED (hr)) {

                    hr = DVRAttributeHelpers::SetAttribute (
                            pINSSBuffer3,
                            ATTRID_ENCDEC_BLOCK_SBE,
                            dwLen,
                            m_Scratch.Buffer ()
                            ) ;
                }
            }
            else {
                hr = HRESULT_FROM_WIN32 (dwRet) ;
            }
        }
    }

    return hr ;
}

HRESULT
CDVRDShowToWMSDKTranslator::SetAttributesWMSDK (
    IN  CDVRReceiveStatsWriter *    pRecvStatsWriter,
    IN  DWORD                       dwSamplesPerSec,
    IN  IReferenceClock *           pRefClock,
    IN  IMediaSample *              pIMS,
    OUT INSSBuffer3 *               pINSSBuffer3,
    OUT DWORD *                     pdwWMSDKFlags
    )
{
    HRESULT hr ;

    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer3) ;
    ASSERT (pdwWMSDKFlags) ;
    ASSERT (pRefClock) ;

    //  flags
    (* pdwWMSDKFlags) = 0 ;
    if (pIMS -> IsDiscontinuity () == S_OK) {
        (* pdwWMSDKFlags) |= WM_SF_DISCONTINUITY ;
    }

    // Workaround for bug# 629263
    // For a MS that is saved cross file bounary, the Seek(0) of format SDK will
    // skip data at the beginning of a file until it reaches next clean point. This
    // SDK bug causes the data at the beginning of a file to be lost if a MS is not
    // marked as a clean point. This bit is save in:
    //   DShow->WMSDK (write to file):   SetAttributesWMSDK() <here> and below
    //   WMSDK->DShow (read from file):  SetAttributesDShow()
    if(IsCleanPoint(pIMS))
        (* pdwWMSDKFlags) |= WM_SF_CLEANPOINT ;

    //  inline data
    hr = InlineProperties_ (
            dwSamplesPerSec,
            pIMS,
            pINSSBuffer3
            ) ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRWMSDKToDShowTranslator::CDVRWMSDKToDShowTranslator (
    IN  CDVRPolicy *    pPolicy,
    IN  int             iFlowId
    ) : CDVRAttributeTranslator     (pPolicy, iFlowId),
        m_dwContinuityCounterNext   (UNDEFINED)
{
}

CDVRWMSDKToDShowTranslator::~CDVRWMSDKToDShowTranslator (
    )
{
}

void
CDVRWMSDKToDShowTranslator::TransferEncryptionAttribute_ (
    IN      INSSBuffer3 *   pINSSBuffer3,
    IN OUT  IMediaSample *  pIMS
    )
{
    HRESULT hr ;
    DWORD   dwLen ;
    DWORD   dwRet ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (pIMS) ;
    ASSERT (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, ATTRID_ENCDEC_BLOCK_SBE)) ;

    hr = DVRAttributeHelpers::GetAttribute (
            pINSSBuffer3,
            ATTRID_ENCDEC_BLOCK_SBE,
            & dwLen,
            NULL
            ) ;

    if (SUCCEEDED (hr)) {
        ASSERT (dwLen > 0) ;

        dwRet = m_Scratch.SetMinLen (dwLen) ;

        if (dwRet == NOERROR) {

            hr = DVRAttributeHelpers::GetAttribute (
                    pINSSBuffer3,
                    ATTRID_ENCDEC_BLOCK_SBE,
                    & dwLen,
                    m_Scratch.Buffer ()
                    ) ;

            if (SUCCEEDED (hr)) {
                ASSERT (dwLen > 0) ;

                hr = DVRAttributeHelpers::SetAttribute (
                        pIMS,
                        ATTRID_ENCDEC_BLOCK_SBE,
                        dwLen,
                        m_Scratch.Buffer ()
                        ) ;
            }
        }
        else {
            hr = HRESULT_FROM_WIN32 (dwRet) ;
        }
    }
}

HRESULT
CDVRWMSDKToDShowTranslator::RecoverInlineProperties_ (
    IN      double              dCurRate,
    IN      INSSBuffer *        pINSSBuffer,
    IN OUT  IMediaSample *      pIMS,
    OUT     AM_MEDIA_TYPE **    ppmtNew                 //  dyn format change
    )
{
    AM_SAMPLE2_PROPERTIES   SampleProperties ;
    HRESULT                 hr ;
    INSSBuffer3 *           pINSSBuffer3 ;
    BOOL                    r ;
    IMediaSample2 *         pIMS2 ;

    ASSERT (pINSSBuffer) ;
    ASSERT (pIMS) ;
    ASSERT (ppmtNew) ;

    pINSSBuffer3    = NULL ;
    (* ppmtNew)     = NULL ;

    hr = pINSSBuffer -> QueryInterface (
            IID_INSSBuffer3,
            (void **) & pINSSBuffer3
            ) ;
    if (SUCCEEDED (hr)) {

        #ifdef SBE_PERF
        ::OnReadout_Perf_ (pINSSBuffer3) ;
        #endif  //  SBE_PERF

        //  ====================================================================
        //  recover inlined props, if they're there
        if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, INSSBuffer3Prop_SBE_Attributes)) {

            //  recover the dshow attributes; include the sync point and discontinuity flags.
            hr = DShowWMSDKHelpers::RecoverSBEAttributes (
                    pINSSBuffer3,
                    pIMS,
                    dCurRate,                 // Direction of data flow
                    &m_dwContinuityCounterNext
                    ) ;
        }
        else {
            //  we're not implemented to NOT recover the attributes via
            //   INSSBuffer3 i.e. recover the times directly from the WMSDK
            hr = E_NOTIMPL ;
        }

        //  ====================================================================
        //  check for a dynamic format change; only care about dynamic format
        //    changes if we're moving forward; if we're reading backwards and
        //    we cross a boundary it's nearly impossible; note that we have a
        //    "shotgun" approach to accepting/rejecting on the input side; the
        //    default is to accept, but since most observed occur right at graph
        //    start we don't go back and forth over the boundary
        if (SUCCEEDED (hr)  &&
            dCurRate > 0    &&
            DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, INSSBuffer3Prop_DShowNewMediaType)) {

            //  recover the new media type
            hr = DShowWMSDKHelpers::RecoverNewMediaType (
                    pINSSBuffer3,
                    ppmtNew
                    ) ;

            //  if we successfully recovered a media type, we must tag the
            //   media sample with it
            if (SUCCEEDED (hr) &&
                (* ppmtNew)) {

                //  want to pass back out the pointer to the actual media type,
                //   not a copy
                hr = pIMS -> SetMediaType (* ppmtNew) ;
                if (SUCCEEDED (hr)) {
                    //  free allocated in the RecoverNewMediaType call
                    DeleteMediaType (* ppmtNew) ;
                    (* ppmtNew) = NULL ;

                    //  retrieve a direct pointer to the media type in the
                    //   media sample (vs. making a copy of it)
                    hr = pIMS -> QueryInterface (IID_IMediaSample2, (void **) & pIMS2) ;
                    if (SUCCEEDED (hr)) {
                        hr = pIMS2 -> GetProperties (
                                            sizeof SampleProperties,
                                            reinterpret_cast <BYTE *> (& SampleProperties)
                                            ) ;
                        if (SUCCEEDED (hr)) {
                            (* ppmtNew) = SampleProperties.pMediaType ;
                        }

                        pIMS2 -> Release () ;
                    }
                }
            }
        }
        else {
            //  clear explicitely
            (* ppmtNew) = NULL ;
        }

        //  ====================================================================
        //  check for the encryption attribute
        if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, ATTRID_ENCDEC_BLOCK_SBE)) {
            TransferEncryptionAttribute_ (pINSSBuffer3, pIMS) ;
        }
    }

    RELEASE_AND_CLEAR (pINSSBuffer3) ;

    return hr ;
}

HRESULT
CDVRWMSDKToDShowTranslator::SetAttributesDShow (
    IN      CDVRSendStatsWriter *   pSendStatsWriter,
    IN      INSSBuffer *            pINSSBuffer,
    IN      QWORD                   cnsStreamTimeOfSample,
    IN      QWORD                   cnsSampleDuration,
    IN      DWORD                   dwFlags,
    IN      double                  dCurRate,
    OUT     DWORD *                 pdwMuxedStreamStats,
    IN OUT  IMediaSample *          pIMS,
    OUT     AM_MEDIA_TYPE **        ppmtNew                 //  dyn format change
    )
{
    HRESULT hr ;

    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer) ;

    //  NOTE: we set these before trying to use the attributes; if we cannot
    //      recover an attribute, or if the policy on the writer was such that
    //      an attribute was left out, we'll fall back on the flags provided
    //      to us via the WMSDK, but when we cross file-boundaries, they will
    //      not be correct
    pIMS -> SetDiscontinuity (dwFlags & WM_SF_DISCONTINUITY) ;

    // Will set SynPoint based on our own setting than SDK's
    INSSBUFFER3PROP_SBE_ATTRIB  SBEAttrib ;
    INSSBuffer3 *               pINSSBuffer3 ;
    DWORD                       dwSize ;
    BOOL                        r;

    //  recover the attributes
    hr = pINSSBuffer -> QueryInterface (IID_INSSBuffer3, (void **) & pINSSBuffer3) ;

    if (SUCCEEDED (hr)) {

        r = DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, INSSBuffer3Prop_SBE_Attributes) ;

        if (r) {

            dwSize = sizeof (SBEAttrib) ;

            hr = DVRAttributeHelpers::GetAttribute (
                    pINSSBuffer3,
                    INSSBuffer3Prop_SBE_Attributes,
                    & dwSize,
                    (BYTE *) &SBEAttrib
                    ) ;

            if(SUCCEEDED (hr) &&
                dwSize == sizeof (SBEAttrib)) {

                // Bug# 629263 (WMSDK->DShow, read)
                // Ignore WM_SF_CLEANPOINT setting, and use saved SyncPoint flag instead.
                pIMS -> SetSyncPoint(IS_SBE_SYNCPOINT(SBEAttrib.dwFlags));

                //  recover the muxed stream stats
                (* pdwMuxedStreamStats) = SBEAttrib.dwMuxedStreamStats ;

            } else if (dwSize != sizeof (SBEAttrib)){
                hr = NS_E_INVALID_DATA;
            }
        } else {
            hr = NS_E_INVALID_DATA;
        }
        pINSSBuffer3 -> Release () ;
    }

    hr = RecoverInlineProperties_ (
            dCurRate,
            pINSSBuffer,
            pIMS,
            ppmtNew
            ) ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRWMSDKToDShowMpeg2Translator::FlagAnalysisPresent_ (
    IN      INSSBuffer3 *   pINSSBuffer3,
    IN      IAttributeSet * pDVRAttribSet,
    IN OUT  BOOL *          pfAnalysisPresent
    )
{
    BOOL    r ;
    DWORD   dwAnalysisGlobal ;
    HRESULT hr ;
    DWORD   dwSize ;

    DVR_ANALYSIS_GLOBAL_CLEAR (dwAnalysisGlobal) ;

    //  is the property present ?
    r = DVRAttributeHelpers::IsAttributePresent (
            pINSSBuffer3,
            DVRAnalysis_Global
            ) ;
    if (r) {
        dwSize = sizeof dwAnalysisGlobal ;
        hr = pINSSBuffer3 -> GetProperty (
                DVRAnalysis_Global,
                (BYTE *) & dwAnalysisGlobal,
                & dwSize
                ) ;
        if (SUCCEEDED (hr)) {
            (* pfAnalysisPresent) = DVR_ANALYSIS_GLOBAL_IS_PRESENT (dwAnalysisGlobal) ;
        }
        else {
            (* pfAnalysisPresent) = FALSE ;
        }
    }
    else {
        (* pfAnalysisPresent) = FALSE ;
    }

    hr = pDVRAttribSet -> SetAttrib (
            DVRAnalysis_Global,
            (BYTE *) & dwAnalysisGlobal,
            sizeof dwAnalysisGlobal
            ) ;

    return hr ;
}

HRESULT
CDVRWMSDKToDShowMpeg2Translator::FlagMpeg2VideoAnalysis_ (
    IN      INSSBuffer3 *   pINSSBuffer3,
    IN      IAttributeSet * pDVRAttribSet
    )
{
    DWORD   dwMpeg2FrameAnalysis ;
    DWORD   dwSize ;
    HRESULT hr ;

    ASSERT (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer3, DVRAnalysis_Mpeg2Video)) ;

    //  frame-analysis attribute is present; retrieve it
    dwSize = sizeof dwMpeg2FrameAnalysis ;
    hr = pINSSBuffer3 -> GetProperty (
            DVRAnalysis_Mpeg2Video,
            (BYTE *) & dwMpeg2FrameAnalysis,
            & dwSize
            ) ;
    if (SUCCEEDED (hr)                          &&
        dwSize == sizeof dwMpeg2FrameAnalysis   &&
        !DVR_ANALYSIS_MP2_IS_NONE (dwMpeg2FrameAnalysis)) {

        //  set it on the outgoing media sample
        hr = pDVRAttribSet -> SetAttrib (
                DVRAnalysis_Mpeg2Video,
                (BYTE *) & dwMpeg2FrameAnalysis,
                sizeof dwMpeg2FrameAnalysis
                ) ;
    }

    /*
    TRACE_4 (LOG_AREA_DVRANALYSIS, 5,
        TEXT ("mpeg-2 analysis RECOVERED : %s frame, boundary = %d; %08xh; %08xh"),
        (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwMpeg2FrameAnalysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER ? TEXT ("I") :
         (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwMpeg2FrameAnalysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_B_FRAME ? TEXT ("B") :
          TEXT ("P")
         )
        ),
        DVR_ANALYSIS_MP2_IS_BOUNDARY (dwMpeg2FrameAnalysis) ? 1 : 0,
        dwMpeg2FrameAnalysis,
        pINSSBuffer3
        ) ;
    */

    return hr ;
}

HRESULT
CDVRWMSDKToDShowMpeg2Translator::RecoverInlineAnalysisData_ (
    IN      CDVRSendStatsWriter *   pSendStatsWriter,
    IN      INSSBuffer *            pINSSBuffer,
    IN OUT  IMediaSample *          pIMS
    )
{
    HRESULT         hr ;
    INSSBuffer3 *   pINSSBuffer3 ;
    IAttributeSet * pDVRAttribSet ;
    BOOL            r ;
    DWORD           dwMpeg2FrameAnalysis ;
    DWORD           dwSize ;
    BOOL            fAnalysisPresent ;

    pDVRAttribSet   = NULL ;
    pINSSBuffer3    = NULL ;

    //  need this interface to get the property
    hr = pINSSBuffer -> QueryInterface (IID_INSSBuffer3, (void **) & pINSSBuffer3) ;
    if (SUCCEEDED (hr)) {
        //  this one to set it
        hr = pIMS -> QueryInterface (IID_IAttributeSet, (void **) & pDVRAttribSet) ;
        if (SUCCEEDED (hr)) {
            fAnalysisPresent = FALSE ;
            hr = FlagAnalysisPresent_ (
                    pINSSBuffer3,
                    pDVRAttribSet,
                    & fAnalysisPresent
                    ) ;
            if (SUCCEEDED (hr) &&
                fAnalysisPresent) {

                hr = FlagMpeg2VideoAnalysis_ (
                        pINSSBuffer3,
                        pDVRAttribSet
                        ) ;
            }
        }
    }

    RELEASE_AND_CLEAR (pDVRAttribSet) ;
    RELEASE_AND_CLEAR (pINSSBuffer3) ;

    return hr ;
}

HRESULT
CDVRWMSDKToDShowMpeg2Translator::SetAttributesDShow (
    IN      CDVRSendStatsWriter *   pSendStatsWriter,
    IN      INSSBuffer *            pINSSBuffer,
    IN      QWORD                   cnsStreamTimeOfSample,
    IN      QWORD                   cnsSampleDuration,
    IN      DWORD                   dwFlags,
    IN      double                  dCurRate,
    OUT     DWORD *                 pdwMuxedStreamStats,
    IN OUT  IMediaSample *          pIMS,
    OUT     AM_MEDIA_TYPE **        ppmtNew                 //  dyn format change
    )
{
    HRESULT hr ;

    hr = CDVRWMSDKToDShowTranslator::SetAttributesDShow (
            pSendStatsWriter,
            pINSSBuffer,
            cnsStreamTimeOfSample,
            cnsSampleDuration,
            dwFlags,
            dCurRate,
            pdwMuxedStreamStats,
            pIMS,
            ppmtNew
            ) ;
    if (SUCCEEDED (hr)) {
        hr = RecoverInlineAnalysisData_ (
                pSendStatsWriter,
                pINSSBuffer,
                pIMS
                ) ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRDShowToWMSDKMpeg2Translator::InlineAnalysisData_ (
    IN      CDVRReceiveStatsWriter *    pRecvStatsWriter,
    IN      IReferenceClock *           pRefClock,
    IN      IMediaSample *              pIMS,
    IN OUT  DWORD *                     pdwWMSDKFlags,
    OUT     INSSBuffer3 *               pINSSBuffer3
    )
{
    HRESULT         hr ;
    IAttributeGet * pIDVRAnalysisGet ;
    DWORD           dwAnalysisDataLen ;
    DWORD           dwMpeg2FrameAnalysis ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    hr = pIMS -> QueryInterface (
                    IID_IAttributeGet,
                    (void **) & pIDVRAnalysisGet
                    ) ;
    if (SUCCEEDED (hr)) {
        //  inline the frame-analysis directly
        dwAnalysisDataLen = sizeof dwMpeg2FrameAnalysis ;
        hr = pIDVRAnalysisGet -> GetAttrib (
                DVRAnalysis_Mpeg2Video,                                 //  guid
                reinterpret_cast <BYTE *> (& dwMpeg2FrameAnalysis),     //  data
                & dwAnalysisDataLen                                     //  size
                ) ;

        //  if there's something there
        if (SUCCEEDED (hr) &&
            dwAnalysisDataLen > 0) {

            /*
            TRACE_5 (LOG_AREA_DVRANALYSIS, 6,
                TEXT ("mpeg-2 analysis COLLECTED : %s frame, boundary = %d; %08xh; sample %s timestamped; %d bytes long"),
                (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwMpeg2FrameAnalysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER ? TEXT ("I") :
                 (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwMpeg2FrameAnalysis) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_B_FRAME ? TEXT ("B") :
                  TEXT ("P")
                 )
                ),
                DVR_ANALYSIS_MP2_IS_BOUNDARY (dwMpeg2FrameAnalysis) ? 1 : 0,
                dwMpeg2FrameAnalysis,
                (SUCCEEDED (pIMS -> GetTime (& rtStart, & rtStop)) ? TEXT ("IS") : TEXT ("IS NOT")),
                pIMS -> GetActualDataLength ()
                ) ;
            */

            //  analysis is present
            pRecvStatsWriter -> Mpeg2SampleWithFrameAnalysis (pIMS, dwMpeg2FrameAnalysis) ;
        }
        else {
            //  no analysis; still need to write something in regardless because
            //   INSSBuffer3 expects it on all samples

            TRACE_2 (LOG_AREA_DVRANALYSIS, 6,
                TEXT ("CDVRDShowToWMSDKMpeg2Translator::InlineAnalysisData_ (); analysis: NONE; sample %s timestamped; %d bytes long"),
                (SUCCEEDED (pIMS -> GetTime (& rtStart, & rtStop)) ? TEXT ("IS") : TEXT ("IS NOT")), pIMS -> GetActualDataLength ()) ;

            //  set the value to be "none"
            DVR_ANALYSIS_MP2_SET_NONE (dwMpeg2FrameAnalysis) ;
            dwAnalysisDataLen = sizeof dwMpeg2FrameAnalysis ;

            pRecvStatsWriter -> Mpeg2SampleWithNoFrameAnalysis (pIMS) ;
        }

        //  write it in
        hr = pINSSBuffer3 -> SetProperty (
                DVRAnalysis_Mpeg2Video,
                reinterpret_cast <BYTE *> (& dwMpeg2FrameAnalysis),
                dwAnalysisDataLen
                ) ;

        pIDVRAnalysisGet -> Release () ;
    }
    else {
        //  still succeed the call - just means we don't have analysis in place
        //    upstream
        hr = S_OK ;
    }

    //  set the prop that indicates if the stream was analyzed
    if (SUCCEEDED (hr)) {
        hr = pINSSBuffer3 -> SetProperty (
                DVRAnalysis_Global,
                reinterpret_cast <BYTE *> (& m_dwGlobalAnalysisFlags),
                sizeof m_dwGlobalAnalysisFlags
                ) ;
    }

    return hr ;
}

HRESULT
CDVRDShowToWMSDKMpeg2Translator::InlineMpeg2Attributes_ (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  IMediaSample *  pIMS
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    hr = pIMS -> GetTime (& rtStart, & rtStop) ;
    if (hr != VFW_E_SAMPLE_TIME_NOT_SET) {
        hr = pINSSBuffer3 -> SetProperty (
                                INSSBuffer3Prop_Mpeg2ElementaryStream,
                                & rtStart,
                                sizeof rtStart
                                ) ;
    }
    else {
        //  no time set; don't fail the call
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVRDShowToWMSDKMpeg2Translator::SetAttributesWMSDK (
    IN  CDVRReceiveStatsWriter *    pRecvStatsWriter,
    IN  DWORD                       dwSamplesPerSec,
    IN  IReferenceClock *           pRefClock,
    IN  IMediaSample *              pIMS,
    OUT INSSBuffer3 *               pINSSBuffer3,
    OUT DWORD *                     pdwWMSDKFlags
    )
{
    HRESULT hr ;

    hr = CDVRDShowToWMSDKTranslator::SetAttributesWMSDK (
            pRecvStatsWriter,
            dwSamplesPerSec,
            pRefClock,
            pIMS,
            pINSSBuffer3,
            pdwWMSDKFlags
            ) ;
    if (SUCCEEDED (hr)) {
        hr = InlineAnalysisData_ (
                pRecvStatsWriter,
                pRefClock,
                pIMS,
                pdwWMSDKFlags,
                pINSSBuffer3
                ) ;
        if (SUCCEEDED (hr)) {
            hr = InlineMpeg2Attributes_ (
                    pINSSBuffer3,
                    pIMS
                    ) ;
        }
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

//  BUGBUG: for now based on the type of analysis
CDVRAnalysisFlags *
GetAnalysisTagger (
    IN  REFGUID rguidAnalysis
    )
{
    CDVRAnalysisFlags * pTagger ;

    if (rguidAnalysis == DVRAnalysis_Mpeg2GOP ||
        rguidAnalysis == DVRAnalysis_Mpeg2_BFrame ||
        rguidAnalysis == DVRAnalysis_Mpeg2_PFrame) {

        pTagger = new CDVRMpeg2VideoAnalysisFlags () ;
    }
    else {
        pTagger = NULL ;
    }

    return pTagger ;
}

void
RecycleAnalysisTagger (
    IN  CDVRAnalysisFlags * pTagger
    )
{
    delete pTagger ;
}

//  ----------------------------------------------

HRESULT
CDVRAnalysisFlags::TransferCoreMSSettings_ (
    IN  IMediaSample *          pIMSReceived,
    IN  CMediaSampleWrapper *   pMSWrapper
    )
{
    HRESULT                 hr ;
    IMediaSample2 *         pIMS2 ;
    LONGLONG                llStart ;
    LONGLONG                llStop ;
    AM_SAMPLE2_PROPERTIES   SampleProps ;
    DWORD                   dwTypeSpecificFlags ;

    ASSERT (pIMSReceived) ;
    ASSERT (pMSWrapper) ;

    pIMS2 = NULL ;

    //  ------------------------------------------------------------------------
    //  flags
    //  ------------------------------------------------------------------------

    pMSWrapper -> SetDiscontinuity  (pIMSReceived -> IsDiscontinuity () == S_OK ? TRUE : FALSE) ;
    pMSWrapper -> SetPreroll        (pIMSReceived -> IsPreroll () == S_OK ? TRUE : FALSE) ;

    //  ------------------------------------------------------------------------
    //  stream time
    //  ------------------------------------------------------------------------

    hr = pIMSReceived -> GetMediaTime (
            & llStart,
            & llStop
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pMSWrapper -> SetMediaTime (& llStart, & llStop) ;
    }
    else {
        //  ok to not succeed
        hr = S_OK ;
    }

    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  .dwTypeSpecificFlags
    //  ------------------------------------------------------------------------

    hr = pIMSReceived -> QueryInterface (
            IID_IMediaSample2,
            (void **) & pIMS2
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIMS2 -> GetProperties (
                sizeof SampleProps,
                reinterpret_cast <BYTE *> (& SampleProps)
                ) ;
        if (SUCCEEDED (hr)) {
            //  only transfer the props if we have some to transfer
            if (SampleProps.dwTypeSpecificFlags != 0) {
                //  save them off
                dwTypeSpecificFlags = SampleProps.dwTypeSpecificFlags ;

                //  retrieve the target sample props
                hr = pMSWrapper -> GetProperties (
                        sizeof SampleProps,
                        reinterpret_cast <BYTE *> (& SampleProps)
                        ) ;
                if (SUCCEEDED (hr)) {
                    //  switcheroo
                    SampleProps.dwTypeSpecificFlags = dwTypeSpecificFlags ;

                    //  set them
                    hr = pMSWrapper -> SetProperties (
                            sizeof SampleProps,
                            reinterpret_cast <const BYTE *> (& SampleProps)
                            ) ;
                }
            }
        }
    }
    else {
        //  not expected.. but not a real failure
        hr = S_OK ;
    }

    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------

    cleanup :

    RELEASE_AND_CLEAR (pIMS2) ;

    return hr ;
}

HRESULT
CDVRAnalysisFlags::TransferAttributes_ (
    IN  IMediaSample *          pIMSReceived,
    IN  CMediaSampleWrapper *   pMSWrapper
    )
{
    ASSERT (pIMSReceived) ;
    ASSERT (pMSWrapper) ;

    //  BUGBUG: implement !!
    return S_OK ;
}

HRESULT
CDVRMpeg2VideoAnalysisFlags::Transfer (
    IN  IMediaSample *          pIMSReceived,
    IN  CMediaSampleWrapper *   pMSWrapper
    )
{
    HRESULT hr ;

    ASSERT (pIMSReceived) ;
    ASSERT (pMSWrapper) ;

    hr = TransferSettingsAndAttributes_ (pIMSReceived, pMSWrapper) ;
    if (SUCCEEDED (hr)) {

        //  reset these flags if we've found a discontinuity
        if (pMSWrapper -> IsDiscontinuity () == S_OK) {
            m_fCachedStartValid = FALSE ;
            m_fCachedStopValid = FALSE ;
        }

        //  this is media-specific; in PES the timestamp in the PES header
        //    applies to the next "access unit" (frame boundary); the next
        //    "access unit" is not guaranteed to be aligned with the start of
        //    the PES payload, so there may be some bytes in between the PES
        //    header and the next "access unit" that belong to the last frame;
        //    we cache these and apply them to the next frame boundary we see

        hr = pIMSReceived -> GetTime (& m_rtCachedStart, & m_rtCachedStop) ;
        if (SUCCEEDED (hr)) {
            m_fCachedStartValid = TRUE ;
            m_fCachedStopValid = (hr != VFW_S_NO_STOP_TIME ? TRUE : FALSE) ;
        }

        //  don't fail the call because of the timestamps
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVRMpeg2VideoAnalysisFlags::Mark (
    IN  CMediaSampleWrapper *   pMSWrapper,
    IN  GUID *                  pguidAttribute,
    IN  BYTE *                  pbAttributeData,
    IN  DWORD                   dwAttributeDataLen
    )
{
    HRESULT hr ;
    DWORD * pdwMpeg2FrameAttribute ;

    ASSERT (pMSWrapper) ;
    ASSERT (pguidAttribute) ;

    hr = pMSWrapper -> SetAttrib (
            (* pguidAttribute),
            pbAttributeData,
            dwAttributeDataLen
            ) ;
    if (SUCCEEDED (hr)) {
        //  if we've got a cached timestamp to apply to the next "access unit",
        //    check now if we're flagging a frame boundary
        if (m_fCachedStartValid &&
            (* pguidAttribute) == DVRAnalysis_Mpeg2Video) {

            //  something has been flagged
            ASSERT (dwAttributeDataLen == sizeof DWORD) ;
            pdwMpeg2FrameAttribute = reinterpret_cast <DWORD *> (pbAttributeData) ;

            //  is it a frame-boundary (see dvranalysis.idl) ?
            if (DVR_ANALYSIS_MP2_IS_BOUNDARY (* pdwMpeg2FrameAttribute)) {
                //  frame boundary (some type .. doesn't matter which); tag the
                //    timestamp to it
                hr = pMSWrapper -> SetTime (
                        & m_rtCachedStart,
                        (m_fCachedStopValid ? & m_rtCachedStop : NULL)
                        ) ;
                if (SUCCEEDED (hr)) {
                    //  timestamp.. should we really be keying off the keyframes..
                    //  BUGBUG
                    pMSWrapper -> SetSyncPoint (TRUE) ;

                    m_fCachedStartValid = FALSE ;
                    m_fCachedStopValid = FALSE ;
                }
            }
        }
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

REFERENCE_TIME
CTimelines::get_RateStart_PTS (
    )
{
    return get_Playtime () + MillisToDShowTime (0) ;
}

REFERENCE_TIME
CTimelines::get_RateStart_Runtime (
    )
{
    return get_Runtime () + MillisToDShowTime (0) ;
}

//  ============================================================================
//  ============================================================================

CDVRThread::CDVRThread()
    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest()
{
    m_hThread = NULL;
}

CDVRThread::~CDVRThread() {
    Close();
}


// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CDVRThread::InitialThreadProc(LPVOID pv)
{
    HRESULT hrCoInit = CDVRThread::CoInitializeHelper();
    if(FAILED(hrCoInit)) {
        DbgLog((LOG_ERROR, 1, TEXT("CoInitializeEx failed.")));
    }

    CDVRThread * pThread = (CDVRThread *) pv;

    HRESULT hr = pThread->ThreadProc();

    if(SUCCEEDED(hrCoInit)) {
        CoUninitialize();
    }

    return hr;
}

BOOL
CDVRThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
    return FALSE;
    }

    m_hThread = CreateThread(
            NULL,
            0,
            CDVRThread::InitialThreadProc,
            this,
            0,
            &threadid);

    if (!m_hThread) {
    return FALSE;
    }

    return TRUE;
}

DWORD
CDVRThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
    return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// Wait for a request from the client
DWORD
CDVRThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}

// is there a request?
BOOL
CDVRThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
    return FALSE;
    } else {
    if (pParam) {
        *pParam = m_dwParam;
    }
    return TRUE;
    }
}

// reply to the request
void
CDVRThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CDVRThread::CoInitializeHelper()
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(0, COINIT_DISABLE_OLE1DDE );
        }
    }
    else
    {
        // caller must load ole32.dll
        DbgBreak("couldn't locate ole32.dll");
    }

    return hr;
}

void
DumpINSSBuffer3Attributes (
    IN  INSSBuffer *    pINSSBuffer,
    IN  QWORD           cnsRead,
    IN  WORD            wStream,
    IN  DWORD           dwTraceLevel
    )
{
    DWORD                       dwSize ;
    HRESULT                     hr ;
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttributes ;
    DWORD                       dwCounter ;
    DWORD                       dwAnalysisGlobal ;
    DWORD                       dwAnalysisMpeg2Video ;

    TRACE_0 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
        TEXT ("-----------------------------------------")) ;

    TRACE_3 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
        TEXT ("INSSBuffer = %08xh; stream = %u; %I64d ms"),
        pINSSBuffer, wStream, ::WMSDKTimeToMilliseconds (cnsRead)) ;

    //  ------------------------------------------------------------------------
    //  INSSBuffer3Prop_DShowNewMediaType
    if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer, INSSBuffer3Prop_DShowNewMediaType)) {
        //  get size only
        hr = DVRAttributeHelpers::GetAttribute (pINSSBuffer, INSSBuffer3Prop_DShowNewMediaType, & dwSize, NULL) ;
        if (SUCCEEDED (hr)) {
            TRACE_1 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tAnalysisNewMediaType: new; size = %d bytes"),
                dwSize) ;
        }
        else {
            TRACE_1 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tAnalysisNewMediaType: error retrieving it: %08xh"),
                hr) ;
        }
    }
    else {
        TRACE_0 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
            TEXT ("\tAnalysisNewMediaType: no new media type")) ;
    }

    //  ------------------------------------------------------------------------
    //  INSSBuffer3Prop_SBE_Attributes
    if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer, INSSBuffer3Prop_SBE_Attributes)) {
        dwSize = sizeof SBEAttributes ;
        hr = DVRAttributeHelpers::GetAttribute (pINSSBuffer, INSSBuffer3Prop_SBE_Attributes, & dwSize, (BYTE *) & SBEAttributes) ;
        if (SUCCEEDED (hr)) {
            TRACE_6 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tINSSBuffer3Prop_SBE_Attributes: start = %I64d ms; stop = %I64d ms; dwTypeSpecificFlags = %08xh; dwStreamId = %08x; dwFlag = %08x; dwCounter = %08x"),
                ::DShowTimeToMilliseconds (SBEAttributes.rtStart),
                ::DShowTimeToMilliseconds (SBEAttributes.rtStop),
                SBEAttributes.dwTypeSpecificFlags,
                SBEAttributes.dwStreamId,
                SBEAttributes.dwFlags,
                SBEAttributes.dwCounter
                ) ;
        }
        else {
            TRACE_1 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tINSSBuffer3Prop_SBE_Attributes: error retrieving it: %08xh"),
                hr) ;
        }
    }
    else {
        TRACE_0 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
            TEXT ("\tINSSBuffer3Prop_SBEAttributes: none present")) ;
    }

    //  ------------------------------------------------------------------------
    //  INSSBuffer3Prop_Mpeg2ElementaryStream
    //LONGLONG                    llMpeg2Attribute ;
    //if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer, INSSBuffer3Prop_Mpeg2ElementaryStream)) {
    //    dwSize = llMpeg2Attribute ;
    //    hr = DVRAttributeHelpers::GetAttribute (pINSSBuffer, INSSBuffer3Prop_Mpeg2ElementaryStream, & dwSize, (BYTE *) & llMpeg2Attribute) ;
    //}

    //  ------------------------------------------------------------------------
    //  DVRAnalysis_Mpeg2Video
    if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer, DVRAnalysis_Mpeg2Video)) {
        dwSize = sizeof dwAnalysisMpeg2Video ;
        hr = DVRAttributeHelpers::GetAttribute (pINSSBuffer, DVRAnalysis_Mpeg2Video, & dwSize, (BYTE *) & dwAnalysisMpeg2Video) ;
        if (SUCCEEDED (hr)) {
            TRACE_3 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tDVRAnalysis_Mpeg2Video : %s frame, boundary = %d; %08xh"),
                (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwAnalysisMpeg2Video) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_GOP_HEADER ? TEXT ("I") :
                 (DVR_ANALYSIS_MP2_GET_MP2FRAME_ATTRIB (dwAnalysisMpeg2Video) == DVR_ANALYSIS_MPEG2_VIDEO_CONTENT_B_FRAME ? TEXT ("B") :
                  TEXT ("P")
                 )
                ),
                DVR_ANALYSIS_MP2_IS_BOUNDARY (dwAnalysisMpeg2Video) ? 1 : 0,
                dwAnalysisMpeg2Video) ;
        }
        else {
            TRACE_1 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tDVRAnalysis_Mpeg2Video: error retrieving it: %08xh"),
                hr) ;
        }
    }
    else {
        TRACE_0 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
            TEXT ("\tDVRAnalysis_Mpeg2Video: none present")) ;
    }

    //  ------------------------------------------------------------------------
    //  DVRAnalysis_Global
    if (DVRAttributeHelpers::IsAttributePresent (pINSSBuffer, DVRAnalysis_Global)) {
        dwSize = sizeof dwAnalysisGlobal ;
        hr = DVRAttributeHelpers::GetAttribute (pINSSBuffer, DVRAnalysis_Global, & dwSize, (BYTE *) & dwAnalysisGlobal) ;
        if (SUCCEEDED (hr)) {
            TRACE_2 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tDVRAnalysis_Global: %s present; %08xh"),
                DVR_ANALYSIS_GLOBAL_IS_PRESENT (dwAnalysisGlobal) ? TEXT ("IS") : TEXT ("IS NOT"), dwAnalysisGlobal) ;
        }
        else {
            TRACE_1 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
                TEXT ("\tDVRAnalysis_Global: error retrieving it: %08xh"),
                hr) ;
        }
    }
    else {
        TRACE_0 (LOG_AREA_WMSDK_DSHOW, dwTraceLevel,
            TEXT ("\tDVRAnalysis_Mpeg2Video: none present")) ;
    }
}

//  ============================================================================
//  ============================================================================

CConcatRecTimeline::CConcatRecTimeline (
    IN  DWORD           cMaxPreprocess,
    IN  IWMProfile *    pIWMProfile,
    OUT HRESULT *       phr
    ) : m_PTSShift                       (UNDEFINED),
        m_wTimelineStream               (UNDEFINED),
        m_rtAvgDelta                    (UNDEFINED),
        m_cRecPacketsProcessed          (0),
        m_cPreProcessed                 (0),
        m_cMaxPreprocess                (cMaxPreprocess),
        m_ppStreamState                 (NULL),
        m_rtLastGoodTimelinePTSDelta    (UNDEFINED),
        m_rtLastTimelinePTS             (UNDEFINED),
        m_rtLastContinuousPTS           (UNDEFINED),
        m_cnsLastStreamTime             (UNDEFINED),
        m_llStreamtimeShift                      (0)
{
    ASSERT (pIWMProfile) ;

    //  discover the timeline stream (try for audio)
    (* phr) = DiscoverTimelineStream (pIWMProfile, & m_wTimelineStream) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = InitializeStreamStates_ (pIWMProfile) ;
    if (FAILED (* phr)) { goto cleanup ; }

    cleanup :

    return ;
}

CConcatRecTimeline::~CConcatRecTimeline (
    )
{
    delete [] m_ppStreamState ;
}

HRESULT
CConcatRecTimeline::InitializeStreamStates_ (
    IN  IWMProfile *    pIWMProfile
    )
{
    HRESULT             hr ;
    DWORD               i ;
    IWMStreamConfig *   pIWMStreamConfig ;
    WORD                wStreamNumber ;

    pIWMStreamConfig = NULL ;

    hr = pIWMProfile -> GetStreamCount (& m_cStreams) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (m_cStreams != 0) ;

    m_ppStreamState = new STREAM_STATE [m_cStreams] ;
    if (!m_ppStreamState) { hr = E_OUTOFMEMORY ; goto cleanup ; }

    ZeroMemory (m_ppStreamState, m_cStreams * sizeof STREAM_STATE) ;

    for (i = 0; i < m_cStreams; i++) {

        hr = pIWMProfile -> GetStream (i, & pIWMStreamConfig) ;
        if (FAILED (hr)) { goto cleanup ; }

        ASSERT (pIWMStreamConfig) ;
        hr = pIWMStreamConfig -> GetStreamNumber (& m_ppStreamState [i].wStreamNumber) ;
        if (FAILED (hr)) { goto cleanup ; }

        m_ppStreamState [i].dwContinuityCounter = 0 ;

        RELEASE_AND_CLEAR (pIWMStreamConfig) ;
    }

    cleanup :

    RELEASE_AND_CLEAR (pIWMStreamConfig) ;

    return hr ;
}

CConcatRecTimeline::STREAM_STATE *
CConcatRecTimeline::GetStreamState_ (
    IN  WORD    wStreamNumber
    )
{
    STREAM_STATE *  pRet ;
    DWORD           i ;

    pRet = NULL ;

    for (i = 0; i < m_cStreams; i++) {
        if (m_ppStreamState [i].wStreamNumber == wStreamNumber) {
            //  found it
            pRet = & m_ppStreamState [i] ;
            break ;
        }
    }

    return pRet ;
}

void
CConcatRecTimeline::RolloverContinuityCounters_ (
    )
{
    DWORD   i ;

    for (i = 0; i < m_cStreams; i++) {
        m_ppStreamState [i].dwContinuityCounter++ ;
    }
}

void
CConcatRecTimeline::InitForNextRec (
    )
{
    m_cPreProcessed = 0 ;

    m_PTSShift       = UNDEFINED ;
    m_llStreamtimeShift      = UNDEFINED ;
}

HRESULT
CConcatRecTimeline::PreProcess (
    IN  DWORD           cRecSamples,    //  starts at 0 for each new recording & increments
    IN  WORD            wStreamNumber,
    IN  QWORD           cnsStreamTime,
    IN  INSSBuffer *    pINSSBuffer
    )
{
    HRESULT                     hr ;
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttrib ;

    ASSERT (m_cPreProcessed < m_cMaxPreprocess) ;

    hr = S_OK ;

    m_cPreProcessed++ ;

    //  if this is the first pre-processing call, introduce a discontinuity by
    //  rolling over the continuity counters, for all the streams
    if (cRecSamples == 0) {
        RolloverContinuityCounters_ () ;
    }

    //  ------------------------------------------------------------------------
    //  try for out PTS shift

    if (m_rtLastGoodTimelinePTSDelta != UNDEFINED) {

        ASSERT (m_rtLastTimelinePTS != UNDEFINED) ;

        if (wStreamNumber == m_wTimelineStream) {

            //  recover the attributes
            hr = GetSBEAttributes_ (
                    pINSSBuffer,
                    & SBEAttrib
                    ) ;
            if (FAILED (hr)) { goto cleanup ; }

            if (SBEAttrib.rtStart != -1) {
                //  good timestamp; compute our shift
                m_PTSShift = m_rtLastGoodTimelinePTSDelta - (SBEAttrib.rtStart - m_rtLastTimelinePTS) ;

                TRACE_5 (LOG_AREA_DSHOW, 1,
                    TEXT ("CConcatRecTimeline::PreProcess () : stream %u : [PTS] last good delta = %I64d ms, rtStart = %I64d ms, last PTS = %I64d ms }==> m_PTSShift = %I64d ms"),
                    wStreamNumber,
                    ::DShowTimeToMilliseconds (m_rtLastGoodTimelinePTSDelta),
                    ::DShowTimeToMilliseconds (SBEAttrib.rtStart),
                    ::DShowTimeToMilliseconds (m_rtLastTimelinePTS),
                    ::DShowTimeToMilliseconds (m_PTSShift)) ;
            }
        }
    }
    else {
        //  we're done;
        m_PTSShift = 0 ;
    }

    //  ------------------------------------------------------------------------
    //  and our stream time shift

    if (m_llStreamtimeShift == UNDEFINED) {

        if (m_cnsLastStreamTime != UNDEFINED) {
            //  we can base it off the last good stream time
            if (m_rtLastGoodTimelinePTSDelta != UNDEFINED) {
                //  we'll delta by the same figure we got via the PTSs
                m_llStreamtimeShift = m_rtLastGoodTimelinePTSDelta - (LONGLONG) ((LONGLONG) cnsStreamTime - (LONGLONG) m_cnsLastStreamTime) ;
            }
            else {
                //  else we fudge by 100 ms; the danger here is that there is
                //    potential for a cummulative error
                m_llStreamtimeShift = (LONGLONG) ::MillisToWMSDKTime (100) ;
            }
        }
        else {
            //  probably our first run through; we'll normalize to the first
            //    stream time (this one)
            m_llStreamtimeShift = 0 - (LONGLONG) cnsStreamTime ;
        }

        TRACE_3 (LOG_AREA_DSHOW, 1,
            TEXT ("CConcatRecTimeline::PreProcess () : stream %u : [STREAM] cnsStreamTime = %I64u ms, m_llStreamtimeShift = %I64d ms"),
            wStreamNumber,
            ::WMSDKTimeToMilliseconds (cnsStreamTime),
            ::DShowTimeToMilliseconds (m_llStreamtimeShift)
            ) ;
    }

    cleanup :

    //  regardless of success or failure, see if we've exceeded our thresold
    if (m_cPreProcessed == m_cMaxPreprocess &&
        !CanShift ()) {

        m_PTSShift = 0 ;
        m_llStreamtimeShift = 0 ;
    }

    return hr ;
}

HRESULT
CConcatRecTimeline::GetSBEAttributes_ (
    IN  INSSBuffer *                    pINSSBuffer,
    OUT INSSBUFFER3PROP_SBE_ATTRIB *   pSBEAttrib
    )
{
    HRESULT         hr ;
    BOOL            r ;
    INSSBuffer3 *   pINSSBuffer3 ;
    DWORD           dwSize ;

    hr = pINSSBuffer -> QueryInterface (
            IID_INSSBuffer3,
            (void **) & pINSSBuffer3
            ) ;
    if (SUCCEEDED (hr)) {

        r = DVRAttributeHelpers::IsAttributePresent (
                pINSSBuffer3,
                INSSBuffer3Prop_SBE_Attributes
                ) ;

        if (r) {

            dwSize = sizeof (* pSBEAttrib) ;

            hr = DVRAttributeHelpers::GetAttribute (
                    pINSSBuffer3,
                    INSSBuffer3Prop_SBE_Attributes,
                    & dwSize,
                    (BYTE *) pSBEAttrib
                    ) ;

            if (SUCCEEDED (hr) &&
                dwSize != sizeof (* pSBEAttrib)) {

                //  unexpected size
                hr = E_UNEXPECTED ;
            }
        }

        pINSSBuffer3 -> Release () ;
    }

    return hr ;
}

HRESULT
CConcatRecTimeline::SetSBEAttributes_ (
    IN  INSSBuffer *                    pINSSBuffer,
    IN  INSSBUFFER3PROP_SBE_ATTRIB *   pSBEAttrib
    )
{
    HRESULT         hr ;
    BOOL            r ;
    INSSBuffer3 *   pINSSBuffer3 ;
    DWORD           dwSize ;

    hr = pINSSBuffer -> QueryInterface (
            IID_INSSBuffer3,
            (void **) & pINSSBuffer3
            ) ;
    if (SUCCEEDED (hr)) {

        r = DVRAttributeHelpers::IsAttributePresent (
                pINSSBuffer3,
                INSSBuffer3Prop_SBE_Attributes
                ) ;

        if (r) {

            dwSize = sizeof (* pSBEAttrib) ;

            hr = DVRAttributeHelpers::SetAttribute (
                    pINSSBuffer3,
                    INSSBuffer3Prop_SBE_Attributes,
                    sizeof (* pSBEAttrib),
                    (BYTE *) pSBEAttrib
                    ) ;
        }

        pINSSBuffer3 -> Release () ;
    }

    return hr ;
}

HRESULT
CConcatRecTimeline::ShiftDShowPTSs_ (
    IN      WORD            wStreamNumber,
    IN OUT  INSSBuffer *    pINSSBuffer,
    OUT     BOOL *          pfDropSample
    )
{
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttrib ;
    HRESULT                     hr ;

    hr = GetSBEAttributes_ (
            pINSSBuffer,
            & SBEAttrib
            ) ;
    if (SUCCEEDED (hr)) {

        if (SBEAttrib.rtStart != -1)  { SBEAttrib.rtStart += m_PTSShift ; }
        if (SBEAttrib.rtStop != -1)   { SBEAttrib.rtStop  += m_PTSShift ; }

        //  only overwrite if at least 1 time is valid (and was shifted)
        if (SBEAttrib.rtStart != -1 ||
            SBEAttrib.rtStop != -1) {

            TRACE_4 (LOG_AREA_DSHOW, 8,
                TEXT ("CConcatRecTimeline::ShiftDShowPTSs_ () : stream %u :rtStart was shifted  %s ,%I64d, ms ==> ,%I64d, ms"),
                wStreamNumber, (wStreamNumber == 1 ? TEXT (",") : TEXT (",,")),
                ::DShowTimeToMilliseconds (SBEAttrib.rtStart - m_PTSShift),
                ::DShowTimeToMilliseconds (SBEAttrib.rtStart)) ;

            hr = SetSBEAttributes_ (
                    pINSSBuffer,
                    & SBEAttrib
                    ) ;
        }
    }

    //  BUGBUG: implement
    (*  pfDropSample) = FALSE ;

    return S_OK ;
}

HRESULT
CConcatRecTimeline::ShiftWMSDKStreamTime_ (
    IN      WORD    wStreamNumber,
    IN OUT  QWORD * pcnsStreamTime,
    OUT     BOOL *  pfDropSample
    )
{
    ASSERT (!(* pfDropSample)) ;

    (* pcnsStreamTime) = (QWORD) ((LONGLONG) (* pcnsStreamTime) + m_llStreamtimeShift) ;
    (* pfDropSample) = FALSE ;

    m_cnsLastStreamTime = (* pcnsStreamTime) ;

    TRACE_3 (LOG_AREA_DSHOW, 8,
        TEXT ("CConcatRecTimeline::ShiftWMSDKStreamTime_ () : stream %u :stream time %I64u ms ==> %I64u ms"),
        wStreamNumber,
        ::WMSDKTimeToMilliseconds ((QWORD) ((LONGLONG) (* pcnsStreamTime) - m_llStreamtimeShift)),
        ::WMSDKTimeToMilliseconds (* pcnsStreamTime)) ;


    return S_OK ;
}

HRESULT
CConcatRecTimeline::UpdateContinuityCounter_ (
    IN  WORD            wStreamNumber,
    IN  INSSBuffer *    pINSSBuffer
    )
{
    HRESULT         hr ;
    STREAM_STATE *  pStreamState ;
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttrib ;


    pStreamState = GetStreamState_ (wStreamNumber) ;
    if (pStreamState) {
        //  recover the attributes
        hr = GetSBEAttributes_ (
                pINSSBuffer,
                & SBEAttrib
                ) ;

        SBEAttrib.dwCounter = pStreamState -> dwContinuityCounter;

        hr = DVRAttributeHelpers::SetAttribute (
                pINSSBuffer,
                INSSBuffer3Prop_SBE_Attributes,
                sizeof(INSSBUFFER3PROP_SBE_ATTRIB),
                (BYTE *) &SBEAttrib
                );

        pStreamState -> dwContinuityCounter++;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

void
CConcatRecTimeline::ProcessTimelineStreamBuffer_ (
    IN  INSSBuffer *    pINSSBuffer,
    IN  DWORD           dwFlags
    )
{
    INSSBUFFER3PROP_SBE_ATTRIB SBEAttrib ;
    HRESULT                     hr ;

    //  if there's a discontinuity, last PTS is meaningless
    if (dwFlags & WM_SF_DISCONTINUITY) {
        m_rtLastContinuousPTS = UNDEFINED ;
    }

    hr = GetSBEAttributes_ (pINSSBuffer, & SBEAttrib) ;

    if (SUCCEEDED (hr) &&
        SBEAttrib.rtStart != -1) {

        //  try to set the last positive delta
        if (m_rtLastContinuousPTS != UNDEFINED &&          //  we've got a comparison
            SBEAttrib.rtStart >= m_rtLastTimelinePTS) {

            m_rtLastGoodTimelinePTSDelta = SBEAttrib.rtStart - m_rtLastContinuousPTS ;
        }

        //  last PTS
        m_rtLastTimelinePTS     = SBEAttrib.rtStart ;
        m_rtLastContinuousPTS   = SBEAttrib.rtStart ;
    }

    TRACE_4 (LOG_AREA_DSHOW, 7,
        TEXT ("CConcatRecTimeline::ProcessTimelineStreamBuffer_ () : stream %u : m_rtLastGoodTimelinePTSDelta = %I64d ms, m_rtLastTimelinePTS = %I64d ms, m_rtLastContinuousPTS = %I64d ms"),
        m_wTimelineStream,
        ::DShowTimeToMilliseconds (m_rtLastGoodTimelinePTSDelta),
        ::DShowTimeToMilliseconds (m_rtLastTimelinePTS),
        ::DShowTimeToMilliseconds (m_rtLastContinuousPTS)) ;
}

HRESULT
CConcatRecTimeline::Shift (
    IN      WORD            wStreamNumber,
    IN      DWORD           dwFlags,
    IN OUT  INSSBuffer *    pINSSBuffer,
    IN OUT  QWORD *         pcnsStreamTime,
    OUT     BOOL *          pfDropSample
    )
{
    HRESULT hr ;

    m_cRecPacketsProcessed++ ;

    (* pfDropSample) = FALSE ;

    hr = ShiftDShowPTSs_ (wStreamNumber, pINSSBuffer, pfDropSample) ;
    if (FAILED (hr) || (* pfDropSample)) { goto cleanup ; }

    hr = ShiftWMSDKStreamTime_ (wStreamNumber, pcnsStreamTime, pfDropSample) ;
    if (FAILED (hr) || (* pfDropSample)) { goto cleanup ; }

    hr = UpdateContinuityCounter_ (wStreamNumber, pINSSBuffer) ;
    if (FAILED (hr) || (* pfDropSample)) { goto cleanup ; }

    if (wStreamNumber == m_wTimelineStream) {
        ProcessTimelineStreamBuffer_ (pINSSBuffer, dwFlags) ;
    }

    cleanup :

    return hr ;
}

//  ============================================================================
//  ============================================================================

CSBERecordingAttributesFile::CSBERecordingAttributesFile (
    IN  LPCWSTR     pszAttrFile,
    OUT HRESULT *   phr
    ) : m_fLocked       (FALSE),
        m_pszAttrFile   (NULL)
{
    DWORD   dwLen ;

    ASSERT (pszAttrFile) ;

    ::InitializeCriticalSection (& m_crt) ;

    dwLen = wcslen (pszAttrFile) + 1 ;
    if (dwLen > MAX_PATH) {
        (* phr) = E_INVALIDARG ;
        goto cleanup ;
    }

    m_pszAttrFile = new WCHAR [dwLen] ;
    if (!m_pszAttrFile) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    ::CopyMemory (
        m_pszAttrFile,
        pszAttrFile,
        dwLen * sizeof WCHAR    //  includes NULL-terminator
        ) ;

    (* phr) = S_OK ;

    cleanup :

    return ;
}

CSBERecordingAttributesFile::~CSBERecordingAttributesFile (
    )
{
    delete [] m_pszAttrFile ;
    FreeAttributes_ () ;
    ::DeleteCriticalSection (& m_crt) ;
}

void
CSBERecordingAttributesFile::FreeAttributes_ (
    )
{
    CSBERecAttribute *  pSBEAttribute ;
    DWORD               dwLast ;
    HRESULT             hr ;

    while (m_Attributes.GetCount () != 0) {
        dwLast = m_Attributes.GetCount () - 1 ;
        hr = m_Attributes.Remove (dwLast, & pSBEAttribute) ;
        ASSERT (SUCCEEDED (hr)) ;

        delete pSBEAttribute ;
    }
}

void
CSBERecordingAttributesFile::FindLocked_ (
    IN  LPCWSTR                 pszName,
    OUT CSBERecAttribute **     ppSBEAttribute,
    OUT DWORD *                 pdwIndex
    )
{
    HRESULT hr ;

    ASSERT (ppSBEAttribute) ;
    ASSERT (pdwIndex) ;

    for ((* pdwIndex) = 0;;(* pdwIndex)++) {

        hr = m_Attributes.Get ((* pdwIndex), ppSBEAttribute) ;
        if (FAILED (hr)) {
            break ;
        }

        ASSERT (* ppSBEAttribute) ;

        if (::_wcsicmp (pszName, (* ppSBEAttribute) -> Name ()) == 0) {
            //  found it
            return ;
        }
    }

    //  fail
    (* ppSBEAttribute) = NULL ;
}

HRESULT
CSBERecordingAttributesFile::Load (
    )
{
    HANDLE                          hFile ;
    IN_FILE_PVR_ATTRIBUTE_HEADER    AttrHeader ;
    DWORD                           dwCount ;
    BOOL                            r ;
    DWORD                           dwRet ;
    DWORD                           i ;
    DWORD                           dwRead ;
    DWORD                           dwActualRead ;
    HRESULT                         hr ;
    CRatchetBuffer                  AttributeBuffer ;
    LPWSTR                          pszName ;
    BYTE *                          pbAttribute ;

    ASSERT (m_pszAttrFile) ;

    if (m_fLocked) {
        return E_UNEXPECTED ;
    }

    Lock_ () ;

    //  don't accumulate attributes; reset ourselves
    FreeAttributes_ () ;

    hFile = ::CreateFileW (
                m_pszAttrFile,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                ) ;
    if (hFile == INVALID_HANDLE_VALUE) {
        dwRet = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dwRet) ;
        goto cleanup ;
    }

    //  first get the attribute count
    dwRead = sizeof dwCount ;
    r = ::ReadFile (hFile, (LPVOID) & dwCount, dwRead, & dwActualRead, NULL) ;
    if (!r) { dwRet = ::GetLastError () ; hr = HRESULT_FROM_WIN32 (dwRet) ; goto cleanup ; }
    ASSERT (dwRead == dwActualRead) ;

    //  cycle through the attributes, and read them out
    for (i = 0; i < dwCount; i++) {
        dwRead = sizeof AttrHeader ;
        r = ::ReadFile (hFile, (LPVOID) & AttrHeader, dwRead, & dwActualRead, NULL) ;
        if (!r) { dwRet = ::GetLastError () ; hr = HRESULT_FROM_WIN32 (dwRet) ; goto cleanup ; }
        ASSERT (dwActualRead == dwRead) ;

        //  validate
        if (AttrHeader.dwMagicMarker != PVR_ATTRIB_MAGIC_MARKER ||
            AttrHeader.ulReserved != 0                          ||
            (AttrHeader.dwDataLength & 0xffff0000)              ||
            AttrHeader.DataType > STREAMBUFFER_TYPE_GUID        ||
            AttrHeader.dwTotalAttributeLen  != sizeof AttrHeader + AttrHeader.dwNameLengthBytes + AttrHeader.dwDataLength) {

            //  bad data
            hr = E_FAIL ;
            goto cleanup ;
        }

        //  prep the buffer we'll read into
        dwRet = AttributeBuffer.SetMinLen (AttrHeader.dwTotalAttributeLen - sizeof AttrHeader) ;
        if (dwRet != NOERROR) {
            hr = HRESULT_FROM_WIN32 (dwRet) ;
            goto cleanup ;
        }

        //  read in the name and the attribute
        dwRead = AttrHeader.dwNameLengthBytes + AttrHeader.dwDataLength ;
        r = ::ReadFile (hFile, (LPVOID) AttributeBuffer.Buffer (), dwRead, & dwActualRead, NULL) ;
        if (!r) { dwRet = ::GetLastError () ; hr = HRESULT_FROM_WIN32 (dwRet) ; goto cleanup ; }
        ASSERT (dwActualRead == dwRead) ;

        //  validate what we read in
        pszName = (LPWSTR) AttributeBuffer.Buffer () ;
        if (pszName [(AttrHeader.dwNameLengthBytes / sizeof WCHAR) - 1] != L'\0') {
            //  bad data - there's no null-terminator there
            hr = E_FAIL ;
            goto cleanup ;
        }

        //  set the attribute pointer
        pbAttribute = AttributeBuffer.Buffer () + AttrHeader.dwNameLengthBytes ;

        //  create the attribute
        hr = SetAttribute (
                    (WORD) AttrHeader.ulReserved,
                    pszName,
                    AttrHeader.DataType,
                    pbAttribute,
                    (WORD) AttrHeader.dwDataLength
                    ) ;

        if (FAILED (hr)) {
            goto cleanup ;
        }
    }

    hr = S_OK ;

    //  don't allow changes to the loaded attribute file
    m_fLocked = TRUE ;

    cleanup :

    Unlock_ () ;

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hFile) ;
    }

    return hr ;
}

HRESULT
CSBERecordingAttributesFile::Flush (
    )
{
    HANDLE                          hFile ;
    IN_FILE_PVR_ATTRIBUTE_HEADER    AttrHeader ;
    DWORD                           dwCount ;
    BOOL                            r ;
    DWORD                           dwRet ;
    DWORD                           i ;
    DWORD                           dwWritten ;
    DWORD                           dwWrite ;
    CSBERecAttribute *              pSBEAttribute ;
    HRESULT                         hr ;

    ASSERT (m_pszAttrFile) ;

    if (m_fLocked) {
        return E_UNEXPECTED ;
    }

    Lock_ () ;

    r = ::SetFileAttributesW (m_pszAttrFile, FILE_ATTRIBUTE_NORMAL) ;

    hFile = ::CreateFileW (
                m_pszAttrFile,
                GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                ) ;
    if (hFile == INVALID_HANDLE_VALUE) {
        dwRet = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dwRet) ;
        goto cleanup ;
    }

    r = ::SetFileAttributesW (m_pszAttrFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM) ;
    if (!r) {
        dwRet = ::GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dwRet) ;
        goto cleanup ;
    }

    //  first write the attribute count
    dwCount = m_Attributes.GetCount () ;
    dwWrite = sizeof dwCount ;
    r = ::WriteFile (hFile, (LPVOID) & dwCount, dwWrite, & dwWritten, NULL) ;
    if (!r) { dwRet = ::GetLastError () ; hr = HRESULT_FROM_WIN32 (dwRet) ; goto cleanup ; }
    ASSERT (dwWritten == dwWrite) ;

    //  cycle through the attributes, and write them to disk
    for (i = 0; i < dwCount; i++) {
        hr = m_Attributes.Get (i, & pSBEAttribute) ;
        if (FAILED (hr)) {
        goto cleanup ; }

        //  set the header
        AttrHeader.dwMagicMarker        = PVR_ATTRIB_MAGIC_MARKER ;
        AttrHeader.ulReserved           = 0 ;
        AttrHeader.dwNameLengthBytes    = pSBEAttribute -> NameLenBytes () ;
        AttrHeader.DataType             = pSBEAttribute -> DataType () ;
        AttrHeader.dwDataLength         = pSBEAttribute -> Length () ;
        AttrHeader.dwTotalAttributeLen  = sizeof AttrHeader + AttrHeader.dwNameLengthBytes + AttrHeader.dwDataLength ;

        //  write the header
        dwWrite = sizeof AttrHeader ;
        r = ::WriteFile (hFile, (LPVOID) & AttrHeader, dwWrite, & dwWritten, NULL) ;
        if (!r) { dwRet = ::GetLastError () ; hr = HRESULT_FROM_WIN32 (dwRet) ;
        goto cleanup ; }
        ASSERT (dwWritten == dwWrite) ;

        //  write the name
        dwWrite = AttrHeader.dwNameLengthBytes ;
        r = ::WriteFile (hFile, (LPVOID) pSBEAttribute -> Name (), dwWrite, & dwWritten, NULL) ;
        if (!r) { dwRet = ::GetLastError () ; hr = HRESULT_FROM_WIN32 (dwRet) ;
        goto cleanup ; }
        ASSERT (dwWritten == dwWrite) ;

        //  write the data
        dwWrite = AttrHeader.dwDataLength ;
        r = ::WriteFile (hFile, (LPVOID) pSBEAttribute -> Attribute (), dwWrite, & dwWritten, NULL) ;
        if (!r) { dwRet = ::GetLastError () ; hr = HRESULT_FROM_WIN32 (dwRet) ;
        goto cleanup ; }
        ASSERT (dwWritten == dwWrite) ;
    }

    hr = S_OK ;

    //  don't allow anymore changes to this attribute file
    m_fLocked = TRUE ;

    cleanup :

    Unlock_ () ;

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hFile) ;
    }

    if (FAILED (hr)) {
        ::DeleteFileW (m_pszAttrFile) ;
    }

    return hr ;
}

//  checks against reserved names, cross-typed well-known, etc...
BOOL
CSBERecordingAttributesFile::ValidAttribute_ (
    IN  LPCWSTR                     pszAttributeName,       //  name
    IN  STREAMBUFFER_ATTR_DATATYPE  SBEAttributeType,       //  type
    IN  BYTE *                      pbAttribute,            //  blob
    IN  WORD                        cbAttributeLength       //  blob length
    )
{
    return TRUE ;
}

HRESULT
CSBERecordingAttributesFile::SetAttribute (
    IN  WORD                wReserved,             //  0
    IN  LPCWSTR             pszAttributeName,       //  name
    IN  WMT_ATTR_DATATYPE   WMAttributeType,        //  type (WM)
    IN  BYTE *              pbAttribute,            //  blob
    IN  WORD                cbAttributeLength       //  blob length
    )
{
    return SetAttribute (
                wReserved,
                pszAttributeName,
                (STREAMBUFFER_ATTR_DATATYPE) WMAttributeType,
                pbAttribute,
                cbAttributeLength
                ) ;
}

HRESULT
CSBERecordingAttributesFile::SetAttribute (
    IN  WORD                        wReserved,             //  0
    IN  LPCWSTR                     pszAttributeName,       //  name
    IN  STREAMBUFFER_ATTR_DATATYPE  SBEAttributeType,       //  type
    IN  BYTE *                      pbAttribute,            //  blob
    IN  WORD                        cbAttributeLength       //  blob length
    )
{
    CSBERecAttribute *  pNewSBEAttribute ;
    CSBERecAttribute *  pExistingSBEAttribute ;
    DWORD               dwExistingIndex ;
    DWORD               dwRet ;
    BOOL                r ;
    HRESULT             hr ;

    if (!pszAttributeName ||
        (cbAttributeLength > 0 && !pbAttribute)) {

        return E_POINTER ;
    }

    Lock_ () ;

    if (!m_fLocked) {
        //  validate
        r = ValidAttribute_ (
                pszAttributeName,
                SBEAttributeType,
                pbAttribute,
                cbAttributeLength
                ) ;
        if (r) {

            //  instantiate the new
            pNewSBEAttribute = new CSBERecAttribute (
                                        pszAttributeName,
                                        SBEAttributeType,
                                        pbAttribute,
                                        cbAttributeLength,
                                        & dwRet
                                        ) ;
            if (!pNewSBEAttribute) {
                hr = E_OUTOFMEMORY ;
                goto cleanup ;
            }
            else if (dwRet != NOERROR) {
                delete pNewSBEAttribute ;
                hr = HRESULT_FROM_WIN32 (dwRet) ;
                goto cleanup ;
            }

            //  check if we need to remove a dupe first
            FindLocked_ (
                pszAttributeName,
                & pExistingSBEAttribute,
                & dwExistingIndex
                ) ;

            if (pExistingSBEAttribute) {
                //  remove and free the one that already exists
                m_Attributes.Remove (dwExistingIndex) ;
                delete pExistingSBEAttribute ;
            }

            //  append the new
            hr = m_Attributes.Append (pNewSBEAttribute) ;
            if (FAILED (hr)) {
                delete pNewSBEAttribute ;
            }
        }
        else {
            hr = E_INVALIDARG ;
        }
    }
    else {
        //  wrong state
        hr = E_FAIL ;
    }

    cleanup :

    Unlock_ () ;

    return hr ;

}

HRESULT
CSBERecordingAttributesFile::GetAttributeCount (
    IN  WORD    wReserved,     //  0
    OUT WORD *  pcAttributes    //  count
    )
{
    if (!pcAttributes) {
        return E_POINTER ;
    }

    (* pcAttributes) = (WORD) m_Attributes.GetCount () ;

    return S_OK ;
}

HRESULT
CSBERecordingAttributesFile::GetAttributeByName (
    IN      LPCWSTR             pszAttributeName,   //  name
    IN      WORD *              pwReserved,         //  0
    OUT     WMT_ATTR_DATATYPE * pWMAttributeType,
    OUT     BYTE *              pbAttribute,
    IN OUT  WORD *              pcbLength
    )
{
    return GetAttributeByName (
                pszAttributeName,
                pwReserved,
                (STREAMBUFFER_ATTR_DATATYPE *) pWMAttributeType,
                pbAttribute,
                pcbLength
                ) ;
}

HRESULT
CSBERecordingAttributesFile::GetAttributeByName (
    IN      LPCWSTR                         pszAttributeName,   //  name
    IN      WORD *                          pwReserved,         //  0
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    CSBERecAttribute *  pExistingSBEAttribute ;
    DWORD               dwExistingIndex ;
    HRESULT             hr ;

    if (!pszAttributeName   ||
        !pcbLength) {

        return E_POINTER ;
    }

    if (!pbAttribute) {
        //  caller just wants length; init to 0 length
        ASSERT (pcbLength) ;
        (* pcbLength) = 0 ;
    }

    Lock_ () ;

    //  check if we need to remove a dupe first
    FindLocked_ (
        pszAttributeName,
        & pExistingSBEAttribute,
        & dwExistingIndex
        ) ;

    if (pExistingSBEAttribute) {

        if ((* pcbLength) >= pExistingSBEAttribute -> Length () &&
            pbAttribute) {

            //  copy it out

            (* pSBEAttributeType)   = pExistingSBEAttribute -> DataType () ;
            (* pcbLength)           = pExistingSBEAttribute -> Length () ;
            (* pwReserved)          = 0 ;

            ::CopyMemory (
                pbAttribute,
                pExistingSBEAttribute -> Attribute (),
                pExistingSBEAttribute -> Length ()
                ) ;

            //  success
            hr = S_OK ;
        }
        else {
            //  buffer too small
            (* pcbLength) = pExistingSBEAttribute -> Length () ;

            if (!pbAttribute) {
                //  caller only wanted the length
                hr = S_OK ;
            }
            else {
                //  they wanted the attribute; fail the call
                hr = VFW_E_BUFFER_OVERFLOW ;
            }
        }
    }
    else {
        hr = E_FAIL ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CSBERecordingAttributesFile::GetAttributeByIndex (
    IN      WORD                wIndex,
    IN      WORD *              pwReserved,
    OUT     WCHAR *             pszAttributeName,
    IN OUT  WORD *              pcchNameLength,         //  includes NULL-terminator; in BYTES
    OUT     WMT_ATTR_DATATYPE * pWMAttributeType,
    OUT     BYTE *              pbAttribute,
    IN OUT  WORD *              pcbLength
    )
{
    return GetAttributeByIndex (
                wIndex,
                pwReserved,
                pszAttributeName,
                pcchNameLength,
                (STREAMBUFFER_ATTR_DATATYPE *) pWMAttributeType,
                pbAttribute,
                pcbLength
                ) ;
}

HRESULT
CSBERecordingAttributesFile::GetAttributeByIndex (
    IN      WORD                            wIndex,
    IN      WORD *                          pwReserved,
    OUT     WCHAR *                         pszAttributeName,
    IN OUT  WORD *                          pcchNameLength,         //  includes NULL-terminator; in BYTES
    OUT     STREAMBUFFER_ATTR_DATATYPE *    pSBEAttributeType,
    OUT     BYTE *                          pbAttribute,
    IN OUT  WORD *                          pcbLength
    )
{
    CSBERecAttribute *  pExistingSBEAttribute ;
    HRESULT             hr ;

    if (!pcbLength      ||
        !pcchNameLength ||
        !pwReserved) {

        return E_POINTER ;
    }

    if (!pbAttribute) {
        //  caller just wants length; init to 0 length
        ASSERT (pcbLength) ;
        (* pcbLength) = 0 ;
    }

    if (!pszAttributeName) {
        //  caller just wants length; init to 0 length
        ASSERT (pcchNameLength) ;
        (* pcchNameLength) = 0 ;
    }

    Lock_ () ;

    hr = m_Attributes.Get (
            wIndex,
            & pExistingSBEAttribute
            ) ;

    if (SUCCEEDED (hr)) {

        ASSERT (pExistingSBEAttribute) ;

        //  check the length
        if ((* pcbLength)       >= pExistingSBEAttribute -> Length () &&
            (* pcchNameLength)  >= pExistingSBEAttribute -> NameLenBytes ()) {

            //  copy it out

            (* pSBEAttributeType)   = pExistingSBEAttribute -> DataType () ;
            (* pcbLength)           = pExistingSBEAttribute -> Length () ;
            (* pwReserved)          = 0 ;

            //  attribute
            ::CopyMemory (
                pbAttribute,
                pExistingSBEAttribute -> Attribute (),
                pExistingSBEAttribute -> Length ()
                ) ;

            //  name
            ::CopyMemory (
                (LPVOID) pszAttributeName,
                (LPVOID) pExistingSBEAttribute -> Name (),
                pExistingSBEAttribute -> NameLenBytes ()
                ) ;

            //  success
            hr = S_OK ;
        }
        else {
            //  buffer too small
            (* pcbLength)       = pExistingSBEAttribute -> Length () ;
            (* pcchNameLength)  = (WORD) pExistingSBEAttribute -> NameLenBytes () ;

            if (!pszAttributeName &&
                !pbAttribute) {

                hr = S_OK ;
            }
            else {
                hr = VFW_E_BUFFER_OVERFLOW ;
            }
        }
    }

    Unlock_ () ;

    return hr ;
}

#ifdef SBE_PERF

ULONGLONG   g_cSample ;

void
OnCaptureInstrumentPerf_ (
    IN  IMediaSample *  pIMediaSample,
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  int             iStream
    )
{
    INSSBUFFER3PROP_PERF    SBEPerf ;
    REFERENCE_TIME          rtStart ;
    REFERENCE_TIME          rtStop ;

    SBEPerf.cMuxPacketCount = ++g_cSample ;
    SBEPerf.cMillisAtWrite  = ::timeGetTime () ;
    SBEPerf.iStream         = iStream ;
    SBEPerf.fDiscontinuity  = (pIMediaSample -> IsDiscontinuity () == S_OK) ;
    SBEPerf.fTimestamped    = (pIMediaSample -> GetTime (& rtStart, & rtStop) == S_OK) ;
    SBEPerf.cBytes          = pIMediaSample -> GetActualDataLength () ;
    SBEPerf.dwReserved1     = 0 ;
    SBEPerf.dwReserved2     = 0 ;

    DVRAttributeHelpers::SetAttribute (
        pINSSBuffer3,
        INSSBuffer3Prop_Perf,
        sizeof SBEPerf,
        (BYTE *) & SBEPerf
        ) ;
}

void
OnReadout_Perf_ (
    IN  INSSBuffer3 *   pINSSBuffer3
    )
{
    INSSBUFFER3PROP_PERF    SBEPerf ;
    DWORD                   dwSize ;
    HRESULT                 hr ;
    DWORD                   dwDeltaTicks ;

    dwSize = sizeof SBEPerf ;
    hr = DVRAttributeHelpers::GetAttribute (
        pINSSBuffer3,
        INSSBuffer3Prop_Perf,
        & dwSize,
        (BYTE *) & SBEPerf
        ) ;
    if (SUCCEEDED (hr) &&
        dwSize == sizeof SBEPerf) {

        dwDeltaTicks = ::timeGetTime () - SBEPerf.cMillisAtWrite ;

        TRACE_7 (LOG_TIMING, 1, TEXT ("SBE_PERF: stream[%-2d] : %-10u bytes; mux packet = %-10I64u; write ms = %-8u; delta ms = %-8u; discontinuity = %d; pts = %d;"),
            SBEPerf.iStream,
            SBEPerf.cBytes,
            SBEPerf.cMuxPacketCount,
            SBEPerf.cMillisAtWrite,
            dwDeltaTicks,
            SBEPerf.fDiscontinuity,
            SBEPerf.fTimestamped
            ) ;
    }
}

#endif  //  SBE_PERF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\util\dvrpolicy.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        dvrpolicy.cpp

    Abstract:

        This module contains the class implementation for stats.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        24-May-2001     created

--*/

#include "dvrall.h"

//  ============================================================================
//  ============================================================================

CTSDVRSettings::CTSDVRSettings (
    IN  HKEY    hkeyDefaultTopLevel,
    IN  TCHAR * psz2ndLevel,
    IN  TCHAR * pszInstanceRoot
    ) : m_hkeyDVRRoot       (NULL),
        m_hkeyInstanceRoot  (NULL),
        m_hkeyStats         (NULL)
{
    HKEY    hkeyDVRRoot ;
    LONG    l ;

    TRACE_CONSTRUCTOR (TEXT ("CTSDVRSettings")) ;

    InitializeCriticalSection (& m_crt) ;

    hkeyDVRRoot = NULL ;

    l = RegCreateKeyEx (
            hkeyDefaultTopLevel,
            psz2ndLevel,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & hkeyDVRRoot,
            NULL
            ) ;
    if (l == ERROR_SUCCESS) {

        //  deliberately ignore the return value here -- we've got defaults for
        //   all calls into this object; we pay attention to return value if
        //   an external caller sets us up
        SetDVRRegKey (
            hkeyDVRRoot,
            pszInstanceRoot
            ) ;

        RegCloseKey (hkeyDVRRoot) ;
        hkeyDVRRoot = NULL ;
    }

    //  stats is special; it is kept globally, per system
    l = RegCreateKeyEx (
            REG_DVR_TOP_LEVEL,
            REG_DVR_2ND_LEVEL TEXT ("\\") REG_DVR_ROOT,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyStats,
            NULL
            ) ;
    if (l == ERROR_SUCCESS) {
        //  init
        m_Reg_StatsEnabled.fValid = FALSE ;
        GetValLocked_ (m_hkeyStats, REG_DVR_STATS_NAME, REG_CONST_DVR_STATS, REG_DEF_STATS, & m_Reg_StatsEnabled) ;
        m_Reg_StatsEnabled.fValid = TRUE ;
    }
    else {
        //  make sure this is NULL if above call failed
        m_hkeyStats = NULL ;
    }

    //  BUGBUG: remove
    g_fRegGenericStreams_Video = REG_VID_USE_GENERIC_STREAMS_DEFAULT ;
    GetRegDWORDValIfExist (m_hkeyDVRRoot, REG_VID_USE_GENERIC_STREAMS_NAME, (DWORD *) & g_fRegGenericStreams_Video) ;

    //  BUGBUG: remove
    g_fRegGenericStreams_Audio = REG_AUD_USE_GENERIC_STREAMS_DEFAULT ;
    GetRegDWORDValIfExist (m_hkeyDVRRoot, REG_AUD_USE_GENERIC_STREAMS_NAME, (DWORD *) & g_fRegGenericStreams_Audio) ;

    return ;
}

CTSDVRSettings::~CTSDVRSettings (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CTSDVRSettings")) ;

    CloseRegKeys_ () ;

    if (m_hkeyStats) {
        RegCloseKey (m_hkeyStats) ;
    }

    DeleteCriticalSection (& m_crt) ;
}

void
CTSDVRSettings::ResetCachedRegValuesLocked_ (
    )
{
    //  first invalidate everything
    for (int i = 0; i < REG_VALUE_COUNT; i++) {
        m_RegVal [i].fValid = FALSE ;
    }
    //  except for stats - it's global
    //m_Reg_StatsEnabled.fValid                   = FALSE ;

    //  now preset some of the defaults; the DVRIO layer doesn't necessarily
    //    create the key, but does look for its presence
    WMPacketSize () ;
}

void
CTSDVRSettings::CloseRegKeys_ (
    )
{
    Lock_ () ;

    if (m_hkeyDVRRoot) {
        RegCloseKey (m_hkeyDVRRoot) ;
        m_hkeyDVRRoot = NULL ;
    }

    if (m_hkeyInstanceRoot) {
        RegCloseKey (m_hkeyInstanceRoot) ;
        m_hkeyInstanceRoot = NULL ;
    }

    Unlock_ () ;
}

HRESULT
CTSDVRSettings::SetDVRRegKey (
    IN  HKEY    hkeyRoot,
    IN  TCHAR * pszInstanceRoot
    )
{
    LONG    l ;

    Lock_ () ;

    CloseRegKeys_ () ;

    l = RegCreateKeyEx (
            hkeyRoot,
            REG_DVR_ROOT,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyDVRRoot,
            NULL
            ) ;
    if (l != ERROR_SUCCESS) { goto cleanup ; }

    l = RegCreateKeyEx (
            m_hkeyDVRRoot,
            pszInstanceRoot,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyInstanceRoot,
            NULL
            ) ;
    if (l != ERROR_SUCCESS) { goto cleanup ; }

    ResetCachedRegValuesLocked_ () ;

    cleanup :

    if (l != ERROR_SUCCESS) {
        CloseRegKeys_ () ;
    }

    Unlock_ () ;

    return (HRESULT_FROM_WIN32 (l)) ;
}

DWORD
CTSDVRSettings::GetValLocked_ (
    IN  HKEY                hkeyRoot,
    IN  TCHAR *             szValName,
    IN  BOOL                fConst,
    IN  DWORD               dwDefVal,
    IN  CTRegVal <DWORD> *  prv
    )
{
    DWORD dwRet ;

    if (!prv -> fValid) {

        if (!fConst) {

            dwRet = dwDefVal ;

            if (m_hkeyDVRRoot) {
                GetRegDWORDValIfExist (hkeyRoot, szValName, & dwRet) ;
            }

            prv -> Val = dwRet ;
            prv -> fValid = TRUE ;
        }
        else {
            return GetValLocked_ (
                        hkeyRoot,
                        szValName,
                        fConst,
                        dwDefVal,
                        dwDefVal,
                        dwDefVal,
                        prv
                        ) ;
        }
    }

    return prv -> Val ;
}

DWORD
CTSDVRSettings::GetValLocked_ (
    IN  HKEY                hkeyRoot,
    IN  TCHAR *             szValName,
    IN  BOOL                fConst,
    IN  DWORD               dwDefVal,
    IN  DWORD               dwMin,
    IN  DWORD               dwMax,
    IN  CTRegVal <DWORD> *  prv
    )
{
    DWORD dwRet ;

    ASSERT (dwMin <= dwDefVal && dwDefVal <= dwMax) ;

    if (!prv -> fValid) {

        dwRet = dwDefVal ;

        if (m_hkeyDVRRoot) {
            GetRegDWORDValIfExist (hkeyRoot, szValName, & dwRet) ;

            if (!fConst) {

                //  not fixed; check against the bracket

                if (dwRet < dwMin) {
                    //  less than min; adjust & update the value in the registry
                    dwRet = dwMin ;
                    ::SetRegDWORDVal (hkeyRoot, szValName, dwRet) ;

                }
                else if (dwRet > dwMax) {
                    dwRet = dwMax ;
                    ::SetRegDWORDVal (hkeyRoot, szValName, dwRet) ;
                }
            }
            else {
                //  fixed; if not default, then set it
                if (dwRet != dwDefVal) {
                    dwRet = dwDefVal ;
                    ::SetRegDWORDVal (hkeyRoot, szValName, dwRet) ;
                }
            }

        }

        prv -> Val = dwRet ;
        prv -> fValid = TRUE ;
    }

    return prv -> Val ;
}

DWORD
CTSDVRSettings::EnableStats (
    IN  BOOL    f
    )
{
    BOOL    r ;

    Lock_ () ;

    if (m_hkeyDVRRoot) {
        r = SetRegDWORDVal (m_hkeyDVRRoot, REG_DVR_STATS_NAME, (f ? DVR_STATS_ENABLED : DVR_STATS_DISABLED)) ;
        if (r) {
            m_Reg_StatsEnabled.Val = f ;
            m_Reg_StatsEnabled.fValid = TRUE ;
        }
    }
    else {
        r = FALSE ;
    }

    Unlock_ () ;

    return (r ? NOERROR : ERROR_GEN_FAILURE) ;
}

//  ============================================================================

CDVRPolicy::CDVRPolicy (
    IN  TCHAR *     pszInstRegRoot,
    OUT HRESULT *   phr
    ) : m_lRef          (1),
        m_pW32SID       (NULL),
        m_RegSettings   (REG_DVR_TOP_LEVEL, REG_DVR_2ND_LEVEL, pszInstRegRoot)
{
    InitializeCriticalSection (& m_crt) ;

    (* phr) = S_OK ;

    return ;
}

CDVRPolicy::~CDVRPolicy (
    )
{
    RELEASE_AND_CLEAR (m_pW32SID) ;
    DeleteCriticalSection (& m_crt) ;
    TRACE_DESTRUCTOR (TEXT ("CDVRPolicy")) ;
}

ULONG
CDVRPolicy::Release (
    )
{
    if (InterlockedDecrement (& m_lRef) == 0) {
        delete this ;
        return 0 ;
    }

    return m_lRef ;
}

HRESULT
CDVRPolicy::SetSIDs (
    IN  DWORD   cSIDs,
    IN  PSID *  ppSID
    )
{
    HRESULT hr ;
    DWORD   dwRet ;

    if (!ppSID &&
        cSIDs != 0) {

        return E_POINTER ;
    }

    Lock_ () ;

    RELEASE_AND_CLEAR (m_pW32SID) ;

    if (ppSID) {

        ASSERT (cSIDs) ;

        m_pW32SID = new CW32SID (ppSID, cSIDs, & dwRet) ;
        if (!m_pW32SID) {
            hr = E_OUTOFMEMORY ;
        }
        else if (dwRet != NOERROR) {
            hr = HRESULT_FROM_WIN32 (dwRet) ;
            delete m_pW32SID ;
            m_pW32SID = NULL ;
        }
        else {
            //  ours
            m_pW32SID -> AddRef () ;
            hr = S_OK ;
        }
    }
    else {
        //  explicitely cleared
        hr = S_OK ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CDVRPolicy::GetSIDs (
    OUT CW32SID **  ppW32SIDs
    )
{
    HRESULT hr ;

    ASSERT (ppW32SIDs) ;

    Lock_ () ;

    if (m_pW32SID) {
        (* ppW32SIDs) = m_pW32SID ;

        //  outgoing
        (* ppW32SIDs) -> AddRef () ;

        hr = S_OK ;
    }
    else {
        (* ppW32SIDs) = NULL ;

        hr = E_FAIL ;
    }

    Unlock_ () ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVREventSink::CDVREventSink (
    ) : m_pIMediaEventSink  (NULL)
{
    InitializeCriticalSection (& m_crt) ;
}

CDVREventSink::~CDVREventSink (
    )
{
    RELEASE_AND_CLEAR (m_pIMediaEventSink) ;
    DeleteCriticalSection (& m_crt) ;
}

HRESULT
CDVREventSink::Initialize (
    IN  IFilterGraph *  pIFilterGraph
    )
{
    HRESULT hr ;

    Lock_ () ;

    RELEASE_AND_CLEAR (m_pIMediaEventSink) ;
    if (pIFilterGraph) {
        hr = pIFilterGraph -> QueryInterface (IID_IMediaEventSink, (void **) & m_pIMediaEventSink) ;
    }
    else {
        hr = S_OK ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CDVREventSink::OnEvent (
    IN  long        lEventCode,
    IN  LONG_PTR    lptrEventParam1,
    IN  LONG_PTR    lptrEventParam2
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (m_pIMediaEventSink) {
        hr = m_pIMediaEventSink -> Notify (
            lEventCode,
            lptrEventParam1,
            lptrEventParam2
            ) ;

        TRACE_6 (LOG_AREA_DSHOW, 1,
            TEXT ("CDVREventSink::OnEvent () -> event = %d (%08xh), param1 = %d (%08xh), param2 = %d (%08xh)"),
            lEventCode, lEventCode,
            lptrEventParam1, lptrEventParam1,
            lptrEventParam2, lptrEventParam2
            ) ;
    }
    else {
        hr = S_OK ;
    }

    Unlock_ () ;

    return hr ;
}

void
__stdcall
CDVREventSink::DVRIOCallback (
    IN  LPVOID  pvContext,
    IN  DWORD   dwNotificationReasons
    )
{
    CDVREventSink * pDVREventSink ;

    ASSERT (pvContext) ;
    pDVREventSink = reinterpret_cast <CDVREventSink *> (pvContext) ;

    //  translate DVRIO -> dshow

    if (dwNotificationReasons & DVRIO_NOTIFICATION_REASON_CATCH_UP) {
        pDVREventSink -> OnEvent (
            STREAMBUFFER_EC_CONTENT_BECOMING_STALE,
            0,
            0
            ) ;
    }

    if (dwNotificationReasons & DVRIO_NOTIFICATION_REASON_FILE_GONE) {
        pDVREventSink -> OnEvent (
            STREAMBUFFER_EC_STALE_FILE_DELETED,
            0,
            0
            ) ;
    }

    if (dwNotificationReasons & DVRIO_NOTIFICATION_REASON_WRITE_ERROR) {
        pDVREventSink -> OnEvent (
            STREAMBUFFER_EC_WRITE_FAILURE,
            0,
            0
            ) ;
    }
}

//  ============================================================================
//  ============================================================================

CDVRConfigure::CDVRConfigure (
    IN  LPUNKNOWN   punkControlling
    ) : CUnknown        (TEXT (DVR_CONFIGURATION),
                         punkControlling
                         ),
        m_hkeyDVRRoot   (NULL)
{
}

CDVRConfigure::~CDVRConfigure (
    )
{
    if (m_hkeyDVRRoot) {
        RegCloseKey (m_hkeyDVRRoot) ;
    }
}

STDMETHODIMP
CDVRConfigure::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT VOID ** ppv
    )
{
    if (riid == IID_IStreamBufferConfigure) {

        return GetInterface (
                    (IStreamBufferConfigure *) this,
                    ppv
                    ) ;
    }

    else if (riid == IID_IStreamBufferInitialize) {

        return GetInterface (
                    (IStreamBufferInitialize *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

STDMETHODIMP
CDVRConfigure::SetDirectory (
    IN  LPCWSTR pszDirectoryName
    )
{
    HRESULT hr ;
    DWORD   dw ;
    BOOL    r ;
    LPWSTR  pszTempDVRDir ;
    DWORD   dwParamLen ;
    DWORD   dwDVRIOTempDirLen ;
    WCHAR   achDVRIOTempDir [MAX_PATH] ;
    DWORD   dwAttrib ;
    DWORD   dwRegStringLen ;

    if (!pszDirectoryName) {
        return E_POINTER ;
    }

    if (!IsInitialized_ ()) {
        return E_UNEXPECTED ;
    }

    dwParamLen = lstrlenW (pszDirectoryName) ;
    if (dwParamLen == 0) {
        return E_INVALIDARG ;
    }

    //  try to create the directory that the DVRIO layer will create; compute
    //    length of string we'll need to allocate

    //  tally the base length
    dwDVRIOTempDirLen   = dwParamLen ;                                              //  specified string
    dwDVRIOTempDirLen   += (pszDirectoryName [dwParamLen - 1] != L'\\' ? 1 : 0) ;   //  might have to insert a '\'

    //  this is the length of the string that we're going to put in the registry
    dwRegStringLen = dwDVRIOTempDirLen ;

    //  plus the hidden system directory that the DVRIO layer will append
    dwDVRIOTempDirLen   += wcslen (DVRIO_RINGBUFFER_TEMPDIRNAME) ;                  //  temp dir name
    dwDVRIOTempDirLen   += 1 ;                                                      //  null-terminator

    //  make sure the total length we'll need is bounded
    if (dwDVRIOTempDirLen > MAX_PATH) {
        return E_INVALIDARG ;
    }

    //  create the string
    wsprintf (achDVRIOTempDir, L"%s%s%s",
        pszDirectoryName,
        (pszDirectoryName [dwParamLen - 1] != L'\\' ? L"\\" : L""),
        DVRIO_RINGBUFFER_TEMPDIRNAME
        ) ;

    r = ::CreateDirectoryW (achDVRIOTempDir, NULL) ;
    if (!r)
    {
        dwAttrib = ::GetFileAttributesW (achDVRIOTempDir);
        if (dwAttrib == (DWORD) (-1))
        {
            dw = ::GetLastError () ;
            hr = HRESULT_FROM_WIN32 (dw) ;
            goto cleanup ;
        }
        else if ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
        {
            dw = ERROR_DIRECTORY ;
            hr = HRESULT_FROM_WIN32(dw) ;
            goto cleanup ;
        }

        //  else we're still ok
    }

    //  lop off the hidden system directory that the DVRIO layer will append; this
    //    ensures that what we write into the registry is a directory; we deal
    //    fine with just a drive letter, but then it's vague when the value is
    //    retrieved
    achDVRIOTempDir [dwRegStringLen] = L'\0' ;

    r = ::SetRegStringValW (
            m_hkeyDVRRoot,
            REG_DVRIO_WRITER_LOCATION,
            REG_DVRIO_WRITER_LOCATION_KEYNAME,
            achDVRIOTempDir
            ) ;

    if (r) {
        //  success: registry key created
        hr = S_OK ;
    }
    else {
        //  lost the error code
        hr = E_FAIL ;
    }

    cleanup :

    return hr ;
}

STDMETHODIMP
CDVRConfigure::GetDirectory (
    OUT LPWSTR *    ppszDirectoryName
    )
{
    HRESULT hr ;
    DWORD   dwLen ;
    BOOL    r ;

    if (!ppszDirectoryName) {
        return E_POINTER ;
    }

    if (!IsInitialized_ ()) {
        return E_UNEXPECTED ;
    }

    //  get the length
    r = ::GetRegStringValW (
            m_hkeyDVRRoot,
            REG_DVRIO_WRITER_LOCATION,
            REG_DVRIO_WRITER_LOCATION_KEYNAME,
            & dwLen,
            NULL
            ) ;
    if (r && dwLen > sizeof WCHAR) {
        //  key value exists and value is not an empty string

        //  allocate
        (* ppszDirectoryName) = (LPWSTR) CoTaskMemAlloc (dwLen) ;
        if (* ppszDirectoryName) {
            //  retrieve
            r = ::GetRegStringValW (
                    m_hkeyDVRRoot,
                    REG_DVRIO_WRITER_LOCATION,
                    REG_DVRIO_WRITER_LOCATION_KEYNAME,
                    & dwLen,
                    (BYTE *) (* ppszDirectoryName)
                    ) ;
            if (r) {
                hr = S_OK ;
            }
            else {
                CoTaskMemFree (* ppszDirectoryName) ;
                (* ppszDirectoryName) = NULL ;

                hr = E_FAIL ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  key may not exist.. TEMP is our default
        dwLen = ::GetTempPathW (0, NULL) ;
        if (dwLen > 0) {
            dwLen++ ;   //  null-terminator
            (* ppszDirectoryName) = (LPWSTR) CoTaskMemAlloc (dwLen * sizeof WCHAR) ;
            if (* ppszDirectoryName) {
                //  retrieve
                dwLen = ::GetTempPathW (dwLen, (* ppszDirectoryName)) ;
                if (dwLen > 0) {
                    hr = S_OK ;
                }
                else {
                    CoTaskMemFree (* ppszDirectoryName) ;
                    (* ppszDirectoryName) = NULL ;

                    hr = E_FAIL ;
                }
            }
            else {
                hr = E_OUTOFMEMORY ;
            }
        }
        else {
            //  no temp path ??
            hr = E_FAIL ;
        }
    }

    return hr ;
}

STDMETHODIMP
CDVRConfigure::SetBackingFileCount (
    IN  DWORD   dwMin,
    IN  DWORD   dwMax
    )
{
    BOOL    r ;
    HRESULT hr ;

    if (!IsInitialized_ ()) {
        return E_UNEXPECTED ;
    }

    if (!InRange <DWORD> (dwMin, DVR_MIN_HARD_STOP_MIN_BACKING_FILES, DVR_MAX_HARD_STOP_MIN_BACKING_FILES)  ||
        !InRange <DWORD> (dwMax, DVR_MIN_HARD_STOP_MAX_BACKING_FILES, DVR_MAX_HARD_STOP_MAX_BACKING_FILES)  ||
        dwMax <= dwMin                                                                                      ||
        dwMin + DVR_MIN_HARD_STOP_MIN_MAX_DELTA > dwMax) {

        return E_INVALIDARG ;
    }

    //  min
    r = ::SetRegDWORDVal (
            m_hkeyDVRRoot,
            REG_MIN_NUM_BACKING_FILES_NAME,
            dwMin
            ) ;
    if (r) {
        //  max
        r = ::SetRegDWORDVal (
                m_hkeyDVRRoot,
                REG_MAX_NUM_BACKING_FILES_NAME,
                dwMax
                ) ;
        if (r) {
            //  grow by
            r = ::SetRegDWORDVal (
                    m_hkeyDVRRoot,
                    REG_RING_BUFFER_GROW_BY_NAME,
                    Min <DWORD> (dwMin, DVR_MAX_HARD_STOP_MAX_BACKING_FILES - dwMin)
                    ) ;
        }
    }

    if (r) {
        hr = S_OK ;
    }
    else {
        //  lost the error code
        hr = E_FAIL ;
    }

    return hr ;
}

STDMETHODIMP
CDVRConfigure::GetBackingFileCount (
    OUT DWORD * pdwMin,
    OUT DWORD * pdwMax
    )
{
    BOOL    r ;

    if (!IsInitialized_ ()) {
        return E_UNEXPECTED ;
    }

    if (!pdwMin ||
        !pdwMax) {

        return E_POINTER ;
    }

    //  min
    r = ::GetRegDWORDVal (
            m_hkeyDVRRoot,
            REG_MIN_NUM_BACKING_FILES_NAME,
            pdwMin
            ) ;
    if (!r) {
        (* pdwMin) = REG_DEF_MIN_NUM_BACKING_FILES ;
    }

    //  max
    r = ::GetRegDWORDVal (
            m_hkeyDVRRoot,
            REG_MAX_NUM_BACKING_FILES_NAME,
            pdwMax
            ) ;
    if (!r) {
        (* pdwMax) = REG_DEF_MAX_NUM_BACKING_FILES ;
    }

    return S_OK ;
}

STDMETHODIMP
CDVRConfigure::SetBackingFileDuration (
    IN  DWORD   dwSeconds
    )
{
    BOOL    r ;
    HRESULT hr ;

    if (!IsInitialized_ ()) {
        return E_UNEXPECTED ;
    }

    if (dwSeconds < DVR_MIN_HARD_STOP_BACKING_FILE_DURATION_SEC) {
        return E_INVALIDARG ;
    }

    r = ::SetRegDWORDVal (
            m_hkeyDVRRoot,
            REG_BACKING_FILE_DURATION_SECONDS_NAME,
            dwSeconds
            ) ;
    if (r) {
        hr = S_OK ;
    }
    else {
        hr = E_FAIL ;
    }

    return hr ;
}

STDMETHODIMP
CDVRConfigure::GetBackingFileDuration (
    OUT DWORD * pdwSeconds
    )
{
    BOOL    r ;

    if (!IsInitialized_ ()) {
        return E_UNEXPECTED ;
    }

    if (!pdwSeconds) {
        return E_POINTER ;
    }

    r = ::GetRegDWORDVal (
            m_hkeyDVRRoot,
            REG_BACKING_FILE_DURATION_SECONDS_NAME,
            pdwSeconds
            ) ;
    if (!r) {
        (* pdwSeconds) = REG_DEF_BACKING_FILE_DURATION_SECONDS ;
    }

    return S_OK ;
}

STDMETHODIMP
CDVRConfigure::SetHKEY (
    IN  HKEY    hkeyRoot
    )
{
    HRESULT hr ;
    LONG    l ;

    if (m_hkeyDVRRoot) {
        RegCloseKey (m_hkeyDVRRoot) ;
        m_hkeyDVRRoot = NULL ;
    }

    l = RegCreateKeyEx (
            hkeyRoot,
            REG_DVR_ROOT,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyDVRRoot,
            NULL
            ) ;
    if (l != ERROR_SUCCESS) { goto cleanup ; }

    cleanup :

    hr = HRESULT_FROM_WIN32 (l) ;

    return hr ;
}

STDMETHODIMP
CDVRConfigure::SetSIDs (
    IN  DWORD   cSIDs,
    IN  PSID *  ppSID
    )
{
    return E_NOTIMPL ;
}

CUnknown *
WINAPI
CDVRConfigure::CreateInstance (
    IN  IUnknown *  punkControlling,
    IN  HRESULT *   phr
    )
{
    CDVRConfigure * pDVRConfigure ;

    pDVRConfigure = new CDVRConfigure (punkControlling) ;

    return pDVRConfigure ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\util\dvrw32.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrw32.cpp

    Abstract:

        This module the ts/dvr-wide utility code;

    Author:

        Matthijs Gates  (mgates)

    Revision History:


--*/

#include "dvrall.h"

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = L'\0';
	MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);

	return buffer;
}

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = '\0';
	WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len, NULL, FALSE);

	return buffer;
}

BOOL
IsXPe (
    )
{
	OSVERSIONINFOEX Version ;
    BOOL            r ;

	Version.dwOSVersionInfoSize = sizeof OSVERSIONINFOEX ;

	::GetVersionEx (reinterpret_cast <LPOSVERSIONINFO> (& Version)) ;

    r = ((Version.wSuiteMask & VER_SUITE_EMBEDDEDNT) ? TRUE : FALSE) ;

    return r ;
}

BOOL
CheckOS (
    )
{
    BOOL    r ;

#ifdef DVR_XPE_ONLY
    #pragma message("XPe bits only")
    r = ::IsXPe () ;
#else
    r = TRUE ;
#endif

    return r ;
}

static
BOOL
IsModulePresent (
    IN  LPCWSTR pszDLLName
    )
{
    BOOL    r ;
    HMODULE hMod ;

    r = FALSE ;

    hMod = ::LoadLibrary (pszDLLName) ;

    if (hMod) {
        ::FreeLibrary (hMod) ;
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
RequiredModulesPresent (
    )
{
    BOOL    r ;

    return TRUE ;

    r = (IsModulePresent (L"wmvcore2.dll") &&
         IsModulePresent (L"sbeio.dll") ? TRUE : FALSE) ;

    return r ;
}

static
VOID *
WINAPI
hook_NULL (
    )
{
	::SetLastError( ERROR_MOD_NOT_FOUND ) ;

	return NULL ;
}

static
DWORD
WINAPI
hook_NOTFOUND (
    )
{
	return HRESULT_FROM_WIN32 (ERROR_MOD_NOT_FOUND) ;
}

FARPROC
WINAPI
SBE_DelayLoadFailureHook (
    IN  UINT            unReason,
    IN  DelayLoadInfo * pDelayInfo
    )
{
	if(!lstrcmpiA (pDelayInfo -> szDll, "wmvcore2.dll") ||
	   !lstrcmpiA (pDelayInfo -> szDll, "sbeio.dll")) {

		return (FARPROC) hook_NOTFOUND ;
	}

	return (FARPROC) hook_NULL ;
}

PfnDliHook __pfnDliFailureHook2 = SBE_DelayLoadFailureHook ;

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR szValName,
    OUT DWORD * pdw
    )
//  value exists:           retrieves it
//  value does not exist:   sets it
{
    BOOL    r ;
    DWORD   dwCurrent ;

    r = GetRegDWORDVal (
            hkeyRoot,
            szValName,
            & dwCurrent
            ) ;
    if (r) {
        (* pdw) = dwCurrent ;
    }
    else {
        r = SetRegDWORDVal (
                hkeyRoot,
                szValName,
                (* pdw)
                ) ;
    }

    return r ;
}

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdw
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dwCurrent ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdw) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDValIfExist (
                hkey,
                pszRegValName,
                pdw
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegStringValW (
    IN      HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN      LPCWSTR pszRegRoot,
    IN      LPCWSTR pszRegValName,
    IN OUT  DWORD * pdwLen,         //  out: string length + null, in bytes
    OUT     BYTE *  pbBuffer
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dwCurrent ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdwLen) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegStringValW (
                hkey,
                pszRegValName,
                pdwLen,
                pbBuffer
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegStringValW (
    IN      HKEY    hkeyRoot,
    IN      LPCTSTR pszRegValName,
    IN OUT  DWORD * pdwLen,         //  out: string length + null, in bytes
    OUT     BYTE *  pbBuffer
    )
{
    BOOL    r ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;

    ASSERT (pszRegValName) ;

    dwType = REG_SZ ;

    l = RegQueryValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            & dwType,
            (LPBYTE) pbBuffer,
            pdwLen
            ) ;
    if (l == ERROR_SUCCESS) {
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dwCurrent ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDVal (
                hkey,
                pszRegValName,
                pdwRet
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    BOOL    r ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;

    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    dwSize = sizeof (* pdwRet) ;
    dwType = REG_DWORD ;

    l = RegQueryValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            & dwType,
            (LPBYTE) pdwRet,
            & dwSize
            ) ;
    if (l == ERROR_SUCCESS) {
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
SetRegStringValW (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCWSTR pszRegRoot,
    IN  LPCWSTR pszRegValName,
    IN  LPCWSTR pszStringVal
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        r = SetRegStringValW (
                hkey,
                pszRegValName,
                pszStringVal
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}


BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        r = SetRegDWORDVal (
                hkey,
                pszRegValName,
                dwVal
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    LONG    l ;

    l = RegSetValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            REG_DWORD,
            (const BYTE *) & dwVal,
            sizeof dwVal
            ) ;

    return (l == ERROR_SUCCESS ? TRUE : FALSE) ;
}

BOOL
SetRegStringValW (
    IN  HKEY    hkeyRoot,
    IN  LPCWSTR pszRegValName,
    IN  LPCWSTR pszVal
    )
{
    LONG    l ;
    DWORD   dwLen ;

    ASSERT (pszVal) ;

    dwLen = wcslen (pszVal) * sizeof WCHAR ;
    dwLen += sizeof L'\0' ;

    l = RegSetValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            REG_SZ,
            (const BYTE *) pszVal,
            dwLen
            ) ;

    return (l == ERROR_SUCCESS ? TRUE : FALSE) ;
}

//  ============================================================================
//  ============================================================================

CWin32SharedMem::CWin32SharedMem (
    IN  TCHAR *     szName,
    IN  DWORD       dwSize,
    OUT HRESULT *   phr,
    IN  PSECURITY_ATTRIBUTES psa // = NULL
    ) : m_pbShared  (NULL),
        m_dwSize    (0),
        m_hMapping  (NULL)
{
    (* phr) = Create_ (szName, dwSize, psa) ;
}

CWin32SharedMem::~CWin32SharedMem (
    )
{
    Free_ () ;
}

HRESULT
CWin32SharedMem::Create_ (
    IN  TCHAR * pszName,
    IN  DWORD   dwSize,
    IN  PSECURITY_ATTRIBUTES psa
    )
{
    HRESULT hr ;
    DWORD   dw ;

    Free_ () ;

    ASSERT (m_hMapping  == NULL) ;
    ASSERT (m_dwSize    == 0) ;
    ASSERT (m_pbShared  == NULL) ;
    ASSERT (dwSize      > 0) ;

    m_dwSize = dwSize ;

    hr = S_OK ;

    m_hMapping = CreateFileMapping (
                            INVALID_HANDLE_VALUE,
                            psa,
                            PAGE_READWRITE,
                            0,
                            m_dwSize,
                            pszName
                            ) ;

    if (m_hMapping == NULL) {
        dw = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    m_pbShared = reinterpret_cast <BYTE *>
                    (MapViewOfFile (
                                m_hMapping,
                                FILE_MAP_READ | FILE_MAP_WRITE,
                                0,
                                0,
                                0
                                )) ;
    if (m_pbShared == NULL) {
        dw = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    cleanup :

    if (FAILED (hr)) {
        Free_ () ;
    }

    return hr ;
}

void
CWin32SharedMem::Free_ (
    )
{
    if (m_pbShared != NULL) {
        ASSERT (m_hMapping != NULL) ;
        UnmapViewOfFile (m_pbShared) ;
    }

    if (m_hMapping != NULL) {
        CloseHandle (m_hMapping) ;
    }

    m_hMapping  = NULL ;
    m_pbShared  = NULL ;
    m_dwSize    = 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\inc\nserror.h ===
/*++

  Microsoft Windows Media Technology
  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.

Module Name:

    nserror.mc

Abstract:

    Definitions for Windows Media events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the nserror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 LEGACY RANGES

     0  -  199 = General NetShow errors

   200  -  399 = NetShow error events

   400  -  599 = NetShow monitor events

   600  -  799 = NetShow IMmsAutoServer errors

  1000  - 1199 = NetShow MCMADM errors


 NEW RANGES

  2000 -  2999 = ASF (defined in ASFERR.MC)

  3000 -  3999 = Windows Media SDK

  4000 -  4999 = Windows Media Player

  5000 -  5999 = Windows Media Server

  6000 -  6999 = Windows Media HTTP/RTSP result codes (defined in NETERROR.MC)

  7000 -  7999 = Windows Media Tools

  8000 -  8999 = Windows Media Content Discovery

  9000 -  9999 = Windows Media Real Time Collaboration

 10000 - 10999 = Windows Media Digital Rights Management

 11000 - 11999 = Windows Media Setup

 12000 - 12999 = Windows Media Networking

 13000 - 13999 = Windows Media Client Media Services

**************************** READ ME ******************************************

--*/

#ifndef _NSERROR_H
#define _NSERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Success Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS_WIN32                0x7
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: NS_S_CALLPENDING
//
// MessageText:
//
//  The requested operation is pending completion.%0
//
#define NS_S_CALLPENDING                 0x000D0000L

//
// MessageId: NS_S_CALLABORTED
//
// MessageText:
//
//  The requested operation was aborted by the client.%0
//
#define NS_S_CALLABORTED                 0x000D0001L

//
// MessageId: NS_S_STREAM_TRUNCATED
//
// MessageText:
//
//  The stream was purposefully stopped before completion.%0
//
#define NS_S_STREAM_TRUNCATED            0x000D0002L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Warning Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_W_SERVER_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum filebitrate value specified is greater than the server's configured maximum bandwidth.%0
//
#define NS_W_SERVER_BANDWIDTH_LIMIT      0x800D0003L

//
// MessageId: NS_W_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum bandwidth value specified is less than the maximum filebitrate.%0
//
#define NS_W_FILE_BANDWIDTH_LIMIT        0x800D0004L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection established with the Windows Media server. The operation failed.%0
//
#define NS_E_NOCONNECTION                0xC00D0005L

//
// MessageId: NS_E_CANNOTCONNECT
//
// MessageText:
//
//  Unable to establish a connection to the server.%0
//
#define NS_E_CANNOTCONNECT               0xC00D0006L

//
// MessageId: NS_E_CANNOTDESTROYTITLE
//
// MessageText:
//
//  Unable to destroy the title.%0
//
#define NS_E_CANNOTDESTROYTITLE          0xC00D0007L

//
// MessageId: NS_E_CANNOTRENAMETITLE
//
// MessageText:
//
//  Unable to rename the title.%0
//
#define NS_E_CANNOTRENAMETITLE           0xC00D0008L

//
// MessageId: NS_E_CANNOTOFFLINEDISK
//
// MessageText:
//
//  Unable to offline disk.%0
//
#define NS_E_CANNOTOFFLINEDISK           0xC00D0009L

//
// MessageId: NS_E_CANNOTONLINEDISK
//
// MessageText:
//
//  Unable to online disk.%0
//
#define NS_E_CANNOTONLINEDISK            0xC00D000AL

//
// MessageId: NS_E_NOREGISTEREDWALKER
//
// MessageText:
//
//  There is no file parser registered for this type of file.%0
//
#define NS_E_NOREGISTEREDWALKER          0xC00D000BL

//
// MessageId: NS_E_NOFUNNEL
//
// MessageText:
//
//  There is no data connection established.%0
//
#define NS_E_NOFUNNEL                    0xC00D000CL

//
// MessageId: NS_E_NO_LOCALPLAY
//
// MessageText:
//
//  Failed to load the local play DLL.%0
//
#define NS_E_NO_LOCALPLAY                0xC00D000DL

//
// MessageId: NS_E_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.%0
//
#define NS_E_NETWORK_BUSY                0xC00D000EL

//
// MessageId: NS_E_TOO_MANY_SESS
//
// MessageText:
//
//  The server session limit was exceeded.%0
//
#define NS_E_TOO_MANY_SESS               0xC00D000FL

//
// MessageId: NS_E_ALREADY_CONNECTED
//
// MessageText:
//
//  The network connection already exists.%0
//
#define NS_E_ALREADY_CONNECTED           0xC00D0010L

//
// MessageId: NS_E_INVALID_INDEX
//
// MessageText:
//
//  Index %1 is invalid.%0
//
#define NS_E_INVALID_INDEX               0xC00D0011L

//
// MessageId: NS_E_PROTOCOL_MISMATCH
//
// MessageText:
//
//  There is no protocol or protocol version supported by both the client and the server.%0
//
#define NS_E_PROTOCOL_MISMATCH           0xC00D0012L

//
// MessageId: NS_E_TIMEOUT
//
// MessageText:
//
//  The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.%0
//
#define NS_E_TIMEOUT                     0xC00D0013L

//
// MessageId: NS_E_NET_WRITE
//
// MessageText:
//
//  Error writing to the network.%0
//
#define NS_E_NET_WRITE                   0xC00D0014L

//
// MessageId: NS_E_NET_READ
//
// MessageText:
//
//  Error reading from the network.%0
//
#define NS_E_NET_READ                    0xC00D0015L

//
// MessageId: NS_E_DISK_WRITE
//
// MessageText:
//
//  Error writing to a disk.%0
//
#define NS_E_DISK_WRITE                  0xC00D0016L

//
// MessageId: NS_E_DISK_READ
//
// MessageText:
//
//  Error reading from a disk.%0
//
#define NS_E_DISK_READ                   0xC00D0017L

//
// MessageId: NS_E_FILE_WRITE
//
// MessageText:
//
//  Error writing to a file.%0
//
#define NS_E_FILE_WRITE                  0xC00D0018L

//
// MessageId: NS_E_FILE_READ
//
// MessageText:
//
//  Error reading from a file.%0
//
#define NS_E_FILE_READ                   0xC00D0019L

//
// MessageId: NS_E_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.%0
//
#define NS_E_FILE_NOT_FOUND              0xC00D001AL

//
// MessageId: NS_E_FILE_EXISTS
//
// MessageText:
//
//  The file already exists.%0
//
#define NS_E_FILE_EXISTS                 0xC00D001BL

//
// MessageId: NS_E_INVALID_NAME
//
// MessageText:
//
//  The file name, directory name, or volume label syntax is incorrect.%0
//
#define NS_E_INVALID_NAME                0xC00D001CL

//
// MessageId: NS_E_FILE_OPEN_FAILED
//
// MessageText:
//
//  Failed to open a file.%0
//
#define NS_E_FILE_OPEN_FAILED            0xC00D001DL

//
// MessageId: NS_E_FILE_ALLOCATION_FAILED
//
// MessageText:
//
//  Unable to allocate a file.%0
//
#define NS_E_FILE_ALLOCATION_FAILED      0xC00D001EL

//
// MessageId: NS_E_FILE_INIT_FAILED
//
// MessageText:
//
//  Unable to initialize a file.%0
//
#define NS_E_FILE_INIT_FAILED            0xC00D001FL

//
// MessageId: NS_E_FILE_PLAY_FAILED
//
// MessageText:
//
//  Unable to play a file.%0
//
#define NS_E_FILE_PLAY_FAILED            0xC00D0020L

//
// MessageId: NS_E_SET_DISK_UID_FAILED
//
// MessageText:
//
//  Could not set the disk UID.%0
//
#define NS_E_SET_DISK_UID_FAILED         0xC00D0021L

//
// MessageId: NS_E_INDUCED
//
// MessageText:
//
//  An error was induced for testing purposes.%0
//
#define NS_E_INDUCED                     0xC00D0022L

//
// MessageId: NS_E_CCLINK_DOWN
//
// MessageText:
//
//  Two Content Servers failed to communicate.%0
//
#define NS_E_CCLINK_DOWN                 0xC00D0023L

//
// MessageId: NS_E_INTERNAL
//
// MessageText:
//
//  An unknown error occurred.%0
//
#define NS_E_INTERNAL                    0xC00D0024L

//
// MessageId: NS_E_BUSY
//
// MessageText:
//
//  The requested resource is in use.%0
//
#define NS_E_BUSY                        0xC00D0025L

//
// MessageId: NS_E_UNRECOGNIZED_STREAM_TYPE
//
// MessageText:
//
//  The specified protocol is not recognized. Be sure that the file name and syntax, such as slashes, are correct for the protocol.%0
//
#define NS_E_UNRECOGNIZED_STREAM_TYPE    0xC00D0026L

//
// MessageId: NS_E_NETWORK_SERVICE_FAILURE
//
// MessageText:
//
//  The network service provider failed.%0
//
#define NS_E_NETWORK_SERVICE_FAILURE     0xC00D0027L

//
// MessageId: NS_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
//  An attempt to acquire a network resource failed.%0
//
#define NS_E_NETWORK_RESOURCE_FAILURE    0xC00D0028L

//
// MessageId: NS_E_CONNECTION_FAILURE
//
// MessageText:
//
//  The network connection has failed.%0
//
#define NS_E_CONNECTION_FAILURE          0xC00D0029L

//
// MessageId: NS_E_SHUTDOWN
//
// MessageText:
//
//  The session is being terminated locally.%0
//
#define NS_E_SHUTDOWN                    0xC00D002AL

//
// MessageId: NS_E_INVALID_REQUEST
//
// MessageText:
//
//  The request is invalid in the current state.%0
//
#define NS_E_INVALID_REQUEST             0xC00D002BL

//
// MessageId: NS_E_INSUFFICIENT_BANDWIDTH
//
// MessageText:
//
//  There is insufficient bandwidth available to fulfill the request.%0
//
#define NS_E_INSUFFICIENT_BANDWIDTH      0xC00D002CL

//
// MessageId: NS_E_NOT_REBUILDING
//
// MessageText:
//
//  The disk is not rebuilding.%0
//
#define NS_E_NOT_REBUILDING              0xC00D002DL

//
// MessageId: NS_E_LATE_OPERATION
//
// MessageText:
//
//  An operation requested for a particular time could not be carried out on schedule.%0
//
#define NS_E_LATE_OPERATION              0xC00D002EL

//
// MessageId: NS_E_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_INVALID_DATA                0xC00D002FL

//
// MessageId: NS_E_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The bandwidth required to stream a file is higher than the maximum file bandwidth allowed on the server.%0
//
#define NS_E_FILE_BANDWIDTH_LIMIT        0xC00D0030L

//
// MessageId: NS_E_OPEN_FILE_LIMIT
//
// MessageText:
//
//  The client cannot have any more files open simultaneously.%0
//
#define NS_E_OPEN_FILE_LIMIT             0xC00D0031L

//
// MessageId: NS_E_BAD_CONTROL_DATA
//
// MessageText:
//
//  The server received invalid data from the client on the control connection.%0
//
#define NS_E_BAD_CONTROL_DATA            0xC00D0032L

//
// MessageId: NS_E_NO_STREAM
//
// MessageText:
//
//  There is no stream available.%0
//
#define NS_E_NO_STREAM                   0xC00D0033L

//
// MessageId: NS_E_STREAM_END
//
// MessageText:
//
//  There is no more data in the stream.%0
//
#define NS_E_STREAM_END                  0xC00D0034L

//
// MessageId: NS_E_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified server could not be found.%0
//
#define NS_E_SERVER_NOT_FOUND            0xC00D0035L

//
// MessageId: NS_E_DUPLICATE_NAME
//
// MessageText:
//
//  The specified name is already in use.
//
#define NS_E_DUPLICATE_NAME              0xC00D0036L

//
// MessageId: NS_E_DUPLICATE_ADDRESS
//
// MessageText:
//
//  The specified address is already in use.
//
#define NS_E_DUPLICATE_ADDRESS           0xC00D0037L

//
// MessageId: NS_E_BAD_MULTICAST_ADDRESS
//
// MessageText:
//
//  The specified address is not a valid multicast address.
//
#define NS_E_BAD_MULTICAST_ADDRESS       0xC00D0038L

//
// MessageId: NS_E_BAD_ADAPTER_ADDRESS
//
// MessageText:
//
//  The specified adapter address is invalid.
//
#define NS_E_BAD_ADAPTER_ADDRESS         0xC00D0039L

//
// MessageId: NS_E_BAD_DELIVERY_MODE
//
// MessageText:
//
//  The specified delivery mode is invalid.
//
#define NS_E_BAD_DELIVERY_MODE           0xC00D003AL

//
// MessageId: NS_E_INVALID_CHANNEL
//
// MessageText:
//
//  The specified station does not exist.
//
#define NS_E_INVALID_CHANNEL             0xC00D003BL

//
// MessageId: NS_E_INVALID_STREAM
//
// MessageText:
//
//  The specified stream does not exist.
//
#define NS_E_INVALID_STREAM              0xC00D003CL

//
// MessageId: NS_E_INVALID_ARCHIVE
//
// MessageText:
//
//  The specified archive could not be opened.
//
#define NS_E_INVALID_ARCHIVE             0xC00D003DL

//
// MessageId: NS_E_NOTITLES
//
// MessageText:
//
//  The system cannot find any titles on the server.%0
//
#define NS_E_NOTITLES                    0xC00D003EL

//
// MessageId: NS_E_INVALID_CLIENT
//
// MessageText:
//
//  The system cannot find the client specified.%0
//
#define NS_E_INVALID_CLIENT              0xC00D003FL

//
// MessageId: NS_E_INVALID_BLACKHOLE_ADDRESS
//
// MessageText:
//
//  The Blackhole Address is not initialized.%0
//
#define NS_E_INVALID_BLACKHOLE_ADDRESS   0xC00D0040L

//
// MessageId: NS_E_INCOMPATIBLE_FORMAT
//
// MessageText:
//
//  The station does not support the stream format.
//
#define NS_E_INCOMPATIBLE_FORMAT         0xC00D0041L

//
// MessageId: NS_E_INVALID_KEY
//
// MessageText:
//
//  The specified key is not valid.
//
#define NS_E_INVALID_KEY                 0xC00D0042L

//
// MessageId: NS_E_INVALID_PORT
//
// MessageText:
//
//  The specified port is not valid.
//
#define NS_E_INVALID_PORT                0xC00D0043L

//
// MessageId: NS_E_INVALID_TTL
//
// MessageText:
//
//  The specified TTL is not valid.
//
#define NS_E_INVALID_TTL                 0xC00D0044L

//
// MessageId: NS_E_STRIDE_REFUSED
//
// MessageText:
//
//  The request to fast forward or rewind could not be fulfilled.
//
#define NS_E_STRIDE_REFUSED              0xC00D0045L

//
// IMmsAutoServer Errors
//
//
// MessageId: NS_E_MMSAUTOSERVER_CANTFINDWALKER
//
// MessageText:
//
//  Unable to load the appropriate file parser.%0
//
#define NS_E_MMSAUTOSERVER_CANTFINDWALKER 0xC00D0046L

//
// MessageId: NS_E_MAX_BITRATE
//
// MessageText:
//
//  Cannot exceed the maximum bandwidth limit.%0
//
#define NS_E_MAX_BITRATE                 0xC00D0047L

//
// MessageId: NS_E_LOGFILEPERIOD
//
// MessageText:
//
//  Invalid value for LogFilePeriod.%0
//
#define NS_E_LOGFILEPERIOD               0xC00D0048L

//
// MessageId: NS_E_MAX_CLIENTS
//
// MessageText:
//
//  Cannot exceed the maximum client limit.%0
//  
//
#define NS_E_MAX_CLIENTS                 0xC00D0049L

//
// MessageId: NS_E_LOG_FILE_SIZE
//
// MessageText:
//
//  Log File Size too small.%0
//  
//
#define NS_E_LOG_FILE_SIZE               0xC00D004AL

//
// MessageId: NS_E_MAX_FILERATE
//
// MessageText:
//
//  Cannot exceed the maximum file rate.%0
//
#define NS_E_MAX_FILERATE                0xC00D004BL

//
// File Walker Errors
//
//
// MessageId: NS_E_WALKER_UNKNOWN
//
// MessageText:
//
//  Unknown file type.%0
//
#define NS_E_WALKER_UNKNOWN              0xC00D004CL

//
// MessageId: NS_E_WALKER_SERVER
//
// MessageText:
//
//  The specified file, %1, cannot be loaded onto the specified server, %2.%0
//
#define NS_E_WALKER_SERVER               0xC00D004DL

//
// MessageId: NS_E_WALKER_USAGE
//
// MessageText:
//
//  There was a usage error with file parser.%0
//
#define NS_E_WALKER_USAGE                0xC00D004EL


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
/////////////////////////////////////////////////////////////////////////


 // Tiger Events

 // %1 is the tiger name

//
// MessageId: NS_I_TIGER_START
//
// MessageText:
//
//  The Title Server %1 is running.%0
//
#define NS_I_TIGER_START                 0x400D004FL

//
// MessageId: NS_E_TIGER_FAIL
//
// MessageText:
//
//  The Title Server %1 has failed.%0
//
#define NS_E_TIGER_FAIL                  0xC00D0050L


 // Cub Events

 // %1 is the cub ID
 // %2 is the cub name

//
// MessageId: NS_I_CUB_START
//
// MessageText:
//
//  Content Server %1 (%2) is starting.%0
//
#define NS_I_CUB_START                   0x400D0051L

//
// MessageId: NS_I_CUB_RUNNING
//
// MessageText:
//
//  Content Server %1 (%2) is running.%0
//
#define NS_I_CUB_RUNNING                 0x400D0052L

//
// MessageId: NS_E_CUB_FAIL
//
// MessageText:
//
//  Content Server %1 (%2) has failed.%0
//
#define NS_E_CUB_FAIL                    0xC00D0053L


 // Disk Events

 // %1 is the tiger disk ID
 // %2 is the device name
 // %3 is the cub ID
//
// MessageId: NS_I_DISK_START
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, is running.%0
//
#define NS_I_DISK_START                  0x400D0054L

//
// MessageId: NS_E_DISK_FAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has failed.%0
//
#define NS_E_DISK_FAIL                   0xC00D0055L

//
// MessageId: NS_I_DISK_REBUILD_STARTED
//
// MessageText:
//
//  Started rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_STARTED        0x400D0056L

//
// MessageId: NS_I_DISK_REBUILD_FINISHED
//
// MessageText:
//
//  Finished rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_FINISHED       0x400D0057L

//
// MessageId: NS_I_DISK_REBUILD_ABORTED
//
// MessageText:
//
//  Aborted rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_ABORTED        0x400D0058L


 // Admin Events

//
// MessageId: NS_I_LIMIT_FUNNELS
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the data stream limit to %2 streams.%0
//
#define NS_I_LIMIT_FUNNELS               0x400D0059L

//
// MessageId: NS_I_START_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started disk %2.%0
//
#define NS_I_START_DISK                  0x400D005AL

//
// MessageId: NS_I_STOP_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped disk %2.%0
//
#define NS_I_STOP_DISK                   0x400D005BL

//
// MessageId: NS_I_STOP_CUB
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped Content Server %2.%0
//
#define NS_I_STOP_CUB                    0x400D005CL

//
// MessageId: NS_I_KILL_USERSESSION
//
// MessageText:
//
//  A NetShow administrator at network location %1 aborted user session %2 from the system.%0
//
#define NS_I_KILL_USERSESSION            0x400D005DL

//
// MessageId: NS_I_KILL_CONNECTION
//
// MessageText:
//
//  A NetShow administrator at network location %1 aborted obsolete connection %2 from the system.%0
//
#define NS_I_KILL_CONNECTION             0x400D005EL

//
// MessageId: NS_I_REBUILD_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started rebuilding disk %2.%0
//
#define NS_I_REBUILD_DISK                0x400D005FL

//
// MessageId: NS_W_UNKNOWN_EVENT
//
// MessageText:
//
//  Unknown %1 event encountered.%0
//
#define NS_W_UNKNOWN_EVENT               0x800D0060L


 // Alerts

//
// MessageId: NS_E_MAX_FUNNELS_ALERT
//
// MessageText:
//
//  The NetShow data stream limit of %1 streams was reached.%0
//
#define NS_E_MAX_FUNNELS_ALERT           0xC00D0060L

//
// MessageId: NS_E_ALLOCATE_FILE_FAIL
//
// MessageText:
//
//  The NetShow Video Server was unable to allocate a %1 block file named %2.%0
//
#define NS_E_ALLOCATE_FILE_FAIL          0xC00D0061L

//
// MessageId: NS_E_PAGING_ERROR
//
// MessageText:
//
//  A Content Server was unable to page a block.%0
//
#define NS_E_PAGING_ERROR                0xC00D0062L

//
// MessageId: NS_E_BAD_BLOCK0_VERSION
//
// MessageText:
//
//  Disk %1 has unrecognized control block version %2.%0
//
#define NS_E_BAD_BLOCK0_VERSION          0xC00D0063L

//
// MessageId: NS_E_BAD_DISK_UID
//
// MessageText:
//
//  Disk %1 has incorrect uid %2.%0
//
#define NS_E_BAD_DISK_UID                0xC00D0064L

//
// MessageId: NS_E_BAD_FSMAJOR_VERSION
//
// MessageText:
//
//  Disk %1 has unsupported file system major version %2.%0
//
#define NS_E_BAD_FSMAJOR_VERSION         0xC00D0065L

//
// MessageId: NS_E_BAD_STAMPNUMBER
//
// MessageText:
//
//  Disk %1 has bad stamp number in control block.%0
//
#define NS_E_BAD_STAMPNUMBER             0xC00D0066L

//
// MessageId: NS_E_PARTIALLY_REBUILT_DISK
//
// MessageText:
//
//  Disk %1 is partially reconstructed.%0
//
#define NS_E_PARTIALLY_REBUILT_DISK      0xC00D0067L

//
// MessageId: NS_E_ENACTPLAN_GIVEUP
//
// MessageText:
//
//  EnactPlan gives up.%0
//
#define NS_E_ENACTPLAN_GIVEUP            0xC00D0068L


 // MCMADM warnings/errors

//
// MessageId: MCMADM_I_NO_EVENTS
//
// MessageText:
//
//  Event initialization failed, there will be no MCM events.%0
//
#define MCMADM_I_NO_EVENTS               0x400D0069L

//
// MessageId: MCMADM_E_REGKEY_NOT_FOUND
//
// MessageText:
//
//  The key was not found in the registry.%0
//
#define MCMADM_E_REGKEY_NOT_FOUND        0xC00D006AL

//
// MessageId: NS_E_NO_FORMATS
//
// MessageText:
//
//  No stream format information was found.%0
//
#define NS_E_NO_FORMATS                  0xC00D006BL

//
// MessageId: NS_E_NO_REFERENCES
//
// MessageText:
//
//  No reference URLs were found in an ASX file.%0
//
#define NS_E_NO_REFERENCES               0xC00D006CL

//
// MessageId: NS_E_WAVE_OPEN
//
// MessageText:
//
//  Error opening wave device, the device might be in use.%0
//
#define NS_E_WAVE_OPEN                   0xC00D006DL

//
// MessageId: NS_I_LOGGING_FAILED
//
// MessageText:
//
//  The logging operation failed.
//
#define NS_I_LOGGING_FAILED              0x400D006EL

//
// MessageId: NS_E_CANNOTCONNECTEVENTS
//
// MessageText:
//
//  Unable to establish a connection to the NetShow event monitor service.%0
//
#define NS_E_CANNOTCONNECTEVENTS         0xC00D006FL

//
// MessageId: NS_I_LIMIT_BANDWIDTH
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the maximum bandwidth limit to %2 bps.%0
//
#define NS_I_LIMIT_BANDWIDTH             0x400D0070L

//
// MessageId: NS_E_NO_DEVICE
//
// MessageText:
//
//  No device driver is present on the system.%0
//
#define NS_E_NO_DEVICE                   0xC00D0071L

//
// MessageId: NS_E_NO_SPECIFIED_DEVICE
//
// MessageText:
//
//  No specified device driver is present.%0
//
#define NS_E_NO_SPECIFIED_DEVICE         0xC00D0072L


// NOTENOTE!!!
//
// Due to legacy problems these error codes live inside the ASF error code range
//
//
// MessageId: NS_E_NOTHING_TO_DO
//
// MessageText:
//
//  NS_E_NOTHING_TO_DO
//
#define NS_E_NOTHING_TO_DO               0xC00D07F1L

//
// MessageId: NS_E_NO_MULTICAST
//
// MessageText:
//
//  Not receiving data from the server.%0
//
#define NS_E_NO_MULTICAST                0xC00D07F2L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
// IdRange = 200..399
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_MONITOR_GIVEUP
//
// MessageText:
//
//  Netshow Events Monitor is not operational and has been disconnected.%0
//
#define NS_E_MONITOR_GIVEUP              0xC00D00C8L

//
// MessageId: NS_E_REMIRRORED_DISK
//
// MessageText:
//
//  Disk %1 is remirrored.%0
//
#define NS_E_REMIRRORED_DISK             0xC00D00C9L

//
// MessageId: NS_E_INSUFFICIENT_DATA
//
// MessageText:
//
//  Insufficient data found.%0
//
#define NS_E_INSUFFICIENT_DATA           0xC00D00CAL

//
// MessageId: NS_E_ASSERT
//
// MessageText:
//
//  %1 failed in file %2 line %3.%0
//
#define NS_E_ASSERT                      0xC00D00CBL

//
// MessageId: NS_E_BAD_ADAPTER_NAME
//
// MessageText:
//
//  The specified adapter name is invalid.%0
//
#define NS_E_BAD_ADAPTER_NAME            0xC00D00CCL

//
// MessageId: NS_E_NOT_LICENSED
//
// MessageText:
//
//  The application is not licensed for this feature.%0
//
#define NS_E_NOT_LICENSED                0xC00D00CDL

//
// MessageId: NS_E_NO_SERVER_CONTACT
//
// MessageText:
//
//  Unable to contact the server.%0
//
#define NS_E_NO_SERVER_CONTACT           0xC00D00CEL

//
// MessageId: NS_E_TOO_MANY_TITLES
//
// MessageText:
//
//  Maximum number of titles exceeded.%0
//
#define NS_E_TOO_MANY_TITLES             0xC00D00CFL

//
// MessageId: NS_E_TITLE_SIZE_EXCEEDED
//
// MessageText:
//
//  Maximum size of a title exceeded.%0
//
#define NS_E_TITLE_SIZE_EXCEEDED         0xC00D00D0L

//
// MessageId: NS_E_UDP_DISABLED
//
// MessageText:
//
//  UDP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_UDP_DISABLED                0xC00D00D1L

//
// MessageId: NS_E_TCP_DISABLED
//
// MessageText:
//
//  TCP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_TCP_DISABLED                0xC00D00D2L

//
// MessageId: NS_E_HTTP_DISABLED
//
// MessageText:
//
//  HTTP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_HTTP_DISABLED               0xC00D00D3L

//
// MessageId: NS_E_LICENSE_EXPIRED
//
// MessageText:
//
//  The product license has expired.%0
//
#define NS_E_LICENSE_EXPIRED             0xC00D00D4L

//
// MessageId: NS_E_TITLE_BITRATE
//
// MessageText:
//
//  Source file exceeds the per title maximum bitrate. See NetShow Theater documentation for more information.%0
//
#define NS_E_TITLE_BITRATE               0xC00D00D5L

//
// MessageId: NS_E_EMPTY_PROGRAM_NAME
//
// MessageText:
//
//  The program name cannot be empty.%0
//
#define NS_E_EMPTY_PROGRAM_NAME          0xC00D00D6L

//
// MessageId: NS_E_MISSING_CHANNEL
//
// MessageText:
//
//  Station %1 does not exist.%0
//
#define NS_E_MISSING_CHANNEL             0xC00D00D7L

//
// MessageId: NS_E_NO_CHANNELS
//
// MessageText:
//
//  You need to define at least one station before this operation can complete.%0
//
#define NS_E_NO_CHANNELS                 0xC00D00D8L


/////////////////////////////////////////////////////////////////////
// This error message is to replace previous NS_E_INVALID_INDEX which 
// takes an index value for the error message string.  For some application
// obtain the idex value at reporting error time is very difficult, so we
// use this string to avoid the problem.
//////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INDEX2
//
// MessageText:
//
//  The index specified is invalid.%0
//
#define NS_E_INVALID_INDEX2              0xC00D00D9L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
// IdRange = 400..599
//
// Admin Events:
//
// Alerts:
//
// Title Server:
//      %1 is the Title Server name
//
// Content Server:
//      %1 is the Content Server ID
//      %2 is the Content Server name
//      %3 is the Peer Content Server name (optional)
//
// Disks:
//      %1 is the Title Server disk ID
//      %2 is the device name
//      %3 is the Content Server ID
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_CUB_FAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has failed its link to Content Server %3.%0
//
#define NS_E_CUB_FAIL_LINK               0xC00D0190L

//
// MessageId: NS_I_CUB_UNFAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has established its link to Content Server %3.%0
//
#define NS_I_CUB_UNFAIL_LINK             0x400D0191L

//
// MessageId: NS_E_BAD_CUB_UID
//
// MessageText:
//
//  Content Server %1 (%2) has incorrect uid %3.%0
//
#define NS_E_BAD_CUB_UID                 0xC00D0192L

//
// MessageId: NS_I_RESTRIPE_START
//
// MessageText:
//
//  Restripe operation has started.%0
//
#define NS_I_RESTRIPE_START              0x400D0193L

//
// MessageId: NS_I_RESTRIPE_DONE
//
// MessageText:
//
//  Restripe operation has completed.%0
//
#define NS_I_RESTRIPE_DONE               0x400D0194L

//
// MessageId: NS_E_GLITCH_MODE
//
// MessageText:
//
//  Server unreliable because multiple components failed.%0
//
#define NS_E_GLITCH_MODE                 0xC00D0195L

//
// MessageId: NS_I_RESTRIPE_DISK_OUT
//
// MessageText:
//
//  Content disk %1 (%2) on Content Server %3 has been restriped out.%0
//
#define NS_I_RESTRIPE_DISK_OUT           0x400D0196L

//
// MessageId: NS_I_RESTRIPE_CUB_OUT
//
// MessageText:
//
//  Content server %1 (%2) has been restriped out.%0
//
#define NS_I_RESTRIPE_CUB_OUT            0x400D0197L

//
// MessageId: NS_I_DISK_STOP
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has been offlined.%0
//
#define NS_I_DISK_STOP                   0x400D0198L

//
// MessageId: NS_I_CATATONIC_FAILURE
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, will be failed because it is catatonic.%0
//
#define NS_I_CATATONIC_FAILURE           0x800D0199L

//
// MessageId: NS_I_CATATONIC_AUTO_UNFAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, auto online from catatonic state.%0
//
#define NS_I_CATATONIC_AUTO_UNFAIL       0x800D019AL

//
// MessageId: NS_E_NO_MEDIA_PROTOCOL
//
// MessageText:
//
//  Content Server %1 (%2) is unable to communicate with the Media System Network Protocol.%0
//
#define NS_E_NO_MEDIA_PROTOCOL           0xC00D019BL


//
// Advanced Streaming Format (ASF) codes occupy MessageIds 2000-2999
//
// See ASFErr.mc for more details - please do not define any symbols
// in that range in this file.
//


/////////////////////////////////////////////////////////////////////////
//
// Windows Media SDK Errors
//
// IdRange = 3000-3199
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INPUT_FORMAT
//
// MessageText:
//
//  The input media format is invalid.%0
//
#define NS_E_INVALID_INPUT_FORMAT        0xC00D0BB8L

//
// MessageId: NS_E_MSAUDIO_NOT_INSTALLED
//
// MessageText:
//
//  The MSAudio codec is not installed on this system.%0
//
#define NS_E_MSAUDIO_NOT_INSTALLED       0xC00D0BB9L

//
// MessageId: NS_E_UNEXPECTED_MSAUDIO_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the MSAudio codec.%0
//
#define NS_E_UNEXPECTED_MSAUDIO_ERROR    0xC00D0BBAL

//
// MessageId: NS_E_INVALID_OUTPUT_FORMAT
//
// MessageText:
//
//  The output media format is invalid.%0
//
#define NS_E_INVALID_OUTPUT_FORMAT       0xC00D0BBBL

//
// MessageId: NS_E_NOT_CONFIGURED
//
// MessageText:
//
//  The object must be fully configured before audio samples can be processed.%0
//
#define NS_E_NOT_CONFIGURED              0xC00D0BBCL

//
// MessageId: NS_E_PROTECTED_CONTENT
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_PROTECTED_CONTENT           0xC00D0BBDL

//
// MessageId: NS_E_LICENSE_REQUIRED
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_LICENSE_REQUIRED            0xC00D0BBEL

//
// MessageId: NS_E_TAMPERED_CONTENT
//
// MessageText:
//
//  This media file is corrupted or invalid. Contact the content provider for a new file.%0
//
#define NS_E_TAMPERED_CONTENT            0xC00D0BBFL

//
// MessageId: NS_E_LICENSE_OUTOFDATE
//
// MessageText:
//
//  The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_OUTOFDATE           0xC00D0BC0L

//
// MessageId: NS_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
//  You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_INCORRECT_RIGHTS    0xC00D0BC1L

//
// MessageId: NS_E_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested audio codec is not installed on this system.%0
//
#define NS_E_AUDIO_CODEC_NOT_INSTALLED   0xC00D0BC2L

//
// MessageId: NS_E_AUDIO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the audio codec.%0
//
#define NS_E_AUDIO_CODEC_ERROR           0xC00D0BC3L

//
// MessageId: NS_E_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested video codec is not installed on this system.%0
//
#define NS_E_VIDEO_CODEC_NOT_INSTALLED   0xC00D0BC4L

//
// MessageId: NS_E_VIDEO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the video codec.%0
//
#define NS_E_VIDEO_CODEC_ERROR           0xC00D0BC5L

//
// MessageId: NS_E_INVALIDPROFILE
//
// MessageText:
//
//  The Profile is invalid.%0
//
#define NS_E_INVALIDPROFILE              0xC00D0BC6L

//
// MessageId: NS_E_I